[
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payload.rs",
    "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{HmacSha256, VerifySignature},\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, PaymentsVoidType, Response, SetupMandateType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as payload;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Payload {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Payload {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Payload {}\nimpl api::PaymentSession for Payload {}\nimpl api::ConnectorAccessToken for Payload {}\nimpl api::MandateSetup for Payload {}\nimpl api::PaymentAuthorize for Payload {}\nimpl api::PaymentSync for Payload {}\nimpl api::PaymentCapture for Payload {}\nimpl api::PaymentVoid for Payload {}\nimpl api::Refund for Payload {}\nimpl api::RefundExecute for Payload {}\nimpl api::RefundSync for Payload {}\nimpl api::PaymentToken for Payload {}\nimpl api::ConnectorCustomer for Payload {}\n\nimpl ConnectorIntegration<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>\n    for Payload\n{\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            \"application/json\".to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/customers\", self.base_url(connectors),))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = requests::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payload.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__square__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, Card, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::{refunds::Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{self, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\nimpl TryFrom<(&types::TokenizationRouterData, BankDebitData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, BankDebitData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, bank_debit_data) = value;\n        match bank_debit_data {\n            BankDebitData::AchBankDebit { .. }\n            | BankDebitData::SepaBankDebit { .. }\n            | BankDebitData::BecsBankDebit { .. }\n            | BankDebitData::BacsBankDebit { .. }\n            | BankDebitData::SepaGuarenteedBankDebit { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, Card)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, Card)) -> Result<Self, Self::Error> {\n        let (item, card_data) = value;\n        let auth = SquareAuthType::try_from(&item.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let exp_year = Secret::new(\n            card_data\n                .get_expiry_year_4_digit()\n                .peek()\n                .parse::<u16>()\n                .change_context(errors::ConnectorError::DateFormattingFailed)?,\n        );\n        let exp_month = Secret::new(\n            card_data\n                .card_exp_month\n                .peek()\n                .parse::<u16>()\n                .change_context(errors::ConnectorError::DateFormattingFailed)?,\n        );\n        //The below error will never happen because if session-id is not generated it would give error in execute_pretasks itself.\n        let session_id = Secret::new(\n            item.session_token\n                .clone()\n                .ok_or(errors::ConnectorError::RequestEncodingFailed)?,\n        );\n        Ok(Self::Card(SquareTokenizeData {\n            client_id: auth.key1,\n            session_id,\n            card_data: SquareCardData {\n                exp_year,\n                exp_month,\n                number: card_data.card_number,\n                cvv: card_data.card_cvc,\n            },\n        }))\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, PayLaterData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, PayLaterData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, pay_later_data) = value;\n        match pay_later_data {\n            PayLaterData::AfterpayClearpayRedirect { .. }\n            | PayLaterData::KlarnaRedirect { .. }\n            | PayLaterData::KlarnaSdk { .. }\n            | PayLaterData::AffirmRedirect { .. }\n            | PayLaterData::PayBrightRedirect { .. }\n            | PayLaterData::WalleyRedirect { .. }\n            | PayLaterData::AlmaRedirect { .. }\n            | PayLaterData::FlexitiRedirect { .. }\n            | PayLaterData::AtomeRedirect { .. }\n            | PayLaterData::BreadpayRedirect { .. }\n            | PayLaterData::PayjustnowRedirect { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, WalletData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, WalletData)) -> Result<Self, Self::Error> {\n        let (_item, wallet_data) = value;\n        match wallet_data {\n            WalletData::AmazonPay(_)\n            | WalletData::ApplePay(_)\n            | WalletData::GooglePay(_)\n            | WalletData::BluecodeRedirect {}\n            | WalletData::AliPayQr(_)\n            | WalletData::AliPayRedirect(_)\n            | WalletData::AliPayHkRedirect(_)\n            | WalletData::AmazonPayRedirect(_)\n            | WalletData::Paysera(_)\n            | WalletData::Skrill(_)\n            | WalletData::MomoRedirect(_)\n            | WalletData::KakaoPayRedirect(_)\n            | WalletData::GoPayRedirect(_)\n            | WalletData::GcashRedirect(_)\n            | WalletData::ApplePayRedirect(_)\n            | WalletData::ApplePayThirdPartySdk(_)\n            | WalletData::DanaRedirect {}\n            | WalletData::GooglePayRedirect(_)\n            | WalletData::GooglePayThirdPartySdk(_)\n            | WalletData::MbWayRedirect(_)\n            | WalletData::MobilePayRedirect(_)\n            | WalletData::PaypalRedirect(_)\n            | WalletData::PaypalSdk(_)\n            | WalletData::Paze(_)\n            | WalletData::SamsungPay(_)\n            | WalletData::TwintRedirect {}\n            | WalletData::VippsRedirect {}\n            | WalletData::TouchNGoRedirect(_)\n            | WalletData::WeChatPayRedirect(_)",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{BytesExt, StringExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RedirectForm,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSessionRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as bluesnap;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        construct_not_supported_error_report, convert_amount, convert_back_amount_to_minor_units,\n        get_error_code_error_message_based_on_priority, get_header_key_value, get_http_header,\n        handle_json_response_deserialization_failure, to_connector_meta_from_secret,\n        ConnectorErrorType, ConnectorErrorTypeMapping, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub const BLUESNAP_TRANSACTION_NOT_FOUND: &str = \"is not authorized to view merchant-transaction:\";\n\npub const REQUEST_TIMEOUT_PAYMENT_NOT_FOUND: &str = \"Timed out ,payment not found\";\n\n#[derive(Clone)]\npub struct Bluesnap {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n    amount_converter_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bluesnap {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor_unit: &StringMinorUnitForConnector,\n            amount_converter_float_major_unit: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bluesnap\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = self.get_auth_header(&req.connector_auth_type)?;\n        header.push((\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        ));\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bluesnap {\n    fn id(&self) -> &'static str {\n        \"bluesnap\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bluesnap.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bluesnap::BluesnapAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key =\n            BASE64_ENGINE.encode(format!(\"{}:{}\", auth.key1.peek(), auth.api_key.peek()));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),\n        )])",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payme__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::enums::{AuthenticationType, PaymentMethod};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    pii,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::{Execute, Void},\n    router_request_types::{\n        CreateOrderRequestData, PaymentsCancelData, PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, PreprocessingResponseId, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsCancelResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSyncRequestData, RouterData as OtherRouterData,\n    },\n};\n\nconst LANGUAGE: &str = \"en\";\n\n#[derive(Debug, Serialize)]\npub struct PaymeRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PaymeRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PaymePaymentRequest {\n    MandateRequest(MandateRequest),\n    PayRequest(PayRequest),\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeQuerySaleRequest {\n    sale_payme_id: String,\n    seller_payme_id: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeQueryTransactionRequest {\n    payme_transaction_id: String,\n    seller_payme_id: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeCard {\n    credit_card_cvv: Secret<String>,\n    credit_card_exp: Secret<String>,\n    credit_card_number: cards::CardNumber,\n}\n\n#[derive(Debug, Serialize)]\npub struct CaptureBuyerRequest {\n    seller_payme_id: Secret<String>,\n    #[serde(flatten)]\n    card: PaymeCard,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct CaptureBuyerResponse {\n    buyer_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__trustpay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsPreProcessingType, PaymentsSyncType,\n        RefreshTokenType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as trustpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, self as connector_utils, ConnectorErrorType, PaymentsPreProcessingRequestData},\n};\n\n#[derive(Clone)]\npub struct Trustpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n    amount_converter_to_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Trustpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_float_major_unit: &FloatMajorUnitForConnector,\n            amount_converter_to_string_minor_unit: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Trustpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        match req.payment_method {\n            enums::PaymentMethod::BankRedirect | enums::PaymentMethod::BankTransfer => {\n                let token = req\n                    .access_token\n                    .clone()\n                    .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n                Ok(vec![\n                    (\n                        headers::CONTENT_TYPE.to_string(),\n                        \"application/json\".to_owned().into(),\n                    ),\n                    (\n                        headers::AUTHORIZATION.to_string(),\n                        format!(\"Bearer {}\", token.token.peek()).into_masked(),\n                    ),\n                ])\n            }\n            _ => {\n                let mut header = vec![(\n                    headers::CONTENT_TYPE.to_string(),\n                    self.get_content_type().to_string().into(),\n                )];\n                let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n                header.append(&mut api_key);\n                Ok(header)\n            }\n        }\n    }\n}\n\nimpl ConnectorCommon for Trustpay {\n    fn id(&self) -> &'static str {\n        \"trustpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.trustpay.base_url.as_ref()\n    }\n\n    fn get_auth_header(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__trustpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n    ForeignIDRef,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    mandates::{MandateDataType, MandateDetails},\n    router_request_types,\n};\n\n#[async_trait::async_trait]\npub trait PaymentAttemptInterface {\n    type Error;\n    #[cfg(feature = \"v1\")]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn insert_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn update_payment_attempt_with_attempt_id(\n        &self,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn update_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_by_connector_transaction_id_payment_id_processor_merchant_id(\n        &self,\n        connector_transaction_id: &ConnectorTransactionId,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_id: &id_type::GlobalPaymentId,\n        storage_scheme: storage_enums::MerchantStorageScheme,",
    "function_name": "insert_payment_attempt",
    "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use api_models::payments::{QrCodeInformation, VoucherNextStepData};\nuse common_enums::{\n    enums, AttemptStatus, BoletoDocumentKind, BoletoPaymentType, ExpiryType, PixKey,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, ValueExt},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse crc::{Algorithm, Crc};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankTransferData, BoletoVoucherData, PaymentMethodData, VoucherData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{PaymentsUpdateMetadataData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        PaymentsUpdateMetadataRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::{self},\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            Environment, SantanderAuthRequest, SantanderAuthType, SantanderBoletoCancelOperation,\n            SantanderBoletoCancelRequest, SantanderBoletoPaymentRequest,\n            SantanderBoletoUpdateRequest, SantanderDebtor, SantanderGrantType,\n            SantanderMetadataObject, SantanderPaymentRequest, SantanderPaymentsCancelRequest,\n            SantanderPixCancelRequest, SantanderPixDueDateCalendarRequest,\n            SantanderPixImmediateCalendarRequest, SantanderPixQRPaymentRequest,\n            SantanderPixRequestCalendar, SantanderRefundRequest, SantanderRouterData,\n            SantanderValue,\n        },\n        responses::{\n            Key, NsuComposite, Payer, SanatanderAccessTokenResponse, SanatanderTokenResponse,\n            SantanderAdditionalInfo, SantanderBoletoDocumentKind, SantanderBoletoPaymentType,\n            SantanderBoletoStatus, SantanderDocumentKind, SantanderPaymentStatus,\n            SantanderPaymentsResponse, SantanderPaymentsSyncResponse, SantanderPixKeyType,\n            SantanderPixQRCodePaymentsResponse, SantanderPixQRCodeSyncResponse,\n            SantanderRefundResponse, SantanderRefundStatus, SantanderUpdateMetadataResponse,\n            SantanderVoidResponse, SantanderVoidStatus,\n        },\n    },\n    types::{RefreshTokenRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self as connector_utils, QrImage, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nimpl<T> From<(StringMajorUnit, T)> for SantanderRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nimpl TryFrom<&Option<common_utils::pii::SecretSerdeValue>> for SantanderMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        meta_data: &Option<common_utils::pii::SecretSerdeValue>,\n    ) -> Result<Self, Self::Error> {\n        let metadata = connector_utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nimpl TryFrom<&PaymentsUpdateMetadataRouterData> for SantanderBoletoUpdateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsUpdateMetadataRouterData) -> Result<Self, Self::Error> {\n        let santander_mca_metadata = SantanderMetadataObject::try_from(&item.connector_meta_data)?;\n\n        let boleto_mca_metadata = santander_mca_metadata\n            .boleto\n            .ok_or(errors::ConnectorError::NoConnectorMetaData)?;\n\n        let boleto_components = extract_boleto_components(&item.request.connector_transaction_id)?;\n\n        let due_date = Some(format_as_date_only(\n            item.request\n                .feature_metadata\n                .clone()\n                .and_then(|data| data.boleto_additional_details)\n                .and_then(|boleto_details| boleto_details.due_date),\n        )?);\n\n        Ok(Self {\n            covenant_code: boleto_mca_metadata.covenant_code,\n            bank_number: boleto_components.bank_number,\n            due_date,\n        })\n    }\n}\n\npub fn format_emv_field(id: &str, value: &str) -> String {\n    format!(\"{id}{:02}{value}\", value.len())\n}\n\nfn format_field(id: &str, value: &str) -> String {\n    format!(\"{}{:02}{}\", id, value.len(), value)\n}\n\npub fn generate_emv_string(\n    cidade: &str,\n    amount: &str,\n    country: enums::CountryAlpha2,\n    merchant_name: &str,\n    transaction_id: String,\n    location: String,\n) -> Result<String, errors::ConnectorError> {\n    // ID 00: Payload Format Indicator\n    let payload_format_indicator = format_field(\"00\", \"01\");\n\n    // ID 01: Point of Initiation Method\n    let point_of_initiation_method = format_field(\"01\", \"12\");\n\n    // ID 26: Merchant Account Information\n    let gui = format_field(\"00\", \"br.gov.bcb.pix\");\n    let loc = format_field(\"25\", &location);\n    let merchant_account_information = format_field(\"26\", &format!(\"{}{}\", gui, loc));\n\n    // ID 52: Merchant Category Code\n    let merchant_category_code = format_field(\"52\", \"0000\");\n\n    // ID 53: Transaction Currency\n    let transaction_currency = format_field(\"53\", \"986\");\n",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments;\nuse cards::CardNumber;\nuse common_enums::{enums, BankNames, CaptureMethod, Currency};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::Encode,\n    pii::Email,\n    request::Method,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, CardDetailsForNetworkTransactionId, GooglePayWalletData,\n        PaymentMethodData, RealTimePaymentData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse url::Url;\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{self, PaymentsAuthorizeRequestData, QrImage, RefundsRequestData, RouterData as _},\n};\n\npub struct FiuuRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for FiuuRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\npub struct FiuuAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) verify_key: Secret<String>,\n    pub(super) secret_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for FiuuAuthType {\n    type Error = Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                merchant_id: key1.to_owned(),\n                verify_key: api_key.to_owned(),\n                secret_key: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum TxnType {\n    Sals,\n    Auts,\n}\n\nimpl TryFrom<Option<CaptureMethod>> for TxnType {\n    type Error = Report<errors::ConnectorError>;\n    fn try_from(capture_method: Option<CaptureMethod>) -> Result<Self, Self::Error> {\n        match capture_method {\n            Some(CaptureMethod::Automatic) | Some(CaptureMethod::SequentialAutomatic) | None => {\n                Ok(Self::Sals)\n            }\n            Some(CaptureMethod::Manual) => Ok(Self::Auts),\n            _ => Err(errors::ConnectorError::CaptureMethodNotSupported.into()),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Display, Debug, Clone)]\nenum TxnChannel {\n    #[serde(rename = \"CREDITAN\")]\n    #[strum(serialize = \"CREDITAN\")]\n    Creditan,\n    #[serde(rename = \"RPP_DUITNOWQR\")]\n    #[strum(serialize = \"RPP_DUITNOWQR\")]\n    RppDuitNowQr,\n}\n\n#[derive(Serialize, Deserialize, Display, Debug, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum FPXTxnChannel {\n    FpxAbb,\n    FpxUob,\n    FpxAbmb,\n    FpxScb,\n    FpxBsn,\n    FpxKfh,\n    FpxBmmb,\n    FpxBkrm,\n    FpxHsbc,\n    FpxAgrobank,\n    FpxBocm,\n    FpxMb2u,\n    FpxCimbclicks,\n    FpxAmb,\n    FpxHlb,\n    FpxPbb,\n    FpxRhb,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__merchant_connector_account.rs",
    "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\nuse common_utils::{\n    crypto::Encryptable,\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{StringExt, ValueExt},\n    id_type, pii, type_name,\n    types::keymanager::{Identifier, KeyManagerState, ToEncryptable},\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::merchant_connector_account::{\n    BillingAccountReference as DieselBillingAccountReference,\n    MerchantConnectorAccountFeatureMetadata as DieselMerchantConnectorAccountFeatureMetadata,\n    RevenueRecoveryMetadata as DieselRevenueRecoveryMetadata,\n};\nuse diesel_models::{\n    enums,\n    merchant_connector_account::{self as storage, MerchantConnectorAccountUpdateInternal},\n};\nuse error_stack::ResultExt;\nuse masking::{PeekInterface, Secret};\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\n\nuse super::behaviour;\n#[cfg(feature = \"v2\")]\nuse crate::errors::api_error_response;\nuse crate::{\n    mandates::CommonMandateReference,\n    merchant_key_store::MerchantKeyStore,\n    router_data,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]\nimpl MerchantConnectorAccount {\n    pub fn get_id(&self) -> id_type::MerchantConnectorAccountId {\n        self.merchant_connector_id.clone()\n    }\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n\n    pub fn get_connector_wallets_details(&self) -> Option<Secret<Value>> {\n        self.connector_wallets_details.as_deref().cloned()\n    }\n\n    pub fn get_connector_test_mode(&self) -> Option<bool> {\n        self.test_mode\n    }\n\n    pub fn get_connector_name_as_string(&self) -> String {\n        self.connector_name.clone()\n    }\n\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        self.metadata.clone()\n    }\n\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n\n    pub fn should_construct_webhook_setup_capability(&self) -> bool {\n        matches!(self.connector_type, enums::ConnectorType::PaymentProcessor)\n    }\n\n    pub fn get_connector_webhook_registration_details(&self) -> Option<Value> {\n        self.connector_webhook_registration_details.clone()\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug)]\npub enum MerchantConnectorAccountTypeDetails {\n    MerchantConnectorAccount(Box<MerchantConnectorAccount>),\n    MerchantConnectorDetails(common_types::domain::MerchantConnectorAuthDetails),\n}\n\n#[cfg(feature = \"v2\")]\nimpl MerchantConnectorAccountTypeDetails {\n    pub fn get_connector_account_details(",
    "function_name": "get_id",
    "file": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Flexiti {}\nimpl api::PaymentSession for Flexiti {}\nimpl api::ConnectorAccessToken for Flexiti {}\nimpl api::MandateSetup for Flexiti {}\nimpl api::PaymentAuthorize for Flexiti {}\nimpl api::PaymentSync for Flexiti {}\nimpl api::PaymentCapture for Flexiti {}\nimpl api::PaymentVoid for Flexiti {}\nimpl api::Refund for Flexiti {}\nimpl api::RefundExecute for Flexiti {}\nimpl api::RefundSync for Flexiti {}\nimpl api::PaymentToken for Flexiti {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Flexiti\n{\n    // Not Implemented (R)\n}\n\nimpl Flexiti {\n    fn get_default_header() -> (String, masking::Maskable<String>) {\n        (\n            \"x-reference-id\".to_string(),\n            Uuid::new_v4().to_string().into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Flexiti\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let mut header = vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into(),\n        )];\n        header.push(Self::get_default_header());\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Flexiti {\n    fn id(&self) -> &'static str {\n        \"flexiti\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.flexiti.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__stripebilling.rs",
    "code": "pub mod transformers;\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::revenue_recovery;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::types as recovery_router_data_types;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery as recovery_router_flows, subscriptions as subscription_flow_types,\n    },\n    router_request_types::{\n        revenue_recovery as recovery_request_types, subscriptions as subscription_request_types,\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery as recovery_response_types, subscriptions as subscription_response_types,\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, subscriptions as subscriptions_api, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse stripebilling::auth_headers;\nuse transformers as stripebilling;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Stripebilling {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Stripebilling {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Stripebilling {}\nimpl api::PaymentSession for Stripebilling {}\nimpl api::ConnectorAccessToken for Stripebilling {}\nimpl api::MandateSetup for Stripebilling {}\nimpl api::PaymentAuthorize for Stripebilling {}\nimpl api::PaymentSync for Stripebilling {}\nimpl api::PaymentCapture for Stripebilling {}\nimpl api::PaymentVoid for Stripebilling {}\nimpl api::Refund for Stripebilling {}\nimpl api::RefundExecute for Stripebilling {}\nimpl api::RefundSync for Stripebilling {}\nimpl api::PaymentToken for Stripebilling {}\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nimpl api::revenue_recovery::RevenueRecoveryRecordBack for Stripebilling {}\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nimpl api::revenue_recovery::BillingConnectorPaymentsSyncIntegration for Stripebilling {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Stripebilling\n{\n    // Not Implemented (R)\n}\n\nimpl subscriptions_api::Subscriptions for Stripebilling {}\nimpl subscriptions_api::GetSubscriptionItemsFlow for Stripebilling {}\nimpl subscriptions_api::SubscriptionRecordBackFlow for Stripebilling {}\nimpl subscriptions_api::SubscriptionCreate for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionItems,\n        subscription_request_types::GetSubscriptionItemsRequest,\n        subscription_response_types::GetSubscriptionItemsResponse,\n    > for Stripebilling\n{\n}\nimpl subscriptions_api::GetSubscriptionPlanPricesFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionItemPrices,\n        subscription_request_types::GetSubscriptionItemPricesRequest,\n        subscription_response_types::GetSubscriptionItemPricesResponse,\n    > for Stripebilling\n{\n}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::SubscriptionCreate,\n        subscription_request_types::SubscriptionCreateRequest,\n        subscription_response_types::SubscriptionCreateResponse,\n    > for Stripebilling\n{\n}\nimpl subscriptions_api::GetSubscriptionEstimateFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionEstimate,\n        subscription_request_types::GetSubscriptionEstimateRequest,\n        subscription_response_types::GetSubscriptionEstimateResponse,\n    > for Stripebilling\n{\n}\n\nimpl subscriptions_api::SubscriptionCancelFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::SubscriptionCancel,\n        subscription_request_types::SubscriptionCancelRequest,\n        subscription_response_types::SubscriptionCancelResponse,\n    > for Stripebilling\n{\n}",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse transformers as payjustnowinstore;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst PAYJUSTNOWINSTORE_MERCHANT_TERMINAL_ID: &str = \"X-PayJustNow-Merchant-Terminal-ID\";\nconst SIGNATURE: &str = \"X-Signature\";\nconst MERCHANT_REFERENCE_NON_UNIQUE: &str = \"X-Merchant-Reference-Non-Unique\";\n\n#[derive(Clone)]\npub struct Payjustnowinstore {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payjustnowinstore {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Payjustnowinstore {}\nimpl api::PaymentSession for Payjustnowinstore {}\nimpl api::ConnectorAccessToken for Payjustnowinstore {}\nimpl api::MandateSetup for Payjustnowinstore {}\nimpl api::PaymentAuthorize for Payjustnowinstore {}\nimpl api::PaymentSync for Payjustnowinstore {}\nimpl api::PaymentCapture for Payjustnowinstore {}\nimpl api::PaymentVoid for Payjustnowinstore {}\nimpl api::Refund for Payjustnowinstore {}\nimpl api::RefundExecute for Payjustnowinstore {}\nimpl api::RefundSync for Payjustnowinstore {}\nimpl api::PaymentToken for Payjustnowinstore {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payjustnowinstore\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payjustnowinstore\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let request_body = Self::get_request_body(self, req, connectors)?;\n\n        let request_body_string =\n            String::from_utf8(request_body.get_inner_value().peek().as_bytes().to_vec())\n                .map_err(|_| errors::ConnectorError::RequestEncodingFailed)?;\n\n        let request_body_string_without_whitespace =\n            request_body_string.replace(char::is_whitespace, \"\");\n\n        let auth = payjustnowinstore::PayjustnowinstoreAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, auth.merchant_api_key.expose().as_bytes());\n\n        let signature = hmac::sign(&key, request_body_string_without_whitespace.as_bytes());\n\n        let signature_hex = hex::encode(signature.as_ref());\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (SIGNATURE.to_string(), signature_hex.into_masked()),\n            (\n                MERCHANT_REFERENCE_NON_UNIQUE.to_string(),\n                \"true\".to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Payjustnowinstore {\n    fn id(&self) -> &'static str {\n        \"payjustnowinstore\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__wise__transformers.rs",
    "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum WiseHttpStatus {\n    String(String),\n    Number(u16),\n}\n\nimpl Default for WiseHttpStatus {\n    fn default() -> Self {\n        Self::String(\"\".to_string())\n    }\n}\n\nimpl WiseHttpStatus {\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum AccountType {\n    Checking,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__archipel.rs",
    "code": "use std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        IncrementalAuthorization,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse router_env::{error, info};\nuse transformers::{\n    self as archipel, ArchipelCardAuthorizationRequest, ArchipelIncrementalAuthorizationRequest,\n    ArchipelPaymentsCancelRequest, ArchipelRefundRequest, ArchipelWalletAuthorizationRequest,\n};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{is_mandate_supported, PaymentMethodDataType, PaymentsAuthorizeRequestData},\n};\n\npub mod transformers;\n\n#[derive(Clone)]\npub struct Archipel {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Archipel {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::PaymentAuthorize for Archipel {}\nimpl api::PaymentSync for Archipel {}\nimpl api::PaymentVoid for Archipel {}\nimpl api::PaymentCapture for Archipel {}\nimpl api::MandateSetup for Archipel {}\nimpl api::ConnectorAccessToken for Archipel {}\nimpl api::PaymentToken for Archipel {}\nimpl api::PaymentSession for Archipel {}\nimpl api::Refund for Archipel {}\nimpl api::RefundExecute for Archipel {}\nimpl api::RefundSync for Archipel {}\nimpl api::Payment for Archipel {}\nimpl api::PaymentIncrementalAuthorization for Archipel {}\n\nfn build_env_specific_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, errors::ConnectorError> {\n    let archipel_connector_metadata_object =\n        transformers::ArchipelConfigData::try_from(connector_metadata)?;\n    let endpoint_prefix = archipel_connector_metadata_object.platform_url;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Archipel\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Archipel {\n    fn id(&self) -> &'static str {\n        \"archipel\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.archipel.base_url.as_ref()",
    "function_name": "build_env_specific_endpoint",
    "file": "crates__hyperswitch_connectors__src__connectors__archipel.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for update_modular_pm_and_mandate_impl",
    "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_data,\n            },\n            tokenization,\n            types::MultipleCaptureData,\n            OperationSessionGetters, PaymentData, PaymentMethodChecker,\n        },\n        utils as core_utils,\n    },\n    routes::{metrics, SessionState},\n    types::{\n        self, domain,\n        storage::{self, enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n        CaptureSyncResponse, ErrorResponse,\n    },\n    utils,\n};\n\n/// This implementation executes the flow only when\n/// 1. Payment was created with supported payment methods\n/// 2. Payment attempt's status was not a terminal failure\n#[cfg(feature = \"v1\")]\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n                            update_connector_mandate_details_for_the_flow(\n                                mandate_reference.connector_mandate_id.clone(),\n                                mandate_reference.mandate_metadata.clone(),\n                                mandate_reference\n                                    .connector_mandate_request_reference_id\n                                    .clone(),\n                                payment_data,\n                            )\n                            .change_context(\n                                ::payment_methods::errors::ModularPaymentMethodError::UpdateFailed,\n                            )?;\n                            mandate_reference\n                                .connector_mandate_id\n                                .map(|connector_mandate_id| {\n                                    ::payment_methods::types::ConnectorTokenDetails {",
    "function_name": "update_modular_pm_and_mandate_impl",
    "file": "crates__router__src__core__payments__operations__payment_response.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use common_enums::{enums, Currency};\nuse common_utils::{id_type::CustomerId, pii::Email, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    address::Address as DomainAddress,\n    payment_method_data::PaymentMethodData,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        RouterData,\n    },\n    router_flow_types::{\n        payments::Capture,\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{PaymentsCaptureData, ResponseId},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts,\n    errors::{self},\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        get_unimplemented_payment_method_error_message, AddressDetailsData,\n        PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct CeleroRouterData<T> {\n    pub amount: MinorUnit, // CeleroCommerce expects integer cents\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for CeleroRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n// CeleroCommerce Search Request for sync operations - POST /api/transaction/search\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroSearchRequest {\n    transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsSyncRouterData> for CeleroSearchRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsSyncRouterData) -> Result<Self, Self::Error> {\n        let transaction_id = match &item.request.connector_transaction_id {\n            ResponseId::ConnectorTransactionId(id) => id.clone(),\n            _ => {\n                return Err(errors::ConnectorError::MissingConnectorTransactionID.into());\n            }\n        };\n        Ok(Self { transaction_id })\n    }\n}\n\nimpl TryFrom<&RefundSyncRouterData> for CeleroSearchRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &RefundSyncRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            transaction_id: item.request.get_connector_refund_id()?,\n        })\n    }\n}\n\n// CeleroCommerce Payment Request according to API specs\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroPaymentsRequest {\n    idempotency_key: String,\n    #[serde(rename = \"type\")]\n    transaction_type: TransactionType,\n    amount: MinorUnit, // CeleroCommerce expects integer cents\n    currency: Currency,\n    payment_method: CeleroPaymentMethod,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<CeleroAddress>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shipping_address: Option<CeleroAddress>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    create_vault_record: Option<bool>,\n    // CIT/MIT fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    card_on_file_indicator: Option<CardOnFileIndicator>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    initiated_by: Option<InitiatedBy>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    initial_transaction_id: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stored_credential_indicator: Option<StoredCredentialIndicator>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_method: Option<BillingMethod>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroAddress {\n    first_name: Option<Secret<String>>,\n    last_name: Option<Secret<String>>,\n    address_line_1: Option<Secret<String>>,\n    address_line_2: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n    postal_code: Option<Secret<String>>,\n    country: Option<common_enums::CountryAlpha2>,\n    phone: Option<Secret<String>>,\n    email: Option<Email>,\n}\n\nimpl TryFrom<&DomainAddress> for CeleroAddress {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(address: &DomainAddress) -> Result<Self, Self::Error> {\n        let address_details = address.address.as_ref();\n        match address_details {\n            Some(address_details) => Ok(Self {\n                first_name: address_details.get_optional_first_name(),\n                last_name: address_details.get_optional_last_name(),\n                address_line_1: address_details.get_optional_line1(),\n                address_line_2: address_details.get_optional_line2(),\n                city: address_details.get_optional_city(),\n                state: address_details.get_optional_state(),\n                postal_code: address_details.get_optional_zip(),\n                country: address_details.get_optional_country(),\n                phone: address\n                    .phone\n                    .as_ref()\n                    .and_then(|phone| phone.number.clone()),\n                email: address.email.clone(),\n            }),",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__celero__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs",
    "code": "use common_enums::{enums, AttemptStatus, BankNames};\nuse common_utils::{\n    errors::ParsingError,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{self},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct MultisafepayRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for MultisafepayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Type {\n    Direct,\n    Redirect,\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum Gateway {\n    Amex,\n    CreditCard,\n    Discover,\n    Maestro,\n    MasterCard,\n    Visa,\n    Klarna,\n    Googlepay,\n    Paypal,\n    Ideal,\n    Giropay,\n    Trustly,\n    Alipay,\n    #[serde(rename = \"WECHAT\")]\n    WeChatPay,\n    Eps,\n    MbWay,\n    #[serde(rename = \"DIRECTBANK\")]\n    Sofort,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Coupons {\n    pub allow: Option<Vec<Secret<String>>>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Mistercash {\n    pub mobile_pay_button_position: Option<String>,\n    pub disable_mobile_pay_button: Option<String>,\n    pub qr_only: Option<String>,\n    pub qr_size: Option<String>,\n}\n\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub struct Gateways {\n    pub mistercash: Option<Mistercash>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Settings {\n    pub coupons: Option<Coupons>,\n    pub gateways: Option<Gateways>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct PaymentOptions {\n    pub notification_url: Option<String>,\n    pub notification_method: Option<String>,\n    pub redirect_url: String,\n    pub cancel_url: String,\n    pub close_window: Option<bool>,\n    pub settings: Option<Settings>,\n    pub template_id: Option<String>,\n    pub allowed_countries: Option<Vec<String>>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Browser {\n    pub javascript_enabled: Option<bool>,\n    pub java_enabled: Option<bool>,\n    pub cookies_enabled: Option<bool>,\n    pub language: Option<String>,\n    pub screen_color_depth: Option<i32>,\n    pub screen_height: Option<i32>,\n    pub screen_width: Option<i32>,\n    pub time_zone: Option<i32>,\n    pub user_agent: Option<String>,\n    pub platform: Option<String>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Customer {\n    pub browser: Option<Browser>,\n    pub locale: Option<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse transformers as bamboraapac;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Bamboraapac {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Bamboraapac {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bamboraapac {}\nimpl api::PaymentSession for Bamboraapac {}\nimpl api::ConnectorAccessToken for Bamboraapac {}\nimpl api::MandateSetup for Bamboraapac {}\nimpl api::PaymentAuthorize for Bamboraapac {}\nimpl api::PaymentSync for Bamboraapac {}\nimpl api::PaymentCapture for Bamboraapac {}\nimpl api::PaymentVoid for Bamboraapac {}\nimpl api::Refund for Bamboraapac {}\nimpl api::RefundExecute for Bamboraapac {}\nimpl api::RefundSync for Bamboraapac {}\nimpl api::PaymentToken for Bamboraapac {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Bamboraapac\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bamboraapac\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorValidation for Bamboraapac {\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \"mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n}\n\nimpl ConnectorCommon for Bamboraapac {\n    fn id(&self) -> &'static str {\n        \"bamboraapac\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"text/xml\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bamboraapac.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n    ForeignIDRef,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    mandates::{MandateDataType, MandateDetails},\n    router_request_types,\n};\n\n#[async_trait::async_trait]\npub trait PaymentAttemptInterface {\n    type Error;\n    #[cfg(feature = \"v1\")]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn insert_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn update_payment_attempt_with_attempt_id(\n        &self,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn update_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_by_connector_transaction_id_payment_id_processor_merchant_id(\n        &self,\n        connector_transaction_id: &ConnectorTransactionId,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_id: &id_type::GlobalPaymentId,\n        storage_scheme: storage_enums::MerchantStorageScheme,",
    "function_name": "insert_payment_attempt",
    "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum WiseHttpStatus {\n    String(String),\n    Number(u16),\n}\n\nimpl Default for WiseHttpStatus {\n    fn default() -> Self {\n        Self::String(\"\".to_string())\n    }\n}\n\nimpl WiseHttpStatus {\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum AccountType {\n    Checking,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__affirm.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as affirm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Affirm {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Affirm {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Affirm {}\nimpl api::PaymentSession for Affirm {}\nimpl api::ConnectorAccessToken for Affirm {}\nimpl api::MandateSetup for Affirm {}\nimpl api::PaymentAuthorize for Affirm {}\nimpl api::PaymentsCompleteAuthorize for Affirm {}\nimpl api::PaymentSync for Affirm {}\nimpl api::PaymentCapture for Affirm {}\nimpl api::PaymentVoid for Affirm {}\nimpl api::Refund for Affirm {}\nimpl api::RefundExecute for Affirm {}\nimpl api::RefundSync for Affirm {}\nimpl api::PaymentToken for Affirm {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Affirm\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Affirm\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Affirm {\n    fn id(&self) -> &'static str {\n        \"affirm\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.affirm.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = affirm::AffirmAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key = BASE64_ENGINE.encode(format!(\n            \"{}:{}\",\n            auth.public_key.peek(),\n            auth.private_key.peek()\n        ));\n\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__affirm.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__masking__src__serde.rs",
    "code": "//! Serde-related.\n\npub use erased_serde::Serialize as ErasedSerialize;\npub use serde::{de, Deserialize, Serialize, Serializer};\nuse serde_json::{value::Serializer as JsonValueSerializer, Value};\n\nuse crate::{Secret, Strategy, StrongSecret, ZeroizableSecret};\n\n/// Marker trait for secret types which can be [`Serialize`]-d by [`serde`].\n///\n/// When the `serde` feature of this crate is enabled and types are marked with\n/// this trait, they receive a [`Serialize` impl] for `Secret<T>`.\n/// (NOTE: all types which impl `DeserializeOwned` receive a [`Deserialize`]\n/// impl)\n///\n/// This is done deliberately to prevent accidental exfiltration of secrets\n/// via `serde` serialization.\n#[cfg_attr(docsrs, cfg(feature = \"serde\"))]\npub trait SerializableSecret: Serialize {}\n// #[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n// pub trait NonSerializableSecret: Serialize {}\n\nimpl SerializableSecret for Value {}\nimpl SerializableSecret for u8 {}\nimpl SerializableSecret for u16 {}\nimpl SerializableSecret for i8 {}\nimpl SerializableSecret for i32 {}\nimpl SerializableSecret for i64 {}\nimpl SerializableSecret for url::Url {}\n\n#[cfg(feature = \"time\")]\nimpl SerializableSecret for time::Date {}\n\nimpl<T: SerializableSecret> SerializableSecret for &T {}\n\nimpl<'de, T, I> Deserialize<'de> for Secret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for Secret<T, I>\nwhere\n    T: SerializableSecret + Serialize + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\nimpl<'de, T, I> Deserialize<'de> for StrongSecret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized + ZeroizableSecret,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for StrongSecret<T, I>\nwhere\n    T: SerializableSecret + Serialize + ZeroizableSecret + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\n/// Masked serialization.\n///\n/// the default behaviour for secrets is to serialize in exposed format since the common use cases\n/// for storing the secret to database or sending it over the network requires the secret to be exposed\n/// This method allows to serialize the secret in masked format if needed for logs or other insecure exposures\npub fn masked_serialize<T: Serialize>(value: &T) -> Result<Value, serde_json::Error> {\n    value.serialize(PIISerializer {\n        inner: JsonValueSerializer,\n    })\n}\n\n/// Masked serialization.\n///\n/// Trait object for supporting serialization to Value while accounting for masking\n/// The usual Serde Serialize trait cannot be used as trait objects\n/// like &dyn Serialize or boxed trait objects like Box<dyn Serialize> because of Rust's \"object safety\" rules.\n/// In particular, the trait contains generic methods which cannot be made into a trait object.\n/// In this case we remove the generic for assuming the serialization to be of 2 types only raw json or masked json\npub trait ErasedMaskSerialize: ErasedSerialize {\n    /// Masked serialization.\n    fn masked_serialize(&self) -> Result<Value, serde_json::Error>;\n}\n\nimpl<T: Serialize + ErasedSerialize> ErasedMaskSerialize for T {\n    fn masked_serialize(&self) -> Result<Value, serde_json::Error> {\n        masked_serialize(self)\n    }\n}\n\nimpl Serialize for dyn ErasedMaskSerialize + '_ {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        erased_serde::serialize(self, serializer)\n    }\n}\n\nimpl Serialize for dyn ErasedMaskSerialize + '_ + Send {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        erased_serde::serialize(self, serializer)\n    }\n}\n\nuse pii_serializer::PIISerializer;\n\nmod pii_serializer {\n    use std::fmt::Display;\n\n    pub(super) fn pii_serialize<",
    "function_name": "deserialize",
    "file": "crates__masking__src__serde.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        CreateOrderRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, CreateOrderType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as airwallex;\n\nuse crate::{\n    connectors::airwallex::transformers::AirwallexAuthorizeResponse,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{\n        self as connector_utils, convert_amount, AccessTokenRequestInfo, ForeignTryFrom,\n        PaymentMethodDataType, PaymentsAuthorizeRequestData, RefundsRequestData,\n    },\n};\n\n#[derive(Clone)]\npub struct Airwallex {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_string_minor:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Airwallex {\n    fn id(&self) -> &'static str {\n        \"airwallex\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.airwallex.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__airwallex.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__common_utils__src__pii.rs",
    "code": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse serde::Deserialize;\n\nuse crate::{\n    crypto::Encryptable,\n    errors::{self, ValidationError},\n    validation::{validate_email, validate_phone_number},\n};\n\n/// A string constant representing a redacted or masked value.\npub const REDACTED: &str = \"Redacted\";\n\n/// Type alias for serde_json value which has Secret Information\npub type SecretSerdeValue = Secret<serde_json::Value>;\n\n/// Strategy for masking a PhoneNumber\n#[derive(Debug)]\npub enum PhoneNumberStrategy {}\n\n/// Phone Number\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(try_from = \"String\")]\npub struct PhoneNumber(Secret<String, PhoneNumberStrategy>);\n\nimpl<T> Strategy<T> for PhoneNumberStrategy\nwhere\n    T: AsRef<str> + fmt::Debug,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    }\n}\n\nimpl FromStr for PhoneNumber {\n    type Err = error_stack::Report<ValidationError>;\n    fn from_str(phone_number: &str) -> Result<Self, Self::Err> {\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    }\n}\n\nimpl TryFrom<String> for PhoneNumber {\n    type Error = error_stack::Report<errors::ParsingError>;\n\n    fn try_from(value: String) -> Result<Self, Self::Error> {\n        Self::from_str(&value).change_context(errors::ParsingError::PhoneNumberParsingError)\n    }\n}\n\nimpl ops::Deref for PhoneNumber {\n    type Target = Secret<String, PhoneNumberStrategy>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl ops::DerefMut for PhoneNumber {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<DB> Queryable<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    Self: FromSql<sql_types::Text, DB>,\n{\n    type Row = Self;\n\n    fn build(row: Self::Row) -> deserialize::Result<Self> {\n        Ok(row)\n    }\n}\n\nimpl<DB> FromSql<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    String: FromSql<sql_types::Text, DB>,\n{\n    fn from_sql(bytes: DB::RawValue<'_>) -> deserialize::Result<Self> {\n        let val = String::from_sql(bytes)?;\n        Ok(Self::from_str(val.as_str())?)\n    }\n}\n\nimpl<DB> ToSql<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    String: ToSql<sql_types::Text, DB>,\n{\n    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, DB>) -> diesel::serialize::Result {\n        self.0.to_sql(out)\n    }\n}\n\n/*\n/// Phone number\n#[derive(Debug)]\npub struct PhoneNumber;\n\nimpl<T> Strategy<T> for PhoneNumber\nwhere\n    T: AsRef<str>,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if val_str.len() < 10 || val_str.len() > 12 {\n            return WithType::fmt(val, f);\n        }\n\n        write!(\n            f,\n            \"{}{}{}\",",
    "function_name": "fmt",
    "file": "crates__common_utils__src__pii.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        convert_amount, get_unimplemented_payment_method_error_message, AddressData,\n        AddressDetailsData, BrowserInformationData, CardData as CardDataUtil, CustomerData,\n        OrderDetailsWithAmountData, PaymentMethodTokenizationRequestData,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct MollieRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for MollieRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MolliePaymentsRequest {\n    amount: Amount,\n    description: String,\n    redirect_url: String,\n    cancel_url: Option<String>,\n    webhook_url: String,\n    locale: Option<String>,\n    #[serde(flatten)]\n    payment_method_data: MolliePaymentMethodData,\n    metadata: Option<MollieMetadata>,\n    sequence_type: SequenceType,\n    customer_id: Option<String>,\n    capture_mode: Option<MollieCaptureMode>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]\npub struct Amount {\n    currency: enums::Currency,\n    value: StringMajorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(tag = \"method\")]\n#[serde(rename_all = \"lowercase\")]\npub enum MolliePaymentMethodData {\n    Applepay(Box<ApplePayMethodData>),\n    Eps,\n    Giropay,\n    Ideal(Box<IdealMethodData>),\n    Paypal(Box<PaypalMethodData>),\n    Sofort,\n    Przelewy24(Box<Przelewy24MethodData>),\n    Bancontact,\n    CreditCard(Box<CreditCardMethodData>),\n    DirectDebit(Box<DirectDebitMethodData>),\n    Klarna(Box<KlarnaMethodData>),\n    #[serde(untagged)]\n    MandatePayment(Box<MandatePaymentMethodData>),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ApplePayMethodData {\n    apple_pay_payment_token: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct IdealMethodData {\n    issuer: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaypalMethodData {\n    billing_address: Option<Address>,\n    shipping_address: Option<Address>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct KlarnaMethodData {\n    billing_address: Address,\n    lines: Vec<MollieLinesItems>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MollieLinesItems {\n    description: String,\n    quantity: i32,\n    quantity_unit: Option<String>,\n    unit_price: OrderItemUnitPrice,\n    total_amount: OrderItemUnitPrice,\n    discount_amount: Option<OrderItemUnitPrice>,\n    sku: Option<String>,\n    image_url: Option<String>,\n}\n\nimpl TryFrom<(types::OrderDetailsWithAmount, enums::Currency)> for MollieLinesItems {\n    type Error = Error;\n    fn try_from(\n        (order_details, currency): (types::OrderDetailsWithAmount, enums::Currency),\n    ) -> Result<Self, Self::Error> {\n        let description = order_details.get_order_description()?;\n        let quantity = i32::from(order_details.get_order_quantity());\n        let quantity_unit = order_details.get_optional_order_quantity_unit();\n        let sku = order_details.get_optional_sku();",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "#[cfg(feature = \"payouts\")]\nmod payout_requests;\n#[cfg(feature = \"payouts\")]\nmod payout_response;\n#[cfg(feature = \"payouts\")]\npub mod payout_transformers;\nmod requests;\nmod response;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{payments::PaymentIdType, webhooks::IncomingWebhookEvent};\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundExecuteRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsVoidType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Mask;\n#[cfg(feature = \"payouts\")]\nuse payout_requests::WorldpayPayoutRequest;\n#[cfg(feature = \"payouts\")]\nuse payout_response::WorldpayPayoutResponse;\nuse requests::{\n    WorldpayCompleteAuthorizationRequest, WorldpayPartialRequest, WorldpayPaymentsRequest,\n};\nuse response::{\n    EventType, ResponseIdStr, WorldpayErrorResponse, WorldpayEventResponse,\n    WorldpayPaymentsResponse, WorldpayWebhookEventType, WorldpayWebhookTransactionId,\n    WP_CORRELATION_ID,\n};\nuse ring::hmac;\n\n#[cfg(feature = \"payouts\")]\nuse self::payout_transformers as worldpay_payout;\nuse self::transformers as worldpay;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, get_header_key_value, is_html_response_from_headers, is_mandate_supported,\n        ForeignTryFrom, PaymentMethodDataType, RefundsRequestData,\n    },\n};\n\n#[cfg(feature = \"payouts\")]\nconst WORLDPAY_PAYOUT_CONTENT_TYPE: &str = \"application/vnd.worldpay.payouts-v4+json\";\n\n#[derive(Clone)]\npub struct Worldpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Worldpay {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (headers::WP_API_VERSION.to_string(), \"2024-06-01\".into()),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut api_key);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Worldpay {\n    fn id(&self) -> &'static str {\n        \"worldpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__core__payments__operations__payment_response.rs",
    "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_data,\n            },\n            tokenization,\n            types::MultipleCaptureData,\n            OperationSessionGetters, PaymentData, PaymentMethodChecker,\n        },\n        utils as core_utils,\n    },\n    routes::{metrics, SessionState},\n    types::{\n        self, domain,\n        storage::{self, enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n        CaptureSyncResponse, ErrorResponse,\n    },\n    utils,\n};\n\n/// This implementation executes the flow only when\n/// 1. Payment was created with supported payment methods\n/// 2. Payment attempt's status was not a terminal failure\n#[cfg(feature = \"v1\")]\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n                            update_connector_mandate_details_for_the_flow(\n                                mandate_reference.connector_mandate_id.clone(),\n                                mandate_reference.mandate_metadata.clone(),\n                                mandate_reference\n                                    .connector_mandate_request_reference_id\n                                    .clone(),\n                                payment_data,\n                            )\n                            .change_context(\n                                ::payment_methods::errors::ModularPaymentMethodError::UpdateFailed,\n                            )?;\n                            mandate_reference\n                                .connector_mandate_id\n                                .map(|connector_mandate_id| {\n                                    ::payment_methods::types::ConnectorTokenDetails {",
    "function_name": "update_modular_pm_and_mandate_impl",
    "file": "crates__router__src__core__payments__operations__payment_response.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as zift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Zift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Zift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Zift {}\nimpl api::PaymentSession for Zift {}\nimpl api::ConnectorAccessToken for Zift {}\nimpl api::PaymentAuthorize for Zift {}\nimpl api::PaymentSync for Zift {}\nimpl api::PaymentCapture for Zift {}\nimpl api::PaymentVoid for Zift {}\nimpl api::Refund for Zift {}\nimpl api::RefundExecute for Zift {}\nimpl api::RefundSync for Zift {}\nimpl api::PaymentToken for Zift {}\nimpl api::MandateSetup for Zift {}\n\nimpl ConnectorIntegration<SetupMandate, SetupMandateRequestData, PaymentsResponseData> for Zift {\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_content_type(&self) -> &'static str {\n        self.common_get_content_type()\n    }\n\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__zift.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__common_utils__src__types.rs",
    "code": "//! Types that can be used in other crates\npub mod keymanager;\n\n/// Enum for Authentication Level\npub mod authentication;\n/// User related types\npub mod user;\n\n/// types that are wrappers around primitive types\npub mod primitive_wrappers;\n\nuse std::{\n    borrow::Cow,\n    fmt::Display,\n    iter::Sum,\n    num::NonZeroI64,\n    ops::{Add, Mul, Sub},\n    primitive::i64,\n    str::FromStr,\n};\n\nuse common_enums::enums;\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    serialize::{Output, ToSql},\n    sql_types,\n    sql_types::Jsonb,\n    AsExpression, FromSqlRow, Queryable,\n};\nuse error_stack::{report, ResultExt};\npub use primitive_wrappers::bool_wrappers::{\n    AlwaysRequestExtendedAuthorization, ExtendedAuthorizationAppliedBool,\n    RequestExtendedAuthorizationBool,\n};\nuse rust_decimal::{\n    prelude::{FromPrimitive, ToPrimitive},\n    Decimal,\n};\nuse semver::Version;\nuse serde::{de::Visitor, Deserialize, Deserializer, Serialize};\nuse thiserror::Error;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    consts::{\n        self, MAX_DESCRIPTION_LENGTH, MAX_STATEMENT_DESCRIPTOR_LENGTH, PUBLISHABLE_KEY_LENGTH,\n    },\n    errors::{CustomResult, ParsingError, PercentageError, ValidationError},\n    fp_utils::when,\n    id_type, impl_enum_str,\n};\n\n/// Represents Percentage Value between 0 and 100 both inclusive\n#[derive(Clone, Default, Debug, PartialEq, Serialize)]\npub struct Percentage<const PRECISION: u8> {\n    // this value will range from 0 to 100, decimal length defined by precision macro\n    /// Percentage value ranging between 0 and 100\n    percentage: f32,\n}\n\nfn get_invalid_percentage_error_message(precision: u8) -> String {\n    format!(\n        \"value should be a float between 0 to 100 and precise to only upto {precision} decimal digits\",\n\n    )\n}\n\nimpl<const PRECISION: u8> Percentage<PRECISION> {\n    /// construct percentage using a string representation of float value\n    pub fn from_string(value: String) -> CustomResult<Self, PercentageError> {\n        if Self::is_valid_string_value(&value)? {\n            Ok(Self {\n                percentage: value\n                    .parse::<f32>()\n                    .change_context(PercentageError::InvalidPercentageValue)?,\n            })\n        } else {\n            Err(report!(PercentageError::InvalidPercentageValue))\n                .attach_printable(get_invalid_percentage_error_message(PRECISION))\n        }\n    }\n    /// function to get percentage value\n    pub fn get_percentage(&self) -> f32 {\n        self.percentage\n    }\n\n    /// apply the percentage to amount and ceil the result\n    #[allow(clippy::as_conversions)]\n    pub fn apply_and_ceil_result(\n        &self,\n        amount: MinorUnit,\n    ) -> CustomResult<MinorUnit, PercentageError> {\n        let max_amount = i64::MAX / 10000;\n        let amount = amount.0;\n        if amount > max_amount {\n            // value gets rounded off after i64::MAX/10000\n            Err(report!(PercentageError::UnableToApplyPercentage {\n                percentage: self.percentage,\n                amount: MinorUnit::new(amount),\n            }))\n            .attach_printable(format!(\n                \"Cannot calculate percentage for amount greater than {max_amount}\",\n            ))\n        } else {\n            let percentage_f64 = f64::from(self.percentage);\n            let result = (amount as f64 * (percentage_f64 / 100.0)).ceil() as i64;\n            Ok(MinorUnit::new(result))\n        }\n    }\n\n    fn is_valid_string_value(value: &str) -> CustomResult<bool, PercentageError> {\n        let float_value = Self::is_valid_float_string(value)?;\n        Ok(Self::is_valid_range(float_value) && Self::is_valid_precision_length(value))\n    }\n    fn is_valid_float_string(value: &str) -> CustomResult<f32, PercentageError> {\n        value\n            .parse::<f32>()\n            .change_context(PercentageError::InvalidPercentageValue)\n    }\n    fn is_valid_range(value: f32) -> bool {\n        (0.0..=100.0).contains(&value)\n    }\n    fn is_valid_precision_length(value: &str) -> bool {\n        if value.contains('.') {\n            // if string has '.' then take the decimal part and verify precision length\n            match value.split('.').next_back() {\n                Some(decimal_part) => {\n                    decimal_part.trim_end_matches('0').len() <= <u8 as Into<usize>>::into(PRECISION)\n                }\n                // will never be None\n                None => false,\n            }\n        } else {\n            // if there is no '.' then it is a whole number with no decimal part. So return true\n            true\n        }\n    }",
    "function_name": "get_invalid_percentage_error_message",
    "file": "crates__common_utils__src__types.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__paybox.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as paybox;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType, RouterData as _},\n};\n\n#[derive(Clone)]\npub struct Paybox {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Paybox {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paybox {}\nimpl api::PaymentSession for Paybox {}\nimpl api::ConnectorAccessToken for Paybox {}\nimpl api::MandateSetup for Paybox {}\nimpl api::PaymentAuthorize for Paybox {}\nimpl api::PaymentSync for Paybox {}\nimpl api::PaymentCapture for Paybox {}\nimpl api::PaymentVoid for Paybox {}\nimpl api::Refund for Paybox {}\nimpl api::RefundExecute for Paybox {}\nimpl api::RefundSync for Paybox {}\nimpl api::PaymentToken for Paybox {}\nimpl api::PaymentsCompleteAuthorize for Paybox {}\nimpl ConnectorIntegration<Void, PaymentsCancelData, PaymentsResponseData> for Paybox {\n    fn build_request(\n        &self,\n        _req: &PaymentsCancelRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"Cancel/Void flow\".to_string()).into())\n    }\n}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Paybox\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Paybox\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Paybox {\n    fn id(&self) -> &'static str {\n        \"paybox\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.paybox.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = paybox::PayboxAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.cle.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__paybox.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, PSync, PaymentMethodToken, PostCaptureVoid, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Dsync, Evidence, Fetch, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DisputeSyncData,\n        FetchDisputesRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCancelPostCaptureData, PaymentsCaptureData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, RetrieveFileRequestData,\n        SetupMandateRequestData, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DisputeSyncResponse, FetchDisputesResponse,\n        PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, RetrieveFileResponse,\n        SubmitEvidenceResponse, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n        UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, Dispute, DisputeSync, FetchDisputes, SubmitEvidence},\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as worldpayvantiv;\n\nuse crate::{\n    constants::headers,\n    types::{\n        AcceptDisputeRouterData, DisputeSyncRouterData, FetchDisputeRouterData, ResponseRouterData,\n        RetrieveFileRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    utils as connector_utils,\n};\n\n#[derive(Clone)]\npub struct Worldpayvantiv {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Worldpayvantiv {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Worldpayvantiv {}\nimpl api::PaymentSession for Worldpayvantiv {}\nimpl api::ConnectorAccessToken for Worldpayvantiv {}\nimpl api::MandateSetup for Worldpayvantiv {}\nimpl api::PaymentAuthorize for Worldpayvantiv {}\nimpl api::PaymentSync for Worldpayvantiv {}\nimpl api::PaymentCapture for Worldpayvantiv {}\nimpl api::PaymentVoid for Worldpayvantiv {}\nimpl api::Refund for Worldpayvantiv {}\nimpl api::RefundExecute for Worldpayvantiv {}\nimpl api::RefundSync for Worldpayvantiv {}\nimpl api::PaymentToken for Worldpayvantiv {}\nimpl api::PaymentPostCaptureVoid for Worldpayvantiv {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Worldpayvantiv\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpayvantiv\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Worldpayvantiv {\n    fn id(&self) -> &'static str {\n        \"worldpayvantiv\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"text/xml\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.worldpayvantiv.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs",
    "code": "use bytes::Bytes;\nuse common_enums::enums;\nuse common_utils::{\n    date_time::DateFormat, errors::CustomResult, ext_traits::ValueExt, types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, CardMandateInfo, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\npub struct PayboxRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayboxRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst AUTH_REQUEST: &str = \"00001\";\nconst CAPTURE_REQUEST: &str = \"00002\";\nconst AUTH_AND_CAPTURE_REQUEST: &str = \"00003\";\nconst SYNC_REQUEST: &str = \"00017\";\nconst REFUND_REQUEST: &str = \"00014\";\nconst SUCCESS_CODE: &str = \"00000\";\nconst VERSION_PAYBOX: &str = \"00104\";\nconst PAY_ORIGIN_INTERNET: &str = \"024\";\nconst THREE_DS_FAIL_CODE: &str = \"00000000\";\nconst RECURRING_ORIGIN: &str = \"027\";\nconst MANDATE_REQUEST: &str = \"00056\";\nconst MANDATE_AUTH_ONLY: &str = \"00051\";\nconst MANDATE_AUTH_AND_CAPTURE_ONLY: &str = \"00053\";\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PayboxPaymentsRequest {\n    Card(PaymentsRequest),\n    CardThreeDs(ThreeDSPaymentsRequest),\n    Mandate(MandatePaymentRequest),\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymentsRequest {\n    #[serde(rename = \"DATEQ\")]\n    pub date: String,\n\n    #[serde(rename = \"TYPE\")]\n    pub transaction_type: String,\n\n    #[serde(rename = \"NUMQUESTION\")]\n    pub paybox_request_number: String,\n\n    #[serde(rename = \"MONTANT\")]\n    pub amount: MinorUnit,\n\n    #[serde(rename = \"REFERENCE\")]\n    pub description_reference: String,\n\n    #[serde(rename = \"VERSION\")]\n    pub version: String,\n\n    #[serde(rename = \"DEVISE\")]\n    pub currency: String,\n\n    #[serde(rename = \"PORTEUR\")]\n    pub card_number: cards::CardNumber,\n\n    #[serde(rename = \"DATEVAL\")]\n    pub expiration_date: Secret<String>,\n\n    #[serde(rename = \"CVV\")]\n    pub cvv: Secret<String>,\n\n    #[serde(rename = \"ACTIVITE\")]\n    pub activity: String,\n\n    #[serde(rename = \"SITE\")]\n    pub site: Secret<String>,\n\n    #[serde(rename = \"RANG\")]\n    pub rank: Secret<String>,\n\n    #[serde(rename = \"CLE\")]\n    pub key: Secret<String>,\n\n    #[serde(rename = \"ID3D\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub three_ds_data: Option<Secret<String>>,\n\n    #[serde(rename = \"REFABONNE\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub customer_id: Option<Secret<String>>,\n}\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"PascalCase\")]\npub struct ThreeDSPaymentsRequest {\n    id_merchant: Secret<String>,\n    id_session: String,\n    amount: MinorUnit,\n    currency: String,\n    #[serde(rename = \"CCNumber\")]\n    cc_number: cards::CardNumber,\n    #[serde(rename = \"CCExpDate\")]\n    cc_exp_date: Secret<String>,\n    #[serde(rename = \"CVVCode\")]\n    cvv_code: Secret<String>,\n    #[serde(rename = \"URLRetour\")]\n    url_retour: String,\n    #[serde(rename = \"URLHttpDirect\")]\n    url_http_direct: String,\n    email_porteur: common_utils::pii::Email,\n    first_name: Secret<String>,\n    last_name: Secret<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__sift.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as sift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Sift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Sift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Sift {}\nimpl api::PaymentSession for Sift {}\nimpl api::ConnectorAccessToken for Sift {}\nimpl api::MandateSetup for Sift {}\nimpl api::PaymentAuthorize for Sift {}\nimpl api::PaymentSync for Sift {}\nimpl api::PaymentCapture for Sift {}\nimpl api::PaymentVoid for Sift {}\nimpl api::Refund for Sift {}\nimpl api::RefundExecute for Sift {}\nimpl api::RefundSync for Sift {}\nimpl api::PaymentToken for Sift {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Sift {\n    fn id(&self) -> &'static str {\n        \"sift\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.sift.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__sift.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://webservices.apl02.redsys.es\";\npub const REDSYS_SOAP_ACTION: &str = \"consultaOperaciones\";\n\n// Specifies the type of transaction for XML requests\npub mod transaction_type {\n    pub const PAYMENT: &str = \"0\";\n    pub const PREAUTHORIZATION: &str = \"1\";\n    pub const CONFIRMATION: &str = \"2\";\n    pub const REFUND: &str = \"3\";\n    pub const CANCELLATION: &str = \"9\";\n}\n\npub struct RedsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub currency: api_models::enums::Currency,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T, api_models::enums::Currency)> for RedsysRouterData<T> {\n    fn from((amount, item, currency): (StringMinorUnit, T, api_models::enums::Currency)) -> Self {\n        Self {\n            amount,\n            currency,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub struct PaymentsRequest {\n    ds_merchant_amount: StringMinorUnit,\n    ds_merchant_currency: String,\n    ds_merchant_cvv2: Secret<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    ds_merchant_emv3ds: Option<EmvThreedsData>,\n    ds_merchant_expirydate: Secret<String>,\n    ds_merchant_merchantcode: Secret<String>,\n    ds_merchant_order: String,\n    ds_merchant_pan: cards::CardNumber,\n    ds_merchant_terminal: Secret<String>,\n    ds_merchant_transactiontype: RedsysTransactionType,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EmvThreedsData {\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    billing_data: Option<BillingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_accept_header: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_color_depth: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_i_p: Option<Secret<String, common_utils::pii::IpAddress>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_java_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_javascript_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_language: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_height: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_width: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_t_z: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_user_agent: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    cres: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    notification_u_r_l: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    protocol_version: Option<String>,\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    shipping_data: Option<ShippingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    three_d_s_comp_ind: Option<ThreeDSCompInd>,\n    three_d_s_info: RedsysThreeDsInfo,\n    #[serde(\n        alias = \"threeds_server_transaction_id\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    three_d_s_server_trans_i_d: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingData {\n    #[serde(skip_serializing_if = \"Option::is_none\")]",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for generate_authorization_token",
    "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, PaymentCapture, PaymentSync,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse router_env::logger;\nuse time::{format_description, OffsetDateTime};\nuse transformers as worldline;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(Debug, Clone)]\npub struct Worldline;\n\nimpl Worldline {\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n\nimpl ConnectorCommon for Worldline {\n    fn id(&self) -> &'static str {\n        \"worldline\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {",
    "function_name": "generate_authorization_token",
    "file": "crates__hyperswitch_connectors__src__connectors__worldline.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_domain_models__src__lib.rs",
    "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    ApplePayRecurringDetails, ApplePayRegularBillingDetails, FeatureMetadata,\n    OrderDetailsWithAmount, RecurringPaymentIntervalUnit, RedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{\n    BillingConnectorAdditionalCardInfo, BillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails, PaymentRevenueRecoveryMetadata,\n};\n\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize)]\npub enum RemoteStorageObject<T: ForeignIDRef> {\n    ForeignID(String),\n    Object(T),\n}\n\nimpl<T: ForeignIDRef> From<T> for RemoteStorageObject<T> {\n    fn from(value: T) -> Self {\n        Self::Object(value)\n    }\n}\n\npub trait ForeignIDRef {\n    fn foreign_id(&self) -> String;\n}\n\nimpl<T: ForeignIDRef> RemoteStorageObject<T> {\n    pub fn get_id(&self) -> String {\n        match self {\n            Self::ForeignID(id) => id.clone(),\n            Self::Object(i) => i.foreign_id(),\n        }\n    }\n}\n\nuse std::fmt::Debug;\n\npub trait ApiModelToDieselModelConvertor<F> {\n    /// Convert from a foreign type to the current type\n    fn convert_from(from: F) -> Self;\n    fn convert_back(self) -> F;\n}\n\n#[cfg(feature = \"v1\")]\nimpl ApiModelToDieselModelConvertor<ApiFeatureMetadata> for FeatureMetadata {\n    fn convert_from(from: ApiFeatureMetadata) -> Self {\n        let ApiFeatureMetadata {\n            redirect_response,\n            search_tags,\n            apple_pay_recurring_details,\n            pix_additional_details,\n            boleto_additional_details,\n            ..\n        } = from;\n\n        Self {\n            redirect_response: redirect_response.map(RedirectResponse::convert_from),\n            search_tags,\n            apple_pay_recurring_details: apple_pay_recurring_details\n                .map(ApplePayRecurringDetails::convert_from),\n            gateway_system: None,\n            pix_additional_details: pix_additional_details\n                .map(diesel_models::types::PixAdditionalDetails::convert_from),\n            boleto_additional_details: boleto_additional_details\n                .map(diesel_models::types::BoletoAdditionalDetails::convert_from),\n        }\n    }\n\n    fn convert_back(self) -> ApiFeatureMetadata {\n        let Self {",
    "function_name": "from",
    "file": "crates__hyperswitch_domain_models__src__lib.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_id",
    "code": "use std::collections::HashMap;\n\nuse common_enums::MerchantStorageScheme;\nuse common_utils::{\n    encryption::Encryption,\n    errors::{CustomResult, ParsingError},\n    pii,\n};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse masking::ExposeInterface;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::{enums as storage_enums, schema::payment_methods};\n#[cfg(feature = \"v2\")]\nuse crate::{enums as storage_enums, schema_v2::payment_methods};\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Identifiable, Queryable, Selectable, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods, primary_key(payment_method_id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    #[diesel(deserialize_as = super::OptionalDieselArray<storage_enums::Currency>)]\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    #[diesel(deserialize_as = super::OptionalDieselArray<String>)]\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub payment_method_data: Option<Encryption>,\n    pub locker_id: Option<String>,\n    pub last_used_at: PrimitiveDateTime,\n    pub connector_mandate_details: Option<serde_json::Value>,\n    pub customer_acceptance: Option<pii::SecretSerdeValue>,\n    pub status: storage_enums::PaymentMethodStatus,\n    pub network_transaction_id: Option<String>,\n    pub client_secret: Option<String>,\n    pub payment_method_billing_address: Option<Encryption>,\n    pub updated_by: Option<String>,\n    pub version: common_enums::ApiVersion,\n    pub network_token_requestor_reference_id: Option<String>,\n    pub network_token_locker_id: Option<String>,\n    pub network_token_payment_method_data: Option<Encryption>,\n    pub external_vault_source: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub vault_type: Option<storage_enums::VaultType>,\n    pub created_by: Option<String>,\n    pub last_modified_by: Option<String>,\n    pub customer_details: Option<Encryption>,\n    pub locker_fingerprint_id: Option<String>,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, Identifiable, Queryable, Selectable, Serialize, Deserialize)]\n#[diesel(table_name = payment_methods, primary_key(id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::GlobalCustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method_data: Option<Encryption>,\n    pub locker_id: Option<String>,\n    pub last_used_at: PrimitiveDateTime,\n    pub connector_mandate_details: Option<CommonMandateReference>,\n    pub customer_acceptance: Option<pii::SecretSerdeValue>,\n    pub status: storage_enums::PaymentMethodStatus,\n    pub network_transaction_id: Option<Secret<String>>,\n    pub client_secret: Option<String>,\n    pub payment_method_billing_address: Option<Encryption>,\n    pub updated_by: Option<String>,\n    pub version: common_enums::ApiVersion,\n    pub network_token_requestor_reference_id: Option<String>,\n    pub network_token_locker_id: Option<String>,\n    pub network_token_payment_method_data: Option<Encryption>,\n    pub external_vault_source: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub vault_type: Option<storage_enums::VaultType>,\n    pub created_by: Option<String>,\n    pub last_modified_by: Option<String>,\n    pub customer_details: Option<Encryption>,\n    pub locker_fingerprint_id: Option<String>,\n    pub payment_method_type_v2: Option<storage_enums::PaymentMethod>,\n    pub payment_method_subtype: Option<storage_enums::PaymentMethodType>,\n    pub id: common_utils::id_type::GlobalPaymentMethodId,\n    pub external_vault_token_data: Option<Encryption>,\n}\n\nimpl PaymentMethod {\n    #[cfg(feature = \"v1\")]\n    pub fn get_id(&self) -> &String {\n        &self.payment_method_id\n    }\n\n    #[cfg(feature = \"v2\")]\n    pub fn get_id(&self) -> &common_utils::id_type::GlobalPaymentMethodId {\n        &self.id\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Insertable, router_derive::DebugAsDisplay, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods)]\npub struct PaymentMethodNew {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,",
    "function_name": "get_id",
    "file": "crates__diesel_models__src__payment_method.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as digitalvirgo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Digitalvirgo {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Digitalvirgo {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Digitalvirgo {}\nimpl api::PaymentSession for Digitalvirgo {}\nimpl api::ConnectorAccessToken for Digitalvirgo {}\nimpl api::MandateSetup for Digitalvirgo {}\nimpl api::PaymentAuthorize for Digitalvirgo {}\nimpl api::PaymentSync for Digitalvirgo {}\nimpl api::PaymentCapture for Digitalvirgo {}\nimpl api::PaymentVoid for Digitalvirgo {}\nimpl api::Refund for Digitalvirgo {}\nimpl api::RefundExecute for Digitalvirgo {}\nimpl api::RefundSync for Digitalvirgo {}\nimpl api::PaymentToken for Digitalvirgo {}\nimpl api::PaymentsCompleteAuthorize for Digitalvirgo {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Digitalvirgo\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Digitalvirgo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Digitalvirgo {\n    fn id(&self) -> &'static str {\n        \"digitalvirgo\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.digitalvirgo.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = digitalvirgo::DigitalvirgoAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key = consts::BASE64_ENGINE.encode(format!(\n            \"{}:{}\",\n            auth.username.peek(),\n            auth.password.peek()\n        ));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),\n        )])\n    }\n\n    fn build_error_response(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__core__routing__helpers.rs",
    "code": "//! Analysis for usage of all helper functions for use case of routing\n//!\n//! Functions that are used to perform the retrieval of merchant's\n//! routing dict, configs, defaults\nuse std::fmt::Debug;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::str::FromStr;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::sync::Arc;\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router;\nuse api_models::routing as routing_types;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{ext_traits::Encode, id_type};\nuse diesel_models::configs;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse diesel_models::dynamic_routing_stats::{DynamicRoutingStatsNew, DynamicRoutingStatsUpdate};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse diesel_models::routing_algorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_domain_models::api::ApplicationResponse;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v1\")]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashSet;\nuse storage_impl::redis::cache;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse storage_impl::redis::cache::Cacheable;\n\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::db::errors::StorageErrorExt;\n#[cfg(feature = \"v2\")]\nuse crate::types::domain::MerchantConnectorAccount;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::types::transformers::ForeignFrom;\nuse crate::{\n    core::errors::{self, RouterResult},\n    db::StorageInterface,\n    routes::SessionState,\n    types::{domain, storage},\n    utils::StringExt,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    core::payments::{\n        routing::utils::{self as routing_utils, DecisionEngineApiHandler},\n        OperationSessionGetters, OperationSessionSetters,\n    },\n    services,\n};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::{\n    core::{metrics as core_metrics, routing},\n    routes::app::SessionStateInfo,\n    types::transformers::ForeignInto,\n};\npub const SUCCESS_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Success rate based dynamic routing algorithm\";\npub const ELIMINATION_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Elimination based dynamic routing algorithm\";\npub const CONTRACT_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Contract based dynamic routing algorithm\";\n\npub const DECISION_ENGINE_RULE_CREATE_ENDPOINT: &str = \"rule/create\";\npub const DECISION_ENGINE_RULE_UPDATE_ENDPOINT: &str = \"rule/update\";\npub const DECISION_ENGINE_RULE_GET_ENDPOINT: &str = \"rule/get\";\npub const DECISION_ENGINE_RULE_DELETE_ENDPOINT: &str = \"rule/delete\";\npub const DECISION_ENGINE_MERCHANT_BASE_ENDPOINT: &str = \"merchant-account\";\npub const DECISION_ENGINE_MERCHANT_CREATE_ENDPOINT: &str = \"merchant-account/create\";\n\n/// Provides us with all the configured configs of the Merchant in the ascending time configured\n/// manner and chooses the first of them\npub async fn get_merchant_default_config(\n    db: &dyn StorageInterface,\n    // Cannot make this as merchant id domain type because, we are passing profile id also here\n    merchant_id: &str,\n    transaction_type: &storage::enums::TransactionType,\n) -> RouterResult<Vec<routing_types::RoutableConnectorChoice>> {\n    let key = get_default_config_key(merchant_id, transaction_type);\n    let maybe_config = db.find_config_by_key(&key).await;\n\n    match maybe_config {\n        Ok(config) => config\n            .config\n            .parse_struct(\"Vec<RoutableConnectors>\")\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Merchant default config has invalid structure\"),\n\n        Err(e) if e.current_context().is_db_not_found() => {\n            let new_config_conns = Vec::<routing_types::RoutableConnectorChoice>::new();\n            let serialized = new_config_conns\n                .encode_to_string_of_json()\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\n                    \"Error while creating and serializing new merchant default config\",\n                )?;\n\n            let new_config = configs::ConfigNew {\n                key,\n                config: serialized,\n            };\n\n            db.insert_config(new_config)\n                .await\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"Error inserting new default routing config into DB\")?;\n\n            Ok(new_config_conns)\n        }\n\n        Err(e) => Err(e)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Error fetching default config for merchant\"),\n    }\n}\n\n/// Merchant's already created config can be updated and this change will be reflected\n/// in DB as well for the particular updated config\npub async fn update_merchant_default_config(\n    db: &dyn StorageInterface,\n    merchant_id: &str,\n    connectors: Vec<routing_types::RoutableConnectorChoice>,\n    transaction_type: &storage::enums::TransactionType,\n) -> RouterResult<()> {\n    let key = get_default_config_key(merchant_id, transaction_type);\n    let config_str = connectors\n        .encode_to_string_of_json()\n        .change_context(errors::ApiErrorResponse::InternalServerError)",
    "function_name": "get_merchant_default_config",
    "file": "crates__router__src__core__routing__helpers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__nuvei.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\n#[cfg(feature = \"payouts\")]\nuse api_models::webhooks::PayoutIdType;\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    id_type,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        unified_authentication_service::PreAuthenticate,\n        AuthorizeSessionToken, CompleteAuthorize, PostCaptureVoid, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, AuthorizeSessionTokenData, CompleteAuthorizeData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCancelPostCaptureData, PaymentsCaptureData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsAuthorizeSessionTokenRouterData,\n        PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::ExposeInterface;\nuse transformers as nuvei;\n\nuse crate::{\n    connectors::nuvei::transformers::{NuveiPaymentsResponse, NuveiTransactionSyncResponse},\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        self, is_mandate_supported, PaymentMethodDataType, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\n#[derive(Clone)]\npub struct Nuvei {\n    pub amount_convertor: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n    amount_converter_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\nimpl Nuvei {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &StringMajorUnitForConnector,\n            amount_converter_string_minor_unit: &StringMinorUnitForConnector,\n            amount_converter_float_major_unit: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Nuvei\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Nuvei {\n    fn id(&self) -> &'static str {\n        \"nuvei\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.nuvei.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n}\n\nimpl ConnectorValidation for Nuvei {\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nuvei.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs",
    "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        UasAuthenticationConfirmationRouterData, UasAuthenticationRouterData,\n        UasPostAuthenticationRouterData, UasPreAuthenticationRouterData,\n        UasProcessWebhookRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as unified_authentication_service;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct UnifiedAuthenticationService {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl UnifiedAuthenticationService {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for UnifiedAuthenticationService {}\nimpl api::PaymentSession for UnifiedAuthenticationService {}\nimpl api::ConnectorAccessToken for UnifiedAuthenticationService {}\nimpl api::MandateSetup for UnifiedAuthenticationService {}\nimpl api::PaymentAuthorize for UnifiedAuthenticationService {}\nimpl api::PaymentSync for UnifiedAuthenticationService {}\nimpl api::PaymentCapture for UnifiedAuthenticationService {}\nimpl api::PaymentVoid for UnifiedAuthenticationService {}\nimpl api::Refund for UnifiedAuthenticationService {}\nimpl api::RefundExecute for UnifiedAuthenticationService {}\nimpl api::RefundSync for UnifiedAuthenticationService {}\nimpl api::PaymentToken for UnifiedAuthenticationService {}\nimpl api::UnifiedAuthenticationService for UnifiedAuthenticationService {}\nimpl api::UasPreAuthentication for UnifiedAuthenticationService {}\nimpl api::UasPostAuthentication for UnifiedAuthenticationService {}\nimpl api::UasAuthenticationConfirmation for UnifiedAuthenticationService {}\nimpl api::UasAuthentication for UnifiedAuthenticationService {}\nimpl api::UasProcessWebhook for UnifiedAuthenticationService {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for UnifiedAuthenticationService\n{\n}\n\nimpl ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>\n    for UnifiedAuthenticationService\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response>\n    for UnifiedAuthenticationService\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::SOURCE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for UnifiedAuthenticationService {\n    fn id(&self) -> &'static str {\n        \"unified_authentication_service\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.unified_authentication_service.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: unified_authentication_service::UnifiedAuthenticationServiceErrorResponse =",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__chargebee.rs",
    "code": "pub mod transformers;\n\nuse api_models::subscription::SubscriptionItemType;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{revenue_recovery, router_data_v2::RouterDataV2};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::flow_common_types::{\n        GetSubscriptionItemPricesData, GetSubscriptionItemsData, SubscriptionCreateData,\n        SubscriptionCustomerData,\n    },\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery::InvoiceRecordBack,\n        subscriptions::{\n            GetSubscriptionEstimate, GetSubscriptionItemPrices, GetSubscriptionItems,\n            SubscriptionCancel, SubscriptionCreate, SubscriptionPause, SubscriptionResume,\n        },\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        revenue_recovery::InvoiceRecordBackRequest,\n        subscriptions::{\n            GetSubscriptionEstimateRequest, GetSubscriptionItemPricesRequest,\n            GetSubscriptionItemsRequest, SubscriptionCancelRequest, SubscriptionCreateRequest,\n            SubscriptionPauseRequest, SubscriptionResumeRequest,\n        },\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n            GetSubscriptionEstimateResponse, GetSubscriptionItemPricesResponse,\n            GetSubscriptionItemsResponse, SubscriptionCancelResponse, SubscriptionCreateResponse,\n            SubscriptionPauseResponse, SubscriptionResumeResponse,\n        },\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, GetSubscriptionEstimateRouterData,\n        GetSubscriptionItemsRouterData, GetSubscriptionPlanPricesRouterData,\n        InvoiceRecordBackRouterData, PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SubscriptionCancelRouterData, SubscriptionCreateRouterData, SubscriptionPauseRouterData,\n        SubscriptionResumeRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        payments::ConnectorCustomer,\n        subscriptions_v2::{GetSubscriptionPlanPricesV2, GetSubscriptionPlansV2},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    connector_integration_v2::ConnectorIntegrationV2,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as chargebee;\n\nuse crate::{\n    connectors::chargebee::transformers::{\n        ChargebeeGetPlanPricesResponse, ChargebeeListPlansResponse,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils,\n};\n\n#[derive(Clone)]\npub struct Chargebee {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Chargebee {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\nimpl ConnectorCustomer for Chargebee {}\nimpl api::Payment for Chargebee {}\nimpl api::PaymentSession for Chargebee {}\nimpl api::ConnectorAccessToken for Chargebee {}\nimpl api::MandateSetup for Chargebee {}\nimpl api::PaymentAuthorize for Chargebee {}\nimpl api::PaymentSync for Chargebee {}\nimpl api::PaymentCapture for Chargebee {}\nimpl api::PaymentVoid for Chargebee {}\nimpl api::Refund for Chargebee {}\nimpl api::RefundExecute for Chargebee {}\nimpl api::RefundSync for Chargebee {}\nimpl api::PaymentToken for Chargebee {}\nimpl api::subscriptions::Subscriptions for Chargebee {}\n\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nimpl api::revenue_recovery::RevenueRecoveryRecordBack for Chargebee {}\n\nfn build_chargebee_url<Flow, Request, Response>(\n    connector: &Chargebee,\n    req: &RouterData<Flow, Request, Response>,\n    connectors: &Connectors,\n    path: &str,\n) -> CustomResult<String, errors::ConnectorError> {\n    let metadata: chargebee::ChargebeeMetadata =\n        utils::to_connector_meta_from_secret(req.connector_meta_data.clone())?;\n\n    let site = metadata.site.peek();\n    let mut base = connector.base_url(connectors).to_string();\n\n    base = base.replace(\"{{merchant_endpoint_prefix}}\", site);\n    base = base.replace(\"$\", site);\n\n    if base.contains(\"{{merchant_endpoint_prefix}}\") || base.contains('$') {\n        return Err(errors::ConnectorError::InvalidConnectorConfig {\n            config: \"Chargebee base_url has an unresolved placeholder\",\n        }\n        .into());\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__chargebee.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__noon__transformers.rs",
    "code": "use common_enums::enums::{self, AttemptStatus};\nuse common_utils::{ext_traits::Encode, pii, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::{MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, GooglePayWalletData, PaymentsAuthorizeRequestData,\n        RevokeMandateRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\n#[derive(Debug, Serialize)]\npub struct NoonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    pub mandate_amount: Option<StringMajorUnit>,\n}\n\nimpl<T> From<(StringMajorUnit, T, Option<StringMajorUnit>)> for NoonRouterData<T> {\n    fn from(\n        (amount, router_data, mandate_amount): (StringMajorUnit, T, Option<StringMajorUnit>),\n    ) -> Self {\n        Self {\n            amount,\n            router_data,\n            mandate_amount,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonChannels {\n    Web,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonSubscriptionType {\n    Unscheduled,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonSubscriptionData {\n    #[serde(rename = \"type\")]\n    subscription_type: NoonSubscriptionType,\n    //Short description about the subscription.\n    name: String,\n    max_amount: StringMajorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonBillingAddress {\n    street: Option<Secret<String>>,\n    street2: Option<Secret<String>>,\n    city: Option<String>,\n    state_province: Option<Secret<String>>,\n    country: Option<api_models::enums::CountryAlpha2>,\n    postal_code: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonBilling {\n    address: NoonBillingAddress,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonOrder {\n    amount: StringMajorUnit,\n    currency: Option<enums::Currency>,\n    channel: NoonChannels,\n    category: Option<String>,\n    reference: String,\n    //Short description of the order.\n    name: String,\n    nvp: Option<NoonOrderNvp>,\n    ip_address: Option<Secret<String, pii::IpAddress>>,\n}\n\n#[derive(Debug, Serialize)]\npub struct NoonOrderNvp {\n    #[serde(flatten)]\n    inner: std::collections::BTreeMap<String, Secret<String>>,\n}\n\nfn get_value_as_string(value: &serde_json::Value) -> String {\n    match value {\n        serde_json::Value::String(string) => string.to_owned(),\n        serde_json::Value::Null\n        | serde_json::Value::Bool(_)\n        | serde_json::Value::Number(_)\n        | serde_json::Value::Array(_)\n        | serde_json::Value::Object(_) => value.to_string(),\n    }\n}\n\nimpl NoonOrderNvp {\n    pub fn new(metadata: &serde_json::Value) -> Self {\n        let metadata_as_string = metadata.to_string();\n        let hash_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_str(&metadata_as_string).unwrap_or(std::collections::BTreeMap::new());\n        let inner = hash_map\n            .into_iter()\n            .enumerate()\n            .map(|(index, (hs_key, hs_value))| {\n                let noon_key = format!(\"{}\", index + 1);\n                // to_string() function on serde_json::Value returns a string with \"\" quotes. Noon doesn't allow this. Hence get_value_as_string function\n                let noon_value = format!(\"{hs_key}={}\", get_value_as_string(&hs_value));\n                (noon_key, Secret::new(noon_value))\n            })\n            .collect();\n        Self { inner }\n    }\n}",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{self, ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        self, PaymentsCancelRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\npub struct TsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for TsysRouterData<T> {\n    fn from((amount, router_data): (StringMinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RefundsRequestData as _},\n};\n\n#[derive(Debug, Serialize)]\npub enum TsysPaymentsRequest {\n    Auth(TsysPaymentAuthSaleRequest),\n    Sale(TsysPaymentAuthSaleRequest),\n}\n\n#[derive(Default, Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TsysPaymentAuthSaleRequest {\n    #[serde(rename = \"deviceID\")]\n    device_id: Secret<String>,\n    transaction_key: Secret<String>,\n    card_data_source: String,\n    transaction_amount: StringMinorUnit,\n    currency_code: enums::Currency,\n    card_number: cards::CardNumber,\n    expiration_date: Secret<String>,\n    cvv2: Secret<String>,\n    order_number: String,\n    terminal_capability: String,\n    terminal_operating_environment: String,\n    cardholder_authentication_method: String,\n    #[serde(rename = \"developerID\")]\n    developer_id: Secret<String>,\n}\n\nimpl TryFrom<&TsysRouterData<&types::PaymentsAuthorizeRouterData>> for TsysPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item_data: &TsysRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let item = item_data.router_data.clone();\n        match item.request.payment_method_data.clone() {\n            PaymentMethodData::Card(ccard) => {\n                let connector_auth: TsysAuthType =\n                    TsysAuthType::try_from(&item.connector_auth_type)?;\n                let auth_data: TsysPaymentAuthSaleRequest = TsysPaymentAuthSaleRequest {\n                    device_id: connector_auth.device_id,\n                    transaction_key: connector_auth.transaction_key,\n                    card_data_source: \"INTERNET\".to_string(),\n                    transaction_amount: item_data.amount.clone(),\n                    currency_code: item.request.currency,\n                    card_number: ccard.card_number.clone(),\n                    expiration_date: ccard\n                        .get_card_expiry_month_year_2_digit_with_delimiter(\"/\".to_owned())?,\n                    cvv2: ccard.card_cvc,\n                    order_number: item.connector_request_reference_id.clone(),\n                    terminal_capability: \"ICC_CHIP_READ_ONLY\".to_string(),\n                    terminal_operating_environment: \"ON_MERCHANT_PREMISES_ATTENDED\".to_string(),\n                    cardholder_authentication_method: \"NOT_AUTHENTICATED\".to_string(),\n                    developer_id: connector_auth.developer_id,\n                };\n                if item.request.is_auto_capture()? {\n                    Ok(Self::Sale(auth_data))\n                } else {\n                    Ok(Self::Auth(auth_data))\n                }\n            }\n            PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::Wallet(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)\n            | PaymentMethodData::Crypto(_)\n            | PaymentMethodData::MandatePayment\n            | PaymentMethodData::Reward\n            | PaymentMethodData::RealTimePayment(_)\n            | PaymentMethodData::MobilePayment(_)\n            | PaymentMethodData::Upi(_)\n            | PaymentMethodData::Voucher(_)\n            | PaymentMethodData::GiftCard(_)\n            | PaymentMethodData::OpenBanking(_)\n            | PaymentMethodData::CardToken(_)\n            | PaymentMethodData::NetworkToken(_)\n            | PaymentMethodData::CardDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::CardWithLimitedDetails(_)\n            | PaymentMethodData::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::NetworkTokenDetailsForNetworkTransactionId(_) => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"tsys\"),\n                ))?\n            }\n        }\n    }\n}\n\n// Auth Struct\npub struct TsysAuthType {\n    pub(super) device_id: Secret<String>,\n    pub(super) transaction_key: Secret<String>,\n    pub(super) developer_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for TsysAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                device_id: api_key.to_owned(),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__tsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask as _, Maskable};\n\nuse self::transformers as wellsfargopayout;\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Wellsfargopayout {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Wellsfargopayout {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Wellsfargopayout {}\nimpl api::PaymentSession for Wellsfargopayout {}\nimpl api::ConnectorAccessToken for Wellsfargopayout {}\nimpl api::MandateSetup for Wellsfargopayout {}\nimpl api::PaymentAuthorize for Wellsfargopayout {}\nimpl api::PaymentSync for Wellsfargopayout {}\nimpl api::PaymentCapture for Wellsfargopayout {}\nimpl api::PaymentVoid for Wellsfargopayout {}\nimpl api::Refund for Wellsfargopayout {}\nimpl api::RefundExecute for Wellsfargopayout {}\nimpl api::RefundSync for Wellsfargopayout {}\nimpl api::PaymentToken for Wellsfargopayout {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Wellsfargopayout\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargopayout\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Wellsfargopayout {\n    fn id(&self) -> &'static str {\n        \"wellsfargopayout\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        // todo!()\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.wellsfargopayout.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = wellsfargopayout::WellsfargopayoutAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: wellsfargopayout::WellsfargopayoutErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargopayoutErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__forte.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Forte {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Forte {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Forte {}\nimpl api::PaymentSession for Forte {}\nimpl api::ConnectorAccessToken for Forte {}\nimpl api::MandateSetup for Forte {}\nimpl api::PaymentAuthorize for Forte {}\nimpl api::PaymentSync for Forte {}\nimpl api::PaymentCapture for Forte {}\nimpl api::PaymentVoid for Forte {}\nimpl api::Refund for Forte {}\nimpl api::RefundExecute for Forte {}\nimpl api::RefundSync for Forte {}\nimpl api::PaymentToken for Forte {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Forte\n{\n}\npub const AUTH_ORG_ID_HEADER: &str = \"X-Forte-Auth-Organization-Id\";\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Forte\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let content_type = ConnectorCommon::common_get_content_type(self);\n        let mut common_headers = self.get_auth_header(&req.connector_auth_type)?;\n        common_headers.push((\n            headers::CONTENT_TYPE.to_string(),\n            content_type.to_string().into(),\n        ));\n        Ok(common_headers)\n    }\n}\n\nimpl ConnectorCommon for Forte {\n    fn id(&self) -> &'static str {\n        \"forte\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.forte.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = forte::ForteAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let raw_basic_token = format!(\n            \"{}:{}\",\n            auth.api_access_id.peek(),\n            auth.api_secret_key.peek()\n        );\n        let basic_token = format!(\"Basic {}\", BASE64_ENGINE.encode(raw_basic_token));\n        Ok(vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                basic_token.into_masked(),\n            ),\n            (\n                AUTH_ORG_ID_HEADER.to_string(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__forte.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, SignMessage},\n    date_time,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hex::encode;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers as dlocal;\n\nuse crate::{\n    connectors::dlocal::transformers::DlocalRouterData, constants::headers,\n    types::ResponseRouterData, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Dlocal {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Dlocal {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Dlocal {}\nimpl api::PaymentToken for Dlocal {}\nimpl api::PaymentSession for Dlocal {}\nimpl api::ConnectorAccessToken for Dlocal {}\nimpl api::MandateSetup for Dlocal {}\nimpl api::PaymentAuthorize for Dlocal {}\nimpl api::PaymentSync for Dlocal {}\nimpl api::PaymentCapture for Dlocal {}\nimpl api::PaymentVoid for Dlocal {}\nimpl api::Refund for Dlocal {}\nimpl api::RefundExecute for Dlocal {}\nimpl api::RefundSync for Dlocal {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Dlocal\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let dlocal_req = self.get_request_body(req, connectors)?;\n        let date = date_time::date_as_yyyymmddthhmmssmmmz()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let auth = dlocal::DlocalAuthType::try_from(&req.connector_auth_type)?;\n\n        let sign_req: String = if dlocal_req.get_inner_value().peek() == r#\"\"{}\"\"# {\n            format!(\"{}{}\", auth.x_login.peek(), date)\n        } else {\n            format!(\n                \"{}{}{}\",\n                auth.x_login.peek(),\n                date,\n                dlocal_req.get_inner_value().peek()\n            )\n        };\n\n        let authz = crypto::HmacSha256::sign_message(\n            &crypto::HmacSha256,\n            auth.secret.peek().as_bytes(),\n            sign_req.as_bytes(),\n        )\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"Failed to sign the message\")?;\n        let auth_string: String = format!(\"V2-HMAC-SHA256, Signature: {}\", encode(authz));\n        let headers = vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                auth_string.into_masked(),\n            ),\n            (headers::X_LOGIN.to_string(), auth.x_login.into_masked()),\n            (\n                headers::X_TRANS_KEY.to_string(),\n                auth.x_trans_key.into_masked(),\n            ),\n            (headers::X_VERSION.to_string(), \"2.1\".to_string().into()),\n            (headers::X_DATE.to_string(), date.into()),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Dlocal {\n    fn id(&self) -> &'static str {\n        \"dlocal\"\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__dlocal.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://webservices.apl02.redsys.es\";\npub const REDSYS_SOAP_ACTION: &str = \"consultaOperaciones\";\n\n// Specifies the type of transaction for XML requests\npub mod transaction_type {\n    pub const PAYMENT: &str = \"0\";\n    pub const PREAUTHORIZATION: &str = \"1\";\n    pub const CONFIRMATION: &str = \"2\";\n    pub const REFUND: &str = \"3\";\n    pub const CANCELLATION: &str = \"9\";\n}\n\npub struct RedsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub currency: api_models::enums::Currency,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T, api_models::enums::Currency)> for RedsysRouterData<T> {\n    fn from((amount, item, currency): (StringMinorUnit, T, api_models::enums::Currency)) -> Self {\n        Self {\n            amount,\n            currency,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub struct PaymentsRequest {\n    ds_merchant_amount: StringMinorUnit,\n    ds_merchant_currency: String,\n    ds_merchant_cvv2: Secret<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    ds_merchant_emv3ds: Option<EmvThreedsData>,\n    ds_merchant_expirydate: Secret<String>,\n    ds_merchant_merchantcode: Secret<String>,\n    ds_merchant_order: String,\n    ds_merchant_pan: cards::CardNumber,\n    ds_merchant_terminal: Secret<String>,\n    ds_merchant_transactiontype: RedsysTransactionType,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EmvThreedsData {\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    billing_data: Option<BillingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_accept_header: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_color_depth: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_i_p: Option<Secret<String, common_utils::pii::IpAddress>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_java_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_javascript_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_language: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_height: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_width: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_t_z: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_user_agent: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    cres: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    notification_u_r_l: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    protocol_version: Option<String>,\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    shipping_data: Option<ShippingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    three_d_s_comp_ind: Option<ThreeDSCompInd>,\n    three_d_s_info: RedsysThreeDsInfo,\n    #[serde(\n        alias = \"threeds_server_transaction_id\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    three_d_s_server_trans_i_d: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingData {\n    #[serde(skip_serializing_if = \"Option::is_none\")]",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__bitpay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as bitpay;\n\nuse self::bitpay::BitpayWebhookDetails;\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Bitpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bitpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bitpay {}\nimpl api::PaymentToken for Bitpay {}\nimpl api::PaymentSession for Bitpay {}\nimpl api::ConnectorAccessToken for Bitpay {}\nimpl api::MandateSetup for Bitpay {}\nimpl api::PaymentAuthorize for Bitpay {}\nimpl api::PaymentSync for Bitpay {}\nimpl api::PaymentCapture for Bitpay {}\nimpl api::PaymentVoid for Bitpay {}\nimpl api::Refund for Bitpay {}\nimpl api::RefundExecute for Bitpay {}\nimpl api::RefundSync for Bitpay {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Bitpay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bitpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\n                headers::X_ACCEPT_VERSION.to_string(),\n                \"2.0.0\".to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bitpay {\n    fn id(&self) -> &'static str {\n        \"bitpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bitpay.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bitpay::BitpayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bitpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__router_response_types.rs",
    "code": "pub mod disputes;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\nuse std::collections::HashMap;\n\nuse api_models::payments::AddressDetails;\nuse common_utils::{pii, request::Method, types::MinorUnit};\npub use disputes::{\n    AcceptDisputeResponse, DefendDisputeResponse, DisputeSyncResponse, FetchDisputesResponse,\n    SubmitEvidenceResponse,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    errors::api_error_response::ApiErrorResponse,\n    router_request_types::{authentication::AuthNFlowType, ResponseId, UcsAuthenticationData},\n    vault::PaymentMethodVaultingData,\n};\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct RefundsResponseData {\n    pub connector_refund_id: String,\n    pub refund_status: common_enums::RefundStatus,\n    // pub amount_received: Option<i32>, // Calculation for amount received not in place yet\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConnectorCustomerResponseData {\n    pub connector_customer_id: String,\n    pub name: Option<String>,\n    pub email: Option<String>,\n    pub billing_address: Option<AddressDetails>,\n}\n\nimpl ConnectorCustomerResponseData {\n    pub fn new_with_customer_id(connector_customer_id: String) -> Self {\n        Self::new(connector_customer_id, None, None, None)\n    }\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct GiftCardBalanceCheckResponseData {\n    pub balance: MinorUnit,\n    pub currency: common_enums::Currency,\n}\n\n#[derive(Debug, Clone)]\npub struct TaxCalculationResponseData {\n    pub order_tax_amount: MinorUnit,\n}\n\n#[derive(Serialize, Debug, Clone, serde::Deserialize)]\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum CaptureSyncResponse {\n    Success {",
    "function_name": "new_with_customer_id",
    "file": "crates__hyperswitch_domain_models__src__router_response_types.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse api_models::{\n    self,\n    payouts::{BankRedirect, PayoutMethodData},\n};\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    id_type,\n    pii::{self, Email, IpAddress},\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        InteracCustomerInfo, RouterData,\n    },\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::PoQuote, router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::{types::PayoutsResponseRouterData, utils::PayoutsData as _};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, BrowserInformationData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\npub struct GigadatRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GigadatRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst CONNECTOR_BASE_URL: &str = \"https://interac.express-connect.com/\";\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct GigadatConnectorMetadataObject {\n    pub site: String,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for GigadatConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"merchant_connector_account.metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n// CPI (Combined Pay-in) Request Structure for Gigadat\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GigadatCpiRequest {\n    pub user_id: id_type::CustomerId,\n    pub site: String,\n    pub user_ip: Secret<String, IpAddress>,\n    pub currency: Currency,\n    pub amount: FloatMajorUnit,\n    pub transaction_id: String,\n    #[serde(rename = \"type\")]\n    pub transaction_type: GidadatTransactionType,\n    pub sandbox: bool,\n    pub name: Secret<String>,\n    pub email: Email,\n    pub mobile: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum GidadatTransactionType {\n    Cpi,\n    Eto,\n}\n\nimpl TryFrom<&GigadatRouterData<&PaymentsAuthorizeRouterData>> for GigadatCpiRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &GigadatRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let metadata: GigadatConnectorMetadataObject =\n            utils::to_connector_meta_from_secret(item.router_data.connector_meta_data.clone())\n                .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"merchant_connector_account.metadata\",\n                })?;\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::BankRedirect(BankRedirectData::Interac { .. }) => {\n                let router_data = item.router_data;\n                let name = router_data.get_billing_full_name()?;\n                let email = router_data.get_billing_email()?;\n                let mobile = router_data.get_billing_phone_number()?;\n                let currency = item.router_data.request.currency;\n                let sandbox = match item.router_data.test_mode {\n                    Some(true) => true,\n                    Some(false) | None => false,\n                };\n                let user_ip = router_data.request.get_browser_info()?.get_ip_address()?;\n                Ok(Self {\n                    user_id: router_data.get_customer_id()?,\n                    site: metadata.site,\n                    user_ip,\n                    currency,\n                    amount: item.amount,\n                    transaction_id: router_data.connector_request_reference_id.clone(),\n                    transaction_type: GidadatTransactionType::Cpi,\n                    name,\n                    sandbox,\n                    email,\n                    mobile,\n                })\n            }\n            PaymentMethodData::BankRedirect(_) => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),\n            ))?,\n\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__storage_impl__src__merchant_connector_account.rs",
    "code": "use async_bb8_diesel::AsyncConnection;\nuse common_utils::{encryption::Encryption, ext_traits::AsyncExt};\nuse diesel_models::merchant_connector_account as storage;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_connector_account::{self as domain, MerchantConnectorAccountInterface},\n    merchant_key_store::MerchantKeyStore,\n};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"accounts_cache\")]\nuse crate::redis::cache;\nuse crate::{\n    kv_router_store,\n    utils::{pg_accounts_connection_read, pg_accounts_connection_write},\n    CustomResult, DatabaseStore, MockDb, RouterStore, StorageError,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> MerchantConnectorAccountInterface for kv_router_store::KVRouterStore<T> {\n    type Error = StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n",
    "function_name": "find_merchant_connector_account_by_merchant_id_connector_label",
    "file": "crates__storage_impl__src__merchant_connector_account.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__fiuu.rs",
    "code": "pub mod transformers;\n\nuse std::{\n    any::type_name,\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    sync::LazyLock,\n};\n\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::{self as common_errors, CustomResult},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::multipart::Form;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse transformers::{self as fiuu, ExtraParameters, FiuuWebhooksResponse};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentMethodDataType},\n};\n\npub fn parse_and_log_keys_in_url_encoded_response<T>(data: &[u8]) {\n    match std::str::from_utf8(data) {\n        Ok(query_str) => {\n            let loggable_keys = [\n                \"status\",\n                \"orderid\",\n                \"tranID\",\n                \"nbcb\",\n                \"amount\",\n                \"currency\",\n                \"paydate\",\n                \"channel\",\n                \"error_desc\",\n                \"error_code\",\n                \"extraP\",\n            ];\n            let keys: Vec<(Cow<'_, str>, String)> =\n                url::form_urlencoded::parse(query_str.as_bytes())\n                    .map(|(key, value)| {\n                        if loggable_keys.contains(&key.to_string().as_str()) {\n                            (key, value.to_string())\n                        } else {\n                            (key, \"SECRET\".to_string())\n                        }\n                    })\n                    .collect();\n            router_env::logger::info!(\"Keys in {} response\\n{:?}\", type_name::<T>(), keys);\n        }\n        Err(err) => {\n            router_env::logger::error!(\"Failed to convert bytes to string: {:?}\", err);\n        }\n    }\n}\n\nfn parse_response<T>(data: &[u8]) -> Result<T, errors::ConnectorError>\nwhere\n    T: for<'de> Deserialize<'de>,\n{\n    let response_str = String::from_utf8(data.to_vec()).map_err(|e| {\n        router_env::logger::error!(\"Error in Deserializing Response Data: {:?}\", e);\n        errors::ConnectorError::ResponseDeserializationFailed\n    })?;\n\n    let mut json = serde_json::Map::new();\n    let mut miscellaneous: HashMap<String, Secret<String>> = HashMap::new();\n\n    for line in response_str.lines() {\n        if let Some((key, value)) = line.split_once('=') {\n            if key.trim().is_empty() {\n                router_env::logger::error!(\"Null or empty key encountered in response.\");\n                continue;\n            }\n\n            if let Some(old_value) = json.insert(key.to_string(), Value::String(value.to_string()))\n            {\n                router_env::logger::warn!(\"Repeated key encountered: {}\", key);\n                miscellaneous.insert(key.to_string(), Secret::new(old_value.to_string()));\n            }\n        }\n    }\n    if !miscellaneous.is_empty() {\n        let misc_value = serde_json::to_value(miscellaneous).map_err(|e| {\n            router_env::logger::error!(\"Error serializing miscellaneous data: {:?}\", e);\n            errors::ConnectorError::ResponseDeserializationFailed\n        })?;\n        json.insert(\"miscellaneous\".to_string(), misc_value);\n    }\n\n    // TODO: Remove this after debugging\n    let loggable_keys = [\n        \"StatCode\",\n        \"StatName\",\n        \"TranID\",\n        \"ErrorCode\",\n        \"ErrorDesc\",\n        \"miscellaneous\",\n    ];",
    "function_name": "parse_and_log_keys_in_url_encoded_response",
    "file": "crates__hyperswitch_connectors__src__connectors__fiuu.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__checkbook.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{enums, payments::PaymentIdType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as checkbook;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Checkbook {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Checkbook {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Checkbook {}\nimpl api::PaymentSession for Checkbook {}\nimpl api::ConnectorAccessToken for Checkbook {}\nimpl api::MandateSetup for Checkbook {}\nimpl api::PaymentAuthorize for Checkbook {}\nimpl api::PaymentSync for Checkbook {}\nimpl api::PaymentCapture for Checkbook {}\nimpl api::PaymentVoid for Checkbook {}\nimpl api::Refund for Checkbook {}\nimpl api::RefundExecute for Checkbook {}\nimpl api::RefundSync for Checkbook {}\nimpl api::PaymentToken for Checkbook {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Checkbook\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Checkbook\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Checkbook {\n    fn id(&self) -> &'static str {\n        \"checkbook\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.checkbook.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = checkbook::CheckbookAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.publishable_key.expose(),\n            auth.secret_key.expose()\n        );\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__checkbook.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    ApplePayRecurringDetails, ApplePayRegularBillingDetails, FeatureMetadata,\n    OrderDetailsWithAmount, RecurringPaymentIntervalUnit, RedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{\n    BillingConnectorAdditionalCardInfo, BillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails, PaymentRevenueRecoveryMetadata,\n};\n\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize)]\npub enum RemoteStorageObject<T: ForeignIDRef> {\n    ForeignID(String),\n    Object(T),\n}\n\nimpl<T: ForeignIDRef> From<T> for RemoteStorageObject<T> {\n    fn from(value: T) -> Self {\n        Self::Object(value)\n    }\n}\n\npub trait ForeignIDRef {\n    fn foreign_id(&self) -> String;\n}\n\nimpl<T: ForeignIDRef> RemoteStorageObject<T> {\n    pub fn get_id(&self) -> String {\n        match self {\n            Self::ForeignID(id) => id.clone(),\n            Self::Object(i) => i.foreign_id(),\n        }\n    }\n}\n\nuse std::fmt::Debug;\n\npub trait ApiModelToDieselModelConvertor<F> {\n    /// Convert from a foreign type to the current type\n    fn convert_from(from: F) -> Self;\n    fn convert_back(self) -> F;\n}\n\n#[cfg(feature = \"v1\")]\nimpl ApiModelToDieselModelConvertor<ApiFeatureMetadata> for FeatureMetadata {\n    fn convert_from(from: ApiFeatureMetadata) -> Self {\n        let ApiFeatureMetadata {\n            redirect_response,\n            search_tags,\n            apple_pay_recurring_details,\n            pix_additional_details,\n            boleto_additional_details,\n            ..\n        } = from;\n\n        Self {\n            redirect_response: redirect_response.map(RedirectResponse::convert_from),\n            search_tags,\n            apple_pay_recurring_details: apple_pay_recurring_details\n                .map(ApplePayRecurringDetails::convert_from),\n            gateway_system: None,\n            pix_additional_details: pix_additional_details\n                .map(diesel_models::types::PixAdditionalDetails::convert_from),\n            boleto_additional_details: boleto_additional_details\n                .map(diesel_models::types::BoletoAdditionalDetails::convert_from),\n        }\n    }\n\n    fn convert_back(self) -> ApiFeatureMetadata {\n        let Self {",
    "function_name": "from",
    "file": "crates__hyperswitch_domain_models__src__lib.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use common_enums::enums;\nuse common_utils::types::MinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{RefundsData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub struct BamboraapacRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for BamboraapacRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BamboraapacMeta {\n    pub authorize_id: String,\n}\n\n// request body in soap format\npub fn get_payment_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<Vec<u8>, Error> {\n    let transaction_data = get_transaction_body(req)?;\n    let body = format!(\n        r#\"\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n            xmlns:dts=\"http://www.ippayments.com.au/interface/api/dts\">\n                <soapenv:Body>\n                    <dts:SubmitSinglePayment>\n                        <dts:trnXML>\n                            <![CDATA[\n                                {transaction_data}\n                            ]]>\n                        </dts:trnXML>\n                    </dts:SubmitSinglePayment>\n                </soapenv:Body>\n            </soapenv:Envelope>\n        \"#,\n    );\n\n    Ok(body.as_bytes().to_vec())\n}\n\nfn get_transaction_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<String, Error> {\n    let auth_details = BamboraapacAuthType::try_from(&req.router_data.connector_auth_type)?;\n    let transaction_type = get_transaction_type(req.router_data.request.capture_method)?;\n    let card_info = get_card_data(req.router_data)?;\n    let transaction_data = format!(\n        r#\"\n        <Transaction>\n            <CustRef>{}</CustRef>\n            <Amount>{}</Amount>\n            <TrnType>{}</TrnType>\n            <AccountNumber>{}</AccountNumber>\n            {}\n            <Security>\n                    <UserName>{}</UserName>\n                    <Password>{}</Password>\n            </Security>\n        </Transaction>\n    \"#,\n        req.router_data.connector_request_reference_id.to_owned(),\n        req.amount,\n        transaction_type,\n        auth_details.account_number.peek(),\n        card_info,\n        auth_details.username.peek(),\n        auth_details.password.peek(),\n    );\n\n    Ok(transaction_data)\n}\n\nfn get_card_data(req: &types::PaymentsAuthorizeRouterData) -> Result<String, Error> {\n    let card_data = match &req.request.payment_method_data {\n        PaymentMethodData::Card(card) => {\n            if req.is_three_ds() {\n                Err(errors::ConnectorError::NotSupported {\n                    message: \"Cards 3DS\".to_string(),\n                    connector: \"Bamboraapac\",\n                })?\n            }\n            let card_holder_name = req.get_billing_full_name()?;\n\n            if req.request.setup_future_usage == Some(enums::FutureUsage::OffSession) {\n                format!(\n                    r#\"\n                    <CreditCard Registered=\"False\">\n                        <TokeniseAlgorithmID>2</TokeniseAlgorithmID>\n                        <CardNumber>{}</CardNumber>\n                        <ExpM>{}</ExpM>\n                        <ExpY>{}</ExpY>\n                        <CVN>{}</CVN>\n                        <CardHolderName>{}</CardHolderName>\n                    </CreditCard>\n                \"#,\n                    card.card_number.get_card_no(),\n                    card.card_exp_month.peek(),\n                    card.get_expiry_year_4_digit().peek(),\n                    card.card_cvc.peek(),\n                    card_holder_name.peek(),\n                )\n            } else {\n                format!(\n                    r#\"\n                    <CreditCard Registered=\"False\">\n                        <CardNumber>{}</CardNumber>\n                        <ExpM>{}</ExpM>\n                        <ExpY>{}</ExpY>",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__api_models__src__authentication.rs",
    "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__authentication.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__api_models__src__authentication.rs",
    "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__authentication.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__bankofamerica__transformers.rs",
    "code": "use base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{consts, ext_traits::OptionExt, pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, GooglePayWalletData, PaymentMethodData, SamsungPayWalletData,\n        WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\npub struct BankOfAmericaAuthType {\n    pub(super) api_key: Secret<String>,\n    pub(super) merchant_account: Secret<String>,\n    pub(super) api_secret: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for BankOfAmericaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                api_key: api_key.to_owned(),\n                merchant_account: key1.to_owned(),\n                api_secret: api_secret.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\npub struct BankOfAmericaRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for BankOfAmericaRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaPaymentsRequest {\n    processing_information: ProcessingInformation,\n    payment_information: PaymentInformation,\n    order_information: OrderInformationWithBill,\n    client_reference_information: ClientReferenceInformation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    consumer_authentication_information: Option<BankOfAmericaConsumerAuthInformation>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    merchant_defined_information: Option<Vec<MerchantDefinedInformation>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProcessingInformation {\n    action_list: Option<Vec<BankOfAmericaActionsList>>,\n    action_token_types: Option<Vec<BankOfAmericaActionsTokenType>>,\n    authorization_options: Option<BankOfAmericaAuthorizationOptions>,\n    commerce_indicator: String,\n    capture: Option<bool>,\n    capture_options: Option<CaptureOptions>,\n    payment_solution: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum BankOfAmericaActionsList {\n    TokenCreate,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum BankOfAmericaActionsTokenType {\n    PaymentInstrument,\n    Customer,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaAuthorizationOptions {\n    initiator: Option<BankOfAmericaPaymentInitiator>,\n    merchant_initiated_transaction: Option<MerchantInitiatedTransaction>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaPaymentInitiator {\n    #[serde(rename = \"type\")]\n    initiator_type: Option<BankOfAmericaPaymentInitiatorTypes>,\n    credential_stored_on_file: Option<bool>,\n    stored_credential_used: Option<bool>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum BankOfAmericaPaymentInitiatorTypes {\n    Customer,\n}",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__bankofamerica__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__routes__payment_methods.rs",
    "code": "#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse std::collections::HashMap;\n\nuse ::payment_methods::{\n    controller::PaymentMethodsController,\n    core::{migration, migration::payment_methods::migrate_payment_method},\n};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse actix_multipart::form::MultipartForm;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse common_utils::{errors::CustomResult, id_type, transformers::ForeignFrom};\nuse diesel_models::enums::IntentStatus;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    bulk_tokenization::CardNetworkTokenizeRequest, merchant_key_store::MerchantKeyStore,\n    payment_methods::PaymentMethodCustomerMigrate, transformers::ForeignTryFrom,\n};\nuse router_env::{instrument, logger, tracing, Flow};\n\nuse super::app::{AppState, SessionState};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse crate::core::{\n    customers,\n    payment_methods::{batch_retrieve, tokenize},\n};\nuse crate::{\n    core::{\n        api_locking,\n        errors::{self, utils::StorageErrorExt},\n        payment_methods::{self as payment_methods_routes, cards, migration as update_migration},\n    },\n    services::{self, api, authentication as auth, authorization::permissions::Permission},\n    types::{\n        api::payment_methods::{self, PaymentMethodId},\n        domain,\n        storage::payment_method::PaymentTokenData,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _| async move {\n            Box::pin(cards::get_client_secret_or_add_payment_method(\n                &state,\n                req,\n                auth.platform.get_provider(),\n            ))\n            .await\n        },\n        &auth::HeaderAuth(auth::ApiKeyAuth {\n            allow_connected_scope_operation: true,\n            allow_platform_self_operation: true,\n        }),\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    let api_auth = auth::V2ApiKeyAuth {\n        allow_connected_scope_operation: false,\n        allow_platform_self_operation: false,\n    };\n    let jwt_auth = auth::JWTAuth {\n        permission: Permission::MerchantCustomerRead,\n    };\n    let (auth_type, _api_key_type) =\n        match auth::check_internal_api_key_or_dashboard_auth_no_client_secret(\n            req.headers(),\n            api_auth,\n            jwt_auth,\n            state.conf.internal_merchant_id_profile_id_auth.clone(),\n        ) {\n            Ok(auth) => auth,\n            Err(err) => return api::log_and_return_error_response(error_stack::report!(err)),\n        };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, req_state| async move {\n            Box::pin(payment_methods_routes::create_payment_method(\n                &state,\n                &req_state,\n                req,\n                &auth.platform,\n                &auth.profile,\n            ))\n            .await\n        },\n        &*auth_type,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\n#[instrument(skip_all, fields(flow = ?Flow::NetworkTokenEligibilityCheck))]\npub async fn get_pm_nt_eligibility_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    query: web::Query<payment_methods::NetworkTokenEligibilityRequest>,\n) -> HttpResponse {\n    let flow = Flow::NetworkTokenEligibilityCheck;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        query.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _req_state| async move {\n            Box::pin(payment_methods_routes::get_card_nt_eligibility(\n                &state,\n                req,\n                &auth.platform,\n                &auth.profile,\n            ))\n            .await",
    "function_name": "create_payment_method_api",
    "file": "crates__router__src__routes__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::*,\n    router_request_types::*,\n    router_response_types::*,\n    types::*,\n};\nuse hyperswitch_interfaces::{\n    api::{ConnectorCommonExt, ConnectorIntegration, *},\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::*,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, Maskable};\nuse transformers::*;\n\nuse crate::{\n    connectors::worldpaymodular::transformers::request::{\n        WorldpaymodularPartialRefundRequest, WorldpaymodularPaymentsRequest,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, get_header_key_value, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Worldpaymodular {}\n\nimpl Worldpaymodular {\n    pub const fn new() -> &'static Self {\n        &Self {}\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpaymodular\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut api_key);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Worldpaymodular {\n    fn id(&self) -> &'static str {\n        \"worldpaymodular\"\n    }\n\n    fn get_currency_unit(&self) -> CurrencyUnit {\n        CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/vnd.worldpay.payments-v7+json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.worldpaymodular.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = WorldpaymodularAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response = if !res.response.is_empty() {\n            res.response\n                .parse_struct(\"WorldpaymodularErrorResponse\")\n                .change_context(ConnectorError::ResponseDeserializationFailed)?\n        } else {\n            WorldpaymodularErrorResponse::default(res.status_code)\n        };\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_name,\n            message: response.message,\n            reason: response.validation_errors.map(|e| e.to_string()),\n            attempt_status: Some(enums::AttemptStatus::Failure),\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n\nimpl ConnectorValidation for Worldpaymodular {\n    fn validate_mandate_payment(",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{self, RefundsResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _},\n};\n\nconst NO_REFUND_REASON: &str = \"No reason provided\";\n\n//TODO: Fill the struct with respective fields\npub struct PayjustnowRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayjustnowRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowPaymentsRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    request_id: Option<String>,\n    payjustnow: PayjustnowRequest,\n    checkout_total_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowRequest {\n    merchant_order_reference: String,\n    order_amount_cents: MinorUnit,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    order_items: Option<Vec<OrderItem>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer: Option<Customer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<Address>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shipping_address: Option<Address>,\n    confirm_redirect_url: String,\n    cancel_redirect_url: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OrderItem {\n    name: String,\n    sku: String,\n    quantity: u32,\n    price_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Customer {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    first_name: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    last_name: Option<Secret<String>>,\n    email: pii::Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    phone_number: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Address {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    address_line1: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    address_line2: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    city: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    province: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    postal_code: Option<Secret<String>>,\n}\n\nimpl Address {\n    fn is_empty(&self) -> bool {\n        self.address_line1.is_none()\n            && self.address_line2.is_none()\n            && self.city.is_none()\n            && self.province.is_none()\n            && self.postal_code.is_none()\n    }\n}\n\nimpl TryFrom<&PayjustnowRouterData<&PaymentsAuthorizeRouterData>> for PayjustnowPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &PayjustnowRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let router_data = item.router_data;\n        let order_items = router_data\n            .request\n            .order_details\n            .as_ref()\n            .map(|order_details| {\n                order_details\n                    .iter()\n                    .map(|order| {\n                        Ok(OrderItem {\n                            name: order.product_name.clone(),\n                            sku: order.product_id.clone().unwrap_or_default(),\n                            quantity: u32::from(order.quantity),\n                            price_cents: order.amount,\n                        })\n                    })\n                    .collect::<Result<Vec<OrderItem>, errors::ConnectorError>>()\n            })\n            .transpose()?;\n\n        let customer = router_data\n            .get_optional_billing_email()\n            .or_else(|| item.router_data.request.email.clone())\n            .map(|email| Customer {",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Flexiti {}\nimpl api::PaymentSession for Flexiti {}\nimpl api::ConnectorAccessToken for Flexiti {}\nimpl api::MandateSetup for Flexiti {}\nimpl api::PaymentAuthorize for Flexiti {}\nimpl api::PaymentSync for Flexiti {}\nimpl api::PaymentCapture for Flexiti {}\nimpl api::PaymentVoid for Flexiti {}\nimpl api::Refund for Flexiti {}\nimpl api::RefundExecute for Flexiti {}\nimpl api::RefundSync for Flexiti {}\nimpl api::PaymentToken for Flexiti {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Flexiti\n{\n    // Not Implemented (R)\n}\n\nimpl Flexiti {\n    fn get_default_header() -> (String, masking::Maskable<String>) {\n        (\n            \"x-reference-id\".to_string(),\n            Uuid::new_v4().to_string().into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Flexiti\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let mut header = vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into(),\n        )];\n        header.push(Self::get_default_header());\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Flexiti {\n    fn id(&self) -> &'static str {\n        \"flexiti\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.flexiti.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__helcim.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse masking::{ExposeInterface, Mask};\nuse transformers as helcim;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, to_connector_meta, PaymentsAuthorizeRequestData},\n};\n\n#[derive(Clone)]\npub struct Helcim {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Helcim {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Helcim {}\nimpl api::PaymentSession for Helcim {}\nimpl api::ConnectorAccessToken for Helcim {}\nimpl api::MandateSetup for Helcim {}\nimpl api::PaymentAuthorize for Helcim {}\nimpl api::PaymentSync for Helcim {}\nimpl api::PaymentCapture for Helcim {}\nimpl api::PaymentVoid for Helcim {}\nimpl api::Refund for Helcim {}\nimpl api::RefundExecute for Helcim {}\nimpl api::RefundSync for Helcim {}\nimpl api::PaymentToken for Helcim {}\n\nimpl Helcim {\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Helcim {\n    fn id(&self) -> &'static str {\n        \"helcim\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__helcim.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Forte {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Forte {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Forte {}\nimpl api::PaymentSession for Forte {}\nimpl api::ConnectorAccessToken for Forte {}\nimpl api::MandateSetup for Forte {}\nimpl api::PaymentAuthorize for Forte {}\nimpl api::PaymentSync for Forte {}\nimpl api::PaymentCapture for Forte {}\nimpl api::PaymentVoid for Forte {}\nimpl api::Refund for Forte {}\nimpl api::RefundExecute for Forte {}\nimpl api::RefundSync for Forte {}\nimpl api::PaymentToken for Forte {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Forte\n{\n}\npub const AUTH_ORG_ID_HEADER: &str = \"X-Forte-Auth-Organization-Id\";\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Forte\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let content_type = ConnectorCommon::common_get_content_type(self);\n        let mut common_headers = self.get_auth_header(&req.connector_auth_type)?;\n        common_headers.push((\n            headers::CONTENT_TYPE.to_string(),\n            content_type.to_string().into(),\n        ));\n        Ok(common_headers)\n    }\n}\n\nimpl ConnectorCommon for Forte {\n    fn id(&self) -> &'static str {\n        \"forte\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.forte.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = forte::ForteAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let raw_basic_token = format!(\n            \"{}:{}\",\n            auth.api_access_id.peek(),\n            auth.api_secret_key.peek()\n        );\n        let basic_token = format!(\"Basic {}\", BASE64_ENGINE.encode(raw_basic_token));\n        Ok(vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                basic_token.into_masked(),\n            ),\n            (\n                AUTH_ORG_ID_HEADER.to_string(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__forte.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::{\n    AttemptStatus, CaptureMethod, CountryAlpha2, CountryAlpha3, Currency, RefundStatus,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{\n        CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId,\n        SetupMandateRequestData, UcsAuthenticationData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_with::skip_serializing_none;\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPostAuthenticateResponseRouterData, PaymentsPreAuthenticateResponseRouterData,\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, to_connector_meta,\n        to_connector_meta_from_secret, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPostAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSetupMandateRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\n#[derive(Clone, Copy, Debug)]\nenum AddressKind {\n    Billing,\n    Shipping,\n}\n\ntrait AddressConstructor {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self;\n}\n\nimpl AddressConstructor for BillingAddress {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self {\n        Self {\n            name,\n            street,\n            city,\n            post_code,\n            country,\n        }\n    }\n}\n\nimpl AddressConstructor for ShippingAddress {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self {\n        Self {\n            name,\n            street,\n            city,\n            post_code,\n            country,\n        }\n    }\n}\n\nfn get_validated_address_details_generic<RouterContextDataAlias, AddressOutput>(\n    data: &RouterContextDataAlias,\n    address_kind: AddressKind,\n) -> Result<Option<AddressOutput>, error_stack::Report<errors::ConnectorError>>\nwhere\n    RouterContextDataAlias: crate::utils::RouterData,\n    AddressOutput: AddressConstructor + Sized,\n{\n    let (\n        opt_line1,\n        opt_line2,\n        opt_full_name,\n        opt_city,\n        opt_zip,\n        opt_country,\n        has_address_details_check,\n        address_type_str,\n        max_name_len,\n        max_street_len,\n        max_city_len,\n        max_post_code_len,\n        max_country_len,\n    ) = match address_kind {\n        AddressKind::Billing => (\n            data.get_optional_billing_line1(),\n            data.get_optional_billing_line2(),\n            data.get_optional_billing_full_name(),\n            data.get_optional_billing_city(),\n            data.get_optional_billing_zip(),\n            data.get_optional_billing_country()\n                .map(CountryAlpha2::from_alpha2_to_alpha3),\n            data.get_optional_billing().is_some(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__hipay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{self as common_errors, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse reqwest::multipart::Form;\nuse serde::Serialize;\nuse serde_json::Value;\nuse transformers as hipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub fn build_form_from_struct<T: Serialize + Send + 'static>(\n    data: T,\n) -> Result<RequestContent, common_errors::ParsingError> {\n    let mut form = Form::new();\n    let serialized = serde_json::to_value(&data).map_err(|e| {\n        router_env::logger::error!(\"Error serializing data to JSON value: {:?}\", e);\n        common_errors::ParsingError::EncodeError(\"json-value\")\n    })?;\n    let serialized_object = serialized.as_object().ok_or_else(|| {\n        router_env::logger::error!(\"Error: Expected JSON object but got something else\");\n        common_errors::ParsingError::EncodeError(\"Expected object\")\n    })?;\n    for (key, values) in serialized_object {\n        let value = match values {\n            Value::String(s) => s.clone(),\n            Value::Number(n) => n.to_string(),\n            Value::Bool(b) => b.to_string(),\n            Value::Null => \"\".to_string(),\n            Value::Array(_) | Value::Object(_) => {\n                router_env::logger::error!(serialization_error =? \"Form Construction Failed.\");\n                \"\".to_string()\n            }\n        };\n        form = form.text(key.clone(), value.clone());\n    }\n    Ok(RequestContent::FormData((form, Box::new(data))))\n}\n#[derive(Clone)]\npub struct Hipay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Hipay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hipay {}\nimpl api::PaymentSession for Hipay {}\nimpl api::ConnectorAccessToken for Hipay {}\nimpl api::MandateSetup for Hipay {}\nimpl api::PaymentAuthorize for Hipay {}\nimpl api::PaymentSync for Hipay {}\nimpl api::PaymentCapture for Hipay {}\nimpl api::PaymentVoid for Hipay {}\nimpl api::Refund for Hipay {}\nimpl api::RefundExecute for Hipay {}\nimpl api::RefundSync for Hipay {}\nimpl api::PaymentToken for Hipay {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Hipay\n{\n    fn get_headers(\n        &self,\n        req: &TokenizationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_url(\n        &self,\n        _req: &TokenizationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}v2/token/create\",\n            connectors.hipay.secondary_base_url.clone()\n        ))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &TokenizationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = transformers::HiPayTokenRequest::try_from(req)?;\n        router_env::logger::info!(raw_connector_request=?connector_req);\n        build_form_from_struct(connector_req).change_context(errors::ConnectorError::ParsingFailed)\n    }\n\n    fn build_request(\n        &self,",
    "function_name": "build_form_from_struct",
    "file": "crates__hyperswitch_connectors__src__connectors__hipay.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse api_models::{\n    self,\n    payouts::{BankRedirect, PayoutMethodData},\n};\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    id_type,\n    pii::{self, Email, IpAddress},\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        InteracCustomerInfo, RouterData,\n    },\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::PoQuote, router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::{types::PayoutsResponseRouterData, utils::PayoutsData as _};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, BrowserInformationData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\npub struct GigadatRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GigadatRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst CONNECTOR_BASE_URL: &str = \"https://interac.express-connect.com/\";\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct GigadatConnectorMetadataObject {\n    pub site: String,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for GigadatConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"merchant_connector_account.metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n// CPI (Combined Pay-in) Request Structure for Gigadat\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GigadatCpiRequest {\n    pub user_id: id_type::CustomerId,\n    pub site: String,\n    pub user_ip: Secret<String, IpAddress>,\n    pub currency: Currency,\n    pub amount: FloatMajorUnit,\n    pub transaction_id: String,\n    #[serde(rename = \"type\")]\n    pub transaction_type: GidadatTransactionType,\n    pub sandbox: bool,\n    pub name: Secret<String>,\n    pub email: Email,\n    pub mobile: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum GidadatTransactionType {\n    Cpi,\n    Eto,\n}\n\nimpl TryFrom<&GigadatRouterData<&PaymentsAuthorizeRouterData>> for GigadatCpiRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &GigadatRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let metadata: GigadatConnectorMetadataObject =\n            utils::to_connector_meta_from_secret(item.router_data.connector_meta_data.clone())\n                .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"merchant_connector_account.metadata\",\n                })?;\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::BankRedirect(BankRedirectData::Interac { .. }) => {\n                let router_data = item.router_data;\n                let name = router_data.get_billing_full_name()?;\n                let email = router_data.get_billing_email()?;\n                let mobile = router_data.get_billing_phone_number()?;\n                let currency = item.router_data.request.currency;\n                let sandbox = match item.router_data.test_mode {\n                    Some(true) => true,\n                    Some(false) | None => false,\n                };\n                let user_ip = router_data.request.get_browser_info()?.get_ip_address()?;\n                Ok(Self {\n                    user_id: router_data.get_customer_id()?,\n                    site: metadata.site,\n                    user_ip,\n                    currency,\n                    amount: item.amount,\n                    transaction_id: router_data.connector_request_reference_id.clone(),\n                    transaction_type: GidadatTransactionType::Cpi,\n                    name,\n                    sandbox,\n                    email,\n                    mobile,\n                })\n            }\n            PaymentMethodData::BankRedirect(_) => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),\n            ))?,\n\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs",
    "code": "use common_enums::{enums, CountryAlpha2, Currency};\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\npub struct AffirmRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for AffirmRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmPaymentsRequest {\n    pub merchant: Merchant,\n    pub items: Vec<Item>,\n    pub shipping: Option<Shipping>,\n    pub billing: Option<Billing>,\n    pub total: MinorUnit,\n    pub currency: Currency,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmCompleteAuthorizeRequest {\n    pub order_id: Option<String>,\n    pub reference_id: Option<String>,\n    pub transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsCompleteAuthorizeRouterData> for AffirmCompleteAuthorizeRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsCompleteAuthorizeRouterData) -> Result<Self, Self::Error> {\n        let transaction_id = item.request.connector_transaction_id.clone().ok_or(\n            errors::ConnectorError::MissingRequiredField {\n                field_name: \"connector_transaction_id\",\n            },\n        )?;\n\n        let reference_id = item.reference_id.clone();\n        let order_id = item.connector_request_reference_id.clone();\n        Ok(Self {\n            transaction_id,\n            order_id: Some(order_id),\n            reference_id,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Merchant {\n    pub public_api_key: Secret<String>,\n    pub user_confirmation_url: String,\n    pub user_cancel_url: String,\n    pub user_confirmation_url_action: Option<String>,\n    pub use_vcn: Option<String>,\n    pub name: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Item {\n    pub display_name: String,\n    pub sku: String,\n    pub unit_price: MinorUnit,\n    pub qty: i64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Shipping {\n    pub name: Name,\n    pub address: Address,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub phone_number: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option<pii::Email>,\n}\n#[derive(Debug, Serialize)]\npub struct Billing {\n    pub name: Name,\n    pub address: Address,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub phone_number: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option<pii::Email>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Name {\n    pub first: Option<Secret<String>>,\n    pub last: Option<Secret<String>>,\n    pub full: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Address {\n    pub line1: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub line2: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub zipcode: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Metadata {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub shipping_type: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub entity_name: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub platform_type: Option<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__boku__transformers.rs",
    "code": "use std::fmt;\n\nuse common_enums::enums;\nuse common_utils::{request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, AddressDetailsData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct BokuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for BokuRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum BokuPaymentsRequest {\n    BeginSingleCharge(SingleChargeData),\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct SingleChargeData {\n    total_amount: MinorUnit,\n    currency: String,\n    country: String,\n    merchant_id: Secret<String>,\n    merchant_transaction_id: Secret<String>,\n    merchant_request_id: String,\n    merchant_item_description: String,\n    notification_url: Option<String>,\n    payment_method: String,\n    charge_type: String,\n    hosted: Option<BokuHostedData>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuPaymentType {\n    Dana,\n    Momo,\n    Gcash,\n    GoPay,\n    Kakaopay,\n}\n\nimpl fmt::Display for BokuPaymentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Dana => write!(f, \"Dana\"),\n            Self::Momo => write!(f, \"Momo\"),\n            Self::Gcash => write!(f, \"Gcash\"),\n            Self::GoPay => write!(f, \"GoPay\"),\n            Self::Kakaopay => write!(f, \"Kakaopay\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuChargeType {\n    Hosted,\n}\n\nimpl fmt::Display for BokuChargeType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Hosted => write!(f, \"hosted\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct BokuHostedData {\n    forward_url: String,\n}\n\nimpl TryFrom<&BokuRouterData<&types::PaymentsAuthorizeRouterData>> for BokuPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &BokuRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(wallet_data) => Self::try_from((item, &wallet_data)),\n            PaymentMethodData::Card(_)\n            | PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)\n            | PaymentMethodData::Crypto(_)\n            | PaymentMethodData::MandatePayment\n            | PaymentMethodData::Reward\n            | PaymentMethodData::RealTimePayment(_)\n            | PaymentMethodData::MobilePayment(_)\n            | PaymentMethodData::Upi(_)\n            | PaymentMethodData::Voucher(_)\n            | PaymentMethodData::GiftCard(_)\n            | PaymentMethodData::OpenBanking(_)\n            | PaymentMethodData::CardToken(_)\n            | PaymentMethodData::NetworkToken(_)\n            | PaymentMethodData::CardDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::CardWithLimitedDetails(_)\n            | PaymentMethodData::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::NetworkTokenDetailsForNetworkTransactionId(_) => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"boku\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl\n    TryFrom<(\n        &BokuRouterData<&types::PaymentsAuthorizeRouterData>,\n        &WalletData,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs",
    "source": "local_corpus"
  }
]