[
  {
    "query": "show me how to test url non printing character in component",
    "code": "def test_url_non_printing_character_in_component():\n    with pytest.raises(httpx.InvalidURL) as exc:\n        httpx.URL(\"https://www.example.com\", path=\"/\\n\")\n    assert str(exc.value) == (\n        \"Invalid non-printable ASCII character in URL path component, \"\n        \"'\\\\n' at position 1.\"\n    )",
    "function_name": "test_url_non_printing_character_in_component",
    "file": "tests/models/test_url.py",
    "num_lines": 7
  },
  {
    "query": "function that takes chunk_size: int | None",
    "code": "    async def aiter_text(\n        self, chunk_size: int | None = None\n    ) -> typing.AsyncIterator[str]:\n        \"\"\"\n        A str-iterator over the decoded response content\n        that handles both gzip, deflate, etc but also detects the content's\n        string encoding.\n        \"\"\"\n        decoder = TextDecoder(encoding=self.encoding or \"utf-8\")\n        chunker = TextChunker(chunk_size=chunk_size)\n        with request_context(request=self._request):\n            async for byte_content in self.aiter_bytes():\n                text_content = decoder.decode(byte_content)\n                for chunk in chunker.decode(text_content):\n                    yield chunk\n            text_content = decoder.flush()\n            for chunk in chunker.decode(text_content):\n                yield chunk  # pragma: no cover\n            for chunk in chunker.flush():\n                yield chunk",
    "function_name": "aiter_text",
    "file": "httpx/_models.py",
    "num_lines": 20
  },
  {
    "query": "I need to test read and stream data",
    "code": "def test_read_and_stream_data():\n    # Ensure a request may still be streamed if it has been read.\n    # Needed for cases such as authentication classes that read the request body.\n    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n    request.read()\n    assert request.stream is not None\n    assert isinstance(request.stream, typing.Iterable)\n    content = b\"\".join(list(request.stream))\n    assert content == request.content",
    "function_name": "test_read_and_stream_data",
    "file": "tests/models/test_requests.py",
    "num_lines": 9
  },
  {
    "query": "test cookies",
    "code": "def test_cookies():\n    cookies = httpx.Cookies({\"name\": \"value\"})\n    assert cookies[\"name\"] == \"value\"\n    assert \"name\" in cookies\n    assert len(cookies) == 1\n    assert dict(cookies) == {\"name\": \"value\"}\n    assert bool(cookies) is True\n\n    del cookies[\"name\"]\n    assert \"name\" not in cookies\n    assert len(cookies) == 0\n    assert dict(cookies) == {}\n    assert bool(cookies) is False",
    "function_name": "test_cookies",
    "file": "tests/models/test_cookies.py",
    "num_lines": 13
  },
  {
    "query": "with domain test",
    "code": "def test_cookies_with_domain():\n    cookies = httpx.Cookies()\n    cookies.set(\"name\", \"value\", domain=\"example.com\")\n    cookies.set(\"name\", \"value\", domain=\"example.org\")\n\n    with pytest.raises(httpx.CookieConflict):\n        cookies[\"name\"]\n\n    cookies.clear(domain=\"example.com\")\n    assert len(cookies) == 1",
    "function_name": "test_cookies_with_domain",
    "file": "tests/models/test_cookies.py",
    "num_lines": 10
  },
  {
    "query": "aiter test bytes",
    "code": "async def test_aiter_bytes():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = b\"\"\n    async for part in response.aiter_bytes():\n        content += part\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiter_bytes",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "aiter chunk size none",
    "code": "    async def aiter_text(\n        self, chunk_size: int | None = None\n    ) -> typing.AsyncIterator[str]:\n        \"\"\"\n        A str-iterator over the decoded response content\n        that handles both gzip, deflate, etc but also detects the content's\n        string encoding.\n        \"\"\"\n        decoder = TextDecoder(encoding=self.encoding or \"utf-8\")\n        chunker = TextChunker(chunk_size=chunk_size)\n        with request_context(request=self._request):\n            async for byte_content in self.aiter_bytes():\n                text_content = decoder.decode(byte_content)\n                for chunk in chunker.decode(text_content):\n                    yield chunk\n            text_content = decoder.flush()\n            for chunk in chunker.decode(text_content):\n                yield chunk  # pragma: no cover\n            for chunk in chunker.flush():\n                yield chunk",
    "function_name": "aiter_text",
    "file": "httpx/_models.py",
    "num_lines": 20
  },
  {
    "query": "same test domain",
    "code": "def test_same_domain_redirect():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    url = \"https://example.org/cross_domain\"\n    headers = {\"Authorization\": \"abc\"}\n    response = client.get(url, headers=headers, follow_redirects=True)\n    assert response.url == \"https://example.org/cross_domain_target\"\n    assert response.json()[\"headers\"][\"authorization\"] == \"abc\"",
    "function_name": "test_same_domain_redirect",
    "file": "tests/client/test_redirects.py",
    "num_lines": 7
  },
  {
    "query": "how to test aiterator content",
    "code": "async def test_aiterator_content():\n    async def hello_world() -> typing.AsyncIterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"world!\"\n\n    request = httpx.Request(method, url, content=hello_world())\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"\n\n    with pytest.raises(httpx.StreamConsumed):\n        [part async for part in request.stream]\n\n    # Support 'data' for compat with requests.\n    with pytest.warns(DeprecationWarning):\n        request = httpx.Request(method, url, data=hello_world())  # type: ignore\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiterator_content",
    "file": "tests/test_content.py",
    "num_lines": 33
  },
  {
    "query": "test credentials exist httpx",
    "code": "def test_netrc_auth_credentials_do_not_exist() -> None:\n    \"\"\"\n    When netrc auth is being used and a request is made to a host that is\n    not in the netrc file, then no credentials should be applied.\n    \"\"\"\n    netrc_file = str(FIXTURES_DIR / \".netrc\")\n    url = \"http://example.org\"\n    app = App()\n    auth = httpx.NetRCAuth(netrc_file)\n\n    with httpx.Client(transport=httpx.MockTransport(app), auth=auth) as client:\n        response = client.get(url)\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": None}",
    "function_name": "test_netrc_auth_credentials_do_not_exist",
    "file": "tests/client/test_auth.py",
    "num_lines": 15
  },
  {
    "query": "function that takes content: bytes",
    "code": "    def decode(self, content: bytes) -> list[bytes]:\n        if self._chunk_size is None:\n            return [content] if content else []\n\n        self._buffer.write(content)\n        if self._buffer.tell() >= self._chunk_size:\n            value = self._buffer.getvalue()\n            chunks = [\n                value[i : i + self._chunk_size]\n                for i in range(0, len(value), self._chunk_size)\n            ]\n            if len(chunks[-1]) == self._chunk_size:\n                self._buffer.seek(0)\n                self._buffer.truncate()\n                return chunks\n            else:\n                self._buffer.seek(0)\n                self._buffer.write(chunks[-1])\n                self._buffer.truncate()\n                return chunks[:-1]\n        else:\n            return []",
    "function_name": "decode",
    "file": "httpx/_decoders.py",
    "num_lines": 22
  },
  {
    "query": "gets proxy information from the environment",
    "code": "def get_environment_proxies() -> dict[str, str | None]:\n    \"\"\"Gets proxy information from the environment\"\"\"\n\n    # urllib.request.getproxies() falls back on System\n    # Registry and Config for proxies on Windows and macOS.\n    # We don't want to propagate non-HTTP proxies into\n    # our configuration such as 'TRAVIS_APT_PROXY'.\n    proxy_info = getproxies()\n    mounts: dict[str, str | None] = {}\n\n    for scheme in (\"http\", \"https\", \"all\"):\n        if proxy_info.get(scheme):\n            hostname = proxy_info[scheme]\n            mounts[f\"{scheme}://\"] = (\n                hostname if \"://\" in hostname else f\"http://{hostname}\"\n            )\n\n    no_proxy_hosts = [host.strip() for host in proxy_info.get(\"no\", \"\").split(\",\")]\n    for hostname in no_proxy_hosts:\n        # See https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html for details\n        # on how names in `NO_PROXY` are handled.\n        if hostname == \"*\":\n            # If NO_PROXY=* is used or if \"*\" occurs as any one of the comma\n            # separated hostnames, then we should just bypass any information\n            # from HTTP_PROXY, HTTPS_PROXY, ALL_PROXY, and always ignore\n            # proxies.\n            return {}\n        elif hostname:\n            # NO_PROXY=.google.com is marked as \"all://*.google.com,\n            #   which disables \"www.google.com\" but not \"google.com\"\n            # NO_PROXY=google.com is marked as \"all://*google.com,\n            #   which disables \"www.google.com\" and \"google.com\".\n            #   (But not \"wwwgoogle.com\")\n            # NO_PROXY can include domains, IPv6, IPv4 addresses and \"localhost\"\n            #   NO_PROXY=example.com,::1,localhost,192.168.0.0/16\n            if \"://\" in hostname:\n                mounts[hostname] = None\n            elif is_ipv4_hostname(hostname):\n                mounts[f\"all://{hostname}\"] = None\n            elif is_ipv6_hostname(hostname):\n                mounts[f\"all://[{hostname}]\"] = None\n            elif hostname.lower() == \"localhost\":\n                mounts[f\"all://{hostname}\"] = None\n            else:\n                mounts[f\"all://*{hostname}\"] = None\n\n    return mounts",
    "function_name": "get_environment_proxies",
    "file": "httpx/_utils.py",
    "num_lines": 47
  },
  {
    "query": "coerce a primitive data type into a string value",
    "code": "def primitive_value_to_str(value: PrimitiveData) -> str:\n    \"\"\"\n    Coerce a primitive data type into a string value.\n\n    Note that we prefer JSON-style 'true'/'false' for boolean values here.\n    \"\"\"\n    if value is True:\n        return \"true\"\n    elif value is False:\n        return \"false\"\n    elif value is None:\n        return \"\"\n    return str(value)",
    "function_name": "primitive_value_to_str",
    "file": "httpx/_utils.py",
    "num_lines": 13
  },
  {
    "query": "function that test client trust env",
    "code": "def test_client_trust_env():\n    client = httpx.Client()\n    assert client.trust_env\n\n    client = httpx.Client(trust_env=False)\n    assert not client.trust_env",
    "function_name": "test_client_trust_env",
    "file": "tests/client/test_properties.py",
    "num_lines": 6
  },
  {
    "query": "function that takes data: RequestData and files: RequestFiles",
    "code": "def encode_multipart_data(\n    data: RequestData, files: RequestFiles, boundary: bytes | None\n) -> tuple[dict[str, str], MultipartStream]:\n    multipart = MultipartStream(data=data, files=files, boundary=boundary)\n    headers = multipart.get_headers()\n    return headers, multipart",
    "function_name": "encode_multipart_data",
    "file": "httpx/_content.py",
    "num_lines": 6
  },
  {
    "query": "test client event hooks in tests client test properties",
    "code": "def test_client_event_hooks():\n    def on_request(request):\n        pass  # pragma: no cover\n\n    client = httpx.Client()\n    client.event_hooks = {\"request\": [on_request]}\n    assert client.event_hooks == {\"request\": [on_request], \"response\": []}",
    "function_name": "test_client_event_hooks",
    "file": "tests/client/test_properties.py",
    "num_lines": 7
  },
  {
    "query": "looking for the code that test request async streaming content picklable",
    "code": "async def test_request_async_streaming_content_picklable():\n    async def streaming_body(data: bytes) -> typing.AsyncIterator[bytes]:\n        yield data\n\n    data = streaming_body(b\"test 123\")\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n    pickle_request = pickle.loads(pickle.dumps(request))\n    with pytest.raises(httpx.RequestNotRead):\n        pickle_request.content  # noqa: B018\n    with pytest.raises(httpx.StreamClosed):\n        await pickle_request.aread()\n\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n    await request.aread()\n    pickle_request = pickle.loads(pickle.dumps(request))\n    assert pickle_request.content == b\"test 123\"",
    "function_name": "test_request_async_streaming_content_picklable",
    "file": "tests/models/test_requests.py",
    "num_lines": 16
  },
  {
    "query": "from raw test",
    "code": "def test_ipv6_url_from_raw_url(host):\n    url = httpx.URL(scheme=\"https\", host=host, port=443, path=\"/\")\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]\"\n    assert str(url) == \"https://[::ffff:192.168.0.1]/\"",
    "function_name": "test_ipv6_url_from_raw_url",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "request params test python",
    "code": "def test_request_params():\n    request = httpx.Request(\"GET\", \"http://example.com\", params={})\n    assert str(request.url) == \"http://example.com\"\n\n    request = httpx.Request(\n        \"GET\", \"http://example.com?c=3\", params={\"a\": \"1\", \"b\": \"2\"}\n    )\n    assert str(request.url) == \"http://example.com?a=1&b=2\"\n\n    request = httpx.Request(\"GET\", \"http://example.com?a=1\", params={})\n    assert str(request.url) == \"http://example.com\"",
    "function_name": "test_request_params",
    "file": "tests/models/test_requests.py",
    "num_lines": 11
  },
  {
    "query": "handle request in httpx  transports default",
    "code": "    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n        import httpcore\n\n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n            resp = self._pool.handle_request(req)\n\n        assert isinstance(resp.stream, typing.Iterable)\n\n        return Response(\n            status_code=resp.status,\n            headers=resp.headers,\n            stream=ResponseStream(resp.stream),\n            extensions=resp.extensions,\n        )",
    "function_name": "handle_request",
    "file": "httpx/_transports/default.py",
    "num_lines": 30
  },
  {
    "query": "code to test line decoder crnl",
    "code": "def test_line_decoder_crnl():\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\\r\\n\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\", b\"\\n\\r\\nb\\r\\nc\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    # Issue #1033\n    response = httpx.Response(200, content=[b\"\", b\"12345\\r\\n\", b\"foo bar baz\\r\\n\"])\n    assert list(response.iter_lines()) == [\"12345\", \"foo bar baz\"]",
    "function_name": "test_line_decoder_crnl",
    "file": "tests/test_decoders.py",
    "num_lines": 13
  },
  {
    "query": "how does httpx test pool timeout?",
    "code": "async def test_pool_timeout(server):\n    limits = httpx.Limits(max_connections=1)\n    timeout = httpx.Timeout(None, pool=1e-4)\n\n    async with httpx.AsyncClient(limits=limits, timeout=timeout) as client:\n        with pytest.raises(httpx.PoolTimeout):\n            async with client.stream(\"GET\", server.url):\n                await client.get(server.url)",
    "function_name": "test_pool_timeout",
    "file": "tests/test_timeouts.py",
    "num_lines": 8
  },
  {
    "query": "function that takes url: URL | str",
    "code": "def get(\n    url: URL | str,\n    *,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `GET` request.\n\n    **Parameters**: See `httpx.request`.\n\n    Note that the `data`, `files`, `json` and `content` parameters are not available\n    on this function, as `GET` requests should not include a request body.\n    \"\"\"\n    return request(\n        \"GET\",\n        url,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "get",
    "file": "httpx/_api.py",
    "num_lines": 34
  },
  {
    "query": "test multipart file tuple in tests test multipart",
    "code": "def test_multipart_file_tuple():\n    client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n\n    # Test with a list of values 'data' argument,\n    #     and a tuple style 'files' argument.\n    data = {\"text\": [\"abc\"]}\n    files = {\"file\": (\"name.txt\", io.BytesIO(b\"<file content>\"))}\n    response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n    boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n    boundary_bytes = boundary.encode(\"ascii\")\n\n    assert response.status_code == 200\n    assert response.content == b\"\".join(\n        [\n            b\"--\" + boundary_bytes + b\"\\r\\n\",\n            b'Content-Disposition: form-data; name=\"text\"\\r\\n',\n            b\"\\r\\n\",\n            b\"abc\\r\\n\",\n            b\"--\" + boundary_bytes + b\"\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"name.txt\"\\r\\n',\n            b\"Content-Type: text/plain\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--\" + boundary_bytes + b\"--\\r\\n\",\n        ]\n    )",
    "function_name": "test_multipart_file_tuple",
    "file": "tests/test_multipart.py",
    "num_lines": 26
  },
  {
    "query": "function that takes content_type: bytes | None",
    "code": "def get_multipart_boundary_from_content_type(\n    content_type: bytes | None,\n) -> bytes | None:\n    if not content_type or not content_type.startswith(b\"multipart/form-data\"):\n        return None\n    # parse boundary according to\n    # https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n    if b\";\" in content_type:\n        for section in content_type.split(b\";\"):\n            if section.strip().lower().startswith(b\"boundary=\"):\n                return section.strip()[len(b\"boundary=\") :].strip(b'\"')\n    return None",
    "function_name": "get_multipart_boundary_from_content_type",
    "file": "httpx/_multipart.py",
    "num_lines": 12
  },
  {
    "query": "raise asgi test",
    "code": "async def test_asgi_exc_no_raise():\n    transport = httpx.ASGITransport(app=raise_exc, raise_app_exceptions=False)\n    async with httpx.AsyncClient(transport=transport) as client:\n        response = await client.get(\"http://www.example.org/\")\n\n        assert response.status_code == 500",
    "function_name": "test_asgi_exc_no_raise",
    "file": "tests/test_asgi.py",
    "num_lines": 6
  },
  {
    "query": "start response in httpx  transports wsgi",
    "code": "        def start_response(\n            status: str,\n            response_headers: list[tuple[str, str]],\n            exc_info: OptExcInfo | None = None,\n        ) -> typing.Callable[[bytes], typing.Any]:\n            nonlocal seen_status, seen_response_headers, seen_exc_info\n            seen_status = status\n            seen_response_headers = response_headers\n            seen_exc_info = exc_info\n            return lambda _: None",
    "function_name": "start_response",
    "file": "httpx/_transports/wsgi.py",
    "num_lines": 10
  },
  {
    "query": "async test exception",
    "code": "async def test_async_event_hooks_raising_exception():\n    async def raise_on_4xx_5xx(response):\n        response.raise_for_status()\n\n    event_hooks = {\"response\": [raise_on_4xx_5xx]}\n\n    async with httpx.AsyncClient(\n        event_hooks=event_hooks, transport=httpx.MockTransport(app)\n    ) as http:\n        try:\n            await http.get(\"http://127.0.0.1:8000/status/400\")\n        except httpx.HTTPStatusError as exc:\n            assert exc.response.is_closed",
    "function_name": "test_async_event_hooks_raising_exception",
    "file": "tests/client/test_event_hooks.py",
    "num_lines": 13
  },
  {
    "query": "content override test",
    "code": "def test_override_content_length_header():\n    async def streaming_body(data: bytes) -> typing.AsyncIterator[bytes]:\n        yield data  # pragma: no cover\n\n    data = streaming_body(b\"test 123\")\n    headers = {\"Content-Length\": \"8\"}\n\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data, headers=headers)\n    assert request.headers[\"Content-Length\"] == \"8\"",
    "function_name": "test_override_content_length_header",
    "file": "tests/models/test_requests.py",
    "num_lines": 9
  },
  {
    "query": "test aiter bytes in tests models test responses",
    "code": "async def test_aiter_bytes():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = b\"\"\n    async for part in response.aiter_bytes():\n        content += part\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiter_bytes",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "serve in tests conftest",
    "code": "    async def serve(self, sockets=None):\n        self.restart_requested = asyncio.Event()\n\n        loop = asyncio.get_event_loop()\n        tasks = {\n            loop.create_task(super().serve(sockets=sockets)),\n            loop.create_task(self.watch_restarts()),\n        }\n        await asyncio.wait(tasks)",
    "function_name": "serve",
    "file": "tests/conftest.py",
    "num_lines": 9
  },
  {
    "query": "test url non printing character in component in tests models test url",
    "code": "def test_url_non_printing_character_in_component():\n    with pytest.raises(httpx.InvalidURL) as exc:\n        httpx.URL(\"https://www.example.com\", path=\"/\\n\")\n    assert str(exc.value) == (\n        \"Invalid non-printable ASCII character in URL path component, \"\n        \"'\\\\n' at position 1.\"\n    )",
    "function_name": "test_url_non_printing_character_in_component",
    "file": "tests/models/test_url.py",
    "num_lines": 7
  },
  {
    "query": "function that test iter bytes doesnt return empty chunks",
    "code": "def test_iter_bytes_doesnt_return_empty_chunks():\n    def streaming_body_with_empty_chunks() -> typing.Iterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"\"\n        yield b\"world!\"\n        yield b\"\"\n\n    response = httpx.Response(200, content=streaming_body_with_empty_chunks())\n\n    parts = list(response.iter_bytes())\n    assert parts == [b\"Hello, \", b\"world!\"]",
    "function_name": "test_iter_bytes_doesnt_return_empty_chunks",
    "file": "tests/models/test_responses.py",
    "num_lines": 11
  },
  {
    "query": "how to see: https://github.com/encode/httpx/pull/1312",
    "code": "async def test_basic_auth_with_stream() -> None:\n    \"\"\"\n    See: https://github.com/encode/httpx/pull/1312\n    \"\"\"\n    url = \"https://example.org/\"\n    auth = (\"user\", \"password123\")\n    app = App()\n\n    async with httpx.AsyncClient(\n        transport=httpx.MockTransport(app), auth=auth\n    ) as client:\n        async with client.stream(\"GET\", url) as response:\n            await response.aread()\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": \"Basic dXNlcjpwYXNzd29yZDEyMw==\"}",
    "function_name": "test_basic_auth_with_stream",
    "file": "tests/client/test_auth.py",
    "num_lines": 16
  },
  {
    "query": "raw path in httpx  urls",
    "code": "    def raw_path(self) -> bytes:\n        \"\"\"\n        The complete URL path and query string as raw bytes.\n        Used as the target when constructing HTTP requests.\n\n        For example:\n\n        GET /users?search=some%20text HTTP/1.1\n        Host: www.example.org\n        Connection: close\n        \"\"\"\n        path = self._uri_reference.path or \"/\"\n        if self._uri_reference.query is not None:\n            path += \"?\" + self._uri_reference.query\n        return path.encode(\"ascii\")",
    "function_name": "raw_path",
    "file": "httpx/_urls.py",
    "num_lines": 15
  },
  {
    "query": "test request picklable in tests models test requests",
    "code": "def test_request_picklable():\n    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n    pickle_request = pickle.loads(pickle.dumps(request))\n    assert pickle_request.method == \"POST\"\n    assert pickle_request.url.path == \"/\"\n    assert pickle_request.headers[\"Content-Type\"] == \"application/json\"\n    assert pickle_request.content == b'{\"test\":123}'\n    assert pickle_request.stream is not None\n    assert request.headers == {\n        \"Host\": \"example.org\",\n        \"Content-Type\": \"application/json\",\n        \"content-length\": \"12\",\n    }",
    "function_name": "test_request_picklable",
    "file": "tests/models/test_requests.py",
    "num_lines": 13
  },
  {
    "query": "function that takes server",
    "code": "def test_stream_iterator(server):\n    body = b\"\"\n\n    with httpx.Client() as client:\n        with client.stream(\"GET\", server.url) as response:\n            for chunk in response.iter_bytes():\n                body += chunk\n\n    assert response.status_code == 200\n    assert body == b\"Hello, world!\"",
    "function_name": "test_stream_iterator",
    "file": "tests/client/test_client.py",
    "num_lines": 10
  },
  {
    "query": "test ipv6 url copy with host in tests models test url",
    "code": "def test_ipv6_url_copy_with_host(url_str, new_host):\n    url = httpx.URL(url_str).copy_with(host=new_host)\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]:1234\"\n    assert str(url) == \"http://[::ffff:192.168.0.1]:1234\"",
    "function_name": "test_ipv6_url_copy_with_host",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "how to some basic url query parameter manipulation",
    "code": "def test_url_remove_param_manipulation():\n    \"\"\"\n    Some basic URL query parameter manipulation.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/?a=123\")\n    assert url.copy_remove_param(\"a\") == \"https://example.org:123/\"",
    "function_name": "test_url_remove_param_manipulation",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "how to test url copywith userinfo subcomponents using httpx?",
    "code": "def test_url_copywith_userinfo_subcomponents():\n    copy_with_kwargs = {\n        \"username\": \"tom@example.org\",\n        \"password\": \"abc123@ %\",\n    }\n    url = httpx.URL(\"https://example.org\")\n    new = url.copy_with(**copy_with_kwargs)\n    assert str(new) == \"https://tom%40example.org:abc123%40%20%@example.org\"\n    assert new.username == \"tom@example.org\"\n    assert new.password == \"abc123@ %\"\n    assert new.userinfo == b\"tom%40example.org:abc123%40%20%\"",
    "function_name": "test_url_copywith_userinfo_subcomponents",
    "file": "tests/models/test_url.py",
    "num_lines": 11
  },
  {
    "query": "how does httpx test empty request?",
    "code": "async def test_empty_request():\n    request = httpx.Request(method, url, data={}, files={})\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\"Host\": \"www.example.com\", \"Content-Length\": \"0\"}\n    assert sync_content == b\"\"\n    assert async_content == b\"\"",
    "function_name": "test_empty_request",
    "file": "tests/test_content.py",
    "num_lines": 11
  },
  {
    "query": "test aiter raw httpx",
    "code": "async def test_aiter_raw():\n    response = httpx.Response(200, content=async_streaming_body())\n\n    raw = b\"\"\n    async for part in response.aiter_raw():\n        raw += part\n    assert raw == b\"Hello, world!\"",
    "function_name": "test_aiter_raw",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "client env test",
    "code": "def test_client_trust_env():\n    client = httpx.Client()\n    assert client.trust_env\n\n    client = httpx.Client(trust_env=False)\n    assert not client.trust_env",
    "function_name": "test_client_trust_env",
    "file": "tests/client/test_properties.py",
    "num_lines": 6
  },
  {
    "query": "copy this url, returning a new url with some components altered",
    "code": "    def copy_with(self, **kwargs: typing.Any) -> URL:\n        \"\"\"\n        Copy this URL, returning a new URL with some components altered.\n        Accepts the same set of parameters as the components that are made\n        available via properties on the `URL` class.\n\n        For example:\n\n        url = httpx.URL(\"https://www.example.com\").copy_with(\n            username=\"jo@gmail.com\", password=\"a secret\"\n        )\n        assert url == \"https://jo%40email.com:a%20secret@www.example.com\"\n        \"\"\"\n        return URL(self, **kwargs)",
    "function_name": "copy_with",
    "file": "httpx/_urls.py",
    "num_lines": 14
  },
  {
    "query": "test response server",
    "code": "def test_stream_response(server):\n    with httpx.Client() as client:\n        with client.stream(\"GET\", server.url) as response:\n            content = response.read()\n    assert response.status_code == 200\n    assert content == b\"Hello, world!\"",
    "function_name": "test_stream_response",
    "file": "tests/client/test_client.py",
    "num_lines": 6
  },
  {
    "query": "code to test load ssl config verify existing file",
    "code": "def test_load_ssl_config_verify_existing_file():\n    context = httpx.create_ssl_context()\n    context.load_verify_locations(capath=certifi.where())\n    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n    assert context.check_hostname is True",
    "function_name": "test_load_ssl_config_verify_existing_file",
    "file": "tests/test_config.py",
    "num_lines": 5
  },
  {
    "query": "info email.message.message",
    "code": "        def info(self) -> email.message.Message:\n            info = email.message.Message()\n            for key, value in self.response.headers.multi_items():\n                # Note that setting `info[key]` here is an \"append\" operation,\n                # not a \"replace\" operation.\n                # https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.__setitem__\n                info[key] = value\n            return info",
    "function_name": "info",
    "file": "httpx/_models.py",
    "num_lines": 8
  },
  {
    "query": "unicode file none",
    "code": "def test_multipart_encode_unicode_file_contents() -> None:\n    url = \"https://www.example.com/\"\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n    files = {\"file\": (\"name.txt\", b\"<bytes content>\")}\n\n    request = httpx.Request(\"POST\", url, headers=headers, files=files)\n    request.read()\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n        \"Content-Length\": str(len(request.content)),\n    }\n    assert request.content == (\n        b'--BOUNDARY\\r\\nContent-Disposition: form-data; name=\"file\";'\n        b' filename=\"name.txt\"\\r\\n'\n        b\"Content-Type: text/plain\\r\\n\\r\\n<bytes content>\\r\\n\"\n        b\"--BOUNDARY--\\r\\n\"\n    )",
    "function_name": "test_multipart_encode_unicode_file_contents",
    "file": "tests/test_multipart.py",
    "num_lines": 19
  },
  {
    "query": "test iter bytes doesnt return empty chunks in tests models test responses",
    "code": "def test_iter_bytes_doesnt_return_empty_chunks():\n    def streaming_body_with_empty_chunks() -> typing.Iterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"\"\n        yield b\"world!\"\n        yield b\"\"\n\n    response = httpx.Response(200, content=streaming_body_with_empty_chunks())\n\n    parts = list(response.iter_bytes())\n    assert parts == [b\"Hello, \", b\"world!\"]",
    "function_name": "test_iter_bytes_doesnt_return_empty_chunks",
    "file": "tests/models/test_responses.py",
    "num_lines": 11
  },
  {
    "query": "see: https://github.com/encode/httpx/pull/1312",
    "code": "async def test_basic_auth_with_stream() -> None:\n    \"\"\"\n    See: https://github.com/encode/httpx/pull/1312\n    \"\"\"\n    url = \"https://example.org/\"\n    auth = (\"user\", \"password123\")\n    app = App()\n\n    async with httpx.AsyncClient(\n        transport=httpx.MockTransport(app), auth=auth\n    ) as client:\n        async with client.stream(\"GET\", url) as response:\n            await response.aread()\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": \"Basic dXNlcjpwYXNzd29yZDEyMw==\"}",
    "function_name": "test_basic_auth_with_stream",
    "file": "tests/client/test_auth.py",
    "num_lines": 16
  },
  {
    "query": "test redirect 302 in tests client test redirects",
    "code": "def test_redirect_302():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    response = client.post(\"https://example.org/redirect_302\", follow_redirects=True)\n    assert response.status_code == httpx.codes.OK\n    assert response.url == \"https://example.org/\"\n    assert len(response.history) == 1",
    "function_name": "test_redirect_302",
    "file": "tests/client/test_redirects.py",
    "num_lines": 6
  },
  {
    "query": "how to some basic url query parameter manipulation",
    "code": "def test_url_set_param_manipulation():\n    \"\"\"\n    Some basic URL query parameter manipulation.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/?a=123\")\n    assert url.copy_set_param(\"a\", \"456\") == \"https://example.org:123/?a=456\"",
    "function_name": "test_url_set_param_manipulation",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "list flush str",
    "code": "    def flush(self) -> list[str]:\n        value = self._buffer.getvalue()\n        self._buffer.seek(0)\n        self._buffer.truncate()\n        return [value] if value else []",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "where is the ipv4 hostname logic?",
    "code": "def is_ipv4_hostname(hostname: str) -> bool:\n    try:\n        ipaddress.IPv4Address(hostname.split(\"/\")[0])\n    except Exception:\n        return False\n    return True",
    "function_name": "is_ipv4_hostname",
    "file": "httpx/_utils.py",
    "num_lines": 6
  },
  {
    "query": "test zstd",
    "code": "def test_zstd():\n    body = b\"test 123\"\n    compressed_body = zstd.compress(body)\n\n    headers = [(b\"Content-Encoding\", b\"zstd\")]\n    response = httpx.Response(\n        200,\n        headers=headers,\n        content=compressed_body,\n    )\n    assert response.content == body",
    "function_name": "test_zstd",
    "file": "tests/test_decoders.py",
    "num_lines": 11
  },
  {
    "query": "read in httpx  models",
    "code": "    def read(self) -> bytes:\n        \"\"\"\n        Read and return the request content.\n        \"\"\"\n        if not hasattr(self, \"_content\"):\n            assert isinstance(self.stream, typing.Iterable)\n            self._content = b\"\".join(self.stream)\n            if not isinstance(self.stream, ByteStream):\n                # If a streaming request has been read entirely into memory, then\n                # we can replace the stream with a raw bytes implementation,\n                # to ensure that any non-replayable streams can still be used.\n                self.stream = ByteStream(self._content)\n        return self._content",
    "function_name": "read",
    "file": "httpx/_models.py",
    "num_lines": 13
  },
  {
    "query": "request, flow none",
    "code": "    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n        if self._last_challenge:\n            request.headers[\"Authorization\"] = self._build_auth_header(\n                request, self._last_challenge\n            )\n\n        response = yield request\n\n        if response.status_code != 401 or \"www-authenticate\" not in response.headers:\n            # If the response is not a 401 then we don't\n            # need to build an authenticated request.\n            return\n\n        for auth_header in response.headers.get_list(\"www-authenticate\"):\n            if auth_header.lower().startswith(\"digest \"):\n                break\n        else:\n            # If the response does not include a 'WWW-Authenticate: Digest ...'\n            # header, then we don't need to build an authenticated request.\n            return\n\n        self._last_challenge = self._parse_challenge(request, response, auth_header)\n        self._nonce_count = 1\n\n        request.headers[\"Authorization\"] = self._build_auth_header(\n            request, self._last_challenge\n        )\n        if response.cookies:\n            Cookies(response.cookies).set_cookie_header(request=request)\n        yield request",
    "function_name": "auth_flow",
    "file": "httpx/_auth.py",
    "num_lines": 30
  },
  {
    "query": "function that takes server",
    "code": "def test_put(server):\n    with httpx.Client() as client:\n        response = client.put(server.url, content=b\"Hello, world!\")\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"",
    "function_name": "test_put",
    "file": "tests/client/test_client.py",
    "num_lines": 5
  },
  {
    "query": "test ipv6 url from raw url in tests models test url",
    "code": "def test_ipv6_url_from_raw_url(host):\n    url = httpx.URL(scheme=\"https\", host=host, port=443, path=\"/\")\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]\"\n    assert str(url) == \"https://[::ffff:192.168.0.1]/\"",
    "function_name": "test_ipv6_url_from_raw_url",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "test aiter text in tests models test responses",
    "code": "async def test_aiter_text():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = \"\"\n    async for part in response.aiter_text():\n        content += part\n    assert content == \"Hello, world!\"",
    "function_name": "test_aiter_text",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "show me how to parse header links",
    "code": "def _parse_header_links(value: str) -> list[dict[str, str]]:\n    \"\"\"\n    Returns a list of parsed link headers, for more info see:\n    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link\n    The generic syntax of those is:\n    Link: < uri-reference >; param1=value1; param2=\"value2\"\n    So for instance:\n    Link; '<http:/.../front.jpeg>; type=\"image/jpeg\",<http://.../back.jpeg>;'\n    would return\n        [\n            {\"url\": \"http:/.../front.jpeg\", \"type\": \"image/jpeg\"},\n            {\"url\": \"http://.../back.jpeg\"},\n        ]\n    :param value: HTTP Link entity-header field\n    :return: list of parsed link headers\n    \"\"\"\n    links: list[dict[str, str]] = []\n    replace_chars = \" '\\\"\"\n    value = value.strip(replace_chars)\n    if not value:\n        return links\n    for val in re.split(\", *<\", value):\n        try:\n            url, params = val.split(\";\", 1)\n        except ValueError:\n            url, params = val, \"\"\n        link = {\"url\": url.strip(\"<> '\\\"\")}\n        for param in params.split(\";\"):\n            try:\n                key, value = param.split(\"=\")\n            except ValueError:\n                break\n            link[key.strip(replace_chars)] = value.strip(replace_chars)\n        links.append(link)\n    return links",
    "function_name": "_parse_header_links",
    "file": "httpx/_models.py",
    "num_lines": 35
  },
  {
    "query": "function that returns email.message.message",
    "code": "        def info(self) -> email.message.Message:\n            info = email.message.Message()\n            for key, value in self.response.headers.multi_items():\n                # Note that setting `info[key]` here is an \"append\" operation,\n                # not a \"replace\" operation.\n                # https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.__setitem__\n                info[key] = value\n            return info",
    "function_name": "info",
    "file": "httpx/_models.py",
    "num_lines": 8
  },
  {
    "query": "server put test",
    "code": "def test_put(server):\n    with httpx.Client() as client:\n        response = client.put(server.url, content=b\"Hello, world!\")\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"",
    "function_name": "test_put",
    "file": "tests/client/test_client.py",
    "num_lines": 5
  },
  {
    "query": "post in httpx  api",
    "code": "def post(\n    url: URL | str,\n    *,\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: typing.Any | None = None,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `POST` request.\n\n    **Parameters**: See `httpx.request`.\n    \"\"\"\n    return request(\n        \"POST\",\n        url,\n        content=content,\n        data=data,\n        files=files,\n        json=json,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "post",
    "file": "httpx/_api.py",
    "num_lines": 39
  },
  {
    "query": "auth digest 2069",
    "code": "def test_digest_auth_rfc_2069():\n    # Example from https://datatracker.ietf.org/doc/html/rfc2069#section-2.4\n    # with corrected response from https://www.rfc-editor.org/errata/eid749\n\n    auth = httpx.DigestAuth(username=\"Mufasa\", password=\"CircleOfLife\")\n    request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n\n    # The initial request should not include an auth header.\n    flow = auth.sync_auth_flow(request)\n    request = next(flow)\n    assert \"Authorization\" not in request.headers\n\n    # If a 401 response is returned, then a digest auth request is made.\n    headers = {\n        \"WWW-Authenticate\": (\n            'Digest realm=\"testrealm@host.com\", '\n            'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", '\n            'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'\n        )\n    }\n    response = httpx.Response(\n        content=b\"Auth required\", status_code=401, headers=headers, request=request\n    )\n    request = flow.send(response)\n    assert request.headers[\"Authorization\"].startswith(\"Digest\")\n    assert 'username=\"Mufasa\"' in request.headers[\"Authorization\"]\n    assert 'realm=\"testrealm@host.com\"' in request.headers[\"Authorization\"]\n    assert (\n        'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"' in request.headers[\"Authorization\"]\n    )\n    assert 'uri=\"/dir/index.html\"' in request.headers[\"Authorization\"]\n    assert (\n        'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"' in request.headers[\"Authorization\"]\n    )\n    assert (\n        'response=\"1949323746fe6a43ef61f9606e7febea\"'\n        in request.headers[\"Authorization\"]\n    )\n\n    # No other requests are made.\n    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n    with pytest.raises(StopIteration):\n        flow.send(response)",
    "function_name": "test_digest_auth_rfc_2069",
    "file": "tests/test_auth.py",
    "num_lines": 43
  },
  {
    "query": "encode request in httpx  content",
    "code": "def encode_request(\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: Any | None = None,\n    boundary: bytes | None = None,\n) -> tuple[dict[str, str], SyncByteStream | AsyncByteStream]:\n    \"\"\"\n    Handles encoding the given `content`, `data`, `files`, and `json`,\n    returning a two-tuple of (<headers>, <stream>).\n    \"\"\"\n    if data is not None and not isinstance(data, Mapping):\n        # We prefer to separate `content=<bytes|str|byte iterator|bytes aiterator>`\n        # for raw request content, and `data=<form data>` for url encoded or\n        # multipart form content.\n        #\n        # However for compat with requests, we *do* still support\n        # `data=<bytes...>` usages. We deal with that case here, treating it\n        # as if `content=<...>` had been supplied instead.\n        message = \"Use 'content=<...>' to upload raw bytes/text content.\"\n        warnings.warn(message, DeprecationWarning, stacklevel=2)\n        return encode_content(data)\n\n    if content is not None:\n        return encode_content(content)\n    elif files:\n        return encode_multipart_data(data or {}, files, boundary)\n    elif data:\n        return encode_urlencoded_data(data)\n    elif json is not None:\n        return encode_json(json)\n\n    return {}, ByteStream(b\"\")",
    "function_name": "encode_request",
    "file": "httpx/_content.py",
    "num_lines": 33
  },
  {
    "query": "function that returns url",
    "code": "    def copy_with(self, **kwargs: typing.Any) -> URL:\n        \"\"\"\n        Copy this URL, returning a new URL with some components altered.\n        Accepts the same set of parameters as the components that are made\n        available via properties on the `URL` class.\n\n        For example:\n\n        url = httpx.URL(\"https://www.example.com\").copy_with(\n            username=\"jo@gmail.com\", password=\"a secret\"\n        )\n        assert url == \"https://jo%40email.com:a%20secret@www.example.com\"\n        \"\"\"\n        return URL(self, **kwargs)",
    "function_name": "copy_with",
    "file": "httpx/_urls.py",
    "num_lines": 14
  },
  {
    "query": "test zstd truncated",
    "code": "def test_zstd_truncated():\n    body = b\"test 123\"\n    compressed_body = zstd.compress(body)\n\n    headers = [(b\"Content-Encoding\", b\"zstd\")]\n    with pytest.raises(httpx.DecodingError):\n        httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body[1:3],\n        )",
    "function_name": "test_zstd_truncated",
    "file": "tests/test_decoders.py",
    "num_lines": 11
  },
  {
    "query": "json server test",
    "code": "def test_json(server):\n    url = str(server.url.copy_with(path=\"/json\"))\n    runner = CliRunner()\n    result = runner.invoke(httpx.main, [url])\n    assert result.exit_code == 0\n    assert remove_date_header(splitlines(result.output)) == [\n        \"HTTP/1.1 200 OK\",\n        \"server: uvicorn\",\n        \"content-type: application/json\",\n        \"Transfer-Encoding: chunked\",\n        \"\",\n        \"{\",\n        '\"Hello\": \"world!\"',\n        \"}\",\n    ]",
    "function_name": "test_json",
    "file": "tests/test_main.py",
    "num_lines": 15
  },
  {
    "query": "find the function for error",
    "code": "    def is_error(self) -> bool:\n        \"\"\"\n        A property which is `True` for 4xx and 5xx status codes, `False` otherwise.\n        \"\"\"\n        return codes.is_error(self.status_code)",
    "function_name": "is_error",
    "file": "httpx/_models.py",
    "num_lines": 5
  },
  {
    "query": "function that takes url: URL | str",
    "code": "def post(\n    url: URL | str,\n    *,\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: typing.Any | None = None,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `POST` request.\n\n    **Parameters**: See `httpx.request`.\n    \"\"\"\n    return request(\n        \"POST\",\n        url,\n        content=content,\n        data=data,\n        files=files,\n        json=json,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "post",
    "file": "httpx/_api.py",
    "num_lines": 39
  }
]