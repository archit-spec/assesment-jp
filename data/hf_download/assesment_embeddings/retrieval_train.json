[{"query": "Bambora payment request transformation", "code": "use base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::ValueExt,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Deserializer, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct BamboraRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for BamboraRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct BamboraCard {\n    name: Secret<String>,\n    number: cards::CardNumber,\n    expiry_month: Secret<String>,\n    expiry_year: Secret<String>,\n    cvd: Secret<String>,\n    complete: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    #[serde(rename = \"3d_secure\")]\n    three_d_secure: Option<ThreeDSecure>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ThreeDSecure {\n    browser: Option<BamboraBrowserInfo>, //Needed only i\n\n... [truncated 25013 chars] ...\n\nive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct BamboraErrorResponse {\n    pub code: i32,\n    pub category: i32,\n    pub message: String,\n    pub reference: String,\n    pub details: Option<Vec<ErrorDetail>>,\n    pub validation: Option<CardValidation>,\n    pub card: Option<CardError>,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CardError {\n    pub avs: AVSDetails,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AVSDetails {\n    pub message: String,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ErrorDetail {\n    field: String,\n    message: String,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CardValidation {\n    id: String,\n    approved: i32,\n    message_id: i32,\n    message: String,\n    auth_code: String,\n    trans_date: String,\n    order_number: String,\n    type_: String,\n    amount: f64,\n    cvd_id: i32,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bambora__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bambora__transformers.rs"}, {"query": "BamboraCard struct definition", "code": "use base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::ValueExt,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Deserializer, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct BamboraRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for BamboraRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct BamboraCard {\n    name: Secret<String>,\n    number: cards::CardNumber,\n    expiry_month: Secret<String>,\n    expiry_year: Secret<String>,\n    cvd: Secret<String>,\n    complete: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    #[serde(rename = \"3d_secure\")]\n    three_d_secure: Option<ThreeDSecure>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ThreeDSecure {\n    browser: Option<BamboraBrowserInfo>, //Needed only i\n\n... [truncated 25013 chars] ...\n\nive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct BamboraErrorResponse {\n    pub code: i32,\n    pub category: i32,\n    pub message: String,\n    pub reference: String,\n    pub details: Option<Vec<ErrorDetail>>,\n    pub validation: Option<CardValidation>,\n    pub card: Option<CardError>,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CardError {\n    pub avs: AVSDetails,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AVSDetails {\n    pub message: String,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ErrorDetail {\n    field: String,\n    message: String,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CardValidation {\n    id: String,\n    approved: i32,\n    message_id: i32,\n    message: String,\n    auth_code: String,\n    trans_date: String,\n    order_number: String,\n    type_: String,\n    amount: f64,\n    cvd_id: i32,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bambora__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bambora__transformers.rs"}, {"query": "how to implement Bambora refund response", "code": "use base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::ValueExt,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Deserializer, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct BamboraRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for BamboraRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct BamboraCard {\n    name: Secret<String>,\n    number: cards::CardNumber,\n    expiry_month: Secret<String>,\n    expiry_year: Secret<String>,\n    cvd: Secret<String>,\n    complete: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    #[serde(rename = \"3d_secure\")]\n    three_d_secure: Option<ThreeDSecure>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ThreeDSecure {\n    browser: Option<BamboraBrowserInfo>, //Needed only i\n\n... [truncated 25013 chars] ...\n\nive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct BamboraErrorResponse {\n    pub code: i32,\n    pub category: i32,\n    pub message: String,\n    pub reference: String,\n    pub details: Option<Vec<ErrorDetail>>,\n    pub validation: Option<CardValidation>,\n    pub card: Option<CardError>,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CardError {\n    pub avs: AVSDetails,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AVSDetails {\n    pub message: String,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ErrorDetail {\n    field: String,\n    message: String,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CardValidation {\n    id: String,\n    approved: i32,\n    message_id: i32,\n    message: String,\n    auth_code: String,\n    trans_date: String,\n    order_number: String,\n    type_: String,\n    amount: f64,\n    cvd_id: i32,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bambora__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bambora__transformers.rs"}, {"query": "Bambora 3D secure browser info", "code": "use base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::ValueExt,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Deserializer, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct BamboraRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for BamboraRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct BamboraCard {\n    name: Secret<String>,\n    number: cards::CardNumber,\n    expiry_month: Secret<String>,\n    expiry_year: Secret<String>,\n    cvd: Secret<String>,\n    complete: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    #[serde(rename = \"3d_secure\")]\n    three_d_secure: Option<ThreeDSecure>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ThreeDSecure {\n    browser: Option<BamboraBrowserInfo>, //Needed only i\n\n... [truncated 25013 chars] ...\n\nive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct BamboraErrorResponse {\n    pub code: i32,\n    pub category: i32,\n    pub message: String,\n    pub reference: String,\n    pub details: Option<Vec<ErrorDetail>>,\n    pub validation: Option<CardValidation>,\n    pub card: Option<CardError>,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CardError {\n    pub avs: AVSDetails,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AVSDetails {\n    pub message: String,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ErrorDetail {\n    field: String,\n    message: String,\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CardValidation {\n    id: String,\n    approved: i32,\n    message_id: i32,\n    message: String,\n    auth_code: String,\n    trans_date: String,\n    order_number: String,\n    type_: String,\n    amount: f64,\n    cvd_id: i32,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bambora__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bambora__transformers.rs"}, {"query": "hyperswitch payment intent model", "code": "#[cfg(feature = \"v2\")]\nuse std::marker::PhantomData;\n\nuse api_models::customers::CustomerDocumentDetails;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{ConnectorMetadata, SessionToken, VaultSessionDetails};\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_types::{\n    payments::BillingDescriptor,\n    primitive_wrappers::{\n        AlwaysRequestExtendedAuthorization, EnableOvercaptureBool, RequestExtendedAuthorizationBool,\n    },\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::fp_utils;\nuse common_utils::{\n    self,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    id_type, pii,\n    types::{keymanager::ToEncryptable, CreatedBy, MinorUnit},\n};\nuse diesel_models::payment_intent::TaxDetails;\nuse error_stack::Report;\n#[cfg(feature = \"v2\")]\nuse error_stack::ResultExt;\nuse masking::Secret;\nuse router_derive::ToEncryption;\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\n\npub mod payment_attempt;\npub mod payment_intent;\n#[cfg(feature = \"v2\")]\npub mod split_payments;\n\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{FeatureMetadata, OrderDetailsWithAmount};\nuse masking::ExposeInterface;\n\nuse self::{payment_attempt::PaymentAttempt, payment_intent::CustomerData};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, business_profile, customer, errors, merchant_connector_account,\n    merchant_connector_account::MerchantConnectorAccountTypeDetails, payment_address,\n    payment_method_data, payment_methods, platform, revenue_recovery, routing,\n    ApiModelToDieselModelConvertor,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{payment_method_data, RemoteStorageObject};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, PartialEq, serde::Serialize, ToEncryption)]\npub struct PaymentIntent {\n    pub payment_id: id_type::PaymentId,\n    pub merchant_id: id_type::MerchantId,\n    pub status: storage_enums::IntentStatus,\n    pub amount: MinorUnit,\n    pub shipping\n\n... [truncated 62595 chars] ...\n\nub card_data: payment_method_data::Card,\n    pub network_token_data: payment_method_data::NetworkTokenData,\n}\n\nimpl VaultData {\n    pub fn get_card_vault_data(&self) -> Option<payment_method_data::Card> {\n        match self {\n            Self::Card(card_data) => Some(card_data.clone()),\n            Self::NetworkToken(_network_token_data) => None,\n            Self::CardAndNetworkToken(vault_data) => Some(vault_data.card_data.clone()),\n        }\n    }\n\n    pub fn get_network_token_data(&self) -> Option<payment_method_data::NetworkTokenData> {\n        match self {\n            Self::Card(_card_data) => None,\n            Self::NetworkToken(network_token_data) => Some(network_token_data.clone()),\n            Self::CardAndNetworkToken(vault_data) => Some(vault_data.network_token_data.clone()),\n        }\n    }\n}\n\n/// Guest customer details for connectors\n#[derive(Debug, serde::Serialize, serde::Deserialize, Clone, PartialEq)]\npub struct GuestCustomer {\n    pub customer_id: String,\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments.rs", "file": "crates__hyperswitch_domain_models__src__payments.rs"}, {"query": "how to handle card vaulting", "code": "#[cfg(feature = \"v2\")]\nuse std::marker::PhantomData;\n\nuse api_models::customers::CustomerDocumentDetails;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{ConnectorMetadata, SessionToken, VaultSessionDetails};\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_types::{\n    payments::BillingDescriptor,\n    primitive_wrappers::{\n        AlwaysRequestExtendedAuthorization, EnableOvercaptureBool, RequestExtendedAuthorizationBool,\n    },\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::fp_utils;\nuse common_utils::{\n    self,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    id_type, pii,\n    types::{keymanager::ToEncryptable, CreatedBy, MinorUnit},\n};\nuse diesel_models::payment_intent::TaxDetails;\nuse error_stack::Report;\n#[cfg(feature = \"v2\")]\nuse error_stack::ResultExt;\nuse masking::Secret;\nuse router_derive::ToEncryption;\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\n\npub mod payment_attempt;\npub mod payment_intent;\n#[cfg(feature = \"v2\")]\npub mod split_payments;\n\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{FeatureMetadata, OrderDetailsWithAmount};\nuse masking::ExposeInterface;\n\nuse self::{payment_attempt::PaymentAttempt, payment_intent::CustomerData};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, business_profile, customer, errors, merchant_connector_account,\n    merchant_connector_account::MerchantConnectorAccountTypeDetails, payment_address,\n    payment_method_data, payment_methods, platform, revenue_recovery, routing,\n    ApiModelToDieselModelConvertor,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{payment_method_data, RemoteStorageObject};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, PartialEq, serde::Serialize, ToEncryption)]\npub struct PaymentIntent {\n    pub payment_id: id_type::PaymentId,\n    pub merchant_id: id_type::MerchantId,\n    pub status: storage_enums::IntentStatus,\n    pub amount: MinorUnit,\n    pub shipping\n\n... [truncated 62595 chars] ...\n\nub card_data: payment_method_data::Card,\n    pub network_token_data: payment_method_data::NetworkTokenData,\n}\n\nimpl VaultData {\n    pub fn get_card_vault_data(&self) -> Option<payment_method_data::Card> {\n        match self {\n            Self::Card(card_data) => Some(card_data.clone()),\n            Self::NetworkToken(_network_token_data) => None,\n            Self::CardAndNetworkToken(vault_data) => Some(vault_data.card_data.clone()),\n        }\n    }\n\n    pub fn get_network_token_data(&self) -> Option<payment_method_data::NetworkTokenData> {\n        match self {\n            Self::Card(_card_data) => None,\n            Self::NetworkToken(network_token_data) => Some(network_token_data.clone()),\n            Self::CardAndNetworkToken(vault_data) => Some(vault_data.network_token_data.clone()),\n        }\n    }\n}\n\n/// Guest customer details for connectors\n#[derive(Debug, serde::Serialize, serde::Deserialize, Clone, PartialEq)]\npub struct GuestCustomer {\n    pub customer_id: String,\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments.rs", "file": "crates__hyperswitch_domain_models__src__payments.rs"}, {"query": "payment orchestration payment attempt", "code": "#[cfg(feature = \"v2\")]\nuse std::marker::PhantomData;\n\nuse api_models::customers::CustomerDocumentDetails;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{ConnectorMetadata, SessionToken, VaultSessionDetails};\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_types::{\n    payments::BillingDescriptor,\n    primitive_wrappers::{\n        AlwaysRequestExtendedAuthorization, EnableOvercaptureBool, RequestExtendedAuthorizationBool,\n    },\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::fp_utils;\nuse common_utils::{\n    self,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    id_type, pii,\n    types::{keymanager::ToEncryptable, CreatedBy, MinorUnit},\n};\nuse diesel_models::payment_intent::TaxDetails;\nuse error_stack::Report;\n#[cfg(feature = \"v2\")]\nuse error_stack::ResultExt;\nuse masking::Secret;\nuse router_derive::ToEncryption;\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\n\npub mod payment_attempt;\npub mod payment_intent;\n#[cfg(feature = \"v2\")]\npub mod split_payments;\n\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{FeatureMetadata, OrderDetailsWithAmount};\nuse masking::ExposeInterface;\n\nuse self::{payment_attempt::PaymentAttempt, payment_intent::CustomerData};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, business_profile, customer, errors, merchant_connector_account,\n    merchant_connector_account::MerchantConnectorAccountTypeDetails, payment_address,\n    payment_method_data, payment_methods, platform, revenue_recovery, routing,\n    ApiModelToDieselModelConvertor,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{payment_method_data, RemoteStorageObject};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, PartialEq, serde::Serialize, ToEncryption)]\npub struct PaymentIntent {\n    pub payment_id: id_type::PaymentId,\n    pub merchant_id: id_type::MerchantId,\n    pub status: storage_enums::IntentStatus,\n    pub amount: MinorUnit,\n    pub shipping\n\n... [truncated 62595 chars] ...\n\nub card_data: payment_method_data::Card,\n    pub network_token_data: payment_method_data::NetworkTokenData,\n}\n\nimpl VaultData {\n    pub fn get_card_vault_data(&self) -> Option<payment_method_data::Card> {\n        match self {\n            Self::Card(card_data) => Some(card_data.clone()),\n            Self::NetworkToken(_network_token_data) => None,\n            Self::CardAndNetworkToken(vault_data) => Some(vault_data.card_data.clone()),\n        }\n    }\n\n    pub fn get_network_token_data(&self) -> Option<payment_method_data::NetworkTokenData> {\n        match self {\n            Self::Card(_card_data) => None,\n            Self::NetworkToken(network_token_data) => Some(network_token_data.clone()),\n            Self::CardAndNetworkToken(vault_data) => Some(vault_data.network_token_data.clone()),\n        }\n    }\n}\n\n/// Guest customer details for connectors\n#[derive(Debug, serde::Serialize, serde::Deserialize, Clone, PartialEq)]\npub struct GuestCustomer {\n    pub customer_id: String,\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments.rs", "file": "crates__hyperswitch_domain_models__src__payments.rs"}, {"query": "payment method data types", "code": "#[cfg(feature = \"v2\")]\nuse std::marker::PhantomData;\n\nuse api_models::customers::CustomerDocumentDetails;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{ConnectorMetadata, SessionToken, VaultSessionDetails};\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_types::{\n    payments::BillingDescriptor,\n    primitive_wrappers::{\n        AlwaysRequestExtendedAuthorization, EnableOvercaptureBool, RequestExtendedAuthorizationBool,\n    },\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::fp_utils;\nuse common_utils::{\n    self,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    id_type, pii,\n    types::{keymanager::ToEncryptable, CreatedBy, MinorUnit},\n};\nuse diesel_models::payment_intent::TaxDetails;\nuse error_stack::Report;\n#[cfg(feature = \"v2\")]\nuse error_stack::ResultExt;\nuse masking::Secret;\nuse router_derive::ToEncryption;\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\n\npub mod payment_attempt;\npub mod payment_intent;\n#[cfg(feature = \"v2\")]\npub mod split_payments;\n\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{FeatureMetadata, OrderDetailsWithAmount};\nuse masking::ExposeInterface;\n\nuse self::{payment_attempt::PaymentAttempt, payment_intent::CustomerData};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, business_profile, customer, errors, merchant_connector_account,\n    merchant_connector_account::MerchantConnectorAccountTypeDetails, payment_address,\n    payment_method_data, payment_methods, platform, revenue_recovery, routing,\n    ApiModelToDieselModelConvertor,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{payment_method_data, RemoteStorageObject};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, PartialEq, serde::Serialize, ToEncryption)]\npub struct PaymentIntent {\n    pub payment_id: id_type::PaymentId,\n    pub merchant_id: id_type::MerchantId,\n    pub status: storage_enums::IntentStatus,\n    pub amount: MinorUnit,\n    pub shipping\n\n... [truncated 62595 chars] ...\n\nub card_data: payment_method_data::Card,\n    pub network_token_data: payment_method_data::NetworkTokenData,\n}\n\nimpl VaultData {\n    pub fn get_card_vault_data(&self) -> Option<payment_method_data::Card> {\n        match self {\n            Self::Card(card_data) => Some(card_data.clone()),\n            Self::NetworkToken(_network_token_data) => None,\n            Self::CardAndNetworkToken(vault_data) => Some(vault_data.card_data.clone()),\n        }\n    }\n\n    pub fn get_network_token_data(&self) -> Option<payment_method_data::NetworkTokenData> {\n        match self {\n            Self::Card(_card_data) => None,\n            Self::NetworkToken(network_token_data) => Some(network_token_data.clone()),\n            Self::CardAndNetworkToken(vault_data) => Some(vault_data.network_token_data.clone()),\n        }\n    }\n}\n\n/// Guest customer details for connectors\n#[derive(Debug, serde::Serialize, serde::Deserialize, Clone, PartialEq)]\npub struct GuestCustomer {\n    pub customer_id: String,\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments.rs", "file": "crates__hyperswitch_domain_models__src__payments.rs"}, {"query": "Getnet payment gateway integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::{self, Engine};\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::{self},\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{self},\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse ring::hmac;\nuse transformers as getnet;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Getnet {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Getnet {\n    pub fn new() -\n\n... [truncated 28519 chars] ...\n\n\nstatic GETNET_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Getnet\",\n    description: \"Getnet is a high-tech global payment platform that helps businesses accept payments securely while providing the best frictionless experience for customers everywhere.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic GETNET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Getnet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GETNET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GETNET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GETNET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__getnet.rs", "file": "crates__hyperswitch_connectors__src__connectors__getnet.rs"}, {"query": "hyperswitch Getnet connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::{self, Engine};\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::{self},\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{self},\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse ring::hmac;\nuse transformers as getnet;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Getnet {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Getnet {\n    pub fn new() -\n\n... [truncated 28519 chars] ...\n\n\nstatic GETNET_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Getnet\",\n    description: \"Getnet is a high-tech global payment platform that helps businesses accept payments securely while providing the best frictionless experience for customers everywhere.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic GETNET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Getnet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GETNET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GETNET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GETNET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__getnet.rs", "file": "crates__hyperswitch_connectors__src__connectors__getnet.rs"}, {"query": "how to configure Getnet connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::{self, Engine};\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::{self},\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{self},\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse ring::hmac;\nuse transformers as getnet;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Getnet {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Getnet {\n    pub fn new() -\n\n... [truncated 28519 chars] ...\n\n\nstatic GETNET_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Getnet\",\n    description: \"Getnet is a high-tech global payment platform that helps businesses accept payments securely while providing the best frictionless experience for customers everywhere.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic GETNET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Getnet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GETNET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GETNET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GETNET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__getnet.rs", "file": "crates__hyperswitch_connectors__src__connectors__getnet.rs"}, {"query": "Getnet HMAC signature authentication", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::{self, Engine};\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::{self},\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{self},\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse ring::hmac;\nuse transformers as getnet;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Getnet {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Getnet {\n    pub fn new() -\n\n... [truncated 28519 chars] ...\n\n\nstatic GETNET_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Getnet\",\n    description: \"Getnet is a high-tech global payment platform that helps businesses accept payments securely while providing the best frictionless experience for customers everywhere.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic GETNET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Getnet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GETNET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GETNET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GETNET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__getnet.rs", "file": "crates__hyperswitch_connectors__src__connectors__getnet.rs"}, {"query": "Hyperswitch storage abstraction layer", "code": "use std::{fmt::Debug, sync::Arc};\n\nuse common_utils::types::TenantConfig;\nuse diesel_models as store;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_key_store::MerchantKeyStore,\n};\nuse masking::StrongSecret;\nuse redis::{kv_store::RedisConnInterface, pub_sub::PubSubInterface, RedisStore};\nmod address;\npub mod business_profile;\npub mod callback_mapper;\npub mod cards_info;\npub mod config;\npub mod configs;\npub mod connection;\npub mod customers;\npub mod database;\npub mod errors;\npub mod invoice;\npub mod kv_router_store;\npub mod lookup;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod metrics;\npub mod mock_db;\npub mod payment_method;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform_wrapper;\npub mod redis;\npub mod refund;\nmod reverse_lookup;\npub mod subscription;\npub mod utils;\n\nuse common_utils::{errors::CustomResult, types::keymanager::KeyManagerState};\nuse database::store::PgPool;\npub mod tokenization;\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\npub use mock_db::MockDb;\nuse redis_interface::{errors::RedisError, RedisConnectionPool, SaddReply};\n\n#[cfg(not(feature = \"payouts\"))]\npub use crate::database::store::Store;\npub use crate::{database::store::DatabaseStore, errors::StorageError};\n\n#[derive(Debug, Clone)]\npub struct RouterStore<T: DatabaseStore> {\n    db_store: T,\n    cache_store: Arc<RedisStore>,\n    master_encryption_key: StrongSecret<Vec<u8>>,\n    pub request_id: Option<String>,\n    key_manager_state: Option<KeyManagerState>,\n}\n\nimpl<T: DatabaseStore> RouterStore<T> {\n    pub fn set_key_manager_state(&mut self, state: KeyManagerState) {\n        self.key_manager_state = Some(state);\n    }\n    fn get_keymanager_state(&self) -> Result<&KeyManagerState, StorageError> {\n        self.key_manager_state\n            .as_ref()\n            .ok_or_else(\n\n... [truncated 13868 chars] ...\n\n     vec![format!(\n            \"customer_{}_{}\",\n            self.customer_id.get_string_repr(),\n            self.merchant_id.get_string_repr(),\n        )]\n    }\n    fn table_name(&self) -> &str {\n        \"Customer\"\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl UniqueConstraints for diesel_models::Customer {\n    fn unique_constraints(&self) -> Vec<String> {\n        vec![format!(\"customer_{}\", self.id.get_string_repr())]\n    }\n    fn table_name(&self) -> &str {\n        \"Customer\"\n    }\n}\n\n#[cfg(not(feature = \"payouts\"))]\nimpl<T: DatabaseStore> PayoutAttemptInterface for RouterStore<T> {}\n#[cfg(not(feature = \"payouts\"))]\nimpl<T: DatabaseStore> PayoutsInterface for RouterStore<T> {}\n\n#[cfg(all(feature = \"v2\", feature = \"tokenization_v2\"))]\nimpl UniqueConstraints for diesel_models::tokenization::Tokenization {\n    fn unique_constraints(&self) -> Vec<String> {\n        vec![format!(\"id_{}\", self.id.get_string_repr())]\n    }\n\n    fn table_name(&self) -> &str {\n        \"tokenization\"\n    }\n}\n", "function_name": "crates__storage_impl__src__lib.rs", "file": "crates__storage_impl__src__lib.rs"}, {"query": "RouterStore struct implementation", "code": "use std::{fmt::Debug, sync::Arc};\n\nuse common_utils::types::TenantConfig;\nuse diesel_models as store;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_key_store::MerchantKeyStore,\n};\nuse masking::StrongSecret;\nuse redis::{kv_store::RedisConnInterface, pub_sub::PubSubInterface, RedisStore};\nmod address;\npub mod business_profile;\npub mod callback_mapper;\npub mod cards_info;\npub mod config;\npub mod configs;\npub mod connection;\npub mod customers;\npub mod database;\npub mod errors;\npub mod invoice;\npub mod kv_router_store;\npub mod lookup;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod metrics;\npub mod mock_db;\npub mod payment_method;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform_wrapper;\npub mod redis;\npub mod refund;\nmod reverse_lookup;\npub mod subscription;\npub mod utils;\n\nuse common_utils::{errors::CustomResult, types::keymanager::KeyManagerState};\nuse database::store::PgPool;\npub mod tokenization;\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\npub use mock_db::MockDb;\nuse redis_interface::{errors::RedisError, RedisConnectionPool, SaddReply};\n\n#[cfg(not(feature = \"payouts\"))]\npub use crate::database::store::Store;\npub use crate::{database::store::DatabaseStore, errors::StorageError};\n\n#[derive(Debug, Clone)]\npub struct RouterStore<T: DatabaseStore> {\n    db_store: T,\n    cache_store: Arc<RedisStore>,\n    master_encryption_key: StrongSecret<Vec<u8>>,\n    pub request_id: Option<String>,\n    key_manager_state: Option<KeyManagerState>,\n}\n\nimpl<T: DatabaseStore> RouterStore<T> {\n    pub fn set_key_manager_state(&mut self, state: KeyManagerState) {\n        self.key_manager_state = Some(state);\n    }\n    fn get_keymanager_state(&self) -> Result<&KeyManagerState, StorageError> {\n        self.key_manager_state\n            .as_ref()\n            .ok_or_else(\n\n... [truncated 13868 chars] ...\n\n     vec![format!(\n            \"customer_{}_{}\",\n            self.customer_id.get_string_repr(),\n            self.merchant_id.get_string_repr(),\n        )]\n    }\n    fn table_name(&self) -> &str {\n        \"Customer\"\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl UniqueConstraints for diesel_models::Customer {\n    fn unique_constraints(&self) -> Vec<String> {\n        vec![format!(\"customer_{}\", self.id.get_string_repr())]\n    }\n    fn table_name(&self) -> &str {\n        \"Customer\"\n    }\n}\n\n#[cfg(not(feature = \"payouts\"))]\nimpl<T: DatabaseStore> PayoutAttemptInterface for RouterStore<T> {}\n#[cfg(not(feature = \"payouts\"))]\nimpl<T: DatabaseStore> PayoutsInterface for RouterStore<T> {}\n\n#[cfg(all(feature = \"v2\", feature = \"tokenization_v2\"))]\nimpl UniqueConstraints for diesel_models::tokenization::Tokenization {\n    fn unique_constraints(&self) -> Vec<String> {\n        vec![format!(\"id_{}\", self.id.get_string_repr())]\n    }\n\n    fn table_name(&self) -> &str {\n        \"tokenization\"\n    }\n}\n", "function_name": "crates__storage_impl__src__lib.rs", "file": "crates__storage_impl__src__lib.rs"}, {"query": "how to implement DatabaseStore trait", "code": "use std::{fmt::Debug, sync::Arc};\n\nuse common_utils::types::TenantConfig;\nuse diesel_models as store;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_key_store::MerchantKeyStore,\n};\nuse masking::StrongSecret;\nuse redis::{kv_store::RedisConnInterface, pub_sub::PubSubInterface, RedisStore};\nmod address;\npub mod business_profile;\npub mod callback_mapper;\npub mod cards_info;\npub mod config;\npub mod configs;\npub mod connection;\npub mod customers;\npub mod database;\npub mod errors;\npub mod invoice;\npub mod kv_router_store;\npub mod lookup;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod metrics;\npub mod mock_db;\npub mod payment_method;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform_wrapper;\npub mod redis;\npub mod refund;\nmod reverse_lookup;\npub mod subscription;\npub mod utils;\n\nuse common_utils::{errors::CustomResult, types::keymanager::KeyManagerState};\nuse database::store::PgPool;\npub mod tokenization;\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\npub use mock_db::MockDb;\nuse redis_interface::{errors::RedisError, RedisConnectionPool, SaddReply};\n\n#[cfg(not(feature = \"payouts\"))]\npub use crate::database::store::Store;\npub use crate::{database::store::DatabaseStore, errors::StorageError};\n\n#[derive(Debug, Clone)]\npub struct RouterStore<T: DatabaseStore> {\n    db_store: T,\n    cache_store: Arc<RedisStore>,\n    master_encryption_key: StrongSecret<Vec<u8>>,\n    pub request_id: Option<String>,\n    key_manager_state: Option<KeyManagerState>,\n}\n\nimpl<T: DatabaseStore> RouterStore<T> {\n    pub fn set_key_manager_state(&mut self, state: KeyManagerState) {\n        self.key_manager_state = Some(state);\n    }\n    fn get_keymanager_state(&self) -> Result<&KeyManagerState, StorageError> {\n        self.key_manager_state\n            .as_ref()\n            .ok_or_else(\n\n... [truncated 13868 chars] ...\n\n     vec![format!(\n            \"customer_{}_{}\",\n            self.customer_id.get_string_repr(),\n            self.merchant_id.get_string_repr(),\n        )]\n    }\n    fn table_name(&self) -> &str {\n        \"Customer\"\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl UniqueConstraints for diesel_models::Customer {\n    fn unique_constraints(&self) -> Vec<String> {\n        vec![format!(\"customer_{}\", self.id.get_string_repr())]\n    }\n    fn table_name(&self) -> &str {\n        \"Customer\"\n    }\n}\n\n#[cfg(not(feature = \"payouts\"))]\nimpl<T: DatabaseStore> PayoutAttemptInterface for RouterStore<T> {}\n#[cfg(not(feature = \"payouts\"))]\nimpl<T: DatabaseStore> PayoutsInterface for RouterStore<T> {}\n\n#[cfg(all(feature = \"v2\", feature = \"tokenization_v2\"))]\nimpl UniqueConstraints for diesel_models::tokenization::Tokenization {\n    fn unique_constraints(&self) -> Vec<String> {\n        vec![format!(\"id_{}\", self.id.get_string_repr())]\n    }\n\n    fn table_name(&self) -> &str {\n        \"tokenization\"\n    }\n}\n", "function_name": "crates__storage_impl__src__lib.rs", "file": "crates__storage_impl__src__lib.rs"}, {"query": "payment orchestration storage backend", "code": "use std::{fmt::Debug, sync::Arc};\n\nuse common_utils::types::TenantConfig;\nuse diesel_models as store;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_key_store::MerchantKeyStore,\n};\nuse masking::StrongSecret;\nuse redis::{kv_store::RedisConnInterface, pub_sub::PubSubInterface, RedisStore};\nmod address;\npub mod business_profile;\npub mod callback_mapper;\npub mod cards_info;\npub mod config;\npub mod configs;\npub mod connection;\npub mod customers;\npub mod database;\npub mod errors;\npub mod invoice;\npub mod kv_router_store;\npub mod lookup;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod metrics;\npub mod mock_db;\npub mod payment_method;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform_wrapper;\npub mod redis;\npub mod refund;\nmod reverse_lookup;\npub mod subscription;\npub mod utils;\n\nuse common_utils::{errors::CustomResult, types::keymanager::KeyManagerState};\nuse database::store::PgPool;\npub mod tokenization;\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\npub use mock_db::MockDb;\nuse redis_interface::{errors::RedisError, RedisConnectionPool, SaddReply};\n\n#[cfg(not(feature = \"payouts\"))]\npub use crate::database::store::Store;\npub use crate::{database::store::DatabaseStore, errors::StorageError};\n\n#[derive(Debug, Clone)]\npub struct RouterStore<T: DatabaseStore> {\n    db_store: T,\n    cache_store: Arc<RedisStore>,\n    master_encryption_key: StrongSecret<Vec<u8>>,\n    pub request_id: Option<String>,\n    key_manager_state: Option<KeyManagerState>,\n}\n\nimpl<T: DatabaseStore> RouterStore<T> {\n    pub fn set_key_manager_state(&mut self, state: KeyManagerState) {\n        self.key_manager_state = Some(state);\n    }\n    fn get_keymanager_state(&self) -> Result<&KeyManagerState, StorageError> {\n        self.key_manager_state\n            .as_ref()\n            .ok_or_else(\n\n... [truncated 13868 chars] ...\n\n     vec![format!(\n            \"customer_{}_{}\",\n            self.customer_id.get_string_repr(),\n            self.merchant_id.get_string_repr(),\n        )]\n    }\n    fn table_name(&self) -> &str {\n        \"Customer\"\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl UniqueConstraints for diesel_models::Customer {\n    fn unique_constraints(&self) -> Vec<String> {\n        vec![format!(\"customer_{}\", self.id.get_string_repr())]\n    }\n    fn table_name(&self) -> &str {\n        \"Customer\"\n    }\n}\n\n#[cfg(not(feature = \"payouts\"))]\nimpl<T: DatabaseStore> PayoutAttemptInterface for RouterStore<T> {}\n#[cfg(not(feature = \"payouts\"))]\nimpl<T: DatabaseStore> PayoutsInterface for RouterStore<T> {}\n\n#[cfg(all(feature = \"v2\", feature = \"tokenization_v2\"))]\nimpl UniqueConstraints for diesel_models::tokenization::Tokenization {\n    fn unique_constraints(&self) -> Vec<String> {\n        vec![format!(\"id_{}\", self.id.get_string_repr())]\n    }\n\n    fn table_name(&self) -> &str {\n        \"tokenization\"\n    }\n}\n", "function_name": "crates__storage_impl__src__lib.rs", "file": "crates__storage_impl__src__lib.rs"}, {"query": "how does the Payeezy connector work", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse rand::distributions::DistString;\nuse ring::hmac;\nuse transformers as payeezy;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Payeezy;\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payeezy\nwhere\n    Self: ConnectorIntegrati\n\n... [truncated 19484 chars] ...\n\n,\n    description: \"Payeezy is a payment gateway platform that facilitates online and mobile payment processing for businesses. It provides a range of features, including support for various payment methods, security features like PCI-DSS compliance and tokenization, and tools for managing transactions and customer interactions.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic PAYEEZY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Payeezy {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYEEZY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYEEZY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYEEZY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payeezy.rs", "file": "crates__hyperswitch_connectors__src__connectors__payeezy.rs"}, {"query": "Payeezy signature generation implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse rand::distributions::DistString;\nuse ring::hmac;\nuse transformers as payeezy;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Payeezy;\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payeezy\nwhere\n    Self: ConnectorIntegrati\n\n... [truncated 19484 chars] ...\n\n,\n    description: \"Payeezy is a payment gateway platform that facilitates online and mobile payment processing for businesses. It provides a range of features, including support for various payment methods, security features like PCI-DSS compliance and tokenization, and tools for managing transactions and customer interactions.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic PAYEEZY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Payeezy {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYEEZY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYEEZY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYEEZY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payeezy.rs", "file": "crates__hyperswitch_connectors__src__connectors__payeezy.rs"}, {"query": "implement Payeezy payment gateway integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse rand::distributions::DistString;\nuse ring::hmac;\nuse transformers as payeezy;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Payeezy;\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payeezy\nwhere\n    Self: ConnectorIntegrati\n\n... [truncated 19484 chars] ...\n\n,\n    description: \"Payeezy is a payment gateway platform that facilitates online and mobile payment processing for businesses. It provides a range of features, including support for various payment methods, security features like PCI-DSS compliance and tokenization, and tools for managing transactions and customer interactions.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic PAYEEZY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Payeezy {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYEEZY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYEEZY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYEEZY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payeezy.rs", "file": "crates__hyperswitch_connectors__src__connectors__payeezy.rs"}, {"query": "Hyperswitch Payeezy authorize capture flow", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse rand::distributions::DistString;\nuse ring::hmac;\nuse transformers as payeezy;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Payeezy;\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payeezy\nwhere\n    Self: ConnectorIntegrati\n\n... [truncated 19484 chars] ...\n\n,\n    description: \"Payeezy is a payment gateway platform that facilitates online and mobile payment processing for businesses. It provides a range of features, including support for various payment methods, security features like PCI-DSS compliance and tokenization, and tools for managing transactions and customer interactions.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic PAYEEZY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Payeezy {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYEEZY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYEEZY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYEEZY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payeezy.rs", "file": "crates__hyperswitch_connectors__src__connectors__payeezy.rs"}, {"query": "ZSL connector implementation hyperswitch", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSessionRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Secret};\nuse transformers::{self as zsl, get_status};\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n};\n\n#[derive(Debug, Clone)]\npub stru\n\n... [truncated 14220 chars] ...\n\nific_features: None,\n            },\n        );\n\n        zsl_supported_payment_methods\n    };\n\n    static ref ZSL_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"ZSL\",\n        description:\n            \"Zsl is a payment gateway operating in China, specializing in facilitating local bank transfers\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\n    static ref ZSL_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Zsl {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*ZSL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZSL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*ZSL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zsl.rs", "file": "crates__hyperswitch_connectors__src__connectors__zsl.rs"}, {"query": "hyperswitch payment gateway integration rust", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSessionRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Secret};\nuse transformers::{self as zsl, get_status};\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n};\n\n#[derive(Debug, Clone)]\npub stru\n\n... [truncated 14220 chars] ...\n\nific_features: None,\n            },\n        );\n\n        zsl_supported_payment_methods\n    };\n\n    static ref ZSL_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"ZSL\",\n        description:\n            \"Zsl is a payment gateway operating in China, specializing in facilitating local bank transfers\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\n    static ref ZSL_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Zsl {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*ZSL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZSL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*ZSL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zsl.rs", "file": "crates__hyperswitch_connectors__src__connectors__zsl.rs"}, {"query": "how to add new connector hyperswitch", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSessionRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Secret};\nuse transformers::{self as zsl, get_status};\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n};\n\n#[derive(Debug, Clone)]\npub stru\n\n... [truncated 14220 chars] ...\n\nific_features: None,\n            },\n        );\n\n        zsl_supported_payment_methods\n    };\n\n    static ref ZSL_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"ZSL\",\n        description:\n            \"Zsl is a payment gateway operating in China, specializing in facilitating local bank transfers\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\n    static ref ZSL_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Zsl {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*ZSL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZSL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*ZSL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zsl.rs", "file": "crates__hyperswitch_connectors__src__connectors__zsl.rs"}, {"query": "zsl bank transfer payment method hyperswitch", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSessionRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Secret};\nuse transformers::{self as zsl, get_status};\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n};\n\n#[derive(Debug, Clone)]\npub stru\n\n... [truncated 14220 chars] ...\n\nific_features: None,\n            },\n        );\n\n        zsl_supported_payment_methods\n    };\n\n    static ref ZSL_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"ZSL\",\n        description:\n            \"Zsl is a payment gateway operating in China, specializing in facilitating local bank transfers\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\n    static ref ZSL_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Zsl {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*ZSL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZSL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*ZSL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zsl.rs", "file": "crates__hyperswitch_connectors__src__connectors__zsl.rs"}, {"query": "how to store card details in hyperswitch", "code": "pub use ::payment_methods::controller::{DataDuplicationCheck, DeleteCardResp};\nuse api_models::payment_methods::Card;\n#[cfg(feature = \"v2\")]\nuse api_models::{enums as api_enums, payment_methods::PaymentMethodResponseItem};\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v1\")]\nuse common_utils::{crypto::Encryptable, request::Headers, types::keymanager::KeyManagerState};\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, StringExt},\n    id_type,\n    pii::{Email, SecretSerdeValue},\n    request::RequestContent,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data;\nuse josekit::jwe;\n#[cfg(feature = \"v1\")]\nuse masking::Mask;\nuse masking::{ExposeInterface, PeekInterface};\n#[cfg(feature = \"v1\")]\nuse payment_methods::client::{\n    self as pm_client,\n    create::{CreatePaymentMethodResponse, CreatePaymentMethodV1Request},\n    retrieve::{RetrievePaymentMethodResponse, RetrievePaymentMethodV1Request},\n    UpdatePaymentMethod, UpdatePaymentMethodV1Payload, UpdatePaymentMethodV1Request,\n};\nuse router_env::RequestId;\n#[cfg(feature = \"v1\")]\nuse router_env::{logger, RequestIdentifier};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    configs::settings,\n    core::{\n        errors::{self, CustomResult},\n        payment_methods::cards::{call_vault_service, create_encrypted_data},\n    },\n    headers,\n    pii::Secret,\n    routes,\n    services::{api as services, encryption, EncryptionAlgorithm},\n    types::{api, domain},\n    utils::OptionExt,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    consts,\n    types::{payment_methods as pm_types, transformers},\n};\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum StoreLockerReq {\n    LockerCard(StoreCardReq),\n    LockerGeneric(StoreGenericReq),\n}\n\nimpl StoreLockerReq {\n    pub fn update_requestor_card_reference(&mut self, card_reference: Option<String>) {\n        match self {\n            Self::LockerCard(c) => c.requestor_card_reference = card_reference,\n            Self::LockerGeneric(_) => ()\n\n... [truncated 62635 chars] ...\n\ny.clone().expose().to_string().into_masked(),\n    ));\n    parent_headers.insert((\n        headers::X_MERCHANT_ID.to_string(),\n        merchant_id.get_string_repr().to_string().into_masked(),\n    ));\n\n    let trace = RequestIdentifier::new(&state.conf.trace_header.header_name)\n        .use_incoming_id(state.conf.trace_header.id_reuse_strategy);\n\n    //pm client construction\n    let client = pm_client::PaymentMethodClient::new(\n        &state.conf.micro_services.payment_methods_base_url,\n        &parent_headers,\n        &trace,\n    );\n\n    //Modular service call\n    let pm_response =\n        pm_client::CreatePaymentMethod::call(state, &client, payment_method_create_req)\n            .await\n            .map_err(|err| {\n                logger::debug!(\"Error in creating payment method: {:?}\", err);\n                errors::ApiErrorResponse::InternalServerError\n            })\n            .attach_printable(\"Failed to create payment method in modular service\")?;\n\n    Ok(pm_response)\n}\n", "function_name": "crates__router__src__core__payment_methods__transformers.rs", "file": "crates__router__src__core__payment_methods__transformers.rs"}, {"query": "payment method transformer implementation", "code": "pub use ::payment_methods::controller::{DataDuplicationCheck, DeleteCardResp};\nuse api_models::payment_methods::Card;\n#[cfg(feature = \"v2\")]\nuse api_models::{enums as api_enums, payment_methods::PaymentMethodResponseItem};\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v1\")]\nuse common_utils::{crypto::Encryptable, request::Headers, types::keymanager::KeyManagerState};\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, StringExt},\n    id_type,\n    pii::{Email, SecretSerdeValue},\n    request::RequestContent,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data;\nuse josekit::jwe;\n#[cfg(feature = \"v1\")]\nuse masking::Mask;\nuse masking::{ExposeInterface, PeekInterface};\n#[cfg(feature = \"v1\")]\nuse payment_methods::client::{\n    self as pm_client,\n    create::{CreatePaymentMethodResponse, CreatePaymentMethodV1Request},\n    retrieve::{RetrievePaymentMethodResponse, RetrievePaymentMethodV1Request},\n    UpdatePaymentMethod, UpdatePaymentMethodV1Payload, UpdatePaymentMethodV1Request,\n};\nuse router_env::RequestId;\n#[cfg(feature = \"v1\")]\nuse router_env::{logger, RequestIdentifier};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    configs::settings,\n    core::{\n        errors::{self, CustomResult},\n        payment_methods::cards::{call_vault_service, create_encrypted_data},\n    },\n    headers,\n    pii::Secret,\n    routes,\n    services::{api as services, encryption, EncryptionAlgorithm},\n    types::{api, domain},\n    utils::OptionExt,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    consts,\n    types::{payment_methods as pm_types, transformers},\n};\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum StoreLockerReq {\n    LockerCard(StoreCardReq),\n    LockerGeneric(StoreGenericReq),\n}\n\nimpl StoreLockerReq {\n    pub fn update_requestor_card_reference(&mut self, card_reference: Option<String>) {\n        match self {\n            Self::LockerCard(c) => c.requestor_card_reference = card_reference,\n            Self::LockerGeneric(_) => ()\n\n... [truncated 62635 chars] ...\n\ny.clone().expose().to_string().into_masked(),\n    ));\n    parent_headers.insert((\n        headers::X_MERCHANT_ID.to_string(),\n        merchant_id.get_string_repr().to_string().into_masked(),\n    ));\n\n    let trace = RequestIdentifier::new(&state.conf.trace_header.header_name)\n        .use_incoming_id(state.conf.trace_header.id_reuse_strategy);\n\n    //pm client construction\n    let client = pm_client::PaymentMethodClient::new(\n        &state.conf.micro_services.payment_methods_base_url,\n        &parent_headers,\n        &trace,\n    );\n\n    //Modular service call\n    let pm_response =\n        pm_client::CreatePaymentMethod::call(state, &client, payment_method_create_req)\n            .await\n            .map_err(|err| {\n                logger::debug!(\"Error in creating payment method: {:?}\", err);\n                errors::ApiErrorResponse::InternalServerError\n            })\n            .attach_printable(\"Failed to create payment method in modular service\")?;\n\n    Ok(pm_response)\n}\n", "function_name": "crates__router__src__core__payment_methods__transformers.rs", "file": "crates__router__src__core__payment_methods__transformers.rs"}, {"query": "create payment method v1 request structure", "code": "pub use ::payment_methods::controller::{DataDuplicationCheck, DeleteCardResp};\nuse api_models::payment_methods::Card;\n#[cfg(feature = \"v2\")]\nuse api_models::{enums as api_enums, payment_methods::PaymentMethodResponseItem};\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v1\")]\nuse common_utils::{crypto::Encryptable, request::Headers, types::keymanager::KeyManagerState};\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, StringExt},\n    id_type,\n    pii::{Email, SecretSerdeValue},\n    request::RequestContent,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data;\nuse josekit::jwe;\n#[cfg(feature = \"v1\")]\nuse masking::Mask;\nuse masking::{ExposeInterface, PeekInterface};\n#[cfg(feature = \"v1\")]\nuse payment_methods::client::{\n    self as pm_client,\n    create::{CreatePaymentMethodResponse, CreatePaymentMethodV1Request},\n    retrieve::{RetrievePaymentMethodResponse, RetrievePaymentMethodV1Request},\n    UpdatePaymentMethod, UpdatePaymentMethodV1Payload, UpdatePaymentMethodV1Request,\n};\nuse router_env::RequestId;\n#[cfg(feature = \"v1\")]\nuse router_env::{logger, RequestIdentifier};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    configs::settings,\n    core::{\n        errors::{self, CustomResult},\n        payment_methods::cards::{call_vault_service, create_encrypted_data},\n    },\n    headers,\n    pii::Secret,\n    routes,\n    services::{api as services, encryption, EncryptionAlgorithm},\n    types::{api, domain},\n    utils::OptionExt,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    consts,\n    types::{payment_methods as pm_types, transformers},\n};\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum StoreLockerReq {\n    LockerCard(StoreCardReq),\n    LockerGeneric(StoreGenericReq),\n}\n\nimpl StoreLockerReq {\n    pub fn update_requestor_card_reference(&mut self, card_reference: Option<String>) {\n        match self {\n            Self::LockerCard(c) => c.requestor_card_reference = card_reference,\n            Self::LockerGeneric(_) => ()\n\n... [truncated 62635 chars] ...\n\ny.clone().expose().to_string().into_masked(),\n    ));\n    parent_headers.insert((\n        headers::X_MERCHANT_ID.to_string(),\n        merchant_id.get_string_repr().to_string().into_masked(),\n    ));\n\n    let trace = RequestIdentifier::new(&state.conf.trace_header.header_name)\n        .use_incoming_id(state.conf.trace_header.id_reuse_strategy);\n\n    //pm client construction\n    let client = pm_client::PaymentMethodClient::new(\n        &state.conf.micro_services.payment_methods_base_url,\n        &parent_headers,\n        &trace,\n    );\n\n    //Modular service call\n    let pm_response =\n        pm_client::CreatePaymentMethod::call(state, &client, payment_method_create_req)\n            .await\n            .map_err(|err| {\n                logger::debug!(\"Error in creating payment method: {:?}\", err);\n                errors::ApiErrorResponse::InternalServerError\n            })\n            .attach_printable(\"Failed to create payment method in modular service\")?;\n\n    Ok(pm_response)\n}\n", "function_name": "crates__router__src__core__payment_methods__transformers.rs", "file": "crates__router__src__core__payment_methods__transformers.rs"}, {"query": "hyperswitch card duplication check", "code": "pub use ::payment_methods::controller::{DataDuplicationCheck, DeleteCardResp};\nuse api_models::payment_methods::Card;\n#[cfg(feature = \"v2\")]\nuse api_models::{enums as api_enums, payment_methods::PaymentMethodResponseItem};\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v1\")]\nuse common_utils::{crypto::Encryptable, request::Headers, types::keymanager::KeyManagerState};\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, StringExt},\n    id_type,\n    pii::{Email, SecretSerdeValue},\n    request::RequestContent,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data;\nuse josekit::jwe;\n#[cfg(feature = \"v1\")]\nuse masking::Mask;\nuse masking::{ExposeInterface, PeekInterface};\n#[cfg(feature = \"v1\")]\nuse payment_methods::client::{\n    self as pm_client,\n    create::{CreatePaymentMethodResponse, CreatePaymentMethodV1Request},\n    retrieve::{RetrievePaymentMethodResponse, RetrievePaymentMethodV1Request},\n    UpdatePaymentMethod, UpdatePaymentMethodV1Payload, UpdatePaymentMethodV1Request,\n};\nuse router_env::RequestId;\n#[cfg(feature = \"v1\")]\nuse router_env::{logger, RequestIdentifier};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    configs::settings,\n    core::{\n        errors::{self, CustomResult},\n        payment_methods::cards::{call_vault_service, create_encrypted_data},\n    },\n    headers,\n    pii::Secret,\n    routes,\n    services::{api as services, encryption, EncryptionAlgorithm},\n    types::{api, domain},\n    utils::OptionExt,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    consts,\n    types::{payment_methods as pm_types, transformers},\n};\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum StoreLockerReq {\n    LockerCard(StoreCardReq),\n    LockerGeneric(StoreGenericReq),\n}\n\nimpl StoreLockerReq {\n    pub fn update_requestor_card_reference(&mut self, card_reference: Option<String>) {\n        match self {\n            Self::LockerCard(c) => c.requestor_card_reference = card_reference,\n            Self::LockerGeneric(_) => ()\n\n... [truncated 62635 chars] ...\n\ny.clone().expose().to_string().into_masked(),\n    ));\n    parent_headers.insert((\n        headers::X_MERCHANT_ID.to_string(),\n        merchant_id.get_string_repr().to_string().into_masked(),\n    ));\n\n    let trace = RequestIdentifier::new(&state.conf.trace_header.header_name)\n        .use_incoming_id(state.conf.trace_header.id_reuse_strategy);\n\n    //pm client construction\n    let client = pm_client::PaymentMethodClient::new(\n        &state.conf.micro_services.payment_methods_base_url,\n        &parent_headers,\n        &trace,\n    );\n\n    //Modular service call\n    let pm_response =\n        pm_client::CreatePaymentMethod::call(state, &client, payment_method_create_req)\n            .await\n            .map_err(|err| {\n                logger::debug!(\"Error in creating payment method: {:?}\", err);\n                errors::ApiErrorResponse::InternalServerError\n            })\n            .attach_printable(\"Failed to create payment method in modular service\")?;\n\n    Ok(pm_response)\n}\n", "function_name": "crates__router__src__core__payment_methods__transformers.rs", "file": "crates__router__src__core__payment_methods__transformers.rs"}, {"query": "how does Mpgs connector work", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as mpgs;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Mpgs {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Mpgs {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mpgs {}\nimpl api::PaymentSession for Mpgs {}\nimpl \n\n... [truncated 18412 chars] ...\n\nrors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic MPGS_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic MPGS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Mpgs\",\n    description: \"Mpgs connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic MPGS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Mpgs {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MPGS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MPGS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MPGS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mpgs.rs", "file": "crates__hyperswitch_connectors__src__connectors__mpgs.rs"}, {"query": "Mpgs struct implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as mpgs;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Mpgs {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Mpgs {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mpgs {}\nimpl api::PaymentSession for Mpgs {}\nimpl \n\n... [truncated 18412 chars] ...\n\nrors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic MPGS_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic MPGS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Mpgs\",\n    description: \"Mpgs connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic MPGS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Mpgs {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MPGS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MPGS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MPGS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mpgs.rs", "file": "crates__hyperswitch_connectors__src__connectors__mpgs.rs"}, {"query": "how to implement Mpgs payment gateway", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as mpgs;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Mpgs {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Mpgs {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mpgs {}\nimpl api::PaymentSession for Mpgs {}\nimpl \n\n... [truncated 18412 chars] ...\n\nrors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic MPGS_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic MPGS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Mpgs\",\n    description: \"Mpgs connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic MPGS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Mpgs {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MPGS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MPGS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MPGS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mpgs.rs", "file": "crates__hyperswitch_connectors__src__connectors__mpgs.rs"}, {"query": "Hyperswitch Mpgs authorization flow", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as mpgs;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Mpgs {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Mpgs {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mpgs {}\nimpl api::PaymentSession for Mpgs {}\nimpl \n\n... [truncated 18412 chars] ...\n\nrors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic MPGS_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic MPGS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Mpgs\",\n    description: \"Mpgs connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic MPGS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Mpgs {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MPGS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MPGS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MPGS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mpgs.rs", "file": "crates__hyperswitch_connectors__src__connectors__mpgs.rs"}, {"query": "how to integrate Fiuu payment gateway", "code": "use std::collections::HashMap;\n\nuse api_models::payments;\nuse cards::CardNumber;\nuse common_enums::{enums, BankNames, CaptureMethod, Currency};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::Encode,\n    pii::Email,\n    request::Method,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, CardDetailsForNetworkTransactionId, GooglePayWalletData,\n        PaymentMethodData, RealTimePaymentData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse url::Url;\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{self, PaymentsAuthorizeRequestData, QrImage, RefundsRequestData, RouterData as _},\n};\n\npub struct FiuuRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for FiuuRouterData<T> {\n    fn fr\n\n... [truncated 77666 chars] ...\n\nss => Self::PaymentIntentSuccess,\n            FiuuPaymentWebhookStatus::Failure => Self::PaymentIntentFailure,\n            FiuuPaymentWebhookStatus::Pending => Self::PaymentIntentProcessing,\n        }\n    }\n}\n\nimpl From<FiuuRefundsWebhookStatus> for api_models::webhooks::IncomingWebhookEvent {\n    fn from(value: FiuuRefundsWebhookStatus) -> Self {\n        match value {\n            FiuuRefundsWebhookStatus::RefundSuccess => Self::RefundSuccess,\n            FiuuRefundsWebhookStatus::RefundFailure => Self::RefundFailure,\n            FiuuRefundsWebhookStatus::RefundPending => Self::EventNotSupported,\n        }\n    }\n}\n\nimpl From<FiuuRefundsWebhookStatus> for enums::RefundStatus {\n    fn from(value: FiuuRefundsWebhookStatus) -> Self {\n        match value {\n            FiuuRefundsWebhookStatus::RefundFailure => Self::Failure,\n            FiuuRefundsWebhookStatus::RefundSuccess => Self::Success,\n            FiuuRefundsWebhookStatus::RefundPending => Self::Pending,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs"}, {"query": "FiuuAuthType struct definition", "code": "use std::collections::HashMap;\n\nuse api_models::payments;\nuse cards::CardNumber;\nuse common_enums::{enums, BankNames, CaptureMethod, Currency};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::Encode,\n    pii::Email,\n    request::Method,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, CardDetailsForNetworkTransactionId, GooglePayWalletData,\n        PaymentMethodData, RealTimePaymentData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse url::Url;\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{self, PaymentsAuthorizeRequestData, QrImage, RefundsRequestData, RouterData as _},\n};\n\npub struct FiuuRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for FiuuRouterData<T> {\n    fn fr\n\n... [truncated 77666 chars] ...\n\nss => Self::PaymentIntentSuccess,\n            FiuuPaymentWebhookStatus::Failure => Self::PaymentIntentFailure,\n            FiuuPaymentWebhookStatus::Pending => Self::PaymentIntentProcessing,\n        }\n    }\n}\n\nimpl From<FiuuRefundsWebhookStatus> for api_models::webhooks::IncomingWebhookEvent {\n    fn from(value: FiuuRefundsWebhookStatus) -> Self {\n        match value {\n            FiuuRefundsWebhookStatus::RefundSuccess => Self::RefundSuccess,\n            FiuuRefundsWebhookStatus::RefundFailure => Self::RefundFailure,\n            FiuuRefundsWebhookStatus::RefundPending => Self::EventNotSupported,\n        }\n    }\n}\n\nimpl From<FiuuRefundsWebhookStatus> for enums::RefundStatus {\n    fn from(value: FiuuRefundsWebhookStatus) -> Self {\n        match value {\n            FiuuRefundsWebhookStatus::RefundFailure => Self::Failure,\n            FiuuRefundsWebhookStatus::RefundSuccess => Self::Success,\n            FiuuRefundsWebhookStatus::RefundPending => Self::Pending,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs"}, {"query": "implement payment capture with Fiuu", "code": "use std::collections::HashMap;\n\nuse api_models::payments;\nuse cards::CardNumber;\nuse common_enums::{enums, BankNames, CaptureMethod, Currency};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::Encode,\n    pii::Email,\n    request::Method,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, CardDetailsForNetworkTransactionId, GooglePayWalletData,\n        PaymentMethodData, RealTimePaymentData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse url::Url;\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{self, PaymentsAuthorizeRequestData, QrImage, RefundsRequestData, RouterData as _},\n};\n\npub struct FiuuRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for FiuuRouterData<T> {\n    fn fr\n\n... [truncated 77666 chars] ...\n\nss => Self::PaymentIntentSuccess,\n            FiuuPaymentWebhookStatus::Failure => Self::PaymentIntentFailure,\n            FiuuPaymentWebhookStatus::Pending => Self::PaymentIntentProcessing,\n        }\n    }\n}\n\nimpl From<FiuuRefundsWebhookStatus> for api_models::webhooks::IncomingWebhookEvent {\n    fn from(value: FiuuRefundsWebhookStatus) -> Self {\n        match value {\n            FiuuRefundsWebhookStatus::RefundSuccess => Self::RefundSuccess,\n            FiuuRefundsWebhookStatus::RefundFailure => Self::RefundFailure,\n            FiuuRefundsWebhookStatus::RefundPending => Self::EventNotSupported,\n        }\n    }\n}\n\nimpl From<FiuuRefundsWebhookStatus> for enums::RefundStatus {\n    fn from(value: FiuuRefundsWebhookStatus) -> Self {\n        match value {\n            FiuuRefundsWebhookStatus::RefundFailure => Self::Failure,\n            FiuuRefundsWebhookStatus::RefundSuccess => Self::Success,\n            FiuuRefundsWebhookStatus::RefundPending => Self::Pending,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs"}, {"query": "Fiuu webhook status mapping", "code": "use std::collections::HashMap;\n\nuse api_models::payments;\nuse cards::CardNumber;\nuse common_enums::{enums, BankNames, CaptureMethod, Currency};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::Encode,\n    pii::Email,\n    request::Method,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, CardDetailsForNetworkTransactionId, GooglePayWalletData,\n        PaymentMethodData, RealTimePaymentData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse url::Url;\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{self, PaymentsAuthorizeRequestData, QrImage, RefundsRequestData, RouterData as _},\n};\n\npub struct FiuuRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for FiuuRouterData<T> {\n    fn fr\n\n... [truncated 77666 chars] ...\n\nss => Self::PaymentIntentSuccess,\n            FiuuPaymentWebhookStatus::Failure => Self::PaymentIntentFailure,\n            FiuuPaymentWebhookStatus::Pending => Self::PaymentIntentProcessing,\n        }\n    }\n}\n\nimpl From<FiuuRefundsWebhookStatus> for api_models::webhooks::IncomingWebhookEvent {\n    fn from(value: FiuuRefundsWebhookStatus) -> Self {\n        match value {\n            FiuuRefundsWebhookStatus::RefundSuccess => Self::RefundSuccess,\n            FiuuRefundsWebhookStatus::RefundFailure => Self::RefundFailure,\n            FiuuRefundsWebhookStatus::RefundPending => Self::EventNotSupported,\n        }\n    }\n}\n\nimpl From<FiuuRefundsWebhookStatus> for enums::RefundStatus {\n    fn from(value: FiuuRefundsWebhookStatus) -> Self {\n        match value {\n            FiuuRefundsWebhookStatus::RefundFailure => Self::Failure,\n            FiuuRefundsWebhookStatus::RefundSuccess => Self::Success,\n            FiuuRefundsWebhookStatus::RefundPending => Self::Pending,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs"}, {"query": "how to create a payout in hyperswitch", "code": "#[cfg(feature = \"olap\")]\nuse strum::IntoEnumIterator;\npub mod access_token;\npub mod helpers;\n#[cfg(feature = \"payout_retry\")]\npub mod retry;\npub mod transformers;\npub mod validator;\nuse std::{\n    collections::{HashMap, HashSet},\n    vec::IntoIter,\n};\n\nuse api_models::{self, enums as api_enums, payouts::PayoutLinkResponse};\n#[cfg(feature = \"olap\")]\nuse api_models::{admin::MerchantConnectorInfo, payments as payment_enums};\n#[cfg(feature = \"payout_retry\")]\nuse common_enums::PayoutRetryType;\nuse common_utils::{\n    consts,\n    ext_traits::{AsyncExt, ValueExt},\n    id_type::{self, GenerateId},\n    link_utils::{GenericLinkStatus, GenericLinkUiConfig, PayoutLinkData, PayoutLinkStatus},\n    types::{MinorUnit, UnifiedCode, UnifiedMessage},\n};\nuse diesel_models::{\n    enums as storage_enums,\n    generic_link::{GenericLinkNew, PayoutLink},\n    CommonMandateReference, PayoutsMandateReference, PayoutsMandateReferenceRecord,\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"olap\")]\nuse futures::future::join_all;\nuse hyperswitch_domain_models::{self as domain_models, payment_methods::PaymentMethod};\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"payout_retry\")]\nuse retry::GsmValidation;\nuse router_env::{instrument, logger, tracing, Env};\nuse scheduler::utils as pt_utils;\nuse time::Duration;\n\n#[cfg(all(feature = \"olap\", feature = \"payouts\"))]\nuse crate::consts as payout_consts;\n#[cfg(feature = \"olap\")]\nuse crate::types::domain::behaviour::Conversion;\n#[cfg(feature = \"olap\")]\nuse crate::types::PayoutActionData;\nuse crate::{\n    core::{\n        errors::{\n            self, ConnectorErrorExt, CustomResult, RouterResponse, RouterResult, StorageErrorExt,\n        },\n        payments::{self, customers, helpers as payment_helpers},\n        utils as core_utils,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    services,\n    types::{\n        self,\n        api::{self, payments as payment_api_types, payouts},\n        domain,\n        storage::{self, PaymentRoutingInfo},\n     \n\n... [truncated 134579 chars] ...\n\n                &updated_payout_attempt,\n                    merchant_account.storage_scheme,\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)\n                .attach_printable(\"Error while updating payout\")?;\n        }\n\n        Ok(services::ApplicationResponse::Json(\n            api_models::payouts::PayoutsManualUpdateResponse {\n                payout_id: updated_payout_attempt.payout_id,\n                payout_attempt_id: updated_payout_attempt.payout_attempt_id,\n                merchant_id: updated_payout_attempt.merchant_id,\n                attempt_status: updated_payout_attempt.status,\n                error_code,\n                error_message,\n                connector_payout_id,\n            },\n        ))\n    } else {\n        Err(errors::ApiErrorResponse::UnprocessableEntity {\n            message: \"Request must contain atleast one parameter to update\".to_string(),\n        }\n        .into())\n    }\n}\n", "function_name": "crates__router__src__core__payouts.rs", "file": "crates__router__src__core__payouts.rs"}, {"query": "payout retry logic implementation", "code": "#[cfg(feature = \"olap\")]\nuse strum::IntoEnumIterator;\npub mod access_token;\npub mod helpers;\n#[cfg(feature = \"payout_retry\")]\npub mod retry;\npub mod transformers;\npub mod validator;\nuse std::{\n    collections::{HashMap, HashSet},\n    vec::IntoIter,\n};\n\nuse api_models::{self, enums as api_enums, payouts::PayoutLinkResponse};\n#[cfg(feature = \"olap\")]\nuse api_models::{admin::MerchantConnectorInfo, payments as payment_enums};\n#[cfg(feature = \"payout_retry\")]\nuse common_enums::PayoutRetryType;\nuse common_utils::{\n    consts,\n    ext_traits::{AsyncExt, ValueExt},\n    id_type::{self, GenerateId},\n    link_utils::{GenericLinkStatus, GenericLinkUiConfig, PayoutLinkData, PayoutLinkStatus},\n    types::{MinorUnit, UnifiedCode, UnifiedMessage},\n};\nuse diesel_models::{\n    enums as storage_enums,\n    generic_link::{GenericLinkNew, PayoutLink},\n    CommonMandateReference, PayoutsMandateReference, PayoutsMandateReferenceRecord,\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"olap\")]\nuse futures::future::join_all;\nuse hyperswitch_domain_models::{self as domain_models, payment_methods::PaymentMethod};\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"payout_retry\")]\nuse retry::GsmValidation;\nuse router_env::{instrument, logger, tracing, Env};\nuse scheduler::utils as pt_utils;\nuse time::Duration;\n\n#[cfg(all(feature = \"olap\", feature = \"payouts\"))]\nuse crate::consts as payout_consts;\n#[cfg(feature = \"olap\")]\nuse crate::types::domain::behaviour::Conversion;\n#[cfg(feature = \"olap\")]\nuse crate::types::PayoutActionData;\nuse crate::{\n    core::{\n        errors::{\n            self, ConnectorErrorExt, CustomResult, RouterResponse, RouterResult, StorageErrorExt,\n        },\n        payments::{self, customers, helpers as payment_helpers},\n        utils as core_utils,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    services,\n    types::{\n        self,\n        api::{self, payments as payment_api_types, payouts},\n        domain,\n        storage::{self, PaymentRoutingInfo},\n     \n\n... [truncated 134579 chars] ...\n\n                &updated_payout_attempt,\n                    merchant_account.storage_scheme,\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)\n                .attach_printable(\"Error while updating payout\")?;\n        }\n\n        Ok(services::ApplicationResponse::Json(\n            api_models::payouts::PayoutsManualUpdateResponse {\n                payout_id: updated_payout_attempt.payout_id,\n                payout_attempt_id: updated_payout_attempt.payout_attempt_id,\n                merchant_id: updated_payout_attempt.merchant_id,\n                attempt_status: updated_payout_attempt.status,\n                error_code,\n                error_message,\n                connector_payout_id,\n            },\n        ))\n    } else {\n        Err(errors::ApiErrorResponse::UnprocessableEntity {\n            message: \"Request must contain atleast one parameter to update\".to_string(),\n        }\n        .into())\n    }\n}\n", "function_name": "crates__router__src__core__payouts.rs", "file": "crates__router__src__core__payouts.rs"}, {"query": "manual payout status update", "code": "#[cfg(feature = \"olap\")]\nuse strum::IntoEnumIterator;\npub mod access_token;\npub mod helpers;\n#[cfg(feature = \"payout_retry\")]\npub mod retry;\npub mod transformers;\npub mod validator;\nuse std::{\n    collections::{HashMap, HashSet},\n    vec::IntoIter,\n};\n\nuse api_models::{self, enums as api_enums, payouts::PayoutLinkResponse};\n#[cfg(feature = \"olap\")]\nuse api_models::{admin::MerchantConnectorInfo, payments as payment_enums};\n#[cfg(feature = \"payout_retry\")]\nuse common_enums::PayoutRetryType;\nuse common_utils::{\n    consts,\n    ext_traits::{AsyncExt, ValueExt},\n    id_type::{self, GenerateId},\n    link_utils::{GenericLinkStatus, GenericLinkUiConfig, PayoutLinkData, PayoutLinkStatus},\n    types::{MinorUnit, UnifiedCode, UnifiedMessage},\n};\nuse diesel_models::{\n    enums as storage_enums,\n    generic_link::{GenericLinkNew, PayoutLink},\n    CommonMandateReference, PayoutsMandateReference, PayoutsMandateReferenceRecord,\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"olap\")]\nuse futures::future::join_all;\nuse hyperswitch_domain_models::{self as domain_models, payment_methods::PaymentMethod};\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"payout_retry\")]\nuse retry::GsmValidation;\nuse router_env::{instrument, logger, tracing, Env};\nuse scheduler::utils as pt_utils;\nuse time::Duration;\n\n#[cfg(all(feature = \"olap\", feature = \"payouts\"))]\nuse crate::consts as payout_consts;\n#[cfg(feature = \"olap\")]\nuse crate::types::domain::behaviour::Conversion;\n#[cfg(feature = \"olap\")]\nuse crate::types::PayoutActionData;\nuse crate::{\n    core::{\n        errors::{\n            self, ConnectorErrorExt, CustomResult, RouterResponse, RouterResult, StorageErrorExt,\n        },\n        payments::{self, customers, helpers as payment_helpers},\n        utils as core_utils,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    services,\n    types::{\n        self,\n        api::{self, payments as payment_api_types, payouts},\n        domain,\n        storage::{self, PaymentRoutingInfo},\n     \n\n... [truncated 134579 chars] ...\n\n                &updated_payout_attempt,\n                    merchant_account.storage_scheme,\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)\n                .attach_printable(\"Error while updating payout\")?;\n        }\n\n        Ok(services::ApplicationResponse::Json(\n            api_models::payouts::PayoutsManualUpdateResponse {\n                payout_id: updated_payout_attempt.payout_id,\n                payout_attempt_id: updated_payout_attempt.payout_attempt_id,\n                merchant_id: updated_payout_attempt.merchant_id,\n                attempt_status: updated_payout_attempt.status,\n                error_code,\n                error_message,\n                connector_payout_id,\n            },\n        ))\n    } else {\n        Err(errors::ApiErrorResponse::UnprocessableEntity {\n            message: \"Request must contain atleast one parameter to update\".to_string(),\n        }\n        .into())\n    }\n}\n", "function_name": "crates__router__src__core__payouts.rs", "file": "crates__router__src__core__payouts.rs"}, {"query": "PayoutData struct definition", "code": "#[cfg(feature = \"olap\")]\nuse strum::IntoEnumIterator;\npub mod access_token;\npub mod helpers;\n#[cfg(feature = \"payout_retry\")]\npub mod retry;\npub mod transformers;\npub mod validator;\nuse std::{\n    collections::{HashMap, HashSet},\n    vec::IntoIter,\n};\n\nuse api_models::{self, enums as api_enums, payouts::PayoutLinkResponse};\n#[cfg(feature = \"olap\")]\nuse api_models::{admin::MerchantConnectorInfo, payments as payment_enums};\n#[cfg(feature = \"payout_retry\")]\nuse common_enums::PayoutRetryType;\nuse common_utils::{\n    consts,\n    ext_traits::{AsyncExt, ValueExt},\n    id_type::{self, GenerateId},\n    link_utils::{GenericLinkStatus, GenericLinkUiConfig, PayoutLinkData, PayoutLinkStatus},\n    types::{MinorUnit, UnifiedCode, UnifiedMessage},\n};\nuse diesel_models::{\n    enums as storage_enums,\n    generic_link::{GenericLinkNew, PayoutLink},\n    CommonMandateReference, PayoutsMandateReference, PayoutsMandateReferenceRecord,\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"olap\")]\nuse futures::future::join_all;\nuse hyperswitch_domain_models::{self as domain_models, payment_methods::PaymentMethod};\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"payout_retry\")]\nuse retry::GsmValidation;\nuse router_env::{instrument, logger, tracing, Env};\nuse scheduler::utils as pt_utils;\nuse time::Duration;\n\n#[cfg(all(feature = \"olap\", feature = \"payouts\"))]\nuse crate::consts as payout_consts;\n#[cfg(feature = \"olap\")]\nuse crate::types::domain::behaviour::Conversion;\n#[cfg(feature = \"olap\")]\nuse crate::types::PayoutActionData;\nuse crate::{\n    core::{\n        errors::{\n            self, ConnectorErrorExt, CustomResult, RouterResponse, RouterResult, StorageErrorExt,\n        },\n        payments::{self, customers, helpers as payment_helpers},\n        utils as core_utils,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    services,\n    types::{\n        self,\n        api::{self, payments as payment_api_types, payouts},\n        domain,\n        storage::{self, PaymentRoutingInfo},\n     \n\n... [truncated 134579 chars] ...\n\n                &updated_payout_attempt,\n                    merchant_account.storage_scheme,\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)\n                .attach_printable(\"Error while updating payout\")?;\n        }\n\n        Ok(services::ApplicationResponse::Json(\n            api_models::payouts::PayoutsManualUpdateResponse {\n                payout_id: updated_payout_attempt.payout_id,\n                payout_attempt_id: updated_payout_attempt.payout_attempt_id,\n                merchant_id: updated_payout_attempt.merchant_id,\n                attempt_status: updated_payout_attempt.status,\n                error_code,\n                error_message,\n                connector_payout_id,\n            },\n        ))\n    } else {\n        Err(errors::ApiErrorResponse::UnprocessableEntity {\n            message: \"Request must contain atleast one parameter to update\".to_string(),\n        }\n        .into())\n    }\n}\n", "function_name": "crates__router__src__core__payouts.rs", "file": "crates__router__src__core__payouts.rs"}, {"query": "Authipay payment connector integration", "code": "use common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData},\n};\n\n// Type definition for router data with amount\npub struct AuthipayRouterData<T> {\n    pub amount: FloatMajorUnit, // Amount in major units (e.g., dollars instead of cents)\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for AuthipayRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n// Basic request/response structs used across multiple operations\n\n#[derive(Default, Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Amount {\n    total: FloatMajorUnit,\n    currency: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    components: Option<AmountComponents>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmountComponents {\n    subtotal: FloatMajorUnit,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ExpiryDate {\n    month: Secret<String>,\n    year: Secret<String>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Card {\n    number: cards::CardNumber,\n    security_code: Secret<String>,\n    expiry_date: ExpiryDate,\n}\n\n#[derive(De\n\n... [truncated 19819 chars] ...\n\nelCase\")]\npub struct AuthipayErrorResponse {\n    pub client_request_id: Option<String>,\n    pub api_trace_id: Option<String>,\n    pub response_type: Option<String>,\n    #[serde(rename = \"type\")]\n    pub response_object_type: Option<String>,\n    pub error: ErrorDetails,\n    pub decline_reason_code: Option<String>,\n}\n\nimpl From<&AuthipayErrorResponse> for ErrorResponse {\n    fn from(item: &AuthipayErrorResponse) -> Self {\n        Self {\n            status_code: 500, // Default to Internal Server Error, will be overridden by actual HTTP status\n            code: item.error.code.clone().unwrap_or_default(),\n            message: item.error.message.clone(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authipay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__authipay__transformers.rs"}, {"query": "AuthipayPaymentsRequest struct", "code": "use common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData},\n};\n\n// Type definition for router data with amount\npub struct AuthipayRouterData<T> {\n    pub amount: FloatMajorUnit, // Amount in major units (e.g., dollars instead of cents)\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for AuthipayRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n// Basic request/response structs used across multiple operations\n\n#[derive(Default, Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Amount {\n    total: FloatMajorUnit,\n    currency: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    components: Option<AmountComponents>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmountComponents {\n    subtotal: FloatMajorUnit,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ExpiryDate {\n    month: Secret<String>,\n    year: Secret<String>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Card {\n    number: cards::CardNumber,\n    security_code: Secret<String>,\n    expiry_date: ExpiryDate,\n}\n\n#[derive(De\n\n... [truncated 19819 chars] ...\n\nelCase\")]\npub struct AuthipayErrorResponse {\n    pub client_request_id: Option<String>,\n    pub api_trace_id: Option<String>,\n    pub response_type: Option<String>,\n    #[serde(rename = \"type\")]\n    pub response_object_type: Option<String>,\n    pub error: ErrorDetails,\n    pub decline_reason_code: Option<String>,\n}\n\nimpl From<&AuthipayErrorResponse> for ErrorResponse {\n    fn from(item: &AuthipayErrorResponse) -> Self {\n        Self {\n            status_code: 500, // Default to Internal Server Error, will be overridden by actual HTTP status\n            code: item.error.code.clone().unwrap_or_default(),\n            message: item.error.message.clone(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authipay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__authipay__transformers.rs"}, {"query": "how to implement Authipay refunds", "code": "use common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData},\n};\n\n// Type definition for router data with amount\npub struct AuthipayRouterData<T> {\n    pub amount: FloatMajorUnit, // Amount in major units (e.g., dollars instead of cents)\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for AuthipayRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n// Basic request/response structs used across multiple operations\n\n#[derive(Default, Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Amount {\n    total: FloatMajorUnit,\n    currency: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    components: Option<AmountComponents>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmountComponents {\n    subtotal: FloatMajorUnit,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ExpiryDate {\n    month: Secret<String>,\n    year: Secret<String>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Card {\n    number: cards::CardNumber,\n    security_code: Secret<String>,\n    expiry_date: ExpiryDate,\n}\n\n#[derive(De\n\n... [truncated 19819 chars] ...\n\nelCase\")]\npub struct AuthipayErrorResponse {\n    pub client_request_id: Option<String>,\n    pub api_trace_id: Option<String>,\n    pub response_type: Option<String>,\n    #[serde(rename = \"type\")]\n    pub response_object_type: Option<String>,\n    pub error: ErrorDetails,\n    pub decline_reason_code: Option<String>,\n}\n\nimpl From<&AuthipayErrorResponse> for ErrorResponse {\n    fn from(item: &AuthipayErrorResponse) -> Self {\n        Self {\n            status_code: 500, // Default to Internal Server Error, will be overridden by actual HTTP status\n            code: item.error.code.clone().unwrap_or_default(),\n            message: item.error.message.clone(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authipay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__authipay__transformers.rs"}, {"query": "Authipay error response mapping", "code": "use common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData},\n};\n\n// Type definition for router data with amount\npub struct AuthipayRouterData<T> {\n    pub amount: FloatMajorUnit, // Amount in major units (e.g., dollars instead of cents)\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for AuthipayRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n// Basic request/response structs used across multiple operations\n\n#[derive(Default, Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Amount {\n    total: FloatMajorUnit,\n    currency: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    components: Option<AmountComponents>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmountComponents {\n    subtotal: FloatMajorUnit,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ExpiryDate {\n    month: Secret<String>,\n    year: Secret<String>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Card {\n    number: cards::CardNumber,\n    security_code: Secret<String>,\n    expiry_date: ExpiryDate,\n}\n\n#[derive(De\n\n... [truncated 19819 chars] ...\n\nelCase\")]\npub struct AuthipayErrorResponse {\n    pub client_request_id: Option<String>,\n    pub api_trace_id: Option<String>,\n    pub response_type: Option<String>,\n    #[serde(rename = \"type\")]\n    pub response_object_type: Option<String>,\n    pub error: ErrorDetails,\n    pub decline_reason_code: Option<String>,\n}\n\nimpl From<&AuthipayErrorResponse> for ErrorResponse {\n    fn from(item: &AuthipayErrorResponse) -> Self {\n        Self {\n            status_code: 500, // Default to Internal Server Error, will be overridden by actual HTTP status\n            code: item.error.code.clone().unwrap_or_default(),\n            message: item.error.message.clone(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authipay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__authipay__transformers.rs"}, {"query": "stripe payment intent types", "code": "use std::str::FromStr;\n\nuse api_models::payments;\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    date_time,\n    ext_traits::StringExt,\n    id_type,\n    pii::{IpAddress, SecretSerdeValue, UpiVpaMaskingStrategy},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    compatibility::stripe::refunds::types as stripe_refunds,\n    connector::utils::AddressData,\n    consts,\n    core::errors,\n    pii::{Email, PeekInterface},\n    types::{\n        api::{admin, enums as api_enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n    },\n};\n\n#[derive(Default, Serialize, PartialEq, Eq, Deserialize, Clone, Debug)]\npub struct StripeBillingDetails {\n    pub address: Option<AddressDetails>,\n    pub email: Option<Email>,\n    pub name: Option<String>,\n    pub phone: Option<masking::Secret<String>>,\n}\n\nimpl From<StripeBillingDetails> for payments::Address {\n    fn from(details: StripeBillingDetails) -> Self {\n        Self {\n            phone: Some(payments::PhoneDetails {\n                number: details.phone,\n                country_code: details.address.as_ref().and_then(|address| {\n                    address.country.as_ref().map(|country| country.to_string())\n                }),\n            }),\n            email: details.email,\n            address: details.address.map(|address| payments::AddressDetails {\n                city: address.city,\n                country: address.country,\n                line1: address.line1,\n                line2: address.line2,\n                zip: address.postal_code,\n                state: address.state,\n                first_name: None,\n                line3: None,\n                last_name: None,\n                origin_zip: None,\n            }),\n        }\n    }\n}\n\n#[derive(Default, Serialize, PartialEq, Eq, Deserialize, Clone, Debug)]\npub struct StripeCard {\n    pub number: cards::CardNumber,\n    pub exp_month: masking::Secret<String>,\n    pub ex\n\n... [truncated 34362 chars] ...\n\n     payments::RealTimePaymentData::VietQr {},\n            )))\n        }\n        Some(api_enums::PaymentMethodType::Ideal) => Some(\n            payments::PaymentMethodData::BankRedirect(payments::BankRedirectData::Ideal {\n                billing_details: billing_details.as_ref().map(|billing_data| {\n                    payments::BankRedirectBilling {\n                        billing_name: billing_data.get_optional_full_name(),\n                        email: billing_data.email.clone(),\n                    }\n                }),\n                bank_name: None,\n                country: billing_details\n                    .as_ref()\n                    .and_then(|billing_data| billing_data.get_optional_country()),\n            }),\n        ),\n        Some(api_enums::PaymentMethodType::LocalBankRedirect) => {\n            Some(payments::PaymentMethodData::BankRedirect(\n                payments::BankRedirectData::LocalBankRedirect {},\n            ))\n        }\n        _ => None,\n    }\n}\n", "function_name": "crates__router__src__compatibility__stripe__payment_intents__types.rs", "file": "crates__router__src__compatibility__stripe__payment_intents__types.rs"}, {"query": "StripePaymentMethodData struct", "code": "use std::str::FromStr;\n\nuse api_models::payments;\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    date_time,\n    ext_traits::StringExt,\n    id_type,\n    pii::{IpAddress, SecretSerdeValue, UpiVpaMaskingStrategy},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    compatibility::stripe::refunds::types as stripe_refunds,\n    connector::utils::AddressData,\n    consts,\n    core::errors,\n    pii::{Email, PeekInterface},\n    types::{\n        api::{admin, enums as api_enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n    },\n};\n\n#[derive(Default, Serialize, PartialEq, Eq, Deserialize, Clone, Debug)]\npub struct StripeBillingDetails {\n    pub address: Option<AddressDetails>,\n    pub email: Option<Email>,\n    pub name: Option<String>,\n    pub phone: Option<masking::Secret<String>>,\n}\n\nimpl From<StripeBillingDetails> for payments::Address {\n    fn from(details: StripeBillingDetails) -> Self {\n        Self {\n            phone: Some(payments::PhoneDetails {\n                number: details.phone,\n                country_code: details.address.as_ref().and_then(|address| {\n                    address.country.as_ref().map(|country| country.to_string())\n                }),\n            }),\n            email: details.email,\n            address: details.address.map(|address| payments::AddressDetails {\n                city: address.city,\n                country: address.country,\n                line1: address.line1,\n                line2: address.line2,\n                zip: address.postal_code,\n                state: address.state,\n                first_name: None,\n                line3: None,\n                last_name: None,\n                origin_zip: None,\n            }),\n        }\n    }\n}\n\n#[derive(Default, Serialize, PartialEq, Eq, Deserialize, Clone, Debug)]\npub struct StripeCard {\n    pub number: cards::CardNumber,\n    pub exp_month: masking::Secret<String>,\n    pub ex\n\n... [truncated 34362 chars] ...\n\n     payments::RealTimePaymentData::VietQr {},\n            )))\n        }\n        Some(api_enums::PaymentMethodType::Ideal) => Some(\n            payments::PaymentMethodData::BankRedirect(payments::BankRedirectData::Ideal {\n                billing_details: billing_details.as_ref().map(|billing_data| {\n                    payments::BankRedirectBilling {\n                        billing_name: billing_data.get_optional_full_name(),\n                        email: billing_data.email.clone(),\n                    }\n                }),\n                bank_name: None,\n                country: billing_details\n                    .as_ref()\n                    .and_then(|billing_data| billing_data.get_optional_country()),\n            }),\n        ),\n        Some(api_enums::PaymentMethodType::LocalBankRedirect) => {\n            Some(payments::PaymentMethodData::BankRedirect(\n                payments::BankRedirectData::LocalBankRedirect {},\n            ))\n        }\n        _ => None,\n    }\n}\n", "function_name": "crates__router__src__compatibility__stripe__payment_intents__types.rs", "file": "crates__router__src__compatibility__stripe__payment_intents__types.rs"}, {"query": "how to handle stripe payment methods", "code": "use std::str::FromStr;\n\nuse api_models::payments;\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    date_time,\n    ext_traits::StringExt,\n    id_type,\n    pii::{IpAddress, SecretSerdeValue, UpiVpaMaskingStrategy},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    compatibility::stripe::refunds::types as stripe_refunds,\n    connector::utils::AddressData,\n    consts,\n    core::errors,\n    pii::{Email, PeekInterface},\n    types::{\n        api::{admin, enums as api_enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n    },\n};\n\n#[derive(Default, Serialize, PartialEq, Eq, Deserialize, Clone, Debug)]\npub struct StripeBillingDetails {\n    pub address: Option<AddressDetails>,\n    pub email: Option<Email>,\n    pub name: Option<String>,\n    pub phone: Option<masking::Secret<String>>,\n}\n\nimpl From<StripeBillingDetails> for payments::Address {\n    fn from(details: StripeBillingDetails) -> Self {\n        Self {\n            phone: Some(payments::PhoneDetails {\n                number: details.phone,\n                country_code: details.address.as_ref().and_then(|address| {\n                    address.country.as_ref().map(|country| country.to_string())\n                }),\n            }),\n            email: details.email,\n            address: details.address.map(|address| payments::AddressDetails {\n                city: address.city,\n                country: address.country,\n                line1: address.line1,\n                line2: address.line2,\n                zip: address.postal_code,\n                state: address.state,\n                first_name: None,\n                line3: None,\n                last_name: None,\n                origin_zip: None,\n            }),\n        }\n    }\n}\n\n#[derive(Default, Serialize, PartialEq, Eq, Deserialize, Clone, Debug)]\npub struct StripeCard {\n    pub number: cards::CardNumber,\n    pub exp_month: masking::Secret<String>,\n    pub ex\n\n... [truncated 34362 chars] ...\n\n     payments::RealTimePaymentData::VietQr {},\n            )))\n        }\n        Some(api_enums::PaymentMethodType::Ideal) => Some(\n            payments::PaymentMethodData::BankRedirect(payments::BankRedirectData::Ideal {\n                billing_details: billing_details.as_ref().map(|billing_data| {\n                    payments::BankRedirectBilling {\n                        billing_name: billing_data.get_optional_full_name(),\n                        email: billing_data.email.clone(),\n                    }\n                }),\n                bank_name: None,\n                country: billing_details\n                    .as_ref()\n                    .and_then(|billing_data| billing_data.get_optional_country()),\n            }),\n        ),\n        Some(api_enums::PaymentMethodType::LocalBankRedirect) => {\n            Some(payments::PaymentMethodData::BankRedirect(\n                payments::BankRedirectData::LocalBankRedirect {},\n            ))\n        }\n        _ => None,\n    }\n}\n", "function_name": "crates__router__src__compatibility__stripe__payment_intents__types.rs", "file": "crates__router__src__compatibility__stripe__payment_intents__types.rs"}, {"query": "convert stripe payment intent to api model", "code": "use std::str::FromStr;\n\nuse api_models::payments;\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    date_time,\n    ext_traits::StringExt,\n    id_type,\n    pii::{IpAddress, SecretSerdeValue, UpiVpaMaskingStrategy},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    compatibility::stripe::refunds::types as stripe_refunds,\n    connector::utils::AddressData,\n    consts,\n    core::errors,\n    pii::{Email, PeekInterface},\n    types::{\n        api::{admin, enums as api_enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n    },\n};\n\n#[derive(Default, Serialize, PartialEq, Eq, Deserialize, Clone, Debug)]\npub struct StripeBillingDetails {\n    pub address: Option<AddressDetails>,\n    pub email: Option<Email>,\n    pub name: Option<String>,\n    pub phone: Option<masking::Secret<String>>,\n}\n\nimpl From<StripeBillingDetails> for payments::Address {\n    fn from(details: StripeBillingDetails) -> Self {\n        Self {\n            phone: Some(payments::PhoneDetails {\n                number: details.phone,\n                country_code: details.address.as_ref().and_then(|address| {\n                    address.country.as_ref().map(|country| country.to_string())\n                }),\n            }),\n            email: details.email,\n            address: details.address.map(|address| payments::AddressDetails {\n                city: address.city,\n                country: address.country,\n                line1: address.line1,\n                line2: address.line2,\n                zip: address.postal_code,\n                state: address.state,\n                first_name: None,\n                line3: None,\n                last_name: None,\n                origin_zip: None,\n            }),\n        }\n    }\n}\n\n#[derive(Default, Serialize, PartialEq, Eq, Deserialize, Clone, Debug)]\npub struct StripeCard {\n    pub number: cards::CardNumber,\n    pub exp_month: masking::Secret<String>,\n    pub ex\n\n... [truncated 34362 chars] ...\n\n     payments::RealTimePaymentData::VietQr {},\n            )))\n        }\n        Some(api_enums::PaymentMethodType::Ideal) => Some(\n            payments::PaymentMethodData::BankRedirect(payments::BankRedirectData::Ideal {\n                billing_details: billing_details.as_ref().map(|billing_data| {\n                    payments::BankRedirectBilling {\n                        billing_name: billing_data.get_optional_full_name(),\n                        email: billing_data.email.clone(),\n                    }\n                }),\n                bank_name: None,\n                country: billing_details\n                    .as_ref()\n                    .and_then(|billing_data| billing_data.get_optional_country()),\n            }),\n        ),\n        Some(api_enums::PaymentMethodType::LocalBankRedirect) => {\n            Some(payments::PaymentMethodData::BankRedirect(\n                payments::BankRedirectData::LocalBankRedirect {},\n            ))\n        }\n        _ => None,\n    }\n}\n", "function_name": "crates__router__src__compatibility__stripe__payment_intents__types.rs", "file": "crates__router__src__compatibility__stripe__payment_intents__types.rs"}, {"query": "custombilling connector implementation hyperswitch", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as custombilling;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Custombilling {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Custombilling {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Custombilling {}\nimpl api::PaymentSession for Custombilling {}\nimpl api::ConnectorAccessToken for Custombilling {}\nimpl api::MandateSetup for Custombilling {}\nimpl api::PaymentAuthorize for Custombilling {}\nimpl\n\n... [truncated 16934 chars] ...\n\nebhooks::IncomingWebhook for Custombilling {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Custombilling {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__custombilling.rs", "file": "crates__hyperswitch_connectors__src__connectors__custombilling.rs"}, {"query": "how to implement custom payment connector", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as custombilling;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Custombilling {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Custombilling {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Custombilling {}\nimpl api::PaymentSession for Custombilling {}\nimpl api::ConnectorAccessToken for Custombilling {}\nimpl api::MandateSetup for Custombilling {}\nimpl api::PaymentAuthorize for Custombilling {}\nimpl\n\n... [truncated 16934 chars] ...\n\nebhooks::IncomingWebhook for Custombilling {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Custombilling {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__custombilling.rs", "file": "crates__hyperswitch_connectors__src__connectors__custombilling.rs"}, {"query": "hyperswitch custombilling authorize capture", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as custombilling;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Custombilling {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Custombilling {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Custombilling {}\nimpl api::PaymentSession for Custombilling {}\nimpl api::ConnectorAccessToken for Custombilling {}\nimpl api::MandateSetup for Custombilling {}\nimpl api::PaymentAuthorize for Custombilling {}\nimpl\n\n... [truncated 16934 chars] ...\n\nebhooks::IncomingWebhook for Custombilling {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Custombilling {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__custombilling.rs", "file": "crates__hyperswitch_connectors__src__connectors__custombilling.rs"}, {"query": "payment orchestration custom billing integration", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as custombilling;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Custombilling {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Custombilling {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Custombilling {}\nimpl api::PaymentSession for Custombilling {}\nimpl api::ConnectorAccessToken for Custombilling {}\nimpl api::MandateSetup for Custombilling {}\nimpl api::PaymentAuthorize for Custombilling {}\nimpl\n\n... [truncated 16934 chars] ...\n\nebhooks::IncomingWebhook for Custombilling {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Custombilling {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__custombilling.rs", "file": "crates__hyperswitch_connectors__src__connectors__custombilling.rs"}, {"query": "how to track API events in hyperswitch", "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\n#[cfg(feature = \"v2\")]\nuse super::{\n    PaymentAttemptListRequest, PaymentAttemptListResponse, PaymentStartRedirectionRequest,\n    PaymentsCreateIntentRequest, PaymentsGetIntentRequest, PaymentsIntentResponse, PaymentsRequest,\n    RecoveryPaymentListResponse, RecoveryPaymentsCreate, RecoveryPaymentsResponse,\n    RevenueRecoveryGetIntentResponse,\n};\n#[cfg(feature = \"v2\")]\nuse crate::payment_methods::{\n    ListMethodsForPaymentMethodsRequest, PaymentMethodGetTokenDetailsResponse,\n    PaymentMethodListResponseForSession,\n};\nuse crate::{\n    payment_methods::{\n        self, ListCountriesCurrenciesRequest, ListCountriesCurrenciesResponse,\n        PaymentMethodCollectLinkRenderRequest, PaymentMethodCollectLinkRequest,\n        PaymentMethodCollectLinkResponse, PaymentMethodMigrateResponse, PaymentMethodResponse,\n        PaymentMethodUpdate,\n    },\n    payments::{\n        self, PaymentListConstraints, PaymentListFilters, PaymentListFiltersV2,\n        PaymentListResponse, PaymentsAggregateResponse, PaymentsSessionResponse,\n        RedirectionResponse,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    payment_methods::{\n        CustomerPaymentMethodUpdateResponse, PaymentMethodListRequest, PaymentMethodListResponse,\n    },\n    payments::{\n        ExtendedCardInfoResponse, PaymentIdType, PaymentListFilterConstraints,\n        PaymentListResponseV2, PaymentsApproveRequest, PaymentsCancelPostCaptureRequest,\n        PaymentsCancelRequest, PaymentsCaptureRequest, PaymentsCompleteAuthorizeRequest,\n        PaymentsDynamicTaxCalculationRequest, PaymentsDynamicTaxCalculationResponse,\n        PaymentsExtendAuthorizationRequest, PaymentsExternalAuthenticationRequest,\n        PaymentsExternalAuthenticationResponse, PaymentsIncrementalAuthorizationRequest,\n        PaymentsManualUpdateRequest, PaymentsManualUpdateResponse,\n        PaymentsPostSessionTokensRequest, PaymentsPostSessionTokensResponse, PaymentsRejectRequest,\n        PaymentsRetr\n\n... [truncated 15703 chars] ...\n\nType::Payment {\n            payment_id: self.id.clone(),\n        })\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payments::PaymentMethodListResponseForPayments {\n    // Payment id would be populated by the request\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        None\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for PaymentMethodListResponseForSession {}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payments::PaymentsCaptureResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Payment {\n            payment_id: self.id.clone(),\n        })\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payment_methods::PaymentMethodGetTokenDetailsResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::PaymentMethod {\n            payment_method_id: self.id.clone(),\n            payment_method_type: None,\n            payment_method_subtype: None,\n        })\n    }\n}\n", "function_name": "crates__api_models__src__events__payment.rs", "file": "crates__api_models__src__events__payment.rs"}, {"query": "ApiEventMetric trait implementation", "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\n#[cfg(feature = \"v2\")]\nuse super::{\n    PaymentAttemptListRequest, PaymentAttemptListResponse, PaymentStartRedirectionRequest,\n    PaymentsCreateIntentRequest, PaymentsGetIntentRequest, PaymentsIntentResponse, PaymentsRequest,\n    RecoveryPaymentListResponse, RecoveryPaymentsCreate, RecoveryPaymentsResponse,\n    RevenueRecoveryGetIntentResponse,\n};\n#[cfg(feature = \"v2\")]\nuse crate::payment_methods::{\n    ListMethodsForPaymentMethodsRequest, PaymentMethodGetTokenDetailsResponse,\n    PaymentMethodListResponseForSession,\n};\nuse crate::{\n    payment_methods::{\n        self, ListCountriesCurrenciesRequest, ListCountriesCurrenciesResponse,\n        PaymentMethodCollectLinkRenderRequest, PaymentMethodCollectLinkRequest,\n        PaymentMethodCollectLinkResponse, PaymentMethodMigrateResponse, PaymentMethodResponse,\n        PaymentMethodUpdate,\n    },\n    payments::{\n        self, PaymentListConstraints, PaymentListFilters, PaymentListFiltersV2,\n        PaymentListResponse, PaymentsAggregateResponse, PaymentsSessionResponse,\n        RedirectionResponse,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    payment_methods::{\n        CustomerPaymentMethodUpdateResponse, PaymentMethodListRequest, PaymentMethodListResponse,\n    },\n    payments::{\n        ExtendedCardInfoResponse, PaymentIdType, PaymentListFilterConstraints,\n        PaymentListResponseV2, PaymentsApproveRequest, PaymentsCancelPostCaptureRequest,\n        PaymentsCancelRequest, PaymentsCaptureRequest, PaymentsCompleteAuthorizeRequest,\n        PaymentsDynamicTaxCalculationRequest, PaymentsDynamicTaxCalculationResponse,\n        PaymentsExtendAuthorizationRequest, PaymentsExternalAuthenticationRequest,\n        PaymentsExternalAuthenticationResponse, PaymentsIncrementalAuthorizationRequest,\n        PaymentsManualUpdateRequest, PaymentsManualUpdateResponse,\n        PaymentsPostSessionTokensRequest, PaymentsPostSessionTokensResponse, PaymentsRejectRequest,\n        PaymentsRetr\n\n... [truncated 15703 chars] ...\n\nType::Payment {\n            payment_id: self.id.clone(),\n        })\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payments::PaymentMethodListResponseForPayments {\n    // Payment id would be populated by the request\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        None\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for PaymentMethodListResponseForSession {}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payments::PaymentsCaptureResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Payment {\n            payment_id: self.id.clone(),\n        })\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payment_methods::PaymentMethodGetTokenDetailsResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::PaymentMethod {\n            payment_method_id: self.id.clone(),\n            payment_method_type: None,\n            payment_method_subtype: None,\n        })\n    }\n}\n", "function_name": "crates__api_models__src__events__payment.rs", "file": "crates__api_models__src__events__payment.rs"}, {"query": "how to implement payment event tracking", "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\n#[cfg(feature = \"v2\")]\nuse super::{\n    PaymentAttemptListRequest, PaymentAttemptListResponse, PaymentStartRedirectionRequest,\n    PaymentsCreateIntentRequest, PaymentsGetIntentRequest, PaymentsIntentResponse, PaymentsRequest,\n    RecoveryPaymentListResponse, RecoveryPaymentsCreate, RecoveryPaymentsResponse,\n    RevenueRecoveryGetIntentResponse,\n};\n#[cfg(feature = \"v2\")]\nuse crate::payment_methods::{\n    ListMethodsForPaymentMethodsRequest, PaymentMethodGetTokenDetailsResponse,\n    PaymentMethodListResponseForSession,\n};\nuse crate::{\n    payment_methods::{\n        self, ListCountriesCurrenciesRequest, ListCountriesCurrenciesResponse,\n        PaymentMethodCollectLinkRenderRequest, PaymentMethodCollectLinkRequest,\n        PaymentMethodCollectLinkResponse, PaymentMethodMigrateResponse, PaymentMethodResponse,\n        PaymentMethodUpdate,\n    },\n    payments::{\n        self, PaymentListConstraints, PaymentListFilters, PaymentListFiltersV2,\n        PaymentListResponse, PaymentsAggregateResponse, PaymentsSessionResponse,\n        RedirectionResponse,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    payment_methods::{\n        CustomerPaymentMethodUpdateResponse, PaymentMethodListRequest, PaymentMethodListResponse,\n    },\n    payments::{\n        ExtendedCardInfoResponse, PaymentIdType, PaymentListFilterConstraints,\n        PaymentListResponseV2, PaymentsApproveRequest, PaymentsCancelPostCaptureRequest,\n        PaymentsCancelRequest, PaymentsCaptureRequest, PaymentsCompleteAuthorizeRequest,\n        PaymentsDynamicTaxCalculationRequest, PaymentsDynamicTaxCalculationResponse,\n        PaymentsExtendAuthorizationRequest, PaymentsExternalAuthenticationRequest,\n        PaymentsExternalAuthenticationResponse, PaymentsIncrementalAuthorizationRequest,\n        PaymentsManualUpdateRequest, PaymentsManualUpdateResponse,\n        PaymentsPostSessionTokensRequest, PaymentsPostSessionTokensResponse, PaymentsRejectRequest,\n        PaymentsRetr\n\n... [truncated 15703 chars] ...\n\nType::Payment {\n            payment_id: self.id.clone(),\n        })\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payments::PaymentMethodListResponseForPayments {\n    // Payment id would be populated by the request\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        None\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for PaymentMethodListResponseForSession {}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payments::PaymentsCaptureResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Payment {\n            payment_id: self.id.clone(),\n        })\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payment_methods::PaymentMethodGetTokenDetailsResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::PaymentMethod {\n            payment_method_id: self.id.clone(),\n            payment_method_type: None,\n            payment_method_subtype: None,\n        })\n    }\n}\n", "function_name": "crates__api_models__src__events__payment.rs", "file": "crates__api_models__src__events__payment.rs"}, {"query": "hyperswitch payment event types", "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\n#[cfg(feature = \"v2\")]\nuse super::{\n    PaymentAttemptListRequest, PaymentAttemptListResponse, PaymentStartRedirectionRequest,\n    PaymentsCreateIntentRequest, PaymentsGetIntentRequest, PaymentsIntentResponse, PaymentsRequest,\n    RecoveryPaymentListResponse, RecoveryPaymentsCreate, RecoveryPaymentsResponse,\n    RevenueRecoveryGetIntentResponse,\n};\n#[cfg(feature = \"v2\")]\nuse crate::payment_methods::{\n    ListMethodsForPaymentMethodsRequest, PaymentMethodGetTokenDetailsResponse,\n    PaymentMethodListResponseForSession,\n};\nuse crate::{\n    payment_methods::{\n        self, ListCountriesCurrenciesRequest, ListCountriesCurrenciesResponse,\n        PaymentMethodCollectLinkRenderRequest, PaymentMethodCollectLinkRequest,\n        PaymentMethodCollectLinkResponse, PaymentMethodMigrateResponse, PaymentMethodResponse,\n        PaymentMethodUpdate,\n    },\n    payments::{\n        self, PaymentListConstraints, PaymentListFilters, PaymentListFiltersV2,\n        PaymentListResponse, PaymentsAggregateResponse, PaymentsSessionResponse,\n        RedirectionResponse,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    payment_methods::{\n        CustomerPaymentMethodUpdateResponse, PaymentMethodListRequest, PaymentMethodListResponse,\n    },\n    payments::{\n        ExtendedCardInfoResponse, PaymentIdType, PaymentListFilterConstraints,\n        PaymentListResponseV2, PaymentsApproveRequest, PaymentsCancelPostCaptureRequest,\n        PaymentsCancelRequest, PaymentsCaptureRequest, PaymentsCompleteAuthorizeRequest,\n        PaymentsDynamicTaxCalculationRequest, PaymentsDynamicTaxCalculationResponse,\n        PaymentsExtendAuthorizationRequest, PaymentsExternalAuthenticationRequest,\n        PaymentsExternalAuthenticationResponse, PaymentsIncrementalAuthorizationRequest,\n        PaymentsManualUpdateRequest, PaymentsManualUpdateResponse,\n        PaymentsPostSessionTokensRequest, PaymentsPostSessionTokensResponse, PaymentsRejectRequest,\n        PaymentsRetr\n\n... [truncated 15703 chars] ...\n\nType::Payment {\n            payment_id: self.id.clone(),\n        })\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payments::PaymentMethodListResponseForPayments {\n    // Payment id would be populated by the request\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        None\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for PaymentMethodListResponseForSession {}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payments::PaymentsCaptureResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Payment {\n            payment_id: self.id.clone(),\n        })\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl ApiEventMetric for payment_methods::PaymentMethodGetTokenDetailsResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::PaymentMethod {\n            payment_method_id: self.id.clone(),\n            payment_method_type: None,\n            payment_method_subtype: None,\n        })\n    }\n}\n", "function_name": "crates__api_models__src__events__payment.rs", "file": "crates__api_models__src__events__payment.rs"}, {"query": "Affirm payment connector implementation", "code": "use common_enums::{enums, CountryAlpha2, Currency};\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\npub struct AffirmRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for AffirmRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmPaymentsRequest {\n    pub merchant: Merchant,\n    pub items: Vec<Item>,\n    pub shipping: Option<Shipping>,\n    pub billing: Option<Billing>,\n    pub total: MinorUnit,\n    pub currency: Currency,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmCompleteAuthorizeRequest {\n    pub order_id: Option<String>,\n    pub reference_id: Option<String>,\n    pub transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsCompleteAuthorizeRouterData> for AffirmCompleteAuthorizeRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsCompleteAuthorizeRouterData) -> Result<Self, Self::Error> {\n        let transaction_id \n\n... [truncated 26065 chars] ...\n\non_id: Option<String>,\n}\n\nimpl TryFrom<PaymentsCancelResponseRouterData<AffirmCancelResponse>> for PaymentsCancelRouterData {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: PaymentsCancelResponseRouterData<AffirmCancelResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            status: enums::AttemptStatus::from(item.response.event_type.clone()),\n            response: Ok(PaymentsResponseData::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(item.response.id),\n                redirection_data: Box::new(None),\n                mandate_reference: Box::new(None),\n                connector_metadata: None,\n                network_txn_id: None,\n                connector_response_reference_id: None,\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs"}, {"query": "AffirmPaymentsRequest struct definition", "code": "use common_enums::{enums, CountryAlpha2, Currency};\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\npub struct AffirmRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for AffirmRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmPaymentsRequest {\n    pub merchant: Merchant,\n    pub items: Vec<Item>,\n    pub shipping: Option<Shipping>,\n    pub billing: Option<Billing>,\n    pub total: MinorUnit,\n    pub currency: Currency,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmCompleteAuthorizeRequest {\n    pub order_id: Option<String>,\n    pub reference_id: Option<String>,\n    pub transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsCompleteAuthorizeRouterData> for AffirmCompleteAuthorizeRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsCompleteAuthorizeRouterData) -> Result<Self, Self::Error> {\n        let transaction_id \n\n... [truncated 26065 chars] ...\n\non_id: Option<String>,\n}\n\nimpl TryFrom<PaymentsCancelResponseRouterData<AffirmCancelResponse>> for PaymentsCancelRouterData {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: PaymentsCancelResponseRouterData<AffirmCancelResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            status: enums::AttemptStatus::from(item.response.event_type.clone()),\n            response: Ok(PaymentsResponseData::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(item.response.id),\n                redirection_data: Box::new(None),\n                mandate_reference: Box::new(None),\n                connector_metadata: None,\n                network_txn_id: None,\n                connector_response_reference_id: None,\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs"}, {"query": "how to transform Hyperswitch to Affirm", "code": "use common_enums::{enums, CountryAlpha2, Currency};\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\npub struct AffirmRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for AffirmRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmPaymentsRequest {\n    pub merchant: Merchant,\n    pub items: Vec<Item>,\n    pub shipping: Option<Shipping>,\n    pub billing: Option<Billing>,\n    pub total: MinorUnit,\n    pub currency: Currency,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmCompleteAuthorizeRequest {\n    pub order_id: Option<String>,\n    pub reference_id: Option<String>,\n    pub transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsCompleteAuthorizeRouterData> for AffirmCompleteAuthorizeRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsCompleteAuthorizeRouterData) -> Result<Self, Self::Error> {\n        let transaction_id \n\n... [truncated 26065 chars] ...\n\non_id: Option<String>,\n}\n\nimpl TryFrom<PaymentsCancelResponseRouterData<AffirmCancelResponse>> for PaymentsCancelRouterData {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: PaymentsCancelResponseRouterData<AffirmCancelResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            status: enums::AttemptStatus::from(item.response.event_type.clone()),\n            response: Ok(PaymentsResponseData::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(item.response.id),\n                redirection_data: Box::new(None),\n                mandate_reference: Box::new(None),\n                connector_metadata: None,\n                network_txn_id: None,\n                connector_response_reference_id: None,\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs"}, {"query": "AffirmCancelResponse mapping logic", "code": "use common_enums::{enums, CountryAlpha2, Currency};\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\npub struct AffirmRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for AffirmRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmPaymentsRequest {\n    pub merchant: Merchant,\n    pub items: Vec<Item>,\n    pub shipping: Option<Shipping>,\n    pub billing: Option<Billing>,\n    pub total: MinorUnit,\n    pub currency: Currency,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmCompleteAuthorizeRequest {\n    pub order_id: Option<String>,\n    pub reference_id: Option<String>,\n    pub transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsCompleteAuthorizeRouterData> for AffirmCompleteAuthorizeRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsCompleteAuthorizeRouterData) -> Result<Self, Self::Error> {\n        let transaction_id \n\n... [truncated 26065 chars] ...\n\non_id: Option<String>,\n}\n\nimpl TryFrom<PaymentsCancelResponseRouterData<AffirmCancelResponse>> for PaymentsCancelRouterData {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: PaymentsCancelResponseRouterData<AffirmCancelResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            status: enums::AttemptStatus::from(item.response.event_type.clone()),\n            response: Ok(PaymentsResponseData::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(item.response.id),\n                redirection_data: Box::new(None),\n                mandate_reference: Box::new(None),\n                connector_metadata: None,\n                network_txn_id: None,\n                connector_response_reference_id: None,\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs"}, {"query": "hyperswitch nexixpay connector implementation", "code": "pub mod transformers;\nuse std::collections::HashSet;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        unified_authentication_service::PostAuthenticate,\n        PreAuthenticate,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connecto\n\n... [truncated 46113 chars] ...\n\nSupportedPaymentMethods> {\n        Some(&*NEXIXPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*NEXIXPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                request_data,\n                auth_type,\n            } => {\n                // Mandate payments should skip pre-authentication and go directly to authorize\n                if request_data.is_mandate_payment() {\n                    false\n                } else {\n                    self.is_3ds_setup_required(request_data, *auth_type)\n                }\n            }\n            // No alternate flow for complete authorize\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexixpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexixpay.rs"}, {"query": "Nexixpay struct hyperswitch", "code": "pub mod transformers;\nuse std::collections::HashSet;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        unified_authentication_service::PostAuthenticate,\n        PreAuthenticate,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connecto\n\n... [truncated 46113 chars] ...\n\nSupportedPaymentMethods> {\n        Some(&*NEXIXPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*NEXIXPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                request_data,\n                auth_type,\n            } => {\n                // Mandate payments should skip pre-authentication and go directly to authorize\n                if request_data.is_mandate_payment() {\n                    false\n                } else {\n                    self.is_3ds_setup_required(request_data, *auth_type)\n                }\n            }\n            // No alternate flow for complete authorize\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexixpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexixpay.rs"}, {"query": "how to implement nexixpay payment gateway in rust", "code": "pub mod transformers;\nuse std::collections::HashSet;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        unified_authentication_service::PostAuthenticate,\n        PreAuthenticate,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connecto\n\n... [truncated 46113 chars] ...\n\nSupportedPaymentMethods> {\n        Some(&*NEXIXPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*NEXIXPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                request_data,\n                auth_type,\n            } => {\n                // Mandate payments should skip pre-authentication and go directly to authorize\n                if request_data.is_mandate_payment() {\n                    false\n                } else {\n                    self.is_3ds_setup_required(request_data, *auth_type)\n                }\n            }\n            // No alternate flow for complete authorize\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexixpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexixpay.rs"}, {"query": "hyperswitch nexixpay 3ds setup", "code": "pub mod transformers;\nuse std::collections::HashSet;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        unified_authentication_service::PostAuthenticate,\n        PreAuthenticate,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connecto\n\n... [truncated 46113 chars] ...\n\nSupportedPaymentMethods> {\n        Some(&*NEXIXPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*NEXIXPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                request_data,\n                auth_type,\n            } => {\n                // Mandate payments should skip pre-authentication and go directly to authorize\n                if request_data.is_mandate_payment() {\n                    false\n                } else {\n                    self.is_3ds_setup_required(request_data, *auth_type)\n                }\n            }\n            // No alternate flow for complete authorize\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexixpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexixpay.rs"}, {"query": "nexinets payment request transformer", "code": "use base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus};\nuse common_utils::{consts, errors::CustomResult, request::Method};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, Card, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, PaymentsAuthorizeRequestData, PaymentsCancelRequestData, WalletData as _,\n    },\n};\n\npub mod nexinets_constants {\n    pub const MAX_PAYMENT_REFERENCE_ID_LENGTH: usize = 30;\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NexinetsPaymentsRequest {\n    initial_amount: i64,\n    currency: enums::Currency,\n    channel: NexinetsChannel,\n    product: NexinetsProduct,\n    payment: Option<NexinetsPaymentDetails>,\n    #[serde(rename = \"async\")]\n    nexinets_async: NexinetsAsyncDetails,\n    merchant_order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize, Default)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum NexinetsChannel {\n    #[default]\n    Ecom,\n}\n\n#[derive(Default, Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum NexinetsProduct {\n    #[default]\n    Creditcard,\n    Paypal,\n    Giropay,\n    Sofort,\n    Eps,\n    Ideal,\n    Applepay,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\n#[serde(untagged)]\npub enum NexinetsPaymentDetails {\n    Card(Box<NexiCardDetails>\n\n... [truncated 24138 chars] ...\n\n| WalletData::WeChatPayQr(_)\n        | WalletData::CashappQr(_)\n        | WalletData::SwishQr(_)\n        | WalletData::Mifinity(_)\n        | WalletData::RevolutPay(_) => Err(errors::ConnectorError::NotImplemented(\n            utils::get_unimplemented_payment_method_error_message(\"nexinets\"),\n        ))?,\n    }\n}\n\npub fn get_order_id(\n    meta: &NexinetsPaymentsMetadata,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    let order_id = meta.order_id.clone().ok_or(\n        errors::ConnectorError::MissingConnectorRelatedTransactionID {\n            id: \"order_id\".to_string(),\n        },\n    )?;\n    Ok(order_id)\n}\n\npub fn get_transaction_id(\n    meta: &NexinetsPaymentsMetadata,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    let transaction_id = meta.transaction_id.clone().ok_or(\n        errors::ConnectorError::MissingConnectorRelatedTransactionID {\n            id: \"transaction_id\".to_string(),\n        },\n    )?;\n    Ok(transaction_id)\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexinets__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexinets__transformers.rs"}, {"query": "how to map card data to nexinets", "code": "use base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus};\nuse common_utils::{consts, errors::CustomResult, request::Method};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, Card, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, PaymentsAuthorizeRequestData, PaymentsCancelRequestData, WalletData as _,\n    },\n};\n\npub mod nexinets_constants {\n    pub const MAX_PAYMENT_REFERENCE_ID_LENGTH: usize = 30;\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NexinetsPaymentsRequest {\n    initial_amount: i64,\n    currency: enums::Currency,\n    channel: NexinetsChannel,\n    product: NexinetsProduct,\n    payment: Option<NexinetsPaymentDetails>,\n    #[serde(rename = \"async\")]\n    nexinets_async: NexinetsAsyncDetails,\n    merchant_order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize, Default)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum NexinetsChannel {\n    #[default]\n    Ecom,\n}\n\n#[derive(Default, Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum NexinetsProduct {\n    #[default]\n    Creditcard,\n    Paypal,\n    Giropay,\n    Sofort,\n    Eps,\n    Ideal,\n    Applepay,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\n#[serde(untagged)]\npub enum NexinetsPaymentDetails {\n    Card(Box<NexiCardDetails>\n\n... [truncated 24138 chars] ...\n\n| WalletData::WeChatPayQr(_)\n        | WalletData::CashappQr(_)\n        | WalletData::SwishQr(_)\n        | WalletData::Mifinity(_)\n        | WalletData::RevolutPay(_) => Err(errors::ConnectorError::NotImplemented(\n            utils::get_unimplemented_payment_method_error_message(\"nexinets\"),\n        ))?,\n    }\n}\n\npub fn get_order_id(\n    meta: &NexinetsPaymentsMetadata,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    let order_id = meta.order_id.clone().ok_or(\n        errors::ConnectorError::MissingConnectorRelatedTransactionID {\n            id: \"order_id\".to_string(),\n        },\n    )?;\n    Ok(order_id)\n}\n\npub fn get_transaction_id(\n    meta: &NexinetsPaymentsMetadata,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    let transaction_id = meta.transaction_id.clone().ok_or(\n        errors::ConnectorError::MissingConnectorRelatedTransactionID {\n            id: \"transaction_id\".to_string(),\n        },\n    )?;\n    Ok(transaction_id)\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexinets__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexinets__transformers.rs"}, {"query": "nexinets connector implementation", "code": "use base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus};\nuse common_utils::{consts, errors::CustomResult, request::Method};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, Card, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, PaymentsAuthorizeRequestData, PaymentsCancelRequestData, WalletData as _,\n    },\n};\n\npub mod nexinets_constants {\n    pub const MAX_PAYMENT_REFERENCE_ID_LENGTH: usize = 30;\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NexinetsPaymentsRequest {\n    initial_amount: i64,\n    currency: enums::Currency,\n    channel: NexinetsChannel,\n    product: NexinetsProduct,\n    payment: Option<NexinetsPaymentDetails>,\n    #[serde(rename = \"async\")]\n    nexinets_async: NexinetsAsyncDetails,\n    merchant_order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize, Default)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum NexinetsChannel {\n    #[default]\n    Ecom,\n}\n\n#[derive(Default, Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum NexinetsProduct {\n    #[default]\n    Creditcard,\n    Paypal,\n    Giropay,\n    Sofort,\n    Eps,\n    Ideal,\n    Applepay,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\n#[serde(untagged)]\npub enum NexinetsPaymentDetails {\n    Card(Box<NexiCardDetails>\n\n... [truncated 24138 chars] ...\n\n| WalletData::WeChatPayQr(_)\n        | WalletData::CashappQr(_)\n        | WalletData::SwishQr(_)\n        | WalletData::Mifinity(_)\n        | WalletData::RevolutPay(_) => Err(errors::ConnectorError::NotImplemented(\n            utils::get_unimplemented_payment_method_error_message(\"nexinets\"),\n        ))?,\n    }\n}\n\npub fn get_order_id(\n    meta: &NexinetsPaymentsMetadata,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    let order_id = meta.order_id.clone().ok_or(\n        errors::ConnectorError::MissingConnectorRelatedTransactionID {\n            id: \"order_id\".to_string(),\n        },\n    )?;\n    Ok(order_id)\n}\n\npub fn get_transaction_id(\n    meta: &NexinetsPaymentsMetadata,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    let transaction_id = meta.transaction_id.clone().ok_or(\n        errors::ConnectorError::MissingConnectorRelatedTransactionID {\n            id: \"transaction_id\".to_string(),\n        },\n    )?;\n    Ok(transaction_id)\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexinets__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexinets__transformers.rs"}, {"query": "transform router data to nexinets format", "code": "use base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus};\nuse common_utils::{consts, errors::CustomResult, request::Method};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, Card, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, PaymentsAuthorizeRequestData, PaymentsCancelRequestData, WalletData as _,\n    },\n};\n\npub mod nexinets_constants {\n    pub const MAX_PAYMENT_REFERENCE_ID_LENGTH: usize = 30;\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NexinetsPaymentsRequest {\n    initial_amount: i64,\n    currency: enums::Currency,\n    channel: NexinetsChannel,\n    product: NexinetsProduct,\n    payment: Option<NexinetsPaymentDetails>,\n    #[serde(rename = \"async\")]\n    nexinets_async: NexinetsAsyncDetails,\n    merchant_order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize, Default)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum NexinetsChannel {\n    #[default]\n    Ecom,\n}\n\n#[derive(Default, Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum NexinetsProduct {\n    #[default]\n    Creditcard,\n    Paypal,\n    Giropay,\n    Sofort,\n    Eps,\n    Ideal,\n    Applepay,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\n#[serde(untagged)]\npub enum NexinetsPaymentDetails {\n    Card(Box<NexiCardDetails>\n\n... [truncated 24138 chars] ...\n\n| WalletData::WeChatPayQr(_)\n        | WalletData::CashappQr(_)\n        | WalletData::SwishQr(_)\n        | WalletData::Mifinity(_)\n        | WalletData::RevolutPay(_) => Err(errors::ConnectorError::NotImplemented(\n            utils::get_unimplemented_payment_method_error_message(\"nexinets\"),\n        ))?,\n    }\n}\n\npub fn get_order_id(\n    meta: &NexinetsPaymentsMetadata,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    let order_id = meta.order_id.clone().ok_or(\n        errors::ConnectorError::MissingConnectorRelatedTransactionID {\n            id: \"order_id\".to_string(),\n        },\n    )?;\n    Ok(order_id)\n}\n\npub fn get_transaction_id(\n    meta: &NexinetsPaymentsMetadata,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    let transaction_id = meta.transaction_id.clone().ok_or(\n        errors::ConnectorError::MissingConnectorRelatedTransactionID {\n            id: \"transaction_id\".to_string(),\n        },\n    )?;\n    Ok(transaction_id)\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexinets__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexinets__transformers.rs"}, {"query": "Chargebee subscription transformer", "code": "#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse std::str::FromStr;\n\nuse api_models::subscription as api;\nuse common_enums::{connector_enums, enums};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    id_type::{CustomerId, InvoiceId, SubscriptionId},\n    pii::{self, Email},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse hyperswitch_domain_models::revenue_recovery;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{subscriptions::SubscriptionAutoCollection, ResponseId},\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n            self, GetSubscriptionEstimateResponse, GetSubscriptionItemPricesResponse,\n            GetSubscriptionItemsResponse, SubscriptionCancelResponse, SubscriptionCreateResponse,\n            SubscriptionInvoiceData, SubscriptionLineItem, SubscriptionPauseResponse,\n            SubscriptionResumeResponse, SubscriptionStatus,\n        },\n        ConnectorCustomerResponseData, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        GetSubscriptionEstimateRouterData, InvoiceRecordBackRouterData,\n        PaymentsAuthorizeRouterData, RefundsRouterData, SubscriptionCancelRouterData,\n        SubscriptionPauseRouterData, SubscriptionResumeRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    convert_connector_response_to_domain_response,\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\n\n// SubscriptionCreate structures\n#[derive(Debug, Serialize)]\npub struct ChargebeeSubscriptionCreateRequest {\n    #[serde(rename = \"id\")]\n\n\n... [truncated 51934 chars] ...\n\nouterData<_, ChargebeeResumeSubscriptionResponse, _, _>| {\n        let subscription = item.response.subscription;\n        Ok(Self {\n            response: Ok(SubscriptionResumeResponse {\n                subscription_id: subscription.id.clone(),\n                status: subscription.status.clone().into(),\n                next_billing_at: subscription.next_billing_at,\n            }),\n            ..item.data\n        })\n    }\n);\n\nconvert_connector_response_to_domain_response!(\n    ChargebeeCancelSubscriptionResponse,\n    SubscriptionCancelResponse,\n    |item: ResponseRouterData<_, ChargebeeCancelSubscriptionResponse, _, _>| {\n        let subscription = item.response.subscription;\n        Ok(Self {\n            response: Ok(SubscriptionCancelResponse {\n                subscription_id: subscription.id.clone(),\n                status: subscription.status.clone().into(),\n                cancelled_at: subscription.cancelled_at,\n            }),\n            ..item.data\n        })\n    }\n);\n", "function_name": "crates__hyperswitch_connectors__src__connectors__chargebee__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__chargebee__transformers.rs"}, {"query": "transform Chargebee subscription response", "code": "#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse std::str::FromStr;\n\nuse api_models::subscription as api;\nuse common_enums::{connector_enums, enums};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    id_type::{CustomerId, InvoiceId, SubscriptionId},\n    pii::{self, Email},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse hyperswitch_domain_models::revenue_recovery;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{subscriptions::SubscriptionAutoCollection, ResponseId},\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n            self, GetSubscriptionEstimateResponse, GetSubscriptionItemPricesResponse,\n            GetSubscriptionItemsResponse, SubscriptionCancelResponse, SubscriptionCreateResponse,\n            SubscriptionInvoiceData, SubscriptionLineItem, SubscriptionPauseResponse,\n            SubscriptionResumeResponse, SubscriptionStatus,\n        },\n        ConnectorCustomerResponseData, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        GetSubscriptionEstimateRouterData, InvoiceRecordBackRouterData,\n        PaymentsAuthorizeRouterData, RefundsRouterData, SubscriptionCancelRouterData,\n        SubscriptionPauseRouterData, SubscriptionResumeRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    convert_connector_response_to_domain_response,\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\n\n// SubscriptionCreate structures\n#[derive(Debug, Serialize)]\npub struct ChargebeeSubscriptionCreateRequest {\n    #[serde(rename = \"id\")]\n\n\n... [truncated 51934 chars] ...\n\nouterData<_, ChargebeeResumeSubscriptionResponse, _, _>| {\n        let subscription = item.response.subscription;\n        Ok(Self {\n            response: Ok(SubscriptionResumeResponse {\n                subscription_id: subscription.id.clone(),\n                status: subscription.status.clone().into(),\n                next_billing_at: subscription.next_billing_at,\n            }),\n            ..item.data\n        })\n    }\n);\n\nconvert_connector_response_to_domain_response!(\n    ChargebeeCancelSubscriptionResponse,\n    SubscriptionCancelResponse,\n    |item: ResponseRouterData<_, ChargebeeCancelSubscriptionResponse, _, _>| {\n        let subscription = item.response.subscription;\n        Ok(Self {\n            response: Ok(SubscriptionCancelResponse {\n                subscription_id: subscription.id.clone(),\n                status: subscription.status.clone().into(),\n                cancelled_at: subscription.cancelled_at,\n            }),\n            ..item.data\n        })\n    }\n);\n", "function_name": "crates__hyperswitch_connectors__src__connectors__chargebee__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__chargebee__transformers.rs"}, {"query": "how to create Chargebee subscription request", "code": "#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse std::str::FromStr;\n\nuse api_models::subscription as api;\nuse common_enums::{connector_enums, enums};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    id_type::{CustomerId, InvoiceId, SubscriptionId},\n    pii::{self, Email},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse hyperswitch_domain_models::revenue_recovery;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{subscriptions::SubscriptionAutoCollection, ResponseId},\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n            self, GetSubscriptionEstimateResponse, GetSubscriptionItemPricesResponse,\n            GetSubscriptionItemsResponse, SubscriptionCancelResponse, SubscriptionCreateResponse,\n            SubscriptionInvoiceData, SubscriptionLineItem, SubscriptionPauseResponse,\n            SubscriptionResumeResponse, SubscriptionStatus,\n        },\n        ConnectorCustomerResponseData, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        GetSubscriptionEstimateRouterData, InvoiceRecordBackRouterData,\n        PaymentsAuthorizeRouterData, RefundsRouterData, SubscriptionCancelRouterData,\n        SubscriptionPauseRouterData, SubscriptionResumeRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    convert_connector_response_to_domain_response,\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\n\n// SubscriptionCreate structures\n#[derive(Debug, Serialize)]\npub struct ChargebeeSubscriptionCreateRequest {\n    #[serde(rename = \"id\")]\n\n\n... [truncated 51934 chars] ...\n\nouterData<_, ChargebeeResumeSubscriptionResponse, _, _>| {\n        let subscription = item.response.subscription;\n        Ok(Self {\n            response: Ok(SubscriptionResumeResponse {\n                subscription_id: subscription.id.clone(),\n                status: subscription.status.clone().into(),\n                next_billing_at: subscription.next_billing_at,\n            }),\n            ..item.data\n        })\n    }\n);\n\nconvert_connector_response_to_domain_response!(\n    ChargebeeCancelSubscriptionResponse,\n    SubscriptionCancelResponse,\n    |item: ResponseRouterData<_, ChargebeeCancelSubscriptionResponse, _, _>| {\n        let subscription = item.response.subscription;\n        Ok(Self {\n            response: Ok(SubscriptionCancelResponse {\n                subscription_id: subscription.id.clone(),\n                status: subscription.status.clone().into(),\n                cancelled_at: subscription.cancelled_at,\n            }),\n            ..item.data\n        })\n    }\n);\n", "function_name": "crates__hyperswitch_connectors__src__connectors__chargebee__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__chargebee__transformers.rs"}, {"query": "hyperswitch Chargebee subscription cancel", "code": "#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse std::str::FromStr;\n\nuse api_models::subscription as api;\nuse common_enums::{connector_enums, enums};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    id_type::{CustomerId, InvoiceId, SubscriptionId},\n    pii::{self, Email},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse hyperswitch_domain_models::revenue_recovery;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{subscriptions::SubscriptionAutoCollection, ResponseId},\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n            self, GetSubscriptionEstimateResponse, GetSubscriptionItemPricesResponse,\n            GetSubscriptionItemsResponse, SubscriptionCancelResponse, SubscriptionCreateResponse,\n            SubscriptionInvoiceData, SubscriptionLineItem, SubscriptionPauseResponse,\n            SubscriptionResumeResponse, SubscriptionStatus,\n        },\n        ConnectorCustomerResponseData, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        GetSubscriptionEstimateRouterData, InvoiceRecordBackRouterData,\n        PaymentsAuthorizeRouterData, RefundsRouterData, SubscriptionCancelRouterData,\n        SubscriptionPauseRouterData, SubscriptionResumeRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    convert_connector_response_to_domain_response,\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\n\n// SubscriptionCreate structures\n#[derive(Debug, Serialize)]\npub struct ChargebeeSubscriptionCreateRequest {\n    #[serde(rename = \"id\")]\n\n\n... [truncated 51934 chars] ...\n\nouterData<_, ChargebeeResumeSubscriptionResponse, _, _>| {\n        let subscription = item.response.subscription;\n        Ok(Self {\n            response: Ok(SubscriptionResumeResponse {\n                subscription_id: subscription.id.clone(),\n                status: subscription.status.clone().into(),\n                next_billing_at: subscription.next_billing_at,\n            }),\n            ..item.data\n        })\n    }\n);\n\nconvert_connector_response_to_domain_response!(\n    ChargebeeCancelSubscriptionResponse,\n    SubscriptionCancelResponse,\n    |item: ResponseRouterData<_, ChargebeeCancelSubscriptionResponse, _, _>| {\n        let subscription = item.response.subscription;\n        Ok(Self {\n            response: Ok(SubscriptionCancelResponse {\n                subscription_id: subscription.id.clone(),\n                status: subscription.status.clone().into(),\n                cancelled_at: subscription.cancelled_at,\n            }),\n            ..item.data\n        })\n    }\n);\n", "function_name": "crates__hyperswitch_connectors__src__connectors__chargebee__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__chargebee__transformers.rs"}, {"query": "how to invalidate routing cache", "code": "//! Analysis for usage of all helper functions for use case of routing\n//!\n//! Functions that are used to perform the retrieval of merchant's\n//! routing dict, configs, defaults\nuse std::fmt::Debug;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::str::FromStr;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::sync::Arc;\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router;\nuse api_models::routing as routing_types;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{ext_traits::Encode, id_type};\nuse diesel_models::configs;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse diesel_models::dynamic_routing_stats::{DynamicRoutingStatsNew, DynamicRoutingStatsUpdate};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse diesel_models::routing_algorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_domain_models::api::ApplicationResponse;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v1\")]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashSet;\nuse storage_impl::redis::cache;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse storage_impl::redis::cache::Cacheable;\n\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::db::errors::StorageErrorExt;\n#[cfg(feature = \"v2\")]\nuse crate::types::domain::MerchantConnectorAccount;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::types::transformers::ForeignFrom;\nuse crate::{\n    core::errors::{self, Route\n\n... [truncated 115344 chars] ...\n\nasync fn redact_routing_cache(\n    state: &SessionState,\n    merchant_id: &id_type::MerchantId,\n    profile_id: &id_type::ProfileId,\n) -> RouterResult<()> {\n    let routing_payments_key = format!(\n        \"routing_config_{}_{}\",\n        merchant_id.get_string_repr(),\n        profile_id.get_string_repr(),\n    );\n    let routing_payouts_key = format!(\n        \"routing_config_po_{}_{}\",\n        merchant_id.get_string_repr(),\n        profile_id.get_string_repr(),\n    );\n\n    let routing_payouts_cache_key = cache::CacheKind::Routing(routing_payouts_key.clone().into());\n    let routing_payments_cache_key = cache::CacheKind::CGraph(routing_payments_key.clone().into());\n    cache::redact_from_redis_and_publish(\n        state.store.get_cache_store().as_ref(),\n        [routing_payouts_cache_key, routing_payments_cache_key],\n    )\n    .await\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to invalidate the routing cache\")?;\n\n    Ok(())\n}\n", "function_name": "crates__router__src__core__routing__helpers.rs", "file": "crates__router__src__core__routing__helpers.rs"}, {"query": "merchant routing configuration retrieval", "code": "//! Analysis for usage of all helper functions for use case of routing\n//!\n//! Functions that are used to perform the retrieval of merchant's\n//! routing dict, configs, defaults\nuse std::fmt::Debug;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::str::FromStr;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::sync::Arc;\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router;\nuse api_models::routing as routing_types;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{ext_traits::Encode, id_type};\nuse diesel_models::configs;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse diesel_models::dynamic_routing_stats::{DynamicRoutingStatsNew, DynamicRoutingStatsUpdate};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse diesel_models::routing_algorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_domain_models::api::ApplicationResponse;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v1\")]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashSet;\nuse storage_impl::redis::cache;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse storage_impl::redis::cache::Cacheable;\n\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::db::errors::StorageErrorExt;\n#[cfg(feature = \"v2\")]\nuse crate::types::domain::MerchantConnectorAccount;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::types::transformers::ForeignFrom;\nuse crate::{\n    core::errors::{self, Route\n\n... [truncated 115344 chars] ...\n\nasync fn redact_routing_cache(\n    state: &SessionState,\n    merchant_id: &id_type::MerchantId,\n    profile_id: &id_type::ProfileId,\n) -> RouterResult<()> {\n    let routing_payments_key = format!(\n        \"routing_config_{}_{}\",\n        merchant_id.get_string_repr(),\n        profile_id.get_string_repr(),\n    );\n    let routing_payouts_key = format!(\n        \"routing_config_po_{}_{}\",\n        merchant_id.get_string_repr(),\n        profile_id.get_string_repr(),\n    );\n\n    let routing_payouts_cache_key = cache::CacheKind::Routing(routing_payouts_key.clone().into());\n    let routing_payments_cache_key = cache::CacheKind::CGraph(routing_payments_key.clone().into());\n    cache::redact_from_redis_and_publish(\n        state.store.get_cache_store().as_ref(),\n        [routing_payouts_cache_key, routing_payments_cache_key],\n    )\n    .await\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to invalidate the routing cache\")?;\n\n    Ok(())\n}\n", "function_name": "crates__router__src__core__routing__helpers.rs", "file": "crates__router__src__core__routing__helpers.rs"}, {"query": "dynamic routing algorithm constants", "code": "//! Analysis for usage of all helper functions for use case of routing\n//!\n//! Functions that are used to perform the retrieval of merchant's\n//! routing dict, configs, defaults\nuse std::fmt::Debug;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::str::FromStr;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::sync::Arc;\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router;\nuse api_models::routing as routing_types;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{ext_traits::Encode, id_type};\nuse diesel_models::configs;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse diesel_models::dynamic_routing_stats::{DynamicRoutingStatsNew, DynamicRoutingStatsUpdate};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse diesel_models::routing_algorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_domain_models::api::ApplicationResponse;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v1\")]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashSet;\nuse storage_impl::redis::cache;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse storage_impl::redis::cache::Cacheable;\n\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::db::errors::StorageErrorExt;\n#[cfg(feature = \"v2\")]\nuse crate::types::domain::MerchantConnectorAccount;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::types::transformers::ForeignFrom;\nuse crate::{\n    core::errors::{self, Route\n\n... [truncated 115344 chars] ...\n\nasync fn redact_routing_cache(\n    state: &SessionState,\n    merchant_id: &id_type::MerchantId,\n    profile_id: &id_type::ProfileId,\n) -> RouterResult<()> {\n    let routing_payments_key = format!(\n        \"routing_config_{}_{}\",\n        merchant_id.get_string_repr(),\n        profile_id.get_string_repr(),\n    );\n    let routing_payouts_key = format!(\n        \"routing_config_po_{}_{}\",\n        merchant_id.get_string_repr(),\n        profile_id.get_string_repr(),\n    );\n\n    let routing_payouts_cache_key = cache::CacheKind::Routing(routing_payouts_key.clone().into());\n    let routing_payments_cache_key = cache::CacheKind::CGraph(routing_payments_key.clone().into());\n    cache::redact_from_redis_and_publish(\n        state.store.get_cache_store().as_ref(),\n        [routing_payouts_cache_key, routing_payments_cache_key],\n    )\n    .await\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to invalidate the routing cache\")?;\n\n    Ok(())\n}\n", "function_name": "crates__router__src__core__routing__helpers.rs", "file": "crates__router__src__core__routing__helpers.rs"}, {"query": "decision engine endpoint helpers", "code": "//! Analysis for usage of all helper functions for use case of routing\n//!\n//! Functions that are used to perform the retrieval of merchant's\n//! routing dict, configs, defaults\nuse std::fmt::Debug;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::str::FromStr;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::sync::Arc;\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router;\nuse api_models::routing as routing_types;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{ext_traits::Encode, id_type};\nuse diesel_models::configs;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse diesel_models::dynamic_routing_stats::{DynamicRoutingStatsNew, DynamicRoutingStatsUpdate};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse diesel_models::routing_algorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_domain_models::api::ApplicationResponse;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v1\")]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashSet;\nuse storage_impl::redis::cache;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse storage_impl::redis::cache::Cacheable;\n\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::db::errors::StorageErrorExt;\n#[cfg(feature = \"v2\")]\nuse crate::types::domain::MerchantConnectorAccount;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::types::transformers::ForeignFrom;\nuse crate::{\n    core::errors::{self, Route\n\n... [truncated 115344 chars] ...\n\nasync fn redact_routing_cache(\n    state: &SessionState,\n    merchant_id: &id_type::MerchantId,\n    profile_id: &id_type::ProfileId,\n) -> RouterResult<()> {\n    let routing_payments_key = format!(\n        \"routing_config_{}_{}\",\n        merchant_id.get_string_repr(),\n        profile_id.get_string_repr(),\n    );\n    let routing_payouts_key = format!(\n        \"routing_config_po_{}_{}\",\n        merchant_id.get_string_repr(),\n        profile_id.get_string_repr(),\n    );\n\n    let routing_payouts_cache_key = cache::CacheKind::Routing(routing_payouts_key.clone().into());\n    let routing_payments_cache_key = cache::CacheKind::CGraph(routing_payments_key.clone().into());\n    cache::redact_from_redis_and_publish(\n        state.store.get_cache_store().as_ref(),\n        [routing_payouts_cache_key, routing_payments_cache_key],\n    )\n    .await\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to invalidate the routing cache\")?;\n\n    Ok(())\n}\n", "function_name": "crates__router__src__core__routing__helpers.rs", "file": "crates__router__src__core__routing__helpers.rs"}, {"query": "how to implement Globalpay payment gateway", "code": "mod requests;\nmod response;\npub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData, SyncRequestType,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, CaptureSyncMethod, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorRedirectResponse, ConnectorSpecifications, ConnectorValidation,\n        PaymentsCompleteAuthorize,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, Pay\n\n... [truncated 41260 chars] ...\n\n\nstatic GLOBALPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Globalpay\",\n        description: \"Global Payments is an American multinational financial technology company that provides payment technology and services to merchants, issuers and consumers.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic GLOBALPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Globalpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GLOBALPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GLOBALPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GLOBALPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__globalpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__globalpay.rs"}, {"query": "Globalpay connector integration hyperswitch", "code": "mod requests;\nmod response;\npub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData, SyncRequestType,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, CaptureSyncMethod, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorRedirectResponse, ConnectorSpecifications, ConnectorValidation,\n        PaymentsCompleteAuthorize,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, Pay\n\n... [truncated 41260 chars] ...\n\n\nstatic GLOBALPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Globalpay\",\n        description: \"Global Payments is an American multinational financial technology company that provides payment technology and services to merchants, issuers and consumers.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic GLOBALPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Globalpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GLOBALPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GLOBALPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GLOBALPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__globalpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__globalpay.rs"}, {"query": "GlobalpayPaymentsRequest struct definition", "code": "mod requests;\nmod response;\npub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData, SyncRequestType,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, CaptureSyncMethod, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorRedirectResponse, ConnectorSpecifications, ConnectorValidation,\n        PaymentsCompleteAuthorize,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, Pay\n\n... [truncated 41260 chars] ...\n\n\nstatic GLOBALPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Globalpay\",\n        description: \"Global Payments is an American multinational financial technology company that provides payment technology and services to merchants, issuers and consumers.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic GLOBALPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Globalpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GLOBALPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GLOBALPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GLOBALPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__globalpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__globalpay.rs"}, {"query": "Globalpay payment method configuration", "code": "mod requests;\nmod response;\npub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData, SyncRequestType,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, CaptureSyncMethod, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorRedirectResponse, ConnectorSpecifications, ConnectorValidation,\n        PaymentsCompleteAuthorize,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, Pay\n\n... [truncated 41260 chars] ...\n\n\nstatic GLOBALPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Globalpay\",\n        description: \"Global Payments is an American multinational financial technology company that provides payment technology and services to merchants, issuers and consumers.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic GLOBALPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Globalpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GLOBALPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GLOBALPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GLOBALPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__globalpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__globalpay.rs"}, {"query": "Volt payment request transformer", "code": "use common_enums::enums;\nuse common_utils::{id_type, pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, RefreshTokenRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, is_payment_failure, AddressDetailsData, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst PASSWORD: &str = \"password\";\n\npub struct VoltRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for VoltRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\npub mod webhook_headers {\n    pub const X_VOLT_SIGNED: &str = \"X-Volt-Signed\";\n    pub const X_VOLT_TIMED: &str = \"X-Volt-Timed\";\n    pub const USER_AGENT: &str = \"User-Agent\";\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct VoltPaymentsRequest {\n    amount: MinorUnit,\n    currency: enums::Currency,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    open_banking_u_k: Option<OpenBankingUk>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    open_banking_e_u: Option<OpenBankingEu>,\n    internal_reference: String,\n    payer: PayerDetails,\n    payment_system: PaymentSystem,\n    communication: CommunicationDetails,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum Transact\n\n... [truncated 25512 chars] ...\n\n     VoltWebhookPaymentStatus::Completed | VoltWebhookPaymentStatus::Pending => {\n                    Self::PaymentIntentProcessing\n                }\n            },\n            VoltWebhookBodyEventType::Refund(refund_data) => match refund_data.status {\n                VoltWebhookRefundsStatus::RefundConfirmed => Self::RefundSuccess,\n                VoltWebhookRefundsStatus::RefundFailed => Self::RefundFailure,\n            },\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct VoltErrorResponse {\n    pub code: Option<String>,\n    pub message: String,\n    pub errors: Option<Vec<Errors>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Errors {\n    #[serde(rename = \"type\")]\n    pub error_type: String,\n    pub property_path: String,\n    pub message: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct VoltAuthErrorResponse {\n    pub code: u64,\n    pub message: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__volt__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__volt__transformers.rs"}, {"query": "how to handle Volt webhook events", "code": "use common_enums::enums;\nuse common_utils::{id_type, pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, RefreshTokenRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, is_payment_failure, AddressDetailsData, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst PASSWORD: &str = \"password\";\n\npub struct VoltRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for VoltRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\npub mod webhook_headers {\n    pub const X_VOLT_SIGNED: &str = \"X-Volt-Signed\";\n    pub const X_VOLT_TIMED: &str = \"X-Volt-Timed\";\n    pub const USER_AGENT: &str = \"User-Agent\";\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct VoltPaymentsRequest {\n    amount: MinorUnit,\n    currency: enums::Currency,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    open_banking_u_k: Option<OpenBankingUk>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    open_banking_e_u: Option<OpenBankingEu>,\n    internal_reference: String,\n    payer: PayerDetails,\n    payment_system: PaymentSystem,\n    communication: CommunicationDetails,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum Transact\n\n... [truncated 25512 chars] ...\n\n     VoltWebhookPaymentStatus::Completed | VoltWebhookPaymentStatus::Pending => {\n                    Self::PaymentIntentProcessing\n                }\n            },\n            VoltWebhookBodyEventType::Refund(refund_data) => match refund_data.status {\n                VoltWebhookRefundsStatus::RefundConfirmed => Self::RefundSuccess,\n                VoltWebhookRefundsStatus::RefundFailed => Self::RefundFailure,\n            },\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct VoltErrorResponse {\n    pub code: Option<String>,\n    pub message: String,\n    pub errors: Option<Vec<Errors>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Errors {\n    #[serde(rename = \"type\")]\n    pub error_type: String,\n    pub property_path: String,\n    pub message: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct VoltAuthErrorResponse {\n    pub code: u64,\n    pub message: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__volt__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__volt__transformers.rs"}, {"query": "Volt refund request structure", "code": "use common_enums::enums;\nuse common_utils::{id_type, pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, RefreshTokenRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, is_payment_failure, AddressDetailsData, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst PASSWORD: &str = \"password\";\n\npub struct VoltRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for VoltRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\npub mod webhook_headers {\n    pub const X_VOLT_SIGNED: &str = \"X-Volt-Signed\";\n    pub const X_VOLT_TIMED: &str = \"X-Volt-Timed\";\n    pub const USER_AGENT: &str = \"User-Agent\";\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct VoltPaymentsRequest {\n    amount: MinorUnit,\n    currency: enums::Currency,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    open_banking_u_k: Option<OpenBankingUk>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    open_banking_e_u: Option<OpenBankingEu>,\n    internal_reference: String,\n    payer: PayerDetails,\n    payment_system: PaymentSystem,\n    communication: CommunicationDetails,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum Transact\n\n... [truncated 25512 chars] ...\n\n     VoltWebhookPaymentStatus::Completed | VoltWebhookPaymentStatus::Pending => {\n                    Self::PaymentIntentProcessing\n                }\n            },\n            VoltWebhookBodyEventType::Refund(refund_data) => match refund_data.status {\n                VoltWebhookRefundsStatus::RefundConfirmed => Self::RefundSuccess,\n                VoltWebhookRefundsStatus::RefundFailed => Self::RefundFailure,\n            },\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct VoltErrorResponse {\n    pub code: Option<String>,\n    pub message: String,\n    pub errors: Option<Vec<Errors>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Errors {\n    #[serde(rename = \"type\")]\n    pub error_type: String,\n    pub property_path: String,\n    pub message: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct VoltAuthErrorResponse {\n    pub code: u64,\n    pub message: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__volt__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__volt__transformers.rs"}, {"query": "Volt connector error handling", "code": "use common_enums::enums;\nuse common_utils::{id_type, pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, RefreshTokenRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, is_payment_failure, AddressDetailsData, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst PASSWORD: &str = \"password\";\n\npub struct VoltRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for VoltRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\npub mod webhook_headers {\n    pub const X_VOLT_SIGNED: &str = \"X-Volt-Signed\";\n    pub const X_VOLT_TIMED: &str = \"X-Volt-Timed\";\n    pub const USER_AGENT: &str = \"User-Agent\";\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct VoltPaymentsRequest {\n    amount: MinorUnit,\n    currency: enums::Currency,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    open_banking_u_k: Option<OpenBankingUk>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    open_banking_e_u: Option<OpenBankingEu>,\n    internal_reference: String,\n    payer: PayerDetails,\n    payment_system: PaymentSystem,\n    communication: CommunicationDetails,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum Transact\n\n... [truncated 25512 chars] ...\n\n     VoltWebhookPaymentStatus::Completed | VoltWebhookPaymentStatus::Pending => {\n                    Self::PaymentIntentProcessing\n                }\n            },\n            VoltWebhookBodyEventType::Refund(refund_data) => match refund_data.status {\n                VoltWebhookRefundsStatus::RefundConfirmed => Self::RefundSuccess,\n                VoltWebhookRefundsStatus::RefundFailed => Self::RefundFailure,\n            },\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct VoltErrorResponse {\n    pub code: Option<String>,\n    pub message: String,\n    pub errors: Option<Vec<Errors>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Errors {\n    #[serde(rename = \"type\")]\n    pub error_type: String,\n    pub property_path: String,\n    pub message: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct VoltAuthErrorResponse {\n    pub code: u64,\n    pub message: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__volt__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__volt__transformers.rs"}, {"query": "how to store payment events in hyperswitch", "code": "use std::collections::HashSet;\n\nuse common_utils::ext_traits::AsyncExt;\nuse error_stack::{report, ResultExt};\nuse futures::future::try_join_all;\nuse router_env::{instrument, tracing};\n\nuse super::{MockDb, Store};\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    types::{\n        domain::{\n            self,\n            behaviour::{Conversion, ReverseConversion},\n        },\n        storage,\n    },\n};\n\n#[async_trait::async_trait]\npub trait EventInterface\nwhere\n    domain::Event:\n        Conversion<DstType = storage::events::Event, NewDstType = storage::events::EventNew>,\n{\n    async fn insert_event(\n        &self,\n        event: domain::Event,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    async fn find_event_by_merchant_id_event_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        event_id: &str,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    async fn find_event_by_merchant_id_idempotent_event_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        idempotent_event_id: &str,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    #[allow(clippy::too_many_arguments)]\n    async fn list_initial_events_by_merchant_id_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        created_after: time::PrimitiveDateTime,\n        created_before: time::PrimitiveDateTime,\n        limit: Option<i64>,\n        offset: Option<i64>,\n        event_types: HashSet<common_enums::EventType>,\n        is_delivered: Option<bool>,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::Event>, errors::StorageError>;\n\n    async fn list_events_by_merchant_id_initial_attempt_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n      \n\n... [truncated 59688 chars] ...\n\n       1,\n            \"Expected exactly 1 row in events table when querying by primary_object_id, found {}\",\n            events_by_object_id.len()\n        );\n\n        let first_event = events_by_object_id\n            .first()\n            .ok_or(\"Expected at least one event in the result\")?;\n        let event_id = first_event.event_id.clone();\n        let event_by_event_id = state\n            .store\n            .find_initial_event_by_merchant_id_initial_attempt_id(\n                &business_profile.merchant_id,\n                &event_id,\n                &merchant_key_store,\n            )\n            .await?;\n\n        assert!(\n            event_by_event_id.is_some(),\n            \"Expected to find an event when querying by initial_attempt_id (event_id)\"\n        );\n\n        let found_event = event_by_event_id.unwrap();\n        assert_eq!(\n            first_event.event_id, found_event.event_id,\n            \"Event IDs should match between queries\"\n        );\n        Ok(())\n    }\n}\n", "function_name": "crates__router__src__db__events.rs", "file": "crates__router__src__db__events.rs"}, {"query": "EventInterface trait implementation", "code": "use std::collections::HashSet;\n\nuse common_utils::ext_traits::AsyncExt;\nuse error_stack::{report, ResultExt};\nuse futures::future::try_join_all;\nuse router_env::{instrument, tracing};\n\nuse super::{MockDb, Store};\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    types::{\n        domain::{\n            self,\n            behaviour::{Conversion, ReverseConversion},\n        },\n        storage,\n    },\n};\n\n#[async_trait::async_trait]\npub trait EventInterface\nwhere\n    domain::Event:\n        Conversion<DstType = storage::events::Event, NewDstType = storage::events::EventNew>,\n{\n    async fn insert_event(\n        &self,\n        event: domain::Event,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    async fn find_event_by_merchant_id_event_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        event_id: &str,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    async fn find_event_by_merchant_id_idempotent_event_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        idempotent_event_id: &str,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    #[allow(clippy::too_many_arguments)]\n    async fn list_initial_events_by_merchant_id_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        created_after: time::PrimitiveDateTime,\n        created_before: time::PrimitiveDateTime,\n        limit: Option<i64>,\n        offset: Option<i64>,\n        event_types: HashSet<common_enums::EventType>,\n        is_delivered: Option<bool>,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::Event>, errors::StorageError>;\n\n    async fn list_events_by_merchant_id_initial_attempt_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n      \n\n... [truncated 59688 chars] ...\n\n       1,\n            \"Expected exactly 1 row in events table when querying by primary_object_id, found {}\",\n            events_by_object_id.len()\n        );\n\n        let first_event = events_by_object_id\n            .first()\n            .ok_or(\"Expected at least one event in the result\")?;\n        let event_id = first_event.event_id.clone();\n        let event_by_event_id = state\n            .store\n            .find_initial_event_by_merchant_id_initial_attempt_id(\n                &business_profile.merchant_id,\n                &event_id,\n                &merchant_key_store,\n            )\n            .await?;\n\n        assert!(\n            event_by_event_id.is_some(),\n            \"Expected to find an event when querying by initial_attempt_id (event_id)\"\n        );\n\n        let found_event = event_by_event_id.unwrap();\n        assert_eq!(\n            first_event.event_id, found_event.event_id,\n            \"Event IDs should match between queries\"\n        );\n        Ok(())\n    }\n}\n", "function_name": "crates__router__src__db__events.rs", "file": "crates__router__src__db__events.rs"}, {"query": "how to implement event persistence in rust", "code": "use std::collections::HashSet;\n\nuse common_utils::ext_traits::AsyncExt;\nuse error_stack::{report, ResultExt};\nuse futures::future::try_join_all;\nuse router_env::{instrument, tracing};\n\nuse super::{MockDb, Store};\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    types::{\n        domain::{\n            self,\n            behaviour::{Conversion, ReverseConversion},\n        },\n        storage,\n    },\n};\n\n#[async_trait::async_trait]\npub trait EventInterface\nwhere\n    domain::Event:\n        Conversion<DstType = storage::events::Event, NewDstType = storage::events::EventNew>,\n{\n    async fn insert_event(\n        &self,\n        event: domain::Event,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    async fn find_event_by_merchant_id_event_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        event_id: &str,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    async fn find_event_by_merchant_id_idempotent_event_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        idempotent_event_id: &str,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    #[allow(clippy::too_many_arguments)]\n    async fn list_initial_events_by_merchant_id_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        created_after: time::PrimitiveDateTime,\n        created_before: time::PrimitiveDateTime,\n        limit: Option<i64>,\n        offset: Option<i64>,\n        event_types: HashSet<common_enums::EventType>,\n        is_delivered: Option<bool>,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::Event>, errors::StorageError>;\n\n    async fn list_events_by_merchant_id_initial_attempt_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n      \n\n... [truncated 59688 chars] ...\n\n       1,\n            \"Expected exactly 1 row in events table when querying by primary_object_id, found {}\",\n            events_by_object_id.len()\n        );\n\n        let first_event = events_by_object_id\n            .first()\n            .ok_or(\"Expected at least one event in the result\")?;\n        let event_id = first_event.event_id.clone();\n        let event_by_event_id = state\n            .store\n            .find_initial_event_by_merchant_id_initial_attempt_id(\n                &business_profile.merchant_id,\n                &event_id,\n                &merchant_key_store,\n            )\n            .await?;\n\n        assert!(\n            event_by_event_id.is_some(),\n            \"Expected to find an event when querying by initial_attempt_id (event_id)\"\n        );\n\n        let found_event = event_by_event_id.unwrap();\n        assert_eq!(\n            first_event.event_id, found_event.event_id,\n            \"Event IDs should match between queries\"\n        );\n        Ok(())\n    }\n}\n", "function_name": "crates__router__src__db__events.rs", "file": "crates__router__src__db__events.rs"}, {"query": "hyperswitch event store encryption merchant key store", "code": "use std::collections::HashSet;\n\nuse common_utils::ext_traits::AsyncExt;\nuse error_stack::{report, ResultExt};\nuse futures::future::try_join_all;\nuse router_env::{instrument, tracing};\n\nuse super::{MockDb, Store};\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    types::{\n        domain::{\n            self,\n            behaviour::{Conversion, ReverseConversion},\n        },\n        storage,\n    },\n};\n\n#[async_trait::async_trait]\npub trait EventInterface\nwhere\n    domain::Event:\n        Conversion<DstType = storage::events::Event, NewDstType = storage::events::EventNew>,\n{\n    async fn insert_event(\n        &self,\n        event: domain::Event,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    async fn find_event_by_merchant_id_event_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        event_id: &str,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    async fn find_event_by_merchant_id_idempotent_event_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        idempotent_event_id: &str,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<domain::Event, errors::StorageError>;\n\n    #[allow(clippy::too_many_arguments)]\n    async fn list_initial_events_by_merchant_id_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        created_after: time::PrimitiveDateTime,\n        created_before: time::PrimitiveDateTime,\n        limit: Option<i64>,\n        offset: Option<i64>,\n        event_types: HashSet<common_enums::EventType>,\n        is_delivered: Option<bool>,\n        merchant_key_store: &domain::MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::Event>, errors::StorageError>;\n\n    async fn list_events_by_merchant_id_initial_attempt_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n      \n\n... [truncated 59688 chars] ...\n\n       1,\n            \"Expected exactly 1 row in events table when querying by primary_object_id, found {}\",\n            events_by_object_id.len()\n        );\n\n        let first_event = events_by_object_id\n            .first()\n            .ok_or(\"Expected at least one event in the result\")?;\n        let event_id = first_event.event_id.clone();\n        let event_by_event_id = state\n            .store\n            .find_initial_event_by_merchant_id_initial_attempt_id(\n                &business_profile.merchant_id,\n                &event_id,\n                &merchant_key_store,\n            )\n            .await?;\n\n        assert!(\n            event_by_event_id.is_some(),\n            \"Expected to find an event when querying by initial_attempt_id (event_id)\"\n        );\n\n        let found_event = event_by_event_id.unwrap();\n        assert_eq!(\n            first_event.event_id, found_event.event_id,\n            \"Event IDs should match between queries\"\n        );\n        Ok(())\n    }\n}\n", "function_name": "crates__router__src__db__events.rs", "file": "crates__router__src__db__events.rs"}, {"query": "Worldline payment gateway integration", "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, PaymentCapture, PaymentSync,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse router_env::logger;\nuse time::{format_description, OffsetDateTime};\nuse transformers as worldline;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(D\n\n... [truncated 31707 chars] ...\n\ne_supported_payment_methods\n    });\n\nstatic WORLDLINE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldline\",\n    description: \"Worldpay is an industry leading payments technology and solutions company with unique capabilities to power omni-commerce across the globe.r\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic WORLDLINE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Worldline {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDLINE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDLINE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDLINE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldline.rs"}, {"query": "hyperswitch worldline connector", "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, PaymentCapture, PaymentSync,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse router_env::logger;\nuse time::{format_description, OffsetDateTime};\nuse transformers as worldline;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(D\n\n... [truncated 31707 chars] ...\n\ne_supported_payment_methods\n    });\n\nstatic WORLDLINE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldline\",\n    description: \"Worldpay is an industry leading payments technology and solutions company with unique capabilities to power omni-commerce across the globe.r\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic WORLDLINE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Worldline {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDLINE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDLINE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDLINE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldline.rs"}, {"query": "how to implement worldline payments", "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, PaymentCapture, PaymentSync,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse router_env::logger;\nuse time::{format_description, OffsetDateTime};\nuse transformers as worldline;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(D\n\n... [truncated 31707 chars] ...\n\ne_supported_payment_methods\n    });\n\nstatic WORLDLINE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldline\",\n    description: \"Worldpay is an industry leading payments technology and solutions company with unique capabilities to power omni-commerce across the globe.r\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic WORLDLINE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Worldline {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDLINE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDLINE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDLINE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldline.rs"}, {"query": "generate worldline authorization token", "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, PaymentCapture, PaymentSync,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse router_env::logger;\nuse time::{format_description, OffsetDateTime};\nuse transformers as worldline;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(D\n\n... [truncated 31707 chars] ...\n\ne_supported_payment_methods\n    });\n\nstatic WORLDLINE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldline\",\n    description: \"Worldpay is an industry leading payments technology and solutions company with unique capabilities to power omni-commerce across the globe.r\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic WORLDLINE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Worldline {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDLINE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDLINE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDLINE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldline.rs"}, {"query": "Forte payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\n\n... [truncated 24956 chars] ...\n\nayment_methods\n});\n\nstatic FORTE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Forte\",\n    description:\n        \"CSG Forte offers a unified payments platform, enabling businesses to securely process credit cards, debit cards, ACH/eCheck transactions, and more, with advanced fraud prevention and seamless integration.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FORTE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Forte {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FORTE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FORTE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FORTE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__forte.rs", "file": "crates__hyperswitch_connectors__src__connectors__forte.rs"}, {"query": "hyperswitch forte connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\n\n... [truncated 24956 chars] ...\n\nayment_methods\n});\n\nstatic FORTE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Forte\",\n    description:\n        \"CSG Forte offers a unified payments platform, enabling businesses to securely process credit cards, debit cards, ACH/eCheck transactions, and more, with advanced fraud prevention and seamless integration.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FORTE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Forte {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FORTE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FORTE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FORTE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__forte.rs", "file": "crates__hyperswitch_connectors__src__connectors__forte.rs"}, {"query": "how to configure Forte in hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\n\n... [truncated 24956 chars] ...\n\nayment_methods\n});\n\nstatic FORTE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Forte\",\n    description:\n        \"CSG Forte offers a unified payments platform, enabling businesses to securely process credit cards, debit cards, ACH/eCheck transactions, and more, with advanced fraud prevention and seamless integration.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FORTE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Forte {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FORTE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FORTE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FORTE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__forte.rs", "file": "crates__hyperswitch_connectors__src__connectors__forte.rs"}, {"query": "forte payment method tokenization", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\n\n... [truncated 24956 chars] ...\n\nayment_methods\n});\n\nstatic FORTE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Forte\",\n    description:\n        \"CSG Forte offers a unified payments platform, enabling businesses to securely process credit cards, debit cards, ACH/eCheck transactions, and more, with advanced fraud prevention and seamless integration.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FORTE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Forte {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FORTE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FORTE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FORTE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__forte.rs", "file": "crates__hyperswitch_connectors__src__connectors__forte.rs"}, {"query": "hyperswitch refund validation logic", "code": "pub mod refunds_transformers;\npub mod refunds_validator;\n\nuse std::{collections::HashSet, marker::PhantomData, str::FromStr};\n\nuse api_models::enums::{Connector, DisputeStage, DisputeStatus};\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutVendorAccountDetails;\nuse common_enums::{IntentStatus, RequestIncrementalAuthorization};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{crypto::Encryptable, pii::Email};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::AsyncExt,\n    types::{ConnectorTransactionIdTrait, MinorUnit},\n};\nuse diesel_models::refund as diesel_refund;\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::types::VaultRouterData;\nuse hyperswitch_domain_models::{\n    merchant_connector_account::MerchantConnectorAccount,\n    payment_address::PaymentAddress,\n    router_data::ErrorResponse,\n    router_data_v2::flow_common_types::VaultConnectorFlowData,\n    router_request_types,\n    types::{OrderDetailsWithAmount, VaultRouterDataV2},\n};\nuse hyperswitch_interfaces::api::ConnectorSpecifications;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeOptionInterface;\nuse masking::Secret;\n#[cfg(feature = \"payouts\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse maud::{html, PreEscaped};\nuse regex::Regex;\nuse router_env::{instrument, tracing};\n\nuse super::payments::helpers;\n#[cfg(feature = \"payouts\")]\nuse super::payouts::{helpers as payout_helpers, PayoutData};\n#[cfg(feature = \"payouts\")]\nuse crate::core::payments;\n#[cfg(feature = \"v2\")]\nuse crate::core::payments::helpers as payment_helpers;\nuse crate::{\n    configs::Settings,\n    consts,\n    core::{\n        errors::{self, RouterResult, StorageErrorExt},\n        payments::PaymentData,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    types::{\n        self, api, domain,\n        storage::{self, enums},\n        PollConfig,\n    },\n    utils::{generate_id, OptionExt, ValueExt},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Default)]\npub struct FeatureConfig {\n  \n\n... [truncated 104648 chars] ...\n\nnnectors\n        .connector_list\n        .clone();\n    list_dispute_supported_connectors.contains(&connector_name)\n}\n\npub fn should_proceed_with_submit_evidence(\n    dispute_stage: DisputeStage,\n    dispute_status: DisputeStatus,\n) -> bool {\n    matches!(\n        dispute_stage,\n        DisputeStage::PreDispute\n            | DisputeStage::Dispute\n            | DisputeStage::PreArbitration\n            | DisputeStage::Arbitration\n    ) && matches!(\n        dispute_status,\n        DisputeStatus::DisputeOpened | DisputeStatus::DisputeChallenged\n    )\n}\n\npub fn should_proceed_with_accept_dispute(\n    dispute_stage: DisputeStage,\n    dispute_status: DisputeStatus,\n) -> bool {\n    matches!(\n        dispute_stage,\n        DisputeStage::PreDispute\n            | DisputeStage::Dispute\n            | DisputeStage::PreArbitration\n            | DisputeStage::Arbitration\n    ) && matches!(\n        dispute_status,\n        DisputeStatus::DisputeChallenged | DisputeStatus::DisputeOpened\n    )\n}\n", "function_name": "crates__router__src__core__utils.rs", "file": "crates__router__src__core__utils.rs"}, {"query": "construct_payout_router_data function", "code": "pub mod refunds_transformers;\npub mod refunds_validator;\n\nuse std::{collections::HashSet, marker::PhantomData, str::FromStr};\n\nuse api_models::enums::{Connector, DisputeStage, DisputeStatus};\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutVendorAccountDetails;\nuse common_enums::{IntentStatus, RequestIncrementalAuthorization};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{crypto::Encryptable, pii::Email};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::AsyncExt,\n    types::{ConnectorTransactionIdTrait, MinorUnit},\n};\nuse diesel_models::refund as diesel_refund;\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::types::VaultRouterData;\nuse hyperswitch_domain_models::{\n    merchant_connector_account::MerchantConnectorAccount,\n    payment_address::PaymentAddress,\n    router_data::ErrorResponse,\n    router_data_v2::flow_common_types::VaultConnectorFlowData,\n    router_request_types,\n    types::{OrderDetailsWithAmount, VaultRouterDataV2},\n};\nuse hyperswitch_interfaces::api::ConnectorSpecifications;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeOptionInterface;\nuse masking::Secret;\n#[cfg(feature = \"payouts\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse maud::{html, PreEscaped};\nuse regex::Regex;\nuse router_env::{instrument, tracing};\n\nuse super::payments::helpers;\n#[cfg(feature = \"payouts\")]\nuse super::payouts::{helpers as payout_helpers, PayoutData};\n#[cfg(feature = \"payouts\")]\nuse crate::core::payments;\n#[cfg(feature = \"v2\")]\nuse crate::core::payments::helpers as payment_helpers;\nuse crate::{\n    configs::Settings,\n    consts,\n    core::{\n        errors::{self, RouterResult, StorageErrorExt},\n        payments::PaymentData,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    types::{\n        self, api, domain,\n        storage::{self, enums},\n        PollConfig,\n    },\n    utils::{generate_id, OptionExt, ValueExt},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Default)]\npub struct FeatureConfig {\n  \n\n... [truncated 104648 chars] ...\n\nnnectors\n        .connector_list\n        .clone();\n    list_dispute_supported_connectors.contains(&connector_name)\n}\n\npub fn should_proceed_with_submit_evidence(\n    dispute_stage: DisputeStage,\n    dispute_status: DisputeStatus,\n) -> bool {\n    matches!(\n        dispute_stage,\n        DisputeStage::PreDispute\n            | DisputeStage::Dispute\n            | DisputeStage::PreArbitration\n            | DisputeStage::Arbitration\n    ) && matches!(\n        dispute_status,\n        DisputeStatus::DisputeOpened | DisputeStatus::DisputeChallenged\n    )\n}\n\npub fn should_proceed_with_accept_dispute(\n    dispute_stage: DisputeStage,\n    dispute_status: DisputeStatus,\n) -> bool {\n    matches!(\n        dispute_stage,\n        DisputeStage::PreDispute\n            | DisputeStage::Dispute\n            | DisputeStage::PreArbitration\n            | DisputeStage::Arbitration\n    ) && matches!(\n        dispute_status,\n        DisputeStatus::DisputeChallenged | DisputeStatus::DisputeOpened\n    )\n}\n", "function_name": "crates__router__src__core__utils.rs", "file": "crates__router__src__core__utils.rs"}, {"query": "how to validate Plusgiro payment method", "code": "pub mod refunds_transformers;\npub mod refunds_validator;\n\nuse std::{collections::HashSet, marker::PhantomData, str::FromStr};\n\nuse api_models::enums::{Connector, DisputeStage, DisputeStatus};\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutVendorAccountDetails;\nuse common_enums::{IntentStatus, RequestIncrementalAuthorization};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{crypto::Encryptable, pii::Email};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::AsyncExt,\n    types::{ConnectorTransactionIdTrait, MinorUnit},\n};\nuse diesel_models::refund as diesel_refund;\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::types::VaultRouterData;\nuse hyperswitch_domain_models::{\n    merchant_connector_account::MerchantConnectorAccount,\n    payment_address::PaymentAddress,\n    router_data::ErrorResponse,\n    router_data_v2::flow_common_types::VaultConnectorFlowData,\n    router_request_types,\n    types::{OrderDetailsWithAmount, VaultRouterDataV2},\n};\nuse hyperswitch_interfaces::api::ConnectorSpecifications;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeOptionInterface;\nuse masking::Secret;\n#[cfg(feature = \"payouts\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse maud::{html, PreEscaped};\nuse regex::Regex;\nuse router_env::{instrument, tracing};\n\nuse super::payments::helpers;\n#[cfg(feature = \"payouts\")]\nuse super::payouts::{helpers as payout_helpers, PayoutData};\n#[cfg(feature = \"payouts\")]\nuse crate::core::payments;\n#[cfg(feature = \"v2\")]\nuse crate::core::payments::helpers as payment_helpers;\nuse crate::{\n    configs::Settings,\n    consts,\n    core::{\n        errors::{self, RouterResult, StorageErrorExt},\n        payments::PaymentData,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    types::{\n        self, api, domain,\n        storage::{self, enums},\n        PollConfig,\n    },\n    utils::{generate_id, OptionExt, ValueExt},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Default)]\npub struct FeatureConfig {\n  \n\n... [truncated 104648 chars] ...\n\nnnectors\n        .connector_list\n        .clone();\n    list_dispute_supported_connectors.contains(&connector_name)\n}\n\npub fn should_proceed_with_submit_evidence(\n    dispute_stage: DisputeStage,\n    dispute_status: DisputeStatus,\n) -> bool {\n    matches!(\n        dispute_stage,\n        DisputeStage::PreDispute\n            | DisputeStage::Dispute\n            | DisputeStage::PreArbitration\n            | DisputeStage::Arbitration\n    ) && matches!(\n        dispute_status,\n        DisputeStatus::DisputeOpened | DisputeStatus::DisputeChallenged\n    )\n}\n\npub fn should_proceed_with_accept_dispute(\n    dispute_stage: DisputeStage,\n    dispute_status: DisputeStatus,\n) -> bool {\n    matches!(\n        dispute_stage,\n        DisputeStage::PreDispute\n            | DisputeStage::Dispute\n            | DisputeStage::PreArbitration\n            | DisputeStage::Arbitration\n    ) && matches!(\n        dispute_status,\n        DisputeStatus::DisputeChallenged | DisputeStatus::DisputeOpened\n    )\n}\n", "function_name": "crates__router__src__core__utils.rs", "file": "crates__router__src__core__utils.rs"}, {"query": "dispute flow utilities hyperswitch", "code": "pub mod refunds_transformers;\npub mod refunds_validator;\n\nuse std::{collections::HashSet, marker::PhantomData, str::FromStr};\n\nuse api_models::enums::{Connector, DisputeStage, DisputeStatus};\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutVendorAccountDetails;\nuse common_enums::{IntentStatus, RequestIncrementalAuthorization};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{crypto::Encryptable, pii::Email};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::AsyncExt,\n    types::{ConnectorTransactionIdTrait, MinorUnit},\n};\nuse diesel_models::refund as diesel_refund;\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::types::VaultRouterData;\nuse hyperswitch_domain_models::{\n    merchant_connector_account::MerchantConnectorAccount,\n    payment_address::PaymentAddress,\n    router_data::ErrorResponse,\n    router_data_v2::flow_common_types::VaultConnectorFlowData,\n    router_request_types,\n    types::{OrderDetailsWithAmount, VaultRouterDataV2},\n};\nuse hyperswitch_interfaces::api::ConnectorSpecifications;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeOptionInterface;\nuse masking::Secret;\n#[cfg(feature = \"payouts\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse maud::{html, PreEscaped};\nuse regex::Regex;\nuse router_env::{instrument, tracing};\n\nuse super::payments::helpers;\n#[cfg(feature = \"payouts\")]\nuse super::payouts::{helpers as payout_helpers, PayoutData};\n#[cfg(feature = \"payouts\")]\nuse crate::core::payments;\n#[cfg(feature = \"v2\")]\nuse crate::core::payments::helpers as payment_helpers;\nuse crate::{\n    configs::Settings,\n    consts,\n    core::{\n        errors::{self, RouterResult, StorageErrorExt},\n        payments::PaymentData,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    types::{\n        self, api, domain,\n        storage::{self, enums},\n        PollConfig,\n    },\n    utils::{generate_id, OptionExt, ValueExt},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Default)]\npub struct FeatureConfig {\n  \n\n... [truncated 104648 chars] ...\n\nnnectors\n        .connector_list\n        .clone();\n    list_dispute_supported_connectors.contains(&connector_name)\n}\n\npub fn should_proceed_with_submit_evidence(\n    dispute_stage: DisputeStage,\n    dispute_status: DisputeStatus,\n) -> bool {\n    matches!(\n        dispute_stage,\n        DisputeStage::PreDispute\n            | DisputeStage::Dispute\n            | DisputeStage::PreArbitration\n            | DisputeStage::Arbitration\n    ) && matches!(\n        dispute_status,\n        DisputeStatus::DisputeOpened | DisputeStatus::DisputeChallenged\n    )\n}\n\npub fn should_proceed_with_accept_dispute(\n    dispute_stage: DisputeStage,\n    dispute_status: DisputeStatus,\n) -> bool {\n    matches!(\n        dispute_stage,\n        DisputeStage::PreDispute\n            | DisputeStage::Dispute\n            | DisputeStage::PreArbitration\n            | DisputeStage::Arbitration\n    ) && matches!(\n        dispute_status,\n        DisputeStatus::DisputeChallenged | DisputeStatus::DisputeOpened\n    )\n}\n", "function_name": "crates__router__src__core__utils.rs", "file": "crates__router__src__core__utils.rs"}, {"query": "how does VGS connector work", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        ExternalVaultInsertFlow, ExternalVaultRetrieveFlow,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData, VaultRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData, VaultResponseData},\n    types::{RefreshTokenRouterData, VaultRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as vgs;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Vgs;\n\nimpl api::Payment for Vgs {}\nimpl api::PaymentSession for Vgs {}\nimpl api::ConnectorAccessToken for Vgs {}\nimpl api::MandateSetup for Vgs {}\nimpl api::PaymentAuthorize for Vgs {}\nimpl api::PaymentSync for Vgs {}\nimpl api::PaymentCapture for Vgs {}\nimpl api::PaymentVoid for Vgs {}\nimpl api::Refund for Vgs {}\nimpl api::RefundExecute for Vgs {}\nimpl api::RefundSync for Vgs {}\nimpl api::PaymentToken for Vgs {}\nimpl api::ExternalVaultInsert for Vgs {}\nimpl api::ExternalVault for Vgs {}\nimpl api::ExternalVaultRetrieve for Vgs {}\n\nimpl ConnectorInte\n\n... [truncated 12880 chars] ...\n\n:async_trait]\nimpl webhooks::IncomingWebhook for Vgs {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Vgs {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__vgs.rs", "file": "crates__hyperswitch_connectors__src__connectors__vgs.rs"}, {"query": "Vgs struct implementation", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        ExternalVaultInsertFlow, ExternalVaultRetrieveFlow,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData, VaultRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData, VaultResponseData},\n    types::{RefreshTokenRouterData, VaultRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as vgs;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Vgs;\n\nimpl api::Payment for Vgs {}\nimpl api::PaymentSession for Vgs {}\nimpl api::ConnectorAccessToken for Vgs {}\nimpl api::MandateSetup for Vgs {}\nimpl api::PaymentAuthorize for Vgs {}\nimpl api::PaymentSync for Vgs {}\nimpl api::PaymentCapture for Vgs {}\nimpl api::PaymentVoid for Vgs {}\nimpl api::Refund for Vgs {}\nimpl api::RefundExecute for Vgs {}\nimpl api::RefundSync for Vgs {}\nimpl api::PaymentToken for Vgs {}\nimpl api::ExternalVaultInsert for Vgs {}\nimpl api::ExternalVault for Vgs {}\nimpl api::ExternalVaultRetrieve for Vgs {}\n\nimpl ConnectorInte\n\n... [truncated 12880 chars] ...\n\n:async_trait]\nimpl webhooks::IncomingWebhook for Vgs {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Vgs {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__vgs.rs", "file": "crates__hyperswitch_connectors__src__connectors__vgs.rs"}, {"query": "how to implement payment connector", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        ExternalVaultInsertFlow, ExternalVaultRetrieveFlow,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData, VaultRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData, VaultResponseData},\n    types::{RefreshTokenRouterData, VaultRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as vgs;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Vgs;\n\nimpl api::Payment for Vgs {}\nimpl api::PaymentSession for Vgs {}\nimpl api::ConnectorAccessToken for Vgs {}\nimpl api::MandateSetup for Vgs {}\nimpl api::PaymentAuthorize for Vgs {}\nimpl api::PaymentSync for Vgs {}\nimpl api::PaymentCapture for Vgs {}\nimpl api::PaymentVoid for Vgs {}\nimpl api::Refund for Vgs {}\nimpl api::RefundExecute for Vgs {}\nimpl api::RefundSync for Vgs {}\nimpl api::PaymentToken for Vgs {}\nimpl api::ExternalVaultInsert for Vgs {}\nimpl api::ExternalVault for Vgs {}\nimpl api::ExternalVaultRetrieve for Vgs {}\n\nimpl ConnectorInte\n\n... [truncated 12880 chars] ...\n\n:async_trait]\nimpl webhooks::IncomingWebhook for Vgs {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Vgs {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__vgs.rs", "file": "crates__hyperswitch_connectors__src__connectors__vgs.rs"}, {"query": "VGS virtual global services integration", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        ExternalVaultInsertFlow, ExternalVaultRetrieveFlow,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData, VaultRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData, VaultResponseData},\n    types::{RefreshTokenRouterData, VaultRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as vgs;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Vgs;\n\nimpl api::Payment for Vgs {}\nimpl api::PaymentSession for Vgs {}\nimpl api::ConnectorAccessToken for Vgs {}\nimpl api::MandateSetup for Vgs {}\nimpl api::PaymentAuthorize for Vgs {}\nimpl api::PaymentSync for Vgs {}\nimpl api::PaymentCapture for Vgs {}\nimpl api::PaymentVoid for Vgs {}\nimpl api::Refund for Vgs {}\nimpl api::RefundExecute for Vgs {}\nimpl api::RefundSync for Vgs {}\nimpl api::PaymentToken for Vgs {}\nimpl api::ExternalVaultInsert for Vgs {}\nimpl api::ExternalVault for Vgs {}\nimpl api::ExternalVaultRetrieve for Vgs {}\n\nimpl ConnectorInte\n\n... [truncated 12880 chars] ...\n\n:async_trait]\nimpl webhooks::IncomingWebhook for Vgs {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Vgs {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__vgs.rs", "file": "crates__hyperswitch_connectors__src__connectors__vgs.rs"}, {"query": "Fiserv payment request transformer", "code": "use api_models::payments::{\n    ApplePayCombinedMetadata, ApplepayCombinedSessionTokenData, ApplepaySessionTokenData,\n    ApplepaySessionTokenMetadata,\n};\nuse base64::Engine;\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    consts::BASE64_ENGINE, ext_traits::ValueExt, pii, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{ser::Serializer, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData as _, PaymentsCancelRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct FiservRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for FiservRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from((amount, router_data): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data,\n        })\n    }\n}\n\nimpl Serialize for FiservCheckoutChargesRequest {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Checkout(inner) => inner.serialize(serializer),\n            Self::Charges(inner) => inner.serialize(serializer),\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct FiservPaymentsRequest {\n    amount: Amount,\n    merchant_details: MerchantDetails,\n    #[serde(flatten)]\n    checkout_charges_request: FiservCheckoutCharge\n\n... [truncated 47874 chars] ...\n\nHandlingFailed)?;\n        let transaction_id = match gateway_resp {\n            FiservPaymentsResponse::Charges(res) => {\n                &res.gateway_response\n                    .transaction_processing_details\n                    .transaction_id\n            }\n            FiservPaymentsResponse::Checkout(res) => {\n                &res.gateway_response\n                    .transaction_processing_details\n                    .transaction_id\n            }\n        };\n\n        let transaction_state = match gateway_resp {\n            FiservPaymentsResponse::Charges(res) => &res.gateway_response.transaction_state,\n            FiservPaymentsResponse::Checkout(res) => &res.gateway_response.transaction_state,\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: transaction_id.clone(),\n                refund_status: enums::RefundStatus::from(transaction_state.clone()),\n            }),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiserv__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiserv__transformers.rs"}, {"query": "how to map router data to Fiserv API", "code": "use api_models::payments::{\n    ApplePayCombinedMetadata, ApplepayCombinedSessionTokenData, ApplepaySessionTokenData,\n    ApplepaySessionTokenMetadata,\n};\nuse base64::Engine;\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    consts::BASE64_ENGINE, ext_traits::ValueExt, pii, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{ser::Serializer, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData as _, PaymentsCancelRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct FiservRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for FiservRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from((amount, router_data): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data,\n        })\n    }\n}\n\nimpl Serialize for FiservCheckoutChargesRequest {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Checkout(inner) => inner.serialize(serializer),\n            Self::Charges(inner) => inner.serialize(serializer),\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct FiservPaymentsRequest {\n    amount: Amount,\n    merchant_details: MerchantDetails,\n    #[serde(flatten)]\n    checkout_charges_request: FiservCheckoutCharge\n\n... [truncated 47874 chars] ...\n\nHandlingFailed)?;\n        let transaction_id = match gateway_resp {\n            FiservPaymentsResponse::Charges(res) => {\n                &res.gateway_response\n                    .transaction_processing_details\n                    .transaction_id\n            }\n            FiservPaymentsResponse::Checkout(res) => {\n                &res.gateway_response\n                    .transaction_processing_details\n                    .transaction_id\n            }\n        };\n\n        let transaction_state = match gateway_resp {\n            FiservPaymentsResponse::Charges(res) => &res.gateway_response.transaction_state,\n            FiservPaymentsResponse::Checkout(res) => &res.gateway_response.transaction_state,\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: transaction_id.clone(),\n                refund_status: enums::RefundStatus::from(transaction_state.clone()),\n            }),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiserv__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiserv__transformers.rs"}, {"query": "Fiserv refund response handling", "code": "use api_models::payments::{\n    ApplePayCombinedMetadata, ApplepayCombinedSessionTokenData, ApplepaySessionTokenData,\n    ApplepaySessionTokenMetadata,\n};\nuse base64::Engine;\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    consts::BASE64_ENGINE, ext_traits::ValueExt, pii, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{ser::Serializer, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData as _, PaymentsCancelRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct FiservRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for FiservRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from((amount, router_data): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data,\n        })\n    }\n}\n\nimpl Serialize for FiservCheckoutChargesRequest {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Checkout(inner) => inner.serialize(serializer),\n            Self::Charges(inner) => inner.serialize(serializer),\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct FiservPaymentsRequest {\n    amount: Amount,\n    merchant_details: MerchantDetails,\n    #[serde(flatten)]\n    checkout_charges_request: FiservCheckoutCharge\n\n... [truncated 47874 chars] ...\n\nHandlingFailed)?;\n        let transaction_id = match gateway_resp {\n            FiservPaymentsResponse::Charges(res) => {\n                &res.gateway_response\n                    .transaction_processing_details\n                    .transaction_id\n            }\n            FiservPaymentsResponse::Checkout(res) => {\n                &res.gateway_response\n                    .transaction_processing_details\n                    .transaction_id\n            }\n        };\n\n        let transaction_state = match gateway_resp {\n            FiservPaymentsResponse::Charges(res) => &res.gateway_response.transaction_state,\n            FiservPaymentsResponse::Checkout(res) => &res.gateway_response.transaction_state,\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: transaction_id.clone(),\n                refund_status: enums::RefundStatus::from(transaction_state.clone()),\n            }),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiserv__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiserv__transformers.rs"}, {"query": "FiservPaymentsRequest struct definition", "code": "use api_models::payments::{\n    ApplePayCombinedMetadata, ApplepayCombinedSessionTokenData, ApplepaySessionTokenData,\n    ApplepaySessionTokenMetadata,\n};\nuse base64::Engine;\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    consts::BASE64_ENGINE, ext_traits::ValueExt, pii, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{ser::Serializer, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData as _, PaymentsCancelRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct FiservRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for FiservRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from((amount, router_data): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data,\n        })\n    }\n}\n\nimpl Serialize for FiservCheckoutChargesRequest {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Checkout(inner) => inner.serialize(serializer),\n            Self::Charges(inner) => inner.serialize(serializer),\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct FiservPaymentsRequest {\n    amount: Amount,\n    merchant_details: MerchantDetails,\n    #[serde(flatten)]\n    checkout_charges_request: FiservCheckoutCharge\n\n... [truncated 47874 chars] ...\n\nHandlingFailed)?;\n        let transaction_id = match gateway_resp {\n            FiservPaymentsResponse::Charges(res) => {\n                &res.gateway_response\n                    .transaction_processing_details\n                    .transaction_id\n            }\n            FiservPaymentsResponse::Checkout(res) => {\n                &res.gateway_response\n                    .transaction_processing_details\n                    .transaction_id\n            }\n        };\n\n        let transaction_state = match gateway_resp {\n            FiservPaymentsResponse::Charges(res) => &res.gateway_response.transaction_state,\n            FiservPaymentsResponse::Checkout(res) => &res.gateway_response.transaction_state,\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: transaction_id.clone(),\n                refund_status: enums::RefundStatus::from(transaction_state.clone()),\n            }),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiserv__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiserv__transformers.rs"}, {"query": "hyperswitch split payments configuration", "code": "//! Payment related types\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    date_time, errors, events, ext_traits::OptionExt, impl_to_sql_from_sql_json, pii,\n    types::MinorUnit,\n};\nuse diesel::{\n    sql_types::{Jsonb, Text},\n    AsExpression, FromSqlRow,\n};\nuse error_stack::{Report, Result, ResultExt};\nuse euclid::frontend::{\n    ast::Program,\n    dir::{DirKeyKind, EuclidDirFilter},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse smithy::SmithyModel;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::domain::{AdyenSplitData, XenditSplitSubMerchantData};\n#[derive(\n    Serialize,\n    Deserialize,\n    Debug,\n    Clone,\n    PartialEq,\n    Eq,\n    FromSqlRow,\n    AsExpression,\n    ToSchema,\n    SmithyModel,\n)]\n#[diesel(sql_type = Jsonb)]\n#[serde(rename_all = \"snake_case\")]\n#[serde(deny_unknown_fields)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\n/// Fee information for Split Payments to be charged on the payment being collected\npub enum SplitPaymentsRequest {\n    /// StripeSplitPayment\n    #[smithy(value_type = \"StripeSplitPaymentRequest\")]\n    StripeSplitPayment(StripeSplitPaymentRequest),\n    /// AdyenSplitPayment\n    #[smithy(value_type = \"AdyenSplitData\")]\n    AdyenSplitPayment(AdyenSplitData),\n    /// XenditSplitPayment\n    #[smithy(value_type = \"XenditSplitRequest\")]\n    XenditSplitPayment(XenditSplitRequest),\n}\nimpl_to_sql_from_sql_json!(SplitPaymentsRequest);\n\n#[derive(\n    Serialize,\n    Deserialize,\n    Debug,\n    Clone,\n    PartialEq,\n    Eq,\n    FromSqlRow,\n    AsExpression,\n    ToSchema,\n    SmithyModel,\n)]\n#[diesel(sql_type = Jsonb)]\n#[serde(deny_unknown_fields)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\n/// Fee information for Split Payments to be charged on the payment being collected for Stripe\npub struct StripeSplitPaymentRequest {\n    /// Stripe's charge type\n    #[schema(value_type = PaymentChargeType, example = \"direct\")]\n    #[smithy(value_ty\n\n... [truncated 38942 chars] ...\n\n,\n\n    /// The card holder's name\n    #[schema(value_type = String, example = \"John Test\")]\n    #[smithy(value_type = \"Option<String>\")]\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    #[schema(value_type = String)]\n    #[smithy(value_type = \"String\")]\n    pub network_transaction_id: Secret<String>,\n\n    /// ECI indicator of the card\n    pub eci: Option<String>,\n\n    /// Source of the token\n    #[schema(value_type = Option<TokenSource>, example = \"googlepay\")]\n    pub token_source: Option<TokenSource>,\n}\n\n#[derive(\n    Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema, PartialEq, Eq, SmithyModel,\n)]\n#[schema(example = \"google_pay, apple_pay\")]\n#[serde(rename_all = \"snake_case\")]\n/// Source of the token\npub enum TokenSource {\n    /// Google Pay\n    GooglePay,\n    /// Apple Pay\n    ApplePay,\n}\n", "function_name": "crates__common_types__src__payments.rs", "file": "crates__common_types__src__payments.rs"}, {"query": "SplitPaymentsRequest enum", "code": "//! Payment related types\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    date_time, errors, events, ext_traits::OptionExt, impl_to_sql_from_sql_json, pii,\n    types::MinorUnit,\n};\nuse diesel::{\n    sql_types::{Jsonb, Text},\n    AsExpression, FromSqlRow,\n};\nuse error_stack::{Report, Result, ResultExt};\nuse euclid::frontend::{\n    ast::Program,\n    dir::{DirKeyKind, EuclidDirFilter},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse smithy::SmithyModel;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::domain::{AdyenSplitData, XenditSplitSubMerchantData};\n#[derive(\n    Serialize,\n    Deserialize,\n    Debug,\n    Clone,\n    PartialEq,\n    Eq,\n    FromSqlRow,\n    AsExpression,\n    ToSchema,\n    SmithyModel,\n)]\n#[diesel(sql_type = Jsonb)]\n#[serde(rename_all = \"snake_case\")]\n#[serde(deny_unknown_fields)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\n/// Fee information for Split Payments to be charged on the payment being collected\npub enum SplitPaymentsRequest {\n    /// StripeSplitPayment\n    #[smithy(value_type = \"StripeSplitPaymentRequest\")]\n    StripeSplitPayment(StripeSplitPaymentRequest),\n    /// AdyenSplitPayment\n    #[smithy(value_type = \"AdyenSplitData\")]\n    AdyenSplitPayment(AdyenSplitData),\n    /// XenditSplitPayment\n    #[smithy(value_type = \"XenditSplitRequest\")]\n    XenditSplitPayment(XenditSplitRequest),\n}\nimpl_to_sql_from_sql_json!(SplitPaymentsRequest);\n\n#[derive(\n    Serialize,\n    Deserialize,\n    Debug,\n    Clone,\n    PartialEq,\n    Eq,\n    FromSqlRow,\n    AsExpression,\n    ToSchema,\n    SmithyModel,\n)]\n#[diesel(sql_type = Jsonb)]\n#[serde(deny_unknown_fields)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\n/// Fee information for Split Payments to be charged on the payment being collected for Stripe\npub struct StripeSplitPaymentRequest {\n    /// Stripe's charge type\n    #[schema(value_type = PaymentChargeType, example = \"direct\")]\n    #[smithy(value_ty\n\n... [truncated 38942 chars] ...\n\n,\n\n    /// The card holder's name\n    #[schema(value_type = String, example = \"John Test\")]\n    #[smithy(value_type = \"Option<String>\")]\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    #[schema(value_type = String)]\n    #[smithy(value_type = \"String\")]\n    pub network_transaction_id: Secret<String>,\n\n    /// ECI indicator of the card\n    pub eci: Option<String>,\n\n    /// Source of the token\n    #[schema(value_type = Option<TokenSource>, example = \"googlepay\")]\n    pub token_source: Option<TokenSource>,\n}\n\n#[derive(\n    Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema, PartialEq, Eq, SmithyModel,\n)]\n#[schema(example = \"google_pay, apple_pay\")]\n#[serde(rename_all = \"snake_case\")]\n/// Source of the token\npub enum TokenSource {\n    /// Google Pay\n    GooglePay,\n    /// Apple Pay\n    ApplePay,\n}\n", "function_name": "crates__common_types__src__payments.rs", "file": "crates__common_types__src__payments.rs"}, {"query": "how to configure stripe split payments", "code": "//! Payment related types\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    date_time, errors, events, ext_traits::OptionExt, impl_to_sql_from_sql_json, pii,\n    types::MinorUnit,\n};\nuse diesel::{\n    sql_types::{Jsonb, Text},\n    AsExpression, FromSqlRow,\n};\nuse error_stack::{Report, Result, ResultExt};\nuse euclid::frontend::{\n    ast::Program,\n    dir::{DirKeyKind, EuclidDirFilter},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse smithy::SmithyModel;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::domain::{AdyenSplitData, XenditSplitSubMerchantData};\n#[derive(\n    Serialize,\n    Deserialize,\n    Debug,\n    Clone,\n    PartialEq,\n    Eq,\n    FromSqlRow,\n    AsExpression,\n    ToSchema,\n    SmithyModel,\n)]\n#[diesel(sql_type = Jsonb)]\n#[serde(rename_all = \"snake_case\")]\n#[serde(deny_unknown_fields)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\n/// Fee information for Split Payments to be charged on the payment being collected\npub enum SplitPaymentsRequest {\n    /// StripeSplitPayment\n    #[smithy(value_type = \"StripeSplitPaymentRequest\")]\n    StripeSplitPayment(StripeSplitPaymentRequest),\n    /// AdyenSplitPayment\n    #[smithy(value_type = \"AdyenSplitData\")]\n    AdyenSplitPayment(AdyenSplitData),\n    /// XenditSplitPayment\n    #[smithy(value_type = \"XenditSplitRequest\")]\n    XenditSplitPayment(XenditSplitRequest),\n}\nimpl_to_sql_from_sql_json!(SplitPaymentsRequest);\n\n#[derive(\n    Serialize,\n    Deserialize,\n    Debug,\n    Clone,\n    PartialEq,\n    Eq,\n    FromSqlRow,\n    AsExpression,\n    ToSchema,\n    SmithyModel,\n)]\n#[diesel(sql_type = Jsonb)]\n#[serde(deny_unknown_fields)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\n/// Fee information for Split Payments to be charged on the payment being collected for Stripe\npub struct StripeSplitPaymentRequest {\n    /// Stripe's charge type\n    #[schema(value_type = PaymentChargeType, example = \"direct\")]\n    #[smithy(value_ty\n\n... [truncated 38942 chars] ...\n\n,\n\n    /// The card holder's name\n    #[schema(value_type = String, example = \"John Test\")]\n    #[smithy(value_type = \"Option<String>\")]\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    #[schema(value_type = String)]\n    #[smithy(value_type = \"String\")]\n    pub network_transaction_id: Secret<String>,\n\n    /// ECI indicator of the card\n    pub eci: Option<String>,\n\n    /// Source of the token\n    #[schema(value_type = Option<TokenSource>, example = \"googlepay\")]\n    pub token_source: Option<TokenSource>,\n}\n\n#[derive(\n    Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema, PartialEq, Eq, SmithyModel,\n)]\n#[schema(example = \"google_pay, apple_pay\")]\n#[serde(rename_all = \"snake_case\")]\n/// Source of the token\npub enum TokenSource {\n    /// Google Pay\n    GooglePay,\n    /// Apple Pay\n    ApplePay,\n}\n", "function_name": "crates__common_types__src__payments.rs", "file": "crates__common_types__src__payments.rs"}, {"query": "payment orchestration types hyperswitch", "code": "//! Payment related types\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    date_time, errors, events, ext_traits::OptionExt, impl_to_sql_from_sql_json, pii,\n    types::MinorUnit,\n};\nuse diesel::{\n    sql_types::{Jsonb, Text},\n    AsExpression, FromSqlRow,\n};\nuse error_stack::{Report, Result, ResultExt};\nuse euclid::frontend::{\n    ast::Program,\n    dir::{DirKeyKind, EuclidDirFilter},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse smithy::SmithyModel;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::domain::{AdyenSplitData, XenditSplitSubMerchantData};\n#[derive(\n    Serialize,\n    Deserialize,\n    Debug,\n    Clone,\n    PartialEq,\n    Eq,\n    FromSqlRow,\n    AsExpression,\n    ToSchema,\n    SmithyModel,\n)]\n#[diesel(sql_type = Jsonb)]\n#[serde(rename_all = \"snake_case\")]\n#[serde(deny_unknown_fields)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\n/// Fee information for Split Payments to be charged on the payment being collected\npub enum SplitPaymentsRequest {\n    /// StripeSplitPayment\n    #[smithy(value_type = \"StripeSplitPaymentRequest\")]\n    StripeSplitPayment(StripeSplitPaymentRequest),\n    /// AdyenSplitPayment\n    #[smithy(value_type = \"AdyenSplitData\")]\n    AdyenSplitPayment(AdyenSplitData),\n    /// XenditSplitPayment\n    #[smithy(value_type = \"XenditSplitRequest\")]\n    XenditSplitPayment(XenditSplitRequest),\n}\nimpl_to_sql_from_sql_json!(SplitPaymentsRequest);\n\n#[derive(\n    Serialize,\n    Deserialize,\n    Debug,\n    Clone,\n    PartialEq,\n    Eq,\n    FromSqlRow,\n    AsExpression,\n    ToSchema,\n    SmithyModel,\n)]\n#[diesel(sql_type = Jsonb)]\n#[serde(deny_unknown_fields)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\n/// Fee information for Split Payments to be charged on the payment being collected for Stripe\npub struct StripeSplitPaymentRequest {\n    /// Stripe's charge type\n    #[schema(value_type = PaymentChargeType, example = \"direct\")]\n    #[smithy(value_ty\n\n... [truncated 38942 chars] ...\n\n,\n\n    /// The card holder's name\n    #[schema(value_type = String, example = \"John Test\")]\n    #[smithy(value_type = \"Option<String>\")]\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    #[schema(value_type = String)]\n    #[smithy(value_type = \"String\")]\n    pub network_transaction_id: Secret<String>,\n\n    /// ECI indicator of the card\n    pub eci: Option<String>,\n\n    /// Source of the token\n    #[schema(value_type = Option<TokenSource>, example = \"googlepay\")]\n    pub token_source: Option<TokenSource>,\n}\n\n#[derive(\n    Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema, PartialEq, Eq, SmithyModel,\n)]\n#[schema(example = \"google_pay, apple_pay\")]\n#[serde(rename_all = \"snake_case\")]\n/// Source of the token\npub enum TokenSource {\n    /// Google Pay\n    GooglePay,\n    /// Apple Pay\n    ApplePay,\n}\n", "function_name": "crates__common_types__src__payments.rs", "file": "crates__common_types__src__payments.rs"}, {"query": "how to integrate Shift4 payment connector", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    pii::{self, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, Card as CardData, CryptoData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, to_connector_meta, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait Shift4AuthorizePreprocessingCommon {\n    fn is_automatic_capture(&self) -> Result<bool, Error>;\n    fn get_router_return_url(&self) -> Option<String>;\n    fn get_email_optional(&self) -> Option<pii::Email>;\n    fn get_complete_authorize_url(&self) -> Option<String>;\n    fn get_currency_required(&self) -> Result<enums::Currency, Error>;\n    fn get_metadata(&self) -> Result<Option<serde_json::Value>, Error>;\n    fn get_payment_method_data_required(&self) -> Result<PaymentMethodData, Error>;\n}\n\npub struct Shift\n\n... [truncated 38660 chars] ...\n\n    event,\n        Shift4WebhookEvent::ChargeCaptured\n            | Shift4WebhookEvent::ChargeFailed\n            | Shift4WebhookEvent::ChargeSucceeded\n            | Shift4WebhookEvent::ChargeUpdated\n    )\n}\n\npub fn is_refund_event(event: &Shift4WebhookEvent) -> bool {\n    matches!(event, Shift4WebhookEvent::ChargeRefunded)\n}\n\nimpl From<Shift4WebhookEvent> for IncomingWebhookEvent {\n    fn from(event: Shift4WebhookEvent) -> Self {\n        match event {\n            Shift4WebhookEvent::ChargeSucceeded | Shift4WebhookEvent::ChargeUpdated => {\n                //reference : https://dev.shift4.com/docs/api#event-types\n                Self::PaymentIntentProcessing\n            }\n            Shift4WebhookEvent::ChargeCaptured => Self::PaymentIntentSuccess,\n            Shift4WebhookEvent::ChargeFailed => Self::PaymentIntentFailure,\n            Shift4WebhookEvent::ChargeRefunded => Self::RefundSuccess,\n            Shift4WebhookEvent::Unknown => Self::EventNotSupported,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs"}, {"query": "Shift4RouterData struct definition", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    pii::{self, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, Card as CardData, CryptoData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, to_connector_meta, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait Shift4AuthorizePreprocessingCommon {\n    fn is_automatic_capture(&self) -> Result<bool, Error>;\n    fn get_router_return_url(&self) -> Option<String>;\n    fn get_email_optional(&self) -> Option<pii::Email>;\n    fn get_complete_authorize_url(&self) -> Option<String>;\n    fn get_currency_required(&self) -> Result<enums::Currency, Error>;\n    fn get_metadata(&self) -> Result<Option<serde_json::Value>, Error>;\n    fn get_payment_method_data_required(&self) -> Result<PaymentMethodData, Error>;\n}\n\npub struct Shift\n\n... [truncated 38660 chars] ...\n\n    event,\n        Shift4WebhookEvent::ChargeCaptured\n            | Shift4WebhookEvent::ChargeFailed\n            | Shift4WebhookEvent::ChargeSucceeded\n            | Shift4WebhookEvent::ChargeUpdated\n    )\n}\n\npub fn is_refund_event(event: &Shift4WebhookEvent) -> bool {\n    matches!(event, Shift4WebhookEvent::ChargeRefunded)\n}\n\nimpl From<Shift4WebhookEvent> for IncomingWebhookEvent {\n    fn from(event: Shift4WebhookEvent) -> Self {\n        match event {\n            Shift4WebhookEvent::ChargeSucceeded | Shift4WebhookEvent::ChargeUpdated => {\n                //reference : https://dev.shift4.com/docs/api#event-types\n                Self::PaymentIntentProcessing\n            }\n            Shift4WebhookEvent::ChargeCaptured => Self::PaymentIntentSuccess,\n            Shift4WebhookEvent::ChargeFailed => Self::PaymentIntentFailure,\n            Shift4WebhookEvent::ChargeRefunded => Self::RefundSuccess,\n            Shift4WebhookEvent::Unknown => Self::EventNotSupported,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs"}, {"query": "implement Shift4 webhook handler", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    pii::{self, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, Card as CardData, CryptoData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, to_connector_meta, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait Shift4AuthorizePreprocessingCommon {\n    fn is_automatic_capture(&self) -> Result<bool, Error>;\n    fn get_router_return_url(&self) -> Option<String>;\n    fn get_email_optional(&self) -> Option<pii::Email>;\n    fn get_complete_authorize_url(&self) -> Option<String>;\n    fn get_currency_required(&self) -> Result<enums::Currency, Error>;\n    fn get_metadata(&self) -> Result<Option<serde_json::Value>, Error>;\n    fn get_payment_method_data_required(&self) -> Result<PaymentMethodData, Error>;\n}\n\npub struct Shift\n\n... [truncated 38660 chars] ...\n\n    event,\n        Shift4WebhookEvent::ChargeCaptured\n            | Shift4WebhookEvent::ChargeFailed\n            | Shift4WebhookEvent::ChargeSucceeded\n            | Shift4WebhookEvent::ChargeUpdated\n    )\n}\n\npub fn is_refund_event(event: &Shift4WebhookEvent) -> bool {\n    matches!(event, Shift4WebhookEvent::ChargeRefunded)\n}\n\nimpl From<Shift4WebhookEvent> for IncomingWebhookEvent {\n    fn from(event: Shift4WebhookEvent) -> Self {\n        match event {\n            Shift4WebhookEvent::ChargeSucceeded | Shift4WebhookEvent::ChargeUpdated => {\n                //reference : https://dev.shift4.com/docs/api#event-types\n                Self::PaymentIntentProcessing\n            }\n            Shift4WebhookEvent::ChargeCaptured => Self::PaymentIntentSuccess,\n            Shift4WebhookEvent::ChargeFailed => Self::PaymentIntentFailure,\n            Shift4WebhookEvent::ChargeRefunded => Self::RefundSuccess,\n            Shift4WebhookEvent::Unknown => Self::EventNotSupported,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs"}, {"query": "Shift4 payment authorization transformation", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    pii::{self, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, Card as CardData, CryptoData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, to_connector_meta, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait Shift4AuthorizePreprocessingCommon {\n    fn is_automatic_capture(&self) -> Result<bool, Error>;\n    fn get_router_return_url(&self) -> Option<String>;\n    fn get_email_optional(&self) -> Option<pii::Email>;\n    fn get_complete_authorize_url(&self) -> Option<String>;\n    fn get_currency_required(&self) -> Result<enums::Currency, Error>;\n    fn get_metadata(&self) -> Result<Option<serde_json::Value>, Error>;\n    fn get_payment_method_data_required(&self) -> Result<PaymentMethodData, Error>;\n}\n\npub struct Shift\n\n... [truncated 38660 chars] ...\n\n    event,\n        Shift4WebhookEvent::ChargeCaptured\n            | Shift4WebhookEvent::ChargeFailed\n            | Shift4WebhookEvent::ChargeSucceeded\n            | Shift4WebhookEvent::ChargeUpdated\n    )\n}\n\npub fn is_refund_event(event: &Shift4WebhookEvent) -> bool {\n    matches!(event, Shift4WebhookEvent::ChargeRefunded)\n}\n\nimpl From<Shift4WebhookEvent> for IncomingWebhookEvent {\n    fn from(event: Shift4WebhookEvent) -> Self {\n        match event {\n            Shift4WebhookEvent::ChargeSucceeded | Shift4WebhookEvent::ChargeUpdated => {\n                //reference : https://dev.shift4.com/docs/api#event-types\n                Self::PaymentIntentProcessing\n            }\n            Shift4WebhookEvent::ChargeCaptured => Self::PaymentIntentSuccess,\n            Shift4WebhookEvent::ChargeFailed => Self::PaymentIntentFailure,\n            Shift4WebhookEvent::ChargeRefunded => Self::RefundSuccess,\n            Shift4WebhookEvent::Unknown => Self::EventNotSupported,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs"}, {"query": "Hipay payment gateway integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{self as common_errors, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse reqwest::multipart::Form;\nuse serde::Serialize;\nuse serde_json::Value;\nuse transformers as hipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub fn build_form_from_struct<T: Serialize + Send + 'static>(\n\n\n... [truncated 27125 chars] ...\n\ns: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    hipay_supported_payment_methods\n});\n\nstatic HIPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Hipay\",\n    description: \"HiPay is an independent global payment service provider that is based in France.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic HIPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Hipay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&HIPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*HIPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&HIPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__hipay.rs", "file": "crates__hyperswitch_connectors__src__connectors__hipay.rs"}, {"query": "HipayAuthorize function implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{self as common_errors, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse reqwest::multipart::Form;\nuse serde::Serialize;\nuse serde_json::Value;\nuse transformers as hipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub fn build_form_from_struct<T: Serialize + Send + 'static>(\n\n\n... [truncated 27125 chars] ...\n\ns: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    hipay_supported_payment_methods\n});\n\nstatic HIPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Hipay\",\n    description: \"HiPay is an independent global payment service provider that is based in France.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic HIPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Hipay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&HIPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*HIPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&HIPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__hipay.rs", "file": "crates__hyperswitch_connectors__src__connectors__hipay.rs"}, {"query": "how to add a new payment gateway connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{self as common_errors, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse reqwest::multipart::Form;\nuse serde::Serialize;\nuse serde_json::Value;\nuse transformers as hipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub fn build_form_from_struct<T: Serialize + Send + 'static>(\n\n\n... [truncated 27125 chars] ...\n\ns: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    hipay_supported_payment_methods\n});\n\nstatic HIPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Hipay\",\n    description: \"HiPay is an independent global payment service provider that is based in France.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic HIPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Hipay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&HIPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*HIPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&HIPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__hipay.rs", "file": "crates__hyperswitch_connectors__src__connectors__hipay.rs"}, {"query": "Hipay refund processing", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{self as common_errors, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse reqwest::multipart::Form;\nuse serde::Serialize;\nuse serde_json::Value;\nuse transformers as hipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub fn build_form_from_struct<T: Serialize + Send + 'static>(\n\n\n... [truncated 27125 chars] ...\n\ns: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    hipay_supported_payment_methods\n});\n\nstatic HIPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Hipay\",\n    description: \"HiPay is an independent global payment service provider that is based in France.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic HIPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Hipay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&HIPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*HIPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&HIPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__hipay.rs", "file": "crates__hyperswitch_connectors__src__connectors__hipay.rs"}, {"query": "hyperswitch payme connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateOrder, InitPayment, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentsPreProcessing,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::Conn\n\n... [truncated 50835 chars] ...\n\ntes,\n];\n\nimpl ConnectorSpecifications for Payme {\n    fn is_order_create_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type: _,\n                request_data,\n            } => matches!(\n                &request_data.payment_method_data,\n                PaymentMethodData::Card(_) | PaymentMethodData::Wallet(_)\n            ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYME_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYME_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYME_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payme.rs", "file": "crates__hyperswitch_connectors__src__connectors__payme.rs"}, {"query": "Payme struct definition", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateOrder, InitPayment, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentsPreProcessing,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::Conn\n\n... [truncated 50835 chars] ...\n\ntes,\n];\n\nimpl ConnectorSpecifications for Payme {\n    fn is_order_create_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type: _,\n                request_data,\n            } => matches!(\n                &request_data.payment_method_data,\n                PaymentMethodData::Card(_) | PaymentMethodData::Wallet(_)\n            ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYME_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYME_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYME_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payme.rs", "file": "crates__hyperswitch_connectors__src__connectors__payme.rs"}, {"query": "how to add new payment gateway connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateOrder, InitPayment, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentsPreProcessing,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::Conn\n\n... [truncated 50835 chars] ...\n\ntes,\n];\n\nimpl ConnectorSpecifications for Payme {\n    fn is_order_create_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type: _,\n                request_data,\n            } => matches!(\n                &request_data.payment_method_data,\n                PaymentMethodData::Card(_) | PaymentMethodData::Wallet(_)\n            ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYME_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYME_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYME_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payme.rs", "file": "crates__hyperswitch_connectors__src__connectors__payme.rs"}, {"query": "Payme payment method configuration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateOrder, InitPayment, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentsPreProcessing,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::Conn\n\n... [truncated 50835 chars] ...\n\ntes,\n];\n\nimpl ConnectorSpecifications for Payme {\n    fn is_order_create_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type: _,\n                request_data,\n            } => matches!(\n                &request_data.payment_method_data,\n                PaymentMethodData::Card(_) | PaymentMethodData::Wallet(_)\n            ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYME_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYME_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYME_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payme.rs", "file": "crates__hyperswitch_connectors__src__connectors__payme.rs"}, {"query": "hyperswitch Conn trait implementation", "code": "//! API interface\n\n/// authentication module\npub mod authentication;\n/// authentication_v2 module\npub mod authentication_v2;\npub mod disputes;\npub mod disputes_v2;\npub mod files;\npub mod files_v2;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\n#[cfg(feature = \"frm\")]\npub mod fraud_check_v2;\npub mod gateway;\npub mod merchant_connector_webhook_management;\npub mod merchant_connector_webhook_management_v2;\npub mod payments;\npub mod payments_v2;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\n#[cfg(feature = \"payouts\")]\npub mod payouts_v2;\npub mod refunds;\npub mod refunds_v2;\npub mod revenue_recovery;\npub mod revenue_recovery_v2;\npub mod subscriptions;\npub mod subscriptions_v2;\npub mod vault;\npub mod vault_v2;\n\nuse std::fmt::Debug;\n\nuse common_enums::{\n    enums::{\n        self, CallConnectorAction, CaptureMethod, EventClass, PaymentAction, PaymentMethodType,\n    },\n    PaymentMethod,\n};\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    connector_endpoints::Connectors,\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{\n        AccessToken, AccessTokenAuthenticationResponse, ConnectorAuthType, ErrorResponse,\n        RouterData,\n    },\n    router_data_v2::{\n        flow_common_types::{\n            AuthenticationTokenFlowData, ConnectorWebhookConfigurationFlowData,\n            WebhookSourceVerifyData,\n        },\n        AccessTokenFlowData, MandateRevokeFlowData, UasFlowData,\n    },\n    router_flow_types::{\n        mandate_revoke::MandateRevoke,\n        merchant_connector_webhook_management::ConnectorWebhookRegister, AccessTokenAuth,\n        AccessTokenAuthentication, Authenticate, AuthenticationConfirmation, PostAuthenticate,\n        PreAuthenticate, ProcessIncomingWebhook, VerifyWebhookSource,\n    },\n    router_request_types::{\n        self,\n        merchant_connector_webhook_management::ConnectorWebhookRegisterRequ\n\n... [truncated 29458 chars] ...\n\net_payment_method_type(&self) -> Option<PaymentMethodType>;\n    /// Get the merchant id from RouterData\n    fn get_merchant_id(&self) -> common_utils::id_type::MerchantId;\n}\n\nimpl<F, Req, Res> AccessTokenData for RouterData<F, Req, Res> {\n    fn get_payment_method_type(&self) -> Option<PaymentMethodType> {\n        self.payment_method_type\n    }\n    fn get_merchant_id(&self) -> common_utils::id_type::MerchantId {\n        self.merchant_id.clone()\n    }\n}\n\n/// Trait ConnectorAccessTokenSuffix\npub trait ConnectorAccessTokenSuffix {\n    /// Function to get dynamic access token key suffix from Connector\n    fn get_access_token_key(\n        &self,\n        router_data: &dyn AccessTokenData,\n        merchant_connector_id_or_connector_name: String,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(common_utils::access_token::get_default_access_token_key(\n            &router_data.get_merchant_id(),\n            merchant_connector_id_or_connector_name,\n        ))\n    }\n}\n", "function_name": "crates__hyperswitch_interfaces__src__api.rs", "file": "crates__hyperswitch_interfaces__src__api.rs"}, {"query": "how to implement payment gateway connector", "code": "//! API interface\n\n/// authentication module\npub mod authentication;\n/// authentication_v2 module\npub mod authentication_v2;\npub mod disputes;\npub mod disputes_v2;\npub mod files;\npub mod files_v2;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\n#[cfg(feature = \"frm\")]\npub mod fraud_check_v2;\npub mod gateway;\npub mod merchant_connector_webhook_management;\npub mod merchant_connector_webhook_management_v2;\npub mod payments;\npub mod payments_v2;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\n#[cfg(feature = \"payouts\")]\npub mod payouts_v2;\npub mod refunds;\npub mod refunds_v2;\npub mod revenue_recovery;\npub mod revenue_recovery_v2;\npub mod subscriptions;\npub mod subscriptions_v2;\npub mod vault;\npub mod vault_v2;\n\nuse std::fmt::Debug;\n\nuse common_enums::{\n    enums::{\n        self, CallConnectorAction, CaptureMethod, EventClass, PaymentAction, PaymentMethodType,\n    },\n    PaymentMethod,\n};\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    connector_endpoints::Connectors,\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{\n        AccessToken, AccessTokenAuthenticationResponse, ConnectorAuthType, ErrorResponse,\n        RouterData,\n    },\n    router_data_v2::{\n        flow_common_types::{\n            AuthenticationTokenFlowData, ConnectorWebhookConfigurationFlowData,\n            WebhookSourceVerifyData,\n        },\n        AccessTokenFlowData, MandateRevokeFlowData, UasFlowData,\n    },\n    router_flow_types::{\n        mandate_revoke::MandateRevoke,\n        merchant_connector_webhook_management::ConnectorWebhookRegister, AccessTokenAuth,\n        AccessTokenAuthentication, Authenticate, AuthenticationConfirmation, PostAuthenticate,\n        PreAuthenticate, ProcessIncomingWebhook, VerifyWebhookSource,\n    },\n    router_request_types::{\n        self,\n        merchant_connector_webhook_management::ConnectorWebhookRegisterRequ\n\n... [truncated 29458 chars] ...\n\net_payment_method_type(&self) -> Option<PaymentMethodType>;\n    /// Get the merchant id from RouterData\n    fn get_merchant_id(&self) -> common_utils::id_type::MerchantId;\n}\n\nimpl<F, Req, Res> AccessTokenData for RouterData<F, Req, Res> {\n    fn get_payment_method_type(&self) -> Option<PaymentMethodType> {\n        self.payment_method_type\n    }\n    fn get_merchant_id(&self) -> common_utils::id_type::MerchantId {\n        self.merchant_id.clone()\n    }\n}\n\n/// Trait ConnectorAccessTokenSuffix\npub trait ConnectorAccessTokenSuffix {\n    /// Function to get dynamic access token key suffix from Connector\n    fn get_access_token_key(\n        &self,\n        router_data: &dyn AccessTokenData,\n        merchant_connector_id_or_connector_name: String,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(common_utils::access_token::get_default_access_token_key(\n            &router_data.get_merchant_id(),\n            merchant_connector_id_or_connector_name,\n        ))\n    }\n}\n", "function_name": "crates__hyperswitch_interfaces__src__api.rs", "file": "crates__hyperswitch_interfaces__src__api.rs"}, {"query": "hyperswitch authentication module", "code": "//! API interface\n\n/// authentication module\npub mod authentication;\n/// authentication_v2 module\npub mod authentication_v2;\npub mod disputes;\npub mod disputes_v2;\npub mod files;\npub mod files_v2;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\n#[cfg(feature = \"frm\")]\npub mod fraud_check_v2;\npub mod gateway;\npub mod merchant_connector_webhook_management;\npub mod merchant_connector_webhook_management_v2;\npub mod payments;\npub mod payments_v2;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\n#[cfg(feature = \"payouts\")]\npub mod payouts_v2;\npub mod refunds;\npub mod refunds_v2;\npub mod revenue_recovery;\npub mod revenue_recovery_v2;\npub mod subscriptions;\npub mod subscriptions_v2;\npub mod vault;\npub mod vault_v2;\n\nuse std::fmt::Debug;\n\nuse common_enums::{\n    enums::{\n        self, CallConnectorAction, CaptureMethod, EventClass, PaymentAction, PaymentMethodType,\n    },\n    PaymentMethod,\n};\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    connector_endpoints::Connectors,\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{\n        AccessToken, AccessTokenAuthenticationResponse, ConnectorAuthType, ErrorResponse,\n        RouterData,\n    },\n    router_data_v2::{\n        flow_common_types::{\n            AuthenticationTokenFlowData, ConnectorWebhookConfigurationFlowData,\n            WebhookSourceVerifyData,\n        },\n        AccessTokenFlowData, MandateRevokeFlowData, UasFlowData,\n    },\n    router_flow_types::{\n        mandate_revoke::MandateRevoke,\n        merchant_connector_webhook_management::ConnectorWebhookRegister, AccessTokenAuth,\n        AccessTokenAuthentication, Authenticate, AuthenticationConfirmation, PostAuthenticate,\n        PreAuthenticate, ProcessIncomingWebhook, VerifyWebhookSource,\n    },\n    router_request_types::{\n        self,\n        merchant_connector_webhook_management::ConnectorWebhookRegisterRequ\n\n... [truncated 29458 chars] ...\n\net_payment_method_type(&self) -> Option<PaymentMethodType>;\n    /// Get the merchant id from RouterData\n    fn get_merchant_id(&self) -> common_utils::id_type::MerchantId;\n}\n\nimpl<F, Req, Res> AccessTokenData for RouterData<F, Req, Res> {\n    fn get_payment_method_type(&self) -> Option<PaymentMethodType> {\n        self.payment_method_type\n    }\n    fn get_merchant_id(&self) -> common_utils::id_type::MerchantId {\n        self.merchant_id.clone()\n    }\n}\n\n/// Trait ConnectorAccessTokenSuffix\npub trait ConnectorAccessTokenSuffix {\n    /// Function to get dynamic access token key suffix from Connector\n    fn get_access_token_key(\n        &self,\n        router_data: &dyn AccessTokenData,\n        merchant_connector_id_or_connector_name: String,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(common_utils::access_token::get_default_access_token_key(\n            &router_data.get_merchant_id(),\n            merchant_connector_id_or_connector_name,\n        ))\n    }\n}\n", "function_name": "crates__hyperswitch_interfaces__src__api.rs", "file": "crates__hyperswitch_interfaces__src__api.rs"}, {"query": "payment orchestration API interface", "code": "//! API interface\n\n/// authentication module\npub mod authentication;\n/// authentication_v2 module\npub mod authentication_v2;\npub mod disputes;\npub mod disputes_v2;\npub mod files;\npub mod files_v2;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\n#[cfg(feature = \"frm\")]\npub mod fraud_check_v2;\npub mod gateway;\npub mod merchant_connector_webhook_management;\npub mod merchant_connector_webhook_management_v2;\npub mod payments;\npub mod payments_v2;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\n#[cfg(feature = \"payouts\")]\npub mod payouts_v2;\npub mod refunds;\npub mod refunds_v2;\npub mod revenue_recovery;\npub mod revenue_recovery_v2;\npub mod subscriptions;\npub mod subscriptions_v2;\npub mod vault;\npub mod vault_v2;\n\nuse std::fmt::Debug;\n\nuse common_enums::{\n    enums::{\n        self, CallConnectorAction, CaptureMethod, EventClass, PaymentAction, PaymentMethodType,\n    },\n    PaymentMethod,\n};\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    connector_endpoints::Connectors,\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{\n        AccessToken, AccessTokenAuthenticationResponse, ConnectorAuthType, ErrorResponse,\n        RouterData,\n    },\n    router_data_v2::{\n        flow_common_types::{\n            AuthenticationTokenFlowData, ConnectorWebhookConfigurationFlowData,\n            WebhookSourceVerifyData,\n        },\n        AccessTokenFlowData, MandateRevokeFlowData, UasFlowData,\n    },\n    router_flow_types::{\n        mandate_revoke::MandateRevoke,\n        merchant_connector_webhook_management::ConnectorWebhookRegister, AccessTokenAuth,\n        AccessTokenAuthentication, Authenticate, AuthenticationConfirmation, PostAuthenticate,\n        PreAuthenticate, ProcessIncomingWebhook, VerifyWebhookSource,\n    },\n    router_request_types::{\n        self,\n        merchant_connector_webhook_management::ConnectorWebhookRegisterRequ\n\n... [truncated 29458 chars] ...\n\net_payment_method_type(&self) -> Option<PaymentMethodType>;\n    /// Get the merchant id from RouterData\n    fn get_merchant_id(&self) -> common_utils::id_type::MerchantId;\n}\n\nimpl<F, Req, Res> AccessTokenData for RouterData<F, Req, Res> {\n    fn get_payment_method_type(&self) -> Option<PaymentMethodType> {\n        self.payment_method_type\n    }\n    fn get_merchant_id(&self) -> common_utils::id_type::MerchantId {\n        self.merchant_id.clone()\n    }\n}\n\n/// Trait ConnectorAccessTokenSuffix\npub trait ConnectorAccessTokenSuffix {\n    /// Function to get dynamic access token key suffix from Connector\n    fn get_access_token_key(\n        &self,\n        router_data: &dyn AccessTokenData,\n        merchant_connector_id_or_connector_name: String,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(common_utils::access_token::get_default_access_token_key(\n            &router_data.get_merchant_id(),\n            merchant_connector_id_or_connector_name,\n        ))\n    }\n}\n", "function_name": "crates__hyperswitch_interfaces__src__api.rs", "file": "crates__hyperswitch_interfaces__src__api.rs"}, {"query": "how to integrate VOLT payment gateway in Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsAuthorizeType, PaymentsVoidType, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as volt;\n\nuse self::volt::{webhook_headers, VoltWebhookBodyEventType};\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self},\n};\n\nconst X_VOLT_API_VERSION: &str = \"X-Volt-Api-Version\";\nconst X_VOLT_INI\n\n... [truncated 25716 chars] ...\n\nific_features: None,\n        },\n    );\n\n    volt_supported_payment_methods\n});\n\nstatic VOLT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"VOLT\",\n    description:\n        \"Volt is a payment gateway operating in China, specializing in facilitating local bank transfers\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic VOLT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Volt {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&VOLT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*VOLT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&VOLT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__volt.rs", "file": "crates__hyperswitch_connectors__src__connectors__volt.rs"}, {"query": "Volt connector implementation Rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsAuthorizeType, PaymentsVoidType, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as volt;\n\nuse self::volt::{webhook_headers, VoltWebhookBodyEventType};\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self},\n};\n\nconst X_VOLT_API_VERSION: &str = \"X-Volt-Api-Version\";\nconst X_VOLT_INI\n\n... [truncated 25716 chars] ...\n\nific_features: None,\n        },\n    );\n\n    volt_supported_payment_methods\n});\n\nstatic VOLT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"VOLT\",\n    description:\n        \"Volt is a payment gateway operating in China, specializing in facilitating local bank transfers\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic VOLT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Volt {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&VOLT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*VOLT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&VOLT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__volt.rs", "file": "crates__hyperswitch_connectors__src__connectors__volt.rs"}, {"query": "implement payment authorization with VOLT", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsAuthorizeType, PaymentsVoidType, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as volt;\n\nuse self::volt::{webhook_headers, VoltWebhookBodyEventType};\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self},\n};\n\nconst X_VOLT_API_VERSION: &str = \"X-Volt-Api-Version\";\nconst X_VOLT_INI\n\n... [truncated 25716 chars] ...\n\nific_features: None,\n        },\n    );\n\n    volt_supported_payment_methods\n});\n\nstatic VOLT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"VOLT\",\n    description:\n        \"Volt is a payment gateway operating in China, specializing in facilitating local bank transfers\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic VOLT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Volt {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&VOLT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*VOLT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&VOLT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__volt.rs", "file": "crates__hyperswitch_connectors__src__connectors__volt.rs"}, {"query": "Volt webhook handling hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsAuthorizeType, PaymentsVoidType, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as volt;\n\nuse self::volt::{webhook_headers, VoltWebhookBodyEventType};\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self},\n};\n\nconst X_VOLT_API_VERSION: &str = \"X-Volt-Api-Version\";\nconst X_VOLT_INI\n\n... [truncated 25716 chars] ...\n\nific_features: None,\n        },\n    );\n\n    volt_supported_payment_methods\n});\n\nstatic VOLT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"VOLT\",\n    description:\n        \"Volt is a payment gateway operating in China, specializing in facilitating local bank transfers\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic VOLT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Volt {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&VOLT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*VOLT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&VOLT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__volt.rs", "file": "crates__hyperswitch_connectors__src__connectors__volt.rs"}, {"query": "how to encrypt data using TypeEncryption trait", "code": "use async_trait::async_trait;\nuse common_utils::{\n    crypto,\n    encryption::Encryption,\n    errors::{CryptoError, CustomResult},\n    ext_traits::AsyncExt,\n    metrics::utils::record_operation_time,\n    types::keymanager::{Identifier, KeyManagerState},\n};\nuse encrypt::TypeEncryption;\nuse masking::Secret;\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashMap;\n\nmod encrypt {\n    use async_trait::async_trait;\n    use common_utils::{\n        crypto,\n        encryption::Encryption,\n        errors::{self, CustomResult},\n        ext_traits::ByteSliceExt,\n        keymanager::call_encryption_service,\n        transformers::{ForeignFrom, ForeignTryFrom},\n        types::keymanager::{\n            BatchDecryptDataResponse, BatchEncryptDataRequest, BatchEncryptDataResponse,\n            DecryptDataResponse, EncryptDataRequest, EncryptDataResponse, Identifier,\n            KeyManagerState, TransientBatchDecryptDataRequest, TransientDecryptDataRequest,\n        },\n    };\n    use error_stack::ResultExt;\n    use http::Method;\n    use masking::{PeekInterface, Secret};\n    use router_env::{instrument, logger, tracing};\n    use rustc_hash::FxHashMap;\n\n    use super::{metrics, obtain_data_to_decrypt_locally, EncryptedJsonType};\n\n    #[async_trait]\n    pub trait TypeEncryption<\n        T,\n        V: crypto::EncodeMessage + crypto::DecodeMessage,\n        S: masking::Strategy<T>,\n    >: Sized\n    {\n        async fn encrypt_via_api(\n            state: &KeyManagerState,\n            masked_data: Secret<T, S>,\n            identifier: Identifier,\n            key: &[u8],\n            crypt_algo: V,\n        ) -> CustomResult<Self, errors::CryptoError>;\n\n        async fn decrypt_via_api(\n            state: &KeyManagerState,\n            encrypted_data: Encryption,\n            identifier: Identifier,\n            key: &[u8],\n            crypt_algo: V,\n        ) -> CustomResult<Self, errors::CryptoError>;\n\n        async fn encrypt(\n            masked_data: Secret<T, S>,\n            key: &[u8],\n           \n\n... [truncated 59560 chars] ...\n\n = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v2\"[..], &b\"data!@#$%^&*()\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_colon_in_data() {\n        // Colon after the first colon should be part of data\n        let input = b\"v1:data:more:colons\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v1\"[..], &b\"data:more:colons\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_zero_version() {\n        let input = b\"v0:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v0\"[..], &b\"data\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_leading_zeros() {\n        let input = b\"v01:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v01\"[..], &b\"data\"[..])));\n\n        let input = b\"v001:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v001\"[..], &b\"data\"[..])));\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__type_encryption.rs", "file": "crates__hyperswitch_domain_models__src__type_encryption.rs"}, {"query": "TypeEncryption trait implementation", "code": "use async_trait::async_trait;\nuse common_utils::{\n    crypto,\n    encryption::Encryption,\n    errors::{CryptoError, CustomResult},\n    ext_traits::AsyncExt,\n    metrics::utils::record_operation_time,\n    types::keymanager::{Identifier, KeyManagerState},\n};\nuse encrypt::TypeEncryption;\nuse masking::Secret;\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashMap;\n\nmod encrypt {\n    use async_trait::async_trait;\n    use common_utils::{\n        crypto,\n        encryption::Encryption,\n        errors::{self, CustomResult},\n        ext_traits::ByteSliceExt,\n        keymanager::call_encryption_service,\n        transformers::{ForeignFrom, ForeignTryFrom},\n        types::keymanager::{\n            BatchDecryptDataResponse, BatchEncryptDataRequest, BatchEncryptDataResponse,\n            DecryptDataResponse, EncryptDataRequest, EncryptDataResponse, Identifier,\n            KeyManagerState, TransientBatchDecryptDataRequest, TransientDecryptDataRequest,\n        },\n    };\n    use error_stack::ResultExt;\n    use http::Method;\n    use masking::{PeekInterface, Secret};\n    use router_env::{instrument, logger, tracing};\n    use rustc_hash::FxHashMap;\n\n    use super::{metrics, obtain_data_to_decrypt_locally, EncryptedJsonType};\n\n    #[async_trait]\n    pub trait TypeEncryption<\n        T,\n        V: crypto::EncodeMessage + crypto::DecodeMessage,\n        S: masking::Strategy<T>,\n    >: Sized\n    {\n        async fn encrypt_via_api(\n            state: &KeyManagerState,\n            masked_data: Secret<T, S>,\n            identifier: Identifier,\n            key: &[u8],\n            crypt_algo: V,\n        ) -> CustomResult<Self, errors::CryptoError>;\n\n        async fn decrypt_via_api(\n            state: &KeyManagerState,\n            encrypted_data: Encryption,\n            identifier: Identifier,\n            key: &[u8],\n            crypt_algo: V,\n        ) -> CustomResult<Self, errors::CryptoError>;\n\n        async fn encrypt(\n            masked_data: Secret<T, S>,\n            key: &[u8],\n           \n\n... [truncated 59560 chars] ...\n\n = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v2\"[..], &b\"data!@#$%^&*()\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_colon_in_data() {\n        // Colon after the first colon should be part of data\n        let input = b\"v1:data:more:colons\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v1\"[..], &b\"data:more:colons\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_zero_version() {\n        let input = b\"v0:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v0\"[..], &b\"data\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_leading_zeros() {\n        let input = b\"v01:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v01\"[..], &b\"data\"[..])));\n\n        let input = b\"v001:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v001\"[..], &b\"data\"[..])));\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__type_encryption.rs", "file": "crates__hyperswitch_domain_models__src__type_encryption.rs"}, {"query": "how to decrypt encrypted data types", "code": "use async_trait::async_trait;\nuse common_utils::{\n    crypto,\n    encryption::Encryption,\n    errors::{CryptoError, CustomResult},\n    ext_traits::AsyncExt,\n    metrics::utils::record_operation_time,\n    types::keymanager::{Identifier, KeyManagerState},\n};\nuse encrypt::TypeEncryption;\nuse masking::Secret;\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashMap;\n\nmod encrypt {\n    use async_trait::async_trait;\n    use common_utils::{\n        crypto,\n        encryption::Encryption,\n        errors::{self, CustomResult},\n        ext_traits::ByteSliceExt,\n        keymanager::call_encryption_service,\n        transformers::{ForeignFrom, ForeignTryFrom},\n        types::keymanager::{\n            BatchDecryptDataResponse, BatchEncryptDataRequest, BatchEncryptDataResponse,\n            DecryptDataResponse, EncryptDataRequest, EncryptDataResponse, Identifier,\n            KeyManagerState, TransientBatchDecryptDataRequest, TransientDecryptDataRequest,\n        },\n    };\n    use error_stack::ResultExt;\n    use http::Method;\n    use masking::{PeekInterface, Secret};\n    use router_env::{instrument, logger, tracing};\n    use rustc_hash::FxHashMap;\n\n    use super::{metrics, obtain_data_to_decrypt_locally, EncryptedJsonType};\n\n    #[async_trait]\n    pub trait TypeEncryption<\n        T,\n        V: crypto::EncodeMessage + crypto::DecodeMessage,\n        S: masking::Strategy<T>,\n    >: Sized\n    {\n        async fn encrypt_via_api(\n            state: &KeyManagerState,\n            masked_data: Secret<T, S>,\n            identifier: Identifier,\n            key: &[u8],\n            crypt_algo: V,\n        ) -> CustomResult<Self, errors::CryptoError>;\n\n        async fn decrypt_via_api(\n            state: &KeyManagerState,\n            encrypted_data: Encryption,\n            identifier: Identifier,\n            key: &[u8],\n            crypt_algo: V,\n        ) -> CustomResult<Self, errors::CryptoError>;\n\n        async fn encrypt(\n            masked_data: Secret<T, S>,\n            key: &[u8],\n           \n\n... [truncated 59560 chars] ...\n\n = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v2\"[..], &b\"data!@#$%^&*()\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_colon_in_data() {\n        // Colon after the first colon should be part of data\n        let input = b\"v1:data:more:colons\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v1\"[..], &b\"data:more:colons\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_zero_version() {\n        let input = b\"v0:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v0\"[..], &b\"data\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_leading_zeros() {\n        let input = b\"v01:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v01\"[..], &b\"data\"[..])));\n\n        let input = b\"v001:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v001\"[..], &b\"data\"[..])));\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__type_encryption.rs", "file": "crates__hyperswitch_domain_models__src__type_encryption.rs"}, {"query": "hyperswitch keymanager encryption service", "code": "use async_trait::async_trait;\nuse common_utils::{\n    crypto,\n    encryption::Encryption,\n    errors::{CryptoError, CustomResult},\n    ext_traits::AsyncExt,\n    metrics::utils::record_operation_time,\n    types::keymanager::{Identifier, KeyManagerState},\n};\nuse encrypt::TypeEncryption;\nuse masking::Secret;\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashMap;\n\nmod encrypt {\n    use async_trait::async_trait;\n    use common_utils::{\n        crypto,\n        encryption::Encryption,\n        errors::{self, CustomResult},\n        ext_traits::ByteSliceExt,\n        keymanager::call_encryption_service,\n        transformers::{ForeignFrom, ForeignTryFrom},\n        types::keymanager::{\n            BatchDecryptDataResponse, BatchEncryptDataRequest, BatchEncryptDataResponse,\n            DecryptDataResponse, EncryptDataRequest, EncryptDataResponse, Identifier,\n            KeyManagerState, TransientBatchDecryptDataRequest, TransientDecryptDataRequest,\n        },\n    };\n    use error_stack::ResultExt;\n    use http::Method;\n    use masking::{PeekInterface, Secret};\n    use router_env::{instrument, logger, tracing};\n    use rustc_hash::FxHashMap;\n\n    use super::{metrics, obtain_data_to_decrypt_locally, EncryptedJsonType};\n\n    #[async_trait]\n    pub trait TypeEncryption<\n        T,\n        V: crypto::EncodeMessage + crypto::DecodeMessage,\n        S: masking::Strategy<T>,\n    >: Sized\n    {\n        async fn encrypt_via_api(\n            state: &KeyManagerState,\n            masked_data: Secret<T, S>,\n            identifier: Identifier,\n            key: &[u8],\n            crypt_algo: V,\n        ) -> CustomResult<Self, errors::CryptoError>;\n\n        async fn decrypt_via_api(\n            state: &KeyManagerState,\n            encrypted_data: Encryption,\n            identifier: Identifier,\n            key: &[u8],\n            crypt_algo: V,\n        ) -> CustomResult<Self, errors::CryptoError>;\n\n        async fn encrypt(\n            masked_data: Secret<T, S>,\n            key: &[u8],\n           \n\n... [truncated 59560 chars] ...\n\n = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v2\"[..], &b\"data!@#$%^&*()\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_colon_in_data() {\n        // Colon after the first colon should be part of data\n        let input = b\"v1:data:more:colons\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v1\"[..], &b\"data:more:colons\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_zero_version() {\n        let input = b\"v0:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v0\"[..], &b\"data\"[..])));\n    }\n\n    #[test]\n    fn test_split_version_prefix_leading_zeros() {\n        let input = b\"v01:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v01\"[..], &b\"data\"[..])));\n\n        let input = b\"v001:data\";\n        let result = split_version_prefix(input);\n        assert_eq!(result, Some((&b\"v001\"[..], &b\"data\"[..])));\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__type_encryption.rs", "file": "crates__hyperswitch_domain_models__src__type_encryption.rs"}, {"query": "mandate data structures rust", "code": "use std::collections::HashMap;\n\nuse api_models::payments::{\n    MandateAmountData as ApiMandateAmountData, MandateData as ApiMandateData, MandateType,\n};\nuse common_enums::Currency;\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    date_time,\n    errors::{CustomResult, ParsingError},\n    pii,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse time::PrimitiveDateTime;\n\nuse crate::router_data::RecurringMandatePaymentData;\n\n#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub struct MandateDetails {\n    pub update_mandate_id: Option<String>,\n}\n\nimpl From<MandateDetails> for diesel_models::enums::MandateDetails {\n    fn from(value: MandateDetails) -> Self {\n        Self {\n            update_mandate_id: value.update_mandate_id,\n        }\n    }\n}\n\nimpl From<diesel_models::enums::MandateDetails> for MandateDetails {\n    fn from(value: diesel_models::enums::MandateDetails) -> Self {\n        Self {\n            update_mandate_id: value.update_mandate_id,\n        }\n    }\n}\n\n#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub enum MandateDataType {\n    SingleUse(MandateAmountData),\n    MultiUse(Option<MandateAmountData>),\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize, PartialEq, Eq)]\npub struct MandateAmountData {\n    pub amount: MinorUnit,\n    pub currency: Currency,\n    pub start_date: Option<PrimitiveDateTime>,\n    pub end_date: Option<PrimitiveDateTime>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n}\n\n// The fields on this struct are optional, as we want to allow the merchant to provide partial\n// information about creating mandates\n#[derive(Default, Eq, PartialEq, Debug, Clone, serde::Serialize)]\npub struct MandateData {\n    /// A way to update the mandate's payment method details\n    pub update_mandate_id: Option<String>,\n    /// A consent from the customer to store the payment method\n    pub customer_\n\n... [truncated 15220 chars] ...\n\nd_amount,\n            original_payment_authorized_currency,\n            metadata,\n            connector_token_status,\n            connector_token_request_reference_id,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<PaymentsMandateReferenceRecord> for diesel_models::PaymentsMandateReferenceRecord {\n    fn from(value: PaymentsMandateReferenceRecord) -> Self {\n        Self {\n            connector_mandate_id: value.connector_mandate_id,\n            payment_method_type: value.payment_method_type,\n            original_payment_authorized_amount: value.original_payment_authorized_amount,\n            original_payment_authorized_currency: value.original_payment_authorized_currency,\n            mandate_metadata: value.mandate_metadata,\n            connector_mandate_status: value.connector_mandate_status,\n            connector_mandate_request_reference_id: value.connector_mandate_request_reference_id,\n            connector_customer_id: value.connector_customer_id,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__mandates.rs", "file": "crates__hyperswitch_domain_models__src__mandates.rs"}, {"query": "how to create mandate in hyperswitch", "code": "use std::collections::HashMap;\n\nuse api_models::payments::{\n    MandateAmountData as ApiMandateAmountData, MandateData as ApiMandateData, MandateType,\n};\nuse common_enums::Currency;\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    date_time,\n    errors::{CustomResult, ParsingError},\n    pii,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse time::PrimitiveDateTime;\n\nuse crate::router_data::RecurringMandatePaymentData;\n\n#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub struct MandateDetails {\n    pub update_mandate_id: Option<String>,\n}\n\nimpl From<MandateDetails> for diesel_models::enums::MandateDetails {\n    fn from(value: MandateDetails) -> Self {\n        Self {\n            update_mandate_id: value.update_mandate_id,\n        }\n    }\n}\n\nimpl From<diesel_models::enums::MandateDetails> for MandateDetails {\n    fn from(value: diesel_models::enums::MandateDetails) -> Self {\n        Self {\n            update_mandate_id: value.update_mandate_id,\n        }\n    }\n}\n\n#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub enum MandateDataType {\n    SingleUse(MandateAmountData),\n    MultiUse(Option<MandateAmountData>),\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize, PartialEq, Eq)]\npub struct MandateAmountData {\n    pub amount: MinorUnit,\n    pub currency: Currency,\n    pub start_date: Option<PrimitiveDateTime>,\n    pub end_date: Option<PrimitiveDateTime>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n}\n\n// The fields on this struct are optional, as we want to allow the merchant to provide partial\n// information about creating mandates\n#[derive(Default, Eq, PartialEq, Debug, Clone, serde::Serialize)]\npub struct MandateData {\n    /// A way to update the mandate's payment method details\n    pub update_mandate_id: Option<String>,\n    /// A consent from the customer to store the payment method\n    pub customer_\n\n... [truncated 15220 chars] ...\n\nd_amount,\n            original_payment_authorized_currency,\n            metadata,\n            connector_token_status,\n            connector_token_request_reference_id,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<PaymentsMandateReferenceRecord> for diesel_models::PaymentsMandateReferenceRecord {\n    fn from(value: PaymentsMandateReferenceRecord) -> Self {\n        Self {\n            connector_mandate_id: value.connector_mandate_id,\n            payment_method_type: value.payment_method_type,\n            original_payment_authorized_amount: value.original_payment_authorized_amount,\n            original_payment_authorized_currency: value.original_payment_authorized_currency,\n            mandate_metadata: value.mandate_metadata,\n            connector_mandate_status: value.connector_mandate_status,\n            connector_mandate_request_reference_id: value.connector_mandate_request_reference_id,\n            connector_customer_id: value.connector_customer_id,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__mandates.rs", "file": "crates__hyperswitch_domain_models__src__mandates.rs"}, {"query": "mandate type enum single use multi use", "code": "use std::collections::HashMap;\n\nuse api_models::payments::{\n    MandateAmountData as ApiMandateAmountData, MandateData as ApiMandateData, MandateType,\n};\nuse common_enums::Currency;\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    date_time,\n    errors::{CustomResult, ParsingError},\n    pii,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse time::PrimitiveDateTime;\n\nuse crate::router_data::RecurringMandatePaymentData;\n\n#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub struct MandateDetails {\n    pub update_mandate_id: Option<String>,\n}\n\nimpl From<MandateDetails> for diesel_models::enums::MandateDetails {\n    fn from(value: MandateDetails) -> Self {\n        Self {\n            update_mandate_id: value.update_mandate_id,\n        }\n    }\n}\n\nimpl From<diesel_models::enums::MandateDetails> for MandateDetails {\n    fn from(value: diesel_models::enums::MandateDetails) -> Self {\n        Self {\n            update_mandate_id: value.update_mandate_id,\n        }\n    }\n}\n\n#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub enum MandateDataType {\n    SingleUse(MandateAmountData),\n    MultiUse(Option<MandateAmountData>),\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize, PartialEq, Eq)]\npub struct MandateAmountData {\n    pub amount: MinorUnit,\n    pub currency: Currency,\n    pub start_date: Option<PrimitiveDateTime>,\n    pub end_date: Option<PrimitiveDateTime>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n}\n\n// The fields on this struct are optional, as we want to allow the merchant to provide partial\n// information about creating mandates\n#[derive(Default, Eq, PartialEq, Debug, Clone, serde::Serialize)]\npub struct MandateData {\n    /// A way to update the mandate's payment method details\n    pub update_mandate_id: Option<String>,\n    /// A consent from the customer to store the payment method\n    pub customer_\n\n... [truncated 15220 chars] ...\n\nd_amount,\n            original_payment_authorized_currency,\n            metadata,\n            connector_token_status,\n            connector_token_request_reference_id,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<PaymentsMandateReferenceRecord> for diesel_models::PaymentsMandateReferenceRecord {\n    fn from(value: PaymentsMandateReferenceRecord) -> Self {\n        Self {\n            connector_mandate_id: value.connector_mandate_id,\n            payment_method_type: value.payment_method_type,\n            original_payment_authorized_amount: value.original_payment_authorized_amount,\n            original_payment_authorized_currency: value.original_payment_authorized_currency,\n            mandate_metadata: value.mandate_metadata,\n            connector_mandate_status: value.connector_mandate_status,\n            connector_mandate_request_reference_id: value.connector_mandate_request_reference_id,\n            connector_customer_id: value.connector_customer_id,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__mandates.rs", "file": "crates__hyperswitch_domain_models__src__mandates.rs"}, {"query": "mandate amount data definition", "code": "use std::collections::HashMap;\n\nuse api_models::payments::{\n    MandateAmountData as ApiMandateAmountData, MandateData as ApiMandateData, MandateType,\n};\nuse common_enums::Currency;\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    date_time,\n    errors::{CustomResult, ParsingError},\n    pii,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse time::PrimitiveDateTime;\n\nuse crate::router_data::RecurringMandatePaymentData;\n\n#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub struct MandateDetails {\n    pub update_mandate_id: Option<String>,\n}\n\nimpl From<MandateDetails> for diesel_models::enums::MandateDetails {\n    fn from(value: MandateDetails) -> Self {\n        Self {\n            update_mandate_id: value.update_mandate_id,\n        }\n    }\n}\n\nimpl From<diesel_models::enums::MandateDetails> for MandateDetails {\n    fn from(value: diesel_models::enums::MandateDetails) -> Self {\n        Self {\n            update_mandate_id: value.update_mandate_id,\n        }\n    }\n}\n\n#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub enum MandateDataType {\n    SingleUse(MandateAmountData),\n    MultiUse(Option<MandateAmountData>),\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize, PartialEq, Eq)]\npub struct MandateAmountData {\n    pub amount: MinorUnit,\n    pub currency: Currency,\n    pub start_date: Option<PrimitiveDateTime>,\n    pub end_date: Option<PrimitiveDateTime>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n}\n\n// The fields on this struct are optional, as we want to allow the merchant to provide partial\n// information about creating mandates\n#[derive(Default, Eq, PartialEq, Debug, Clone, serde::Serialize)]\npub struct MandateData {\n    /// A way to update the mandate's payment method details\n    pub update_mandate_id: Option<String>,\n    /// A consent from the customer to store the payment method\n    pub customer_\n\n... [truncated 15220 chars] ...\n\nd_amount,\n            original_payment_authorized_currency,\n            metadata,\n            connector_token_status,\n            connector_token_request_reference_id,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<PaymentsMandateReferenceRecord> for diesel_models::PaymentsMandateReferenceRecord {\n    fn from(value: PaymentsMandateReferenceRecord) -> Self {\n        Self {\n            connector_mandate_id: value.connector_mandate_id,\n            payment_method_type: value.payment_method_type,\n            original_payment_authorized_amount: value.original_payment_authorized_amount,\n            original_payment_authorized_currency: value.original_payment_authorized_currency,\n            mandate_metadata: value.mandate_metadata,\n            connector_mandate_status: value.connector_mandate_status,\n            connector_mandate_request_reference_id: value.connector_mandate_request_reference_id,\n            connector_customer_id: value.connector_customer_id,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__mandates.rs", "file": "crates__hyperswitch_domain_models__src__mandates.rs"}, {"query": "braintree payment gateway integration", "code": "use api_models::{\n    payments as payment_types,\n    payments::{ApplePaySessionResponse, SessionToken},\n    webhooks::IncomingWebhookEvent,\n};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::{OptionExt, ValueExt},\n    pii,\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        RefundsRequestData, RouterData as _,\n    },\n};\n\npub const CHANNEL_CODE: &str = \"HyperSwitchBT_Ecom\";\npub const CLIENT_TOKEN_MUTATION: &str = \"mutation createClientToken($input: CreateClientTokenInput!) { createClientToken(input: $input) { clientToken}}\";\npub const TOKENIZE_CREDIT_CARD: &str = \"mutation  tokenizeCreditCard($input: TokenizeCreditCardInput!) { tokenizeCreditCard(input: $input) { clientMutationId paymentMethod { id } } }\";\npub const CHARGE_CREDIT_CARD_MUTATION: &str = \"mutation ChargeCreditCard($input: ChargeCreditCardInput!) { chargeCreditCard(input: $input) { transaction { \n\n... [truncated 119576 chars] ...\n\n             field_name: \"application_expiration_month\",\n                                    })?,\n                                expiration_year: decrypt_data.get_four_digit_expiry_year(),\n                                number: decrypt_data.application_primary_account_number.clone(),\n                                origin_details: NetworkTokenOriginDetailsInput {\n                                    origin: NetworkTokenOrigin::ApplePay,\n                                },\n                            },\n                        }),\n                    },\n                }),\n                _ => Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"braintree\"),\n                )\n                .into()),\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"braintree\"),\n            )\n            .into()),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs"}, {"query": "transform braintree graphql mutations", "code": "use api_models::{\n    payments as payment_types,\n    payments::{ApplePaySessionResponse, SessionToken},\n    webhooks::IncomingWebhookEvent,\n};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::{OptionExt, ValueExt},\n    pii,\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        RefundsRequestData, RouterData as _,\n    },\n};\n\npub const CHANNEL_CODE: &str = \"HyperSwitchBT_Ecom\";\npub const CLIENT_TOKEN_MUTATION: &str = \"mutation createClientToken($input: CreateClientTokenInput!) { createClientToken(input: $input) { clientToken}}\";\npub const TOKENIZE_CREDIT_CARD: &str = \"mutation  tokenizeCreditCard($input: TokenizeCreditCardInput!) { tokenizeCreditCard(input: $input) { clientMutationId paymentMethod { id } } }\";\npub const CHARGE_CREDIT_CARD_MUTATION: &str = \"mutation ChargeCreditCard($input: ChargeCreditCardInput!) { chargeCreditCard(input: $input) { transaction { \n\n... [truncated 119576 chars] ...\n\n             field_name: \"application_expiration_month\",\n                                    })?,\n                                expiration_year: decrypt_data.get_four_digit_expiry_year(),\n                                number: decrypt_data.application_primary_account_number.clone(),\n                                origin_details: NetworkTokenOriginDetailsInput {\n                                    origin: NetworkTokenOrigin::ApplePay,\n                                },\n                            },\n                        }),\n                    },\n                }),\n                _ => Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"braintree\"),\n                )\n                .into()),\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"braintree\"),\n            )\n            .into()),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs"}, {"query": "payments authorize capture braintree", "code": "use api_models::{\n    payments as payment_types,\n    payments::{ApplePaySessionResponse, SessionToken},\n    webhooks::IncomingWebhookEvent,\n};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::{OptionExt, ValueExt},\n    pii,\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        RefundsRequestData, RouterData as _,\n    },\n};\n\npub const CHANNEL_CODE: &str = \"HyperSwitchBT_Ecom\";\npub const CLIENT_TOKEN_MUTATION: &str = \"mutation createClientToken($input: CreateClientTokenInput!) { createClientToken(input: $input) { clientToken}}\";\npub const TOKENIZE_CREDIT_CARD: &str = \"mutation  tokenizeCreditCard($input: TokenizeCreditCardInput!) { tokenizeCreditCard(input: $input) { clientMutationId paymentMethod { id } } }\";\npub const CHARGE_CREDIT_CARD_MUTATION: &str = \"mutation ChargeCreditCard($input: ChargeCreditCardInput!) { chargeCreditCard(input: $input) { transaction { \n\n... [truncated 119576 chars] ...\n\n             field_name: \"application_expiration_month\",\n                                    })?,\n                                expiration_year: decrypt_data.get_four_digit_expiry_year(),\n                                number: decrypt_data.application_primary_account_number.clone(),\n                                origin_details: NetworkTokenOriginDetailsInput {\n                                    origin: NetworkTokenOrigin::ApplePay,\n                                },\n                            },\n                        }),\n                    },\n                }),\n                _ => Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"braintree\"),\n                )\n                .into()),\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"braintree\"),\n            )\n            .into()),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs"}, {"query": "braintree payment method tokenization", "code": "use api_models::{\n    payments as payment_types,\n    payments::{ApplePaySessionResponse, SessionToken},\n    webhooks::IncomingWebhookEvent,\n};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::{OptionExt, ValueExt},\n    pii,\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        RefundsRequestData, RouterData as _,\n    },\n};\n\npub const CHANNEL_CODE: &str = \"HyperSwitchBT_Ecom\";\npub const CLIENT_TOKEN_MUTATION: &str = \"mutation createClientToken($input: CreateClientTokenInput!) { createClientToken(input: $input) { clientToken}}\";\npub const TOKENIZE_CREDIT_CARD: &str = \"mutation  tokenizeCreditCard($input: TokenizeCreditCardInput!) { tokenizeCreditCard(input: $input) { clientMutationId paymentMethod { id } } }\";\npub const CHARGE_CREDIT_CARD_MUTATION: &str = \"mutation ChargeCreditCard($input: ChargeCreditCardInput!) { chargeCreditCard(input: $input) { transaction { \n\n... [truncated 119576 chars] ...\n\n             field_name: \"application_expiration_month\",\n                                    })?,\n                                expiration_year: decrypt_data.get_four_digit_expiry_year(),\n                                number: decrypt_data.application_primary_account_number.clone(),\n                                origin_details: NetworkTokenOriginDetailsInput {\n                                    origin: NetworkTokenOrigin::ApplePay,\n                                },\n                            },\n                        }),\n                    },\n                }),\n                _ => Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"braintree\"),\n                )\n                .into()),\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"braintree\"),\n            )\n            .into()),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs"}, {"query": "Dwolla webhook event mapping", "code": "use common_enums::{enums, AttemptStatus};\nuse common_utils::{errors::CustomResult, types::StringMajorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::RSync,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CustomerData, RouterData as _},\n};\n\npub struct DwollaAuthType {\n    pub(super) client_id: Secret<String>,\n    pub(super) client_secret: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for DwollaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                client_id: api_key.to_owned(),\n                client_secret: key1.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, PartialEq)]\npub struct DwollaAccessTokenRequest {\n    pub grant_type: String,\n}\n\n#[derive(Default, Debug, Clone, Deserialize, PartialEq, Serialize)]\npub struct DwollaAccessTokenResponse {\n    access_token: Secret<String>,\n    expires_in: i64,\n    token_type: String,\n}\n\npub fn extract_token_from_body(body: &[u8]) -> CustomResult<String, errors::ConnectorError> {\n    let parsed: serde_json::Value = serde_json::from_slice(body)\n        .map_err(|_| report!(errors::ConnectorError::ResponseDeserializationFailed))?;\n\n    parsed\n        .get(\"_links\")\n        .and_then(|\n\n... [truncated 19012 chars] ...\n\nntType::CustomerTransferCompleted, true)\n            | (DwollaWebhookEventType::CustomerBankTransferCompleted, true) => Self::RefundSuccess,\n            (DwollaWebhookEventType::CustomerTransferFailed, true)\n            | (DwollaWebhookEventType::CustomerBankTransferFailed, true) => Self::RefundFailure,\n\n            (DwollaWebhookEventType::CustomerTransferCreated, false)\n            | (DwollaWebhookEventType::CustomerBankTransferCreated, false) => {\n                Self::PaymentIntentProcessing\n            }\n            (DwollaWebhookEventType::CustomerTransferCompleted, false)\n            | (DwollaWebhookEventType::CustomerBankTransferCompleted, false) => {\n                Self::PaymentIntentSuccess\n            }\n            (DwollaWebhookEventType::CustomerTransferFailed, false)\n            | (DwollaWebhookEventType::CustomerBankTransferFailed, false) => {\n                Self::PaymentIntentFailure\n            }\n            _ => Self::EventNotSupported,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__dwolla__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__dwolla__transformers.rs"}, {"query": "DwollaAuthType struct", "code": "use common_enums::{enums, AttemptStatus};\nuse common_utils::{errors::CustomResult, types::StringMajorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::RSync,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CustomerData, RouterData as _},\n};\n\npub struct DwollaAuthType {\n    pub(super) client_id: Secret<String>,\n    pub(super) client_secret: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for DwollaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                client_id: api_key.to_owned(),\n                client_secret: key1.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, PartialEq)]\npub struct DwollaAccessTokenRequest {\n    pub grant_type: String,\n}\n\n#[derive(Default, Debug, Clone, Deserialize, PartialEq, Serialize)]\npub struct DwollaAccessTokenResponse {\n    access_token: Secret<String>,\n    expires_in: i64,\n    token_type: String,\n}\n\npub fn extract_token_from_body(body: &[u8]) -> CustomResult<String, errors::ConnectorError> {\n    let parsed: serde_json::Value = serde_json::from_slice(body)\n        .map_err(|_| report!(errors::ConnectorError::ResponseDeserializationFailed))?;\n\n    parsed\n        .get(\"_links\")\n        .and_then(|\n\n... [truncated 19012 chars] ...\n\nntType::CustomerTransferCompleted, true)\n            | (DwollaWebhookEventType::CustomerBankTransferCompleted, true) => Self::RefundSuccess,\n            (DwollaWebhookEventType::CustomerTransferFailed, true)\n            | (DwollaWebhookEventType::CustomerBankTransferFailed, true) => Self::RefundFailure,\n\n            (DwollaWebhookEventType::CustomerTransferCreated, false)\n            | (DwollaWebhookEventType::CustomerBankTransferCreated, false) => {\n                Self::PaymentIntentProcessing\n            }\n            (DwollaWebhookEventType::CustomerTransferCompleted, false)\n            | (DwollaWebhookEventType::CustomerBankTransferCompleted, false) => {\n                Self::PaymentIntentSuccess\n            }\n            (DwollaWebhookEventType::CustomerTransferFailed, false)\n            | (DwollaWebhookEventType::CustomerBankTransferFailed, false) => {\n                Self::PaymentIntentFailure\n            }\n            _ => Self::EventNotSupported,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__dwolla__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__dwolla__transformers.rs"}, {"query": "how to handle Dwolla webhooks", "code": "use common_enums::{enums, AttemptStatus};\nuse common_utils::{errors::CustomResult, types::StringMajorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::RSync,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CustomerData, RouterData as _},\n};\n\npub struct DwollaAuthType {\n    pub(super) client_id: Secret<String>,\n    pub(super) client_secret: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for DwollaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                client_id: api_key.to_owned(),\n                client_secret: key1.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, PartialEq)]\npub struct DwollaAccessTokenRequest {\n    pub grant_type: String,\n}\n\n#[derive(Default, Debug, Clone, Deserialize, PartialEq, Serialize)]\npub struct DwollaAccessTokenResponse {\n    access_token: Secret<String>,\n    expires_in: i64,\n    token_type: String,\n}\n\npub fn extract_token_from_body(body: &[u8]) -> CustomResult<String, errors::ConnectorError> {\n    let parsed: serde_json::Value = serde_json::from_slice(body)\n        .map_err(|_| report!(errors::ConnectorError::ResponseDeserializationFailed))?;\n\n    parsed\n        .get(\"_links\")\n        .and_then(|\n\n... [truncated 19012 chars] ...\n\nntType::CustomerTransferCompleted, true)\n            | (DwollaWebhookEventType::CustomerBankTransferCompleted, true) => Self::RefundSuccess,\n            (DwollaWebhookEventType::CustomerTransferFailed, true)\n            | (DwollaWebhookEventType::CustomerBankTransferFailed, true) => Self::RefundFailure,\n\n            (DwollaWebhookEventType::CustomerTransferCreated, false)\n            | (DwollaWebhookEventType::CustomerBankTransferCreated, false) => {\n                Self::PaymentIntentProcessing\n            }\n            (DwollaWebhookEventType::CustomerTransferCompleted, false)\n            | (DwollaWebhookEventType::CustomerBankTransferCompleted, false) => {\n                Self::PaymentIntentSuccess\n            }\n            (DwollaWebhookEventType::CustomerTransferFailed, false)\n            | (DwollaWebhookEventType::CustomerBankTransferFailed, false) => {\n                Self::PaymentIntentFailure\n            }\n            _ => Self::EventNotSupported,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__dwolla__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__dwolla__transformers.rs"}, {"query": "Dwolla connector authentication", "code": "use common_enums::{enums, AttemptStatus};\nuse common_utils::{errors::CustomResult, types::StringMajorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::RSync,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CustomerData, RouterData as _},\n};\n\npub struct DwollaAuthType {\n    pub(super) client_id: Secret<String>,\n    pub(super) client_secret: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for DwollaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                client_id: api_key.to_owned(),\n                client_secret: key1.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, PartialEq)]\npub struct DwollaAccessTokenRequest {\n    pub grant_type: String,\n}\n\n#[derive(Default, Debug, Clone, Deserialize, PartialEq, Serialize)]\npub struct DwollaAccessTokenResponse {\n    access_token: Secret<String>,\n    expires_in: i64,\n    token_type: String,\n}\n\npub fn extract_token_from_body(body: &[u8]) -> CustomResult<String, errors::ConnectorError> {\n    let parsed: serde_json::Value = serde_json::from_slice(body)\n        .map_err(|_| report!(errors::ConnectorError::ResponseDeserializationFailed))?;\n\n    parsed\n        .get(\"_links\")\n        .and_then(|\n\n... [truncated 19012 chars] ...\n\nntType::CustomerTransferCompleted, true)\n            | (DwollaWebhookEventType::CustomerBankTransferCompleted, true) => Self::RefundSuccess,\n            (DwollaWebhookEventType::CustomerTransferFailed, true)\n            | (DwollaWebhookEventType::CustomerBankTransferFailed, true) => Self::RefundFailure,\n\n            (DwollaWebhookEventType::CustomerTransferCreated, false)\n            | (DwollaWebhookEventType::CustomerBankTransferCreated, false) => {\n                Self::PaymentIntentProcessing\n            }\n            (DwollaWebhookEventType::CustomerTransferCompleted, false)\n            | (DwollaWebhookEventType::CustomerBankTransferCompleted, false) => {\n                Self::PaymentIntentSuccess\n            }\n            (DwollaWebhookEventType::CustomerTransferFailed, false)\n            | (DwollaWebhookEventType::CustomerBankTransferFailed, false) => {\n                Self::PaymentIntentFailure\n            }\n            _ => Self::EventNotSupported,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__dwolla__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__dwolla__transformers.rs"}, {"query": "novalnet payment connector integration", "code": "use std::collections::HashMap;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::{enums, enums as api_enums};\nuse common_utils::{\n    consts,\n    ext_traits::OptionExt,\n    pii::Email,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, PaymentMethodData, WalletData as WalletDataPaymentMethod,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressData, AddressDetailsData, ApplePay, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCaptureRequestData, PaymentsSetupMandateRequestData,\n        PaymentsSyncRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub struct NovalnetRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for NovalnetRouterData<T> {\n    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst MINIMAL_CUSTOMER_DATA_PASSED: i64 = 1;\nconst CREATE_TOKEN_REQUIRED: i8 = 1;\n\nconst TEST_MODE_ENABLED: i8 = 1;\nconst TEST_MODE_DISABLED: i8 = 0;\n\nfn get_test_\n\n... [truncated 68719 chars] ...\n\nd::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"novalnet\"),\n                    ))?\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"novalnet\"),\n            ))?,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__novalnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__novalnet__transformers.rs"}, {"query": "NovalnetPaymentsRequest struct definition", "code": "use std::collections::HashMap;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::{enums, enums as api_enums};\nuse common_utils::{\n    consts,\n    ext_traits::OptionExt,\n    pii::Email,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, PaymentMethodData, WalletData as WalletDataPaymentMethod,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressData, AddressDetailsData, ApplePay, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCaptureRequestData, PaymentsSetupMandateRequestData,\n        PaymentsSyncRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub struct NovalnetRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for NovalnetRouterData<T> {\n    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst MINIMAL_CUSTOMER_DATA_PASSED: i64 = 1;\nconst CREATE_TOKEN_REQUIRED: i8 = 1;\n\nconst TEST_MODE_ENABLED: i8 = 1;\nconst TEST_MODE_DISABLED: i8 = 0;\n\nfn get_test_\n\n... [truncated 68719 chars] ...\n\nd::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"novalnet\"),\n                    ))?\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"novalnet\"),\n            ))?,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__novalnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__novalnet__transformers.rs"}, {"query": "how to handle novalnet refunds", "code": "use std::collections::HashMap;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::{enums, enums as api_enums};\nuse common_utils::{\n    consts,\n    ext_traits::OptionExt,\n    pii::Email,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, PaymentMethodData, WalletData as WalletDataPaymentMethod,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressData, AddressDetailsData, ApplePay, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCaptureRequestData, PaymentsSetupMandateRequestData,\n        PaymentsSyncRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub struct NovalnetRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for NovalnetRouterData<T> {\n    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst MINIMAL_CUSTOMER_DATA_PASSED: i64 = 1;\nconst CREATE_TOKEN_REQUIRED: i8 = 1;\n\nconst TEST_MODE_ENABLED: i8 = 1;\nconst TEST_MODE_DISABLED: i8 = 0;\n\nfn get_test_\n\n... [truncated 68719 chars] ...\n\nd::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"novalnet\"),\n                    ))?\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"novalnet\"),\n            ))?,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__novalnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__novalnet__transformers.rs"}, {"query": "novalnet webhook response transformer", "code": "use std::collections::HashMap;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::{enums, enums as api_enums};\nuse common_utils::{\n    consts,\n    ext_traits::OptionExt,\n    pii::Email,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, PaymentMethodData, WalletData as WalletDataPaymentMethod,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressData, AddressDetailsData, ApplePay, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCaptureRequestData, PaymentsSetupMandateRequestData,\n        PaymentsSyncRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub struct NovalnetRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for NovalnetRouterData<T> {\n    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst MINIMAL_CUSTOMER_DATA_PASSED: i64 = 1;\nconst CREATE_TOKEN_REQUIRED: i8 = 1;\n\nconst TEST_MODE_ENABLED: i8 = 1;\nconst TEST_MODE_DISABLED: i8 = 0;\n\nfn get_test_\n\n... [truncated 68719 chars] ...\n\nd::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"novalnet\"),\n                    ))?\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"novalnet\"),\n            ))?,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__novalnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__novalnet__transformers.rs"}, {"query": "Checkout connector request transformation", "code": "use common_enums::{\n    enums::{self, AttemptStatus, PaymentChannel},\n    CountryAlpha2,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    ext_traits::ByteSliceExt,\n    request::{Method, RequestContent},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    payment_methods::storage_enums::MitCategory,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{Execute, RSync, SetupMandate},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors, webhooks};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse serde_with::skip_serializing_none;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AdditionalCardInfo, PaymentsAuthorizeRequestData, PaymentsCaptureRequestData,\n        PaymentsSyncRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct CheckoutRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for CheckoutRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n  \n\n... [truncated 79719 chars] ...\n\n               .recurring_transaction_agreement_provider_file_id,\n            additional_evidence_file: submit_evidence_request_data\n                .uncategorized_file_provider_file_id,\n        })\n    }\n}\n\nimpl From<String> for utils::ErrorCodeAndMessage {\n    fn from(error: String) -> Self {\n        Self {\n            error_code: error.clone(),\n            error_message: error,\n        }\n    }\n}\n\nfn convert_to_additional_payment_method_connector_response(\n    source: Option<&Source>,\n) -> Option<AdditionalPaymentMethodConnectorResponse> {\n    source.map(|code| {\n        let payment_checks = serde_json::json!({\n            \"avs_result\": code.avs_check,\n            \"card_validation_result\": code.cvv_check,\n        });\n        AdditionalPaymentMethodConnectorResponse::Card {\n            authentication_data: None,\n            payment_checks: Some(payment_checks),\n            card_network: None,\n            domestic_network: None,\n            auth_code: None,\n        }\n    })\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs"}, {"query": "CheckoutRouterData struct", "code": "use common_enums::{\n    enums::{self, AttemptStatus, PaymentChannel},\n    CountryAlpha2,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    ext_traits::ByteSliceExt,\n    request::{Method, RequestContent},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    payment_methods::storage_enums::MitCategory,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{Execute, RSync, SetupMandate},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors, webhooks};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse serde_with::skip_serializing_none;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AdditionalCardInfo, PaymentsAuthorizeRequestData, PaymentsCaptureRequestData,\n        PaymentsSyncRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct CheckoutRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for CheckoutRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n  \n\n... [truncated 79719 chars] ...\n\n               .recurring_transaction_agreement_provider_file_id,\n            additional_evidence_file: submit_evidence_request_data\n                .uncategorized_file_provider_file_id,\n        })\n    }\n}\n\nimpl From<String> for utils::ErrorCodeAndMessage {\n    fn from(error: String) -> Self {\n        Self {\n            error_code: error.clone(),\n            error_message: error,\n        }\n    }\n}\n\nfn convert_to_additional_payment_method_connector_response(\n    source: Option<&Source>,\n) -> Option<AdditionalPaymentMethodConnectorResponse> {\n    source.map(|code| {\n        let payment_checks = serde_json::json!({\n            \"avs_result\": code.avs_check,\n            \"card_validation_result\": code.cvv_check,\n        });\n        AdditionalPaymentMethodConnectorResponse::Card {\n            authentication_data: None,\n            payment_checks: Some(payment_checks),\n            card_network: None,\n            domestic_network: None,\n            auth_code: None,\n        }\n    })\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs"}, {"query": "how to implement Apple Pay tokenization", "code": "use common_enums::{\n    enums::{self, AttemptStatus, PaymentChannel},\n    CountryAlpha2,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    ext_traits::ByteSliceExt,\n    request::{Method, RequestContent},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    payment_methods::storage_enums::MitCategory,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{Execute, RSync, SetupMandate},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors, webhooks};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse serde_with::skip_serializing_none;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AdditionalCardInfo, PaymentsAuthorizeRequestData, PaymentsCaptureRequestData,\n        PaymentsSyncRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct CheckoutRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for CheckoutRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n  \n\n... [truncated 79719 chars] ...\n\n               .recurring_transaction_agreement_provider_file_id,\n            additional_evidence_file: submit_evidence_request_data\n                .uncategorized_file_provider_file_id,\n        })\n    }\n}\n\nimpl From<String> for utils::ErrorCodeAndMessage {\n    fn from(error: String) -> Self {\n        Self {\n            error_code: error.clone(),\n            error_message: error,\n        }\n    }\n}\n\nfn convert_to_additional_payment_method_connector_response(\n    source: Option<&Source>,\n) -> Option<AdditionalPaymentMethodConnectorResponse> {\n    source.map(|code| {\n        let payment_checks = serde_json::json!({\n            \"avs_result\": code.avs_check,\n            \"card_validation_result\": code.cvv_check,\n        });\n        AdditionalPaymentMethodConnectorResponse::Card {\n            authentication_data: None,\n            payment_checks: Some(payment_checks),\n            card_network: None,\n            domestic_network: None,\n            auth_code: None,\n        }\n    })\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs"}, {"query": "hyperswitch checkout evidence submission", "code": "use common_enums::{\n    enums::{self, AttemptStatus, PaymentChannel},\n    CountryAlpha2,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    ext_traits::ByteSliceExt,\n    request::{Method, RequestContent},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    payment_methods::storage_enums::MitCategory,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{Execute, RSync, SetupMandate},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors, webhooks};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse serde_with::skip_serializing_none;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AdditionalCardInfo, PaymentsAuthorizeRequestData, PaymentsCaptureRequestData,\n        PaymentsSyncRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct CheckoutRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for CheckoutRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n  \n\n... [truncated 79719 chars] ...\n\n               .recurring_transaction_agreement_provider_file_id,\n            additional_evidence_file: submit_evidence_request_data\n                .uncategorized_file_provider_file_id,\n        })\n    }\n}\n\nimpl From<String> for utils::ErrorCodeAndMessage {\n    fn from(error: String) -> Self {\n        Self {\n            error_code: error.clone(),\n            error_message: error,\n        }\n    }\n}\n\nfn convert_to_additional_payment_method_connector_response(\n    source: Option<&Source>,\n) -> Option<AdditionalPaymentMethodConnectorResponse> {\n    source.map(|code| {\n        let payment_checks = serde_json::json!({\n            \"avs_result\": code.avs_check,\n            \"card_validation_result\": code.cvv_check,\n        });\n        AdditionalPaymentMethodConnectorResponse::Card {\n            authentication_data: None,\n            payment_checks: Some(payment_checks),\n            card_network: None,\n            domestic_network: None,\n            auth_code: None,\n        }\n    })\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs"}, {"query": "payment authorization request data structure", "code": "pub mod authentication;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\npub mod unified_authentication_service;\nuse api_models::payments::{AdditionalPaymentData, AddressDetails, RequestSurchargeDetails};\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    consts, errors,\n    ext_traits::OptionExt,\n    id_type, payout_method_utils, pii,\n    types::{MinorUnit, SemanticVersion},\n};\nuse diesel_models::{enums as storage_enums, types::OrderDetailsWithAmount};\nuse error_stack::ResultExt;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\n\nuse super::payment_method_data::PaymentMethodData;\nuse crate::{\n    address,\n    errors::api_error_response::{ApiErrorResponse, NotImplementedMessage},\n    mandates,\n    payment_method_data::ExternalVaultPaymentMethodData,\n    payments,\n    router_data::{self, AccessTokenAuthenticationResponse, RouterData},\n    router_flow_types as flows, router_response_types as response_types,\n    vault::PaymentMethodCustomVaultingData,\n};\n#[derive(Debug, Clone, Serialize)]\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Opt\n\n... [truncated 64898 chars] ...\n\nstomerId>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub payment_channel: Option<storage_enums::PaymentChannel>,\n    pub is_stored_credential: Option<bool>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n}\n\n#[derive(Debug, Clone)]\npub struct VaultRequestData {\n    pub payment_method_vaulting_data: Option<PaymentMethodCustomVaultingData>,\n    pub connector_vault_id: Option<String>,\n    pub connector_customer_id: Option<String>,\n    pub should_generate_multiple_tokens: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct DisputeSyncData {\n    pub dispute_id: String,\n    pub connector_dispute_id: String,\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_request_types.rs", "file": "crates__hyperswitch_domain_models__src__router_request_types.rs"}, {"query": "PaymentsAuthorizeData struct definition", "code": "pub mod authentication;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\npub mod unified_authentication_service;\nuse api_models::payments::{AdditionalPaymentData, AddressDetails, RequestSurchargeDetails};\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    consts, errors,\n    ext_traits::OptionExt,\n    id_type, payout_method_utils, pii,\n    types::{MinorUnit, SemanticVersion},\n};\nuse diesel_models::{enums as storage_enums, types::OrderDetailsWithAmount};\nuse error_stack::ResultExt;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\n\nuse super::payment_method_data::PaymentMethodData;\nuse crate::{\n    address,\n    errors::api_error_response::{ApiErrorResponse, NotImplementedMessage},\n    mandates,\n    payment_method_data::ExternalVaultPaymentMethodData,\n    payments,\n    router_data::{self, AccessTokenAuthenticationResponse, RouterData},\n    router_flow_types as flows, router_response_types as response_types,\n    vault::PaymentMethodCustomVaultingData,\n};\n#[derive(Debug, Clone, Serialize)]\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Opt\n\n... [truncated 64898 chars] ...\n\nstomerId>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub payment_channel: Option<storage_enums::PaymentChannel>,\n    pub is_stored_credential: Option<bool>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n}\n\n#[derive(Debug, Clone)]\npub struct VaultRequestData {\n    pub payment_method_vaulting_data: Option<PaymentMethodCustomVaultingData>,\n    pub connector_vault_id: Option<String>,\n    pub connector_customer_id: Option<String>,\n    pub should_generate_multiple_tokens: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct DisputeSyncData {\n    pub dispute_id: String,\n    pub connector_dispute_id: String,\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_request_types.rs", "file": "crates__hyperswitch_domain_models__src__router_request_types.rs"}, {"query": "how to handle payment surcharge details", "code": "pub mod authentication;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\npub mod unified_authentication_service;\nuse api_models::payments::{AdditionalPaymentData, AddressDetails, RequestSurchargeDetails};\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    consts, errors,\n    ext_traits::OptionExt,\n    id_type, payout_method_utils, pii,\n    types::{MinorUnit, SemanticVersion},\n};\nuse diesel_models::{enums as storage_enums, types::OrderDetailsWithAmount};\nuse error_stack::ResultExt;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\n\nuse super::payment_method_data::PaymentMethodData;\nuse crate::{\n    address,\n    errors::api_error_response::{ApiErrorResponse, NotImplementedMessage},\n    mandates,\n    payment_method_data::ExternalVaultPaymentMethodData,\n    payments,\n    router_data::{self, AccessTokenAuthenticationResponse, RouterData},\n    router_flow_types as flows, router_response_types as response_types,\n    vault::PaymentMethodCustomVaultingData,\n};\n#[derive(Debug, Clone, Serialize)]\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Opt\n\n... [truncated 64898 chars] ...\n\nstomerId>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub payment_channel: Option<storage_enums::PaymentChannel>,\n    pub is_stored_credential: Option<bool>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n}\n\n#[derive(Debug, Clone)]\npub struct VaultRequestData {\n    pub payment_method_vaulting_data: Option<PaymentMethodCustomVaultingData>,\n    pub connector_vault_id: Option<String>,\n    pub connector_customer_id: Option<String>,\n    pub should_generate_multiple_tokens: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct DisputeSyncData {\n    pub dispute_id: String,\n    pub connector_dispute_id: String,\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_request_types.rs", "file": "crates__hyperswitch_domain_models__src__router_request_types.rs"}, {"query": "payment capture request types rust", "code": "pub mod authentication;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\npub mod unified_authentication_service;\nuse api_models::payments::{AdditionalPaymentData, AddressDetails, RequestSurchargeDetails};\nuse common_types::payments as common_payments_types;\nuse common_utils::{\n    consts, errors,\n    ext_traits::OptionExt,\n    id_type, payout_method_utils, pii,\n    types::{MinorUnit, SemanticVersion},\n};\nuse diesel_models::{enums as storage_enums, types::OrderDetailsWithAmount};\nuse error_stack::ResultExt;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\n\nuse super::payment_method_data::PaymentMethodData;\nuse crate::{\n    address,\n    errors::api_error_response::{ApiErrorResponse, NotImplementedMessage},\n    mandates,\n    payment_method_data::ExternalVaultPaymentMethodData,\n    payments,\n    router_data::{self, AccessTokenAuthenticationResponse, RouterData},\n    router_flow_types as flows, router_response_types as response_types,\n    vault::PaymentMethodCustomVaultingData,\n};\n#[derive(Debug, Clone, Serialize)]\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Opt\n\n... [truncated 64898 chars] ...\n\nstomerId>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub payment_channel: Option<storage_enums::PaymentChannel>,\n    pub is_stored_credential: Option<bool>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n}\n\n#[derive(Debug, Clone)]\npub struct VaultRequestData {\n    pub payment_method_vaulting_data: Option<PaymentMethodCustomVaultingData>,\n    pub connector_vault_id: Option<String>,\n    pub connector_customer_id: Option<String>,\n    pub should_generate_multiple_tokens: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct DisputeSyncData {\n    pub dispute_id: String,\n    pub connector_dispute_id: String,\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_request_types.rs", "file": "crates__hyperswitch_domain_models__src__router_request_types.rs"}, {"query": "how does 3dsecure.io integration work", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhook\n\n... [truncated 15787 chars] ...\n\n   PreAuthNRequestData,\n        AuthenticationResponseData,\n    > for Threedsecureio\n{\n}\n\nstatic THREEDSECUREIO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"3dsecure.io\",\n    description: \"3DSecure.io is a service that facilitates 3-D Secure verifications for online credit and debit card transactions through a simple JSON API, enhancing payment security for merchants.docs.3dsecure.io3dsecure.io\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Threedsecureio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&THREEDSECUREIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__threedsecureio.rs", "file": "crates__hyperswitch_connectors__src__connectors__threedsecureio.rs"}, {"query": "Threedsecureio struct implementation", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhook\n\n... [truncated 15787 chars] ...\n\n   PreAuthNRequestData,\n        AuthenticationResponseData,\n    > for Threedsecureio\n{\n}\n\nstatic THREEDSECUREIO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"3dsecure.io\",\n    description: \"3DSecure.io is a service that facilitates 3-D Secure verifications for online credit and debit card transactions through a simple JSON API, enhancing payment security for merchants.docs.3dsecure.io3dsecure.io\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Threedsecureio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&THREEDSECUREIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__threedsecureio.rs", "file": "crates__hyperswitch_connectors__src__connectors__threedsecureio.rs"}, {"query": "how to implement 3D Secure authentication", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhook\n\n... [truncated 15787 chars] ...\n\n   PreAuthNRequestData,\n        AuthenticationResponseData,\n    > for Threedsecureio\n{\n}\n\nstatic THREEDSECUREIO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"3dsecure.io\",\n    description: \"3DSecure.io is a service that facilitates 3-D Secure verifications for online credit and debit card transactions through a simple JSON API, enhancing payment security for merchants.docs.3dsecure.io3dsecure.io\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Threedsecureio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&THREEDSECUREIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__threedsecureio.rs", "file": "crates__hyperswitch_connectors__src__connectors__threedsecureio.rs"}, {"query": "Hyperswitch 3dsecureio connector", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhook\n\n... [truncated 15787 chars] ...\n\n   PreAuthNRequestData,\n        AuthenticationResponseData,\n    > for Threedsecureio\n{\n}\n\nstatic THREEDSECUREIO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"3dsecure.io\",\n    description: \"3DSecure.io is a service that facilitates 3-D Secure verifications for online credit and debit card transactions through a simple JSON API, enhancing payment security for merchants.docs.3dsecure.io3dsecure.io\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Threedsecureio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&THREEDSECUREIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__threedsecureio.rs", "file": "crates__hyperswitch_connectors__src__connectors__threedsecureio.rs"}, {"query": "gocardless payment status mapping", "code": "use common_enums::{enums, CountryAlpha2, UsStatesAbbreviation};\nuse common_utils::{\n    id_type,\n    pii::{self, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{\n        ConnectorCustomerData, PaymentMethodTokenizationData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CustomerData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\npub struct GocardlessRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for GocardlessRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomerRequest {\n    customers: GocardlessCustomer,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomer {\n    address_line1: Option<Secret<String>>,\n    address_line2: Option<Secret<String>>,\n    address_line3: Option<Secret<String>>,\n    city: Option<Secret<String>>,\n    region: Option<Secret<String>>,\n    country_code: Option<CountryAlpha2>,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    metadata: CustomerMetaData,\n    danish_identity_number: Option<Secre\n\n... [truncated 28274 chars] ...\n\nmatch action {\n                PaymentsAction::CustomerApprovalGranted | PaymentsAction::Submitted => {\n                    Ok(Self::Submitted)\n                }\n                PaymentsAction::CustomerApprovalDenied => Ok(Self::CustomerApprovalDenied),\n                PaymentsAction::LateFailureSettled => Ok(Self::Failed),\n                PaymentsAction::Failed => Ok(Self::Failed),\n                PaymentsAction::Cancelled => Ok(Self::Cancelled),\n                PaymentsAction::Confirmed => Ok(Self::Confirmed),\n                PaymentsAction::PaidOut => Ok(Self::PaidOut),\n                PaymentsAction::SurchargeFeeDebited\n                | PaymentsAction::ResubmissionRequired\n                | PaymentsAction::Created => Err(errors::ConnectorError::WebhookEventTypeNotFound)?,\n            },\n            WebhookAction::RefundsAction(_) | WebhookAction::MandatesAction(_) => {\n                Err(errors::ConnectorError::WebhookEventTypeNotFound)?\n            }\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs"}, {"query": "GoCardless customer request transformer", "code": "use common_enums::{enums, CountryAlpha2, UsStatesAbbreviation};\nuse common_utils::{\n    id_type,\n    pii::{self, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{\n        ConnectorCustomerData, PaymentMethodTokenizationData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CustomerData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\npub struct GocardlessRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for GocardlessRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomerRequest {\n    customers: GocardlessCustomer,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomer {\n    address_line1: Option<Secret<String>>,\n    address_line2: Option<Secret<String>>,\n    address_line3: Option<Secret<String>>,\n    city: Option<Secret<String>>,\n    region: Option<Secret<String>>,\n    country_code: Option<CountryAlpha2>,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    metadata: CustomerMetaData,\n    danish_identity_number: Option<Secre\n\n... [truncated 28274 chars] ...\n\nmatch action {\n                PaymentsAction::CustomerApprovalGranted | PaymentsAction::Submitted => {\n                    Ok(Self::Submitted)\n                }\n                PaymentsAction::CustomerApprovalDenied => Ok(Self::CustomerApprovalDenied),\n                PaymentsAction::LateFailureSettled => Ok(Self::Failed),\n                PaymentsAction::Failed => Ok(Self::Failed),\n                PaymentsAction::Cancelled => Ok(Self::Cancelled),\n                PaymentsAction::Confirmed => Ok(Self::Confirmed),\n                PaymentsAction::PaidOut => Ok(Self::PaidOut),\n                PaymentsAction::SurchargeFeeDebited\n                | PaymentsAction::ResubmissionRequired\n                | PaymentsAction::Created => Err(errors::ConnectorError::WebhookEventTypeNotFound)?,\n            },\n            WebhookAction::RefundsAction(_) | WebhookAction::MandatesAction(_) => {\n                Err(errors::ConnectorError::WebhookEventTypeNotFound)?\n            }\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs"}, {"query": "transform hyperswitch to gocardless", "code": "use common_enums::{enums, CountryAlpha2, UsStatesAbbreviation};\nuse common_utils::{\n    id_type,\n    pii::{self, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{\n        ConnectorCustomerData, PaymentMethodTokenizationData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CustomerData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\npub struct GocardlessRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for GocardlessRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomerRequest {\n    customers: GocardlessCustomer,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomer {\n    address_line1: Option<Secret<String>>,\n    address_line2: Option<Secret<String>>,\n    address_line3: Option<Secret<String>>,\n    city: Option<Secret<String>>,\n    region: Option<Secret<String>>,\n    country_code: Option<CountryAlpha2>,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    metadata: CustomerMetaData,\n    danish_identity_number: Option<Secre\n\n... [truncated 28274 chars] ...\n\nmatch action {\n                PaymentsAction::CustomerApprovalGranted | PaymentsAction::Submitted => {\n                    Ok(Self::Submitted)\n                }\n                PaymentsAction::CustomerApprovalDenied => Ok(Self::CustomerApprovalDenied),\n                PaymentsAction::LateFailureSettled => Ok(Self::Failed),\n                PaymentsAction::Failed => Ok(Self::Failed),\n                PaymentsAction::Cancelled => Ok(Self::Cancelled),\n                PaymentsAction::Confirmed => Ok(Self::Confirmed),\n                PaymentsAction::PaidOut => Ok(Self::PaidOut),\n                PaymentsAction::SurchargeFeeDebited\n                | PaymentsAction::ResubmissionRequired\n                | PaymentsAction::Created => Err(errors::ConnectorError::WebhookEventTypeNotFound)?,\n            },\n            WebhookAction::RefundsAction(_) | WebhookAction::MandatesAction(_) => {\n                Err(errors::ConnectorError::WebhookEventTypeNotFound)?\n            }\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs"}, {"query": "gocardless webhook event handler", "code": "use common_enums::{enums, CountryAlpha2, UsStatesAbbreviation};\nuse common_utils::{\n    id_type,\n    pii::{self, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{\n        ConnectorCustomerData, PaymentMethodTokenizationData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CustomerData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\npub struct GocardlessRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for GocardlessRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomerRequest {\n    customers: GocardlessCustomer,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomer {\n    address_line1: Option<Secret<String>>,\n    address_line2: Option<Secret<String>>,\n    address_line3: Option<Secret<String>>,\n    city: Option<Secret<String>>,\n    region: Option<Secret<String>>,\n    country_code: Option<CountryAlpha2>,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    metadata: CustomerMetaData,\n    danish_identity_number: Option<Secre\n\n... [truncated 28274 chars] ...\n\nmatch action {\n                PaymentsAction::CustomerApprovalGranted | PaymentsAction::Submitted => {\n                    Ok(Self::Submitted)\n                }\n                PaymentsAction::CustomerApprovalDenied => Ok(Self::CustomerApprovalDenied),\n                PaymentsAction::LateFailureSettled => Ok(Self::Failed),\n                PaymentsAction::Failed => Ok(Self::Failed),\n                PaymentsAction::Cancelled => Ok(Self::Cancelled),\n                PaymentsAction::Confirmed => Ok(Self::Confirmed),\n                PaymentsAction::PaidOut => Ok(Self::PaidOut),\n                PaymentsAction::SurchargeFeeDebited\n                | PaymentsAction::ResubmissionRequired\n                | PaymentsAction::Created => Err(errors::ConnectorError::WebhookEventTypeNotFound)?,\n            },\n            WebhookAction::RefundsAction(_) | WebhookAction::MandatesAction(_) => {\n                Err(errors::ConnectorError::WebhookEventTypeNotFound)?\n            }\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs"}, {"query": "Sift payment gateway integration hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as sift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Sift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Sift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Sift {}\nimpl api::PaymentSession for Sift {}\nimpl \n\n... [truncated 18419 chars] ...\n\nonnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic SIFT_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic SIFT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Sift\",\n    description: \"Sift connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic SIFT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Sift {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SIFT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SIFT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&SIFT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__sift.rs", "file": "crates__hyperswitch_connectors__src__connectors__sift.rs"}, {"query": "hyperswitch sift connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as sift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Sift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Sift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Sift {}\nimpl api::PaymentSession for Sift {}\nimpl \n\n... [truncated 18419 chars] ...\n\nonnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic SIFT_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic SIFT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Sift\",\n    description: \"Sift connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic SIFT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Sift {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SIFT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SIFT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&SIFT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__sift.rs", "file": "crates__hyperswitch_connectors__src__connectors__sift.rs"}, {"query": "how to add new payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as sift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Sift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Sift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Sift {}\nimpl api::PaymentSession for Sift {}\nimpl \n\n... [truncated 18419 chars] ...\n\nonnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic SIFT_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic SIFT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Sift\",\n    description: \"Sift connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic SIFT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Sift {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SIFT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SIFT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&SIFT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__sift.rs", "file": "crates__hyperswitch_connectors__src__connectors__sift.rs"}, {"query": "Sift fraud detection API hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as sift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Sift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Sift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Sift {}\nimpl api::PaymentSession for Sift {}\nimpl \n\n... [truncated 18419 chars] ...\n\nonnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic SIFT_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic SIFT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Sift\",\n    description: \"Sift connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic SIFT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Sift {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SIFT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SIFT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&SIFT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__sift.rs", "file": "crates__hyperswitch_connectors__src__connectors__sift.rs"}, {"query": "how does the Boku payment connector work", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, OptionExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface, Secret, WithType};\nuse ring::hmac;\nuse router_env::logger;\nuse time::OffsetDateTime;\nuse transformers as boku;\n\nuse crate::{\n    constants::{headers, UNSUPPORTED_ERROR_MESSAGE},\n    metrics,\n    types::ResponseRouterData,\n    utils::convert_amount,\n\n... [truncated 24559 chars] ...\n\n         specific_features: None,\n        },\n    );\n\n    boku_supported_payment_methods\n});\n\nstatic BOKU_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Boku\",\n    description: \"Boku, Inc. is a mobile payments company that allows businesses to collect online payments through both carrier billing and mobile wallets.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic BOKU_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Boku {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BOKU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BOKU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BOKU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__boku.rs", "file": "crates__hyperswitch_connectors__src__connectors__boku.rs"}, {"query": "Boku payment integration Rust hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, OptionExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface, Secret, WithType};\nuse ring::hmac;\nuse router_env::logger;\nuse time::OffsetDateTime;\nuse transformers as boku;\n\nuse crate::{\n    constants::{headers, UNSUPPORTED_ERROR_MESSAGE},\n    metrics,\n    types::ResponseRouterData,\n    utils::convert_amount,\n\n... [truncated 24559 chars] ...\n\n         specific_features: None,\n        },\n    );\n\n    boku_supported_payment_methods\n});\n\nstatic BOKU_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Boku\",\n    description: \"Boku, Inc. is a mobile payments company that allows businesses to collect online payments through both carrier billing and mobile wallets.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic BOKU_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Boku {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BOKU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BOKU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BOKU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__boku.rs", "file": "crates__hyperswitch_connectors__src__connectors__boku.rs"}, {"query": "implement Boku payment method hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, OptionExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface, Secret, WithType};\nuse ring::hmac;\nuse router_env::logger;\nuse time::OffsetDateTime;\nuse transformers as boku;\n\nuse crate::{\n    constants::{headers, UNSUPPORTED_ERROR_MESSAGE},\n    metrics,\n    types::ResponseRouterData,\n    utils::convert_amount,\n\n... [truncated 24559 chars] ...\n\n         specific_features: None,\n        },\n    );\n\n    boku_supported_payment_methods\n});\n\nstatic BOKU_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Boku\",\n    description: \"Boku, Inc. is a mobile payments company that allows businesses to collect online payments through both carrier billing and mobile wallets.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic BOKU_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Boku {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BOKU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BOKU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BOKU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__boku.rs", "file": "crates__hyperswitch_connectors__src__connectors__boku.rs"}, {"query": "Boku connector authentication and webhook handling", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, OptionExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface, Secret, WithType};\nuse ring::hmac;\nuse router_env::logger;\nuse time::OffsetDateTime;\nuse transformers as boku;\n\nuse crate::{\n    constants::{headers, UNSUPPORTED_ERROR_MESSAGE},\n    metrics,\n    types::ResponseRouterData,\n    utils::convert_amount,\n\n... [truncated 24559 chars] ...\n\n         specific_features: None,\n        },\n    );\n\n    boku_supported_payment_methods\n});\n\nstatic BOKU_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Boku\",\n    description: \"Boku, Inc. is a mobile payments company that allows businesses to collect online payments through both carrier billing and mobile wallets.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic BOKU_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Boku {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BOKU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BOKU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BOKU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__boku.rs", "file": "crates__hyperswitch_connectors__src__connectors__boku.rs"}, {"query": "how to implement paybox payment request transformation", "code": "use bytes::Bytes;\nuse common_enums::enums;\nuse common_utils::{\n    date_time::DateFormat, errors::CustomResult, ext_traits::ValueExt, types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, CardMandateInfo, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\npub struct PayboxRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayboxRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst AUTH_REQUEST: &str = \"00001\";\nconst CAPTURE_REQUEST: &str = \"00002\";\nconst AUTH_AND_CAPTURE_REQUEST: &str = \"00003\";\nconst SYNC_REQUEST: &str = \"00017\";\nconst REFUND_REQUEST: &str = \"00014\";\nconst SUCCESS_CODE: &str = \"00000\";\nconst VERSION_PAYBOX: &str = \"00104\";\nconst PAY_ORIGIN_INTERNET: &str = \"024\";\nconst THREE_DS_FAIL_CODE: &str = \"00000000\";\nconst RECURRING_ORIGIN: &str = \"027\";\nconst MANDATE_REQUEST: &str = \"00056\";\nconst MANDATE_AUTH_ONLY: &str = \"00051\";\nconst MANDATE_AUTH_AND_CAPTURE_ONLY: &str = \"00053\";\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PayboxPaymentsRequest {\n    C\n\n... [truncated 44576 chars] ...\n\n       site: auth_data.site,\n            rank: auth_data.rang,\n            key: auth_data.cle,\n            customer_id: Secret::new(\n                item.router_data\n                    .request\n                    .get_connector_mandate_request_reference_id()?,\n            ),\n            carrier_id: Secret::new(item.router_data.request.get_connector_mandate_id()?),\n            cc_exp_date: get_card_expiry_month_year_2_digit(\n                card_mandate_info.card_exp_month.clone(),\n                card_mandate_info.card_exp_year.clone(),\n            )?,\n        })\n    }\n}\n\nfn get_card_expiry_month_year_2_digit(\n    card_exp_month: Secret<String>,\n    card_exp_year: Secret<String>,\n) -> Result<Secret<String>, errors::ConnectorError> {\n    Ok(Secret::new(format!(\n        \"{}{}\",\n        card_exp_month.peek(),\n        card_exp_year\n            .peek()\n            .get(card_exp_year.peek().len() - 2..)\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n    )))\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs"}, {"query": "PayboxPaymentsRequest struct definition", "code": "use bytes::Bytes;\nuse common_enums::enums;\nuse common_utils::{\n    date_time::DateFormat, errors::CustomResult, ext_traits::ValueExt, types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, CardMandateInfo, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\npub struct PayboxRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayboxRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst AUTH_REQUEST: &str = \"00001\";\nconst CAPTURE_REQUEST: &str = \"00002\";\nconst AUTH_AND_CAPTURE_REQUEST: &str = \"00003\";\nconst SYNC_REQUEST: &str = \"00017\";\nconst REFUND_REQUEST: &str = \"00014\";\nconst SUCCESS_CODE: &str = \"00000\";\nconst VERSION_PAYBOX: &str = \"00104\";\nconst PAY_ORIGIN_INTERNET: &str = \"024\";\nconst THREE_DS_FAIL_CODE: &str = \"00000000\";\nconst RECURRING_ORIGIN: &str = \"027\";\nconst MANDATE_REQUEST: &str = \"00056\";\nconst MANDATE_AUTH_ONLY: &str = \"00051\";\nconst MANDATE_AUTH_AND_CAPTURE_ONLY: &str = \"00053\";\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PayboxPaymentsRequest {\n    C\n\n... [truncated 44576 chars] ...\n\n       site: auth_data.site,\n            rank: auth_data.rang,\n            key: auth_data.cle,\n            customer_id: Secret::new(\n                item.router_data\n                    .request\n                    .get_connector_mandate_request_reference_id()?,\n            ),\n            carrier_id: Secret::new(item.router_data.request.get_connector_mandate_id()?),\n            cc_exp_date: get_card_expiry_month_year_2_digit(\n                card_mandate_info.card_exp_month.clone(),\n                card_mandate_info.card_exp_year.clone(),\n            )?,\n        })\n    }\n}\n\nfn get_card_expiry_month_year_2_digit(\n    card_exp_month: Secret<String>,\n    card_exp_year: Secret<String>,\n) -> Result<Secret<String>, errors::ConnectorError> {\n    Ok(Secret::new(format!(\n        \"{}{}\",\n        card_exp_month.peek(),\n        card_exp_year\n            .peek()\n            .get(card_exp_year.peek().len() - 2..)\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n    )))\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs"}, {"query": "transform hyperswitch payments to paybox format", "code": "use bytes::Bytes;\nuse common_enums::enums;\nuse common_utils::{\n    date_time::DateFormat, errors::CustomResult, ext_traits::ValueExt, types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, CardMandateInfo, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\npub struct PayboxRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayboxRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst AUTH_REQUEST: &str = \"00001\";\nconst CAPTURE_REQUEST: &str = \"00002\";\nconst AUTH_AND_CAPTURE_REQUEST: &str = \"00003\";\nconst SYNC_REQUEST: &str = \"00017\";\nconst REFUND_REQUEST: &str = \"00014\";\nconst SUCCESS_CODE: &str = \"00000\";\nconst VERSION_PAYBOX: &str = \"00104\";\nconst PAY_ORIGIN_INTERNET: &str = \"024\";\nconst THREE_DS_FAIL_CODE: &str = \"00000000\";\nconst RECURRING_ORIGIN: &str = \"027\";\nconst MANDATE_REQUEST: &str = \"00056\";\nconst MANDATE_AUTH_ONLY: &str = \"00051\";\nconst MANDATE_AUTH_AND_CAPTURE_ONLY: &str = \"00053\";\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PayboxPaymentsRequest {\n    C\n\n... [truncated 44576 chars] ...\n\n       site: auth_data.site,\n            rank: auth_data.rang,\n            key: auth_data.cle,\n            customer_id: Secret::new(\n                item.router_data\n                    .request\n                    .get_connector_mandate_request_reference_id()?,\n            ),\n            carrier_id: Secret::new(item.router_data.request.get_connector_mandate_id()?),\n            cc_exp_date: get_card_expiry_month_year_2_digit(\n                card_mandate_info.card_exp_month.clone(),\n                card_mandate_info.card_exp_year.clone(),\n            )?,\n        })\n    }\n}\n\nfn get_card_expiry_month_year_2_digit(\n    card_exp_month: Secret<String>,\n    card_exp_year: Secret<String>,\n) -> Result<Secret<String>, errors::ConnectorError> {\n    Ok(Secret::new(format!(\n        \"{}{}\",\n        card_exp_month.peek(),\n        card_exp_year\n            .peek()\n            .get(card_exp_year.peek().len() - 2..)\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n    )))\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs"}, {"query": "paybox refund request serialization", "code": "use bytes::Bytes;\nuse common_enums::enums;\nuse common_utils::{\n    date_time::DateFormat, errors::CustomResult, ext_traits::ValueExt, types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, CardMandateInfo, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\npub struct PayboxRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayboxRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst AUTH_REQUEST: &str = \"00001\";\nconst CAPTURE_REQUEST: &str = \"00002\";\nconst AUTH_AND_CAPTURE_REQUEST: &str = \"00003\";\nconst SYNC_REQUEST: &str = \"00017\";\nconst REFUND_REQUEST: &str = \"00014\";\nconst SUCCESS_CODE: &str = \"00000\";\nconst VERSION_PAYBOX: &str = \"00104\";\nconst PAY_ORIGIN_INTERNET: &str = \"024\";\nconst THREE_DS_FAIL_CODE: &str = \"00000000\";\nconst RECURRING_ORIGIN: &str = \"027\";\nconst MANDATE_REQUEST: &str = \"00056\";\nconst MANDATE_AUTH_ONLY: &str = \"00051\";\nconst MANDATE_AUTH_AND_CAPTURE_ONLY: &str = \"00053\";\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PayboxPaymentsRequest {\n    C\n\n... [truncated 44576 chars] ...\n\n       site: auth_data.site,\n            rank: auth_data.rang,\n            key: auth_data.cle,\n            customer_id: Secret::new(\n                item.router_data\n                    .request\n                    .get_connector_mandate_request_reference_id()?,\n            ),\n            carrier_id: Secret::new(item.router_data.request.get_connector_mandate_id()?),\n            cc_exp_date: get_card_expiry_month_year_2_digit(\n                card_mandate_info.card_exp_month.clone(),\n                card_mandate_info.card_exp_year.clone(),\n            )?,\n        })\n    }\n}\n\nfn get_card_expiry_month_year_2_digit(\n    card_exp_month: Secret<String>,\n    card_exp_year: Secret<String>,\n) -> Result<Secret<String>, errors::ConnectorError> {\n    Ok(Secret::new(format!(\n        \"{}{}\",\n        card_exp_month.peek(),\n        card_exp_year\n            .peek()\n            .get(card_exp_year.peek().len() - 2..)\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n    )))\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs"}, {"query": "Wells Fargo payout connector implementation", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask as _, Maskable};\n\nuse self::transformers as wellsfargopayout;\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Wellsfargopayout {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Wellsfargopayout {\n    pub fn\n\n... [truncated 17704 chars] ...\n\nomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic WELLSFARGOPAYOUTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wellsfargo Payout\",\n    description: \"Wells Fargo Payouts streamlines secure domestic and international payments for businesses via online banking, supporting Bill Pay, Digital Wires, and Zelle\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Wellsfargopayout {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WELLSFARGOPAYOUTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs"}, {"query": "Wellsfargopayout struct definition", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask as _, Maskable};\n\nuse self::transformers as wellsfargopayout;\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Wellsfargopayout {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Wellsfargopayout {\n    pub fn\n\n... [truncated 17704 chars] ...\n\nomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic WELLSFARGOPAYOUTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wellsfargo Payout\",\n    description: \"Wells Fargo Payouts streamlines secure domestic and international payments for businesses via online banking, supporting Bill Pay, Digital Wires, and Zelle\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Wellsfargopayout {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WELLSFARGOPAYOUTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs"}, {"query": "how to add a new payout connector", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask as _, Maskable};\n\nuse self::transformers as wellsfargopayout;\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Wellsfargopayout {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Wellsfargopayout {\n    pub fn\n\n... [truncated 17704 chars] ...\n\nomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic WELLSFARGOPAYOUTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wellsfargo Payout\",\n    description: \"Wells Fargo Payouts streamlines secure domestic and international payments for businesses via online banking, supporting Bill Pay, Digital Wires, and Zelle\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Wellsfargopayout {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WELLSFARGOPAYOUTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs"}, {"query": "Hyperswitch Wells Fargo integration", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask as _, Maskable};\n\nuse self::transformers as wellsfargopayout;\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Wellsfargopayout {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Wellsfargopayout {\n    pub fn\n\n... [truncated 17704 chars] ...\n\nomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic WELLSFARGOPAYOUTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wellsfargo Payout\",\n    description: \"Wells Fargo Payouts streamlines secure domestic and international payments for businesses via online banking, supporting Bill Pay, Digital Wires, and Zelle\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Wellsfargopayout {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WELLSFARGOPAYOUTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs"}, {"query": "Ebanx connector implementation", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, Request, RequestBuilder};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector};\nuse common_utils::{errors::CustomResult, ext_traits::BytesExt};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::{PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutCancelType, PayoutCreateType, PayoutFulfillType};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse masking::Maskable;\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\nuse transformers as ebanx;\n\n#[cfg(feature = \"pa\n\n... [truncated 13114 chars] ...\n\nlf,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic EBANX_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Ebanx\",\n    description: \"EBANX payout connector for cross-border disbursements and local currency payouts across Latin America, Africa, and emerging markets\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Ebanx {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&EBANX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__ebanx.rs", "file": "crates__hyperswitch_connectors__src__connectors__ebanx.rs"}, {"query": "hyperswitch payout connector", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, Request, RequestBuilder};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector};\nuse common_utils::{errors::CustomResult, ext_traits::BytesExt};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::{PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutCancelType, PayoutCreateType, PayoutFulfillType};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse masking::Maskable;\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\nuse transformers as ebanx;\n\n#[cfg(feature = \"pa\n\n... [truncated 13114 chars] ...\n\nlf,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic EBANX_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Ebanx\",\n    description: \"EBANX payout connector for cross-border disbursements and local currency payouts across Latin America, Africa, and emerging markets\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Ebanx {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&EBANX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__ebanx.rs", "file": "crates__hyperswitch_connectors__src__connectors__ebanx.rs"}, {"query": "how to implement Ebanx payment gateway", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, Request, RequestBuilder};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector};\nuse common_utils::{errors::CustomResult, ext_traits::BytesExt};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::{PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutCancelType, PayoutCreateType, PayoutFulfillType};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse masking::Maskable;\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\nuse transformers as ebanx;\n\n#[cfg(feature = \"pa\n\n... [truncated 13114 chars] ...\n\nlf,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic EBANX_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Ebanx\",\n    description: \"EBANX payout connector for cross-border disbursements and local currency payouts across Latin America, Africa, and emerging markets\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Ebanx {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&EBANX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__ebanx.rs", "file": "crates__hyperswitch_connectors__src__connectors__ebanx.rs"}, {"query": "ebanx disbursement API rust", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, Request, RequestBuilder};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector};\nuse common_utils::{errors::CustomResult, ext_traits::BytesExt};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::{PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutCancelType, PayoutCreateType, PayoutFulfillType};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse masking::Maskable;\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\nuse transformers as ebanx;\n\n#[cfg(feature = \"pa\n\n... [truncated 13114 chars] ...\n\nlf,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic EBANX_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Ebanx\",\n    description: \"EBANX payout connector for cross-border disbursements and local currency payouts across Latin America, Africa, and emerging markets\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Ebanx {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&EBANX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__ebanx.rs", "file": "crates__hyperswitch_connectors__src__connectors__ebanx.rs"}, {"query": "Fiuu payment gateway connector implementation", "code": "pub mod transformers;\n\nuse std::{\n    any::type_name,\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    sync::LazyLock,\n};\n\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::{self as common_errors, CustomResult},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::multipart::Form;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse transformers::{self as fiuu, ExtraParameters, FiuuWebhooksRespons\n\n... [truncated 40923 chars] ...\n\nformerly known as Razer Merchant Services, is a leading online payment gateway in Southeast Asia, offering secure and seamless payment solutions for businesses of all sizes, including credit and debit cards, e-wallets, and bank transfers.\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic FIUU_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 2] = [\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n];\n\nimpl ConnectorSpecifications for Fiuu {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FIUU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FIUU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&FIUU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiuu.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiuu.rs"}, {"query": "hyperswitch Fiuu authorize capture refund", "code": "pub mod transformers;\n\nuse std::{\n    any::type_name,\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    sync::LazyLock,\n};\n\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::{self as common_errors, CustomResult},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::multipart::Form;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse transformers::{self as fiuu, ExtraParameters, FiuuWebhooksRespons\n\n... [truncated 40923 chars] ...\n\nformerly known as Razer Merchant Services, is a leading online payment gateway in Southeast Asia, offering secure and seamless payment solutions for businesses of all sizes, including credit and debit cards, e-wallets, and bank transfers.\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic FIUU_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 2] = [\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n];\n\nimpl ConnectorSpecifications for Fiuu {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FIUU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FIUU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&FIUU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiuu.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiuu.rs"}, {"query": "how to implement Fiuu connector", "code": "pub mod transformers;\n\nuse std::{\n    any::type_name,\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    sync::LazyLock,\n};\n\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::{self as common_errors, CustomResult},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::multipart::Form;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse transformers::{self as fiuu, ExtraParameters, FiuuWebhooksRespons\n\n... [truncated 40923 chars] ...\n\nformerly known as Razer Merchant Services, is a leading online payment gateway in Southeast Asia, offering secure and seamless payment solutions for businesses of all sizes, including credit and debit cards, e-wallets, and bank transfers.\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic FIUU_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 2] = [\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n];\n\nimpl ConnectorSpecifications for Fiuu {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FIUU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FIUU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&FIUU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiuu.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiuu.rs"}, {"query": "Fiuu webhook handler hyperswitch", "code": "pub mod transformers;\n\nuse std::{\n    any::type_name,\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    sync::LazyLock,\n};\n\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::{self as common_errors, CustomResult},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::multipart::Form;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse transformers::{self as fiuu, ExtraParameters, FiuuWebhooksRespons\n\n... [truncated 40923 chars] ...\n\nformerly known as Razer Merchant Services, is a leading online payment gateway in Southeast Asia, offering secure and seamless payment solutions for businesses of all sizes, including credit and debit cards, e-wallets, and bank transfers.\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic FIUU_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 2] = [\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n];\n\nimpl ConnectorSpecifications for Fiuu {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FIUU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FIUU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&FIUU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiuu.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiuu.rs"}, {"query": "hyperswitch envoy connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as envoy;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Envoy {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Envoy {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Envoy {}\nimpl api::PaymentSession for Envoy {}\n\n\n... [truncated 18145 chars] ...\n\nnnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic ENVOY_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic ENVOY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Envoy\",\n    description: \"Envoy connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic ENVOY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Envoy {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ENVOY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ENVOY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ENVOY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__envoy.rs", "file": "crates__hyperswitch_connectors__src__connectors__envoy.rs"}, {"query": "Envoy struct payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as envoy;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Envoy {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Envoy {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Envoy {}\nimpl api::PaymentSession for Envoy {}\n\n\n... [truncated 18145 chars] ...\n\nnnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic ENVOY_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic ENVOY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Envoy\",\n    description: \"Envoy connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic ENVOY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Envoy {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ENVOY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ENVOY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ENVOY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__envoy.rs", "file": "crates__hyperswitch_connectors__src__connectors__envoy.rs"}, {"query": "how to add new connector to hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as envoy;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Envoy {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Envoy {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Envoy {}\nimpl api::PaymentSession for Envoy {}\n\n\n... [truncated 18145 chars] ...\n\nnnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic ENVOY_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic ENVOY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Envoy\",\n    description: \"Envoy connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic ENVOY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Envoy {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ENVOY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ENVOY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ENVOY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__envoy.rs", "file": "crates__hyperswitch_connectors__src__connectors__envoy.rs"}, {"query": "hyperswitch payment orchestration envoy", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as envoy;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Envoy {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Envoy {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Envoy {}\nimpl api::PaymentSession for Envoy {}\n\n\n... [truncated 18145 chars] ...\n\nnnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic ENVOY_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic ENVOY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Envoy\",\n    description: \"Envoy connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic ENVOY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Envoy {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ENVOY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ENVOY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ENVOY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__envoy.rs", "file": "crates__hyperswitch_connectors__src__connectors__envoy.rs"}, {"query": "IATAPay payment integration hyperswitch", "code": "use std::collections::HashMap;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult, ext_traits::Encode, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData, RealTimePaymentData, UpiData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        Authorize,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{Secret, SwitchStrategy};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        get_unimplemented_payment_method_error_message, is_payment_failure, is_refund_failure,\n        PaymentsAuthorizeRequestData, RefundsRequestData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n// Every access token will be valid for 5 minutes. It contains grant_type and scope for different type of access, but for our usecases it should be only 'client_credentials' and 'payment' resp(as per doc) for all type of api call.\n#[derive(Debug, Serialize)]\npub struct IatapayAuthUpdateRequest {\n    grant_type: String,\n    scope: String,\n}\nimpl TryFrom<&types::RefreshTokenRouterData> for IatapayAuthUpdateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]\npub struct IatapayRouterData<T> {\n    amount: FloatMajorUnit,\n    router_data:\n\n... [truncated 22808 chars] ...\n\nayRefundWebhookStatus::Settled => Ok(Self::RefundSuccess),\n                IatapayRefundWebhookStatus::Failed => Ok(Self::RefundFailure),\n                IatapayRefundWebhookStatus::Created\n                | IatapayRefundWebhookStatus::Locked\n                | IatapayRefundWebhookStatus::Initiated\n                | IatapayRefundWebhookStatus::Unknown => Ok(Self::EventNotSupported),\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum IatapayWebhookStatus {\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    Tobeinvestigated,\n    Blocked,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum IatapayRefundWebhookStatus {\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Failed,\n    Cleared,\n    Locked,\n    #[serde(other)]\n    Unknown,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs"}, {"query": "IatapayRouterData struct definition", "code": "use std::collections::HashMap;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult, ext_traits::Encode, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData, RealTimePaymentData, UpiData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        Authorize,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{Secret, SwitchStrategy};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        get_unimplemented_payment_method_error_message, is_payment_failure, is_refund_failure,\n        PaymentsAuthorizeRequestData, RefundsRequestData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n// Every access token will be valid for 5 minutes. It contains grant_type and scope for different type of access, but for our usecases it should be only 'client_credentials' and 'payment' resp(as per doc) for all type of api call.\n#[derive(Debug, Serialize)]\npub struct IatapayAuthUpdateRequest {\n    grant_type: String,\n    scope: String,\n}\nimpl TryFrom<&types::RefreshTokenRouterData> for IatapayAuthUpdateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]\npub struct IatapayRouterData<T> {\n    amount: FloatMajorUnit,\n    router_data:\n\n... [truncated 22808 chars] ...\n\nayRefundWebhookStatus::Settled => Ok(Self::RefundSuccess),\n                IatapayRefundWebhookStatus::Failed => Ok(Self::RefundFailure),\n                IatapayRefundWebhookStatus::Created\n                | IatapayRefundWebhookStatus::Locked\n                | IatapayRefundWebhookStatus::Initiated\n                | IatapayRefundWebhookStatus::Unknown => Ok(Self::EventNotSupported),\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum IatapayWebhookStatus {\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    Tobeinvestigated,\n    Blocked,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum IatapayRefundWebhookStatus {\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Failed,\n    Cleared,\n    Locked,\n    #[serde(other)]\n    Unknown,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs"}, {"query": "how to implement IATAPay refunds", "code": "use std::collections::HashMap;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult, ext_traits::Encode, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData, RealTimePaymentData, UpiData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        Authorize,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{Secret, SwitchStrategy};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        get_unimplemented_payment_method_error_message, is_payment_failure, is_refund_failure,\n        PaymentsAuthorizeRequestData, RefundsRequestData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n// Every access token will be valid for 5 minutes. It contains grant_type and scope for different type of access, but for our usecases it should be only 'client_credentials' and 'payment' resp(as per doc) for all type of api call.\n#[derive(Debug, Serialize)]\npub struct IatapayAuthUpdateRequest {\n    grant_type: String,\n    scope: String,\n}\nimpl TryFrom<&types::RefreshTokenRouterData> for IatapayAuthUpdateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]\npub struct IatapayRouterData<T> {\n    amount: FloatMajorUnit,\n    router_data:\n\n... [truncated 22808 chars] ...\n\nayRefundWebhookStatus::Settled => Ok(Self::RefundSuccess),\n                IatapayRefundWebhookStatus::Failed => Ok(Self::RefundFailure),\n                IatapayRefundWebhookStatus::Created\n                | IatapayRefundWebhookStatus::Locked\n                | IatapayRefundWebhookStatus::Initiated\n                | IatapayRefundWebhookStatus::Unknown => Ok(Self::EventNotSupported),\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum IatapayWebhookStatus {\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    Tobeinvestigated,\n    Blocked,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum IatapayRefundWebhookStatus {\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Failed,\n    Cleared,\n    Locked,\n    #[serde(other)]\n    Unknown,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs"}, {"query": "IATAPay webhook status mapping", "code": "use std::collections::HashMap;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult, ext_traits::Encode, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData, RealTimePaymentData, UpiData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        Authorize,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{Secret, SwitchStrategy};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        get_unimplemented_payment_method_error_message, is_payment_failure, is_refund_failure,\n        PaymentsAuthorizeRequestData, RefundsRequestData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n// Every access token will be valid for 5 minutes. It contains grant_type and scope for different type of access, but for our usecases it should be only 'client_credentials' and 'payment' resp(as per doc) for all type of api call.\n#[derive(Debug, Serialize)]\npub struct IatapayAuthUpdateRequest {\n    grant_type: String,\n    scope: String,\n}\nimpl TryFrom<&types::RefreshTokenRouterData> for IatapayAuthUpdateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]\npub struct IatapayRouterData<T> {\n    amount: FloatMajorUnit,\n    router_data:\n\n... [truncated 22808 chars] ...\n\nayRefundWebhookStatus::Settled => Ok(Self::RefundSuccess),\n                IatapayRefundWebhookStatus::Failed => Ok(Self::RefundFailure),\n                IatapayRefundWebhookStatus::Created\n                | IatapayRefundWebhookStatus::Locked\n                | IatapayRefundWebhookStatus::Initiated\n                | IatapayRefundWebhookStatus::Unknown => Ok(Self::EventNotSupported),\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum IatapayWebhookStatus {\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    Tobeinvestigated,\n    Blocked,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum IatapayRefundWebhookStatus {\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Failed,\n    Cleared,\n    Locked,\n    #[serde(other)]\n    Unknown,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs"}, {"query": "Signifyd webhook integration", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{AttemptStatus, Currency, FraudCheckStatus, PaymentMethod};\nuse common_utils::{ext_traits::ValueExt, pii::Email};\nuse error_stack::{self, ResultExt};\npub use hyperswitch_domain_models::router_request_types::fraud_check::RefundMethod;\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::Fulfillment,\n    router_request_types::{\n        fraud_check::{self, FraudCheckFulfillmentData, FrmFulfillmentRequest},\n        ResponseId,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse num_traits::ToPrimitive;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    types::{\n        FrmCheckoutRouterData, FrmFulfillmentRouterData, FrmRecordReturnRouterData,\n        FrmSaleRouterData, FrmTransactionRouterData, ResponseRouterData,\n    },\n    utils::{\n        AddressDetailsData as _, FraudCheckCheckoutRequest, FraudCheckRecordReturnRequest as _,\n        FraudCheckSaleRequest as _, FraudCheckTransactionRequest as _, RouterData as _,\n    },\n};\n#[allow(dead_code)]\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum DecisionDelivery {\n    Sync,\n    AsyncOnly,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]\npub enum OrderChannel {\n  \n\n... [truncated 22127 chars] ...\n\n         method: item.request.refund_method.clone(),\n            amount: item.request.amount.to_string(),\n            currency,\n        };\n        Ok(Self {\n            return_id: uuid::Uuid::new_v4().to_string(),\n            refund_transaction_id: item.request.refund_transaction_id.clone(),\n            refund,\n            order_id: item.attempt_id.clone(),\n        })\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SignifydWebhookBody {\n    pub order_id: String,\n    pub review_disposition: ReviewDisposition,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ReviewDisposition {\n    Fraudulent,\n    Good,\n}\n\nimpl From<ReviewDisposition> for IncomingWebhookEvent {\n    fn from(value: ReviewDisposition) -> Self {\n        match value {\n            ReviewDisposition::Fraudulent => Self::FrmRejected,\n            ReviewDisposition::Good => Self::FrmApproved,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "file": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs"}, {"query": "SignifydFraudCheckResponseData struct", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{AttemptStatus, Currency, FraudCheckStatus, PaymentMethod};\nuse common_utils::{ext_traits::ValueExt, pii::Email};\nuse error_stack::{self, ResultExt};\npub use hyperswitch_domain_models::router_request_types::fraud_check::RefundMethod;\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::Fulfillment,\n    router_request_types::{\n        fraud_check::{self, FraudCheckFulfillmentData, FrmFulfillmentRequest},\n        ResponseId,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse num_traits::ToPrimitive;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    types::{\n        FrmCheckoutRouterData, FrmFulfillmentRouterData, FrmRecordReturnRouterData,\n        FrmSaleRouterData, FrmTransactionRouterData, ResponseRouterData,\n    },\n    utils::{\n        AddressDetailsData as _, FraudCheckCheckoutRequest, FraudCheckRecordReturnRequest as _,\n        FraudCheckSaleRequest as _, FraudCheckTransactionRequest as _, RouterData as _,\n    },\n};\n#[allow(dead_code)]\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum DecisionDelivery {\n    Sync,\n    AsyncOnly,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]\npub enum OrderChannel {\n  \n\n... [truncated 22127 chars] ...\n\n         method: item.request.refund_method.clone(),\n            amount: item.request.amount.to_string(),\n            currency,\n        };\n        Ok(Self {\n            return_id: uuid::Uuid::new_v4().to_string(),\n            refund_transaction_id: item.request.refund_transaction_id.clone(),\n            refund,\n            order_id: item.attempt_id.clone(),\n        })\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SignifydWebhookBody {\n    pub order_id: String,\n    pub review_disposition: ReviewDisposition,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ReviewDisposition {\n    Fraudulent,\n    Good,\n}\n\nimpl From<ReviewDisposition> for IncomingWebhookEvent {\n    fn from(value: ReviewDisposition) -> Self {\n        match value {\n            ReviewDisposition::Fraudulent => Self::FrmRejected,\n            ReviewDisposition::Good => Self::FrmApproved,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "file": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs"}, {"query": "how to implement Signifyd payment fraud check", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{AttemptStatus, Currency, FraudCheckStatus, PaymentMethod};\nuse common_utils::{ext_traits::ValueExt, pii::Email};\nuse error_stack::{self, ResultExt};\npub use hyperswitch_domain_models::router_request_types::fraud_check::RefundMethod;\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::Fulfillment,\n    router_request_types::{\n        fraud_check::{self, FraudCheckFulfillmentData, FrmFulfillmentRequest},\n        ResponseId,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse num_traits::ToPrimitive;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    types::{\n        FrmCheckoutRouterData, FrmFulfillmentRouterData, FrmRecordReturnRouterData,\n        FrmSaleRouterData, FrmTransactionRouterData, ResponseRouterData,\n    },\n    utils::{\n        AddressDetailsData as _, FraudCheckCheckoutRequest, FraudCheckRecordReturnRequest as _,\n        FraudCheckSaleRequest as _, FraudCheckTransactionRequest as _, RouterData as _,\n    },\n};\n#[allow(dead_code)]\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum DecisionDelivery {\n    Sync,\n    AsyncOnly,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]\npub enum OrderChannel {\n  \n\n... [truncated 22127 chars] ...\n\n         method: item.request.refund_method.clone(),\n            amount: item.request.amount.to_string(),\n            currency,\n        };\n        Ok(Self {\n            return_id: uuid::Uuid::new_v4().to_string(),\n            refund_transaction_id: item.request.refund_transaction_id.clone(),\n            refund,\n            order_id: item.attempt_id.clone(),\n        })\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SignifydWebhookBody {\n    pub order_id: String,\n    pub review_disposition: ReviewDisposition,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ReviewDisposition {\n    Fraudulent,\n    Good,\n}\n\nimpl From<ReviewDisposition> for IncomingWebhookEvent {\n    fn from(value: ReviewDisposition) -> Self {\n        match value {\n            ReviewDisposition::Fraudulent => Self::FrmRejected,\n            ReviewDisposition::Good => Self::FrmApproved,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "file": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs"}, {"query": "Signifyd webhook event mapping", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{AttemptStatus, Currency, FraudCheckStatus, PaymentMethod};\nuse common_utils::{ext_traits::ValueExt, pii::Email};\nuse error_stack::{self, ResultExt};\npub use hyperswitch_domain_models::router_request_types::fraud_check::RefundMethod;\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::Fulfillment,\n    router_request_types::{\n        fraud_check::{self, FraudCheckFulfillmentData, FrmFulfillmentRequest},\n        ResponseId,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse num_traits::ToPrimitive;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    types::{\n        FrmCheckoutRouterData, FrmFulfillmentRouterData, FrmRecordReturnRouterData,\n        FrmSaleRouterData, FrmTransactionRouterData, ResponseRouterData,\n    },\n    utils::{\n        AddressDetailsData as _, FraudCheckCheckoutRequest, FraudCheckRecordReturnRequest as _,\n        FraudCheckSaleRequest as _, FraudCheckTransactionRequest as _, RouterData as _,\n    },\n};\n#[allow(dead_code)]\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum DecisionDelivery {\n    Sync,\n    AsyncOnly,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]\npub enum OrderChannel {\n  \n\n... [truncated 22127 chars] ...\n\n         method: item.request.refund_method.clone(),\n            amount: item.request.amount.to_string(),\n            currency,\n        };\n        Ok(Self {\n            return_id: uuid::Uuid::new_v4().to_string(),\n            refund_transaction_id: item.request.refund_transaction_id.clone(),\n            refund,\n            order_id: item.attempt_id.clone(),\n        })\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SignifydWebhookBody {\n    pub order_id: String,\n    pub review_disposition: ReviewDisposition,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ReviewDisposition {\n    Fraudulent,\n    Good,\n}\n\nimpl From<ReviewDisposition> for IncomingWebhookEvent {\n    fn from(value: ReviewDisposition) -> Self {\n        match value {\n            ReviewDisposition::Fraudulent => Self::FrmRejected,\n            ReviewDisposition::Good => Self::FrmApproved,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "file": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs"}, {"query": "how does the Tesouro payment connector work", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as tesouro;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self as connector_utils, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Tesouro {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Tesouro {\n    p\n\n... [truncated 33680 chars] ...\n\nme(&*TESOURO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TESOURO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n    ) -> String {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            let max_payment_reference_id_length =\n                tesouro::tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH;\n            nanoid::nanoid!(max_payment_reference_id_length)\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tesouro.rs", "file": "crates__hyperswitch_connectors__src__connectors__tesouro.rs"}, {"query": "Tesouro payment gateway integration Rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as tesouro;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self as connector_utils, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Tesouro {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Tesouro {\n    p\n\n... [truncated 33680 chars] ...\n\nme(&*TESOURO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TESOURO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n    ) -> String {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            let max_payment_reference_id_length =\n                tesouro::tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH;\n            nanoid::nanoid!(max_payment_reference_id_length)\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tesouro.rs", "file": "crates__hyperswitch_connectors__src__connectors__tesouro.rs"}, {"query": "implement payment capture with Tesouro API", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as tesouro;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self as connector_utils, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Tesouro {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Tesouro {\n    p\n\n... [truncated 33680 chars] ...\n\nme(&*TESOURO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TESOURO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n    ) -> String {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            let max_payment_reference_id_length =\n                tesouro::tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH;\n            nanoid::nanoid!(max_payment_reference_id_length)\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tesouro.rs", "file": "crates__hyperswitch_connectors__src__connectors__tesouro.rs"}, {"query": "hyperswitch connector tesouro authentication", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as tesouro;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self as connector_utils, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Tesouro {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Tesouro {\n    p\n\n... [truncated 33680 chars] ...\n\nme(&*TESOURO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TESOURO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n    ) -> String {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            let max_payment_reference_id_length =\n                tesouro::tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH;\n            nanoid::nanoid!(max_payment_reference_id_length)\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tesouro.rs", "file": "crates__hyperswitch_connectors__src__connectors__tesouro.rs"}, {"query": "Payjustnow payment request transformation", "code": "use common_enums::enums;\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{self, RefundsResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _},\n};\n\nconst NO_REFUND_REASON: &str = \"No reason provided\";\n\n//TODO: Fill the struct with respective fields\npub struct PayjustnowRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayjustnowRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowPaymentsRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    request_id: Option<String>,\n    payjustnow: PayjustnowRequest,\n    checkout_total_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowRequest {\n    merchant_order_reference: String,\n    order_amount_cents: MinorUnit,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    order_items: Option<Vec<OrderItem>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer: Option<Customer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<Address>,\n    #[serde(sk\n\n... [truncated 14983 chars] ...\n\nync, PayjustnowRsyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.request_id.clone(),\n                refund_status: enums::RefundStatus::from(item.response.checkout_payment_status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PayjustnowError {\n    pub message: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum PayjustnowErrorResponse {\n    Structured(PayjustnowError),\n    Message(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum PayjustnowWebhookStatus {\n    PaidPendingCallback,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowWebhookDetails {\n    pub checkout_token: String,\n    pub checkout_payment_status: PayjustnowWebhookStatus,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs"}, {"query": "PayjustnowRefundsResponseData struct", "code": "use common_enums::enums;\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{self, RefundsResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _},\n};\n\nconst NO_REFUND_REASON: &str = \"No reason provided\";\n\n//TODO: Fill the struct with respective fields\npub struct PayjustnowRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayjustnowRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowPaymentsRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    request_id: Option<String>,\n    payjustnow: PayjustnowRequest,\n    checkout_total_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowRequest {\n    merchant_order_reference: String,\n    order_amount_cents: MinorUnit,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    order_items: Option<Vec<OrderItem>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer: Option<Customer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<Address>,\n    #[serde(sk\n\n... [truncated 14983 chars] ...\n\nync, PayjustnowRsyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.request_id.clone(),\n                refund_status: enums::RefundStatus::from(item.response.checkout_payment_status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PayjustnowError {\n    pub message: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum PayjustnowErrorResponse {\n    Structured(PayjustnowError),\n    Message(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum PayjustnowWebhookStatus {\n    PaidPendingCallback,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowWebhookDetails {\n    pub checkout_token: String,\n    pub checkout_payment_status: PayjustnowWebhookStatus,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs"}, {"query": "how to implement Payjustnow webhook handler", "code": "use common_enums::enums;\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{self, RefundsResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _},\n};\n\nconst NO_REFUND_REASON: &str = \"No reason provided\";\n\n//TODO: Fill the struct with respective fields\npub struct PayjustnowRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayjustnowRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowPaymentsRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    request_id: Option<String>,\n    payjustnow: PayjustnowRequest,\n    checkout_total_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowRequest {\n    merchant_order_reference: String,\n    order_amount_cents: MinorUnit,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    order_items: Option<Vec<OrderItem>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer: Option<Customer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<Address>,\n    #[serde(sk\n\n... [truncated 14983 chars] ...\n\nync, PayjustnowRsyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.request_id.clone(),\n                refund_status: enums::RefundStatus::from(item.response.checkout_payment_status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PayjustnowError {\n    pub message: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum PayjustnowErrorResponse {\n    Structured(PayjustnowError),\n    Message(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum PayjustnowWebhookStatus {\n    PaidPendingCallback,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowWebhookDetails {\n    pub checkout_token: String,\n    pub checkout_payment_status: PayjustnowWebhookStatus,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs"}, {"query": "Payjustnow PII masking configuration", "code": "use common_enums::enums;\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{self, RefundsResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _},\n};\n\nconst NO_REFUND_REASON: &str = \"No reason provided\";\n\n//TODO: Fill the struct with respective fields\npub struct PayjustnowRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayjustnowRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowPaymentsRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    request_id: Option<String>,\n    payjustnow: PayjustnowRequest,\n    checkout_total_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowRequest {\n    merchant_order_reference: String,\n    order_amount_cents: MinorUnit,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    order_items: Option<Vec<OrderItem>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer: Option<Customer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<Address>,\n    #[serde(sk\n\n... [truncated 14983 chars] ...\n\nync, PayjustnowRsyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.request_id.clone(),\n                refund_status: enums::RefundStatus::from(item.response.checkout_payment_status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PayjustnowError {\n    pub message: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum PayjustnowErrorResponse {\n    Structured(PayjustnowError),\n    Message(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum PayjustnowWebhookStatus {\n    PaidPendingCallback,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowWebhookDetails {\n    pub checkout_token: String,\n    pub checkout_payment_status: PayjustnowWebhookStatus,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs"}, {"query": "Helcim payment connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse masking::{ExposeInterface, Mask};\nuse transformers as helcim;\n\nuse crate::{\n    constants::head\n\n... [truncated 30547 chars] ...\n\n:ResourceIdNotFound)\n        } else {\n            Ok(payment_attempt\n                .get_connector_payment_id()\n                .map(ToString::to_string))\n        }\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn connector_transaction_id(\n        &self,\n        payment_attempt: &PaymentAttempt,\n    ) -> Result<Option<String>, ApiErrorResponse> {\n        use hyperswitch_domain_models::errors::api_error_response::ApiErrorResponse;\n\n        if payment_attempt.get_connector_payment_id().is_none() {\n            let metadata = Self::connector_transaction_id(\n                self,\n                payment_attempt\n                    .connector_metadata\n                    .as_ref()\n                    .map(|connector_metadata| connector_metadata.peek()),\n            );\n            metadata.map_err(|_| ApiErrorResponse::ResourceIdNotFound)\n        } else {\n            Ok(payment_attempt\n                .get_connector_payment_id()\n                .map(ToString::to_string))\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "file": "crates__hyperswitch_connectors__src__connectors__helcim.rs"}, {"query": "Helcim connector API integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse masking::{ExposeInterface, Mask};\nuse transformers as helcim;\n\nuse crate::{\n    constants::head\n\n... [truncated 30547 chars] ...\n\n:ResourceIdNotFound)\n        } else {\n            Ok(payment_attempt\n                .get_connector_payment_id()\n                .map(ToString::to_string))\n        }\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn connector_transaction_id(\n        &self,\n        payment_attempt: &PaymentAttempt,\n    ) -> Result<Option<String>, ApiErrorResponse> {\n        use hyperswitch_domain_models::errors::api_error_response::ApiErrorResponse;\n\n        if payment_attempt.get_connector_payment_id().is_none() {\n            let metadata = Self::connector_transaction_id(\n                self,\n                payment_attempt\n                    .connector_metadata\n                    .as_ref()\n                    .map(|connector_metadata| connector_metadata.peek()),\n            );\n            metadata.map_err(|_| ApiErrorResponse::ResourceIdNotFound)\n        } else {\n            Ok(payment_attempt\n                .get_connector_payment_id()\n                .map(ToString::to_string))\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "file": "crates__hyperswitch_connectors__src__connectors__helcim.rs"}, {"query": "how to implement Helcim payment gateway", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse masking::{ExposeInterface, Mask};\nuse transformers as helcim;\n\nuse crate::{\n    constants::head\n\n... [truncated 30547 chars] ...\n\n:ResourceIdNotFound)\n        } else {\n            Ok(payment_attempt\n                .get_connector_payment_id()\n                .map(ToString::to_string))\n        }\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn connector_transaction_id(\n        &self,\n        payment_attempt: &PaymentAttempt,\n    ) -> Result<Option<String>, ApiErrorResponse> {\n        use hyperswitch_domain_models::errors::api_error_response::ApiErrorResponse;\n\n        if payment_attempt.get_connector_payment_id().is_none() {\n            let metadata = Self::connector_transaction_id(\n                self,\n                payment_attempt\n                    .connector_metadata\n                    .as_ref()\n                    .map(|connector_metadata| connector_metadata.peek()),\n            );\n            metadata.map_err(|_| ApiErrorResponse::ResourceIdNotFound)\n        } else {\n            Ok(payment_attempt\n                .get_connector_payment_id()\n                .map(ToString::to_string))\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "file": "crates__hyperswitch_connectors__src__connectors__helcim.rs"}, {"query": "Helcim webhook handling", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse masking::{ExposeInterface, Mask};\nuse transformers as helcim;\n\nuse crate::{\n    constants::head\n\n... [truncated 30547 chars] ...\n\n:ResourceIdNotFound)\n        } else {\n            Ok(payment_attempt\n                .get_connector_payment_id()\n                .map(ToString::to_string))\n        }\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn connector_transaction_id(\n        &self,\n        payment_attempt: &PaymentAttempt,\n    ) -> Result<Option<String>, ApiErrorResponse> {\n        use hyperswitch_domain_models::errors::api_error_response::ApiErrorResponse;\n\n        if payment_attempt.get_connector_payment_id().is_none() {\n            let metadata = Self::connector_transaction_id(\n                self,\n                payment_attempt\n                    .connector_metadata\n                    .as_ref()\n                    .map(|connector_metadata| connector_metadata.peek()),\n            );\n            metadata.map_err(|_| ApiErrorResponse::ResourceIdNotFound)\n        } else {\n            Ok(payment_attempt\n                .get_connector_payment_id()\n                .map(ToString::to_string))\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "file": "crates__hyperswitch_connectors__src__connectors__helcim.rs"}, {"query": "Santander payment request transformation", "code": "use api_models::payments::{QrCodeInformation, VoucherNextStepData};\nuse common_enums::{\n    enums, AttemptStatus, BoletoDocumentKind, BoletoPaymentType, ExpiryType, PixKey,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, ValueExt},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse crc::{Algorithm, Crc};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankTransferData, BoletoVoucherData, PaymentMethodData, VoucherData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{PaymentsUpdateMetadataData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        PaymentsUpdateMetadataRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::{self},\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            Environment, SantanderAuthRequest, SantanderAuthType, SantanderBoletoCancelOperation,\n            SantanderBoletoCancelRequest, SantanderBoletoPaymentRequest,\n            SantanderBoletoUpdateRequest, SantanderDebtor, SantanderGrantType,\n            SantanderMetadataObject, SantanderPaymentRequest, SantanderPaymentsCancelRequest,\n            SantanderPixCancelRequest, SantanderPixDueDateCalendarRequest,\n            SantanderPixImmediateCalendarRequest, SantanderPixQRPaymentRequest,\n            SantanderPixRequestCalendar, SantanderRefundRequest, SantanderRouterData,\n            SantanderValue,\n        },\n        responses::{\n            Key, NsuComposite, Payer, SanatanderAccessTokenResponse, SanatanderTokenResponse,\n            SantanderAdditionalInfo, SantanderBoletoDocumentKind, SantanderBoletoPay\n\n... [truncated 51519 chars] ...\n\n?)\n}\n\nfn extract_boleto_components(input: &str) -> Result<NsuComposite, errors::ConnectorError> {\n    let parts: Vec<&str> = input.split('.').collect();\n\n    let [nsu_code, nsu_date, environment, covenant_code, bank_number] = parts\n        .as_slice()\n        .try_into()\n        .map_err(|_| errors::ConnectorError::ParsingFailed)?;\n\n    Ok(NsuComposite {\n        nsu_code: nsu_code.to_string(),\n        nsu_date: nsu_date.to_string(),\n        environment: environment.to_string(),\n        covenant_code: covenant_code.to_string(),\n        bank_number: bank_number.to_string(),\n    })\n}\n\npub fn format_as_date_only(\n    date_time: Option<time::PrimitiveDateTime>,\n) -> Result<String, errors::ConnectorError> {\n    let dt = date_time.ok_or(errors::ConnectorError::MissingRequiredField {\n        field_name: \"due_date\",\n    })?;\n\n    let format = time::macros::format_description!(\"[year]-[month]-[day]\");\n    dt.format(&format)\n        .map_err(|_| errors::ConnectorError::ParsingFailed)\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs"}, {"query": "SantanderPixRequest struct", "code": "use api_models::payments::{QrCodeInformation, VoucherNextStepData};\nuse common_enums::{\n    enums, AttemptStatus, BoletoDocumentKind, BoletoPaymentType, ExpiryType, PixKey,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, ValueExt},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse crc::{Algorithm, Crc};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankTransferData, BoletoVoucherData, PaymentMethodData, VoucherData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{PaymentsUpdateMetadataData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        PaymentsUpdateMetadataRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::{self},\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            Environment, SantanderAuthRequest, SantanderAuthType, SantanderBoletoCancelOperation,\n            SantanderBoletoCancelRequest, SantanderBoletoPaymentRequest,\n            SantanderBoletoUpdateRequest, SantanderDebtor, SantanderGrantType,\n            SantanderMetadataObject, SantanderPaymentRequest, SantanderPaymentsCancelRequest,\n            SantanderPixCancelRequest, SantanderPixDueDateCalendarRequest,\n            SantanderPixImmediateCalendarRequest, SantanderPixQRPaymentRequest,\n            SantanderPixRequestCalendar, SantanderRefundRequest, SantanderRouterData,\n            SantanderValue,\n        },\n        responses::{\n            Key, NsuComposite, Payer, SanatanderAccessTokenResponse, SanatanderTokenResponse,\n            SantanderAdditionalInfo, SantanderBoletoDocumentKind, SantanderBoletoPay\n\n... [truncated 51519 chars] ...\n\n?)\n}\n\nfn extract_boleto_components(input: &str) -> Result<NsuComposite, errors::ConnectorError> {\n    let parts: Vec<&str> = input.split('.').collect();\n\n    let [nsu_code, nsu_date, environment, covenant_code, bank_number] = parts\n        .as_slice()\n        .try_into()\n        .map_err(|_| errors::ConnectorError::ParsingFailed)?;\n\n    Ok(NsuComposite {\n        nsu_code: nsu_code.to_string(),\n        nsu_date: nsu_date.to_string(),\n        environment: environment.to_string(),\n        covenant_code: covenant_code.to_string(),\n        bank_number: bank_number.to_string(),\n    })\n}\n\npub fn format_as_date_only(\n    date_time: Option<time::PrimitiveDateTime>,\n) -> Result<String, errors::ConnectorError> {\n    let dt = date_time.ok_or(errors::ConnectorError::MissingRequiredField {\n        field_name: \"due_date\",\n    })?;\n\n    let format = time::macros::format_description!(\"[year]-[month]-[day]\");\n    dt.format(&format)\n        .map_err(|_| errors::ConnectorError::ParsingFailed)\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs"}, {"query": "how to configure Santander connector", "code": "use api_models::payments::{QrCodeInformation, VoucherNextStepData};\nuse common_enums::{\n    enums, AttemptStatus, BoletoDocumentKind, BoletoPaymentType, ExpiryType, PixKey,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, ValueExt},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse crc::{Algorithm, Crc};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankTransferData, BoletoVoucherData, PaymentMethodData, VoucherData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{PaymentsUpdateMetadataData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        PaymentsUpdateMetadataRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::{self},\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            Environment, SantanderAuthRequest, SantanderAuthType, SantanderBoletoCancelOperation,\n            SantanderBoletoCancelRequest, SantanderBoletoPaymentRequest,\n            SantanderBoletoUpdateRequest, SantanderDebtor, SantanderGrantType,\n            SantanderMetadataObject, SantanderPaymentRequest, SantanderPaymentsCancelRequest,\n            SantanderPixCancelRequest, SantanderPixDueDateCalendarRequest,\n            SantanderPixImmediateCalendarRequest, SantanderPixQRPaymentRequest,\n            SantanderPixRequestCalendar, SantanderRefundRequest, SantanderRouterData,\n            SantanderValue,\n        },\n        responses::{\n            Key, NsuComposite, Payer, SanatanderAccessTokenResponse, SanatanderTokenResponse,\n            SantanderAdditionalInfo, SantanderBoletoDocumentKind, SantanderBoletoPay\n\n... [truncated 51519 chars] ...\n\n?)\n}\n\nfn extract_boleto_components(input: &str) -> Result<NsuComposite, errors::ConnectorError> {\n    let parts: Vec<&str> = input.split('.').collect();\n\n    let [nsu_code, nsu_date, environment, covenant_code, bank_number] = parts\n        .as_slice()\n        .try_into()\n        .map_err(|_| errors::ConnectorError::ParsingFailed)?;\n\n    Ok(NsuComposite {\n        nsu_code: nsu_code.to_string(),\n        nsu_date: nsu_date.to_string(),\n        environment: environment.to_string(),\n        covenant_code: covenant_code.to_string(),\n        bank_number: bank_number.to_string(),\n    })\n}\n\npub fn format_as_date_only(\n    date_time: Option<time::PrimitiveDateTime>,\n) -> Result<String, errors::ConnectorError> {\n    let dt = date_time.ok_or(errors::ConnectorError::MissingRequiredField {\n        field_name: \"due_date\",\n    })?;\n\n    let format = time::macros::format_description!(\"[year]-[month]-[day]\");\n    dt.format(&format)\n        .map_err(|_| errors::ConnectorError::ParsingFailed)\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs"}, {"query": "Pix QR code payment Santander", "code": "use api_models::payments::{QrCodeInformation, VoucherNextStepData};\nuse common_enums::{\n    enums, AttemptStatus, BoletoDocumentKind, BoletoPaymentType, ExpiryType, PixKey,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, ValueExt},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse crc::{Algorithm, Crc};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankTransferData, BoletoVoucherData, PaymentMethodData, VoucherData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{PaymentsUpdateMetadataData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        PaymentsUpdateMetadataRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::{self},\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            Environment, SantanderAuthRequest, SantanderAuthType, SantanderBoletoCancelOperation,\n            SantanderBoletoCancelRequest, SantanderBoletoPaymentRequest,\n            SantanderBoletoUpdateRequest, SantanderDebtor, SantanderGrantType,\n            SantanderMetadataObject, SantanderPaymentRequest, SantanderPaymentsCancelRequest,\n            SantanderPixCancelRequest, SantanderPixDueDateCalendarRequest,\n            SantanderPixImmediateCalendarRequest, SantanderPixQRPaymentRequest,\n            SantanderPixRequestCalendar, SantanderRefundRequest, SantanderRouterData,\n            SantanderValue,\n        },\n        responses::{\n            Key, NsuComposite, Payer, SanatanderAccessTokenResponse, SanatanderTokenResponse,\n            SantanderAdditionalInfo, SantanderBoletoDocumentKind, SantanderBoletoPay\n\n... [truncated 51519 chars] ...\n\n?)\n}\n\nfn extract_boleto_components(input: &str) -> Result<NsuComposite, errors::ConnectorError> {\n    let parts: Vec<&str> = input.split('.').collect();\n\n    let [nsu_code, nsu_date, environment, covenant_code, bank_number] = parts\n        .as_slice()\n        .try_into()\n        .map_err(|_| errors::ConnectorError::ParsingFailed)?;\n\n    Ok(NsuComposite {\n        nsu_code: nsu_code.to_string(),\n        nsu_date: nsu_date.to_string(),\n        environment: environment.to_string(),\n        covenant_code: covenant_code.to_string(),\n        bank_number: bank_number.to_string(),\n    })\n}\n\npub fn format_as_date_only(\n    date_time: Option<time::PrimitiveDateTime>,\n) -> Result<String, errors::ConnectorError> {\n    let dt = date_time.ok_or(errors::ConnectorError::MissingRequiredField {\n        field_name: \"due_date\",\n    })?;\n\n    let format = time::macros::format_description!(\"[year]-[month]-[day]\");\n    dt.format(&format)\n        .map_err(|_| errors::ConnectorError::ParsingFailed)\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs"}, {"query": "Moneris payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as moneris;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, is_mandate_supported, PaymentMethodDataType, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Moneris {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Moneris {\n    pub fn new() -> &'stati\n\n... [truncated 28586 chars] ...\n\n           }),\n            ),\n        },\n    );\n\n    moneris_supported_payment_methods\n});\n\nstatic MONERIS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Moneris\",\n    description: \"Moneris is Canada's top payment solutions provider, empowering businesses with innovative mobile, online & in-store solutions.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic MONERIS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Moneris {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MONERIS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MONERIS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MONERIS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__moneris.rs", "file": "crates__hyperswitch_connectors__src__connectors__moneris.rs"}, {"query": "hyperswitch Moneris connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as moneris;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, is_mandate_supported, PaymentMethodDataType, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Moneris {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Moneris {\n    pub fn new() -> &'stati\n\n... [truncated 28586 chars] ...\n\n           }),\n            ),\n        },\n    );\n\n    moneris_supported_payment_methods\n});\n\nstatic MONERIS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Moneris\",\n    description: \"Moneris is Canada's top payment solutions provider, empowering businesses with innovative mobile, online & in-store solutions.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic MONERIS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Moneris {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MONERIS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MONERIS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MONERIS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__moneris.rs", "file": "crates__hyperswitch_connectors__src__connectors__moneris.rs"}, {"query": "how to implement Moneris payments", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as moneris;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, is_mandate_supported, PaymentMethodDataType, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Moneris {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Moneris {\n    pub fn new() -> &'stati\n\n... [truncated 28586 chars] ...\n\n           }),\n            ),\n        },\n    );\n\n    moneris_supported_payment_methods\n});\n\nstatic MONERIS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Moneris\",\n    description: \"Moneris is Canada's top payment solutions provider, empowering businesses with innovative mobile, online & in-store solutions.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic MONERIS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Moneris {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MONERIS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MONERIS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MONERIS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__moneris.rs", "file": "crates__hyperswitch_connectors__src__connectors__moneris.rs"}, {"query": "moneris authorize capture refund", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as moneris;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, is_mandate_supported, PaymentMethodDataType, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Moneris {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Moneris {\n    pub fn new() -> &'stati\n\n... [truncated 28586 chars] ...\n\n           }),\n            ),\n        },\n    );\n\n    moneris_supported_payment_methods\n});\n\nstatic MONERIS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Moneris\",\n    description: \"Moneris is Canada's top payment solutions provider, empowering businesses with innovative mobile, online & in-store solutions.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic MONERIS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Moneris {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MONERIS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MONERIS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MONERIS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__moneris.rs", "file": "crates__hyperswitch_connectors__src__connectors__moneris.rs"}, {"query": "Payjustnow connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, SignMessage},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface, Secret};\nuse transformers as payjustnow;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self},\n};\n\n#[derive(Clone)]\npub struct Payjustnow {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payjustnow {\n    pub fn new() -> &'static Sel\n\n... [truncated 27760 chars] ...\n\nd_payment_methods\n    });\n\nstatic PAYJUSTNOW_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Payjustnow\",\n    description: \"PayJustNow is a South African payment connector that enables customers to split online purchases into three interest-free monthly installments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYJUSTNOW_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Payjustnow {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYJUSTNOW_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYJUSTNOW_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYJUSTNOW_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnow.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnow.rs"}, {"query": "how to integrate PayJustNow payment gateway", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, SignMessage},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface, Secret};\nuse transformers as payjustnow;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self},\n};\n\n#[derive(Clone)]\npub struct Payjustnow {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payjustnow {\n    pub fn new() -> &'static Sel\n\n... [truncated 27760 chars] ...\n\nd_payment_methods\n    });\n\nstatic PAYJUSTNOW_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Payjustnow\",\n    description: \"PayJustNow is a South African payment connector that enables customers to split online purchases into three interest-free monthly installments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYJUSTNOW_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Payjustnow {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYJUSTNOW_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYJUSTNOW_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYJUSTNOW_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnow.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnow.rs"}, {"query": "Hyperswitch PayLater connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, SignMessage},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface, Secret};\nuse transformers as payjustnow;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self},\n};\n\n#[derive(Clone)]\npub struct Payjustnow {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payjustnow {\n    pub fn new() -> &'static Sel\n\n... [truncated 27760 chars] ...\n\nd_payment_methods\n    });\n\nstatic PAYJUSTNOW_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Payjustnow\",\n    description: \"PayJustNow is a South African payment connector that enables customers to split online purchases into three interest-free monthly installments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYJUSTNOW_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Payjustnow {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYJUSTNOW_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYJUSTNOW_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYJUSTNOW_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnow.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnow.rs"}, {"query": "Payjustnow authorize capture refund", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, SignMessage},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface, Secret};\nuse transformers as payjustnow;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self},\n};\n\n#[derive(Clone)]\npub struct Payjustnow {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payjustnow {\n    pub fn new() -> &'static Sel\n\n... [truncated 27760 chars] ...\n\nd_payment_methods\n    });\n\nstatic PAYJUSTNOW_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Payjustnow\",\n    description: \"PayJustNow is a South African payment connector that enables customers to split online purchases into three interest-free monthly installments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYJUSTNOW_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Payjustnow {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYJUSTNOW_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYJUSTNOW_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYJUSTNOW_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnow.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnow.rs"}, {"query": "Juspay 3Ds Server connector implementation", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as juspaythreedsserver;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Juspayt\n\n... [truncated 20088 chars] ...\n\n masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic JUSPAYTHREEDSSERVER_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Juspay 3Ds Server\",\n    description: \"Juspay 3DS Server provider for comprehensive 3-Domain Secure authentication, cardholder verification, and fraud prevention across card networks\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Juspaythreedsserver {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&JUSPAYTHREEDSSERVER_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "file": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs"}, {"query": "Juspaythreedsserver struct definition", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as juspaythreedsserver;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Juspayt\n\n... [truncated 20088 chars] ...\n\n masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic JUSPAYTHREEDSSERVER_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Juspay 3Ds Server\",\n    description: \"Juspay 3DS Server provider for comprehensive 3-Domain Secure authentication, cardholder verification, and fraud prevention across card networks\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Juspaythreedsserver {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&JUSPAYTHREEDSSERVER_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "file": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs"}, {"query": "how to implement Juspay 3DS authentication", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as juspaythreedsserver;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Juspayt\n\n... [truncated 20088 chars] ...\n\n masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic JUSPAYTHREEDSSERVER_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Juspay 3Ds Server\",\n    description: \"Juspay 3DS Server provider for comprehensive 3-Domain Secure authentication, cardholder verification, and fraud prevention across card networks\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Juspaythreedsserver {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&JUSPAYTHREEDSSERVER_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "file": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs"}, {"query": "Hyperswitch Juspay payment integration", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as juspaythreedsserver;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Juspayt\n\n... [truncated 20088 chars] ...\n\n masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic JUSPAYTHREEDSSERVER_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Juspay 3Ds Server\",\n    description: \"Juspay 3DS Server provider for comprehensive 3-Domain Secure authentication, cardholder verification, and fraud prevention across card networks\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Juspaythreedsserver {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&JUSPAYTHREEDSSERVER_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "file": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs"}, {"query": "Zift payment gateway integration hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as zift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Zift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Zift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Zift {}\nimpl api::PaymentSes\n\n... [truncated 25687 chars] ...\n\nms::FeatureStatus::Supported,\n                        supported_card_networks: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    zift_supported_payment_methods\n});\n\nstatic ZIFT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Zift\",\n    description: \"Zift connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic ZIFT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Zift {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ZIFT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZIFT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ZIFT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zift.rs", "file": "crates__hyperswitch_connectors__src__connectors__zift.rs"}, {"query": "hyperswitch Zift connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as zift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Zift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Zift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Zift {}\nimpl api::PaymentSes\n\n... [truncated 25687 chars] ...\n\nms::FeatureStatus::Supported,\n                        supported_card_networks: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    zift_supported_payment_methods\n});\n\nstatic ZIFT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Zift\",\n    description: \"Zift connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic ZIFT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Zift {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ZIFT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZIFT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ZIFT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zift.rs", "file": "crates__hyperswitch_connectors__src__connectors__zift.rs"}, {"query": "how to configure Zift payment method", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as zift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Zift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Zift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Zift {}\nimpl api::PaymentSes\n\n... [truncated 25687 chars] ...\n\nms::FeatureStatus::Supported,\n                        supported_card_networks: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    zift_supported_payment_methods\n});\n\nstatic ZIFT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Zift\",\n    description: \"Zift connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic ZIFT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Zift {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ZIFT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZIFT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ZIFT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zift.rs", "file": "crates__hyperswitch_connectors__src__connectors__zift.rs"}, {"query": "hyperswitch Zift authorize capture refund", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as zift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Zift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Zift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Zift {}\nimpl api::PaymentSes\n\n... [truncated 25687 chars] ...\n\nms::FeatureStatus::Supported,\n                        supported_card_networks: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    zift_supported_payment_methods\n});\n\nstatic ZIFT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Zift\",\n    description: \"Zift connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic ZIFT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Zift {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ZIFT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZIFT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ZIFT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zift.rs", "file": "crates__hyperswitch_connectors__src__connectors__zift.rs"}, {"query": "how to build analytics queries in Rust", "code": "use std::{fmt, marker::PhantomData};\n\nuse api_models::{\n    analytics::{\n        self as analytics_api,\n        api_event::ApiEventDimensions,\n        auth_events::{AuthEventDimensions, AuthEventFlows},\n        disputes::DisputeDimensions,\n        frm::{FrmDimensions, FrmTransactionType},\n        payment_intents::PaymentIntentDimensions,\n        payments::{PaymentDimensions, PaymentDistributions},\n        refunds::{RefundDimensions, RefundDistributions, RefundType},\n        sdk_events::{SdkEventDimensions, SdkEventNames},\n        Granularity,\n    },\n    enums::{\n        AttemptStatus, AuthenticationType, Connector, Currency, DisputeStage, IntentStatus,\n        PaymentMethod, PaymentMethodType, RoutingApproach,\n    },\n    refunds::RefundStatus,\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    id_type::{MerchantId, OrganizationId, ProfileId},\n};\nuse diesel_models::{enums as storage_enums, enums::FraudCheckStatus};\nuse error_stack::ResultExt;\nuse router_env::{logger, Flow};\n\nuse super::types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, TableEngine};\nuse crate::{enums::AuthInfo, types::QueryExecutionError};\npub type QueryResult<T> = error_stack::Result<T, QueryBuildingError>;\npub trait QueryFilter<T>\nwhere\n    T: AnalyticsDataSource,\n    AnalyticsCollection: ToSql<T>,\n{\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()>;\n}\n\npub trait GroupByClause<T>\nwhere\n    T: AnalyticsDataSource,\n    AnalyticsCollection: ToSql<T>,\n{\n    fn set_group_by_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()>;\n}\n\npub trait SeriesBucket {\n    type SeriesType;\n    type GranularityLevel;\n\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel;\n\n    fn get_bucket_size(&self) -> u8;\n\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::Serie\n\n... [truncated 27461 chars] ...\n\nause(\"organization_id\", org_id)\n                    .attach_printable(\"Error adding organization_id filter\")?;\n                builder\n                    .add_filter_in_range_clause(\"merchant_id\", merchant_ids)\n                    .attach_printable(\"Error adding merchant_id filter\")?;\n            }\n            Self::ProfileLevel {\n                org_id,\n                merchant_id,\n                profile_ids,\n            } => {\n                builder\n                    .add_filter_clause(\"organization_id\", org_id)\n                    .attach_printable(\"Error adding organization_id filter\")?;\n                builder\n                    .add_filter_clause(\"merchant_id\", merchant_id)\n                    .attach_printable(\"Error adding merchant_id filter\")?;\n                builder\n                    .add_filter_in_range_clause(\"profile_id\", profile_ids)\n                    .attach_printable(\"Error adding profile_id filter\")?;\n            }\n        }\n        Ok(())\n    }\n}\n", "function_name": "crates__analytics__src__query.rs", "file": "crates__analytics__src__query.rs"}, {"query": "QueryFilter trait implementation", "code": "use std::{fmt, marker::PhantomData};\n\nuse api_models::{\n    analytics::{\n        self as analytics_api,\n        api_event::ApiEventDimensions,\n        auth_events::{AuthEventDimensions, AuthEventFlows},\n        disputes::DisputeDimensions,\n        frm::{FrmDimensions, FrmTransactionType},\n        payment_intents::PaymentIntentDimensions,\n        payments::{PaymentDimensions, PaymentDistributions},\n        refunds::{RefundDimensions, RefundDistributions, RefundType},\n        sdk_events::{SdkEventDimensions, SdkEventNames},\n        Granularity,\n    },\n    enums::{\n        AttemptStatus, AuthenticationType, Connector, Currency, DisputeStage, IntentStatus,\n        PaymentMethod, PaymentMethodType, RoutingApproach,\n    },\n    refunds::RefundStatus,\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    id_type::{MerchantId, OrganizationId, ProfileId},\n};\nuse diesel_models::{enums as storage_enums, enums::FraudCheckStatus};\nuse error_stack::ResultExt;\nuse router_env::{logger, Flow};\n\nuse super::types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, TableEngine};\nuse crate::{enums::AuthInfo, types::QueryExecutionError};\npub type QueryResult<T> = error_stack::Result<T, QueryBuildingError>;\npub trait QueryFilter<T>\nwhere\n    T: AnalyticsDataSource,\n    AnalyticsCollection: ToSql<T>,\n{\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()>;\n}\n\npub trait GroupByClause<T>\nwhere\n    T: AnalyticsDataSource,\n    AnalyticsCollection: ToSql<T>,\n{\n    fn set_group_by_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()>;\n}\n\npub trait SeriesBucket {\n    type SeriesType;\n    type GranularityLevel;\n\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel;\n\n    fn get_bucket_size(&self) -> u8;\n\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::Serie\n\n... [truncated 27461 chars] ...\n\nause(\"organization_id\", org_id)\n                    .attach_printable(\"Error adding organization_id filter\")?;\n                builder\n                    .add_filter_in_range_clause(\"merchant_id\", merchant_ids)\n                    .attach_printable(\"Error adding merchant_id filter\")?;\n            }\n            Self::ProfileLevel {\n                org_id,\n                merchant_id,\n                profile_ids,\n            } => {\n                builder\n                    .add_filter_clause(\"organization_id\", org_id)\n                    .attach_printable(\"Error adding organization_id filter\")?;\n                builder\n                    .add_filter_clause(\"merchant_id\", merchant_id)\n                    .attach_printable(\"Error adding merchant_id filter\")?;\n                builder\n                    .add_filter_in_range_clause(\"profile_id\", profile_ids)\n                    .attach_printable(\"Error adding profile_id filter\")?;\n            }\n        }\n        Ok(())\n    }\n}\n", "function_name": "crates__analytics__src__query.rs", "file": "crates__analytics__src__query.rs"}, {"query": "how to filter analytics data by organization", "code": "use std::{fmt, marker::PhantomData};\n\nuse api_models::{\n    analytics::{\n        self as analytics_api,\n        api_event::ApiEventDimensions,\n        auth_events::{AuthEventDimensions, AuthEventFlows},\n        disputes::DisputeDimensions,\n        frm::{FrmDimensions, FrmTransactionType},\n        payment_intents::PaymentIntentDimensions,\n        payments::{PaymentDimensions, PaymentDistributions},\n        refunds::{RefundDimensions, RefundDistributions, RefundType},\n        sdk_events::{SdkEventDimensions, SdkEventNames},\n        Granularity,\n    },\n    enums::{\n        AttemptStatus, AuthenticationType, Connector, Currency, DisputeStage, IntentStatus,\n        PaymentMethod, PaymentMethodType, RoutingApproach,\n    },\n    refunds::RefundStatus,\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    id_type::{MerchantId, OrganizationId, ProfileId},\n};\nuse diesel_models::{enums as storage_enums, enums::FraudCheckStatus};\nuse error_stack::ResultExt;\nuse router_env::{logger, Flow};\n\nuse super::types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, TableEngine};\nuse crate::{enums::AuthInfo, types::QueryExecutionError};\npub type QueryResult<T> = error_stack::Result<T, QueryBuildingError>;\npub trait QueryFilter<T>\nwhere\n    T: AnalyticsDataSource,\n    AnalyticsCollection: ToSql<T>,\n{\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()>;\n}\n\npub trait GroupByClause<T>\nwhere\n    T: AnalyticsDataSource,\n    AnalyticsCollection: ToSql<T>,\n{\n    fn set_group_by_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()>;\n}\n\npub trait SeriesBucket {\n    type SeriesType;\n    type GranularityLevel;\n\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel;\n\n    fn get_bucket_size(&self) -> u8;\n\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::Serie\n\n... [truncated 27461 chars] ...\n\nause(\"organization_id\", org_id)\n                    .attach_printable(\"Error adding organization_id filter\")?;\n                builder\n                    .add_filter_in_range_clause(\"merchant_id\", merchant_ids)\n                    .attach_printable(\"Error adding merchant_id filter\")?;\n            }\n            Self::ProfileLevel {\n                org_id,\n                merchant_id,\n                profile_ids,\n            } => {\n                builder\n                    .add_filter_clause(\"organization_id\", org_id)\n                    .attach_printable(\"Error adding organization_id filter\")?;\n                builder\n                    .add_filter_clause(\"merchant_id\", merchant_id)\n                    .attach_printable(\"Error adding merchant_id filter\")?;\n                builder\n                    .add_filter_in_range_clause(\"profile_id\", profile_ids)\n                    .attach_printable(\"Error adding profile_id filter\")?;\n            }\n        }\n        Ok(())\n    }\n}\n", "function_name": "crates__analytics__src__query.rs", "file": "crates__analytics__src__query.rs"}, {"query": "Granularity GroupByClause trait", "code": "use std::{fmt, marker::PhantomData};\n\nuse api_models::{\n    analytics::{\n        self as analytics_api,\n        api_event::ApiEventDimensions,\n        auth_events::{AuthEventDimensions, AuthEventFlows},\n        disputes::DisputeDimensions,\n        frm::{FrmDimensions, FrmTransactionType},\n        payment_intents::PaymentIntentDimensions,\n        payments::{PaymentDimensions, PaymentDistributions},\n        refunds::{RefundDimensions, RefundDistributions, RefundType},\n        sdk_events::{SdkEventDimensions, SdkEventNames},\n        Granularity,\n    },\n    enums::{\n        AttemptStatus, AuthenticationType, Connector, Currency, DisputeStage, IntentStatus,\n        PaymentMethod, PaymentMethodType, RoutingApproach,\n    },\n    refunds::RefundStatus,\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    id_type::{MerchantId, OrganizationId, ProfileId},\n};\nuse diesel_models::{enums as storage_enums, enums::FraudCheckStatus};\nuse error_stack::ResultExt;\nuse router_env::{logger, Flow};\n\nuse super::types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, TableEngine};\nuse crate::{enums::AuthInfo, types::QueryExecutionError};\npub type QueryResult<T> = error_stack::Result<T, QueryBuildingError>;\npub trait QueryFilter<T>\nwhere\n    T: AnalyticsDataSource,\n    AnalyticsCollection: ToSql<T>,\n{\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()>;\n}\n\npub trait GroupByClause<T>\nwhere\n    T: AnalyticsDataSource,\n    AnalyticsCollection: ToSql<T>,\n{\n    fn set_group_by_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()>;\n}\n\npub trait SeriesBucket {\n    type SeriesType;\n    type GranularityLevel;\n\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel;\n\n    fn get_bucket_size(&self) -> u8;\n\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::Serie\n\n... [truncated 27461 chars] ...\n\nause(\"organization_id\", org_id)\n                    .attach_printable(\"Error adding organization_id filter\")?;\n                builder\n                    .add_filter_in_range_clause(\"merchant_id\", merchant_ids)\n                    .attach_printable(\"Error adding merchant_id filter\")?;\n            }\n            Self::ProfileLevel {\n                org_id,\n                merchant_id,\n                profile_ids,\n            } => {\n                builder\n                    .add_filter_clause(\"organization_id\", org_id)\n                    .attach_printable(\"Error adding organization_id filter\")?;\n                builder\n                    .add_filter_clause(\"merchant_id\", merchant_id)\n                    .attach_printable(\"Error adding merchant_id filter\")?;\n                builder\n                    .add_filter_in_range_clause(\"profile_id\", profile_ids)\n                    .attach_printable(\"Error adding profile_id filter\")?;\n            }\n        }\n        Ok(())\n    }\n}\n", "function_name": "crates__analytics__src__query.rs", "file": "crates__analytics__src__query.rs"}, {"query": "Opayo payment connector implementation", "code": "mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as opayo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Opayo {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Opayo {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Opayo {}\nimpl api::PaymentSession for Opayo {}\nimpl api::ConnectorAcce\n\n... [truncated 17140 chars] ...\n\nnc_trait]\nimpl webhooks::IncomingWebhook for Opayo {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Opayo {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__opayo.rs", "file": "crates__hyperswitch_connectors__src__connectors__opayo.rs"}, {"query": "hyperswitch Opayo integration", "code": "mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as opayo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Opayo {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Opayo {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Opayo {}\nimpl api::PaymentSession for Opayo {}\nimpl api::ConnectorAcce\n\n... [truncated 17140 chars] ...\n\nnc_trait]\nimpl webhooks::IncomingWebhook for Opayo {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Opayo {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__opayo.rs", "file": "crates__hyperswitch_connectors__src__connectors__opayo.rs"}, {"query": "how to configure Opayo connector", "code": "mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as opayo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Opayo {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Opayo {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Opayo {}\nimpl api::PaymentSession for Opayo {}\nimpl api::ConnectorAcce\n\n... [truncated 17140 chars] ...\n\nnc_trait]\nimpl webhooks::IncomingWebhook for Opayo {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Opayo {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__opayo.rs", "file": "crates__hyperswitch_connectors__src__connectors__opayo.rs"}, {"query": "Opayo API authentication hyperswitch", "code": "mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as opayo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Opayo {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Opayo {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Opayo {}\nimpl api::PaymentSession for Opayo {}\nimpl api::ConnectorAcce\n\n... [truncated 17140 chars] ...\n\nnc_trait]\nimpl webhooks::IncomingWebhook for Opayo {\n    fn get_webhook_object_reference_id(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<api_models::webhooks::ObjectReferenceId, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_event_type(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<api_models::webhooks::IncomingWebhookEvent, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n\n    fn get_webhook_resource_object(\n        &self,\n        _request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nimpl ConnectorSpecifications for Opayo {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__opayo.rs", "file": "crates__hyperswitch_connectors__src__connectors__opayo.rs"}, {"query": "Square API data transformation", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, Card, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::{refunds::Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{self, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\nimpl TryFrom<(&types::TokenizationRouterData, BankDebitData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, BankDebitData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, bank_debit_data) = value;\n        match bank_debit_data {\n            BankDebitData::AchBankDebit { .. }\n            | BankDebitData::SepaBankDebit { .. }\n            | BankDebitData::BecsBankDebit { .. }\n            | BankDebitData::BacsBankDebit { .. }\n            | BankDebitData::SepaGuarenteedBankDebit { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, Card)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, Card)) -> Result<Self, Self::Error> {\n        let (item, card_data) = value;\n        let auth = SquareAuthType::try_from(&item.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType\n\n... [truncated 18236 chars] ...\n\nk_type: String,\n    pub data: SquareWebhookData,\n}\n\nimpl From<SquareWebhookObject> for IncomingWebhookEvent {\n    fn from(item: SquareWebhookObject) -> Self {\n        match item {\n            SquareWebhookObject::Payment(payment_data) => match payment_data.status {\n                SquarePaymentStatus::Completed => Self::PaymentIntentSuccess,\n                SquarePaymentStatus::Failed => Self::PaymentIntentFailure,\n                SquarePaymentStatus::Pending => Self::PaymentIntentProcessing,\n                SquarePaymentStatus::Approved | SquarePaymentStatus::Canceled => {\n                    Self::EventNotSupported\n                }\n            },\n            SquareWebhookObject::Refund(refund_data) => match refund_data.status {\n                RefundStatus::Completed => Self::RefundSuccess,\n                RefundStatus::Failed | RefundStatus::Rejected => Self::RefundFailure,\n                RefundStatus::Pending => Self::EventNotSupported,\n            },\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs"}, {"query": "SquareTokenRequest struct definition", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, Card, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::{refunds::Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{self, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\nimpl TryFrom<(&types::TokenizationRouterData, BankDebitData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, BankDebitData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, bank_debit_data) = value;\n        match bank_debit_data {\n            BankDebitData::AchBankDebit { .. }\n            | BankDebitData::SepaBankDebit { .. }\n            | BankDebitData::BecsBankDebit { .. }\n            | BankDebitData::BacsBankDebit { .. }\n            | BankDebitData::SepaGuarenteedBankDebit { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, Card)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, Card)) -> Result<Self, Self::Error> {\n        let (item, card_data) = value;\n        let auth = SquareAuthType::try_from(&item.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType\n\n... [truncated 18236 chars] ...\n\nk_type: String,\n    pub data: SquareWebhookData,\n}\n\nimpl From<SquareWebhookObject> for IncomingWebhookEvent {\n    fn from(item: SquareWebhookObject) -> Self {\n        match item {\n            SquareWebhookObject::Payment(payment_data) => match payment_data.status {\n                SquarePaymentStatus::Completed => Self::PaymentIntentSuccess,\n                SquarePaymentStatus::Failed => Self::PaymentIntentFailure,\n                SquarePaymentStatus::Pending => Self::PaymentIntentProcessing,\n                SquarePaymentStatus::Approved | SquarePaymentStatus::Canceled => {\n                    Self::EventNotSupported\n                }\n            },\n            SquareWebhookObject::Refund(refund_data) => match refund_data.status {\n                RefundStatus::Completed => Self::RefundSuccess,\n                RefundStatus::Failed | RefundStatus::Rejected => Self::RefundFailure,\n                RefundStatus::Pending => Self::EventNotSupported,\n            },\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs"}, {"query": "how to convert hyperswitch data to Square format", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, Card, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::{refunds::Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{self, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\nimpl TryFrom<(&types::TokenizationRouterData, BankDebitData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, BankDebitData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, bank_debit_data) = value;\n        match bank_debit_data {\n            BankDebitData::AchBankDebit { .. }\n            | BankDebitData::SepaBankDebit { .. }\n            | BankDebitData::BecsBankDebit { .. }\n            | BankDebitData::BacsBankDebit { .. }\n            | BankDebitData::SepaGuarenteedBankDebit { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, Card)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, Card)) -> Result<Self, Self::Error> {\n        let (item, card_data) = value;\n        let auth = SquareAuthType::try_from(&item.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType\n\n... [truncated 18236 chars] ...\n\nk_type: String,\n    pub data: SquareWebhookData,\n}\n\nimpl From<SquareWebhookObject> for IncomingWebhookEvent {\n    fn from(item: SquareWebhookObject) -> Self {\n        match item {\n            SquareWebhookObject::Payment(payment_data) => match payment_data.status {\n                SquarePaymentStatus::Completed => Self::PaymentIntentSuccess,\n                SquarePaymentStatus::Failed => Self::PaymentIntentFailure,\n                SquarePaymentStatus::Pending => Self::PaymentIntentProcessing,\n                SquarePaymentStatus::Approved | SquarePaymentStatus::Canceled => {\n                    Self::EventNotSupported\n                }\n            },\n            SquareWebhookObject::Refund(refund_data) => match refund_data.status {\n                RefundStatus::Completed => Self::RefundSuccess,\n                RefundStatus::Failed | RefundStatus::Rejected => Self::RefundFailure,\n                RefundStatus::Pending => Self::EventNotSupported,\n            },\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs"}, {"query": "Square webhook event mapping", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, Card, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::{refunds::Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{self, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\nimpl TryFrom<(&types::TokenizationRouterData, BankDebitData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, BankDebitData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, bank_debit_data) = value;\n        match bank_debit_data {\n            BankDebitData::AchBankDebit { .. }\n            | BankDebitData::SepaBankDebit { .. }\n            | BankDebitData::BecsBankDebit { .. }\n            | BankDebitData::BacsBankDebit { .. }\n            | BankDebitData::SepaGuarenteedBankDebit { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, Card)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, Card)) -> Result<Self, Self::Error> {\n        let (item, card_data) = value;\n        let auth = SquareAuthType::try_from(&item.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType\n\n... [truncated 18236 chars] ...\n\nk_type: String,\n    pub data: SquareWebhookData,\n}\n\nimpl From<SquareWebhookObject> for IncomingWebhookEvent {\n    fn from(item: SquareWebhookObject) -> Self {\n        match item {\n            SquareWebhookObject::Payment(payment_data) => match payment_data.status {\n                SquarePaymentStatus::Completed => Self::PaymentIntentSuccess,\n                SquarePaymentStatus::Failed => Self::PaymentIntentFailure,\n                SquarePaymentStatus::Pending => Self::PaymentIntentProcessing,\n                SquarePaymentStatus::Approved | SquarePaymentStatus::Canceled => {\n                    Self::EventNotSupported\n                }\n            },\n            SquareWebhookObject::Refund(refund_data) => match refund_data.status {\n                RefundStatus::Completed => Self::RefundSuccess,\n                RefundStatus::Failed | RefundStatus::Rejected => Self::RefundFailure,\n                RefundStatus::Pending => Self::EventNotSupported,\n            },\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs"}, {"query": "Cybersource payment integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, IncrementalAuthorization, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, MandateRevokeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthenticateData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRou\n\n... [truncated 88076 chars] ...\n\n      .redirect_response\n                    .as_ref()\n                    .and_then(|redirect_response| redirect_response.params.as_ref());\n                match redirection_params {\n                    Some(param) if !param.peek().is_empty() => false,\n                    Some(_) | None => true,\n                }\n            }\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n}\n\nimpl Cybersource {\n    pub fn is_3ds_setup_required(\n        &self,\n        request: &PaymentsAuthorizeData,\n        auth_type: common_enums::AuthenticationType,\n    ) -> bool {\n        router_env::logger::info!(router_data_request=?request, auth_type=?auth_type, \"Checking if 3DS setup is required for Cybersource\");\n        auth_type.is_three_ds()\n            && request.is_card()\n            && (request.connector_mandate_id().is_none()\n                && request.get_optional_network_transaction_id().is_none())\n            && request.authentication_data.is_none()\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersource.rs"}, {"query": "Hyperswitch Cybersource connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, IncrementalAuthorization, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, MandateRevokeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthenticateData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRou\n\n... [truncated 88076 chars] ...\n\n      .redirect_response\n                    .as_ref()\n                    .and_then(|redirect_response| redirect_response.params.as_ref());\n                match redirection_params {\n                    Some(param) if !param.peek().is_empty() => false,\n                    Some(_) | None => true,\n                }\n            }\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n}\n\nimpl Cybersource {\n    pub fn is_3ds_setup_required(\n        &self,\n        request: &PaymentsAuthorizeData,\n        auth_type: common_enums::AuthenticationType,\n    ) -> bool {\n        router_env::logger::info!(router_data_request=?request, auth_type=?auth_type, \"Checking if 3DS setup is required for Cybersource\");\n        auth_type.is_three_ds()\n            && request.is_card()\n            && (request.connector_mandate_id().is_none()\n                && request.get_optional_network_transaction_id().is_none())\n            && request.authentication_data.is_none()\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersource.rs"}, {"query": "implement 3ds authentication Cybersource", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, IncrementalAuthorization, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, MandateRevokeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthenticateData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRou\n\n... [truncated 88076 chars] ...\n\n      .redirect_response\n                    .as_ref()\n                    .and_then(|redirect_response| redirect_response.params.as_ref());\n                match redirection_params {\n                    Some(param) if !param.peek().is_empty() => false,\n                    Some(_) | None => true,\n                }\n            }\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n}\n\nimpl Cybersource {\n    pub fn is_3ds_setup_required(\n        &self,\n        request: &PaymentsAuthorizeData,\n        auth_type: common_enums::AuthenticationType,\n    ) -> bool {\n        router_env::logger::info!(router_data_request=?request, auth_type=?auth_type, \"Checking if 3DS setup is required for Cybersource\");\n        auth_type.is_three_ds()\n            && request.is_card()\n            && (request.connector_mandate_id().is_none()\n                && request.get_optional_network_transaction_id().is_none())\n            && request.authentication_data.is_none()\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersource.rs"}, {"query": "Cybersource authorize capture flow", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, IncrementalAuthorization, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, MandateRevokeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthenticateData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRou\n\n... [truncated 88076 chars] ...\n\n      .redirect_response\n                    .as_ref()\n                    .and_then(|redirect_response| redirect_response.params.as_ref());\n                match redirection_params {\n                    Some(param) if !param.peek().is_empty() => false,\n                    Some(_) | None => true,\n                }\n            }\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n}\n\nimpl Cybersource {\n    pub fn is_3ds_setup_required(\n        &self,\n        request: &PaymentsAuthorizeData,\n        auth_type: common_enums::AuthenticationType,\n    ) -> bool {\n        router_env::logger::info!(router_data_request=?request, auth_type=?auth_type, \"Checking if 3DS setup is required for Cybersource\");\n        auth_type.is_three_ds()\n            && request.is_card()\n            && (request.connector_mandate_id().is_none()\n                && request.get_optional_network_transaction_id().is_none())\n            && request.authentication_data.is_none()\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersource.rs"}, {"query": "how does payment routing work", "code": "use std::{fmt::Debug, ops::Deref};\n\nuse common_types::three_ds_decision_rule_engine::{ThreeDSDecision, ThreeDSDecisionRule};\nuse common_utils::{\n    errors::{ParsingError, ValidationError},\n    ext_traits::ValueExt,\n    fp_utils, pii,\n};\nuse euclid::frontend::ast::Program;\npub use euclid::{\n    dssa::types::EuclidAnalysable,\n    enums::RoutableConnectors,\n    frontend::{\n        ast,\n        dir::{DirKeyKind, EuclidDirFilter},\n    },\n};\nuse serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\n\nuse crate::{enums::TransactionType, open_router};\n\n// Define constants for default values\nconst DEFAULT_LATENCY_THRESHOLD: f64 = 90.0;\nconst DEFAULT_BUCKET_SIZE: i32 = 200;\nconst DEFAULT_HEDGING_PERCENT: f64 = 5.0;\nconst DEFAULT_ELIMINATION_THRESHOLD: f64 = 0.35;\nconst DEFAULT_PAYMENT_METHOD: &str = \"CARD\";\nconst MAX_NAME_LENGTH: usize = 64;\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\n#[serde(tag = \"type\", content = \"data\", rename_all = \"snake_case\")]\npub enum ConnectorSelection {\n    Priority(Vec<RoutableConnectorChoice>),\n    VolumeSplit(Vec<ConnectorVolumeSplit>),\n}\n\nimpl ConnectorSelection {\n    pub fn get_connector_list(&self) -> Vec<RoutableConnectorChoice> {\n        match self {\n            Self::Priority(list) => list.clone(),\n            Self::VolumeSplit(splits) => {\n                splits.iter().map(|split| split.connector.clone()).collect()\n            }\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingConfigRequest {\n    pub name: String,\n    pub description: String,\n    pub algorithm: StaticRoutingAlgorithm,\n    #[schema(value_type = String)]\n    pub profile_id: common_utils::id_type::ProfileId,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingConfigRequest {\n    #[schema(value_type = Option<String>)]\n    pub name: Option<RoutingConfigName>,\n    pub description: Option<String>,\n    pub algorithm: Option<Static\n\n... [truncated 55584 chars] ...\n\n payment.method.cardtype = (debit, credit)\n    EnumVariantArray(Vec<String>),\n    /// Like a number array but can include comparisons. Useful for\n    /// conditions like \"500 < amount < 1000\"\n    /// eg: payment.amount = (> 500, < 1000)\n    NumberComparisonArray(Vec<NumberComparison>),\n}\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, ToSchema)]\npub struct MetadataValue {\n    pub key: String,\n    pub value: String,\n}\n/// Represents a number comparison for \"NumberComparisonArrayValue\"\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize, ToSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct NumberComparison {\n    pub comparison_type: ComparisonType,\n    pub number: u64,\n}\n/// Conditional comparison type\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, ToSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ComparisonType {\n    Equal,\n    NotEqual,\n    LessThan,\n    LessThanEqual,\n    GreaterThan,\n    GreaterThanEqual,\n}\n", "function_name": "crates__api_models__src__routing.rs", "file": "crates__api_models__src__routing.rs"}, {"query": "ConnectorSelection enum definition", "code": "use std::{fmt::Debug, ops::Deref};\n\nuse common_types::three_ds_decision_rule_engine::{ThreeDSDecision, ThreeDSDecisionRule};\nuse common_utils::{\n    errors::{ParsingError, ValidationError},\n    ext_traits::ValueExt,\n    fp_utils, pii,\n};\nuse euclid::frontend::ast::Program;\npub use euclid::{\n    dssa::types::EuclidAnalysable,\n    enums::RoutableConnectors,\n    frontend::{\n        ast,\n        dir::{DirKeyKind, EuclidDirFilter},\n    },\n};\nuse serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\n\nuse crate::{enums::TransactionType, open_router};\n\n// Define constants for default values\nconst DEFAULT_LATENCY_THRESHOLD: f64 = 90.0;\nconst DEFAULT_BUCKET_SIZE: i32 = 200;\nconst DEFAULT_HEDGING_PERCENT: f64 = 5.0;\nconst DEFAULT_ELIMINATION_THRESHOLD: f64 = 0.35;\nconst DEFAULT_PAYMENT_METHOD: &str = \"CARD\";\nconst MAX_NAME_LENGTH: usize = 64;\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\n#[serde(tag = \"type\", content = \"data\", rename_all = \"snake_case\")]\npub enum ConnectorSelection {\n    Priority(Vec<RoutableConnectorChoice>),\n    VolumeSplit(Vec<ConnectorVolumeSplit>),\n}\n\nimpl ConnectorSelection {\n    pub fn get_connector_list(&self) -> Vec<RoutableConnectorChoice> {\n        match self {\n            Self::Priority(list) => list.clone(),\n            Self::VolumeSplit(splits) => {\n                splits.iter().map(|split| split.connector.clone()).collect()\n            }\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingConfigRequest {\n    pub name: String,\n    pub description: String,\n    pub algorithm: StaticRoutingAlgorithm,\n    #[schema(value_type = String)]\n    pub profile_id: common_utils::id_type::ProfileId,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingConfigRequest {\n    #[schema(value_type = Option<String>)]\n    pub name: Option<RoutingConfigName>,\n    pub description: Option<String>,\n    pub algorithm: Option<Static\n\n... [truncated 55584 chars] ...\n\n payment.method.cardtype = (debit, credit)\n    EnumVariantArray(Vec<String>),\n    /// Like a number array but can include comparisons. Useful for\n    /// conditions like \"500 < amount < 1000\"\n    /// eg: payment.amount = (> 500, < 1000)\n    NumberComparisonArray(Vec<NumberComparison>),\n}\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, ToSchema)]\npub struct MetadataValue {\n    pub key: String,\n    pub value: String,\n}\n/// Represents a number comparison for \"NumberComparisonArrayValue\"\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize, ToSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct NumberComparison {\n    pub comparison_type: ComparisonType,\n    pub number: u64,\n}\n/// Conditional comparison type\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, ToSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ComparisonType {\n    Equal,\n    NotEqual,\n    LessThan,\n    LessThanEqual,\n    GreaterThan,\n    GreaterThanEqual,\n}\n", "function_name": "crates__api_models__src__routing.rs", "file": "crates__api_models__src__routing.rs"}, {"query": "how to implement volume split routing", "code": "use std::{fmt::Debug, ops::Deref};\n\nuse common_types::three_ds_decision_rule_engine::{ThreeDSDecision, ThreeDSDecisionRule};\nuse common_utils::{\n    errors::{ParsingError, ValidationError},\n    ext_traits::ValueExt,\n    fp_utils, pii,\n};\nuse euclid::frontend::ast::Program;\npub use euclid::{\n    dssa::types::EuclidAnalysable,\n    enums::RoutableConnectors,\n    frontend::{\n        ast,\n        dir::{DirKeyKind, EuclidDirFilter},\n    },\n};\nuse serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\n\nuse crate::{enums::TransactionType, open_router};\n\n// Define constants for default values\nconst DEFAULT_LATENCY_THRESHOLD: f64 = 90.0;\nconst DEFAULT_BUCKET_SIZE: i32 = 200;\nconst DEFAULT_HEDGING_PERCENT: f64 = 5.0;\nconst DEFAULT_ELIMINATION_THRESHOLD: f64 = 0.35;\nconst DEFAULT_PAYMENT_METHOD: &str = \"CARD\";\nconst MAX_NAME_LENGTH: usize = 64;\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\n#[serde(tag = \"type\", content = \"data\", rename_all = \"snake_case\")]\npub enum ConnectorSelection {\n    Priority(Vec<RoutableConnectorChoice>),\n    VolumeSplit(Vec<ConnectorVolumeSplit>),\n}\n\nimpl ConnectorSelection {\n    pub fn get_connector_list(&self) -> Vec<RoutableConnectorChoice> {\n        match self {\n            Self::Priority(list) => list.clone(),\n            Self::VolumeSplit(splits) => {\n                splits.iter().map(|split| split.connector.clone()).collect()\n            }\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingConfigRequest {\n    pub name: String,\n    pub description: String,\n    pub algorithm: StaticRoutingAlgorithm,\n    #[schema(value_type = String)]\n    pub profile_id: common_utils::id_type::ProfileId,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingConfigRequest {\n    #[schema(value_type = Option<String>)]\n    pub name: Option<RoutingConfigName>,\n    pub description: Option<String>,\n    pub algorithm: Option<Static\n\n... [truncated 55584 chars] ...\n\n payment.method.cardtype = (debit, credit)\n    EnumVariantArray(Vec<String>),\n    /// Like a number array but can include comparisons. Useful for\n    /// conditions like \"500 < amount < 1000\"\n    /// eg: payment.amount = (> 500, < 1000)\n    NumberComparisonArray(Vec<NumberComparison>),\n}\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, ToSchema)]\npub struct MetadataValue {\n    pub key: String,\n    pub value: String,\n}\n/// Represents a number comparison for \"NumberComparisonArrayValue\"\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize, ToSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct NumberComparison {\n    pub comparison_type: ComparisonType,\n    pub number: u64,\n}\n/// Conditional comparison type\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, ToSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ComparisonType {\n    Equal,\n    NotEqual,\n    LessThan,\n    LessThanEqual,\n    GreaterThan,\n    GreaterThanEqual,\n}\n", "function_name": "crates__api_models__src__routing.rs", "file": "crates__api_models__src__routing.rs"}, {"query": "routing decision rule engine AST", "code": "use std::{fmt::Debug, ops::Deref};\n\nuse common_types::three_ds_decision_rule_engine::{ThreeDSDecision, ThreeDSDecisionRule};\nuse common_utils::{\n    errors::{ParsingError, ValidationError},\n    ext_traits::ValueExt,\n    fp_utils, pii,\n};\nuse euclid::frontend::ast::Program;\npub use euclid::{\n    dssa::types::EuclidAnalysable,\n    enums::RoutableConnectors,\n    frontend::{\n        ast,\n        dir::{DirKeyKind, EuclidDirFilter},\n    },\n};\nuse serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\n\nuse crate::{enums::TransactionType, open_router};\n\n// Define constants for default values\nconst DEFAULT_LATENCY_THRESHOLD: f64 = 90.0;\nconst DEFAULT_BUCKET_SIZE: i32 = 200;\nconst DEFAULT_HEDGING_PERCENT: f64 = 5.0;\nconst DEFAULT_ELIMINATION_THRESHOLD: f64 = 0.35;\nconst DEFAULT_PAYMENT_METHOD: &str = \"CARD\";\nconst MAX_NAME_LENGTH: usize = 64;\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\n#[serde(tag = \"type\", content = \"data\", rename_all = \"snake_case\")]\npub enum ConnectorSelection {\n    Priority(Vec<RoutableConnectorChoice>),\n    VolumeSplit(Vec<ConnectorVolumeSplit>),\n}\n\nimpl ConnectorSelection {\n    pub fn get_connector_list(&self) -> Vec<RoutableConnectorChoice> {\n        match self {\n            Self::Priority(list) => list.clone(),\n            Self::VolumeSplit(splits) => {\n                splits.iter().map(|split| split.connector.clone()).collect()\n            }\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingConfigRequest {\n    pub name: String,\n    pub description: String,\n    pub algorithm: StaticRoutingAlgorithm,\n    #[schema(value_type = String)]\n    pub profile_id: common_utils::id_type::ProfileId,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingConfigRequest {\n    #[schema(value_type = Option<String>)]\n    pub name: Option<RoutingConfigName>,\n    pub description: Option<String>,\n    pub algorithm: Option<Static\n\n... [truncated 55584 chars] ...\n\n payment.method.cardtype = (debit, credit)\n    EnumVariantArray(Vec<String>),\n    /// Like a number array but can include comparisons. Useful for\n    /// conditions like \"500 < amount < 1000\"\n    /// eg: payment.amount = (> 500, < 1000)\n    NumberComparisonArray(Vec<NumberComparison>),\n}\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, ToSchema)]\npub struct MetadataValue {\n    pub key: String,\n    pub value: String,\n}\n/// Represents a number comparison for \"NumberComparisonArrayValue\"\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize, ToSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct NumberComparison {\n    pub comparison_type: ComparisonType,\n    pub number: u64,\n}\n/// Conditional comparison type\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, ToSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ComparisonType {\n    Equal,\n    NotEqual,\n    LessThan,\n    LessThanEqual,\n    GreaterThan,\n    GreaterThanEqual,\n}\n", "function_name": "crates__api_models__src__routing.rs", "file": "crates__api_models__src__routing.rs"}, {"query": "how to convert API models to storage models", "code": "use actix_web::http::header::HeaderMap;\nuse api_models::{\n    cards_info as card_info_types, enums as api_enums, gsm as gsm_api_types, payment_methods,\n    payments, routing::ConnectorSelection,\n};\nuse common_utils::{\n    consts::X_HS_LATENCY,\n    crypto::Encryptable,\n    ext_traits::{Encode, StringExt, ValueExt},\n    fp_utils::when,\n    pii,\n    types::ConnectorTransactionIdTrait,\n};\nuse diesel_models::enums as storage_enums;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::CustomerData;\nuse hyperswitch_interfaces::api::ConnectorSpecifications;\nuse masking::{ExposeInterface, PeekInterface, Secret};\n\nuse super::domain;\n#[cfg(feature = \"v2\")]\nuse crate::db::storage::revenue_recovery_redis_operation;\nuse crate::{\n    core::errors,\n    headers::{\n        ACCEPT_LANGUAGE, BROWSER_NAME, X_APP_ID, X_CLIENT_PLATFORM, X_CLIENT_SOURCE,\n        X_CLIENT_VERSION, X_MERCHANT_DOMAIN, X_PAYMENT_CONFIRM_SOURCE, X_REDIRECT_URI,\n        X_REFERENCE_ID,\n    },\n    services::authentication::get_header_value_by_key,\n    types::{\n        self as router_types,\n        api::{self as api_types, routing as routing_types},\n        storage,\n    },\n};\n\npub trait ForeignInto<T> {\n    fn foreign_into(self) -> T;\n}\n\npub trait ForeignTryInto<T> {\n    type Error;\n\n    fn foreign_try_into(self) -> Result<T, Self::Error>;\n}\n\npub trait ForeignFrom<F> {\n    fn foreign_from(from: F) -> Self;\n}\n\npub trait ForeignTryFrom<F>: Sized {\n    type Error;\n\n    fn foreign_try_from(from: F) -> Result<Self, Self::Error>;\n}\n\nimpl<F, T> ForeignInto<T> for F\nwhere\n    T: ForeignFrom<F>,\n{\n    fn foreign_into(self) -> T {\n        T::foreign_from(self)\n    }\n}\n\nimpl<F, T> ForeignTryInto<T> for F\nwhere\n    T: ForeignTryFrom<F>,\n{\n    type Error = <T as ForeignTryFrom<F>>::Error;\n\n    fn foreign_try_into(self) -> Result<T, Self::Error> {\n        T::foreign_try_from(self)\n    }\n}\n\nimpl ForeignFrom<api_models::refunds::RefundType> for storage_enums::RefundType {\n    fn foreign_from(item: \n\n... [truncated 102235 chars] ...\n\nrevenue_recovery_redis_operation::PaymentProcessorTokenStatus) -> Self {\n        let card_info = &value.payment_processor_token_details;\n        // TODO! All other card info fields needs to be populated in redis.\n        Self {\n            card_issuer: card_info.card_issuer.to_owned(),\n            card_network: card_info.card_network.to_owned(),\n            card_type: card_info.card_type.to_owned(),\n            card_issuing_country: None,\n            card_issuing_country_code: None,\n            bank_code: None,\n            last4: card_info.last_four_digits.to_owned(),\n            card_isin: None,\n            card_extended_bin: None,\n            card_exp_month: card_info.expiry_month.to_owned(),\n            card_exp_year: card_info.expiry_year.to_owned(),\n            card_holder_name: None,\n            payment_checks: None,\n            authentication_data: None,\n            is_regulated: None,\n            signature_network: None,\n            auth_code: None,\n        }\n    }\n}\n", "function_name": "crates__router__src__types__transformers.rs", "file": "crates__router__src__types__transformers.rs"}, {"query": "ForeignFrom trait implementation", "code": "use actix_web::http::header::HeaderMap;\nuse api_models::{\n    cards_info as card_info_types, enums as api_enums, gsm as gsm_api_types, payment_methods,\n    payments, routing::ConnectorSelection,\n};\nuse common_utils::{\n    consts::X_HS_LATENCY,\n    crypto::Encryptable,\n    ext_traits::{Encode, StringExt, ValueExt},\n    fp_utils::when,\n    pii,\n    types::ConnectorTransactionIdTrait,\n};\nuse diesel_models::enums as storage_enums;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::CustomerData;\nuse hyperswitch_interfaces::api::ConnectorSpecifications;\nuse masking::{ExposeInterface, PeekInterface, Secret};\n\nuse super::domain;\n#[cfg(feature = \"v2\")]\nuse crate::db::storage::revenue_recovery_redis_operation;\nuse crate::{\n    core::errors,\n    headers::{\n        ACCEPT_LANGUAGE, BROWSER_NAME, X_APP_ID, X_CLIENT_PLATFORM, X_CLIENT_SOURCE,\n        X_CLIENT_VERSION, X_MERCHANT_DOMAIN, X_PAYMENT_CONFIRM_SOURCE, X_REDIRECT_URI,\n        X_REFERENCE_ID,\n    },\n    services::authentication::get_header_value_by_key,\n    types::{\n        self as router_types,\n        api::{self as api_types, routing as routing_types},\n        storage,\n    },\n};\n\npub trait ForeignInto<T> {\n    fn foreign_into(self) -> T;\n}\n\npub trait ForeignTryInto<T> {\n    type Error;\n\n    fn foreign_try_into(self) -> Result<T, Self::Error>;\n}\n\npub trait ForeignFrom<F> {\n    fn foreign_from(from: F) -> Self;\n}\n\npub trait ForeignTryFrom<F>: Sized {\n    type Error;\n\n    fn foreign_try_from(from: F) -> Result<Self, Self::Error>;\n}\n\nimpl<F, T> ForeignInto<T> for F\nwhere\n    T: ForeignFrom<F>,\n{\n    fn foreign_into(self) -> T {\n        T::foreign_from(self)\n    }\n}\n\nimpl<F, T> ForeignTryInto<T> for F\nwhere\n    T: ForeignTryFrom<F>,\n{\n    type Error = <T as ForeignTryFrom<F>>::Error;\n\n    fn foreign_try_into(self) -> Result<T, Self::Error> {\n        T::foreign_try_from(self)\n    }\n}\n\nimpl ForeignFrom<api_models::refunds::RefundType> for storage_enums::RefundType {\n    fn foreign_from(item: \n\n... [truncated 102235 chars] ...\n\nrevenue_recovery_redis_operation::PaymentProcessorTokenStatus) -> Self {\n        let card_info = &value.payment_processor_token_details;\n        // TODO! All other card info fields needs to be populated in redis.\n        Self {\n            card_issuer: card_info.card_issuer.to_owned(),\n            card_network: card_info.card_network.to_owned(),\n            card_type: card_info.card_type.to_owned(),\n            card_issuing_country: None,\n            card_issuing_country_code: None,\n            bank_code: None,\n            last4: card_info.last_four_digits.to_owned(),\n            card_isin: None,\n            card_extended_bin: None,\n            card_exp_month: card_info.expiry_month.to_owned(),\n            card_exp_year: card_info.expiry_year.to_owned(),\n            card_holder_name: None,\n            payment_checks: None,\n            authentication_data: None,\n            is_regulated: None,\n            signature_network: None,\n            auth_code: None,\n        }\n    }\n}\n", "function_name": "crates__router__src__types__transformers.rs", "file": "crates__router__src__types__transformers.rs"}, {"query": "convert payment intent to storage", "code": "use actix_web::http::header::HeaderMap;\nuse api_models::{\n    cards_info as card_info_types, enums as api_enums, gsm as gsm_api_types, payment_methods,\n    payments, routing::ConnectorSelection,\n};\nuse common_utils::{\n    consts::X_HS_LATENCY,\n    crypto::Encryptable,\n    ext_traits::{Encode, StringExt, ValueExt},\n    fp_utils::when,\n    pii,\n    types::ConnectorTransactionIdTrait,\n};\nuse diesel_models::enums as storage_enums;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::CustomerData;\nuse hyperswitch_interfaces::api::ConnectorSpecifications;\nuse masking::{ExposeInterface, PeekInterface, Secret};\n\nuse super::domain;\n#[cfg(feature = \"v2\")]\nuse crate::db::storage::revenue_recovery_redis_operation;\nuse crate::{\n    core::errors,\n    headers::{\n        ACCEPT_LANGUAGE, BROWSER_NAME, X_APP_ID, X_CLIENT_PLATFORM, X_CLIENT_SOURCE,\n        X_CLIENT_VERSION, X_MERCHANT_DOMAIN, X_PAYMENT_CONFIRM_SOURCE, X_REDIRECT_URI,\n        X_REFERENCE_ID,\n    },\n    services::authentication::get_header_value_by_key,\n    types::{\n        self as router_types,\n        api::{self as api_types, routing as routing_types},\n        storage,\n    },\n};\n\npub trait ForeignInto<T> {\n    fn foreign_into(self) -> T;\n}\n\npub trait ForeignTryInto<T> {\n    type Error;\n\n    fn foreign_try_into(self) -> Result<T, Self::Error>;\n}\n\npub trait ForeignFrom<F> {\n    fn foreign_from(from: F) -> Self;\n}\n\npub trait ForeignTryFrom<F>: Sized {\n    type Error;\n\n    fn foreign_try_from(from: F) -> Result<Self, Self::Error>;\n}\n\nimpl<F, T> ForeignInto<T> for F\nwhere\n    T: ForeignFrom<F>,\n{\n    fn foreign_into(self) -> T {\n        T::foreign_from(self)\n    }\n}\n\nimpl<F, T> ForeignTryInto<T> for F\nwhere\n    T: ForeignTryFrom<F>,\n{\n    type Error = <T as ForeignTryFrom<F>>::Error;\n\n    fn foreign_try_into(self) -> Result<T, Self::Error> {\n        T::foreign_try_from(self)\n    }\n}\n\nimpl ForeignFrom<api_models::refunds::RefundType> for storage_enums::RefundType {\n    fn foreign_from(item: \n\n... [truncated 102235 chars] ...\n\nrevenue_recovery_redis_operation::PaymentProcessorTokenStatus) -> Self {\n        let card_info = &value.payment_processor_token_details;\n        // TODO! All other card info fields needs to be populated in redis.\n        Self {\n            card_issuer: card_info.card_issuer.to_owned(),\n            card_network: card_info.card_network.to_owned(),\n            card_type: card_info.card_type.to_owned(),\n            card_issuing_country: None,\n            card_issuing_country_code: None,\n            bank_code: None,\n            last4: card_info.last_four_digits.to_owned(),\n            card_isin: None,\n            card_extended_bin: None,\n            card_exp_month: card_info.expiry_month.to_owned(),\n            card_exp_year: card_info.expiry_year.to_owned(),\n            card_holder_name: None,\n            payment_checks: None,\n            authentication_data: None,\n            is_regulated: None,\n            signature_network: None,\n            auth_code: None,\n        }\n    }\n}\n", "function_name": "crates__router__src__types__transformers.rs", "file": "crates__router__src__types__transformers.rs"}, {"query": "RefundType enum mapping", "code": "use actix_web::http::header::HeaderMap;\nuse api_models::{\n    cards_info as card_info_types, enums as api_enums, gsm as gsm_api_types, payment_methods,\n    payments, routing::ConnectorSelection,\n};\nuse common_utils::{\n    consts::X_HS_LATENCY,\n    crypto::Encryptable,\n    ext_traits::{Encode, StringExt, ValueExt},\n    fp_utils::when,\n    pii,\n    types::ConnectorTransactionIdTrait,\n};\nuse diesel_models::enums as storage_enums;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::CustomerData;\nuse hyperswitch_interfaces::api::ConnectorSpecifications;\nuse masking::{ExposeInterface, PeekInterface, Secret};\n\nuse super::domain;\n#[cfg(feature = \"v2\")]\nuse crate::db::storage::revenue_recovery_redis_operation;\nuse crate::{\n    core::errors,\n    headers::{\n        ACCEPT_LANGUAGE, BROWSER_NAME, X_APP_ID, X_CLIENT_PLATFORM, X_CLIENT_SOURCE,\n        X_CLIENT_VERSION, X_MERCHANT_DOMAIN, X_PAYMENT_CONFIRM_SOURCE, X_REDIRECT_URI,\n        X_REFERENCE_ID,\n    },\n    services::authentication::get_header_value_by_key,\n    types::{\n        self as router_types,\n        api::{self as api_types, routing as routing_types},\n        storage,\n    },\n};\n\npub trait ForeignInto<T> {\n    fn foreign_into(self) -> T;\n}\n\npub trait ForeignTryInto<T> {\n    type Error;\n\n    fn foreign_try_into(self) -> Result<T, Self::Error>;\n}\n\npub trait ForeignFrom<F> {\n    fn foreign_from(from: F) -> Self;\n}\n\npub trait ForeignTryFrom<F>: Sized {\n    type Error;\n\n    fn foreign_try_from(from: F) -> Result<Self, Self::Error>;\n}\n\nimpl<F, T> ForeignInto<T> for F\nwhere\n    T: ForeignFrom<F>,\n{\n    fn foreign_into(self) -> T {\n        T::foreign_from(self)\n    }\n}\n\nimpl<F, T> ForeignTryInto<T> for F\nwhere\n    T: ForeignTryFrom<F>,\n{\n    type Error = <T as ForeignTryFrom<F>>::Error;\n\n    fn foreign_try_into(self) -> Result<T, Self::Error> {\n        T::foreign_try_from(self)\n    }\n}\n\nimpl ForeignFrom<api_models::refunds::RefundType> for storage_enums::RefundType {\n    fn foreign_from(item: \n\n... [truncated 102235 chars] ...\n\nrevenue_recovery_redis_operation::PaymentProcessorTokenStatus) -> Self {\n        let card_info = &value.payment_processor_token_details;\n        // TODO! All other card info fields needs to be populated in redis.\n        Self {\n            card_issuer: card_info.card_issuer.to_owned(),\n            card_network: card_info.card_network.to_owned(),\n            card_type: card_info.card_type.to_owned(),\n            card_issuing_country: None,\n            card_issuing_country_code: None,\n            bank_code: None,\n            last4: card_info.last_four_digits.to_owned(),\n            card_isin: None,\n            card_extended_bin: None,\n            card_exp_month: card_info.expiry_month.to_owned(),\n            card_exp_year: card_info.expiry_year.to_owned(),\n            card_holder_name: None,\n            payment_checks: None,\n            authentication_data: None,\n            is_regulated: None,\n            signature_network: None,\n            auth_code: None,\n        }\n    }\n}\n", "function_name": "crates__router__src__types__transformers.rs", "file": "crates__router__src__types__transformers.rs"}, {"query": "Bluesnap payment request transformation", "code": "use std::collections::HashMap;\n\nuse api_models::{\n    payments::{\n        AmountInfo, ApplePayPaymentRequest, ApplePaySessionResponse,\n        ApplepayCombinedSessionTokenData, ApplepaySessionTokenData, ApplepaySessionTokenMetadata,\n        ApplepaySessionTokenResponse, NextActionCall, NoThirdPartySdkSessionResponse,\n        SdkNextAction, SessionToken,\n    },\n    webhooks::IncomingWebhookEvent,\n};\nuse base64::Engine;\nuse common_enums::{enums, CountryAlpha2};\nuse common_utils::{\n    consts::{APPLEPAY_VALIDATION_URL, BASE64_ENGINE},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, Encode, OptionExt, StringExt, ValueExt},\n    pii::Email,\n    types::{FloatMajorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{self, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, ApplePay, CardData as _, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst DISPLAY_METADATA: &str = \"Y\";\n\n#[derive(Debug, Serialize)]\npub struct BluesnapRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for BluesnapRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, S\n\n... [truncated 40746 chars] ...\n\n address.get_first_name()?;\n    Ok(Some(BluesnapCardHolderInfo {\n        first_name: first_name.clone(),\n        last_name: address.get_last_name().unwrap_or(first_name).clone(),\n        email,\n    }))\n}\n\nimpl From<ErrorDetails> for utils::ErrorCodeAndMessage {\n    fn from(error: ErrorDetails) -> Self {\n        Self {\n            error_code: error.code.to_string(),\n            error_message: error.error_name.unwrap_or(error.code),\n        }\n    }\n}\n\nfn convert_metadata_to_request_metadata(metadata: Value) -> Vec<RequestMetadata> {\n    let hashmap: HashMap<Option<String>, Option<Value>> =\n        serde_json::from_str(&metadata.to_string()).unwrap_or(HashMap::new());\n    let mut vector = Vec::<RequestMetadata>::new();\n    for (key, value) in hashmap {\n        vector.push(RequestMetadata {\n            meta_key: key,\n            meta_value: value.map(|field_value| field_value.to_string()),\n            is_visible: Some(DISPLAY_METADATA.to_string()),\n        });\n    }\n    vector\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bluesnap__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bluesnap__transformers.rs"}, {"query": "hyperswitch bluesnap connector integration", "code": "use std::collections::HashMap;\n\nuse api_models::{\n    payments::{\n        AmountInfo, ApplePayPaymentRequest, ApplePaySessionResponse,\n        ApplepayCombinedSessionTokenData, ApplepaySessionTokenData, ApplepaySessionTokenMetadata,\n        ApplepaySessionTokenResponse, NextActionCall, NoThirdPartySdkSessionResponse,\n        SdkNextAction, SessionToken,\n    },\n    webhooks::IncomingWebhookEvent,\n};\nuse base64::Engine;\nuse common_enums::{enums, CountryAlpha2};\nuse common_utils::{\n    consts::{APPLEPAY_VALIDATION_URL, BASE64_ENGINE},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, Encode, OptionExt, StringExt, ValueExt},\n    pii::Email,\n    types::{FloatMajorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{self, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, ApplePay, CardData as _, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst DISPLAY_METADATA: &str = \"Y\";\n\n#[derive(Debug, Serialize)]\npub struct BluesnapRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for BluesnapRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, S\n\n... [truncated 40746 chars] ...\n\n address.get_first_name()?;\n    Ok(Some(BluesnapCardHolderInfo {\n        first_name: first_name.clone(),\n        last_name: address.get_last_name().unwrap_or(first_name).clone(),\n        email,\n    }))\n}\n\nimpl From<ErrorDetails> for utils::ErrorCodeAndMessage {\n    fn from(error: ErrorDetails) -> Self {\n        Self {\n            error_code: error.code.to_string(),\n            error_message: error.error_name.unwrap_or(error.code),\n        }\n    }\n}\n\nfn convert_metadata_to_request_metadata(metadata: Value) -> Vec<RequestMetadata> {\n    let hashmap: HashMap<Option<String>, Option<Value>> =\n        serde_json::from_str(&metadata.to_string()).unwrap_or(HashMap::new());\n    let mut vector = Vec::<RequestMetadata>::new();\n    for (key, value) in hashmap {\n        vector.push(RequestMetadata {\n            meta_key: key,\n            meta_value: value.map(|field_value| field_value.to_string()),\n            is_visible: Some(DISPLAY_METADATA.to_string()),\n        });\n    }\n    vector\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bluesnap__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bluesnap__transformers.rs"}, {"query": "how to map hyperswitch to bluesnap", "code": "use std::collections::HashMap;\n\nuse api_models::{\n    payments::{\n        AmountInfo, ApplePayPaymentRequest, ApplePaySessionResponse,\n        ApplepayCombinedSessionTokenData, ApplepaySessionTokenData, ApplepaySessionTokenMetadata,\n        ApplepaySessionTokenResponse, NextActionCall, NoThirdPartySdkSessionResponse,\n        SdkNextAction, SessionToken,\n    },\n    webhooks::IncomingWebhookEvent,\n};\nuse base64::Engine;\nuse common_enums::{enums, CountryAlpha2};\nuse common_utils::{\n    consts::{APPLEPAY_VALIDATION_URL, BASE64_ENGINE},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, Encode, OptionExt, StringExt, ValueExt},\n    pii::Email,\n    types::{FloatMajorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{self, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, ApplePay, CardData as _, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst DISPLAY_METADATA: &str = \"Y\";\n\n#[derive(Debug, Serialize)]\npub struct BluesnapRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for BluesnapRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, S\n\n... [truncated 40746 chars] ...\n\n address.get_first_name()?;\n    Ok(Some(BluesnapCardHolderInfo {\n        first_name: first_name.clone(),\n        last_name: address.get_last_name().unwrap_or(first_name).clone(),\n        email,\n    }))\n}\n\nimpl From<ErrorDetails> for utils::ErrorCodeAndMessage {\n    fn from(error: ErrorDetails) -> Self {\n        Self {\n            error_code: error.code.to_string(),\n            error_message: error.error_name.unwrap_or(error.code),\n        }\n    }\n}\n\nfn convert_metadata_to_request_metadata(metadata: Value) -> Vec<RequestMetadata> {\n    let hashmap: HashMap<Option<String>, Option<Value>> =\n        serde_json::from_str(&metadata.to_string()).unwrap_or(HashMap::new());\n    let mut vector = Vec::<RequestMetadata>::new();\n    for (key, value) in hashmap {\n        vector.push(RequestMetadata {\n            meta_key: key,\n            meta_value: value.map(|field_value| field_value.to_string()),\n            is_visible: Some(DISPLAY_METADATA.to_string()),\n        });\n    }\n    vector\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bluesnap__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bluesnap__transformers.rs"}, {"query": "BluesnapPaymentsRequest struct definition", "code": "use std::collections::HashMap;\n\nuse api_models::{\n    payments::{\n        AmountInfo, ApplePayPaymentRequest, ApplePaySessionResponse,\n        ApplepayCombinedSessionTokenData, ApplepaySessionTokenData, ApplepaySessionTokenMetadata,\n        ApplepaySessionTokenResponse, NextActionCall, NoThirdPartySdkSessionResponse,\n        SdkNextAction, SessionToken,\n    },\n    webhooks::IncomingWebhookEvent,\n};\nuse base64::Engine;\nuse common_enums::{enums, CountryAlpha2};\nuse common_utils::{\n    consts::{APPLEPAY_VALIDATION_URL, BASE64_ENGINE},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, Encode, OptionExt, StringExt, ValueExt},\n    pii::Email,\n    types::{FloatMajorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{self, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, ApplePay, CardData as _, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst DISPLAY_METADATA: &str = \"Y\";\n\n#[derive(Debug, Serialize)]\npub struct BluesnapRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for BluesnapRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, S\n\n... [truncated 40746 chars] ...\n\n address.get_first_name()?;\n    Ok(Some(BluesnapCardHolderInfo {\n        first_name: first_name.clone(),\n        last_name: address.get_last_name().unwrap_or(first_name).clone(),\n        email,\n    }))\n}\n\nimpl From<ErrorDetails> for utils::ErrorCodeAndMessage {\n    fn from(error: ErrorDetails) -> Self {\n        Self {\n            error_code: error.code.to_string(),\n            error_message: error.error_name.unwrap_or(error.code),\n        }\n    }\n}\n\nfn convert_metadata_to_request_metadata(metadata: Value) -> Vec<RequestMetadata> {\n    let hashmap: HashMap<Option<String>, Option<Value>> =\n        serde_json::from_str(&metadata.to_string()).unwrap_or(HashMap::new());\n    let mut vector = Vec::<RequestMetadata>::new();\n    for (key, value) in hashmap {\n        vector.push(RequestMetadata {\n            meta_key: key,\n            meta_value: value.map(|field_value| field_value.to_string()),\n            is_visible: Some(DISPLAY_METADATA.to_string()),\n        });\n    }\n    vector\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bluesnap__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bluesnap__transformers.rs"}, {"query": "how to mask sort code and routing number", "code": "//! Contains new types with restrictions\nuse masking::{ExposeInterface, PeekInterface, Secret};\n\nuse crate::{\n    consts::MAX_ALLOWED_MERCHANT_NAME_LENGTH,\n    pii::{Email, UpiVpaMaskingStrategy},\n    transformers::ForeignFrom,\n};\n\n#[nutype::nutype(\n    derive(Clone, Serialize, Deserialize, Debug),\n    validate(len_char_min = 1, len_char_max = MAX_ALLOWED_MERCHANT_NAME_LENGTH)\n)]\npub struct MerchantName(String);\n\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string()\n\n... [truncated 7865 chars] ...\n\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}\n", "function_name": "crates__common_utils__src__new_type.rs", "file": "crates__common_utils__src__new_type.rs"}, {"query": "Rust new type pattern for sensitive data", "code": "//! Contains new types with restrictions\nuse masking::{ExposeInterface, PeekInterface, Secret};\n\nuse crate::{\n    consts::MAX_ALLOWED_MERCHANT_NAME_LENGTH,\n    pii::{Email, UpiVpaMaskingStrategy},\n    transformers::ForeignFrom,\n};\n\n#[nutype::nutype(\n    derive(Clone, Serialize, Deserialize, Debug),\n    validate(len_char_min = 1, len_char_max = MAX_ALLOWED_MERCHANT_NAME_LENGTH)\n)]\npub struct MerchantName(String);\n\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string()\n\n... [truncated 7865 chars] ...\n\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}\n", "function_name": "crates__common_utils__src__new_type.rs", "file": "crates__common_utils__src__new_type.rs"}, {"query": "implement PII masking in payment system", "code": "//! Contains new types with restrictions\nuse masking::{ExposeInterface, PeekInterface, Secret};\n\nuse crate::{\n    consts::MAX_ALLOWED_MERCHANT_NAME_LENGTH,\n    pii::{Email, UpiVpaMaskingStrategy},\n    transformers::ForeignFrom,\n};\n\n#[nutype::nutype(\n    derive(Clone, Serialize, Deserialize, Debug),\n    validate(len_char_min = 1, len_char_max = MAX_ALLOWED_MERCHANT_NAME_LENGTH)\n)]\npub struct MerchantName(String);\n\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string()\n\n... [truncated 7865 chars] ...\n\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}\n", "function_name": "crates__common_utils__src__new_type.rs", "file": "crates__common_utils__src__new_type.rs"}, {"query": "MaskedSortCode and MaskedRoutingNumber types", "code": "//! Contains new types with restrictions\nuse masking::{ExposeInterface, PeekInterface, Secret};\n\nuse crate::{\n    consts::MAX_ALLOWED_MERCHANT_NAME_LENGTH,\n    pii::{Email, UpiVpaMaskingStrategy},\n    transformers::ForeignFrom,\n};\n\n#[nutype::nutype(\n    derive(Clone, Serialize, Deserialize, Debug),\n    validate(len_char_min = 1, len_char_max = MAX_ALLOWED_MERCHANT_NAME_LENGTH)\n)]\npub struct MerchantName(String);\n\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string()\n\n... [truncated 7865 chars] ...\n\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}\n", "function_name": "crates__common_utils__src__new_type.rs", "file": "crates__common_utils__src__new_type.rs"}, {"query": "Redsys payment gateway integration hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        unified_authentication_service::{Authenticate, PreAuthenticate},\n        CompleteAuthorize, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthenticateType, PaymentsAuthorizeType, PaymentsCaptureType,\n        PaymentsCompleteAuthorizeTy\n\n... [truncated 38755 chars] ...\n\nR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*REDSYS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&REDSYS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n    ) -> String {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            connector_utils::generate_12_digit_number().to_string()\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "file": "crates__hyperswitch_connectors__src__connectors__redsys.rs"}, {"query": "Redsys struct implementation hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        unified_authentication_service::{Authenticate, PreAuthenticate},\n        CompleteAuthorize, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthenticateType, PaymentsAuthorizeType, PaymentsCaptureType,\n        PaymentsCompleteAuthorizeTy\n\n... [truncated 38755 chars] ...\n\nR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*REDSYS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&REDSYS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n    ) -> String {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            connector_utils::generate_12_digit_number().to_string()\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "file": "crates__hyperswitch_connectors__src__connectors__redsys.rs"}, {"query": "how to configure Redsys connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        unified_authentication_service::{Authenticate, PreAuthenticate},\n        CompleteAuthorize, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthenticateType, PaymentsAuthorizeType, PaymentsCaptureType,\n        PaymentsCompleteAuthorizeTy\n\n... [truncated 38755 chars] ...\n\nR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*REDSYS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&REDSYS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n    ) -> String {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            connector_utils::generate_12_digit_number().to_string()\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "file": "crates__hyperswitch_connectors__src__connectors__redsys.rs"}, {"query": "Redsys payment authorization flow", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        unified_authentication_service::{Authenticate, PreAuthenticate},\n        CompleteAuthorize, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthenticateType, PaymentsAuthorizeType, PaymentsCaptureType,\n        PaymentsCompleteAuthorizeTy\n\n... [truncated 38755 chars] ...\n\nR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*REDSYS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&REDSYS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n    ) -> String {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            connector_utils::generate_12_digit_number().to_string()\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "file": "crates__hyperswitch_connectors__src__connectors__redsys.rs"}, {"query": "Wells Fargo payment integration", "code": "use api_models::payments;\nuse base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    consts, pii,\n    types::{SemanticVersion, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankDebitData, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct WellsfargoRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for WellsfargoRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n\n... [truncated 91736 chars] ...\n\non(\n    error_info: Option<String>,\n    detailed_error_info: Option<String>,\n    avs_error_info: Option<String>,\n) -> Option<String> {\n    match (error_info, detailed_error_info, avs_error_info) {\n        (Some(message), Some(details), Some(avs_message)) => Some(format!(\n            \"{message}, detailed_error_information: {details}, avs_message: {avs_message}\",\n        )),\n        (Some(message), Some(details), None) => {\n            Some(format!(\"{message}, detailed_error_information: {details}\"))\n        }\n        (Some(message), None, Some(avs_message)) => {\n            Some(format!(\"{message}, avs_message: {avs_message}\"))\n        }\n        (None, Some(details), Some(avs_message)) => {\n            Some(format!(\"{details}, avs_message: {avs_message}\"))\n        }\n        (Some(message), None, None) => Some(message),\n        (None, Some(details), None) => Some(details),\n        (None, None, Some(avs_message)) => Some(avs_message),\n        (None, None, None) => None,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs"}, {"query": "WellsfargoRouterData struct", "code": "use api_models::payments;\nuse base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    consts, pii,\n    types::{SemanticVersion, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankDebitData, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct WellsfargoRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for WellsfargoRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n\n... [truncated 91736 chars] ...\n\non(\n    error_info: Option<String>,\n    detailed_error_info: Option<String>,\n    avs_error_info: Option<String>,\n) -> Option<String> {\n    match (error_info, detailed_error_info, avs_error_info) {\n        (Some(message), Some(details), Some(avs_message)) => Some(format!(\n            \"{message}, detailed_error_information: {details}, avs_message: {avs_message}\",\n        )),\n        (Some(message), Some(details), None) => {\n            Some(format!(\"{message}, detailed_error_information: {details}\"))\n        }\n        (Some(message), None, Some(avs_message)) => {\n            Some(format!(\"{message}, avs_message: {avs_message}\"))\n        }\n        (None, Some(details), Some(avs_message)) => {\n            Some(format!(\"{details}, avs_message: {avs_message}\"))\n        }\n        (Some(message), None, None) => Some(message),\n        (None, Some(details), None) => Some(details),\n        (None, None, Some(avs_message)) => Some(avs_message),\n        (None, None, None) => None,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs"}, {"query": "how to implement Wells Fargo mandate", "code": "use api_models::payments;\nuse base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    consts, pii,\n    types::{SemanticVersion, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankDebitData, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct WellsfargoRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for WellsfargoRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n\n... [truncated 91736 chars] ...\n\non(\n    error_info: Option<String>,\n    detailed_error_info: Option<String>,\n    avs_error_info: Option<String>,\n) -> Option<String> {\n    match (error_info, detailed_error_info, avs_error_info) {\n        (Some(message), Some(details), Some(avs_message)) => Some(format!(\n            \"{message}, detailed_error_information: {details}, avs_message: {avs_message}\",\n        )),\n        (Some(message), Some(details), None) => {\n            Some(format!(\"{message}, detailed_error_information: {details}\"))\n        }\n        (Some(message), None, Some(avs_message)) => {\n            Some(format!(\"{message}, avs_message: {avs_message}\"))\n        }\n        (None, Some(details), Some(avs_message)) => {\n            Some(format!(\"{details}, avs_message: {avs_message}\"))\n        }\n        (Some(message), None, None) => Some(message),\n        (None, Some(details), None) => Some(details),\n        (None, None, Some(avs_message)) => Some(avs_message),\n        (None, None, None) => None,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs"}, {"query": "Wells Fargo API transformer", "code": "use api_models::payments;\nuse base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    consts, pii,\n    types::{SemanticVersion, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankDebitData, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct WellsfargoRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for WellsfargoRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n\n... [truncated 91736 chars] ...\n\non(\n    error_info: Option<String>,\n    detailed_error_info: Option<String>,\n    avs_error_info: Option<String>,\n) -> Option<String> {\n    match (error_info, detailed_error_info, avs_error_info) {\n        (Some(message), Some(details), Some(avs_message)) => Some(format!(\n            \"{message}, detailed_error_information: {details}, avs_message: {avs_message}\",\n        )),\n        (Some(message), Some(details), None) => {\n            Some(format!(\"{message}, detailed_error_information: {details}\"))\n        }\n        (Some(message), None, Some(avs_message)) => {\n            Some(format!(\"{message}, avs_message: {avs_message}\"))\n        }\n        (None, Some(details), Some(avs_message)) => {\n            Some(format!(\"{details}, avs_message: {avs_message}\"))\n        }\n        (Some(message), None, None) => Some(message),\n        (None, Some(details), None) => Some(details),\n        (None, None, Some(avs_message)) => Some(avs_message),\n        (None, None, None) => None,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs"}, {"query": "how payment routing works", "code": "mod transformers;\npub mod utils;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse std::collections::hash_map;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse std::hash::{Hash, Hasher};\nuse std::{collections::HashMap, str::FromStr, sync::Arc};\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router::{self as or_types, DecidedGateway, OpenRouterDecideGatewayRequest};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing as api_routing;\nuse api_models::{\n    admin as admin_api,\n    enums::{self as api_enums, CountryAlpha2},\n    routing::ConnectorSelection,\n};\nuse common_types::payments as common_payments_types;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::AsyncExt;\nuse diesel_models::enums as storage_enums;\nuse error_stack::ResultExt;\nuse euclid::{\n    backend::{self, inputs as dsl_inputs, EuclidBackend},\n    dssa::graph::{self as euclid_graph, CgraphExt},\n    enums as euclid_enums,\n    frontend::{ast, dir as euclid_dir},\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting, DynamicRoutingError,\n};\nuse hyperswitch_domain_models::address::Address;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs::{ApiMethod, RoutingEngine};\nuse kgraph_utils::{\n    mca as mca_graph,\n    transformers::{IntoContext, IntoDirValue},\n    types::CountryCurrencyFilter,\n};\nuse masking::{PeekInterface, Secret};\nuse rand::distributions::{self, Distribution};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse rand::SeedableRng;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashMap;\nuse storage_impl::redis::cache::{CacheKey, CGRAPH_CACHE, ROUTING_CACHE};\n\n#[cfg(\n\n... [truncated 113203 chars] ...\n\ns.clone());\n        routing_event.set_routing_approach(api_routing::RoutingApproach::ContractBased.to_string());\n        state.event_handler().log_event(&routing_event);\n        Ok(connectors)\n    } else {\n        Ok(routable_connectors)\n    }\n}\n\npub async fn get_active_mca_ids(\n    state: &SessionState,\n    key_store: &domain::MerchantKeyStore,\n) -> RoutingResult<std::collections::HashSet<common_utils::id_type::MerchantConnectorAccountId>> {\n    let db_mcas = state\n        .store\n        .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n            &key_store.merchant_id,\n            false,\n            key_store,\n        )\n        .await\n        .unwrap_or_else(|_| {\n            hyperswitch_domain_models::merchant_connector_account::MerchantConnectorAccounts::new(\n                vec![],\n            )\n        });\n\n    let active_mca_ids: std::collections::HashSet<_> =\n        db_mcas.iter().map(|mca| mca.get_id().clone()).collect();\n    Ok(active_mca_ids)\n}\n", "function_name": "crates__router__src__core__payments__routing.rs", "file": "crates__router__src__core__payments__routing.rs"}, {"query": "route_payment function", "code": "mod transformers;\npub mod utils;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse std::collections::hash_map;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse std::hash::{Hash, Hasher};\nuse std::{collections::HashMap, str::FromStr, sync::Arc};\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router::{self as or_types, DecidedGateway, OpenRouterDecideGatewayRequest};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing as api_routing;\nuse api_models::{\n    admin as admin_api,\n    enums::{self as api_enums, CountryAlpha2},\n    routing::ConnectorSelection,\n};\nuse common_types::payments as common_payments_types;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::AsyncExt;\nuse diesel_models::enums as storage_enums;\nuse error_stack::ResultExt;\nuse euclid::{\n    backend::{self, inputs as dsl_inputs, EuclidBackend},\n    dssa::graph::{self as euclid_graph, CgraphExt},\n    enums as euclid_enums,\n    frontend::{ast, dir as euclid_dir},\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting, DynamicRoutingError,\n};\nuse hyperswitch_domain_models::address::Address;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs::{ApiMethod, RoutingEngine};\nuse kgraph_utils::{\n    mca as mca_graph,\n    transformers::{IntoContext, IntoDirValue},\n    types::CountryCurrencyFilter,\n};\nuse masking::{PeekInterface, Secret};\nuse rand::distributions::{self, Distribution};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse rand::SeedableRng;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashMap;\nuse storage_impl::redis::cache::{CacheKey, CGRAPH_CACHE, ROUTING_CACHE};\n\n#[cfg(\n\n... [truncated 113203 chars] ...\n\ns.clone());\n        routing_event.set_routing_approach(api_routing::RoutingApproach::ContractBased.to_string());\n        state.event_handler().log_event(&routing_event);\n        Ok(connectors)\n    } else {\n        Ok(routable_connectors)\n    }\n}\n\npub async fn get_active_mca_ids(\n    state: &SessionState,\n    key_store: &domain::MerchantKeyStore,\n) -> RoutingResult<std::collections::HashSet<common_utils::id_type::MerchantConnectorAccountId>> {\n    let db_mcas = state\n        .store\n        .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n            &key_store.merchant_id,\n            false,\n            key_store,\n        )\n        .await\n        .unwrap_or_else(|_| {\n            hyperswitch_domain_models::merchant_connector_account::MerchantConnectorAccounts::new(\n                vec![],\n            )\n        });\n\n    let active_mca_ids: std::collections::HashSet<_> =\n        db_mcas.iter().map(|mca| mca.get_id().clone()).collect();\n    Ok(active_mca_ids)\n}\n", "function_name": "crates__router__src__core__payments__routing.rs", "file": "crates__router__src__core__payments__routing.rs"}, {"query": "implement payment connector selection", "code": "mod transformers;\npub mod utils;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse std::collections::hash_map;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse std::hash::{Hash, Hasher};\nuse std::{collections::HashMap, str::FromStr, sync::Arc};\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router::{self as or_types, DecidedGateway, OpenRouterDecideGatewayRequest};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing as api_routing;\nuse api_models::{\n    admin as admin_api,\n    enums::{self as api_enums, CountryAlpha2},\n    routing::ConnectorSelection,\n};\nuse common_types::payments as common_payments_types;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::AsyncExt;\nuse diesel_models::enums as storage_enums;\nuse error_stack::ResultExt;\nuse euclid::{\n    backend::{self, inputs as dsl_inputs, EuclidBackend},\n    dssa::graph::{self as euclid_graph, CgraphExt},\n    enums as euclid_enums,\n    frontend::{ast, dir as euclid_dir},\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting, DynamicRoutingError,\n};\nuse hyperswitch_domain_models::address::Address;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs::{ApiMethod, RoutingEngine};\nuse kgraph_utils::{\n    mca as mca_graph,\n    transformers::{IntoContext, IntoDirValue},\n    types::CountryCurrencyFilter,\n};\nuse masking::{PeekInterface, Secret};\nuse rand::distributions::{self, Distribution};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse rand::SeedableRng;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashMap;\nuse storage_impl::redis::cache::{CacheKey, CGRAPH_CACHE, ROUTING_CACHE};\n\n#[cfg(\n\n... [truncated 113203 chars] ...\n\ns.clone());\n        routing_event.set_routing_approach(api_routing::RoutingApproach::ContractBased.to_string());\n        state.event_handler().log_event(&routing_event);\n        Ok(connectors)\n    } else {\n        Ok(routable_connectors)\n    }\n}\n\npub async fn get_active_mca_ids(\n    state: &SessionState,\n    key_store: &domain::MerchantKeyStore,\n) -> RoutingResult<std::collections::HashSet<common_utils::id_type::MerchantConnectorAccountId>> {\n    let db_mcas = state\n        .store\n        .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n            &key_store.merchant_id,\n            false,\n            key_store,\n        )\n        .await\n        .unwrap_or_else(|_| {\n            hyperswitch_domain_models::merchant_connector_account::MerchantConnectorAccounts::new(\n                vec![],\n            )\n        });\n\n    let active_mca_ids: std::collections::HashSet<_> =\n        db_mcas.iter().map(|mca| mca.get_id().clone()).collect();\n    Ok(active_mca_ids)\n}\n", "function_name": "crates__router__src__core__payments__routing.rs", "file": "crates__router__src__core__payments__routing.rs"}, {"query": "dynamic routing algorithm Rust", "code": "mod transformers;\npub mod utils;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse std::collections::hash_map;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse std::hash::{Hash, Hasher};\nuse std::{collections::HashMap, str::FromStr, sync::Arc};\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router::{self as or_types, DecidedGateway, OpenRouterDecideGatewayRequest};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing as api_routing;\nuse api_models::{\n    admin as admin_api,\n    enums::{self as api_enums, CountryAlpha2},\n    routing::ConnectorSelection,\n};\nuse common_types::payments as common_payments_types;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::AsyncExt;\nuse diesel_models::enums as storage_enums;\nuse error_stack::ResultExt;\nuse euclid::{\n    backend::{self, inputs as dsl_inputs, EuclidBackend},\n    dssa::graph::{self as euclid_graph, CgraphExt},\n    enums as euclid_enums,\n    frontend::{ast, dir as euclid_dir},\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting, DynamicRoutingError,\n};\nuse hyperswitch_domain_models::address::Address;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs::{ApiMethod, RoutingEngine};\nuse kgraph_utils::{\n    mca as mca_graph,\n    transformers::{IntoContext, IntoDirValue},\n    types::CountryCurrencyFilter,\n};\nuse masking::{PeekInterface, Secret};\nuse rand::distributions::{self, Distribution};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse rand::SeedableRng;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashMap;\nuse storage_impl::redis::cache::{CacheKey, CGRAPH_CACHE, ROUTING_CACHE};\n\n#[cfg(\n\n... [truncated 113203 chars] ...\n\ns.clone());\n        routing_event.set_routing_approach(api_routing::RoutingApproach::ContractBased.to_string());\n        state.event_handler().log_event(&routing_event);\n        Ok(connectors)\n    } else {\n        Ok(routable_connectors)\n    }\n}\n\npub async fn get_active_mca_ids(\n    state: &SessionState,\n    key_store: &domain::MerchantKeyStore,\n) -> RoutingResult<std::collections::HashSet<common_utils::id_type::MerchantConnectorAccountId>> {\n    let db_mcas = state\n        .store\n        .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n            &key_store.merchant_id,\n            false,\n            key_store,\n        )\n        .await\n        .unwrap_or_else(|_| {\n            hyperswitch_domain_models::merchant_connector_account::MerchantConnectorAccounts::new(\n                vec![],\n            )\n        });\n\n    let active_mca_ids: std::collections::HashSet<_> =\n        db_mcas.iter().map(|mca| mca.get_id().clone()).collect();\n    Ok(active_mca_ids)\n}\n", "function_name": "crates__router__src__core__payments__routing.rs", "file": "crates__router__src__core__payments__routing.rs"}, {"query": "Nordea payment connector implementation", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, date_time,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, AccessTokenAuthenticationResponse, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        AccessTokenAuthentication, CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenAuthenticationRequestData, AccessTokenRequestData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        AccessTokenAuthenticationRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefreshTokenRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, AuthenticationTokenType, RefreshTokenType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Ex\n\n... [truncated 42672 chars] ...\n\ncurrent_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type: _,\n                request_data,\n            } => matches!(\n                &request_data.payment_method_data,\n                payment_method_data::PaymentMethodData::BankDebit(_)\n            ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*NORDEA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NORDEA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*NORDEA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn authentication_token_for_token_creation(&self) -> bool {\n        // Nordea requires authentication token for access token creation\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "file": "crates__hyperswitch_connectors__src__connectors__nordea.rs"}, {"query": "hyperswitch nordea oauth authentication", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, date_time,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, AccessTokenAuthenticationResponse, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        AccessTokenAuthentication, CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenAuthenticationRequestData, AccessTokenRequestData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        AccessTokenAuthenticationRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefreshTokenRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, AuthenticationTokenType, RefreshTokenType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Ex\n\n... [truncated 42672 chars] ...\n\ncurrent_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type: _,\n                request_data,\n            } => matches!(\n                &request_data.payment_method_data,\n                payment_method_data::PaymentMethodData::BankDebit(_)\n            ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*NORDEA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NORDEA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*NORDEA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn authentication_token_for_token_creation(&self) -> bool {\n        // Nordea requires authentication token for access token creation\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "file": "crates__hyperswitch_connectors__src__connectors__nordea.rs"}, {"query": "how to configure nordea connector", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, date_time,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, AccessTokenAuthenticationResponse, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        AccessTokenAuthentication, CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenAuthenticationRequestData, AccessTokenRequestData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        AccessTokenAuthenticationRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefreshTokenRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, AuthenticationTokenType, RefreshTokenType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Ex\n\n... [truncated 42672 chars] ...\n\ncurrent_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type: _,\n                request_data,\n            } => matches!(\n                &request_data.payment_method_data,\n                payment_method_data::PaymentMethodData::BankDebit(_)\n            ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*NORDEA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NORDEA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*NORDEA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn authentication_token_for_token_creation(&self) -> bool {\n        // Nordea requires authentication token for access token creation\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "file": "crates__hyperswitch_connectors__src__connectors__nordea.rs"}, {"query": "nordea hmac signature generation", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, date_time,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, AccessTokenAuthenticationResponse, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        AccessTokenAuthentication, CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenAuthenticationRequestData, AccessTokenRequestData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        AccessTokenAuthenticationRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefreshTokenRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, AuthenticationTokenType, RefreshTokenType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Ex\n\n... [truncated 42672 chars] ...\n\ncurrent_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type: _,\n                request_data,\n            } => matches!(\n                &request_data.payment_method_data,\n                payment_method_data::PaymentMethodData::BankDebit(_)\n            ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*NORDEA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NORDEA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*NORDEA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn authentication_token_for_token_creation(&self) -> bool {\n        // Nordea requires authentication token for access token creation\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "file": "crates__hyperswitch_connectors__src__connectors__nordea.rs"}, {"query": "Rapyd payment response transformation", "code": "use common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct RapydRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for RapydRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct RapydPaymentsRequest {\n    pub amount: FloatMajorUnit,\n    pub currency: enums::Currency,\n    pub payment_method: PaymentMethod,\n    pub payment_method_options: Option<PaymentMethodOptions>,\n    pub merchant_reference_id: Option<String>,\n    pub capture: Option<bool>,\n    pub description: Option<String>,\n    pub complete_payment_url: Option<String>,\n    pub error_payment_url: Option<String>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct PaymentMethodOptions {\n    #[serde(rename = \"3d_required\")]\n    pub three_ds: bool,\n}\n#[derive(Default, Debug, Serialize)]\npub struct PaymentMethod {\n    #[serde(rename = \"type\")]\n    pub pm_type: String,\n    pub fields: Option<PaymentFields>,\n    pub address: Option<Address>,\n    pub digital_wallet: Option<RapydWallet>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct PaymentFiel\n\n... [truncated 18919 chars] ...\n\ntNotSupported,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(untagged)]\npub enum WebhookData {\n    Payment(ResponseData),\n    Refund(RefundResponseData),\n    Dispute(DisputeResponseData),\n}\n\nimpl From<ResponseData> for RapydPaymentsResponse {\n    fn from(value: ResponseData) -> Self {\n        Self {\n            status: Status {\n                error_code: NO_ERROR_CODE.to_owned(),\n                status: None,\n                message: None,\n                response_code: None,\n                operation_id: None,\n            },\n            data: Some(value),\n        }\n    }\n}\n\nimpl From<RefundResponseData> for RefundResponse {\n    fn from(value: RefundResponseData) -> Self {\n        Self {\n            status: Status {\n                error_code: NO_ERROR_CODE.to_owned(),\n                status: None,\n                message: None,\n                response_code: None,\n                operation_id: None,\n            },\n            data: Some(value),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__rapyd__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__rapyd__transformers.rs"}, {"query": "RapydRefundResponseData struct", "code": "use common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct RapydRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for RapydRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct RapydPaymentsRequest {\n    pub amount: FloatMajorUnit,\n    pub currency: enums::Currency,\n    pub payment_method: PaymentMethod,\n    pub payment_method_options: Option<PaymentMethodOptions>,\n    pub merchant_reference_id: Option<String>,\n    pub capture: Option<bool>,\n    pub description: Option<String>,\n    pub complete_payment_url: Option<String>,\n    pub error_payment_url: Option<String>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct PaymentMethodOptions {\n    #[serde(rename = \"3d_required\")]\n    pub three_ds: bool,\n}\n#[derive(Default, Debug, Serialize)]\npub struct PaymentMethod {\n    #[serde(rename = \"type\")]\n    pub pm_type: String,\n    pub fields: Option<PaymentFields>,\n    pub address: Option<Address>,\n    pub digital_wallet: Option<RapydWallet>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct PaymentFiel\n\n... [truncated 18919 chars] ...\n\ntNotSupported,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(untagged)]\npub enum WebhookData {\n    Payment(ResponseData),\n    Refund(RefundResponseData),\n    Dispute(DisputeResponseData),\n}\n\nimpl From<ResponseData> for RapydPaymentsResponse {\n    fn from(value: ResponseData) -> Self {\n        Self {\n            status: Status {\n                error_code: NO_ERROR_CODE.to_owned(),\n                status: None,\n                message: None,\n                response_code: None,\n                operation_id: None,\n            },\n            data: Some(value),\n        }\n    }\n}\n\nimpl From<RefundResponseData> for RefundResponse {\n    fn from(value: RefundResponseData) -> Self {\n        Self {\n            status: Status {\n                error_code: NO_ERROR_CODE.to_owned(),\n                status: None,\n                message: None,\n                response_code: None,\n                operation_id: None,\n            },\n            data: Some(value),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__rapyd__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__rapyd__transformers.rs"}, {"query": "how to handle Rapyd webhook disputes", "code": "use common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct RapydRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for RapydRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct RapydPaymentsRequest {\n    pub amount: FloatMajorUnit,\n    pub currency: enums::Currency,\n    pub payment_method: PaymentMethod,\n    pub payment_method_options: Option<PaymentMethodOptions>,\n    pub merchant_reference_id: Option<String>,\n    pub capture: Option<bool>,\n    pub description: Option<String>,\n    pub complete_payment_url: Option<String>,\n    pub error_payment_url: Option<String>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct PaymentMethodOptions {\n    #[serde(rename = \"3d_required\")]\n    pub three_ds: bool,\n}\n#[derive(Default, Debug, Serialize)]\npub struct PaymentMethod {\n    #[serde(rename = \"type\")]\n    pub pm_type: String,\n    pub fields: Option<PaymentFields>,\n    pub address: Option<Address>,\n    pub digital_wallet: Option<RapydWallet>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct PaymentFiel\n\n... [truncated 18919 chars] ...\n\ntNotSupported,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(untagged)]\npub enum WebhookData {\n    Payment(ResponseData),\n    Refund(RefundResponseData),\n    Dispute(DisputeResponseData),\n}\n\nimpl From<ResponseData> for RapydPaymentsResponse {\n    fn from(value: ResponseData) -> Self {\n        Self {\n            status: Status {\n                error_code: NO_ERROR_CODE.to_owned(),\n                status: None,\n                message: None,\n                response_code: None,\n                operation_id: None,\n            },\n            data: Some(value),\n        }\n    }\n}\n\nimpl From<RefundResponseData> for RefundResponse {\n    fn from(value: RefundResponseData) -> Self {\n        Self {\n            status: Status {\n                error_code: NO_ERROR_CODE.to_owned(),\n                status: None,\n                message: None,\n                response_code: None,\n                operation_id: None,\n            },\n            data: Some(value),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__rapyd__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__rapyd__transformers.rs"}, {"query": "Rapyd to Hyperswitch data mapping", "code": "use common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct RapydRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for RapydRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct RapydPaymentsRequest {\n    pub amount: FloatMajorUnit,\n    pub currency: enums::Currency,\n    pub payment_method: PaymentMethod,\n    pub payment_method_options: Option<PaymentMethodOptions>,\n    pub merchant_reference_id: Option<String>,\n    pub capture: Option<bool>,\n    pub description: Option<String>,\n    pub complete_payment_url: Option<String>,\n    pub error_payment_url: Option<String>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct PaymentMethodOptions {\n    #[serde(rename = \"3d_required\")]\n    pub three_ds: bool,\n}\n#[derive(Default, Debug, Serialize)]\npub struct PaymentMethod {\n    #[serde(rename = \"type\")]\n    pub pm_type: String,\n    pub fields: Option<PaymentFields>,\n    pub address: Option<Address>,\n    pub digital_wallet: Option<RapydWallet>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct PaymentFiel\n\n... [truncated 18919 chars] ...\n\ntNotSupported,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(untagged)]\npub enum WebhookData {\n    Payment(ResponseData),\n    Refund(RefundResponseData),\n    Dispute(DisputeResponseData),\n}\n\nimpl From<ResponseData> for RapydPaymentsResponse {\n    fn from(value: ResponseData) -> Self {\n        Self {\n            status: Status {\n                error_code: NO_ERROR_CODE.to_owned(),\n                status: None,\n                message: None,\n                response_code: None,\n                operation_id: None,\n            },\n            data: Some(value),\n        }\n    }\n}\n\nimpl From<RefundResponseData> for RefundResponse {\n    fn from(value: RefundResponseData) -> Self {\n        Self {\n            status: Status {\n                error_code: NO_ERROR_CODE.to_owned(),\n                status: None,\n                message: None,\n                response_code: None,\n                operation_id: None,\n            },\n            data: Some(value),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__rapyd__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__rapyd__transformers.rs"}, {"query": "how does ClickToPay authentication work", "code": "pub mod types;\nuse std::str::FromStr;\n\nuse common_utils::ext_traits::StringExt;\n\npub mod utils;\n#[cfg(feature = \"v1\")]\nuse api_models::authentication::{\n    AuthenticationEligibilityCheckData, AuthenticationEligibilityCheckRequest,\n    AuthenticationEligibilityCheckResponse, AuthenticationEligibilityCheckResponseData,\n    AuthenticationEligibilityRequest, AuthenticationEligibilityResponse,\n    AuthenticationRetrieveEligibilityCheckRequest, AuthenticationRetrieveEligibilityCheckResponse,\n    AuthenticationSyncPostUpdateRequest, AuthenticationSyncRequest, AuthenticationSyncResponse,\n    ClickToPayEligibilityCheckResponseData,\n};\nuse api_models::{\n    authentication::{\n        AcquirerDetails, AuthenticationAuthenticateRequest, AuthenticationAuthenticateResponse,\n        AuthenticationCreateRequest, AuthenticationResponse, AuthenticationSdkNextAction,\n        AuthenticationSessionTokenRequest,\n    },\n    payments::{self, CustomerDetails},\n};\n#[cfg(feature = \"v1\")]\nuse common_utils::{errors::CustomResult, ext_traits::ValueExt, types::AmountConvertor};\nuse diesel_models::authentication::Authentication;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    ext_traits::OptionExt,\n    payment_method_data,\n    router_request_types::{\n        authentication::{MessageCategory, PreAuthenticationData},\n        unified_authentication_service::{\n            AuthenticationInfo, PaymentDetails, ServiceSessionIds, ThreeDsMetaData,\n            TransactionDetails, UasAuthenticationRequestData, UasConfirmationRequestData,\n            UasPostAuthenticationRequestData, UasPreAuthenticationRequestData,\n        },\n        BrowserInformation,\n    },\n    types::{\n        UasAuthenticationRouterData, UasPostAuthenticationRouterData,\n        UasPreAuthenticationRouterData,\n    },\n};\nuse masking::{ExposeInterface, PeekInterface};\n\nuse super::{\n    errors::{RouterResponse, RouterResult},\n    payments::helpers::MerchantConnectorAccountType,\n};\nuse\n\n... [truncated 90354 chars] ...\n\n   payments::ClickToPaySessionResponse {\n                dpa_id: click_to_pay_metadata.dpa_id,\n                dpa_name: click_to_pay_metadata.dpa_name,\n                locale: click_to_pay_metadata.locale,\n                card_brands,\n                acquirer_bin: click_to_pay_metadata.acquirer_bin,\n                acquirer_merchant_id: click_to_pay_metadata.acquirer_merchant_id,\n                merchant_category_code: click_to_pay_metadata.merchant_category_code,\n                merchant_country_code: click_to_pay_metadata.merchant_country_code,\n                transaction_amount,\n                transaction_currency_code: transaction_currency,\n                phone_number: customer_details.phone.clone(),\n                email: customer_details.email.clone(),\n                phone_country_code: customer_details.phone_country_code.clone(),\n                provider,\n                dpa_client_id: click_to_pay_metadata.dpa_client_id.clone(),\n            },\n        )),\n    )\n}\n", "function_name": "crates__router__src__core__unified_authentication_service.rs", "file": "crates__router__src__core__unified_authentication_service.rs"}, {"query": "ClickToPay session token generation", "code": "pub mod types;\nuse std::str::FromStr;\n\nuse common_utils::ext_traits::StringExt;\n\npub mod utils;\n#[cfg(feature = \"v1\")]\nuse api_models::authentication::{\n    AuthenticationEligibilityCheckData, AuthenticationEligibilityCheckRequest,\n    AuthenticationEligibilityCheckResponse, AuthenticationEligibilityCheckResponseData,\n    AuthenticationEligibilityRequest, AuthenticationEligibilityResponse,\n    AuthenticationRetrieveEligibilityCheckRequest, AuthenticationRetrieveEligibilityCheckResponse,\n    AuthenticationSyncPostUpdateRequest, AuthenticationSyncRequest, AuthenticationSyncResponse,\n    ClickToPayEligibilityCheckResponseData,\n};\nuse api_models::{\n    authentication::{\n        AcquirerDetails, AuthenticationAuthenticateRequest, AuthenticationAuthenticateResponse,\n        AuthenticationCreateRequest, AuthenticationResponse, AuthenticationSdkNextAction,\n        AuthenticationSessionTokenRequest,\n    },\n    payments::{self, CustomerDetails},\n};\n#[cfg(feature = \"v1\")]\nuse common_utils::{errors::CustomResult, ext_traits::ValueExt, types::AmountConvertor};\nuse diesel_models::authentication::Authentication;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    ext_traits::OptionExt,\n    payment_method_data,\n    router_request_types::{\n        authentication::{MessageCategory, PreAuthenticationData},\n        unified_authentication_service::{\n            AuthenticationInfo, PaymentDetails, ServiceSessionIds, ThreeDsMetaData,\n            TransactionDetails, UasAuthenticationRequestData, UasConfirmationRequestData,\n            UasPostAuthenticationRequestData, UasPreAuthenticationRequestData,\n        },\n        BrowserInformation,\n    },\n    types::{\n        UasAuthenticationRouterData, UasPostAuthenticationRouterData,\n        UasPreAuthenticationRouterData,\n    },\n};\nuse masking::{ExposeInterface, PeekInterface};\n\nuse super::{\n    errors::{RouterResponse, RouterResult},\n    payments::helpers::MerchantConnectorAccountType,\n};\nuse\n\n... [truncated 90354 chars] ...\n\n   payments::ClickToPaySessionResponse {\n                dpa_id: click_to_pay_metadata.dpa_id,\n                dpa_name: click_to_pay_metadata.dpa_name,\n                locale: click_to_pay_metadata.locale,\n                card_brands,\n                acquirer_bin: click_to_pay_metadata.acquirer_bin,\n                acquirer_merchant_id: click_to_pay_metadata.acquirer_merchant_id,\n                merchant_category_code: click_to_pay_metadata.merchant_category_code,\n                merchant_country_code: click_to_pay_metadata.merchant_country_code,\n                transaction_amount,\n                transaction_currency_code: transaction_currency,\n                phone_number: customer_details.phone.clone(),\n                email: customer_details.email.clone(),\n                phone_country_code: customer_details.phone_country_code.clone(),\n                provider,\n                dpa_client_id: click_to_pay_metadata.dpa_client_id.clone(),\n            },\n        )),\n    )\n}\n", "function_name": "crates__router__src__core__unified_authentication_service.rs", "file": "crates__router__src__core__unified_authentication_service.rs"}, {"query": "implement unified authentication service", "code": "pub mod types;\nuse std::str::FromStr;\n\nuse common_utils::ext_traits::StringExt;\n\npub mod utils;\n#[cfg(feature = \"v1\")]\nuse api_models::authentication::{\n    AuthenticationEligibilityCheckData, AuthenticationEligibilityCheckRequest,\n    AuthenticationEligibilityCheckResponse, AuthenticationEligibilityCheckResponseData,\n    AuthenticationEligibilityRequest, AuthenticationEligibilityResponse,\n    AuthenticationRetrieveEligibilityCheckRequest, AuthenticationRetrieveEligibilityCheckResponse,\n    AuthenticationSyncPostUpdateRequest, AuthenticationSyncRequest, AuthenticationSyncResponse,\n    ClickToPayEligibilityCheckResponseData,\n};\nuse api_models::{\n    authentication::{\n        AcquirerDetails, AuthenticationAuthenticateRequest, AuthenticationAuthenticateResponse,\n        AuthenticationCreateRequest, AuthenticationResponse, AuthenticationSdkNextAction,\n        AuthenticationSessionTokenRequest,\n    },\n    payments::{self, CustomerDetails},\n};\n#[cfg(feature = \"v1\")]\nuse common_utils::{errors::CustomResult, ext_traits::ValueExt, types::AmountConvertor};\nuse diesel_models::authentication::Authentication;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    ext_traits::OptionExt,\n    payment_method_data,\n    router_request_types::{\n        authentication::{MessageCategory, PreAuthenticationData},\n        unified_authentication_service::{\n            AuthenticationInfo, PaymentDetails, ServiceSessionIds, ThreeDsMetaData,\n            TransactionDetails, UasAuthenticationRequestData, UasConfirmationRequestData,\n            UasPostAuthenticationRequestData, UasPreAuthenticationRequestData,\n        },\n        BrowserInformation,\n    },\n    types::{\n        UasAuthenticationRouterData, UasPostAuthenticationRouterData,\n        UasPreAuthenticationRouterData,\n    },\n};\nuse masking::{ExposeInterface, PeekInterface};\n\nuse super::{\n    errors::{RouterResponse, RouterResult},\n    payments::helpers::MerchantConnectorAccountType,\n};\nuse\n\n... [truncated 90354 chars] ...\n\n   payments::ClickToPaySessionResponse {\n                dpa_id: click_to_pay_metadata.dpa_id,\n                dpa_name: click_to_pay_metadata.dpa_name,\n                locale: click_to_pay_metadata.locale,\n                card_brands,\n                acquirer_bin: click_to_pay_metadata.acquirer_bin,\n                acquirer_merchant_id: click_to_pay_metadata.acquirer_merchant_id,\n                merchant_category_code: click_to_pay_metadata.merchant_category_code,\n                merchant_country_code: click_to_pay_metadata.merchant_country_code,\n                transaction_amount,\n                transaction_currency_code: transaction_currency,\n                phone_number: customer_details.phone.clone(),\n                email: customer_details.email.clone(),\n                phone_country_code: customer_details.phone_country_code.clone(),\n                provider,\n                dpa_client_id: click_to_pay_metadata.dpa_client_id.clone(),\n            },\n        )),\n    )\n}\n", "function_name": "crates__router__src__core__unified_authentication_service.rs", "file": "crates__router__src__core__unified_authentication_service.rs"}, {"query": "ClickToPay pre-authentication request data", "code": "pub mod types;\nuse std::str::FromStr;\n\nuse common_utils::ext_traits::StringExt;\n\npub mod utils;\n#[cfg(feature = \"v1\")]\nuse api_models::authentication::{\n    AuthenticationEligibilityCheckData, AuthenticationEligibilityCheckRequest,\n    AuthenticationEligibilityCheckResponse, AuthenticationEligibilityCheckResponseData,\n    AuthenticationEligibilityRequest, AuthenticationEligibilityResponse,\n    AuthenticationRetrieveEligibilityCheckRequest, AuthenticationRetrieveEligibilityCheckResponse,\n    AuthenticationSyncPostUpdateRequest, AuthenticationSyncRequest, AuthenticationSyncResponse,\n    ClickToPayEligibilityCheckResponseData,\n};\nuse api_models::{\n    authentication::{\n        AcquirerDetails, AuthenticationAuthenticateRequest, AuthenticationAuthenticateResponse,\n        AuthenticationCreateRequest, AuthenticationResponse, AuthenticationSdkNextAction,\n        AuthenticationSessionTokenRequest,\n    },\n    payments::{self, CustomerDetails},\n};\n#[cfg(feature = \"v1\")]\nuse common_utils::{errors::CustomResult, ext_traits::ValueExt, types::AmountConvertor};\nuse diesel_models::authentication::Authentication;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    ext_traits::OptionExt,\n    payment_method_data,\n    router_request_types::{\n        authentication::{MessageCategory, PreAuthenticationData},\n        unified_authentication_service::{\n            AuthenticationInfo, PaymentDetails, ServiceSessionIds, ThreeDsMetaData,\n            TransactionDetails, UasAuthenticationRequestData, UasConfirmationRequestData,\n            UasPostAuthenticationRequestData, UasPreAuthenticationRequestData,\n        },\n        BrowserInformation,\n    },\n    types::{\n        UasAuthenticationRouterData, UasPostAuthenticationRouterData,\n        UasPreAuthenticationRouterData,\n    },\n};\nuse masking::{ExposeInterface, PeekInterface};\n\nuse super::{\n    errors::{RouterResponse, RouterResult},\n    payments::helpers::MerchantConnectorAccountType,\n};\nuse\n\n... [truncated 90354 chars] ...\n\n   payments::ClickToPaySessionResponse {\n                dpa_id: click_to_pay_metadata.dpa_id,\n                dpa_name: click_to_pay_metadata.dpa_name,\n                locale: click_to_pay_metadata.locale,\n                card_brands,\n                acquirer_bin: click_to_pay_metadata.acquirer_bin,\n                acquirer_merchant_id: click_to_pay_metadata.acquirer_merchant_id,\n                merchant_category_code: click_to_pay_metadata.merchant_category_code,\n                merchant_country_code: click_to_pay_metadata.merchant_country_code,\n                transaction_amount,\n                transaction_currency_code: transaction_currency,\n                phone_number: customer_details.phone.clone(),\n                email: customer_details.email.clone(),\n                phone_country_code: customer_details.phone_country_code.clone(),\n                provider,\n                dpa_client_id: click_to_pay_metadata.dpa_client_id.clone(),\n            },\n        )),\n    )\n}\n", "function_name": "crates__router__src__core__unified_authentication_service.rs", "file": "crates__router__src__core__unified_authentication_service.rs"}, {"query": "how to implement tax calculation in Rust", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, CalculateTax, Capture, PSync, PaymentMethodToken, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsTaxCalculationData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n        TaxCalculationResponseData,\n    },\n    types::PaymentsTaxCalculationRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as taxjar;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Taxjar {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Taxjar {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Taxjar {}\nimpl api::PaymentSession for Taxjar {}\nimpl api::ConnectorAccessToken for Taxjar {}\nimpl api::MandateSetup for Taxjar {}\nim\n\n... [truncated 8266 chars] ...\n\nngWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic TAXJAR_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Taxjar\",\n    description: \"TaxJar is a cloud-based platform that automates sales tax calculations, reporting, and filing for businesses across multiple channels\",\n    connector_type: common_enums::HyperswitchConnectorCategory::TaxCalculationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Taxjar {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TAXJAR_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__taxjar.rs", "file": "crates__hyperswitch_connectors__src__connectors__taxjar.rs"}, {"query": "TaxJar connector integration hyperswitch", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, CalculateTax, Capture, PSync, PaymentMethodToken, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsTaxCalculationData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n        TaxCalculationResponseData,\n    },\n    types::PaymentsTaxCalculationRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as taxjar;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Taxjar {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Taxjar {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Taxjar {}\nimpl api::PaymentSession for Taxjar {}\nimpl api::ConnectorAccessToken for Taxjar {}\nimpl api::MandateSetup for Taxjar {}\nim\n\n... [truncated 8266 chars] ...\n\nngWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic TAXJAR_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Taxjar\",\n    description: \"TaxJar is a cloud-based platform that automates sales tax calculations, reporting, and filing for businesses across multiple channels\",\n    connector_type: common_enums::HyperswitchConnectorCategory::TaxCalculationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Taxjar {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TAXJAR_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__taxjar.rs", "file": "crates__hyperswitch_connectors__src__connectors__taxjar.rs"}, {"query": "hyperswitch taxjar sales tax calculation", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, CalculateTax, Capture, PSync, PaymentMethodToken, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsTaxCalculationData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n        TaxCalculationResponseData,\n    },\n    types::PaymentsTaxCalculationRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as taxjar;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Taxjar {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Taxjar {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Taxjar {}\nimpl api::PaymentSession for Taxjar {}\nimpl api::ConnectorAccessToken for Taxjar {}\nimpl api::MandateSetup for Taxjar {}\nim\n\n... [truncated 8266 chars] ...\n\nngWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic TAXJAR_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Taxjar\",\n    description: \"TaxJar is a cloud-based platform that automates sales tax calculations, reporting, and filing for businesses across multiple channels\",\n    connector_type: common_enums::HyperswitchConnectorCategory::TaxCalculationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Taxjar {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TAXJAR_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__taxjar.rs", "file": "crates__hyperswitch_connectors__src__connectors__taxjar.rs"}, {"query": "Rust connector integration for tax calculation", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, CalculateTax, Capture, PSync, PaymentMethodToken, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsTaxCalculationData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n        TaxCalculationResponseData,\n    },\n    types::PaymentsTaxCalculationRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as taxjar;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Taxjar {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Taxjar {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Taxjar {}\nimpl api::PaymentSession for Taxjar {}\nimpl api::ConnectorAccessToken for Taxjar {}\nimpl api::MandateSetup for Taxjar {}\nim\n\n... [truncated 8266 chars] ...\n\nngWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic TAXJAR_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Taxjar\",\n    description: \"TaxJar is a cloud-based platform that automates sales tax calculations, reporting, and filing for businesses across multiple channels\",\n    connector_type: common_enums::HyperswitchConnectorCategory::TaxCalculationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Taxjar {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TAXJAR_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__taxjar.rs", "file": "crates__hyperswitch_connectors__src__connectors__taxjar.rs"}, {"query": "how to integrate Loonio payment gateway", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto::Encryptable,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoFulfill, PoSync},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutFulfillType, PayoutSyncType};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts as api_consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask, Secret};\nuse transformers as loonio;\n\nuse crate::\n\n... [truncated 27293 chars] ...\n\nsing platform that provides APIs for deposits and payouts via methods like Interac, PIX, EFT, and credit cards, with webhook support and transaction sync for real-time and manual status tracking.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n    static ref LOONIO_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = vec![\n        enums::EventClass::Payments,\n        #[cfg(feature = \"payouts\")]\n        enums::EventClass::Payouts,\n    ];\n}\n\nimpl ConnectorSpecifications for Loonio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*LOONIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*LOONIO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*LOONIO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__loonio.rs", "file": "crates__hyperswitch_connectors__src__connectors__loonio.rs"}, {"query": "Loonio connector implementation Rust", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto::Encryptable,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoFulfill, PoSync},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutFulfillType, PayoutSyncType};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts as api_consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask, Secret};\nuse transformers as loonio;\n\nuse crate::\n\n... [truncated 27293 chars] ...\n\nsing platform that provides APIs for deposits and payouts via methods like Interac, PIX, EFT, and credit cards, with webhook support and transaction sync for real-time and manual status tracking.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n    static ref LOONIO_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = vec![\n        enums::EventClass::Payments,\n        #[cfg(feature = \"payouts\")]\n        enums::EventClass::Payouts,\n    ];\n}\n\nimpl ConnectorSpecifications for Loonio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*LOONIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*LOONIO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*LOONIO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__loonio.rs", "file": "crates__hyperswitch_connectors__src__connectors__loonio.rs"}, {"query": "Hyperswitch payment gateway integration", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto::Encryptable,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoFulfill, PoSync},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutFulfillType, PayoutSyncType};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts as api_consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask, Secret};\nuse transformers as loonio;\n\nuse crate::\n\n... [truncated 27293 chars] ...\n\nsing platform that provides APIs for deposits and payouts via methods like Interac, PIX, EFT, and credit cards, with webhook support and transaction sync for real-time and manual status tracking.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n    static ref LOONIO_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = vec![\n        enums::EventClass::Payments,\n        #[cfg(feature = \"payouts\")]\n        enums::EventClass::Payouts,\n    ];\n}\n\nimpl ConnectorSpecifications for Loonio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*LOONIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*LOONIO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*LOONIO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__loonio.rs", "file": "crates__hyperswitch_connectors__src__connectors__loonio.rs"}, {"query": "Loonio API authentication and configuration", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto::Encryptable,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoFulfill, PoSync},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutFulfillType, PayoutSyncType};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts as api_consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask, Secret};\nuse transformers as loonio;\n\nuse crate::\n\n... [truncated 27293 chars] ...\n\nsing platform that provides APIs for deposits and payouts via methods like Interac, PIX, EFT, and credit cards, with webhook support and transaction sync for real-time and manual status tracking.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n    static ref LOONIO_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = vec![\n        enums::EventClass::Payments,\n        #[cfg(feature = \"payouts\")]\n        enums::EventClass::Payouts,\n    ];\n}\n\nimpl ConnectorSpecifications for Loonio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*LOONIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*LOONIO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*LOONIO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__loonio.rs", "file": "crates__hyperswitch_connectors__src__connectors__loonio.rs"}, {"query": "how payment response processing works", "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_\n\n... [truncated 159008 chars] ...\n\nr.get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n            .attach_printable(\"Error while updating the payment_intent\")?;\n\n        let payment_attempt_update = router_data\n            .get_payment_attempt_update(&payment_data, processor.get_account().storage_scheme);\n\n        let updated_payment_attempt = db\n            .update_payment_attempt(\n                processor.get_key_store(),\n                payment_data.payment_attempt.clone(),\n                payment_attempt_update,\n                processor.get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n            .attach_printable(\"Error while updating the payment_attempt\")?;\n\n        payment_data.set_payment_intent(updated_payment_intent);\n        payment_data.set_payment_attempt(updated_payment_attempt);\n\n        Ok(payment_data)\n    }\n}\n", "function_name": "crates__router__src__core__payments__operations__payment_response.rs", "file": "crates__router__src__core__payments__operations__payment_response.rs"}, {"query": "PaymentResponseOperation trait implementation", "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_\n\n... [truncated 159008 chars] ...\n\nr.get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n            .attach_printable(\"Error while updating the payment_intent\")?;\n\n        let payment_attempt_update = router_data\n            .get_payment_attempt_update(&payment_data, processor.get_account().storage_scheme);\n\n        let updated_payment_attempt = db\n            .update_payment_attempt(\n                processor.get_key_store(),\n                payment_data.payment_attempt.clone(),\n                payment_attempt_update,\n                processor.get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n            .attach_printable(\"Error while updating the payment_attempt\")?;\n\n        payment_data.set_payment_intent(updated_payment_intent);\n        payment_data.set_payment_attempt(updated_payment_attempt);\n\n        Ok(payment_data)\n    }\n}\n", "function_name": "crates__router__src__core__payments__operations__payment_response.rs", "file": "crates__router__src__core__payments__operations__payment_response.rs"}, {"query": "how to handle payment capture flow", "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_\n\n... [truncated 159008 chars] ...\n\nr.get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n            .attach_printable(\"Error while updating the payment_intent\")?;\n\n        let payment_attempt_update = router_data\n            .get_payment_attempt_update(&payment_data, processor.get_account().storage_scheme);\n\n        let updated_payment_attempt = db\n            .update_payment_attempt(\n                processor.get_key_store(),\n                payment_data.payment_attempt.clone(),\n                payment_attempt_update,\n                processor.get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n            .attach_printable(\"Error while updating the payment_attempt\")?;\n\n        payment_data.set_payment_intent(updated_payment_intent);\n        payment_data.set_payment_attempt(updated_payment_attempt);\n\n        Ok(payment_data)\n    }\n}\n", "function_name": "crates__router__src__core__payments__operations__payment_response.rs", "file": "crates__router__src__core__payments__operations__payment_response.rs"}, {"query": "update payment intent and attempt logic", "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_\n\n... [truncated 159008 chars] ...\n\nr.get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n            .attach_printable(\"Error while updating the payment_intent\")?;\n\n        let payment_attempt_update = router_data\n            .get_payment_attempt_update(&payment_data, processor.get_account().storage_scheme);\n\n        let updated_payment_attempt = db\n            .update_payment_attempt(\n                processor.get_key_store(),\n                payment_data.payment_attempt.clone(),\n                payment_attempt_update,\n                processor.get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n            .attach_printable(\"Error while updating the payment_attempt\")?;\n\n        payment_data.set_payment_intent(updated_payment_intent);\n        payment_data.set_payment_attempt(updated_payment_attempt);\n\n        Ok(payment_data)\n    }\n}\n", "function_name": "crates__router__src__core__payments__operations__payment_response.rs", "file": "crates__router__src__core__payments__operations__payment_response.rs"}, {"query": "how does actix web route mapping work", "code": "use std::{collections::HashMap, sync::Arc};\n\nuse actix_web::{web, Scope};\n#[cfg(all(feature = \"olap\", feature = \"v1\"))]\nuse api_models::routing::RoutingRetrieveQuery;\nuse api_models::routing::RuleMigrationQuery;\n#[cfg(feature = \"olap\")]\nuse common_enums::{ExecutionMode, TransactionType};\n#[cfg(feature = \"partial-auth\")]\nuse common_utils::crypto::Blake3;\nuse common_utils::{\n    id_type,\n    types::{keymanager::KeyManagerState, TenantConfig},\n};\n#[cfg(feature = \"email\")]\nuse external_services::email::{\n    no_email::NoEmailClient, ses::AwsSes, smtp::SmtpServer, EmailClientConfigs, EmailService,\n};\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse external_services::grpc_client::revenue_recovery::GrpcRecoveryHeaders;\nuse external_services::{\n    file_storage::FileStorageInterface,\n    grpc_client::{GrpcClients, GrpcHeaders, GrpcHeadersUcs, GrpcHeadersUcsBuilderInitial},\n    superposition::SuperpositionClient,\n};\nuse hyperswitch_interfaces::{\n    crm::CrmInterface,\n    encryption_interface::EncryptionManagementInterface,\n    helpers as interfaces_helpers,\n    secrets_interface::secret_state::{RawSecret, SecuredSecret},\n    types as interfaces_types,\n};\nuse router_env::RequestId;\nuse scheduler::SchedulerInterface;\nuse storage_impl::{redis::RedisStore, MockDb};\nuse tokio::sync::oneshot;\n\nuse self::settings::Tenant;\n#[cfg(any(feature = \"olap\", feature = \"oltp\"))]\nuse super::currency;\n#[cfg(feature = \"dummy_connector\")]\nuse super::dummy_connector::*;\n#[cfg(all(any(feature = \"v1\", feature = \"v2\"), feature = \"oltp\"))]\nuse super::ephemeral_key::*;\n#[cfg(any(feature = \"olap\", feature = \"oltp\"))]\nuse super::payment_methods;\n#[cfg(feature = \"payouts\")]\nuse super::payout_link::*;\n#[cfg(feature = \"payouts\")]\nuse super::payouts::*;\n#[cfg(all(feature = \"oltp\", feature = \"v1\"))]\nuse super::pm_auth;\n#[cfg(feature = \"oltp\")]\nuse super::poll;\n#[cfg(feature = \"v2\")]\nuse super::proxy;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\", feature = \"oltp\"))]\nuse super::recovery_webhooks\n\n... [truncated 128988 chars] ...\n\n  .app_data(web::Data::new(state))\n            .service(\n                web::resource(\"\").route(\n                    web::post()\n                        .to(super::revenue_recovery_data_backfill::revenue_recovery_data_backfill),\n                ),\n            )\n            .service(web::resource(\"/status/{connector_cutomer_id}/{payment_intent_id}\").route(\n                web::post().to(\n                    super::revenue_recovery_data_backfill::revenue_recovery_data_backfill_status,\n                ),\n            ))\n            .service(web::resource(\"/redis-data/{connector_cutomer_id}\").route(\n                web::get().to(\n                    super::revenue_recovery_redis::get_revenue_recovery_redis_data,\n                ),\n            ))\n            .service(web::resource(\"/update-token\").route(\n                web::put().to(\n                    super::revenue_recovery_data_backfill::update_revenue_recovery_additional_redis_data,\n                ),\n            ))\n    }\n}\n", "function_name": "crates__router__src__routes__app.rs", "file": "crates__router__src__routes__app.rs"}, {"query": "Hyperswitch payment orchestration router implementation", "code": "use std::{collections::HashMap, sync::Arc};\n\nuse actix_web::{web, Scope};\n#[cfg(all(feature = \"olap\", feature = \"v1\"))]\nuse api_models::routing::RoutingRetrieveQuery;\nuse api_models::routing::RuleMigrationQuery;\n#[cfg(feature = \"olap\")]\nuse common_enums::{ExecutionMode, TransactionType};\n#[cfg(feature = \"partial-auth\")]\nuse common_utils::crypto::Blake3;\nuse common_utils::{\n    id_type,\n    types::{keymanager::KeyManagerState, TenantConfig},\n};\n#[cfg(feature = \"email\")]\nuse external_services::email::{\n    no_email::NoEmailClient, ses::AwsSes, smtp::SmtpServer, EmailClientConfigs, EmailService,\n};\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse external_services::grpc_client::revenue_recovery::GrpcRecoveryHeaders;\nuse external_services::{\n    file_storage::FileStorageInterface,\n    grpc_client::{GrpcClients, GrpcHeaders, GrpcHeadersUcs, GrpcHeadersUcsBuilderInitial},\n    superposition::SuperpositionClient,\n};\nuse hyperswitch_interfaces::{\n    crm::CrmInterface,\n    encryption_interface::EncryptionManagementInterface,\n    helpers as interfaces_helpers,\n    secrets_interface::secret_state::{RawSecret, SecuredSecret},\n    types as interfaces_types,\n};\nuse router_env::RequestId;\nuse scheduler::SchedulerInterface;\nuse storage_impl::{redis::RedisStore, MockDb};\nuse tokio::sync::oneshot;\n\nuse self::settings::Tenant;\n#[cfg(any(feature = \"olap\", feature = \"oltp\"))]\nuse super::currency;\n#[cfg(feature = \"dummy_connector\")]\nuse super::dummy_connector::*;\n#[cfg(all(any(feature = \"v1\", feature = \"v2\"), feature = \"oltp\"))]\nuse super::ephemeral_key::*;\n#[cfg(any(feature = \"olap\", feature = \"oltp\"))]\nuse super::payment_methods;\n#[cfg(feature = \"payouts\")]\nuse super::payout_link::*;\n#[cfg(feature = \"payouts\")]\nuse super::payouts::*;\n#[cfg(all(feature = \"oltp\", feature = \"v1\"))]\nuse super::pm_auth;\n#[cfg(feature = \"oltp\")]\nuse super::poll;\n#[cfg(feature = \"v2\")]\nuse super::proxy;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\", feature = \"oltp\"))]\nuse super::recovery_webhooks\n\n... [truncated 128988 chars] ...\n\n  .app_data(web::Data::new(state))\n            .service(\n                web::resource(\"\").route(\n                    web::post()\n                        .to(super::revenue_recovery_data_backfill::revenue_recovery_data_backfill),\n                ),\n            )\n            .service(web::resource(\"/status/{connector_cutomer_id}/{payment_intent_id}\").route(\n                web::post().to(\n                    super::revenue_recovery_data_backfill::revenue_recovery_data_backfill_status,\n                ),\n            ))\n            .service(web::resource(\"/redis-data/{connector_cutomer_id}\").route(\n                web::get().to(\n                    super::revenue_recovery_redis::get_revenue_recovery_redis_data,\n                ),\n            ))\n            .service(web::resource(\"/update-token\").route(\n                web::put().to(\n                    super::revenue_recovery_data_backfill::update_revenue_recovery_additional_redis_data,\n                ),\n            ))\n    }\n}\n", "function_name": "crates__router__src__routes__app.rs", "file": "crates__router__src__routes__app.rs"}, {"query": "how to add new API routes to Hyperswitch", "code": "use std::{collections::HashMap, sync::Arc};\n\nuse actix_web::{web, Scope};\n#[cfg(all(feature = \"olap\", feature = \"v1\"))]\nuse api_models::routing::RoutingRetrieveQuery;\nuse api_models::routing::RuleMigrationQuery;\n#[cfg(feature = \"olap\")]\nuse common_enums::{ExecutionMode, TransactionType};\n#[cfg(feature = \"partial-auth\")]\nuse common_utils::crypto::Blake3;\nuse common_utils::{\n    id_type,\n    types::{keymanager::KeyManagerState, TenantConfig},\n};\n#[cfg(feature = \"email\")]\nuse external_services::email::{\n    no_email::NoEmailClient, ses::AwsSes, smtp::SmtpServer, EmailClientConfigs, EmailService,\n};\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse external_services::grpc_client::revenue_recovery::GrpcRecoveryHeaders;\nuse external_services::{\n    file_storage::FileStorageInterface,\n    grpc_client::{GrpcClients, GrpcHeaders, GrpcHeadersUcs, GrpcHeadersUcsBuilderInitial},\n    superposition::SuperpositionClient,\n};\nuse hyperswitch_interfaces::{\n    crm::CrmInterface,\n    encryption_interface::EncryptionManagementInterface,\n    helpers as interfaces_helpers,\n    secrets_interface::secret_state::{RawSecret, SecuredSecret},\n    types as interfaces_types,\n};\nuse router_env::RequestId;\nuse scheduler::SchedulerInterface;\nuse storage_impl::{redis::RedisStore, MockDb};\nuse tokio::sync::oneshot;\n\nuse self::settings::Tenant;\n#[cfg(any(feature = \"olap\", feature = \"oltp\"))]\nuse super::currency;\n#[cfg(feature = \"dummy_connector\")]\nuse super::dummy_connector::*;\n#[cfg(all(any(feature = \"v1\", feature = \"v2\"), feature = \"oltp\"))]\nuse super::ephemeral_key::*;\n#[cfg(any(feature = \"olap\", feature = \"oltp\"))]\nuse super::payment_methods;\n#[cfg(feature = \"payouts\")]\nuse super::payout_link::*;\n#[cfg(feature = \"payouts\")]\nuse super::payouts::*;\n#[cfg(all(feature = \"oltp\", feature = \"v1\"))]\nuse super::pm_auth;\n#[cfg(feature = \"oltp\")]\nuse super::poll;\n#[cfg(feature = \"v2\")]\nuse super::proxy;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\", feature = \"oltp\"))]\nuse super::recovery_webhooks\n\n... [truncated 128988 chars] ...\n\n  .app_data(web::Data::new(state))\n            .service(\n                web::resource(\"\").route(\n                    web::post()\n                        .to(super::revenue_recovery_data_backfill::revenue_recovery_data_backfill),\n                ),\n            )\n            .service(web::resource(\"/status/{connector_cutomer_id}/{payment_intent_id}\").route(\n                web::post().to(\n                    super::revenue_recovery_data_backfill::revenue_recovery_data_backfill_status,\n                ),\n            ))\n            .service(web::resource(\"/redis-data/{connector_cutomer_id}\").route(\n                web::get().to(\n                    super::revenue_recovery_redis::get_revenue_recovery_redis_data,\n                ),\n            ))\n            .service(web::resource(\"/update-token\").route(\n                web::put().to(\n                    super::revenue_recovery_data_backfill::update_revenue_recovery_additional_redis_data,\n                ),\n            ))\n    }\n}\n", "function_name": "crates__router__src__routes__app.rs", "file": "crates__router__src__routes__app.rs"}, {"query": "actix web scope configuration and service registration", "code": "use std::{collections::HashMap, sync::Arc};\n\nuse actix_web::{web, Scope};\n#[cfg(all(feature = \"olap\", feature = \"v1\"))]\nuse api_models::routing::RoutingRetrieveQuery;\nuse api_models::routing::RuleMigrationQuery;\n#[cfg(feature = \"olap\")]\nuse common_enums::{ExecutionMode, TransactionType};\n#[cfg(feature = \"partial-auth\")]\nuse common_utils::crypto::Blake3;\nuse common_utils::{\n    id_type,\n    types::{keymanager::KeyManagerState, TenantConfig},\n};\n#[cfg(feature = \"email\")]\nuse external_services::email::{\n    no_email::NoEmailClient, ses::AwsSes, smtp::SmtpServer, EmailClientConfigs, EmailService,\n};\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse external_services::grpc_client::revenue_recovery::GrpcRecoveryHeaders;\nuse external_services::{\n    file_storage::FileStorageInterface,\n    grpc_client::{GrpcClients, GrpcHeaders, GrpcHeadersUcs, GrpcHeadersUcsBuilderInitial},\n    superposition::SuperpositionClient,\n};\nuse hyperswitch_interfaces::{\n    crm::CrmInterface,\n    encryption_interface::EncryptionManagementInterface,\n    helpers as interfaces_helpers,\n    secrets_interface::secret_state::{RawSecret, SecuredSecret},\n    types as interfaces_types,\n};\nuse router_env::RequestId;\nuse scheduler::SchedulerInterface;\nuse storage_impl::{redis::RedisStore, MockDb};\nuse tokio::sync::oneshot;\n\nuse self::settings::Tenant;\n#[cfg(any(feature = \"olap\", feature = \"oltp\"))]\nuse super::currency;\n#[cfg(feature = \"dummy_connector\")]\nuse super::dummy_connector::*;\n#[cfg(all(any(feature = \"v1\", feature = \"v2\"), feature = \"oltp\"))]\nuse super::ephemeral_key::*;\n#[cfg(any(feature = \"olap\", feature = \"oltp\"))]\nuse super::payment_methods;\n#[cfg(feature = \"payouts\")]\nuse super::payout_link::*;\n#[cfg(feature = \"payouts\")]\nuse super::payouts::*;\n#[cfg(all(feature = \"oltp\", feature = \"v1\"))]\nuse super::pm_auth;\n#[cfg(feature = \"oltp\")]\nuse super::poll;\n#[cfg(feature = \"v2\")]\nuse super::proxy;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\", feature = \"oltp\"))]\nuse super::recovery_webhooks\n\n... [truncated 128988 chars] ...\n\n  .app_data(web::Data::new(state))\n            .service(\n                web::resource(\"\").route(\n                    web::post()\n                        .to(super::revenue_recovery_data_backfill::revenue_recovery_data_backfill),\n                ),\n            )\n            .service(web::resource(\"/status/{connector_cutomer_id}/{payment_intent_id}\").route(\n                web::post().to(\n                    super::revenue_recovery_data_backfill::revenue_recovery_data_backfill_status,\n                ),\n            ))\n            .service(web::resource(\"/redis-data/{connector_cutomer_id}\").route(\n                web::get().to(\n                    super::revenue_recovery_redis::get_revenue_recovery_redis_data,\n                ),\n            ))\n            .service(web::resource(\"/update-token\").route(\n                web::put().to(\n                    super::revenue_recovery_data_backfill::update_revenue_recovery_additional_redis_data,\n                ),\n            ))\n    }\n}\n", "function_name": "crates__router__src__routes__app.rs", "file": "crates__router__src__routes__app.rs"}, {"query": "how to implement PhonePe payment gateway", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as phonepe;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Phonepe {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Phonepe {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Phonepe {}\nimpl a\n\n... [truncated 19569 chars] ...\n\nctorInfo {\n        display_name: \"PHONEPE\",\n        description:\n            \"PhonePe is a digital payments and financial services platform built on the UPI system. It allows users to make instant payments, recharge mobiles, pay bills, and access financial services like investments and insurance.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\n    static ref PHONEPE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Phonepe {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*PHONEPE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PHONEPE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*PHONEPE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__phonepe.rs", "file": "crates__hyperswitch_connectors__src__connectors__phonepe.rs"}, {"query": "PhonePe connector integration Rust", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as phonepe;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Phonepe {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Phonepe {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Phonepe {}\nimpl a\n\n... [truncated 19569 chars] ...\n\nctorInfo {\n        display_name: \"PHONEPE\",\n        description:\n            \"PhonePe is a digital payments and financial services platform built on the UPI system. It allows users to make instant payments, recharge mobiles, pay bills, and access financial services like investments and insurance.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\n    static ref PHONEPE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Phonepe {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*PHONEPE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PHONEPE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*PHONEPE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__phonepe.rs", "file": "crates__hyperswitch_connectors__src__connectors__phonepe.rs"}, {"query": "hyperswitch PhonePe payment method configuration", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as phonepe;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Phonepe {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Phonepe {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Phonepe {}\nimpl a\n\n... [truncated 19569 chars] ...\n\nctorInfo {\n        display_name: \"PHONEPE\",\n        description:\n            \"PhonePe is a digital payments and financial services platform built on the UPI system. It allows users to make instant payments, recharge mobiles, pay bills, and access financial services like investments and insurance.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\n    static ref PHONEPE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Phonepe {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*PHONEPE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PHONEPE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*PHONEPE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__phonepe.rs", "file": "crates__hyperswitch_connectors__src__connectors__phonepe.rs"}, {"query": "PhonePe API authorization flow", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as phonepe;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Phonepe {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Phonepe {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Phonepe {}\nimpl a\n\n... [truncated 19569 chars] ...\n\nctorInfo {\n        display_name: \"PHONEPE\",\n        description:\n            \"PhonePe is a digital payments and financial services platform built on the UPI system. It allows users to make instant payments, recharge mobiles, pay bills, and access financial services like investments and insurance.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\n    static ref PHONEPE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Phonepe {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*PHONEPE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PHONEPE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*PHONEPE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__phonepe.rs", "file": "crates__hyperswitch_connectors__src__connectors__phonepe.rs"}, {"query": "PayU payment gateway integration hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefreshTokenType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as payu;\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[deri\n\n... [truncated 27942 chars] ...\n\n    },\n    );\n\n    payu_supported_payment_methods\n});\n\nstatic PAYU_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Payu\",\n        description:\n            \"PayU is a global fintech company providing online payment solutions, including card processing, UPI, wallets, and BNPL services across multiple markets \",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic PAYU_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Payu {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payu.rs", "file": "crates__hyperswitch_connectors__src__connectors__payu.rs"}, {"query": "Payu struct implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefreshTokenType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as payu;\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[deri\n\n... [truncated 27942 chars] ...\n\n    },\n    );\n\n    payu_supported_payment_methods\n});\n\nstatic PAYU_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Payu\",\n        description:\n            \"PayU is a global fintech company providing online payment solutions, including card processing, UPI, wallets, and BNPL services across multiple markets \",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic PAYU_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Payu {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payu.rs", "file": "crates__hyperswitch_connectors__src__connectors__payu.rs"}, {"query": "how to add new payment gateway connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefreshTokenType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as payu;\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[deri\n\n... [truncated 27942 chars] ...\n\n    },\n    );\n\n    payu_supported_payment_methods\n});\n\nstatic PAYU_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Payu\",\n        description:\n            \"PayU is a global fintech company providing online payment solutions, including card processing, UPI, wallets, and BNPL services across multiple markets \",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic PAYU_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Payu {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payu.rs", "file": "crates__hyperswitch_connectors__src__connectors__payu.rs"}, {"query": "PayU supported payment methods hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefreshTokenType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as payu;\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[deri\n\n... [truncated 27942 chars] ...\n\n    },\n    );\n\n    payu_supported_payment_methods\n});\n\nstatic PAYU_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Payu\",\n        description:\n            \"PayU is a global fintech company providing online payment solutions, including card processing, UPI, wallets, and BNPL services across multiple markets \",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic PAYU_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Payu {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYU_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYU_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYU_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payu.rs", "file": "crates__hyperswitch_connectors__src__connectors__payu.rs"}, {"query": "how to create a customer in hyperswitch", "code": "use api_models::customers::CustomerDocumentDetails;\n#[cfg(feature = \"v2\")]\nuse api_models::payment_methods::PaymentMethodId;\nuse common_types::primitive_wrappers::CustomerListLimit;\nuse common_utils::{\n    crypto::Encryptable,\n    errors::ReportSwitchExt,\n    ext_traits::AsyncExt,\n    id_type, pii, type_name,\n    types::{\n        keymanager::{Identifier, KeyManagerState, ToEncryptable},\n        Description,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_methods as payment_methods_domain, type_encryption::AsyncLift,\n};\nuse masking::{ExposeInterface, Secret, SwitchStrategy};\nuse payment_methods::controller::PaymentMethodsController;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_methods::cards::create_encrypted_data;\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_methods::delete_payment_method_by_record;\n#[cfg(feature = \"v1\")]\nuse crate::utils::CustomerAddress;\nuse crate::{\n    core::{\n        errors::{self, StorageErrorExt},\n        payment_methods::{cards, network_tokenization},\n    },\n    db::StorageInterface,\n    pii::PeekInterface,\n    routes::{metrics, SessionState},\n    services,\n    types::{\n        api::customers,\n        domain::{\n            self,\n            types::{self, CryptoOperation},\n        },\n        storage::{self, enums},\n    },\n};\n\npub const REDACTED: &str = \"Redacted\";\n\n#[instrument(skip(state))]\npub async fn create_customer(\n    state: SessionState,\n    provider: domain::Provider,\n    customer_data: customers::CustomerRequest,\n    connector_customer_details: Option<Vec<payment_methods_domain::ConnectorCustomerDetails>>,\n) -> errors::CustomerResponse<customers::CustomerResponse> {\n    customer_data\n        .document_details\n        .as_ref()\n        .map(|doc_details| doc_details.validate())\n        .transpose()\n        .map_err(|err| errors::CustomersErrorResponse::InvalidRequestData {\n            message: err.to_string(),\n        })?;\n\n    let db: &dyn StorageInterf\n\n... [truncated 56481 chars] ...\n\n_from(customer.clone())\n                .change_context(errors::CustomersErrorResponse::InternalServerError)\n                .attach_printable(\"Failed to convert domain customer to CustomerResponse\")?,\n        ))\n    }\n}\n\npub async fn migrate_customers(\n    state: SessionState,\n    customers_migration: Vec<payment_methods_domain::PaymentMethodCustomerMigrate>,\n    platform: domain::Platform,\n) -> errors::CustomerResponse<()> {\n    for customer_migration in customers_migration {\n        match create_customer(\n            state.clone(),\n            platform.get_provider().clone(),\n            customer_migration.customer,\n            customer_migration.connector_customer_details,\n        )\n        .await\n        {\n            Ok(_) => (),\n            Err(e) => match e.current_context() {\n                errors::CustomersErrorResponse::CustomerAlreadyExists => (),\n                _ => return Err(e),\n            },\n        }\n    }\n    Ok(services::ApplicationResponse::Json(()))\n}\n", "function_name": "crates__router__src__core__customers.rs", "file": "crates__router__src__core__customers.rs"}, {"query": "CustomerResponse struct definition", "code": "use api_models::customers::CustomerDocumentDetails;\n#[cfg(feature = \"v2\")]\nuse api_models::payment_methods::PaymentMethodId;\nuse common_types::primitive_wrappers::CustomerListLimit;\nuse common_utils::{\n    crypto::Encryptable,\n    errors::ReportSwitchExt,\n    ext_traits::AsyncExt,\n    id_type, pii, type_name,\n    types::{\n        keymanager::{Identifier, KeyManagerState, ToEncryptable},\n        Description,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_methods as payment_methods_domain, type_encryption::AsyncLift,\n};\nuse masking::{ExposeInterface, Secret, SwitchStrategy};\nuse payment_methods::controller::PaymentMethodsController;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_methods::cards::create_encrypted_data;\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_methods::delete_payment_method_by_record;\n#[cfg(feature = \"v1\")]\nuse crate::utils::CustomerAddress;\nuse crate::{\n    core::{\n        errors::{self, StorageErrorExt},\n        payment_methods::{cards, network_tokenization},\n    },\n    db::StorageInterface,\n    pii::PeekInterface,\n    routes::{metrics, SessionState},\n    services,\n    types::{\n        api::customers,\n        domain::{\n            self,\n            types::{self, CryptoOperation},\n        },\n        storage::{self, enums},\n    },\n};\n\npub const REDACTED: &str = \"Redacted\";\n\n#[instrument(skip(state))]\npub async fn create_customer(\n    state: SessionState,\n    provider: domain::Provider,\n    customer_data: customers::CustomerRequest,\n    connector_customer_details: Option<Vec<payment_methods_domain::ConnectorCustomerDetails>>,\n) -> errors::CustomerResponse<customers::CustomerResponse> {\n    customer_data\n        .document_details\n        .as_ref()\n        .map(|doc_details| doc_details.validate())\n        .transpose()\n        .map_err(|err| errors::CustomersErrorResponse::InvalidRequestData {\n            message: err.to_string(),\n        })?;\n\n    let db: &dyn StorageInterf\n\n... [truncated 56481 chars] ...\n\n_from(customer.clone())\n                .change_context(errors::CustomersErrorResponse::InternalServerError)\n                .attach_printable(\"Failed to convert domain customer to CustomerResponse\")?,\n        ))\n    }\n}\n\npub async fn migrate_customers(\n    state: SessionState,\n    customers_migration: Vec<payment_methods_domain::PaymentMethodCustomerMigrate>,\n    platform: domain::Platform,\n) -> errors::CustomerResponse<()> {\n    for customer_migration in customers_migration {\n        match create_customer(\n            state.clone(),\n            platform.get_provider().clone(),\n            customer_migration.customer,\n            customer_migration.connector_customer_details,\n        )\n        .await\n        {\n            Ok(_) => (),\n            Err(e) => match e.current_context() {\n                errors::CustomersErrorResponse::CustomerAlreadyExists => (),\n                _ => return Err(e),\n            },\n        }\n    }\n    Ok(services::ApplicationResponse::Json(()))\n}\n", "function_name": "crates__router__src__core__customers.rs", "file": "crates__router__src__core__customers.rs"}, {"query": "implement customer update logic", "code": "use api_models::customers::CustomerDocumentDetails;\n#[cfg(feature = \"v2\")]\nuse api_models::payment_methods::PaymentMethodId;\nuse common_types::primitive_wrappers::CustomerListLimit;\nuse common_utils::{\n    crypto::Encryptable,\n    errors::ReportSwitchExt,\n    ext_traits::AsyncExt,\n    id_type, pii, type_name,\n    types::{\n        keymanager::{Identifier, KeyManagerState, ToEncryptable},\n        Description,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_methods as payment_methods_domain, type_encryption::AsyncLift,\n};\nuse masking::{ExposeInterface, Secret, SwitchStrategy};\nuse payment_methods::controller::PaymentMethodsController;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_methods::cards::create_encrypted_data;\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_methods::delete_payment_method_by_record;\n#[cfg(feature = \"v1\")]\nuse crate::utils::CustomerAddress;\nuse crate::{\n    core::{\n        errors::{self, StorageErrorExt},\n        payment_methods::{cards, network_tokenization},\n    },\n    db::StorageInterface,\n    pii::PeekInterface,\n    routes::{metrics, SessionState},\n    services,\n    types::{\n        api::customers,\n        domain::{\n            self,\n            types::{self, CryptoOperation},\n        },\n        storage::{self, enums},\n    },\n};\n\npub const REDACTED: &str = \"Redacted\";\n\n#[instrument(skip(state))]\npub async fn create_customer(\n    state: SessionState,\n    provider: domain::Provider,\n    customer_data: customers::CustomerRequest,\n    connector_customer_details: Option<Vec<payment_methods_domain::ConnectorCustomerDetails>>,\n) -> errors::CustomerResponse<customers::CustomerResponse> {\n    customer_data\n        .document_details\n        .as_ref()\n        .map(|doc_details| doc_details.validate())\n        .transpose()\n        .map_err(|err| errors::CustomersErrorResponse::InvalidRequestData {\n            message: err.to_string(),\n        })?;\n\n    let db: &dyn StorageInterf\n\n... [truncated 56481 chars] ...\n\n_from(customer.clone())\n                .change_context(errors::CustomersErrorResponse::InternalServerError)\n                .attach_printable(\"Failed to convert domain customer to CustomerResponse\")?,\n        ))\n    }\n}\n\npub async fn migrate_customers(\n    state: SessionState,\n    customers_migration: Vec<payment_methods_domain::PaymentMethodCustomerMigrate>,\n    platform: domain::Platform,\n) -> errors::CustomerResponse<()> {\n    for customer_migration in customers_migration {\n        match create_customer(\n            state.clone(),\n            platform.get_provider().clone(),\n            customer_migration.customer,\n            customer_migration.connector_customer_details,\n        )\n        .await\n        {\n            Ok(_) => (),\n            Err(e) => match e.current_context() {\n                errors::CustomersErrorResponse::CustomerAlreadyExists => (),\n                _ => return Err(e),\n            },\n        }\n    }\n    Ok(services::ApplicationResponse::Json(()))\n}\n", "function_name": "crates__router__src__core__customers.rs", "file": "crates__router__src__core__customers.rs"}, {"query": "customer payment method migration", "code": "use api_models::customers::CustomerDocumentDetails;\n#[cfg(feature = \"v2\")]\nuse api_models::payment_methods::PaymentMethodId;\nuse common_types::primitive_wrappers::CustomerListLimit;\nuse common_utils::{\n    crypto::Encryptable,\n    errors::ReportSwitchExt,\n    ext_traits::AsyncExt,\n    id_type, pii, type_name,\n    types::{\n        keymanager::{Identifier, KeyManagerState, ToEncryptable},\n        Description,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_methods as payment_methods_domain, type_encryption::AsyncLift,\n};\nuse masking::{ExposeInterface, Secret, SwitchStrategy};\nuse payment_methods::controller::PaymentMethodsController;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_methods::cards::create_encrypted_data;\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_methods::delete_payment_method_by_record;\n#[cfg(feature = \"v1\")]\nuse crate::utils::CustomerAddress;\nuse crate::{\n    core::{\n        errors::{self, StorageErrorExt},\n        payment_methods::{cards, network_tokenization},\n    },\n    db::StorageInterface,\n    pii::PeekInterface,\n    routes::{metrics, SessionState},\n    services,\n    types::{\n        api::customers,\n        domain::{\n            self,\n            types::{self, CryptoOperation},\n        },\n        storage::{self, enums},\n    },\n};\n\npub const REDACTED: &str = \"Redacted\";\n\n#[instrument(skip(state))]\npub async fn create_customer(\n    state: SessionState,\n    provider: domain::Provider,\n    customer_data: customers::CustomerRequest,\n    connector_customer_details: Option<Vec<payment_methods_domain::ConnectorCustomerDetails>>,\n) -> errors::CustomerResponse<customers::CustomerResponse> {\n    customer_data\n        .document_details\n        .as_ref()\n        .map(|doc_details| doc_details.validate())\n        .transpose()\n        .map_err(|err| errors::CustomersErrorResponse::InvalidRequestData {\n            message: err.to_string(),\n        })?;\n\n    let db: &dyn StorageInterf\n\n... [truncated 56481 chars] ...\n\n_from(customer.clone())\n                .change_context(errors::CustomersErrorResponse::InternalServerError)\n                .attach_printable(\"Failed to convert domain customer to CustomerResponse\")?,\n        ))\n    }\n}\n\npub async fn migrate_customers(\n    state: SessionState,\n    customers_migration: Vec<payment_methods_domain::PaymentMethodCustomerMigrate>,\n    platform: domain::Platform,\n) -> errors::CustomerResponse<()> {\n    for customer_migration in customers_migration {\n        match create_customer(\n            state.clone(),\n            platform.get_provider().clone(),\n            customer_migration.customer,\n            customer_migration.connector_customer_details,\n        )\n        .await\n        {\n            Ok(_) => (),\n            Err(e) => match e.current_context() {\n                errors::CustomersErrorResponse::CustomerAlreadyExists => (),\n                _ => return Err(e),\n            },\n        }\n    }\n    Ok(services::ApplicationResponse::Json(()))\n}\n", "function_name": "crates__router__src__core__customers.rs", "file": "crates__router__src__core__customers.rs"}, {"query": "how to implement ApiEventMetric for routing types", "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\nuse crate::routing::{\n    ContractBasedRoutingPayloadWrapper, ContractBasedRoutingSetupPayloadWrapper,\n    CreateDynamicRoutingWrapper, DynamicRoutingUpdateConfigQuery, EliminationRoutingPayloadWrapper,\n    LinkedRoutingConfigRetrieveResponse, MerchantRoutingAlgorithm, ProfileDefaultRoutingConfig,\n    RoutingAlgorithmId, RoutingConfigRequest, RoutingDictionaryRecord, RoutingKind,\n    RoutingLinkWrapper, RoutingPayloadWrapper, RoutingRetrieveLinkQuery,\n    RoutingRetrieveLinkQueryWrapper, RoutingRetrieveQuery, RoutingVolumeSplit,\n    RoutingVolumeSplitResponse, RoutingVolumeSplitWrapper, RuleMigrationError, RuleMigrationQuery,\n    RuleMigrationResponse, RuleMigrationResult, SuccessBasedRoutingConfig,\n    SuccessBasedRoutingPayloadWrapper, ToggleDynamicRoutingPath, ToggleDynamicRoutingQuery,\n    ToggleDynamicRoutingWrapper,\n};\n\nimpl ApiEventMetric for RoutingKind {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for MerchantRoutingAlgorithm {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingAlgorithmId {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingDictionaryRecord {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for LinkedRoutingConfigRetrieveResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for ProfileDefaultRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for\n\n... [truncated 3166 chars] ...\n\ntMetric for RuleMigrationResult {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RuleMigrationError {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::DecideGatewayResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::OpenRouterDecideGatewayRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::UpdateScorePayload {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::UpdateScoreResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n", "function_name": "crates__api_models__src__events__routing.rs", "file": "crates__api_models__src__events__routing.rs"}, {"query": "RoutingKind event type implementation", "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\nuse crate::routing::{\n    ContractBasedRoutingPayloadWrapper, ContractBasedRoutingSetupPayloadWrapper,\n    CreateDynamicRoutingWrapper, DynamicRoutingUpdateConfigQuery, EliminationRoutingPayloadWrapper,\n    LinkedRoutingConfigRetrieveResponse, MerchantRoutingAlgorithm, ProfileDefaultRoutingConfig,\n    RoutingAlgorithmId, RoutingConfigRequest, RoutingDictionaryRecord, RoutingKind,\n    RoutingLinkWrapper, RoutingPayloadWrapper, RoutingRetrieveLinkQuery,\n    RoutingRetrieveLinkQueryWrapper, RoutingRetrieveQuery, RoutingVolumeSplit,\n    RoutingVolumeSplitResponse, RoutingVolumeSplitWrapper, RuleMigrationError, RuleMigrationQuery,\n    RuleMigrationResponse, RuleMigrationResult, SuccessBasedRoutingConfig,\n    SuccessBasedRoutingPayloadWrapper, ToggleDynamicRoutingPath, ToggleDynamicRoutingQuery,\n    ToggleDynamicRoutingWrapper,\n};\n\nimpl ApiEventMetric for RoutingKind {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for MerchantRoutingAlgorithm {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingAlgorithmId {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingDictionaryRecord {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for LinkedRoutingConfigRetrieveResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for ProfileDefaultRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for\n\n... [truncated 3166 chars] ...\n\ntMetric for RuleMigrationResult {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RuleMigrationError {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::DecideGatewayResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::OpenRouterDecideGatewayRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::UpdateScorePayload {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::UpdateScoreResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n", "function_name": "crates__api_models__src__events__routing.rs", "file": "crates__api_models__src__events__routing.rs"}, {"query": "how to categorize routing API events", "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\nuse crate::routing::{\n    ContractBasedRoutingPayloadWrapper, ContractBasedRoutingSetupPayloadWrapper,\n    CreateDynamicRoutingWrapper, DynamicRoutingUpdateConfigQuery, EliminationRoutingPayloadWrapper,\n    LinkedRoutingConfigRetrieveResponse, MerchantRoutingAlgorithm, ProfileDefaultRoutingConfig,\n    RoutingAlgorithmId, RoutingConfigRequest, RoutingDictionaryRecord, RoutingKind,\n    RoutingLinkWrapper, RoutingPayloadWrapper, RoutingRetrieveLinkQuery,\n    RoutingRetrieveLinkQueryWrapper, RoutingRetrieveQuery, RoutingVolumeSplit,\n    RoutingVolumeSplitResponse, RoutingVolumeSplitWrapper, RuleMigrationError, RuleMigrationQuery,\n    RuleMigrationResponse, RuleMigrationResult, SuccessBasedRoutingConfig,\n    SuccessBasedRoutingPayloadWrapper, ToggleDynamicRoutingPath, ToggleDynamicRoutingQuery,\n    ToggleDynamicRoutingWrapper,\n};\n\nimpl ApiEventMetric for RoutingKind {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for MerchantRoutingAlgorithm {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingAlgorithmId {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingDictionaryRecord {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for LinkedRoutingConfigRetrieveResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for ProfileDefaultRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for\n\n... [truncated 3166 chars] ...\n\ntMetric for RuleMigrationResult {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RuleMigrationError {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::DecideGatewayResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::OpenRouterDecideGatewayRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::UpdateScorePayload {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::UpdateScoreResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n", "function_name": "crates__api_models__src__events__routing.rs", "file": "crates__api_models__src__events__routing.rs"}, {"query": "routing metric event mapping", "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\nuse crate::routing::{\n    ContractBasedRoutingPayloadWrapper, ContractBasedRoutingSetupPayloadWrapper,\n    CreateDynamicRoutingWrapper, DynamicRoutingUpdateConfigQuery, EliminationRoutingPayloadWrapper,\n    LinkedRoutingConfigRetrieveResponse, MerchantRoutingAlgorithm, ProfileDefaultRoutingConfig,\n    RoutingAlgorithmId, RoutingConfigRequest, RoutingDictionaryRecord, RoutingKind,\n    RoutingLinkWrapper, RoutingPayloadWrapper, RoutingRetrieveLinkQuery,\n    RoutingRetrieveLinkQueryWrapper, RoutingRetrieveQuery, RoutingVolumeSplit,\n    RoutingVolumeSplitResponse, RoutingVolumeSplitWrapper, RuleMigrationError, RuleMigrationQuery,\n    RuleMigrationResponse, RuleMigrationResult, SuccessBasedRoutingConfig,\n    SuccessBasedRoutingPayloadWrapper, ToggleDynamicRoutingPath, ToggleDynamicRoutingQuery,\n    ToggleDynamicRoutingWrapper,\n};\n\nimpl ApiEventMetric for RoutingKind {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for MerchantRoutingAlgorithm {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingAlgorithmId {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingDictionaryRecord {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for LinkedRoutingConfigRetrieveResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for ProfileDefaultRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for\n\n... [truncated 3166 chars] ...\n\ntMetric for RuleMigrationResult {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RuleMigrationError {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::DecideGatewayResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::OpenRouterDecideGatewayRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::UpdateScorePayload {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for crate::open_router::UpdateScoreResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n", "function_name": "crates__api_models__src__events__routing.rs", "file": "crates__api_models__src__events__routing.rs"}, {"query": "Forte payment request transformation", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{PaymentsCaptureResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _PaymentsAuthorizeRequestData,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ForteRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for ForteRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FortePaymentsRequest {\n    action: ForteAction,\n    authorization_amount: FloatMajorUnit,\n    billing_address: BillingAddress,\n    card: Card,\n}\n#[derive(Debug, Serialize, Deserialize)]\npub struct BillingAddress {\n    first_name: Secret<String>,\n    last_name: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Card {\n    card_type: ForteCardType,\n    name_on_card: Secret<String>,\n    account_number: CardNumber,\n    expire_month: Secret<String>,\n    expire_year: Secret<String>,\n    card_verification_value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ForteCardType {\n    Visa,\n    MasterCard,\n    Amex,\n    Discover,\n    DinersClub,\n    Jcb,\n}\n\nimpl TryFrom<utils::CardIssuer> for ForteCardType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(issuer: utils::CardIssuer) -> Resul\n\n... [truncated 18806 chars] ...\n\nlize)]\npub struct RefundSyncResponse {\n    status: RefundStatus,\n    transaction_id: String,\n}\n\nimpl TryFrom<RefundsResponseRouterData<RSync, RefundSyncResponse>>\n    for types::RefundsRouterData<RSync>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundSyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.transaction_id,\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponseStatus {\n    pub environment: String,\n    pub response_type: Option<String>,\n    pub response_code: Option<String>,\n    pub response_desc: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ForteErrorResponse {\n    pub response: ErrorResponseStatus,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs"}, {"query": "ForteRouterData struct definition", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{PaymentsCaptureResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _PaymentsAuthorizeRequestData,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ForteRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for ForteRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FortePaymentsRequest {\n    action: ForteAction,\n    authorization_amount: FloatMajorUnit,\n    billing_address: BillingAddress,\n    card: Card,\n}\n#[derive(Debug, Serialize, Deserialize)]\npub struct BillingAddress {\n    first_name: Secret<String>,\n    last_name: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Card {\n    card_type: ForteCardType,\n    name_on_card: Secret<String>,\n    account_number: CardNumber,\n    expire_month: Secret<String>,\n    expire_year: Secret<String>,\n    card_verification_value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ForteCardType {\n    Visa,\n    MasterCard,\n    Amex,\n    Discover,\n    DinersClub,\n    Jcb,\n}\n\nimpl TryFrom<utils::CardIssuer> for ForteCardType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(issuer: utils::CardIssuer) -> Resul\n\n... [truncated 18806 chars] ...\n\nlize)]\npub struct RefundSyncResponse {\n    status: RefundStatus,\n    transaction_id: String,\n}\n\nimpl TryFrom<RefundsResponseRouterData<RSync, RefundSyncResponse>>\n    for types::RefundsRouterData<RSync>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundSyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.transaction_id,\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponseStatus {\n    pub environment: String,\n    pub response_type: Option<String>,\n    pub response_code: Option<String>,\n    pub response_desc: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ForteErrorResponse {\n    pub response: ErrorResponseStatus,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs"}, {"query": "how to implement Forte refunds", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{PaymentsCaptureResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _PaymentsAuthorizeRequestData,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ForteRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for ForteRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FortePaymentsRequest {\n    action: ForteAction,\n    authorization_amount: FloatMajorUnit,\n    billing_address: BillingAddress,\n    card: Card,\n}\n#[derive(Debug, Serialize, Deserialize)]\npub struct BillingAddress {\n    first_name: Secret<String>,\n    last_name: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Card {\n    card_type: ForteCardType,\n    name_on_card: Secret<String>,\n    account_number: CardNumber,\n    expire_month: Secret<String>,\n    expire_year: Secret<String>,\n    card_verification_value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ForteCardType {\n    Visa,\n    MasterCard,\n    Amex,\n    Discover,\n    DinersClub,\n    Jcb,\n}\n\nimpl TryFrom<utils::CardIssuer> for ForteCardType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(issuer: utils::CardIssuer) -> Resul\n\n... [truncated 18806 chars] ...\n\nlize)]\npub struct RefundSyncResponse {\n    status: RefundStatus,\n    transaction_id: String,\n}\n\nimpl TryFrom<RefundsResponseRouterData<RSync, RefundSyncResponse>>\n    for types::RefundsRouterData<RSync>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundSyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.transaction_id,\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponseStatus {\n    pub environment: String,\n    pub response_type: Option<String>,\n    pub response_code: Option<String>,\n    pub response_desc: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ForteErrorResponse {\n    pub response: ErrorResponseStatus,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs"}, {"query": "hyperswitch forte connector types", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{PaymentsCaptureResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _PaymentsAuthorizeRequestData,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ForteRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for ForteRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FortePaymentsRequest {\n    action: ForteAction,\n    authorization_amount: FloatMajorUnit,\n    billing_address: BillingAddress,\n    card: Card,\n}\n#[derive(Debug, Serialize, Deserialize)]\npub struct BillingAddress {\n    first_name: Secret<String>,\n    last_name: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Card {\n    card_type: ForteCardType,\n    name_on_card: Secret<String>,\n    account_number: CardNumber,\n    expire_month: Secret<String>,\n    expire_year: Secret<String>,\n    card_verification_value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ForteCardType {\n    Visa,\n    MasterCard,\n    Amex,\n    Discover,\n    DinersClub,\n    Jcb,\n}\n\nimpl TryFrom<utils::CardIssuer> for ForteCardType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(issuer: utils::CardIssuer) -> Resul\n\n... [truncated 18806 chars] ...\n\nlize)]\npub struct RefundSyncResponse {\n    status: RefundStatus,\n    transaction_id: String,\n}\n\nimpl TryFrom<RefundsResponseRouterData<RSync, RefundSyncResponse>>\n    for types::RefundsRouterData<RSync>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundSyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.transaction_id,\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponseStatus {\n    pub environment: String,\n    pub response_type: Option<String>,\n    pub response_code: Option<String>,\n    pub response_desc: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ForteErrorResponse {\n    pub response: ErrorResponseStatus,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs"}, {"query": "TrustPayments API response mapping", "code": "use common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData, RefundsRequestData, RouterData as RouterDataExt},\n};\n\nconst TRUSTPAYMENTS_API_VERSION: &str = \"1.00\";\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum TrustpaymentsSettleStatus {\n    #[serde(rename = \"0\")]\n    PendingSettlement,\n    #[serde(rename = \"1\")]\n    Settled,\n    #[serde(rename = \"2\")]\n    ManualCapture,\n    #[serde(rename = \"3\")]\n    Voided,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum TrustpaymentsCredentialsOnFile {\n    #[serde(rename = \"0\")]\n    NoStoredCredentials,\n    #[serde(rename = \"1\")]\n    CardholderInitiatedTransaction,\n    #[serde(rename = \"2\")]\n    MerchantInitiatedTransaction,\n}\n\nimpl TrustpaymentsCredentialsOnFile {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            Self::NoStoredCredentials => \"0\",\n            Self::CardholderInitiatedTransaction => \"1\",\n            Self::MerchantInitiatedTransaction => \"2\",\n        }\n    }\n}\n\nimpl std::fmt::Display for TrustpaymentsCredentialsOnFile {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl TrustpaymentsSettleStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n     \n\n... [truncated 48865 chars] ...\n\nesponse.errormessage,\n            reason: error_reason,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n        }\n    }\n}\n\nimpl TrustpaymentsPaymentResponseData {\n    pub fn get_refund_status(&self) -> enums::RefundStatus {\n        match self.errorcode {\n            TrustpaymentsErrorCode::Success => match &self.settlestatus {\n                Some(TrustpaymentsSettleStatus::Settled) => enums::RefundStatus::Success,\n                Some(TrustpaymentsSettleStatus::PendingSettlement) => enums::RefundStatus::Pending,\n                Some(TrustpaymentsSettleStatus::ManualCapture) => enums::RefundStatus::Failure,\n                Some(TrustpaymentsSettleStatus::Voided) => enums::RefundStatus::Failure,\n                None => enums::RefundStatus::Success,\n            },\n            TrustpaymentsErrorCode::Processing => enums::RefundStatus::Pending,\n            _ => enums::RefundStatus::Failure,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpayments__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpayments__transformers.rs"}, {"query": "TrustpaymentsErrorCode enum", "code": "use common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData, RefundsRequestData, RouterData as RouterDataExt},\n};\n\nconst TRUSTPAYMENTS_API_VERSION: &str = \"1.00\";\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum TrustpaymentsSettleStatus {\n    #[serde(rename = \"0\")]\n    PendingSettlement,\n    #[serde(rename = \"1\")]\n    Settled,\n    #[serde(rename = \"2\")]\n    ManualCapture,\n    #[serde(rename = \"3\")]\n    Voided,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum TrustpaymentsCredentialsOnFile {\n    #[serde(rename = \"0\")]\n    NoStoredCredentials,\n    #[serde(rename = \"1\")]\n    CardholderInitiatedTransaction,\n    #[serde(rename = \"2\")]\n    MerchantInitiatedTransaction,\n}\n\nimpl TrustpaymentsCredentialsOnFile {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            Self::NoStoredCredentials => \"0\",\n            Self::CardholderInitiatedTransaction => \"1\",\n            Self::MerchantInitiatedTransaction => \"2\",\n        }\n    }\n}\n\nimpl std::fmt::Display for TrustpaymentsCredentialsOnFile {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl TrustpaymentsSettleStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n     \n\n... [truncated 48865 chars] ...\n\nesponse.errormessage,\n            reason: error_reason,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n        }\n    }\n}\n\nimpl TrustpaymentsPaymentResponseData {\n    pub fn get_refund_status(&self) -> enums::RefundStatus {\n        match self.errorcode {\n            TrustpaymentsErrorCode::Success => match &self.settlestatus {\n                Some(TrustpaymentsSettleStatus::Settled) => enums::RefundStatus::Success,\n                Some(TrustpaymentsSettleStatus::PendingSettlement) => enums::RefundStatus::Pending,\n                Some(TrustpaymentsSettleStatus::ManualCapture) => enums::RefundStatus::Failure,\n                Some(TrustpaymentsSettleStatus::Voided) => enums::RefundStatus::Failure,\n                None => enums::RefundStatus::Success,\n            },\n            TrustpaymentsErrorCode::Processing => enums::RefundStatus::Pending,\n            _ => enums::RefundStatus::Failure,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpayments__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpayments__transformers.rs"}, {"query": "transformers.rs TrustPayments connector", "code": "use common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData, RefundsRequestData, RouterData as RouterDataExt},\n};\n\nconst TRUSTPAYMENTS_API_VERSION: &str = \"1.00\";\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum TrustpaymentsSettleStatus {\n    #[serde(rename = \"0\")]\n    PendingSettlement,\n    #[serde(rename = \"1\")]\n    Settled,\n    #[serde(rename = \"2\")]\n    ManualCapture,\n    #[serde(rename = \"3\")]\n    Voided,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum TrustpaymentsCredentialsOnFile {\n    #[serde(rename = \"0\")]\n    NoStoredCredentials,\n    #[serde(rename = \"1\")]\n    CardholderInitiatedTransaction,\n    #[serde(rename = \"2\")]\n    MerchantInitiatedTransaction,\n}\n\nimpl TrustpaymentsCredentialsOnFile {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            Self::NoStoredCredentials => \"0\",\n            Self::CardholderInitiatedTransaction => \"1\",\n            Self::MerchantInitiatedTransaction => \"2\",\n        }\n    }\n}\n\nimpl std::fmt::Display for TrustpaymentsCredentialsOnFile {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl TrustpaymentsSettleStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n     \n\n... [truncated 48865 chars] ...\n\nesponse.errormessage,\n            reason: error_reason,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n        }\n    }\n}\n\nimpl TrustpaymentsPaymentResponseData {\n    pub fn get_refund_status(&self) -> enums::RefundStatus {\n        match self.errorcode {\n            TrustpaymentsErrorCode::Success => match &self.settlestatus {\n                Some(TrustpaymentsSettleStatus::Settled) => enums::RefundStatus::Success,\n                Some(TrustpaymentsSettleStatus::PendingSettlement) => enums::RefundStatus::Pending,\n                Some(TrustpaymentsSettleStatus::ManualCapture) => enums::RefundStatus::Failure,\n                Some(TrustpaymentsSettleStatus::Voided) => enums::RefundStatus::Failure,\n                None => enums::RefundStatus::Success,\n            },\n            TrustpaymentsErrorCode::Processing => enums::RefundStatus::Pending,\n            _ => enums::RefundStatus::Failure,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpayments__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpayments__transformers.rs"}, {"query": "RefundsRouterData TrustPayments", "code": "use common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData, RefundsRequestData, RouterData as RouterDataExt},\n};\n\nconst TRUSTPAYMENTS_API_VERSION: &str = \"1.00\";\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum TrustpaymentsSettleStatus {\n    #[serde(rename = \"0\")]\n    PendingSettlement,\n    #[serde(rename = \"1\")]\n    Settled,\n    #[serde(rename = \"2\")]\n    ManualCapture,\n    #[serde(rename = \"3\")]\n    Voided,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum TrustpaymentsCredentialsOnFile {\n    #[serde(rename = \"0\")]\n    NoStoredCredentials,\n    #[serde(rename = \"1\")]\n    CardholderInitiatedTransaction,\n    #[serde(rename = \"2\")]\n    MerchantInitiatedTransaction,\n}\n\nimpl TrustpaymentsCredentialsOnFile {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            Self::NoStoredCredentials => \"0\",\n            Self::CardholderInitiatedTransaction => \"1\",\n            Self::MerchantInitiatedTransaction => \"2\",\n        }\n    }\n}\n\nimpl std::fmt::Display for TrustpaymentsCredentialsOnFile {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl TrustpaymentsSettleStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n     \n\n... [truncated 48865 chars] ...\n\nesponse.errormessage,\n            reason: error_reason,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n        }\n    }\n}\n\nimpl TrustpaymentsPaymentResponseData {\n    pub fn get_refund_status(&self) -> enums::RefundStatus {\n        match self.errorcode {\n            TrustpaymentsErrorCode::Success => match &self.settlestatus {\n                Some(TrustpaymentsSettleStatus::Settled) => enums::RefundStatus::Success,\n                Some(TrustpaymentsSettleStatus::PendingSettlement) => enums::RefundStatus::Pending,\n                Some(TrustpaymentsSettleStatus::ManualCapture) => enums::RefundStatus::Failure,\n                Some(TrustpaymentsSettleStatus::Voided) => enums::RefundStatus::Failure,\n                None => enums::RefundStatus::Success,\n            },\n            TrustpaymentsErrorCode::Processing => enums::RefundStatus::Pending,\n            _ => enums::RefundStatus::Failure,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpayments__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpayments__transformers.rs"}, {"query": "Elavon payment gateway integration", "code": "pub mod transformers;\nuse std::{collections::HashMap, str, sync::LazyLock};\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::report;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Secret, WithoutType};\nuse serde::Serialize;\nuse transformers as elavon;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils,\n    utils::{is_mandate_supported, PaymentMethodDataType},\n};\n\npub fn struct_to_xml<T: Serialize>(\n    item: &T,\n) -> Result<HashMap<String, Secret<String, WithoutType>>, errors::ConnectorError> {\n    le\n\n... [truncated 20805 chars] ...\n\n         }\n                }),\n            ),\n        },\n    );\n\n    elavon_supported_payment_methods\n});\n\nstatic ELAVON_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Elavon\",\n    description: \"Elavon, a wholly owned subsidiary of U.S. Bank, has been a global leader in payment processing for more than 30 years.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic ELAVON_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Elavon {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ELAVON_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ELAVON_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ELAVON_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__elavon.rs", "file": "crates__hyperswitch_connectors__src__connectors__elavon.rs"}, {"query": "Elavon connector implementation", "code": "pub mod transformers;\nuse std::{collections::HashMap, str, sync::LazyLock};\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::report;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Secret, WithoutType};\nuse serde::Serialize;\nuse transformers as elavon;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils,\n    utils::{is_mandate_supported, PaymentMethodDataType},\n};\n\npub fn struct_to_xml<T: Serialize>(\n    item: &T,\n) -> Result<HashMap<String, Secret<String, WithoutType>>, errors::ConnectorError> {\n    le\n\n... [truncated 20805 chars] ...\n\n         }\n                }),\n            ),\n        },\n    );\n\n    elavon_supported_payment_methods\n});\n\nstatic ELAVON_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Elavon\",\n    description: \"Elavon, a wholly owned subsidiary of U.S. Bank, has been a global leader in payment processing for more than 30 years.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic ELAVON_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Elavon {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ELAVON_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ELAVON_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ELAVON_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__elavon.rs", "file": "crates__hyperswitch_connectors__src__connectors__elavon.rs"}, {"query": "how to configure Elavon payments", "code": "pub mod transformers;\nuse std::{collections::HashMap, str, sync::LazyLock};\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::report;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Secret, WithoutType};\nuse serde::Serialize;\nuse transformers as elavon;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils,\n    utils::{is_mandate_supported, PaymentMethodDataType},\n};\n\npub fn struct_to_xml<T: Serialize>(\n    item: &T,\n) -> Result<HashMap<String, Secret<String, WithoutType>>, errors::ConnectorError> {\n    le\n\n... [truncated 20805 chars] ...\n\n         }\n                }),\n            ),\n        },\n    );\n\n    elavon_supported_payment_methods\n});\n\nstatic ELAVON_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Elavon\",\n    description: \"Elavon, a wholly owned subsidiary of U.S. Bank, has been a global leader in payment processing for more than 30 years.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic ELAVON_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Elavon {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ELAVON_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ELAVON_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ELAVON_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__elavon.rs", "file": "crates__hyperswitch_connectors__src__connectors__elavon.rs"}, {"query": "Elavon XML request format", "code": "pub mod transformers;\nuse std::{collections::HashMap, str, sync::LazyLock};\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::report;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Secret, WithoutType};\nuse serde::Serialize;\nuse transformers as elavon;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils,\n    utils::{is_mandate_supported, PaymentMethodDataType},\n};\n\npub fn struct_to_xml<T: Serialize>(\n    item: &T,\n) -> Result<HashMap<String, Secret<String, WithoutType>>, errors::ConnectorError> {\n    le\n\n... [truncated 20805 chars] ...\n\n         }\n                }),\n            ),\n        },\n    );\n\n    elavon_supported_payment_methods\n});\n\nstatic ELAVON_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Elavon\",\n    description: \"Elavon, a wholly owned subsidiary of U.S. Bank, has been a global leader in payment processing for more than 30 years.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic ELAVON_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Elavon {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ELAVON_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ELAVON_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ELAVON_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__elavon.rs", "file": "crates__hyperswitch_connectors__src__connectors__elavon.rs"}, {"query": "Payu payment request transformer", "code": "use base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    pii::{Email, IpAddress},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::AccessTokenRequestInfo as _,\n};\n\nconst WALLET_IDENTIFIER: &str = \"PBL\";\n\n#[derive(Debug, Serialize)]\npub struct PayuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PayuRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuPaymentsRequest {\n    customer_ip: Secret<String, IpAddress>,\n    merchant_pos_id: Secret<String>,\n    total_amount: MinorUnit,\n    currency_code: enums::Currency,\n    description: String,\n    pay_methods: PayuPaymentMethod,\n    continue_url: Option<String>,\n    ext_order_id: Option<String>,\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuPaymentMethod {\n    pay_method: PayuPaymentMethodData,\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(untagged)]\npub enum PayuPaymentMethodData {\n    Card(PayuCard),\n    Wallet(PayuWallet),\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PayuCard {\n    #[serde(rename_all = \"camelCase\")]\n    Card {\n        number: cards::CardNumber,\n       \n\n... [truncated 19713 chars] ...\n\nlt<Self, Self::Error> {\n        let refund = match item.response.refunds.first() {\n            Some(refund) => refund,\n            _ => Err(errors::ConnectorError::ResponseHandlingFailed)?,\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: refund.refund_id.clone(),\n                refund_status: enums::RefundStatus::from(refund.status.clone()),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuErrorData {\n    pub status_code: String,\n    pub code: Option<String>,\n    pub code_literal: Option<String>,\n    pub status_desc: String,\n}\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct PayuErrorResponse {\n    pub status: PayuErrorData,\n}\n\n#[derive(Deserialize, Debug, Serialize)]\npub struct PayuAccessTokenErrorResponse {\n    pub error: String,\n    pub error_description: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payu__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payu__transformers.rs"}, {"query": "how to handle Payu refunds", "code": "use base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    pii::{Email, IpAddress},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::AccessTokenRequestInfo as _,\n};\n\nconst WALLET_IDENTIFIER: &str = \"PBL\";\n\n#[derive(Debug, Serialize)]\npub struct PayuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PayuRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuPaymentsRequest {\n    customer_ip: Secret<String, IpAddress>,\n    merchant_pos_id: Secret<String>,\n    total_amount: MinorUnit,\n    currency_code: enums::Currency,\n    description: String,\n    pay_methods: PayuPaymentMethod,\n    continue_url: Option<String>,\n    ext_order_id: Option<String>,\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuPaymentMethod {\n    pay_method: PayuPaymentMethodData,\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(untagged)]\npub enum PayuPaymentMethodData {\n    Card(PayuCard),\n    Wallet(PayuWallet),\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PayuCard {\n    #[serde(rename_all = \"camelCase\")]\n    Card {\n        number: cards::CardNumber,\n       \n\n... [truncated 19713 chars] ...\n\nlt<Self, Self::Error> {\n        let refund = match item.response.refunds.first() {\n            Some(refund) => refund,\n            _ => Err(errors::ConnectorError::ResponseHandlingFailed)?,\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: refund.refund_id.clone(),\n                refund_status: enums::RefundStatus::from(refund.status.clone()),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuErrorData {\n    pub status_code: String,\n    pub code: Option<String>,\n    pub code_literal: Option<String>,\n    pub status_desc: String,\n}\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct PayuErrorResponse {\n    pub status: PayuErrorData,\n}\n\n#[derive(Deserialize, Debug, Serialize)]\npub struct PayuAccessTokenErrorResponse {\n    pub error: String,\n    pub error_description: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payu__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payu__transformers.rs"}, {"query": "Payu connector implementation", "code": "use base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    pii::{Email, IpAddress},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::AccessTokenRequestInfo as _,\n};\n\nconst WALLET_IDENTIFIER: &str = \"PBL\";\n\n#[derive(Debug, Serialize)]\npub struct PayuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PayuRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuPaymentsRequest {\n    customer_ip: Secret<String, IpAddress>,\n    merchant_pos_id: Secret<String>,\n    total_amount: MinorUnit,\n    currency_code: enums::Currency,\n    description: String,\n    pay_methods: PayuPaymentMethod,\n    continue_url: Option<String>,\n    ext_order_id: Option<String>,\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuPaymentMethod {\n    pay_method: PayuPaymentMethodData,\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(untagged)]\npub enum PayuPaymentMethodData {\n    Card(PayuCard),\n    Wallet(PayuWallet),\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PayuCard {\n    #[serde(rename_all = \"camelCase\")]\n    Card {\n        number: cards::CardNumber,\n       \n\n... [truncated 19713 chars] ...\n\nlt<Self, Self::Error> {\n        let refund = match item.response.refunds.first() {\n            Some(refund) => refund,\n            _ => Err(errors::ConnectorError::ResponseHandlingFailed)?,\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: refund.refund_id.clone(),\n                refund_status: enums::RefundStatus::from(refund.status.clone()),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuErrorData {\n    pub status_code: String,\n    pub code: Option<String>,\n    pub code_literal: Option<String>,\n    pub status_desc: String,\n}\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct PayuErrorResponse {\n    pub status: PayuErrorData,\n}\n\n#[derive(Deserialize, Debug, Serialize)]\npub struct PayuAccessTokenErrorResponse {\n    pub error: String,\n    pub error_description: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payu__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payu__transformers.rs"}, {"query": "transform router data to Payu API", "code": "use base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    pii::{Email, IpAddress},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::AccessTokenRequestInfo as _,\n};\n\nconst WALLET_IDENTIFIER: &str = \"PBL\";\n\n#[derive(Debug, Serialize)]\npub struct PayuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PayuRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuPaymentsRequest {\n    customer_ip: Secret<String, IpAddress>,\n    merchant_pos_id: Secret<String>,\n    total_amount: MinorUnit,\n    currency_code: enums::Currency,\n    description: String,\n    pay_methods: PayuPaymentMethod,\n    continue_url: Option<String>,\n    ext_order_id: Option<String>,\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuPaymentMethod {\n    pay_method: PayuPaymentMethodData,\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(untagged)]\npub enum PayuPaymentMethodData {\n    Card(PayuCard),\n    Wallet(PayuWallet),\n}\n\n#[derive(Debug, Eq, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PayuCard {\n    #[serde(rename_all = \"camelCase\")]\n    Card {\n        number: cards::CardNumber,\n       \n\n... [truncated 19713 chars] ...\n\nlt<Self, Self::Error> {\n        let refund = match item.response.refunds.first() {\n            Some(refund) => refund,\n            _ => Err(errors::ConnectorError::ResponseHandlingFailed)?,\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: refund.refund_id.clone(),\n                refund_status: enums::RefundStatus::from(refund.status.clone()),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayuErrorData {\n    pub status_code: String,\n    pub code: Option<String>,\n    pub code_literal: Option<String>,\n    pub status_desc: String,\n}\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct PayuErrorResponse {\n    pub status: PayuErrorData,\n}\n\n#[derive(Deserialize, Debug, Serialize)]\npub struct PayuAccessTokenErrorResponse {\n    pub error: String,\n    pub error_description: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payu__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payu__transformers.rs"}, {"query": "Datatrans payment authorization response transformation", "code": "use std::collections::HashMap;\n\nuse api_models::payments::{self, AdditionalPaymentData};\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, AdditionalCardInfo, CardData as _,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst TRANSACTION_ALREADY_CANCELLED: &str = \"transaction already canceled\";\nconst TRANSACTION_ALREADY_SETTLED: &str = \"already settled\";\nconst REDIRECTION_SBX_URL: &str = \"https://pay.sandbox.datatrans.com\";\nconst REDIRECTION_PROD_URL: &str = \"https://pay.datatrans.com\";\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize)]\npub struct DatatransErrorResponse {\n    pub error: DatatransError,\n}\npub struct DatatransAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) passcode: Secret<String>,\n}\n\npub struct DatatransRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DatatransPaymentsRequest {\n    pub amount: Option<MinorUnit>,\n    pub currency: enums::Currency,\n    pub card: DataTransPaymentDetails,\n    pub refno: String,\n    pub auto_settle: bool,\n    #[serde(ski\n\n... [truncated 33291 chars] ...\n\nnnectorError>;\n\n    fn try_from(\n        item: PaymentsCancelResponseRouterData<DataTransCancelResponse>,\n    ) -> Result<Self, Self::Error> {\n        let status = match item.response {\n            // Datatrans http code 204 implies Successful Cancellation\n            //https://api-reference.datatrans.ch/#tag/v1transactions/operation/cancel\n            DataTransCancelResponse::Empty => {\n                if item.http_code == 204 {\n                    common_enums::AttemptStatus::Voided\n                } else {\n                    common_enums::AttemptStatus::Failure\n                }\n            }\n            DataTransCancelResponse::Error(error) => {\n                if error.message == *TRANSACTION_ALREADY_CANCELLED {\n                    common_enums::AttemptStatus::Voided\n                } else {\n                    common_enums::AttemptStatus::Failure\n                }\n            }\n        };\n        Ok(Self {\n            status,\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs"}, {"query": "DatatransCaptureResponse struct implementation", "code": "use std::collections::HashMap;\n\nuse api_models::payments::{self, AdditionalPaymentData};\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, AdditionalCardInfo, CardData as _,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst TRANSACTION_ALREADY_CANCELLED: &str = \"transaction already canceled\";\nconst TRANSACTION_ALREADY_SETTLED: &str = \"already settled\";\nconst REDIRECTION_SBX_URL: &str = \"https://pay.sandbox.datatrans.com\";\nconst REDIRECTION_PROD_URL: &str = \"https://pay.datatrans.com\";\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize)]\npub struct DatatransErrorResponse {\n    pub error: DatatransError,\n}\npub struct DatatransAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) passcode: Secret<String>,\n}\n\npub struct DatatransRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DatatransPaymentsRequest {\n    pub amount: Option<MinorUnit>,\n    pub currency: enums::Currency,\n    pub card: DataTransPaymentDetails,\n    pub refno: String,\n    pub auto_settle: bool,\n    #[serde(ski\n\n... [truncated 33291 chars] ...\n\nnnectorError>;\n\n    fn try_from(\n        item: PaymentsCancelResponseRouterData<DataTransCancelResponse>,\n    ) -> Result<Self, Self::Error> {\n        let status = match item.response {\n            // Datatrans http code 204 implies Successful Cancellation\n            //https://api-reference.datatrans.ch/#tag/v1transactions/operation/cancel\n            DataTransCancelResponse::Empty => {\n                if item.http_code == 204 {\n                    common_enums::AttemptStatus::Voided\n                } else {\n                    common_enums::AttemptStatus::Failure\n                }\n            }\n            DataTransCancelResponse::Error(error) => {\n                if error.message == *TRANSACTION_ALREADY_CANCELLED {\n                    common_enums::AttemptStatus::Voided\n                } else {\n                    common_enums::AttemptStatus::Failure\n                }\n            }\n        };\n        Ok(Self {\n            status,\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs"}, {"query": "map Datatrans error to AttemptStatus", "code": "use std::collections::HashMap;\n\nuse api_models::payments::{self, AdditionalPaymentData};\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, AdditionalCardInfo, CardData as _,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst TRANSACTION_ALREADY_CANCELLED: &str = \"transaction already canceled\";\nconst TRANSACTION_ALREADY_SETTLED: &str = \"already settled\";\nconst REDIRECTION_SBX_URL: &str = \"https://pay.sandbox.datatrans.com\";\nconst REDIRECTION_PROD_URL: &str = \"https://pay.datatrans.com\";\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize)]\npub struct DatatransErrorResponse {\n    pub error: DatatransError,\n}\npub struct DatatransAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) passcode: Secret<String>,\n}\n\npub struct DatatransRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DatatransPaymentsRequest {\n    pub amount: Option<MinorUnit>,\n    pub currency: enums::Currency,\n    pub card: DataTransPaymentDetails,\n    pub refno: String,\n    pub auto_settle: bool,\n    #[serde(ski\n\n... [truncated 33291 chars] ...\n\nnnectorError>;\n\n    fn try_from(\n        item: PaymentsCancelResponseRouterData<DataTransCancelResponse>,\n    ) -> Result<Self, Self::Error> {\n        let status = match item.response {\n            // Datatrans http code 204 implies Successful Cancellation\n            //https://api-reference.datatrans.ch/#tag/v1transactions/operation/cancel\n            DataTransCancelResponse::Empty => {\n                if item.http_code == 204 {\n                    common_enums::AttemptStatus::Voided\n                } else {\n                    common_enums::AttemptStatus::Failure\n                }\n            }\n            DataTransCancelResponse::Error(error) => {\n                if error.message == *TRANSACTION_ALREADY_CANCELLED {\n                    common_enums::AttemptStatus::Voided\n                } else {\n                    common_enums::AttemptStatus::Failure\n                }\n            }\n        };\n        Ok(Self {\n            status,\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs"}, {"query": "Datatrans connector payment flow", "code": "use std::collections::HashMap;\n\nuse api_models::payments::{self, AdditionalPaymentData};\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, AdditionalCardInfo, CardData as _,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst TRANSACTION_ALREADY_CANCELLED: &str = \"transaction already canceled\";\nconst TRANSACTION_ALREADY_SETTLED: &str = \"already settled\";\nconst REDIRECTION_SBX_URL: &str = \"https://pay.sandbox.datatrans.com\";\nconst REDIRECTION_PROD_URL: &str = \"https://pay.datatrans.com\";\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize)]\npub struct DatatransErrorResponse {\n    pub error: DatatransError,\n}\npub struct DatatransAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) passcode: Secret<String>,\n}\n\npub struct DatatransRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DatatransPaymentsRequest {\n    pub amount: Option<MinorUnit>,\n    pub currency: enums::Currency,\n    pub card: DataTransPaymentDetails,\n    pub refno: String,\n    pub auto_settle: bool,\n    #[serde(ski\n\n... [truncated 33291 chars] ...\n\nnnectorError>;\n\n    fn try_from(\n        item: PaymentsCancelResponseRouterData<DataTransCancelResponse>,\n    ) -> Result<Self, Self::Error> {\n        let status = match item.response {\n            // Datatrans http code 204 implies Successful Cancellation\n            //https://api-reference.datatrans.ch/#tag/v1transactions/operation/cancel\n            DataTransCancelResponse::Empty => {\n                if item.http_code == 204 {\n                    common_enums::AttemptStatus::Voided\n                } else {\n                    common_enums::AttemptStatus::Failure\n                }\n            }\n            DataTransCancelResponse::Error(error) => {\n                if error.message == *TRANSACTION_ALREADY_CANCELLED {\n                    common_enums::AttemptStatus::Voided\n                } else {\n                    common_enums::AttemptStatus::Failure\n                }\n            }\n        };\n        Ok(Self {\n            status,\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs"}, {"query": "how to implement relay interface in rust", "code": "use std::marker::PhantomData;\n\nuse api_models::relay as relay_api_models;\nuse async_trait::async_trait;\nuse common_enums::RelayStatus;\nuse common_utils::{\n    self, fp_utils,\n    id_type::{self, GenerateId},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::relay;\n\nuse super::errors::{self, ConnectorErrorExt, RouterResponse, RouterResult, StorageErrorExt};\nuse crate::{\n    core::payments,\n    routes::SessionState,\n    services,\n    types::{\n        api::{self},\n        domain,\n    },\n    utils::OptionExt,\n};\n\npub mod utils;\n\npub trait Validate {\n    type Error: error_stack::Context;\n    fn validate(&self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayRefundRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayCaptureRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount_to_capture.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        fp_utils::when(\n            self.amount_to_capture.get_amount_as_i64() > self.authorized_amount.get_amount_as_i64(),\n            || {\n                Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"Capture Amount should be less than or equal to Authorized Amount\"\n                        .to_string(),\n                })\n            },\n        )?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayIncrementalAuthorizationRequestData {\n    type Error = errors::ApiError\n\n... [truncated 32442 chars] ...\n\nentsResponseData,\n    > = connector_data.connector.get_connector_integration();\n\n    let capture_method_type = connector_integration\n        .get_multiple_capture_sync_method()\n        .map_err(|err| {\n            router_env::logger::error!(error=?err);\n        })\n        .ok();\n\n    let router_data = utils::construct_relay_payments_retrieve_router_data(\n        state,\n        merchant_id,\n        &connector_account,\n        relay_record,\n        capture_method_type,\n    )\n    .await?;\n\n    let router_data_res = services::execute_connector_processing_step(\n        state,\n        connector_integration,\n        &router_data,\n        payments::CallConnectorAction::Trigger,\n        None,\n        None,\n    )\n    .await\n    .to_payment_failed_response()?;\n\n    let relay_response = relay::RelayUpdate::try_from_capture_response((\n        router_data_res.status,\n        relay_record.connector_resource_id.to_owned(),\n        router_data_res.response,\n    ))?;\n\n    Ok(relay_response)\n}\n", "function_name": "crates__router__src__core__relay.rs", "file": "crates__router__src__core__relay.rs"}, {"query": "RelayInterface trait definition", "code": "use std::marker::PhantomData;\n\nuse api_models::relay as relay_api_models;\nuse async_trait::async_trait;\nuse common_enums::RelayStatus;\nuse common_utils::{\n    self, fp_utils,\n    id_type::{self, GenerateId},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::relay;\n\nuse super::errors::{self, ConnectorErrorExt, RouterResponse, RouterResult, StorageErrorExt};\nuse crate::{\n    core::payments,\n    routes::SessionState,\n    services,\n    types::{\n        api::{self},\n        domain,\n    },\n    utils::OptionExt,\n};\n\npub mod utils;\n\npub trait Validate {\n    type Error: error_stack::Context;\n    fn validate(&self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayRefundRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayCaptureRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount_to_capture.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        fp_utils::when(\n            self.amount_to_capture.get_amount_as_i64() > self.authorized_amount.get_amount_as_i64(),\n            || {\n                Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"Capture Amount should be less than or equal to Authorized Amount\"\n                        .to_string(),\n                })\n            },\n        )?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayIncrementalAuthorizationRequestData {\n    type Error = errors::ApiError\n\n... [truncated 32442 chars] ...\n\nentsResponseData,\n    > = connector_data.connector.get_connector_integration();\n\n    let capture_method_type = connector_integration\n        .get_multiple_capture_sync_method()\n        .map_err(|err| {\n            router_env::logger::error!(error=?err);\n        })\n        .ok();\n\n    let router_data = utils::construct_relay_payments_retrieve_router_data(\n        state,\n        merchant_id,\n        &connector_account,\n        relay_record,\n        capture_method_type,\n    )\n    .await?;\n\n    let router_data_res = services::execute_connector_processing_step(\n        state,\n        connector_integration,\n        &router_data,\n        payments::CallConnectorAction::Trigger,\n        None,\n        None,\n    )\n    .await\n    .to_payment_failed_response()?;\n\n    let relay_response = relay::RelayUpdate::try_from_capture_response((\n        router_data_res.status,\n        relay_record.connector_resource_id.to_owned(),\n        router_data_res.response,\n    ))?;\n\n    Ok(relay_response)\n}\n", "function_name": "crates__router__src__core__relay.rs", "file": "crates__router__src__core__relay.rs"}, {"query": "how to process payment capture via relay", "code": "use std::marker::PhantomData;\n\nuse api_models::relay as relay_api_models;\nuse async_trait::async_trait;\nuse common_enums::RelayStatus;\nuse common_utils::{\n    self, fp_utils,\n    id_type::{self, GenerateId},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::relay;\n\nuse super::errors::{self, ConnectorErrorExt, RouterResponse, RouterResult, StorageErrorExt};\nuse crate::{\n    core::payments,\n    routes::SessionState,\n    services,\n    types::{\n        api::{self},\n        domain,\n    },\n    utils::OptionExt,\n};\n\npub mod utils;\n\npub trait Validate {\n    type Error: error_stack::Context;\n    fn validate(&self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayRefundRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayCaptureRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount_to_capture.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        fp_utils::when(\n            self.amount_to_capture.get_amount_as_i64() > self.authorized_amount.get_amount_as_i64(),\n            || {\n                Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"Capture Amount should be less than or equal to Authorized Amount\"\n                        .to_string(),\n                })\n            },\n        )?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayIncrementalAuthorizationRequestData {\n    type Error = errors::ApiError\n\n... [truncated 32442 chars] ...\n\nentsResponseData,\n    > = connector_data.connector.get_connector_integration();\n\n    let capture_method_type = connector_integration\n        .get_multiple_capture_sync_method()\n        .map_err(|err| {\n            router_env::logger::error!(error=?err);\n        })\n        .ok();\n\n    let router_data = utils::construct_relay_payments_retrieve_router_data(\n        state,\n        merchant_id,\n        &connector_account,\n        relay_record,\n        capture_method_type,\n    )\n    .await?;\n\n    let router_data_res = services::execute_connector_processing_step(\n        state,\n        connector_integration,\n        &router_data,\n        payments::CallConnectorAction::Trigger,\n        None,\n        None,\n    )\n    .await\n    .to_payment_failed_response()?;\n\n    let relay_response = relay::RelayUpdate::try_from_capture_response((\n        router_data_res.status,\n        relay_record.connector_resource_id.to_owned(),\n        router_data_res.response,\n    ))?;\n\n    Ok(relay_response)\n}\n", "function_name": "crates__router__src__core__relay.rs", "file": "crates__router__src__core__relay.rs"}, {"query": "validate relay request data rust", "code": "use std::marker::PhantomData;\n\nuse api_models::relay as relay_api_models;\nuse async_trait::async_trait;\nuse common_enums::RelayStatus;\nuse common_utils::{\n    self, fp_utils,\n    id_type::{self, GenerateId},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::relay;\n\nuse super::errors::{self, ConnectorErrorExt, RouterResponse, RouterResult, StorageErrorExt};\nuse crate::{\n    core::payments,\n    routes::SessionState,\n    services,\n    types::{\n        api::{self},\n        domain,\n    },\n    utils::OptionExt,\n};\n\npub mod utils;\n\npub trait Validate {\n    type Error: error_stack::Context;\n    fn validate(&self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayRefundRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayCaptureRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount_to_capture.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        fp_utils::when(\n            self.amount_to_capture.get_amount_as_i64() > self.authorized_amount.get_amount_as_i64(),\n            || {\n                Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"Capture Amount should be less than or equal to Authorized Amount\"\n                        .to_string(),\n                })\n            },\n        )?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayIncrementalAuthorizationRequestData {\n    type Error = errors::ApiError\n\n... [truncated 32442 chars] ...\n\nentsResponseData,\n    > = connector_data.connector.get_connector_integration();\n\n    let capture_method_type = connector_integration\n        .get_multiple_capture_sync_method()\n        .map_err(|err| {\n            router_env::logger::error!(error=?err);\n        })\n        .ok();\n\n    let router_data = utils::construct_relay_payments_retrieve_router_data(\n        state,\n        merchant_id,\n        &connector_account,\n        relay_record,\n        capture_method_type,\n    )\n    .await?;\n\n    let router_data_res = services::execute_connector_processing_step(\n        state,\n        connector_integration,\n        &router_data,\n        payments::CallConnectorAction::Trigger,\n        None,\n        None,\n    )\n    .await\n    .to_payment_failed_response()?;\n\n    let relay_response = relay::RelayUpdate::try_from_capture_response((\n        router_data_res.status,\n        relay_record.connector_resource_id.to_owned(),\n        router_data_res.response,\n    ))?;\n\n    Ok(relay_response)\n}\n", "function_name": "crates__router__src__core__relay.rs", "file": "crates__router__src__core__relay.rs"}, {"query": "payment orchestration core operations rust", "code": "#[cfg(feature = \"v1\")]\npub mod payment_approve;\n#[cfg(feature = \"v1\")]\npub mod payment_cancel;\n#[cfg(feature = \"v1\")]\npub mod payment_cancel_post_capture;\n#[cfg(feature = \"v1\")]\npub mod payment_capture;\n#[cfg(feature = \"v1\")]\npub mod payment_complete_authorize;\n#[cfg(feature = \"v1\")]\npub mod payment_confirm;\n#[cfg(feature = \"v1\")]\npub mod payment_create;\n#[cfg(feature = \"v1\")]\npub mod payment_post_session_tokens;\n#[cfg(feature = \"v1\")]\npub mod payment_reject;\npub mod payment_response;\n#[cfg(feature = \"v1\")]\npub mod payment_session;\n#[cfg(feature = \"v2\")]\npub mod payment_session_intent;\n#[cfg(feature = \"v1\")]\npub mod payment_start;\n#[cfg(feature = \"v1\")]\npub mod payment_status;\n#[cfg(feature = \"v1\")]\npub mod payment_update;\n#[cfg(feature = \"v1\")]\npub mod payment_update_metadata;\n#[cfg(feature = \"v1\")]\npub mod payments_extend_authorization;\n#[cfg(feature = \"v1\")]\npub mod payments_incremental_authorization;\n#[cfg(feature = \"v1\")]\npub mod tax_calculation;\n\n#[cfg(feature = \"v2\")]\npub mod payment_attempt_list;\n#[cfg(feature = \"v2\")]\npub mod payment_attempt_record;\n#[cfg(feature = \"v2\")]\npub mod payment_confirm_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_create_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_get_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_update_intent;\n#[cfg(feature = \"v2\")]\npub mod proxy_payments_intent;\n\n#[cfg(feature = \"v2\")]\npub mod external_vault_proxy_payment_intent;\n\n#[cfg(feature = \"v2\")]\npub mod payment_get;\n\n#[cfg(feature = \"v2\")]\npub mod payment_capture_v2;\n\n#[cfg(feature = \"v2\")]\npub mod payment_cancel_v2;\n\nuse api_models::enums::FrmSuggestion;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse error_stack::{report, ResultExt};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\npub use self::payment_attempt_list::PaymentGetListAttempts;\n#[cfg(feature = \"v2\")]\npub use self::payment_get::PaymentGet;\n#[cfg(feature = \"v2\")]\npub use self::payment_get_in\n\n... [truncated 29741 chars] ...\n\nectRequest,\n        _payment_intent: &storage::PaymentIntent,\n    ) -> CustomResult<api::ConnectorChoice, errors::ApiErrorResponse> {\n        helpers::get_connector_default(state, None).await\n    }\n\n    #[instrument(skip_all)]\n    async fn guard_payment_against_blocklist<'a>(\n        &'a self,\n        _state: &SessionState,\n        _processor: &domain::Processor,\n        _payment_data: &mut D,\n    ) -> CustomResult<bool, errors::ApiErrorResponse> {\n        Ok(false)\n    }\n}\n\n/// Validate if a particular operation can be performed for the given intent status\npub trait ValidateStatusForOperation {\n    fn validate_status_for_operation(\n        &self,\n        intent_status: common_enums::IntentStatus,\n    ) -> Result<(), errors::ApiErrorResponse>;\n}\n\n/// Should the connector be called for this operation\npub trait ShouldCallConnector {\n    fn should_call_connector(\n        &self,\n        intent_status: common_enums::IntentStatus,\n        force_sync: Option<bool>,\n    ) -> bool;\n}\n", "function_name": "crates__router__src__core__payments__operations.rs", "file": "crates__router__src__core__payments__operations.rs"}, {"query": "PaymentOperation trait implementation", "code": "#[cfg(feature = \"v1\")]\npub mod payment_approve;\n#[cfg(feature = \"v1\")]\npub mod payment_cancel;\n#[cfg(feature = \"v1\")]\npub mod payment_cancel_post_capture;\n#[cfg(feature = \"v1\")]\npub mod payment_capture;\n#[cfg(feature = \"v1\")]\npub mod payment_complete_authorize;\n#[cfg(feature = \"v1\")]\npub mod payment_confirm;\n#[cfg(feature = \"v1\")]\npub mod payment_create;\n#[cfg(feature = \"v1\")]\npub mod payment_post_session_tokens;\n#[cfg(feature = \"v1\")]\npub mod payment_reject;\npub mod payment_response;\n#[cfg(feature = \"v1\")]\npub mod payment_session;\n#[cfg(feature = \"v2\")]\npub mod payment_session_intent;\n#[cfg(feature = \"v1\")]\npub mod payment_start;\n#[cfg(feature = \"v1\")]\npub mod payment_status;\n#[cfg(feature = \"v1\")]\npub mod payment_update;\n#[cfg(feature = \"v1\")]\npub mod payment_update_metadata;\n#[cfg(feature = \"v1\")]\npub mod payments_extend_authorization;\n#[cfg(feature = \"v1\")]\npub mod payments_incremental_authorization;\n#[cfg(feature = \"v1\")]\npub mod tax_calculation;\n\n#[cfg(feature = \"v2\")]\npub mod payment_attempt_list;\n#[cfg(feature = \"v2\")]\npub mod payment_attempt_record;\n#[cfg(feature = \"v2\")]\npub mod payment_confirm_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_create_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_get_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_update_intent;\n#[cfg(feature = \"v2\")]\npub mod proxy_payments_intent;\n\n#[cfg(feature = \"v2\")]\npub mod external_vault_proxy_payment_intent;\n\n#[cfg(feature = \"v2\")]\npub mod payment_get;\n\n#[cfg(feature = \"v2\")]\npub mod payment_capture_v2;\n\n#[cfg(feature = \"v2\")]\npub mod payment_cancel_v2;\n\nuse api_models::enums::FrmSuggestion;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse error_stack::{report, ResultExt};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\npub use self::payment_attempt_list::PaymentGetListAttempts;\n#[cfg(feature = \"v2\")]\npub use self::payment_get::PaymentGet;\n#[cfg(feature = \"v2\")]\npub use self::payment_get_in\n\n... [truncated 29741 chars] ...\n\nectRequest,\n        _payment_intent: &storage::PaymentIntent,\n    ) -> CustomResult<api::ConnectorChoice, errors::ApiErrorResponse> {\n        helpers::get_connector_default(state, None).await\n    }\n\n    #[instrument(skip_all)]\n    async fn guard_payment_against_blocklist<'a>(\n        &'a self,\n        _state: &SessionState,\n        _processor: &domain::Processor,\n        _payment_data: &mut D,\n    ) -> CustomResult<bool, errors::ApiErrorResponse> {\n        Ok(false)\n    }\n}\n\n/// Validate if a particular operation can be performed for the given intent status\npub trait ValidateStatusForOperation {\n    fn validate_status_for_operation(\n        &self,\n        intent_status: common_enums::IntentStatus,\n    ) -> Result<(), errors::ApiErrorResponse>;\n}\n\n/// Should the connector be called for this operation\npub trait ShouldCallConnector {\n    fn should_call_connector(\n        &self,\n        intent_status: common_enums::IntentStatus,\n        force_sync: Option<bool>,\n    ) -> bool;\n}\n", "function_name": "crates__router__src__core__payments__operations.rs", "file": "crates__router__src__core__payments__operations.rs"}, {"query": "how to implement payment capture", "code": "#[cfg(feature = \"v1\")]\npub mod payment_approve;\n#[cfg(feature = \"v1\")]\npub mod payment_cancel;\n#[cfg(feature = \"v1\")]\npub mod payment_cancel_post_capture;\n#[cfg(feature = \"v1\")]\npub mod payment_capture;\n#[cfg(feature = \"v1\")]\npub mod payment_complete_authorize;\n#[cfg(feature = \"v1\")]\npub mod payment_confirm;\n#[cfg(feature = \"v1\")]\npub mod payment_create;\n#[cfg(feature = \"v1\")]\npub mod payment_post_session_tokens;\n#[cfg(feature = \"v1\")]\npub mod payment_reject;\npub mod payment_response;\n#[cfg(feature = \"v1\")]\npub mod payment_session;\n#[cfg(feature = \"v2\")]\npub mod payment_session_intent;\n#[cfg(feature = \"v1\")]\npub mod payment_start;\n#[cfg(feature = \"v1\")]\npub mod payment_status;\n#[cfg(feature = \"v1\")]\npub mod payment_update;\n#[cfg(feature = \"v1\")]\npub mod payment_update_metadata;\n#[cfg(feature = \"v1\")]\npub mod payments_extend_authorization;\n#[cfg(feature = \"v1\")]\npub mod payments_incremental_authorization;\n#[cfg(feature = \"v1\")]\npub mod tax_calculation;\n\n#[cfg(feature = \"v2\")]\npub mod payment_attempt_list;\n#[cfg(feature = \"v2\")]\npub mod payment_attempt_record;\n#[cfg(feature = \"v2\")]\npub mod payment_confirm_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_create_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_get_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_update_intent;\n#[cfg(feature = \"v2\")]\npub mod proxy_payments_intent;\n\n#[cfg(feature = \"v2\")]\npub mod external_vault_proxy_payment_intent;\n\n#[cfg(feature = \"v2\")]\npub mod payment_get;\n\n#[cfg(feature = \"v2\")]\npub mod payment_capture_v2;\n\n#[cfg(feature = \"v2\")]\npub mod payment_cancel_v2;\n\nuse api_models::enums::FrmSuggestion;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse error_stack::{report, ResultExt};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\npub use self::payment_attempt_list::PaymentGetListAttempts;\n#[cfg(feature = \"v2\")]\npub use self::payment_get::PaymentGet;\n#[cfg(feature = \"v2\")]\npub use self::payment_get_in\n\n... [truncated 29741 chars] ...\n\nectRequest,\n        _payment_intent: &storage::PaymentIntent,\n    ) -> CustomResult<api::ConnectorChoice, errors::ApiErrorResponse> {\n        helpers::get_connector_default(state, None).await\n    }\n\n    #[instrument(skip_all)]\n    async fn guard_payment_against_blocklist<'a>(\n        &'a self,\n        _state: &SessionState,\n        _processor: &domain::Processor,\n        _payment_data: &mut D,\n    ) -> CustomResult<bool, errors::ApiErrorResponse> {\n        Ok(false)\n    }\n}\n\n/// Validate if a particular operation can be performed for the given intent status\npub trait ValidateStatusForOperation {\n    fn validate_status_for_operation(\n        &self,\n        intent_status: common_enums::IntentStatus,\n    ) -> Result<(), errors::ApiErrorResponse>;\n}\n\n/// Should the connector be called for this operation\npub trait ShouldCallConnector {\n    fn should_call_connector(\n        &self,\n        intent_status: common_enums::IntentStatus,\n        force_sync: Option<bool>,\n    ) -> bool;\n}\n", "function_name": "crates__router__src__core__payments__operations.rs", "file": "crates__router__src__core__payments__operations.rs"}, {"query": "payment status validation logic", "code": "#[cfg(feature = \"v1\")]\npub mod payment_approve;\n#[cfg(feature = \"v1\")]\npub mod payment_cancel;\n#[cfg(feature = \"v1\")]\npub mod payment_cancel_post_capture;\n#[cfg(feature = \"v1\")]\npub mod payment_capture;\n#[cfg(feature = \"v1\")]\npub mod payment_complete_authorize;\n#[cfg(feature = \"v1\")]\npub mod payment_confirm;\n#[cfg(feature = \"v1\")]\npub mod payment_create;\n#[cfg(feature = \"v1\")]\npub mod payment_post_session_tokens;\n#[cfg(feature = \"v1\")]\npub mod payment_reject;\npub mod payment_response;\n#[cfg(feature = \"v1\")]\npub mod payment_session;\n#[cfg(feature = \"v2\")]\npub mod payment_session_intent;\n#[cfg(feature = \"v1\")]\npub mod payment_start;\n#[cfg(feature = \"v1\")]\npub mod payment_status;\n#[cfg(feature = \"v1\")]\npub mod payment_update;\n#[cfg(feature = \"v1\")]\npub mod payment_update_metadata;\n#[cfg(feature = \"v1\")]\npub mod payments_extend_authorization;\n#[cfg(feature = \"v1\")]\npub mod payments_incremental_authorization;\n#[cfg(feature = \"v1\")]\npub mod tax_calculation;\n\n#[cfg(feature = \"v2\")]\npub mod payment_attempt_list;\n#[cfg(feature = \"v2\")]\npub mod payment_attempt_record;\n#[cfg(feature = \"v2\")]\npub mod payment_confirm_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_create_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_get_intent;\n#[cfg(feature = \"v2\")]\npub mod payment_update_intent;\n#[cfg(feature = \"v2\")]\npub mod proxy_payments_intent;\n\n#[cfg(feature = \"v2\")]\npub mod external_vault_proxy_payment_intent;\n\n#[cfg(feature = \"v2\")]\npub mod payment_get;\n\n#[cfg(feature = \"v2\")]\npub mod payment_capture_v2;\n\n#[cfg(feature = \"v2\")]\npub mod payment_cancel_v2;\n\nuse api_models::enums::FrmSuggestion;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse error_stack::{report, ResultExt};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\npub use self::payment_attempt_list::PaymentGetListAttempts;\n#[cfg(feature = \"v2\")]\npub use self::payment_get::PaymentGet;\n#[cfg(feature = \"v2\")]\npub use self::payment_get_in\n\n... [truncated 29741 chars] ...\n\nectRequest,\n        _payment_intent: &storage::PaymentIntent,\n    ) -> CustomResult<api::ConnectorChoice, errors::ApiErrorResponse> {\n        helpers::get_connector_default(state, None).await\n    }\n\n    #[instrument(skip_all)]\n    async fn guard_payment_against_blocklist<'a>(\n        &'a self,\n        _state: &SessionState,\n        _processor: &domain::Processor,\n        _payment_data: &mut D,\n    ) -> CustomResult<bool, errors::ApiErrorResponse> {\n        Ok(false)\n    }\n}\n\n/// Validate if a particular operation can be performed for the given intent status\npub trait ValidateStatusForOperation {\n    fn validate_status_for_operation(\n        &self,\n        intent_status: common_enums::IntentStatus,\n    ) -> Result<(), errors::ApiErrorResponse>;\n}\n\n/// Should the connector be called for this operation\npub trait ShouldCallConnector {\n    fn should_call_connector(\n        &self,\n        intent_status: common_enums::IntentStatus,\n        force_sync: Option<bool>,\n    ) -> bool;\n}\n", "function_name": "crates__router__src__core__payments__operations.rs", "file": "crates__router__src__core__payments__operations.rs"}, {"query": "how to process refund sync in UCS", "code": "use std::{borrow::Cow, str::FromStr, time::Instant};\n\nuse api_models::admin;\n#[cfg(feature = \"v2\")]\nuse base64::Engine;\nuse common_enums::{\n    connector_enums::Connector, AttemptStatus, CallConnectorAction, ConnectorIntegrationType,\n    ExecutionMode, ExecutionPath, GatewaySystem, PaymentMethodType, UcsAvailability,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::consts::BASE64_ENGINE;\nuse common_utils::{\n    consts::{X_CONNECTOR_NAME, X_FLOW_NAME, X_SUB_FLOW_NAME},\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    id_type,\n    request::{Method, RequestBuilder, RequestContent},\n    ucs_types,\n};\nuse diesel_models::types::FeatureMetadata;\nuse error_stack::ResultExt;\nuse external_services::{\n    grpc_client::{\n        unified_connector_service::{ConnectorAuthMetadata, UnifiedConnectorServiceError},\n        LineageIds,\n    },\n    http_client,\n};\nuse hyperswitch_connectors::utils::CardData;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::merchant_connector_account::{\n    ExternalVaultConnectorMetadata, MerchantConnectorAccountTypeDetails,\n};\nuse hyperswitch_domain_models::{\n    platform::Processor,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds,\n    router_request_types::RefundsData,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse unified_connector_service_cards::CardNumber;\nuse unified_connector_service_client::payments::{\n    self as payments_grpc, payment_method::PaymentMethod, CardDetails, ClassicReward,\n    CryptoCurrency, EVoucher, OpenBanking, PaymentServiceAuthorizeResponse,\n};\n\n#[cfg(feature = \"v2\")]\nuse crate::types::api::enums as api_enums;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, RouterResult},\n        payments::{\n            helpers::{\n                is_ucs_enabled, should_execute_based_on_rollout, MerchantConnectorAccountType,\n                Pro\n\n... [truncated 105608 chars] ...\n\nnector_auth_metadata, grpc_headers)\n                .await\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"UCS refund sync execution failed\")?;\n\n            let grpc_response = response.into_inner();\n\n            // Transform UCS response back to RouterData\n            let (refund_response_data, status_code) =\n                handle_unified_connector_service_response_for_refund_sync(grpc_response.clone())\n                    .change_context(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"Failed to transform UCS refund sync response\")?;\n\n            let mut updated_router_data = router_data;\n            updated_router_data.response = refund_response_data;\n            updated_router_data.connector_http_status_code = Some(status_code);\n\n            Ok((updated_router_data, (), grpc_response))\n        },\n    ))\n    .await\n    .map(|(router_data, _flow_response)| router_data)\n}\n", "function_name": "crates__router__src__core__unified_connector_service.rs", "file": "crates__router__src__core__unified_connector_service.rs"}, {"query": "Unified Connector Service refund implementation", "code": "use std::{borrow::Cow, str::FromStr, time::Instant};\n\nuse api_models::admin;\n#[cfg(feature = \"v2\")]\nuse base64::Engine;\nuse common_enums::{\n    connector_enums::Connector, AttemptStatus, CallConnectorAction, ConnectorIntegrationType,\n    ExecutionMode, ExecutionPath, GatewaySystem, PaymentMethodType, UcsAvailability,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::consts::BASE64_ENGINE;\nuse common_utils::{\n    consts::{X_CONNECTOR_NAME, X_FLOW_NAME, X_SUB_FLOW_NAME},\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    id_type,\n    request::{Method, RequestBuilder, RequestContent},\n    ucs_types,\n};\nuse diesel_models::types::FeatureMetadata;\nuse error_stack::ResultExt;\nuse external_services::{\n    grpc_client::{\n        unified_connector_service::{ConnectorAuthMetadata, UnifiedConnectorServiceError},\n        LineageIds,\n    },\n    http_client,\n};\nuse hyperswitch_connectors::utils::CardData;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::merchant_connector_account::{\n    ExternalVaultConnectorMetadata, MerchantConnectorAccountTypeDetails,\n};\nuse hyperswitch_domain_models::{\n    platform::Processor,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds,\n    router_request_types::RefundsData,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse unified_connector_service_cards::CardNumber;\nuse unified_connector_service_client::payments::{\n    self as payments_grpc, payment_method::PaymentMethod, CardDetails, ClassicReward,\n    CryptoCurrency, EVoucher, OpenBanking, PaymentServiceAuthorizeResponse,\n};\n\n#[cfg(feature = \"v2\")]\nuse crate::types::api::enums as api_enums;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, RouterResult},\n        payments::{\n            helpers::{\n                is_ucs_enabled, should_execute_based_on_rollout, MerchantConnectorAccountType,\n                Pro\n\n... [truncated 105608 chars] ...\n\nnector_auth_metadata, grpc_headers)\n                .await\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"UCS refund sync execution failed\")?;\n\n            let grpc_response = response.into_inner();\n\n            // Transform UCS response back to RouterData\n            let (refund_response_data, status_code) =\n                handle_unified_connector_service_response_for_refund_sync(grpc_response.clone())\n                    .change_context(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"Failed to transform UCS refund sync response\")?;\n\n            let mut updated_router_data = router_data;\n            updated_router_data.response = refund_response_data;\n            updated_router_data.connector_http_status_code = Some(status_code);\n\n            Ok((updated_router_data, (), grpc_response))\n        },\n    ))\n    .await\n    .map(|(router_data, _flow_response)| router_data)\n}\n", "function_name": "crates__router__src__core__unified_connector_service.rs", "file": "crates__router__src__core__unified_connector_service.rs"}, {"query": "process_refund_sync function", "code": "use std::{borrow::Cow, str::FromStr, time::Instant};\n\nuse api_models::admin;\n#[cfg(feature = \"v2\")]\nuse base64::Engine;\nuse common_enums::{\n    connector_enums::Connector, AttemptStatus, CallConnectorAction, ConnectorIntegrationType,\n    ExecutionMode, ExecutionPath, GatewaySystem, PaymentMethodType, UcsAvailability,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::consts::BASE64_ENGINE;\nuse common_utils::{\n    consts::{X_CONNECTOR_NAME, X_FLOW_NAME, X_SUB_FLOW_NAME},\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    id_type,\n    request::{Method, RequestBuilder, RequestContent},\n    ucs_types,\n};\nuse diesel_models::types::FeatureMetadata;\nuse error_stack::ResultExt;\nuse external_services::{\n    grpc_client::{\n        unified_connector_service::{ConnectorAuthMetadata, UnifiedConnectorServiceError},\n        LineageIds,\n    },\n    http_client,\n};\nuse hyperswitch_connectors::utils::CardData;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::merchant_connector_account::{\n    ExternalVaultConnectorMetadata, MerchantConnectorAccountTypeDetails,\n};\nuse hyperswitch_domain_models::{\n    platform::Processor,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds,\n    router_request_types::RefundsData,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse unified_connector_service_cards::CardNumber;\nuse unified_connector_service_client::payments::{\n    self as payments_grpc, payment_method::PaymentMethod, CardDetails, ClassicReward,\n    CryptoCurrency, EVoucher, OpenBanking, PaymentServiceAuthorizeResponse,\n};\n\n#[cfg(feature = \"v2\")]\nuse crate::types::api::enums as api_enums;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, RouterResult},\n        payments::{\n            helpers::{\n                is_ucs_enabled, should_execute_based_on_rollout, MerchantConnectorAccountType,\n                Pro\n\n... [truncated 105608 chars] ...\n\nnector_auth_metadata, grpc_headers)\n                .await\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"UCS refund sync execution failed\")?;\n\n            let grpc_response = response.into_inner();\n\n            // Transform UCS response back to RouterData\n            let (refund_response_data, status_code) =\n                handle_unified_connector_service_response_for_refund_sync(grpc_response.clone())\n                    .change_context(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"Failed to transform UCS refund sync response\")?;\n\n            let mut updated_router_data = router_data;\n            updated_router_data.response = refund_response_data;\n            updated_router_data.connector_http_status_code = Some(status_code);\n\n            Ok((updated_router_data, (), grpc_response))\n        },\n    ))\n    .await\n    .map(|(router_data, _flow_response)| router_data)\n}\n", "function_name": "crates__router__src__core__unified_connector_service.rs", "file": "crates__router__src__core__unified_connector_service.rs"}, {"query": "UCS refund request handling", "code": "use std::{borrow::Cow, str::FromStr, time::Instant};\n\nuse api_models::admin;\n#[cfg(feature = \"v2\")]\nuse base64::Engine;\nuse common_enums::{\n    connector_enums::Connector, AttemptStatus, CallConnectorAction, ConnectorIntegrationType,\n    ExecutionMode, ExecutionPath, GatewaySystem, PaymentMethodType, UcsAvailability,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::consts::BASE64_ENGINE;\nuse common_utils::{\n    consts::{X_CONNECTOR_NAME, X_FLOW_NAME, X_SUB_FLOW_NAME},\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    id_type,\n    request::{Method, RequestBuilder, RequestContent},\n    ucs_types,\n};\nuse diesel_models::types::FeatureMetadata;\nuse error_stack::ResultExt;\nuse external_services::{\n    grpc_client::{\n        unified_connector_service::{ConnectorAuthMetadata, UnifiedConnectorServiceError},\n        LineageIds,\n    },\n    http_client,\n};\nuse hyperswitch_connectors::utils::CardData;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::merchant_connector_account::{\n    ExternalVaultConnectorMetadata, MerchantConnectorAccountTypeDetails,\n};\nuse hyperswitch_domain_models::{\n    platform::Processor,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds,\n    router_request_types::RefundsData,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse unified_connector_service_cards::CardNumber;\nuse unified_connector_service_client::payments::{\n    self as payments_grpc, payment_method::PaymentMethod, CardDetails, ClassicReward,\n    CryptoCurrency, EVoucher, OpenBanking, PaymentServiceAuthorizeResponse,\n};\n\n#[cfg(feature = \"v2\")]\nuse crate::types::api::enums as api_enums;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, RouterResult},\n        payments::{\n            helpers::{\n                is_ucs_enabled, should_execute_based_on_rollout, MerchantConnectorAccountType,\n                Pro\n\n... [truncated 105608 chars] ...\n\nnector_auth_metadata, grpc_headers)\n                .await\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"UCS refund sync execution failed\")?;\n\n            let grpc_response = response.into_inner();\n\n            // Transform UCS response back to RouterData\n            let (refund_response_data, status_code) =\n                handle_unified_connector_service_response_for_refund_sync(grpc_response.clone())\n                    .change_context(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"Failed to transform UCS refund sync response\")?;\n\n            let mut updated_router_data = router_data;\n            updated_router_data.response = refund_response_data;\n            updated_router_data.connector_http_status_code = Some(status_code);\n\n            Ok((updated_router_data, (), grpc_response))\n        },\n    ))\n    .await\n    .map(|(router_data, _flow_response)| router_data)\n}\n", "function_name": "crates__router__src__core__unified_connector_service.rs", "file": "crates__router__src__core__unified_connector_service.rs"}, {"query": "hyperswitch trustpay connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsPreProcessingType,\n\n... [truncated 57097 chars] ...\n\n  ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TRUSTPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TRUSTPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TRUSTPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        _payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        // The length of receipt for Trustpay order request should not exceed 35 characters.\n        uuid::Uuid::now_v7().simple().to_string()\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpay.rs"}, {"query": "Trustpay payment integration rust", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsPreProcessingType,\n\n... [truncated 57097 chars] ...\n\n  ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TRUSTPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TRUSTPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TRUSTPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        _payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        // The length of receipt for Trustpay order request should not exceed 35 characters.\n        uuid::Uuid::now_v7().simple().to_string()\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpay.rs"}, {"query": "how to configure trustpay connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsPreProcessingType,\n\n... [truncated 57097 chars] ...\n\n  ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TRUSTPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TRUSTPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TRUSTPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        _payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        // The length of receipt for Trustpay order request should not exceed 35 characters.\n        uuid::Uuid::now_v7().simple().to_string()\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpay.rs"}, {"query": "trustpay authorize capture flow", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsPreProcessingType,\n\n... [truncated 57097 chars] ...\n\n  ),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TRUSTPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TRUSTPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TRUSTPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        _payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        // The length of receipt for Trustpay order request should not exceed 35 characters.\n        uuid::Uuid::now_v7().simple().to_string()\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpay.rs"}, {"query": "Finix payment connector implementation", "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, ConnectorIntegrationStatus, PaymentMethodType};\nuse common_utils::{\n    crypto::{HmacSha256, VerifySignature},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse\n\n... [truncated 40947 chars] ...\n\nnt_type()\n    }\n    fn get_dispute_details(\n        &self,\n        request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<DisputePayload, errors::ConnectorError> {\n        let webhook_body: finix::FinixWebhookBody =\n            request\n                .body\n                .parse_struct(\"FinixWebhookBody\")\n                .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n        webhook_body.get_dispute_details()\n    }\n    fn get_webhook_resource_object(\n        &self,\n        request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        let webhook_body: finix::FinixWebhookBody =\n            request\n                .body\n                .parse_struct(\"FinixWebhookBody\")\n                .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body))\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__finix.rs", "file": "crates__hyperswitch_connectors__src__connectors__finix.rs"}, {"query": "hyperswitch finix webhook signature verification", "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, ConnectorIntegrationStatus, PaymentMethodType};\nuse common_utils::{\n    crypto::{HmacSha256, VerifySignature},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse\n\n... [truncated 40947 chars] ...\n\nnt_type()\n    }\n    fn get_dispute_details(\n        &self,\n        request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<DisputePayload, errors::ConnectorError> {\n        let webhook_body: finix::FinixWebhookBody =\n            request\n                .body\n                .parse_struct(\"FinixWebhookBody\")\n                .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n        webhook_body.get_dispute_details()\n    }\n    fn get_webhook_resource_object(\n        &self,\n        request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        let webhook_body: finix::FinixWebhookBody =\n            request\n                .body\n                .parse_struct(\"FinixWebhookBody\")\n                .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body))\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__finix.rs", "file": "crates__hyperswitch_connectors__src__connectors__finix.rs"}, {"query": "how to configure finix connector hyperswitch", "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, ConnectorIntegrationStatus, PaymentMethodType};\nuse common_utils::{\n    crypto::{HmacSha256, VerifySignature},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse\n\n... [truncated 40947 chars] ...\n\nnt_type()\n    }\n    fn get_dispute_details(\n        &self,\n        request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<DisputePayload, errors::ConnectorError> {\n        let webhook_body: finix::FinixWebhookBody =\n            request\n                .body\n                .parse_struct(\"FinixWebhookBody\")\n                .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n        webhook_body.get_dispute_details()\n    }\n    fn get_webhook_resource_object(\n        &self,\n        request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        let webhook_body: finix::FinixWebhookBody =\n            request\n                .body\n                .parse_struct(\"FinixWebhookBody\")\n                .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body))\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__finix.rs", "file": "crates__hyperswitch_connectors__src__connectors__finix.rs"}, {"query": "finix payment method types hyperswitch", "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, ConnectorIntegrationStatus, PaymentMethodType};\nuse common_utils::{\n    crypto::{HmacSha256, VerifySignature},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse\n\n... [truncated 40947 chars] ...\n\nnt_type()\n    }\n    fn get_dispute_details(\n        &self,\n        request: &webhooks::IncomingWebhookRequestDetails<'_>,\n        _context: Option<&webhooks::WebhookContext>,\n    ) -> CustomResult<DisputePayload, errors::ConnectorError> {\n        let webhook_body: finix::FinixWebhookBody =\n            request\n                .body\n                .parse_struct(\"FinixWebhookBody\")\n                .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n        webhook_body.get_dispute_details()\n    }\n    fn get_webhook_resource_object(\n        &self,\n        request: &webhooks::IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        let webhook_body: finix::FinixWebhookBody =\n            request\n                .body\n                .parse_struct(\"FinixWebhookBody\")\n                .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body))\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__finix.rs", "file": "crates__hyperswitch_connectors__src__connectors__finix.rs"}, {"query": "Facilitapay payment connector implementation", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse requests::{\n    FacilitapayAuthRequest, FacilitapayCustomerRequest, FacilitapayPaymentsRequest,\n    FacilitapayRouterData,\n};\nuse responses::{\n    FacilitapayAuthResponse, FacilitapayCustomerResponse, Fac\n\n... [truncated 30864 chars] ...\n\n                supported_capture_methods: facilitapay_supported_capture_methods.clone(),\n                specific_features: None,\n            },\n        );\n\n        facilitapay_supported_payment_methods\n    };\n    static ref FACILITAPAY_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = vec![\n        enums::EventClass::Payments,\n    ];\n}\n\nimpl ConnectorSpecifications for Facilitapay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*FACILITAPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FACILITAPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*FACILITAPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__facilitapay.rs", "file": "crates__hyperswitch_connectors__src__connectors__facilitapay.rs"}, {"query": "hyperswitch Facilitapay struct", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse requests::{\n    FacilitapayAuthRequest, FacilitapayCustomerRequest, FacilitapayPaymentsRequest,\n    FacilitapayRouterData,\n};\nuse responses::{\n    FacilitapayAuthResponse, FacilitapayCustomerResponse, Fac\n\n... [truncated 30864 chars] ...\n\n                supported_capture_methods: facilitapay_supported_capture_methods.clone(),\n                specific_features: None,\n            },\n        );\n\n        facilitapay_supported_payment_methods\n    };\n    static ref FACILITAPAY_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = vec![\n        enums::EventClass::Payments,\n    ];\n}\n\nimpl ConnectorSpecifications for Facilitapay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*FACILITAPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FACILITAPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*FACILITAPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__facilitapay.rs", "file": "crates__hyperswitch_connectors__src__connectors__facilitapay.rs"}, {"query": "how to add new payment method to hyperswitch", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse requests::{\n    FacilitapayAuthRequest, FacilitapayCustomerRequest, FacilitapayPaymentsRequest,\n    FacilitapayRouterData,\n};\nuse responses::{\n    FacilitapayAuthResponse, FacilitapayCustomerResponse, Fac\n\n... [truncated 30864 chars] ...\n\n                supported_capture_methods: facilitapay_supported_capture_methods.clone(),\n                specific_features: None,\n            },\n        );\n\n        facilitapay_supported_payment_methods\n    };\n    static ref FACILITAPAY_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = vec![\n        enums::EventClass::Payments,\n    ];\n}\n\nimpl ConnectorSpecifications for Facilitapay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*FACILITAPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FACILITAPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*FACILITAPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__facilitapay.rs", "file": "crates__hyperswitch_connectors__src__connectors__facilitapay.rs"}, {"query": "Facilitapay webhook handling rust", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse requests::{\n    FacilitapayAuthRequest, FacilitapayCustomerRequest, FacilitapayPaymentsRequest,\n    FacilitapayRouterData,\n};\nuse responses::{\n    FacilitapayAuthResponse, FacilitapayCustomerResponse, Fac\n\n... [truncated 30864 chars] ...\n\n                supported_capture_methods: facilitapay_supported_capture_methods.clone(),\n                specific_features: None,\n            },\n        );\n\n        facilitapay_supported_payment_methods\n    };\n    static ref FACILITAPAY_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = vec![\n        enums::EventClass::Payments,\n    ];\n}\n\nimpl ConnectorSpecifications for Facilitapay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*FACILITAPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FACILITAPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*FACILITAPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__facilitapay.rs", "file": "crates__hyperswitch_connectors__src__connectors__facilitapay.rs"}, {"query": "Wise connector authentication implementation", "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<\n\n... [truncated 22832 chars] ...\n\nWiseSyncStatus::IncomingPaymentInitiated => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutProcessing\n        }\n        WiseSyncStatus::Processing => api_models::webhooks::IncomingWebhookEvent::PayoutProcessing,\n        WiseSyncStatus::FundsConverted => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutProcessing\n        }\n        WiseSyncStatus::OutgoingPaymentSent => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutSuccess\n        }\n        WiseSyncStatus::Cancelled => api_models::webhooks::IncomingWebhookEvent::PayoutCancelled,\n        WiseSyncStatus::FundsRefunded => api_models::webhooks::IncomingWebhookEvent::PayoutReversed,\n        WiseSyncStatus::BouncedBack => api_models::webhooks::IncomingWebhookEvent::PayoutProcessing,\n        WiseSyncStatus::ChargedBack => api_models::webhooks::IncomingWebhookEvent::PayoutReversed,\n        WiseSyncStatus::Unknown => api_models::webhooks::IncomingWebhookEvent::EventNotSupported,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs"}, {"query": "Wise webhook event mapping", "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<\n\n... [truncated 22832 chars] ...\n\nWiseSyncStatus::IncomingPaymentInitiated => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutProcessing\n        }\n        WiseSyncStatus::Processing => api_models::webhooks::IncomingWebhookEvent::PayoutProcessing,\n        WiseSyncStatus::FundsConverted => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutProcessing\n        }\n        WiseSyncStatus::OutgoingPaymentSent => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutSuccess\n        }\n        WiseSyncStatus::Cancelled => api_models::webhooks::IncomingWebhookEvent::PayoutCancelled,\n        WiseSyncStatus::FundsRefunded => api_models::webhooks::IncomingWebhookEvent::PayoutReversed,\n        WiseSyncStatus::BouncedBack => api_models::webhooks::IncomingWebhookEvent::PayoutProcessing,\n        WiseSyncStatus::ChargedBack => api_models::webhooks::IncomingWebhookEvent::PayoutReversed,\n        WiseSyncStatus::Unknown => api_models::webhooks::IncomingWebhookEvent::EventNotSupported,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs"}, {"query": "how to transform Wise payout data", "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<\n\n... [truncated 22832 chars] ...\n\nWiseSyncStatus::IncomingPaymentInitiated => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutProcessing\n        }\n        WiseSyncStatus::Processing => api_models::webhooks::IncomingWebhookEvent::PayoutProcessing,\n        WiseSyncStatus::FundsConverted => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutProcessing\n        }\n        WiseSyncStatus::OutgoingPaymentSent => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutSuccess\n        }\n        WiseSyncStatus::Cancelled => api_models::webhooks::IncomingWebhookEvent::PayoutCancelled,\n        WiseSyncStatus::FundsRefunded => api_models::webhooks::IncomingWebhookEvent::PayoutReversed,\n        WiseSyncStatus::BouncedBack => api_models::webhooks::IncomingWebhookEvent::PayoutProcessing,\n        WiseSyncStatus::ChargedBack => api_models::webhooks::IncomingWebhookEvent::PayoutReversed,\n        WiseSyncStatus::Unknown => api_models::webhooks::IncomingWebhookEvent::EventNotSupported,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs"}, {"query": "WiseAuthType struct definition", "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<\n\n... [truncated 22832 chars] ...\n\nWiseSyncStatus::IncomingPaymentInitiated => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutProcessing\n        }\n        WiseSyncStatus::Processing => api_models::webhooks::IncomingWebhookEvent::PayoutProcessing,\n        WiseSyncStatus::FundsConverted => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutProcessing\n        }\n        WiseSyncStatus::OutgoingPaymentSent => {\n            api_models::webhooks::IncomingWebhookEvent::PayoutSuccess\n        }\n        WiseSyncStatus::Cancelled => api_models::webhooks::IncomingWebhookEvent::PayoutCancelled,\n        WiseSyncStatus::FundsRefunded => api_models::webhooks::IncomingWebhookEvent::PayoutReversed,\n        WiseSyncStatus::BouncedBack => api_models::webhooks::IncomingWebhookEvent::PayoutProcessing,\n        WiseSyncStatus::ChargedBack => api_models::webhooks::IncomingWebhookEvent::PayoutReversed,\n        WiseSyncStatus::Unknown => api_models::webhooks::IncomingWebhookEvent::EventNotSupported,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs"}, {"query": "payment method creation struct", "code": "use std::collections::{HashMap, HashSet};\n#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse cards::CardNumber;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableName;\nuse common_utils::{\n    consts::SURCHARGE_PERCENTAGE_PRECISION_LENGTH,\n    errors,\n    ext_traits::OptionExt,\n    id_type, link_utils, pii,\n    types::{MinorUnit, Percentage, Surcharge},\n};\nuse masking::PeekInterface;\nuse serde::de;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::BankCodeResponse;\n#[cfg(feature = \"payouts\")]\nuse crate::payouts;\nuse crate::{admin, enums as api_enums, open_router, payments};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodCreate {\n    /// The type of payment method use for the payment.\n    #[schema(value_type = PaymentMethod,example = \"card\")]\n    pub payment_method: Option<api_enums::PaymentMethod>,\n\n    /// This is a sub-category of payment method.\n    #[schema(value_type = Option<PaymentMethodType>,example = \"credit\")]\n    pub payment_method_type: Option<api_enums::PaymentMethodType>,\n\n    /// The name of the bank/ provider issuing the payment method to the end user\n    #[schema(example = \"Citibank\")]\n    pub payment_method_issuer: Option<String>,\n\n    /// A standard code representing the issuer of payment method\n    #[schema(value_type = Option<PaymentMethodIssuerCode>,example = \"jp_applepay\")]\n    pub payment_method_issuer_code: Option<api_enums::PaymentMethodIssuerCode>,\n\n    /// Card Details\n    #[schema(example = json!({\n    \"card_number\": \"4111111145551142\",\n    \"card_exp_month\": \"10\",\n    \"card_exp_year\": \"25\",\n    \"card_holder_name\": \"John Doe\"}))]\n    pub card: Option<CardDetail>,\n\n    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.\n    #[schema(value_type = Option<Object>,example = json!(\n\n... [truncated 144895 chars] ...\n\n,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\npub struct GetNetworkTokenEiligibilityResponse {\n    /// Indicates if the card bin is eligible for network tokenization for the particular merchant\n    pub eligible_for_network_tokenization: bool,\n}\n\n#[cfg(feature = \"v2\")]\nimpl common_utils::events::ApiEventMetric for NetworkTokenEligibilityRequest {}\n\n#[cfg(feature = \"v2\")]\nimpl common_utils::events::ApiEventMetric for GetNetworkTokenEiligibilityResponse {}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Serialize, ToSchema)]\npub struct PaymentMethodGetTokenDetailsResponse {\n    /// The payment method ID associated with the token\n    #[schema(value_type = String, example = \"12345_pm_019959146f92737389eb6927ce1eb7dc\")]\n    pub id: id_type::GlobalPaymentMethodId,\n\n    /// The token associated with the payment method\n    #[schema(value_type = String, example = \"token_CSum555d9YxDOpGwYq6q\")]\n    pub payment_method_token: String,\n}\n", "function_name": "crates__api_models__src__payment_methods.rs", "file": "crates__api_models__src__payment_methods.rs"}, {"query": "how to update payment method details", "code": "use std::collections::{HashMap, HashSet};\n#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse cards::CardNumber;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableName;\nuse common_utils::{\n    consts::SURCHARGE_PERCENTAGE_PRECISION_LENGTH,\n    errors,\n    ext_traits::OptionExt,\n    id_type, link_utils, pii,\n    types::{MinorUnit, Percentage, Surcharge},\n};\nuse masking::PeekInterface;\nuse serde::de;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::BankCodeResponse;\n#[cfg(feature = \"payouts\")]\nuse crate::payouts;\nuse crate::{admin, enums as api_enums, open_router, payments};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodCreate {\n    /// The type of payment method use for the payment.\n    #[schema(value_type = PaymentMethod,example = \"card\")]\n    pub payment_method: Option<api_enums::PaymentMethod>,\n\n    /// This is a sub-category of payment method.\n    #[schema(value_type = Option<PaymentMethodType>,example = \"credit\")]\n    pub payment_method_type: Option<api_enums::PaymentMethodType>,\n\n    /// The name of the bank/ provider issuing the payment method to the end user\n    #[schema(example = \"Citibank\")]\n    pub payment_method_issuer: Option<String>,\n\n    /// A standard code representing the issuer of payment method\n    #[schema(value_type = Option<PaymentMethodIssuerCode>,example = \"jp_applepay\")]\n    pub payment_method_issuer_code: Option<api_enums::PaymentMethodIssuerCode>,\n\n    /// Card Details\n    #[schema(example = json!({\n    \"card_number\": \"4111111145551142\",\n    \"card_exp_month\": \"10\",\n    \"card_exp_year\": \"25\",\n    \"card_holder_name\": \"John Doe\"}))]\n    pub card: Option<CardDetail>,\n\n    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.\n    #[schema(value_type = Option<Object>,example = json!(\n\n... [truncated 144895 chars] ...\n\n,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\npub struct GetNetworkTokenEiligibilityResponse {\n    /// Indicates if the card bin is eligible for network tokenization for the particular merchant\n    pub eligible_for_network_tokenization: bool,\n}\n\n#[cfg(feature = \"v2\")]\nimpl common_utils::events::ApiEventMetric for NetworkTokenEligibilityRequest {}\n\n#[cfg(feature = \"v2\")]\nimpl common_utils::events::ApiEventMetric for GetNetworkTokenEiligibilityResponse {}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Serialize, ToSchema)]\npub struct PaymentMethodGetTokenDetailsResponse {\n    /// The payment method ID associated with the token\n    #[schema(value_type = String, example = \"12345_pm_019959146f92737389eb6927ce1eb7dc\")]\n    pub id: id_type::GlobalPaymentMethodId,\n\n    /// The token associated with the payment method\n    #[schema(value_type = String, example = \"token_CSum555d9YxDOpGwYq6q\")]\n    pub payment_method_token: String,\n}\n", "function_name": "crates__api_models__src__payment_methods.rs", "file": "crates__api_models__src__payment_methods.rs"}, {"query": "network tokenization eligibility check", "code": "use std::collections::{HashMap, HashSet};\n#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse cards::CardNumber;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableName;\nuse common_utils::{\n    consts::SURCHARGE_PERCENTAGE_PRECISION_LENGTH,\n    errors,\n    ext_traits::OptionExt,\n    id_type, link_utils, pii,\n    types::{MinorUnit, Percentage, Surcharge},\n};\nuse masking::PeekInterface;\nuse serde::de;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::BankCodeResponse;\n#[cfg(feature = \"payouts\")]\nuse crate::payouts;\nuse crate::{admin, enums as api_enums, open_router, payments};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodCreate {\n    /// The type of payment method use for the payment.\n    #[schema(value_type = PaymentMethod,example = \"card\")]\n    pub payment_method: Option<api_enums::PaymentMethod>,\n\n    /// This is a sub-category of payment method.\n    #[schema(value_type = Option<PaymentMethodType>,example = \"credit\")]\n    pub payment_method_type: Option<api_enums::PaymentMethodType>,\n\n    /// The name of the bank/ provider issuing the payment method to the end user\n    #[schema(example = \"Citibank\")]\n    pub payment_method_issuer: Option<String>,\n\n    /// A standard code representing the issuer of payment method\n    #[schema(value_type = Option<PaymentMethodIssuerCode>,example = \"jp_applepay\")]\n    pub payment_method_issuer_code: Option<api_enums::PaymentMethodIssuerCode>,\n\n    /// Card Details\n    #[schema(example = json!({\n    \"card_number\": \"4111111145551142\",\n    \"card_exp_month\": \"10\",\n    \"card_exp_year\": \"25\",\n    \"card_holder_name\": \"John Doe\"}))]\n    pub card: Option<CardDetail>,\n\n    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.\n    #[schema(value_type = Option<Object>,example = json!(\n\n... [truncated 144895 chars] ...\n\n,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\npub struct GetNetworkTokenEiligibilityResponse {\n    /// Indicates if the card bin is eligible for network tokenization for the particular merchant\n    pub eligible_for_network_tokenization: bool,\n}\n\n#[cfg(feature = \"v2\")]\nimpl common_utils::events::ApiEventMetric for NetworkTokenEligibilityRequest {}\n\n#[cfg(feature = \"v2\")]\nimpl common_utils::events::ApiEventMetric for GetNetworkTokenEiligibilityResponse {}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Serialize, ToSchema)]\npub struct PaymentMethodGetTokenDetailsResponse {\n    /// The payment method ID associated with the token\n    #[schema(value_type = String, example = \"12345_pm_019959146f92737389eb6927ce1eb7dc\")]\n    pub id: id_type::GlobalPaymentMethodId,\n\n    /// The token associated with the payment method\n    #[schema(value_type = String, example = \"token_CSum555d9YxDOpGwYq6q\")]\n    pub payment_method_token: String,\n}\n", "function_name": "crates__api_models__src__payment_methods.rs", "file": "crates__api_models__src__payment_methods.rs"}, {"query": "payment method data structures", "code": "use std::collections::{HashMap, HashSet};\n#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse cards::CardNumber;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableName;\nuse common_utils::{\n    consts::SURCHARGE_PERCENTAGE_PRECISION_LENGTH,\n    errors,\n    ext_traits::OptionExt,\n    id_type, link_utils, pii,\n    types::{MinorUnit, Percentage, Surcharge},\n};\nuse masking::PeekInterface;\nuse serde::de;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::BankCodeResponse;\n#[cfg(feature = \"payouts\")]\nuse crate::payouts;\nuse crate::{admin, enums as api_enums, open_router, payments};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodCreate {\n    /// The type of payment method use for the payment.\n    #[schema(value_type = PaymentMethod,example = \"card\")]\n    pub payment_method: Option<api_enums::PaymentMethod>,\n\n    /// This is a sub-category of payment method.\n    #[schema(value_type = Option<PaymentMethodType>,example = \"credit\")]\n    pub payment_method_type: Option<api_enums::PaymentMethodType>,\n\n    /// The name of the bank/ provider issuing the payment method to the end user\n    #[schema(example = \"Citibank\")]\n    pub payment_method_issuer: Option<String>,\n\n    /// A standard code representing the issuer of payment method\n    #[schema(value_type = Option<PaymentMethodIssuerCode>,example = \"jp_applepay\")]\n    pub payment_method_issuer_code: Option<api_enums::PaymentMethodIssuerCode>,\n\n    /// Card Details\n    #[schema(example = json!({\n    \"card_number\": \"4111111145551142\",\n    \"card_exp_month\": \"10\",\n    \"card_exp_year\": \"25\",\n    \"card_holder_name\": \"John Doe\"}))]\n    pub card: Option<CardDetail>,\n\n    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.\n    #[schema(value_type = Option<Object>,example = json!(\n\n... [truncated 144895 chars] ...\n\n,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\npub struct GetNetworkTokenEiligibilityResponse {\n    /// Indicates if the card bin is eligible for network tokenization for the particular merchant\n    pub eligible_for_network_tokenization: bool,\n}\n\n#[cfg(feature = \"v2\")]\nimpl common_utils::events::ApiEventMetric for NetworkTokenEligibilityRequest {}\n\n#[cfg(feature = \"v2\")]\nimpl common_utils::events::ApiEventMetric for GetNetworkTokenEiligibilityResponse {}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Serialize, ToSchema)]\npub struct PaymentMethodGetTokenDetailsResponse {\n    /// The payment method ID associated with the token\n    #[schema(value_type = String, example = \"12345_pm_019959146f92737389eb6927ce1eb7dc\")]\n    pub id: id_type::GlobalPaymentMethodId,\n\n    /// The token associated with the payment method\n    #[schema(value_type = String, example = \"token_CSum555d9YxDOpGwYq6q\")]\n    pub payment_method_token: String,\n}\n", "function_name": "crates__api_models__src__payment_methods.rs", "file": "crates__api_models__src__payment_methods.rs"}, {"query": "how to implement Boku payment integration", "code": "use std::fmt;\n\nuse common_enums::enums;\nuse common_utils::{request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, AddressDetailsData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct BokuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for BokuRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum BokuPaymentsRequest {\n    BeginSingleCharge(SingleChargeData),\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct SingleChargeData {\n    total_amount: MinorUnit,\n    currency: String,\n    country: String,\n    merchant_id: Secret<String>,\n    merchant_transaction_id: Secret<String>,\n    merchant_request_id: String,\n    merchant_item_description: String,\n    notification_url: Option<String>,\n    payment_method: String,\n    charge_type: String,\n    hosted: Option<BokuHostedData>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuPaymentType {\n    Dana,\n    Momo,\n    Gcash,\n    GoPay,\n    Kakaopay,\n}\n\nimpl fmt::Display for BokuPaymentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Dana => write!(f, \"Dana\"),\n            Self::Momo => write!(f, \"Momo\"),\n            Self::Gcash => write!(f, \"Gcash\"),\n            Se\n\n... [truncated 14351 chars] ...\n\n,\n}\n\nimpl TryFrom<RefundsResponseRouterData<RSync, BokuRsyncResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, BokuRsyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.refunds.refund.refund_id,\n                refund_status: get_refund_status(item.response.refunds.refund.refund_status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct BokuErrorResponse {\n    pub status_code: u16,\n    pub code: String,\n    pub message: String,\n    pub reason: Option<String>,\n}\n\nfn get_hosted_data(item: &types::PaymentsAuthorizeRouterData) -> Option<BokuHostedData> {\n    item.request\n        .router_return_url\n        .clone()\n        .map(|url| BokuHostedData { forward_url: url })\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs"}, {"query": "BokuPaymentsRequest struct", "code": "use std::fmt;\n\nuse common_enums::enums;\nuse common_utils::{request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, AddressDetailsData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct BokuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for BokuRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum BokuPaymentsRequest {\n    BeginSingleCharge(SingleChargeData),\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct SingleChargeData {\n    total_amount: MinorUnit,\n    currency: String,\n    country: String,\n    merchant_id: Secret<String>,\n    merchant_transaction_id: Secret<String>,\n    merchant_request_id: String,\n    merchant_item_description: String,\n    notification_url: Option<String>,\n    payment_method: String,\n    charge_type: String,\n    hosted: Option<BokuHostedData>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuPaymentType {\n    Dana,\n    Momo,\n    Gcash,\n    GoPay,\n    Kakaopay,\n}\n\nimpl fmt::Display for BokuPaymentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Dana => write!(f, \"Dana\"),\n            Self::Momo => write!(f, \"Momo\"),\n            Self::Gcash => write!(f, \"Gcash\"),\n            Se\n\n... [truncated 14351 chars] ...\n\n,\n}\n\nimpl TryFrom<RefundsResponseRouterData<RSync, BokuRsyncResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, BokuRsyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.refunds.refund.refund_id,\n                refund_status: get_refund_status(item.response.refunds.refund.refund_status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct BokuErrorResponse {\n    pub status_code: u16,\n    pub code: String,\n    pub message: String,\n    pub reason: Option<String>,\n}\n\nfn get_hosted_data(item: &types::PaymentsAuthorizeRouterData) -> Option<BokuHostedData> {\n    item.request\n        .router_return_url\n        .clone()\n        .map(|url| BokuHostedData { forward_url: url })\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs"}, {"query": "transform router data to Boku API", "code": "use std::fmt;\n\nuse common_enums::enums;\nuse common_utils::{request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, AddressDetailsData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct BokuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for BokuRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum BokuPaymentsRequest {\n    BeginSingleCharge(SingleChargeData),\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct SingleChargeData {\n    total_amount: MinorUnit,\n    currency: String,\n    country: String,\n    merchant_id: Secret<String>,\n    merchant_transaction_id: Secret<String>,\n    merchant_request_id: String,\n    merchant_item_description: String,\n    notification_url: Option<String>,\n    payment_method: String,\n    charge_type: String,\n    hosted: Option<BokuHostedData>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuPaymentType {\n    Dana,\n    Momo,\n    Gcash,\n    GoPay,\n    Kakaopay,\n}\n\nimpl fmt::Display for BokuPaymentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Dana => write!(f, \"Dana\"),\n            Self::Momo => write!(f, \"Momo\"),\n            Self::Gcash => write!(f, \"Gcash\"),\n            Se\n\n... [truncated 14351 chars] ...\n\n,\n}\n\nimpl TryFrom<RefundsResponseRouterData<RSync, BokuRsyncResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, BokuRsyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.refunds.refund.refund_id,\n                refund_status: get_refund_status(item.response.refunds.refund.refund_status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct BokuErrorResponse {\n    pub status_code: u16,\n    pub code: String,\n    pub message: String,\n    pub reason: Option<String>,\n}\n\nfn get_hosted_data(item: &types::PaymentsAuthorizeRouterData) -> Option<BokuHostedData> {\n    item.request\n        .router_return_url\n        .clone()\n        .map(|url| BokuHostedData { forward_url: url })\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs"}, {"query": "Boku refund response handling", "code": "use std::fmt;\n\nuse common_enums::enums;\nuse common_utils::{request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, AddressDetailsData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct BokuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for BokuRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum BokuPaymentsRequest {\n    BeginSingleCharge(SingleChargeData),\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct SingleChargeData {\n    total_amount: MinorUnit,\n    currency: String,\n    country: String,\n    merchant_id: Secret<String>,\n    merchant_transaction_id: Secret<String>,\n    merchant_request_id: String,\n    merchant_item_description: String,\n    notification_url: Option<String>,\n    payment_method: String,\n    charge_type: String,\n    hosted: Option<BokuHostedData>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuPaymentType {\n    Dana,\n    Momo,\n    Gcash,\n    GoPay,\n    Kakaopay,\n}\n\nimpl fmt::Display for BokuPaymentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Dana => write!(f, \"Dana\"),\n            Self::Momo => write!(f, \"Momo\"),\n            Self::Gcash => write!(f, \"Gcash\"),\n            Se\n\n... [truncated 14351 chars] ...\n\n,\n}\n\nimpl TryFrom<RefundsResponseRouterData<RSync, BokuRsyncResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, BokuRsyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.refunds.refund.refund_id,\n                refund_status: get_refund_status(item.response.refunds.refund.refund_status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct BokuErrorResponse {\n    pub status_code: u16,\n    pub code: String,\n    pub message: String,\n    pub reason: Option<String>,\n}\n\nfn get_hosted_data(item: &types::PaymentsAuthorizeRouterData) -> Option<BokuHostedData> {\n    item.request\n        .router_return_url\n        .clone()\n        .map(|url| BokuHostedData { forward_url: url })\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs"}, {"query": "how does payment gateway routing work", "code": "pub mod helpers;\npub mod transformers;\nuse std::collections::HashSet;\n\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing::DynamicRoutingAlgoAccessor;\nuse api_models::{\n    enums, mandates as mandates_api,\n    open_router::{\n        DecideGatewayResponse, OpenRouterDecideGatewayRequest, UpdateScorePayload,\n        UpdateScoreResponse,\n    },\n    routing,\n    routing::{\n        self as routing_types, RoutingRetrieveQuery, RuleMigrationError, RuleMigrationResponse,\n    },\n};\nuse async_trait::async_trait;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::AsyncExt;\nuse common_utils::request::Method;\nuse diesel_models::routing_algorithm::RoutingAlgorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse helpers::{\n    enable_decision_engine_dynamic_routing_setup, update_decision_engine_dynamic_routing_setup,\n};\nuse hyperswitch_domain_models::{mandates, payment_address};\nuse payment_methods::helpers::StorageErrorExt;\nuse rustc_hash::FxHashSet;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse storage_impl::redis::cache;\n\n#[cfg(feature = \"payouts\")]\nuse super::payouts;\nuse super::{\n    errors::RouterResult,\n    payments::{\n        routing::{\n            utils::*,\n            {self as payments_routing},\n        },\n        OperationSessionGetters, OperationSessionSetters,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::utils::ValueExt;\n#[cfg(feature = \"v2\")]\nuse crate::{core::admin, db::StorageInterface, utils::ValueExt};\nuse crate::{\n    core::{\n        errors::{self, CustomResult, RouterResponse},\n        metrics, utils as core_utils,\n    },\n    routes::SessionState,\n    services::api as service\n\n... [truncated 102428 chars] ...\n\nodels::api::ApplicationResponse::Json(\n        response,\n    ))\n}\n\npub async fn update_gateway_score_open_router(\n    state: SessionState,\n    req_body: UpdateScorePayload,\n) -> RouterResponse<UpdateScoreResponse> {\n    let response = if state.conf.open_router.dynamic_routing_enabled {\n        SRApiClient::send_decision_engine_request(\n            &state,\n            Method::Post,\n            \"update-gateway-score\",\n            Some(req_body),\n            None,\n            None,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)?\n        .response\n        .ok_or(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to perform update gateway score call with open router\")?\n    } else {\n        Err(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Dynamic routing is not enabled\")?\n    };\n\n    Ok(hyperswitch_domain_models::api::ApplicationResponse::Json(\n        response,\n    ))\n}\n", "function_name": "crates__router__src__core__routing.rs", "file": "crates__router__src__core__routing.rs"}, {"query": "decide_gateway_open_router function", "code": "pub mod helpers;\npub mod transformers;\nuse std::collections::HashSet;\n\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing::DynamicRoutingAlgoAccessor;\nuse api_models::{\n    enums, mandates as mandates_api,\n    open_router::{\n        DecideGatewayResponse, OpenRouterDecideGatewayRequest, UpdateScorePayload,\n        UpdateScoreResponse,\n    },\n    routing,\n    routing::{\n        self as routing_types, RoutingRetrieveQuery, RuleMigrationError, RuleMigrationResponse,\n    },\n};\nuse async_trait::async_trait;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::AsyncExt;\nuse common_utils::request::Method;\nuse diesel_models::routing_algorithm::RoutingAlgorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse helpers::{\n    enable_decision_engine_dynamic_routing_setup, update_decision_engine_dynamic_routing_setup,\n};\nuse hyperswitch_domain_models::{mandates, payment_address};\nuse payment_methods::helpers::StorageErrorExt;\nuse rustc_hash::FxHashSet;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse storage_impl::redis::cache;\n\n#[cfg(feature = \"payouts\")]\nuse super::payouts;\nuse super::{\n    errors::RouterResult,\n    payments::{\n        routing::{\n            utils::*,\n            {self as payments_routing},\n        },\n        OperationSessionGetters, OperationSessionSetters,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::utils::ValueExt;\n#[cfg(feature = \"v2\")]\nuse crate::{core::admin, db::StorageInterface, utils::ValueExt};\nuse crate::{\n    core::{\n        errors::{self, CustomResult, RouterResponse},\n        metrics, utils as core_utils,\n    },\n    routes::SessionState,\n    services::api as service\n\n... [truncated 102428 chars] ...\n\nodels::api::ApplicationResponse::Json(\n        response,\n    ))\n}\n\npub async fn update_gateway_score_open_router(\n    state: SessionState,\n    req_body: UpdateScorePayload,\n) -> RouterResponse<UpdateScoreResponse> {\n    let response = if state.conf.open_router.dynamic_routing_enabled {\n        SRApiClient::send_decision_engine_request(\n            &state,\n            Method::Post,\n            \"update-gateway-score\",\n            Some(req_body),\n            None,\n            None,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)?\n        .response\n        .ok_or(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to perform update gateway score call with open router\")?\n    } else {\n        Err(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Dynamic routing is not enabled\")?\n    };\n\n    Ok(hyperswitch_domain_models::api::ApplicationResponse::Json(\n        response,\n    ))\n}\n", "function_name": "crates__router__src__core__routing.rs", "file": "crates__router__src__core__routing.rs"}, {"query": "how to implement dynamic payment routing", "code": "pub mod helpers;\npub mod transformers;\nuse std::collections::HashSet;\n\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing::DynamicRoutingAlgoAccessor;\nuse api_models::{\n    enums, mandates as mandates_api,\n    open_router::{\n        DecideGatewayResponse, OpenRouterDecideGatewayRequest, UpdateScorePayload,\n        UpdateScoreResponse,\n    },\n    routing,\n    routing::{\n        self as routing_types, RoutingRetrieveQuery, RuleMigrationError, RuleMigrationResponse,\n    },\n};\nuse async_trait::async_trait;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::AsyncExt;\nuse common_utils::request::Method;\nuse diesel_models::routing_algorithm::RoutingAlgorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse helpers::{\n    enable_decision_engine_dynamic_routing_setup, update_decision_engine_dynamic_routing_setup,\n};\nuse hyperswitch_domain_models::{mandates, payment_address};\nuse payment_methods::helpers::StorageErrorExt;\nuse rustc_hash::FxHashSet;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse storage_impl::redis::cache;\n\n#[cfg(feature = \"payouts\")]\nuse super::payouts;\nuse super::{\n    errors::RouterResult,\n    payments::{\n        routing::{\n            utils::*,\n            {self as payments_routing},\n        },\n        OperationSessionGetters, OperationSessionSetters,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::utils::ValueExt;\n#[cfg(feature = \"v2\")]\nuse crate::{core::admin, db::StorageInterface, utils::ValueExt};\nuse crate::{\n    core::{\n        errors::{self, CustomResult, RouterResponse},\n        metrics, utils as core_utils,\n    },\n    routes::SessionState,\n    services::api as service\n\n... [truncated 102428 chars] ...\n\nodels::api::ApplicationResponse::Json(\n        response,\n    ))\n}\n\npub async fn update_gateway_score_open_router(\n    state: SessionState,\n    req_body: UpdateScorePayload,\n) -> RouterResponse<UpdateScoreResponse> {\n    let response = if state.conf.open_router.dynamic_routing_enabled {\n        SRApiClient::send_decision_engine_request(\n            &state,\n            Method::Post,\n            \"update-gateway-score\",\n            Some(req_body),\n            None,\n            None,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)?\n        .response\n        .ok_or(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to perform update gateway score call with open router\")?\n    } else {\n        Err(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Dynamic routing is not enabled\")?\n    };\n\n    Ok(hyperswitch_domain_models::api::ApplicationResponse::Json(\n        response,\n    ))\n}\n", "function_name": "crates__router__src__core__routing.rs", "file": "crates__router__src__core__routing.rs"}, {"query": "Hyperswitch routing algorithm configuration", "code": "pub mod helpers;\npub mod transformers;\nuse std::collections::HashSet;\n\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse api_models::routing::DynamicRoutingAlgoAccessor;\nuse api_models::{\n    enums, mandates as mandates_api,\n    open_router::{\n        DecideGatewayResponse, OpenRouterDecideGatewayRequest, UpdateScorePayload,\n        UpdateScoreResponse,\n    },\n    routing,\n    routing::{\n        self as routing_types, RoutingRetrieveQuery, RuleMigrationError, RuleMigrationResponse,\n    },\n};\nuse async_trait::async_trait;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::AsyncExt;\nuse common_utils::request::Method;\nuse diesel_models::routing_algorithm::RoutingAlgorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse helpers::{\n    enable_decision_engine_dynamic_routing_setup, update_decision_engine_dynamic_routing_setup,\n};\nuse hyperswitch_domain_models::{mandates, payment_address};\nuse payment_methods::helpers::StorageErrorExt;\nuse rustc_hash::FxHashSet;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse storage_impl::redis::cache;\n\n#[cfg(feature = \"payouts\")]\nuse super::payouts;\nuse super::{\n    errors::RouterResult,\n    payments::{\n        routing::{\n            utils::*,\n            {self as payments_routing},\n        },\n        OperationSessionGetters, OperationSessionSetters,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::utils::ValueExt;\n#[cfg(feature = \"v2\")]\nuse crate::{core::admin, db::StorageInterface, utils::ValueExt};\nuse crate::{\n    core::{\n        errors::{self, CustomResult, RouterResponse},\n        metrics, utils as core_utils,\n    },\n    routes::SessionState,\n    services::api as service\n\n... [truncated 102428 chars] ...\n\nodels::api::ApplicationResponse::Json(\n        response,\n    ))\n}\n\npub async fn update_gateway_score_open_router(\n    state: SessionState,\n    req_body: UpdateScorePayload,\n) -> RouterResponse<UpdateScoreResponse> {\n    let response = if state.conf.open_router.dynamic_routing_enabled {\n        SRApiClient::send_decision_engine_request(\n            &state,\n            Method::Post,\n            \"update-gateway-score\",\n            Some(req_body),\n            None,\n            None,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)?\n        .response\n        .ok_or(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to perform update gateway score call with open router\")?\n    } else {\n        Err(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Dynamic routing is not enabled\")?\n    };\n\n    Ok(hyperswitch_domain_models::api::ApplicationResponse::Json(\n        response,\n    ))\n}\n", "function_name": "crates__router__src__core__routing.rs", "file": "crates__router__src__core__routing.rs"}, {"query": "how to transform nexixpay api response", "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::{\n    AttemptStatus, CaptureMethod, CountryAlpha2, CountryAlpha3, Currency, RefundStatus,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{\n        CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId,\n        SetupMandateRequestData, UcsAuthenticationData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_with::skip_serializing_none;\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPostAuthenticateResponseRouterData, PaymentsPreAuthenticateResponseRouterData,\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, to_connector_meta,\n        to_connector_meta_from_secret, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPostAuthenticateRequestData,\n      \n\n... [truncated 76398 chars] ...\n\nation.order_id.clone(),\n                    ),\n                    redirection_data: Box::new(Some(redirection_form.clone())),\n                    mandate_reference: Box::new(Some(MandateReference {\n                        connector_mandate_id: item\n                            .data\n                            .connector_mandate_request_reference_id\n                            .clone(),\n                        payment_method_id: None,\n                        mandate_metadata: None,\n                        connector_mandate_request_reference_id: None,\n                    })),\n                    connector_metadata,\n                    network_txn_id: None,\n                    connector_response_reference_id: Some(item.response.operation.order_id.clone()),\n                    incremental_authorization_allowed: None,\n                    authentication_data: None,\n                    charges: None,\n                }),\n                ..item.data\n            }),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs"}, {"query": "nexixpay payment response transformer", "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::{\n    AttemptStatus, CaptureMethod, CountryAlpha2, CountryAlpha3, Currency, RefundStatus,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{\n        CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId,\n        SetupMandateRequestData, UcsAuthenticationData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_with::skip_serializing_none;\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPostAuthenticateResponseRouterData, PaymentsPreAuthenticateResponseRouterData,\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, to_connector_meta,\n        to_connector_meta_from_secret, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPostAuthenticateRequestData,\n      \n\n... [truncated 76398 chars] ...\n\nation.order_id.clone(),\n                    ),\n                    redirection_data: Box::new(Some(redirection_form.clone())),\n                    mandate_reference: Box::new(Some(MandateReference {\n                        connector_mandate_id: item\n                            .data\n                            .connector_mandate_request_reference_id\n                            .clone(),\n                        payment_method_id: None,\n                        mandate_metadata: None,\n                        connector_mandate_request_reference_id: None,\n                    })),\n                    connector_metadata,\n                    network_txn_id: None,\n                    connector_response_reference_id: Some(item.response.operation.order_id.clone()),\n                    incremental_authorization_allowed: None,\n                    authentication_data: None,\n                    charges: None,\n                }),\n                ..item.data\n            }),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs"}, {"query": "implement nexixpay refund handling", "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::{\n    AttemptStatus, CaptureMethod, CountryAlpha2, CountryAlpha3, Currency, RefundStatus,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{\n        CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId,\n        SetupMandateRequestData, UcsAuthenticationData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_with::skip_serializing_none;\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPostAuthenticateResponseRouterData, PaymentsPreAuthenticateResponseRouterData,\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, to_connector_meta,\n        to_connector_meta_from_secret, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPostAuthenticateRequestData,\n      \n\n... [truncated 76398 chars] ...\n\nation.order_id.clone(),\n                    ),\n                    redirection_data: Box::new(Some(redirection_form.clone())),\n                    mandate_reference: Box::new(Some(MandateReference {\n                        connector_mandate_id: item\n                            .data\n                            .connector_mandate_request_reference_id\n                            .clone(),\n                        payment_method_id: None,\n                        mandate_metadata: None,\n                        connector_mandate_request_reference_id: None,\n                    })),\n                    connector_metadata,\n                    network_txn_id: None,\n                    connector_response_reference_id: Some(item.response.operation.order_id.clone()),\n                    incremental_authorization_allowed: None,\n                    authentication_data: None,\n                    charges: None,\n                }),\n                ..item.data\n            }),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs"}, {"query": "nexixpay mandate reference mapping", "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::{\n    AttemptStatus, CaptureMethod, CountryAlpha2, CountryAlpha3, Currency, RefundStatus,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{\n        CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId,\n        SetupMandateRequestData, UcsAuthenticationData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_with::skip_serializing_none;\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPostAuthenticateResponseRouterData, PaymentsPreAuthenticateResponseRouterData,\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, to_connector_meta,\n        to_connector_meta_from_secret, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPostAuthenticateRequestData,\n      \n\n... [truncated 76398 chars] ...\n\nation.order_id.clone(),\n                    ),\n                    redirection_data: Box::new(Some(redirection_form.clone())),\n                    mandate_reference: Box::new(Some(MandateReference {\n                        connector_mandate_id: item\n                            .data\n                            .connector_mandate_request_reference_id\n                            .clone(),\n                        payment_method_id: None,\n                        mandate_metadata: None,\n                        connector_mandate_request_reference_id: None,\n                    })),\n                    connector_metadata,\n                    network_txn_id: None,\n                    connector_response_reference_id: Some(item.response.operation.order_id.clone()),\n                    incremental_authorization_allowed: None,\n                    authentication_data: None,\n                    charges: None,\n                }),\n                ..item.data\n            }),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs"}, {"query": "how to implement payment connector in hyperswitch", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{HmacSha256, VerifySignature},\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, PaymentsVoidType, Response, Setu\n\n... [truncated 39587 chars] ...\n\n [enums::EventClass; 3] = [\n    enums::EventClass::Disputes,\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n];\n\nimpl ConnectorSpecifications for Payload {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYLOAD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYLOAD_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYLOAD_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        #[cfg(feature = \"v1\")]\n        return payment_attempt.customer_acceptance.is_some()\n            && payment_attempt.setup_future_usage_applied == Some(enums::FutureUsage::OffSession);\n        #[cfg(feature = \"v2\")]\n        return false;\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payload.rs", "file": "crates__hyperswitch_connectors__src__connectors__payload.rs"}, {"query": "Payload connector authentication implementation", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{HmacSha256, VerifySignature},\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, PaymentsVoidType, Response, Setu\n\n... [truncated 39587 chars] ...\n\n [enums::EventClass; 3] = [\n    enums::EventClass::Disputes,\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n];\n\nimpl ConnectorSpecifications for Payload {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYLOAD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYLOAD_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYLOAD_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        #[cfg(feature = \"v1\")]\n        return payment_attempt.customer_acceptance.is_some()\n            && payment_attempt.setup_future_usage_applied == Some(enums::FutureUsage::OffSession);\n        #[cfg(feature = \"v2\")]\n        return false;\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payload.rs", "file": "crates__hyperswitch_connectors__src__connectors__payload.rs"}, {"query": "hyperswitch connector integration example", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{HmacSha256, VerifySignature},\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, PaymentsVoidType, Response, Setu\n\n... [truncated 39587 chars] ...\n\n [enums::EventClass; 3] = [\n    enums::EventClass::Disputes,\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n];\n\nimpl ConnectorSpecifications for Payload {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYLOAD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYLOAD_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYLOAD_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        #[cfg(feature = \"v1\")]\n        return payment_attempt.customer_acceptance.is_some()\n            && payment_attempt.setup_future_usage_applied == Some(enums::FutureUsage::OffSession);\n        #[cfg(feature = \"v2\")]\n        return false;\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payload.rs", "file": "crates__hyperswitch_connectors__src__connectors__payload.rs"}, {"query": "payment orchestration connector specifications", "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{HmacSha256, VerifySignature},\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, PaymentsVoidType, Response, Setu\n\n... [truncated 39587 chars] ...\n\n [enums::EventClass; 3] = [\n    enums::EventClass::Disputes,\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n];\n\nimpl ConnectorSpecifications for Payload {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYLOAD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYLOAD_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYLOAD_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        #[cfg(feature = \"v1\")]\n        return payment_attempt.customer_acceptance.is_some()\n            && payment_attempt.setup_future_usage_applied == Some(enums::FutureUsage::OffSession);\n        #[cfg(feature = \"v2\")]\n        return false;\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payload.rs", "file": "crates__hyperswitch_connectors__src__connectors__payload.rs"}, {"query": "hyperswitch payment method domain model", "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\n#[cfg(feature = \"v2\")]\nuse api_models::payment_methods::PaymentMethodsData;\nuse api_models::{customers, payment_methods, payments};\n// specific imports because of using the macro\nuse common_enums::enums::MerchantStorageScheme;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableValue;\n#[cfg(feature = \"v2\")]\nuse common_utils::{\n    crypto::Encryptable, encryption::Encryption, ext_traits::OptionExt,\n    types::keymanager::ToEncryptable,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError, ValidationError},\n    id_type, pii, type_name,\n    types::{keymanager, CreatedBy},\n};\npub use diesel_models::{enums as storage_enums, PaymentMethodUpdate};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v2\")]\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v2\")]\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v1\")]\nuse crate::type_encryption::AsyncLift;\nuse crate::{\n    mandates::{self, CommonMandateReference},\n    merchant_key_store::MerchantKeyStore,\n    payment_method_data as domain_payment_method_data,\n    transformers::ForeignTryFrom,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct VaultId(String);\n\nimpl VaultId {\n    pub fn get_string_repr(&self) -> &String {\n        &self.0\n    }\n\n    pub fn generate(id: String) -> Self {\n        Self(id)\n    }\n}\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct PaymentMethod {\n    pub customer_id: id_type::CustomerId,\n    pub merchant_id: id_type::MerchantId,\n    pub payment_method_id: String,\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub \n\n... [truncated 61105 chars] ...\n\nmandate_metadata\": null,\n                \"payment_method_type\": null,\n                \"connector_mandate_id\": \"RcBww0a02c-R22w22w22wNJV-V14o20u24y18sTB18sB24y06g04eVZ04e20u14o\",\n                \"connector_mandate_status\": \"active\",\n                \"original_payment_authorized_amount\": 51,\n                \"original_payment_authorized_currency\": \"USD\",\n                \"connector_mandate_request_reference_id\": \"RowbU9ULN9H59bMhWk\"\n            },\n            \"payouts\": {\n                \"mca_DAHVXbXpbYSjnL7fQWEs\": {\n                    \"transfer_method_id\": \"TRM-678ab3997b16cb7cd\"\n                }\n            }\n        });\n\n        let payment_method = get_payment_method_with_mandate_data(Some(connector_mandate_details));\n\n        let result = payment_method.get_common_mandate_reference();\n\n        assert!(result.is_ok());\n        let common_mandate = result.unwrap();\n\n        assert!(common_mandate.payments.is_some());\n        assert!(common_mandate.payouts.is_some());\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payment_methods.rs", "file": "crates__hyperswitch_domain_models__src__payment_methods.rs"}, {"query": "how to create a PaymentMethod in Rust", "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\n#[cfg(feature = \"v2\")]\nuse api_models::payment_methods::PaymentMethodsData;\nuse api_models::{customers, payment_methods, payments};\n// specific imports because of using the macro\nuse common_enums::enums::MerchantStorageScheme;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableValue;\n#[cfg(feature = \"v2\")]\nuse common_utils::{\n    crypto::Encryptable, encryption::Encryption, ext_traits::OptionExt,\n    types::keymanager::ToEncryptable,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError, ValidationError},\n    id_type, pii, type_name,\n    types::{keymanager, CreatedBy},\n};\npub use diesel_models::{enums as storage_enums, PaymentMethodUpdate};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v2\")]\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v2\")]\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v1\")]\nuse crate::type_encryption::AsyncLift;\nuse crate::{\n    mandates::{self, CommonMandateReference},\n    merchant_key_store::MerchantKeyStore,\n    payment_method_data as domain_payment_method_data,\n    transformers::ForeignTryFrom,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct VaultId(String);\n\nimpl VaultId {\n    pub fn get_string_repr(&self) -> &String {\n        &self.0\n    }\n\n    pub fn generate(id: String) -> Self {\n        Self(id)\n    }\n}\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct PaymentMethod {\n    pub customer_id: id_type::CustomerId,\n    pub merchant_id: id_type::MerchantId,\n    pub payment_method_id: String,\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub \n\n... [truncated 61105 chars] ...\n\nmandate_metadata\": null,\n                \"payment_method_type\": null,\n                \"connector_mandate_id\": \"RcBww0a02c-R22w22w22wNJV-V14o20u24y18sTB18sB24y06g04eVZ04e20u14o\",\n                \"connector_mandate_status\": \"active\",\n                \"original_payment_authorized_amount\": 51,\n                \"original_payment_authorized_currency\": \"USD\",\n                \"connector_mandate_request_reference_id\": \"RowbU9ULN9H59bMhWk\"\n            },\n            \"payouts\": {\n                \"mca_DAHVXbXpbYSjnL7fQWEs\": {\n                    \"transfer_method_id\": \"TRM-678ab3997b16cb7cd\"\n                }\n            }\n        });\n\n        let payment_method = get_payment_method_with_mandate_data(Some(connector_mandate_details));\n\n        let result = payment_method.get_common_mandate_reference();\n\n        assert!(result.is_ok());\n        let common_mandate = result.unwrap();\n\n        assert!(common_mandate.payments.is_some());\n        assert!(common_mandate.payouts.is_some());\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payment_methods.rs", "file": "crates__hyperswitch_domain_models__src__payment_methods.rs"}, {"query": "payment method encryption and validation", "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\n#[cfg(feature = \"v2\")]\nuse api_models::payment_methods::PaymentMethodsData;\nuse api_models::{customers, payment_methods, payments};\n// specific imports because of using the macro\nuse common_enums::enums::MerchantStorageScheme;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableValue;\n#[cfg(feature = \"v2\")]\nuse common_utils::{\n    crypto::Encryptable, encryption::Encryption, ext_traits::OptionExt,\n    types::keymanager::ToEncryptable,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError, ValidationError},\n    id_type, pii, type_name,\n    types::{keymanager, CreatedBy},\n};\npub use diesel_models::{enums as storage_enums, PaymentMethodUpdate};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v2\")]\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v2\")]\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v1\")]\nuse crate::type_encryption::AsyncLift;\nuse crate::{\n    mandates::{self, CommonMandateReference},\n    merchant_key_store::MerchantKeyStore,\n    payment_method_data as domain_payment_method_data,\n    transformers::ForeignTryFrom,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct VaultId(String);\n\nimpl VaultId {\n    pub fn get_string_repr(&self) -> &String {\n        &self.0\n    }\n\n    pub fn generate(id: String) -> Self {\n        Self(id)\n    }\n}\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct PaymentMethod {\n    pub customer_id: id_type::CustomerId,\n    pub merchant_id: id_type::MerchantId,\n    pub payment_method_id: String,\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub \n\n... [truncated 61105 chars] ...\n\nmandate_metadata\": null,\n                \"payment_method_type\": null,\n                \"connector_mandate_id\": \"RcBww0a02c-R22w22w22wNJV-V14o20u24y18sTB18sB24y06g04eVZ04e20u14o\",\n                \"connector_mandate_status\": \"active\",\n                \"original_payment_authorized_amount\": 51,\n                \"original_payment_authorized_currency\": \"USD\",\n                \"connector_mandate_request_reference_id\": \"RowbU9ULN9H59bMhWk\"\n            },\n            \"payouts\": {\n                \"mca_DAHVXbXpbYSjnL7fQWEs\": {\n                    \"transfer_method_id\": \"TRM-678ab3997b16cb7cd\"\n                }\n            }\n        });\n\n        let payment_method = get_payment_method_with_mandate_data(Some(connector_mandate_details));\n\n        let result = payment_method.get_common_mandate_reference();\n\n        assert!(result.is_ok());\n        let common_mandate = result.unwrap();\n\n        assert!(common_mandate.payments.is_some());\n        assert!(common_mandate.payouts.is_some());\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payment_methods.rs", "file": "crates__hyperswitch_domain_models__src__payment_methods.rs"}, {"query": "payment method status and metadata handling", "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\n#[cfg(feature = \"v2\")]\nuse api_models::payment_methods::PaymentMethodsData;\nuse api_models::{customers, payment_methods, payments};\n// specific imports because of using the macro\nuse common_enums::enums::MerchantStorageScheme;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableValue;\n#[cfg(feature = \"v2\")]\nuse common_utils::{\n    crypto::Encryptable, encryption::Encryption, ext_traits::OptionExt,\n    types::keymanager::ToEncryptable,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError, ValidationError},\n    id_type, pii, type_name,\n    types::{keymanager, CreatedBy},\n};\npub use diesel_models::{enums as storage_enums, PaymentMethodUpdate};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v2\")]\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v2\")]\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v1\")]\nuse crate::type_encryption::AsyncLift;\nuse crate::{\n    mandates::{self, CommonMandateReference},\n    merchant_key_store::MerchantKeyStore,\n    payment_method_data as domain_payment_method_data,\n    transformers::ForeignTryFrom,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct VaultId(String);\n\nimpl VaultId {\n    pub fn get_string_repr(&self) -> &String {\n        &self.0\n    }\n\n    pub fn generate(id: String) -> Self {\n        Self(id)\n    }\n}\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct PaymentMethod {\n    pub customer_id: id_type::CustomerId,\n    pub merchant_id: id_type::MerchantId,\n    pub payment_method_id: String,\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub \n\n... [truncated 61105 chars] ...\n\nmandate_metadata\": null,\n                \"payment_method_type\": null,\n                \"connector_mandate_id\": \"RcBww0a02c-R22w22w22wNJV-V14o20u24y18sTB18sB24y06g04eVZ04e20u14o\",\n                \"connector_mandate_status\": \"active\",\n                \"original_payment_authorized_amount\": 51,\n                \"original_payment_authorized_currency\": \"USD\",\n                \"connector_mandate_request_reference_id\": \"RowbU9ULN9H59bMhWk\"\n            },\n            \"payouts\": {\n                \"mca_DAHVXbXpbYSjnL7fQWEs\": {\n                    \"transfer_method_id\": \"TRM-678ab3997b16cb7cd\"\n                }\n            }\n        });\n\n        let payment_method = get_payment_method_with_mandate_data(Some(connector_mandate_details));\n\n        let result = payment_method.get_common_mandate_reference();\n\n        assert!(result.is_ok());\n        let common_mandate = result.unwrap();\n\n        assert!(common_mandate.payments.is_some());\n        assert!(common_mandate.payouts.is_some());\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payment_methods.rs", "file": "crates__hyperswitch_domain_models__src__payment_methods.rs"}, {"query": "how to integrate multisafepay payment gateway", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, AttemptStatus};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as multisafepay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Multisafepay {\n    amount_converter: &'static (dyn AmountConvertor<Output = \n\n... [truncated 24537 chars] ...\n\npecific_features: None,\n            },\n        );\n        multisafepay_supported_payment_methods\n    });\n\nstatic MULTISAFEPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Multisafepay\",\n    description: \"MultiSafePay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic MULTISAFEPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Multisafepay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MULTISAFEPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MULTISAFEPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MULTISAFEPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__multisafepay.rs", "file": "crates__hyperswitch_connectors__src__connectors__multisafepay.rs"}, {"query": "Multisafepay connector implementation hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, AttemptStatus};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as multisafepay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Multisafepay {\n    amount_converter: &'static (dyn AmountConvertor<Output = \n\n... [truncated 24537 chars] ...\n\npecific_features: None,\n            },\n        );\n        multisafepay_supported_payment_methods\n    });\n\nstatic MULTISAFEPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Multisafepay\",\n    description: \"MultiSafePay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic MULTISAFEPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Multisafepay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MULTISAFEPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MULTISAFEPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MULTISAFEPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__multisafepay.rs", "file": "crates__hyperswitch_connectors__src__connectors__multisafepay.rs"}, {"query": "how to configure multisafepay connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, AttemptStatus};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as multisafepay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Multisafepay {\n    amount_converter: &'static (dyn AmountConvertor<Output = \n\n... [truncated 24537 chars] ...\n\npecific_features: None,\n            },\n        );\n        multisafepay_supported_payment_methods\n    });\n\nstatic MULTISAFEPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Multisafepay\",\n    description: \"MultiSafePay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic MULTISAFEPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Multisafepay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MULTISAFEPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MULTISAFEPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MULTISAFEPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__multisafepay.rs", "file": "crates__hyperswitch_connectors__src__connectors__multisafepay.rs"}, {"query": "multisafepay supported payment methods", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, AttemptStatus};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as multisafepay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Multisafepay {\n    amount_converter: &'static (dyn AmountConvertor<Output = \n\n... [truncated 24537 chars] ...\n\npecific_features: None,\n            },\n        );\n        multisafepay_supported_payment_methods\n    });\n\nstatic MULTISAFEPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Multisafepay\",\n    description: \"MultiSafePay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic MULTISAFEPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Multisafepay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&MULTISAFEPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MULTISAFEPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&MULTISAFEPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__multisafepay.rs", "file": "crates__hyperswitch_connectors__src__connectors__multisafepay.rs"}, {"query": "Paysafe payment gateway integration Rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, CreateConnectorCustomer, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInter\n\n... [truncated 45165 chars] ...\n\nSAFE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYSAFE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYSAFE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n            && matches!(\n                payment_attempt.authentication_type,\n                Some(enums::AuthenticationType::NoThreeDs) | None\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paysafe.rs", "file": "crates__hyperswitch_connectors__src__connectors__paysafe.rs"}, {"query": "hyperswitch Paysafe connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, CreateConnectorCustomer, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInter\n\n... [truncated 45165 chars] ...\n\nSAFE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYSAFE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYSAFE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n            && matches!(\n                payment_attempt.authentication_type,\n                Some(enums::AuthenticationType::NoThreeDs) | None\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paysafe.rs", "file": "crates__hyperswitch_connectors__src__connectors__paysafe.rs"}, {"query": "how to add Paysafe payment method", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, CreateConnectorCustomer, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInter\n\n... [truncated 45165 chars] ...\n\nSAFE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYSAFE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYSAFE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n            && matches!(\n                payment_attempt.authentication_type,\n                Some(enums::AuthenticationType::NoThreeDs) | None\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paysafe.rs", "file": "crates__hyperswitch_connectors__src__connectors__paysafe.rs"}, {"query": "Paysafe API authentication hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, CreateConnectorCustomer, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInter\n\n... [truncated 45165 chars] ...\n\nSAFE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYSAFE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYSAFE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n            && matches!(\n                payment_attempt.authentication_type,\n                Some(enums::AuthenticationType::NoThreeDs) | None\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paysafe.rs", "file": "crates__hyperswitch_connectors__src__connectors__paysafe.rs"}, {"query": "Digital Virgo connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as digitalvirgo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Digitalvirgo {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Digit\n\n... [truncated 17131 chars] ...\n\nvirgo_supported_payment_methods\n    });\n\nstatic DIGITALVIRGO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Digital Virgo\",\n        description:\n            \"Digital Virgo is an alternative payment provider specializing in carrier billing and mobile payments \",\n        connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\nstatic DIGITALVIRGO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Digitalvirgo {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DIGITALVIRGO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DIGITALVIRGO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DIGITALVIRGO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs", "file": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs"}, {"query": "hyperswitch carrier billing integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as digitalvirgo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Digitalvirgo {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Digit\n\n... [truncated 17131 chars] ...\n\nvirgo_supported_payment_methods\n    });\n\nstatic DIGITALVIRGO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Digital Virgo\",\n        description:\n            \"Digital Virgo is an alternative payment provider specializing in carrier billing and mobile payments \",\n        connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\nstatic DIGITALVIRGO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Digitalvirgo {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DIGITALVIRGO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DIGITALVIRGO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DIGITALVIRGO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs", "file": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs"}, {"query": "Digitalvirgo authorize capture refund", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as digitalvirgo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Digitalvirgo {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Digit\n\n... [truncated 17131 chars] ...\n\nvirgo_supported_payment_methods\n    });\n\nstatic DIGITALVIRGO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Digital Virgo\",\n        description:\n            \"Digital Virgo is an alternative payment provider specializing in carrier billing and mobile payments \",\n        connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\nstatic DIGITALVIRGO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Digitalvirgo {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DIGITALVIRGO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DIGITALVIRGO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DIGITALVIRGO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs", "file": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs"}, {"query": "hyperswitch mobile payment connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as digitalvirgo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Digitalvirgo {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Digit\n\n... [truncated 17131 chars] ...\n\nvirgo_supported_payment_methods\n    });\n\nstatic DIGITALVIRGO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Digital Virgo\",\n        description:\n            \"Digital Virgo is an alternative payment provider specializing in carrier billing and mobile payments \",\n        connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\nstatic DIGITALVIRGO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Digitalvirgo {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DIGITALVIRGO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DIGITALVIRGO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DIGITALVIRGO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs", "file": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs"}, {"query": "Stripe payment gateway connector implementation", "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{\n    CallConnectorAction, CaptureMethod, PaymentAction, PaymentChargeType, PaymentMethodType,\n    PaymentResourceUpdateStatus, StripeChargeType,\n};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt as _, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, CreateConnectorCustomer, Evidence, Execute,\n        IncrementalAuthorization, PSync, PaymentMethodToken, RSync, Retrieve, Session,\n        SetupMandate, UpdateMetadata, Upload, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, RetrieveFileRequestData, SetupMandateRequestData,\n        SplitRefundsRequest, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n        SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundsRo\n\n... [truncated 119357 chars] ...\n\ne\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic STRIPE_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 3] = [\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n    common_enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Stripe {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STRIPE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*STRIPE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&STRIPE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripe.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripe.rs"}, {"query": "Stripe connector execute function", "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{\n    CallConnectorAction, CaptureMethod, PaymentAction, PaymentChargeType, PaymentMethodType,\n    PaymentResourceUpdateStatus, StripeChargeType,\n};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt as _, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, CreateConnectorCustomer, Evidence, Execute,\n        IncrementalAuthorization, PSync, PaymentMethodToken, RSync, Retrieve, Session,\n        SetupMandate, UpdateMetadata, Upload, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, RetrieveFileRequestData, SetupMandateRequestData,\n        SplitRefundsRequest, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n        SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundsRo\n\n... [truncated 119357 chars] ...\n\ne\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic STRIPE_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 3] = [\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n    common_enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Stripe {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STRIPE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*STRIPE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&STRIPE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripe.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripe.rs"}, {"query": "how to implement Stripe payment gateway", "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{\n    CallConnectorAction, CaptureMethod, PaymentAction, PaymentChargeType, PaymentMethodType,\n    PaymentResourceUpdateStatus, StripeChargeType,\n};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt as _, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, CreateConnectorCustomer, Evidence, Execute,\n        IncrementalAuthorization, PSync, PaymentMethodToken, RSync, Retrieve, Session,\n        SetupMandate, UpdateMetadata, Upload, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, RetrieveFileRequestData, SetupMandateRequestData,\n        SplitRefundsRequest, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n        SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundsRo\n\n... [truncated 119357 chars] ...\n\ne\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic STRIPE_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 3] = [\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n    common_enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Stripe {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STRIPE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*STRIPE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&STRIPE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripe.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripe.rs"}, {"query": "hyperswitch stripe payment method types", "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{\n    CallConnectorAction, CaptureMethod, PaymentAction, PaymentChargeType, PaymentMethodType,\n    PaymentResourceUpdateStatus, StripeChargeType,\n};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt as _, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, CreateConnectorCustomer, Evidence, Execute,\n        IncrementalAuthorization, PSync, PaymentMethodToken, RSync, Retrieve, Session,\n        SetupMandate, UpdateMetadata, Upload, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, RetrieveFileRequestData, SetupMandateRequestData,\n        SplitRefundsRequest, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n        SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundsRo\n\n... [truncated 119357 chars] ...\n\ne\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic STRIPE_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 3] = [\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n    common_enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Stripe {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STRIPE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*STRIPE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(&STRIPE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripe.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripe.rs"}, {"query": "dummy connector types rust", "code": "use api_models::enums::Currency;\nuse common_utils::{errors::CustomResult, generate_id_with_default_len, pii};\nuse error_stack::report;\nuse masking::Secret;\nuse router_env::types::FlowMetric;\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse super::{consts, errors::DummyConnectorErrors};\nuse crate::services;\n\n#[derive(Debug, Display, Clone, PartialEq, Eq)]\n#[allow(clippy::enum_variant_names)]\npub enum Flow {\n    DummyPaymentCreate,\n    DummyPaymentRetrieve,\n    DummyPaymentAuthorize,\n    DummyPaymentComplete,\n    DummyRefundCreate,\n    DummyRefundRetrieve,\n}\n\nimpl FlowMetric for Flow {}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, strum::Display, Eq, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\n#[strum(serialize_all = \"snake_case\")]\npub enum DummyConnectors {\n    #[serde(rename = \"phonypay\")]\n    #[strum(serialize = \"phonypay\")]\n    PhonyPay,\n    #[serde(rename = \"fauxpay\")]\n    #[strum(serialize = \"fauxpay\")]\n    FauxPay,\n    #[serde(rename = \"pretendpay\")]\n    #[strum(serialize = \"pretendpay\")]\n    PretendPay,\n    StripeTest,\n    AdyenTest,\n    CheckoutTest,\n    PaypalTest,\n}\n\nimpl DummyConnectors {\n    pub fn get_connector_image_link(self, base_url: &str) -> String {\n        let image_name = match self {\n            Self::PhonyPay => \"PHONYPAY.svg\",\n            Self::FauxPay => \"FAUXPAY.svg\",\n            Self::PretendPay => \"PRETENDPAY.svg\",\n            Self::StripeTest => \"STRIPE_TEST.svg\",\n            Self::PaypalTest => \"PAYPAL_TEST.svg\",\n            _ => \"PHONYPAY.svg\",\n        };\n        format!(\"{base_url}{image_name}\")\n    }\n}\n\n#[derive(\n    Default, serde::Serialize, serde::Deserialize, strum::Display, Clone, PartialEq, Debug, Eq,\n)]\n#[serde(rename_all = \"lowercase\")]\npub enum DummyConnectorStatus {\n    Succeeded,\n    #[default]\n    Processing,\n    Failed,\n}\n\n#[derive(Clone, Debug, serde::Serialize, Eq, PartialEq, serde::Deserialize)]\npub struct DummyConnectorPaymentAttempt {\n    pub timestamp: PrimitiveDateTime,\n    pub attempt_id: String,\n \n\n... [truncated 10266 chars] ...\n\nPrimitiveDateTime,\n    pub payment_amount: i64,\n    pub refund_amount: i64,\n}\n\nimpl DummyConnectorRefundResponse {\n    pub fn new(\n        status: DummyConnectorStatus,\n        id: String,\n        currency: Currency,\n        created: PrimitiveDateTime,\n        payment_amount: i64,\n        refund_amount: i64,\n    ) -> Self {\n        Self {\n            status,\n            id,\n            currency,\n            created,\n            payment_amount,\n            refund_amount,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct DummyConnectorRefundRetrieveRequest {\n    pub refund_id: String,\n}\n\npub type DummyConnectorResponse<T> =\n    CustomResult<services::ApplicationResponse<T>, DummyConnectorErrors>;\n\npub type DummyConnectorResult<T> = CustomResult<T, DummyConnectorErrors>;\n\npub struct DummyConnectorUpiFlow {\n    pub status: DummyConnectorStatus,\n    pub error: Option<DummyConnectorErrors>,\n    pub is_next_action_required: bool,\n}\n", "function_name": "crates__router__src__routes__dummy_connector__types.rs", "file": "crates__router__src__routes__dummy_connector__types.rs"}, {"query": "how to implement dummy payment gateway", "code": "use api_models::enums::Currency;\nuse common_utils::{errors::CustomResult, generate_id_with_default_len, pii};\nuse error_stack::report;\nuse masking::Secret;\nuse router_env::types::FlowMetric;\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse super::{consts, errors::DummyConnectorErrors};\nuse crate::services;\n\n#[derive(Debug, Display, Clone, PartialEq, Eq)]\n#[allow(clippy::enum_variant_names)]\npub enum Flow {\n    DummyPaymentCreate,\n    DummyPaymentRetrieve,\n    DummyPaymentAuthorize,\n    DummyPaymentComplete,\n    DummyRefundCreate,\n    DummyRefundRetrieve,\n}\n\nimpl FlowMetric for Flow {}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, strum::Display, Eq, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\n#[strum(serialize_all = \"snake_case\")]\npub enum DummyConnectors {\n    #[serde(rename = \"phonypay\")]\n    #[strum(serialize = \"phonypay\")]\n    PhonyPay,\n    #[serde(rename = \"fauxpay\")]\n    #[strum(serialize = \"fauxpay\")]\n    FauxPay,\n    #[serde(rename = \"pretendpay\")]\n    #[strum(serialize = \"pretendpay\")]\n    PretendPay,\n    StripeTest,\n    AdyenTest,\n    CheckoutTest,\n    PaypalTest,\n}\n\nimpl DummyConnectors {\n    pub fn get_connector_image_link(self, base_url: &str) -> String {\n        let image_name = match self {\n            Self::PhonyPay => \"PHONYPAY.svg\",\n            Self::FauxPay => \"FAUXPAY.svg\",\n            Self::PretendPay => \"PRETENDPAY.svg\",\n            Self::StripeTest => \"STRIPE_TEST.svg\",\n            Self::PaypalTest => \"PAYPAL_TEST.svg\",\n            _ => \"PHONYPAY.svg\",\n        };\n        format!(\"{base_url}{image_name}\")\n    }\n}\n\n#[derive(\n    Default, serde::Serialize, serde::Deserialize, strum::Display, Clone, PartialEq, Debug, Eq,\n)]\n#[serde(rename_all = \"lowercase\")]\npub enum DummyConnectorStatus {\n    Succeeded,\n    #[default]\n    Processing,\n    Failed,\n}\n\n#[derive(Clone, Debug, serde::Serialize, Eq, PartialEq, serde::Deserialize)]\npub struct DummyConnectorPaymentAttempt {\n    pub timestamp: PrimitiveDateTime,\n    pub attempt_id: String,\n \n\n... [truncated 10266 chars] ...\n\nPrimitiveDateTime,\n    pub payment_amount: i64,\n    pub refund_amount: i64,\n}\n\nimpl DummyConnectorRefundResponse {\n    pub fn new(\n        status: DummyConnectorStatus,\n        id: String,\n        currency: Currency,\n        created: PrimitiveDateTime,\n        payment_amount: i64,\n        refund_amount: i64,\n    ) -> Self {\n        Self {\n            status,\n            id,\n            currency,\n            created,\n            payment_amount,\n            refund_amount,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct DummyConnectorRefundRetrieveRequest {\n    pub refund_id: String,\n}\n\npub type DummyConnectorResponse<T> =\n    CustomResult<services::ApplicationResponse<T>, DummyConnectorErrors>;\n\npub type DummyConnectorResult<T> = CustomResult<T, DummyConnectorErrors>;\n\npub struct DummyConnectorUpiFlow {\n    pub status: DummyConnectorStatus,\n    pub error: Option<DummyConnectorErrors>,\n    pub is_next_action_required: bool,\n}\n", "function_name": "crates__router__src__routes__dummy_connector__types.rs", "file": "crates__router__src__routes__dummy_connector__types.rs"}, {"query": "payment orchestration dummy connector", "code": "use api_models::enums::Currency;\nuse common_utils::{errors::CustomResult, generate_id_with_default_len, pii};\nuse error_stack::report;\nuse masking::Secret;\nuse router_env::types::FlowMetric;\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse super::{consts, errors::DummyConnectorErrors};\nuse crate::services;\n\n#[derive(Debug, Display, Clone, PartialEq, Eq)]\n#[allow(clippy::enum_variant_names)]\npub enum Flow {\n    DummyPaymentCreate,\n    DummyPaymentRetrieve,\n    DummyPaymentAuthorize,\n    DummyPaymentComplete,\n    DummyRefundCreate,\n    DummyRefundRetrieve,\n}\n\nimpl FlowMetric for Flow {}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, strum::Display, Eq, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\n#[strum(serialize_all = \"snake_case\")]\npub enum DummyConnectors {\n    #[serde(rename = \"phonypay\")]\n    #[strum(serialize = \"phonypay\")]\n    PhonyPay,\n    #[serde(rename = \"fauxpay\")]\n    #[strum(serialize = \"fauxpay\")]\n    FauxPay,\n    #[serde(rename = \"pretendpay\")]\n    #[strum(serialize = \"pretendpay\")]\n    PretendPay,\n    StripeTest,\n    AdyenTest,\n    CheckoutTest,\n    PaypalTest,\n}\n\nimpl DummyConnectors {\n    pub fn get_connector_image_link(self, base_url: &str) -> String {\n        let image_name = match self {\n            Self::PhonyPay => \"PHONYPAY.svg\",\n            Self::FauxPay => \"FAUXPAY.svg\",\n            Self::PretendPay => \"PRETENDPAY.svg\",\n            Self::StripeTest => \"STRIPE_TEST.svg\",\n            Self::PaypalTest => \"PAYPAL_TEST.svg\",\n            _ => \"PHONYPAY.svg\",\n        };\n        format!(\"{base_url}{image_name}\")\n    }\n}\n\n#[derive(\n    Default, serde::Serialize, serde::Deserialize, strum::Display, Clone, PartialEq, Debug, Eq,\n)]\n#[serde(rename_all = \"lowercase\")]\npub enum DummyConnectorStatus {\n    Succeeded,\n    #[default]\n    Processing,\n    Failed,\n}\n\n#[derive(Clone, Debug, serde::Serialize, Eq, PartialEq, serde::Deserialize)]\npub struct DummyConnectorPaymentAttempt {\n    pub timestamp: PrimitiveDateTime,\n    pub attempt_id: String,\n \n\n... [truncated 10266 chars] ...\n\nPrimitiveDateTime,\n    pub payment_amount: i64,\n    pub refund_amount: i64,\n}\n\nimpl DummyConnectorRefundResponse {\n    pub fn new(\n        status: DummyConnectorStatus,\n        id: String,\n        currency: Currency,\n        created: PrimitiveDateTime,\n        payment_amount: i64,\n        refund_amount: i64,\n    ) -> Self {\n        Self {\n            status,\n            id,\n            currency,\n            created,\n            payment_amount,\n            refund_amount,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct DummyConnectorRefundRetrieveRequest {\n    pub refund_id: String,\n}\n\npub type DummyConnectorResponse<T> =\n    CustomResult<services::ApplicationResponse<T>, DummyConnectorErrors>;\n\npub type DummyConnectorResult<T> = CustomResult<T, DummyConnectorErrors>;\n\npub struct DummyConnectorUpiFlow {\n    pub status: DummyConnectorStatus,\n    pub error: Option<DummyConnectorErrors>,\n    pub is_next_action_required: bool,\n}\n", "function_name": "crates__router__src__routes__dummy_connector__types.rs", "file": "crates__router__src__routes__dummy_connector__types.rs"}, {"query": "hyperswitch dummy connector mock", "code": "use api_models::enums::Currency;\nuse common_utils::{errors::CustomResult, generate_id_with_default_len, pii};\nuse error_stack::report;\nuse masking::Secret;\nuse router_env::types::FlowMetric;\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse super::{consts, errors::DummyConnectorErrors};\nuse crate::services;\n\n#[derive(Debug, Display, Clone, PartialEq, Eq)]\n#[allow(clippy::enum_variant_names)]\npub enum Flow {\n    DummyPaymentCreate,\n    DummyPaymentRetrieve,\n    DummyPaymentAuthorize,\n    DummyPaymentComplete,\n    DummyRefundCreate,\n    DummyRefundRetrieve,\n}\n\nimpl FlowMetric for Flow {}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, strum::Display, Eq, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\n#[strum(serialize_all = \"snake_case\")]\npub enum DummyConnectors {\n    #[serde(rename = \"phonypay\")]\n    #[strum(serialize = \"phonypay\")]\n    PhonyPay,\n    #[serde(rename = \"fauxpay\")]\n    #[strum(serialize = \"fauxpay\")]\n    FauxPay,\n    #[serde(rename = \"pretendpay\")]\n    #[strum(serialize = \"pretendpay\")]\n    PretendPay,\n    StripeTest,\n    AdyenTest,\n    CheckoutTest,\n    PaypalTest,\n}\n\nimpl DummyConnectors {\n    pub fn get_connector_image_link(self, base_url: &str) -> String {\n        let image_name = match self {\n            Self::PhonyPay => \"PHONYPAY.svg\",\n            Self::FauxPay => \"FAUXPAY.svg\",\n            Self::PretendPay => \"PRETENDPAY.svg\",\n            Self::StripeTest => \"STRIPE_TEST.svg\",\n            Self::PaypalTest => \"PAYPAL_TEST.svg\",\n            _ => \"PHONYPAY.svg\",\n        };\n        format!(\"{base_url}{image_name}\")\n    }\n}\n\n#[derive(\n    Default, serde::Serialize, serde::Deserialize, strum::Display, Clone, PartialEq, Debug, Eq,\n)]\n#[serde(rename_all = \"lowercase\")]\npub enum DummyConnectorStatus {\n    Succeeded,\n    #[default]\n    Processing,\n    Failed,\n}\n\n#[derive(Clone, Debug, serde::Serialize, Eq, PartialEq, serde::Deserialize)]\npub struct DummyConnectorPaymentAttempt {\n    pub timestamp: PrimitiveDateTime,\n    pub attempt_id: String,\n \n\n... [truncated 10266 chars] ...\n\nPrimitiveDateTime,\n    pub payment_amount: i64,\n    pub refund_amount: i64,\n}\n\nimpl DummyConnectorRefundResponse {\n    pub fn new(\n        status: DummyConnectorStatus,\n        id: String,\n        currency: Currency,\n        created: PrimitiveDateTime,\n        payment_amount: i64,\n        refund_amount: i64,\n    ) -> Self {\n        Self {\n            status,\n            id,\n            currency,\n            created,\n            payment_amount,\n            refund_amount,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct DummyConnectorRefundRetrieveRequest {\n    pub refund_id: String,\n}\n\npub type DummyConnectorResponse<T> =\n    CustomResult<services::ApplicationResponse<T>, DummyConnectorErrors>;\n\npub type DummyConnectorResult<T> = CustomResult<T, DummyConnectorErrors>;\n\npub struct DummyConnectorUpiFlow {\n    pub status: DummyConnectorStatus,\n    pub error: Option<DummyConnectorErrors>,\n    pub is_next_action_required: bool,\n}\n", "function_name": "crates__router__src__routes__dummy_connector__types.rs", "file": "crates__router__src__routes__dummy_connector__types.rs"}, {"query": "Klarna payment authorization response transformation", "code": "use api_models::payments::{KlarnaSessionTokenResponse, SessionToken};\nuse common_enums::enums;\nuse common_utils::{pii, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        KlarnaSdkResponse, RouterData,\n    },\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, AddressData, AddressDetailsData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct KlarnaRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for KlarnaRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct KlarnaConnectorMetadataObject {\n    pub klarna_region: Option<KlarnaEndpoint>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum KlarnaEndpoint {\n    Europe,\n    NorthAmerica,\n    Oceania,\n}\n\nimpl From<KlarnaEndpoint> for String {\n    fn from(endpoint: KlarnaEndpoint) -> Self {\n        Self::from(match endpoint {\n            KlarnaEndpoint::Europe => \"\",\n            KlarnaEndpoint::NorthAmerica => \"-na\",\n            KlarnaEndpoint::Oceania => \"-oc\",\n        })\n    }\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for KlarnaConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_\n\n... [truncated 24856 chars] ...\n\nnse>>\n    for types::RefundsRouterData<RSync>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, KlarnaRefundSyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        // https://docs.klarna.com/api/ordermanagement/#operation/get\n        // If 200 status code, then Refund is Successful, other status codes are handled by the error handler\n        let status = if item.http_code == 200 {\n            enums::RefundStatus::Success\n        } else {\n            enums::RefundStatus::Failure\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.refund_id,\n                refund_status: status,\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug)]\npub struct KlarnaErrorResponse {\n    pub error_code: String,\n    pub error_messages: Option<Vec<String>>,\n    pub error_message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs"}, {"query": "how to handle Klarna refunds in hyperswitch", "code": "use api_models::payments::{KlarnaSessionTokenResponse, SessionToken};\nuse common_enums::enums;\nuse common_utils::{pii, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        KlarnaSdkResponse, RouterData,\n    },\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, AddressData, AddressDetailsData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct KlarnaRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for KlarnaRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct KlarnaConnectorMetadataObject {\n    pub klarna_region: Option<KlarnaEndpoint>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum KlarnaEndpoint {\n    Europe,\n    NorthAmerica,\n    Oceania,\n}\n\nimpl From<KlarnaEndpoint> for String {\n    fn from(endpoint: KlarnaEndpoint) -> Self {\n        Self::from(match endpoint {\n            KlarnaEndpoint::Europe => \"\",\n            KlarnaEndpoint::NorthAmerica => \"-na\",\n            KlarnaEndpoint::Oceania => \"-oc\",\n        })\n    }\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for KlarnaConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_\n\n... [truncated 24856 chars] ...\n\nnse>>\n    for types::RefundsRouterData<RSync>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, KlarnaRefundSyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        // https://docs.klarna.com/api/ordermanagement/#operation/get\n        // If 200 status code, then Refund is Successful, other status codes are handled by the error handler\n        let status = if item.http_code == 200 {\n            enums::RefundStatus::Success\n        } else {\n            enums::RefundStatus::Failure\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.refund_id,\n                refund_status: status,\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug)]\npub struct KlarnaErrorResponse {\n    pub error_code: String,\n    pub error_messages: Option<Vec<String>>,\n    pub error_message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs"}, {"query": "KlarnaPaymentsRequest struct definition", "code": "use api_models::payments::{KlarnaSessionTokenResponse, SessionToken};\nuse common_enums::enums;\nuse common_utils::{pii, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        KlarnaSdkResponse, RouterData,\n    },\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, AddressData, AddressDetailsData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct KlarnaRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for KlarnaRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct KlarnaConnectorMetadataObject {\n    pub klarna_region: Option<KlarnaEndpoint>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum KlarnaEndpoint {\n    Europe,\n    NorthAmerica,\n    Oceania,\n}\n\nimpl From<KlarnaEndpoint> for String {\n    fn from(endpoint: KlarnaEndpoint) -> Self {\n        Self::from(match endpoint {\n            KlarnaEndpoint::Europe => \"\",\n            KlarnaEndpoint::NorthAmerica => \"-na\",\n            KlarnaEndpoint::Oceania => \"-oc\",\n        })\n    }\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for KlarnaConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_\n\n... [truncated 24856 chars] ...\n\nnse>>\n    for types::RefundsRouterData<RSync>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, KlarnaRefundSyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        // https://docs.klarna.com/api/ordermanagement/#operation/get\n        // If 200 status code, then Refund is Successful, other status codes are handled by the error handler\n        let status = if item.http_code == 200 {\n            enums::RefundStatus::Success\n        } else {\n            enums::RefundStatus::Failure\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.refund_id,\n                refund_status: status,\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug)]\npub struct KlarnaErrorResponse {\n    pub error_code: String,\n    pub error_messages: Option<Vec<String>>,\n    pub error_message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs"}, {"query": "Klarna connector error handling", "code": "use api_models::payments::{KlarnaSessionTokenResponse, SessionToken};\nuse common_enums::enums;\nuse common_utils::{pii, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        KlarnaSdkResponse, RouterData,\n    },\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, AddressData, AddressDetailsData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct KlarnaRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for KlarnaRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct KlarnaConnectorMetadataObject {\n    pub klarna_region: Option<KlarnaEndpoint>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum KlarnaEndpoint {\n    Europe,\n    NorthAmerica,\n    Oceania,\n}\n\nimpl From<KlarnaEndpoint> for String {\n    fn from(endpoint: KlarnaEndpoint) -> Self {\n        Self::from(match endpoint {\n            KlarnaEndpoint::Europe => \"\",\n            KlarnaEndpoint::NorthAmerica => \"-na\",\n            KlarnaEndpoint::Oceania => \"-oc\",\n        })\n    }\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for KlarnaConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_\n\n... [truncated 24856 chars] ...\n\nnse>>\n    for types::RefundsRouterData<RSync>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, KlarnaRefundSyncResponse>,\n    ) -> Result<Self, Self::Error> {\n        // https://docs.klarna.com/api/ordermanagement/#operation/get\n        // If 200 status code, then Refund is Successful, other status codes are handled by the error handler\n        let status = if item.http_code == 200 {\n            enums::RefundStatus::Success\n        } else {\n            enums::RefundStatus::Failure\n        };\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.refund_id,\n                refund_status: status,\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug)]\npub struct KlarnaErrorResponse {\n    pub error_code: String,\n    pub error_messages: Option<Vec<String>>,\n    pub error_message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs"}, {"query": "how to execute clickhouse queries in rust", "code": "use std::sync::Arc;\n\nuse actix_web::http::StatusCode;\nuse common_utils::errors::ParsingError;\nuse error_stack::{report, Report, ResultExt};\nuse router_env::logger;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    active_payments::metrics::ActivePaymentsMetricRow,\n    auth_events::metrics::AuthEventMetricRow,\n    frm::{filters::FrmFilterRow, metrics::FrmMetricRow},\n    health_check::HealthCheck,\n    payment_intents::{filters::PaymentIntentFilterRow, metrics::PaymentIntentMetricRow},\n    payments::{\n        distribution::PaymentDistributionRow, filters::PaymentFilterRow, metrics::PaymentMetricRow,\n    },\n    query::{Aggregate, ToSql, Window},\n    refunds::{\n        distribution::RefundDistributionRow, filters::RefundFilterRow, metrics::RefundMetricRow,\n    },\n    sdk_events::{filters::SdkEventFilter, metrics::SdkEventMetricRow},\n    types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, QueryExecutionError},\n};\nuse crate::{\n    api_event::{\n        events::ApiLogsResult,\n        filters::ApiEventFilter,\n        metrics::{latency::LatencyAvg, ApiEventMetricRow},\n    },\n    auth_events::filters::AuthEventFilterRow,\n    connector_events::events::ConnectorEventsResult,\n    disputes::{filters::DisputeFilterRow, metrics::DisputeMetricRow},\n    outgoing_webhook_event::events::OutgoingWebhookLogsResult,\n    routing_events::events::RoutingEventsResult,\n    sdk_events::events::SdkEventsResult,\n    types::TableEngine,\n};\n\npub type ClickhouseResult<T> = error_stack::Result<T, ClickhouseError>;\n\n#[derive(Clone, Debug)]\npub struct ClickhouseClient {\n    pub config: Arc<ClickhouseConfig>,\n    pub database: String,\n}\n\n#[derive(Clone, Debug, serde::Deserialize)]\npub struct ClickhouseConfig {\n    username: String,\n    password: Option<String>,\n    host: String,\n}\n\nimpl Default for ClickhouseConfig {\n    fn default() -> Self {\n        Self {\n            username: \"default\".to_string(),\n            password: None,\n            host: \"http://localhost:8123\".to_string(),\n        }\n    }\n}\n\nimpl Cli\n\n... [truncated 21449 chars] ...\n\n\"row_number() over ({}{}){}\",\n                    partition_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |partition_by| format!(\"partition by {}\", partition_by.to_owned())\n                    ),\n                    order_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |(order_column, order)| format!(\n                            \" order by {} {}\",\n                            order_column.to_owned(),\n                            order\n                        )\n                    ),\n                    alias.map_or_else(|| \"\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n        })\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ClickhouseError {\n    #[error(\"Clickhouse connection error\")]\n    ConnectionError,\n    #[error(\"Clickhouse NON-200 response content: '{0}'\")]\n    ResponseNotOK(String),\n    #[error(\"Clickhouse response error\")]\n    ResponseError,\n}\n", "function_name": "crates__analytics__src__clickhouse.rs", "file": "crates__analytics__src__clickhouse.rs"}, {"query": "ClickhouseClient struct implementation", "code": "use std::sync::Arc;\n\nuse actix_web::http::StatusCode;\nuse common_utils::errors::ParsingError;\nuse error_stack::{report, Report, ResultExt};\nuse router_env::logger;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    active_payments::metrics::ActivePaymentsMetricRow,\n    auth_events::metrics::AuthEventMetricRow,\n    frm::{filters::FrmFilterRow, metrics::FrmMetricRow},\n    health_check::HealthCheck,\n    payment_intents::{filters::PaymentIntentFilterRow, metrics::PaymentIntentMetricRow},\n    payments::{\n        distribution::PaymentDistributionRow, filters::PaymentFilterRow, metrics::PaymentMetricRow,\n    },\n    query::{Aggregate, ToSql, Window},\n    refunds::{\n        distribution::RefundDistributionRow, filters::RefundFilterRow, metrics::RefundMetricRow,\n    },\n    sdk_events::{filters::SdkEventFilter, metrics::SdkEventMetricRow},\n    types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, QueryExecutionError},\n};\nuse crate::{\n    api_event::{\n        events::ApiLogsResult,\n        filters::ApiEventFilter,\n        metrics::{latency::LatencyAvg, ApiEventMetricRow},\n    },\n    auth_events::filters::AuthEventFilterRow,\n    connector_events::events::ConnectorEventsResult,\n    disputes::{filters::DisputeFilterRow, metrics::DisputeMetricRow},\n    outgoing_webhook_event::events::OutgoingWebhookLogsResult,\n    routing_events::events::RoutingEventsResult,\n    sdk_events::events::SdkEventsResult,\n    types::TableEngine,\n};\n\npub type ClickhouseResult<T> = error_stack::Result<T, ClickhouseError>;\n\n#[derive(Clone, Debug)]\npub struct ClickhouseClient {\n    pub config: Arc<ClickhouseConfig>,\n    pub database: String,\n}\n\n#[derive(Clone, Debug, serde::Deserialize)]\npub struct ClickhouseConfig {\n    username: String,\n    password: Option<String>,\n    host: String,\n}\n\nimpl Default for ClickhouseConfig {\n    fn default() -> Self {\n        Self {\n            username: \"default\".to_string(),\n            password: None,\n            host: \"http://localhost:8123\".to_string(),\n        }\n    }\n}\n\nimpl Cli\n\n... [truncated 21449 chars] ...\n\n\"row_number() over ({}{}){}\",\n                    partition_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |partition_by| format!(\"partition by {}\", partition_by.to_owned())\n                    ),\n                    order_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |(order_column, order)| format!(\n                            \" order by {} {}\",\n                            order_column.to_owned(),\n                            order\n                        )\n                    ),\n                    alias.map_or_else(|| \"\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n        })\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ClickhouseError {\n    #[error(\"Clickhouse connection error\")]\n    ConnectionError,\n    #[error(\"Clickhouse NON-200 response content: '{0}'\")]\n    ResponseNotOK(String),\n    #[error(\"Clickhouse response error\")]\n    ResponseError,\n}\n", "function_name": "crates__analytics__src__clickhouse.rs", "file": "crates__analytics__src__clickhouse.rs"}, {"query": "how to fetch payment metrics from clickhouse", "code": "use std::sync::Arc;\n\nuse actix_web::http::StatusCode;\nuse common_utils::errors::ParsingError;\nuse error_stack::{report, Report, ResultExt};\nuse router_env::logger;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    active_payments::metrics::ActivePaymentsMetricRow,\n    auth_events::metrics::AuthEventMetricRow,\n    frm::{filters::FrmFilterRow, metrics::FrmMetricRow},\n    health_check::HealthCheck,\n    payment_intents::{filters::PaymentIntentFilterRow, metrics::PaymentIntentMetricRow},\n    payments::{\n        distribution::PaymentDistributionRow, filters::PaymentFilterRow, metrics::PaymentMetricRow,\n    },\n    query::{Aggregate, ToSql, Window},\n    refunds::{\n        distribution::RefundDistributionRow, filters::RefundFilterRow, metrics::RefundMetricRow,\n    },\n    sdk_events::{filters::SdkEventFilter, metrics::SdkEventMetricRow},\n    types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, QueryExecutionError},\n};\nuse crate::{\n    api_event::{\n        events::ApiLogsResult,\n        filters::ApiEventFilter,\n        metrics::{latency::LatencyAvg, ApiEventMetricRow},\n    },\n    auth_events::filters::AuthEventFilterRow,\n    connector_events::events::ConnectorEventsResult,\n    disputes::{filters::DisputeFilterRow, metrics::DisputeMetricRow},\n    outgoing_webhook_event::events::OutgoingWebhookLogsResult,\n    routing_events::events::RoutingEventsResult,\n    sdk_events::events::SdkEventsResult,\n    types::TableEngine,\n};\n\npub type ClickhouseResult<T> = error_stack::Result<T, ClickhouseError>;\n\n#[derive(Clone, Debug)]\npub struct ClickhouseClient {\n    pub config: Arc<ClickhouseConfig>,\n    pub database: String,\n}\n\n#[derive(Clone, Debug, serde::Deserialize)]\npub struct ClickhouseConfig {\n    username: String,\n    password: Option<String>,\n    host: String,\n}\n\nimpl Default for ClickhouseConfig {\n    fn default() -> Self {\n        Self {\n            username: \"default\".to_string(),\n            password: None,\n            host: \"http://localhost:8123\".to_string(),\n        }\n    }\n}\n\nimpl Cli\n\n... [truncated 21449 chars] ...\n\n\"row_number() over ({}{}){}\",\n                    partition_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |partition_by| format!(\"partition by {}\", partition_by.to_owned())\n                    ),\n                    order_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |(order_column, order)| format!(\n                            \" order by {} {}\",\n                            order_column.to_owned(),\n                            order\n                        )\n                    ),\n                    alias.map_or_else(|| \"\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n        })\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ClickhouseError {\n    #[error(\"Clickhouse connection error\")]\n    ConnectionError,\n    #[error(\"Clickhouse NON-200 response content: '{0}'\")]\n    ResponseNotOK(String),\n    #[error(\"Clickhouse response error\")]\n    ResponseError,\n}\n", "function_name": "crates__analytics__src__clickhouse.rs", "file": "crates__analytics__src__clickhouse.rs"}, {"query": "analytics clickhouse query execution", "code": "use std::sync::Arc;\n\nuse actix_web::http::StatusCode;\nuse common_utils::errors::ParsingError;\nuse error_stack::{report, Report, ResultExt};\nuse router_env::logger;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    active_payments::metrics::ActivePaymentsMetricRow,\n    auth_events::metrics::AuthEventMetricRow,\n    frm::{filters::FrmFilterRow, metrics::FrmMetricRow},\n    health_check::HealthCheck,\n    payment_intents::{filters::PaymentIntentFilterRow, metrics::PaymentIntentMetricRow},\n    payments::{\n        distribution::PaymentDistributionRow, filters::PaymentFilterRow, metrics::PaymentMetricRow,\n    },\n    query::{Aggregate, ToSql, Window},\n    refunds::{\n        distribution::RefundDistributionRow, filters::RefundFilterRow, metrics::RefundMetricRow,\n    },\n    sdk_events::{filters::SdkEventFilter, metrics::SdkEventMetricRow},\n    types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, QueryExecutionError},\n};\nuse crate::{\n    api_event::{\n        events::ApiLogsResult,\n        filters::ApiEventFilter,\n        metrics::{latency::LatencyAvg, ApiEventMetricRow},\n    },\n    auth_events::filters::AuthEventFilterRow,\n    connector_events::events::ConnectorEventsResult,\n    disputes::{filters::DisputeFilterRow, metrics::DisputeMetricRow},\n    outgoing_webhook_event::events::OutgoingWebhookLogsResult,\n    routing_events::events::RoutingEventsResult,\n    sdk_events::events::SdkEventsResult,\n    types::TableEngine,\n};\n\npub type ClickhouseResult<T> = error_stack::Result<T, ClickhouseError>;\n\n#[derive(Clone, Debug)]\npub struct ClickhouseClient {\n    pub config: Arc<ClickhouseConfig>,\n    pub database: String,\n}\n\n#[derive(Clone, Debug, serde::Deserialize)]\npub struct ClickhouseConfig {\n    username: String,\n    password: Option<String>,\n    host: String,\n}\n\nimpl Default for ClickhouseConfig {\n    fn default() -> Self {\n        Self {\n            username: \"default\".to_string(),\n            password: None,\n            host: \"http://localhost:8123\".to_string(),\n        }\n    }\n}\n\nimpl Cli\n\n... [truncated 21449 chars] ...\n\n\"row_number() over ({}{}){}\",\n                    partition_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |partition_by| format!(\"partition by {}\", partition_by.to_owned())\n                    ),\n                    order_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |(order_column, order)| format!(\n                            \" order by {} {}\",\n                            order_column.to_owned(),\n                            order\n                        )\n                    ),\n                    alias.map_or_else(|| \"\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n        })\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ClickhouseError {\n    #[error(\"Clickhouse connection error\")]\n    ConnectionError,\n    #[error(\"Clickhouse NON-200 response content: '{0}'\")]\n    ResponseNotOK(String),\n    #[error(\"Clickhouse response error\")]\n    ResponseError,\n}\n", "function_name": "crates__analytics__src__clickhouse.rs", "file": "crates__analytics__src__clickhouse.rs"}, {"query": "how to implement analytics database queries", "code": "use std::{fmt::Display, str::FromStr};\n\nuse api_models::{\n    analytics::{frm::FrmTransactionType, refunds::RefundType},\n    enums::{DisputeStage, DisputeStatus},\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    DbConnectionParams,\n};\nuse diesel_models::enums::{\n    AttemptStatus, AuthenticationType, Currency, FraudCheckStatus, IntentStatus, PaymentMethod,\n    RefundStatus, RoutingApproach,\n};\nuse error_stack::ResultExt;\nuse sqlx::{\n    postgres::{PgArgumentBuffer, PgPoolOptions, PgRow, PgTypeInfo, PgValueRef},\n    Decode, Encode,\n    Error::ColumnNotFound,\n    FromRow, Pool, Postgres, Row,\n};\nuse storage_impl::config::Database;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    health_check::HealthCheck,\n    query::{Aggregate, ToSql, Window},\n    types::{\n        AnalyticsCollection, AnalyticsDataSource, DBEnumWrapper, LoadRow, QueryExecutionError,\n        TableEngine,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct SqlxClient {\n    pool: Pool<Postgres>,\n}\n\nimpl Default for SqlxClient {\n    fn default() -> Self {\n        let database_url = format!(\n            \"postgres://{}:{}@{}:{}/{}\",\n            \"db_user\", \"db_pass\", \"localhost\", 5432, \"hyperswitch_db\"\n        );\n        Self {\n            #[allow(clippy::expect_used)]\n            pool: PgPoolOptions::new()\n                .connect_lazy(&database_url)\n                .expect(\"SQLX Pool Creation failed\"),\n        }\n    }\n}\n\nimpl SqlxClient {\n    pub async fn from_conf(conf: &Database, schema: &str) -> Self {\n        let database_url = conf.get_database_url(schema);\n        #[allow(clippy::expect_used)]\n        let pool = PgPoolOptions::new()\n            .max_connections(conf.pool_size)\n            .acquire_timeout(std::time::Duration::from_secs(conf.connection_timeout))\n            .connect_lazy(&database_url)\n            .expect(\"SQLX Pool Creation failed\");\n        Self { pool }\n    }\n\n... [truncated 62901 chars] ...\n\n\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n            Self::RowNumber {\n                field: _,\n                partition_by,\n                order_by,\n                alias,\n            } => {\n                format!(\n                    \"row_number() over ({}{}){}\",\n                    partition_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |partition_by| format!(\"partition by {}\", partition_by.to_owned())\n                    ),\n                    order_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |(order_column, order)| format!(\n                            \" order by {} {}\",\n                            order_column.to_owned(),\n                            order\n                        )\n                    ),\n                    alias.map_or_else(|| \"\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n        })\n    }\n}\n", "function_name": "crates__analytics__src__sqlx.rs", "file": "crates__analytics__src__sqlx.rs"}, {"query": "SQLx PostgreSQL connection pool", "code": "use std::{fmt::Display, str::FromStr};\n\nuse api_models::{\n    analytics::{frm::FrmTransactionType, refunds::RefundType},\n    enums::{DisputeStage, DisputeStatus},\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    DbConnectionParams,\n};\nuse diesel_models::enums::{\n    AttemptStatus, AuthenticationType, Currency, FraudCheckStatus, IntentStatus, PaymentMethod,\n    RefundStatus, RoutingApproach,\n};\nuse error_stack::ResultExt;\nuse sqlx::{\n    postgres::{PgArgumentBuffer, PgPoolOptions, PgRow, PgTypeInfo, PgValueRef},\n    Decode, Encode,\n    Error::ColumnNotFound,\n    FromRow, Pool, Postgres, Row,\n};\nuse storage_impl::config::Database;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    health_check::HealthCheck,\n    query::{Aggregate, ToSql, Window},\n    types::{\n        AnalyticsCollection, AnalyticsDataSource, DBEnumWrapper, LoadRow, QueryExecutionError,\n        TableEngine,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct SqlxClient {\n    pool: Pool<Postgres>,\n}\n\nimpl Default for SqlxClient {\n    fn default() -> Self {\n        let database_url = format!(\n            \"postgres://{}:{}@{}:{}/{}\",\n            \"db_user\", \"db_pass\", \"localhost\", 5432, \"hyperswitch_db\"\n        );\n        Self {\n            #[allow(clippy::expect_used)]\n            pool: PgPoolOptions::new()\n                .connect_lazy(&database_url)\n                .expect(\"SQLX Pool Creation failed\"),\n        }\n    }\n}\n\nimpl SqlxClient {\n    pub async fn from_conf(conf: &Database, schema: &str) -> Self {\n        let database_url = conf.get_database_url(schema);\n        #[allow(clippy::expect_used)]\n        let pool = PgPoolOptions::new()\n            .max_connections(conf.pool_size)\n            .acquire_timeout(std::time::Duration::from_secs(conf.connection_timeout))\n            .connect_lazy(&database_url)\n            .expect(\"SQLX Pool Creation failed\");\n        Self { pool }\n    }\n\n... [truncated 62901 chars] ...\n\n\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n            Self::RowNumber {\n                field: _,\n                partition_by,\n                order_by,\n                alias,\n            } => {\n                format!(\n                    \"row_number() over ({}{}){}\",\n                    partition_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |partition_by| format!(\"partition by {}\", partition_by.to_owned())\n                    ),\n                    order_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |(order_column, order)| format!(\n                            \" order by {} {}\",\n                            order_column.to_owned(),\n                            order\n                        )\n                    ),\n                    alias.map_or_else(|| \"\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n        })\n    }\n}\n", "function_name": "crates__analytics__src__sqlx.rs", "file": "crates__analytics__src__sqlx.rs"}, {"query": "DBEnumWrapper encode decode", "code": "use std::{fmt::Display, str::FromStr};\n\nuse api_models::{\n    analytics::{frm::FrmTransactionType, refunds::RefundType},\n    enums::{DisputeStage, DisputeStatus},\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    DbConnectionParams,\n};\nuse diesel_models::enums::{\n    AttemptStatus, AuthenticationType, Currency, FraudCheckStatus, IntentStatus, PaymentMethod,\n    RefundStatus, RoutingApproach,\n};\nuse error_stack::ResultExt;\nuse sqlx::{\n    postgres::{PgArgumentBuffer, PgPoolOptions, PgRow, PgTypeInfo, PgValueRef},\n    Decode, Encode,\n    Error::ColumnNotFound,\n    FromRow, Pool, Postgres, Row,\n};\nuse storage_impl::config::Database;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    health_check::HealthCheck,\n    query::{Aggregate, ToSql, Window},\n    types::{\n        AnalyticsCollection, AnalyticsDataSource, DBEnumWrapper, LoadRow, QueryExecutionError,\n        TableEngine,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct SqlxClient {\n    pool: Pool<Postgres>,\n}\n\nimpl Default for SqlxClient {\n    fn default() -> Self {\n        let database_url = format!(\n            \"postgres://{}:{}@{}:{}/{}\",\n            \"db_user\", \"db_pass\", \"localhost\", 5432, \"hyperswitch_db\"\n        );\n        Self {\n            #[allow(clippy::expect_used)]\n            pool: PgPoolOptions::new()\n                .connect_lazy(&database_url)\n                .expect(\"SQLX Pool Creation failed\"),\n        }\n    }\n}\n\nimpl SqlxClient {\n    pub async fn from_conf(conf: &Database, schema: &str) -> Self {\n        let database_url = conf.get_database_url(schema);\n        #[allow(clippy::expect_used)]\n        let pool = PgPoolOptions::new()\n            .max_connections(conf.pool_size)\n            .acquire_timeout(std::time::Duration::from_secs(conf.connection_timeout))\n            .connect_lazy(&database_url)\n            .expect(\"SQLX Pool Creation failed\");\n        Self { pool }\n    }\n\n... [truncated 62901 chars] ...\n\n\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n            Self::RowNumber {\n                field: _,\n                partition_by,\n                order_by,\n                alias,\n            } => {\n                format!(\n                    \"row_number() over ({}{}){}\",\n                    partition_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |partition_by| format!(\"partition by {}\", partition_by.to_owned())\n                    ),\n                    order_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |(order_column, order)| format!(\n                            \" order by {} {}\",\n                            order_column.to_owned(),\n                            order\n                        )\n                    ),\n                    alias.map_or_else(|| \"\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n        })\n    }\n}\n", "function_name": "crates__analytics__src__sqlx.rs", "file": "crates__analytics__src__sqlx.rs"}, {"query": "aggregate SQL query builder", "code": "use std::{fmt::Display, str::FromStr};\n\nuse api_models::{\n    analytics::{frm::FrmTransactionType, refunds::RefundType},\n    enums::{DisputeStage, DisputeStatus},\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    DbConnectionParams,\n};\nuse diesel_models::enums::{\n    AttemptStatus, AuthenticationType, Currency, FraudCheckStatus, IntentStatus, PaymentMethod,\n    RefundStatus, RoutingApproach,\n};\nuse error_stack::ResultExt;\nuse sqlx::{\n    postgres::{PgArgumentBuffer, PgPoolOptions, PgRow, PgTypeInfo, PgValueRef},\n    Decode, Encode,\n    Error::ColumnNotFound,\n    FromRow, Pool, Postgres, Row,\n};\nuse storage_impl::config::Database;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    health_check::HealthCheck,\n    query::{Aggregate, ToSql, Window},\n    types::{\n        AnalyticsCollection, AnalyticsDataSource, DBEnumWrapper, LoadRow, QueryExecutionError,\n        TableEngine,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct SqlxClient {\n    pool: Pool<Postgres>,\n}\n\nimpl Default for SqlxClient {\n    fn default() -> Self {\n        let database_url = format!(\n            \"postgres://{}:{}@{}:{}/{}\",\n            \"db_user\", \"db_pass\", \"localhost\", 5432, \"hyperswitch_db\"\n        );\n        Self {\n            #[allow(clippy::expect_used)]\n            pool: PgPoolOptions::new()\n                .connect_lazy(&database_url)\n                .expect(\"SQLX Pool Creation failed\"),\n        }\n    }\n}\n\nimpl SqlxClient {\n    pub async fn from_conf(conf: &Database, schema: &str) -> Self {\n        let database_url = conf.get_database_url(schema);\n        #[allow(clippy::expect_used)]\n        let pool = PgPoolOptions::new()\n            .max_connections(conf.pool_size)\n            .acquire_timeout(std::time::Duration::from_secs(conf.connection_timeout))\n            .connect_lazy(&database_url)\n            .expect(\"SQLX Pool Creation failed\");\n        Self { pool }\n    }\n\n... [truncated 62901 chars] ...\n\n\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n            Self::RowNumber {\n                field: _,\n                partition_by,\n                order_by,\n                alias,\n            } => {\n                format!(\n                    \"row_number() over ({}{}){}\",\n                    partition_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |partition_by| format!(\"partition by {}\", partition_by.to_owned())\n                    ),\n                    order_by.as_ref().map_or_else(\n                        || \"\".to_owned(),\n                        |(order_column, order)| format!(\n                            \" order by {} {}\",\n                            order_column.to_owned(),\n                            order\n                        )\n                    ),\n                    alias.map_or_else(|| \"\".to_owned(), |alias| format!(\" as {alias}\"))\n                )\n            }\n        })\n    }\n}\n", "function_name": "crates__analytics__src__sqlx.rs", "file": "crates__analytics__src__sqlx.rs"}, {"query": "Gigadat payment connector implementation", "code": "pub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    crypto::Encryptable,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoCreate, PoFulfill, PoQuote, PoSync},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCreateType, PayoutFulfillType, PayoutQuoteType, PayoutSyncType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts as api_consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\n#[cfg(feature = \"payouts\")]\nuse\n\n... [truncated 34417 chars] ...\n\nransfer\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n    static ref GIGADAT_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = {\n        #[cfg(feature = \"payouts\")]\n        {\n            let mut flows = vec![enums::EventClass::Payments];\n            flows.push(enums::EventClass::Payouts);\n            flows\n        }\n        #[cfg(not(feature = \"payouts\"))]\n        {\n            vec![enums::EventClass::Payments]\n        }\n    };\n}\n\nimpl ConnectorSpecifications for Gigadat {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*GIGADAT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GIGADAT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*GIGADAT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "file": "crates__hyperswitch_connectors__src__connectors__gigadat.rs"}, {"query": "how to integrate Gigadat with Hyperswitch", "code": "pub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    crypto::Encryptable,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoCreate, PoFulfill, PoQuote, PoSync},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCreateType, PayoutFulfillType, PayoutQuoteType, PayoutSyncType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts as api_consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\n#[cfg(feature = \"payouts\")]\nuse\n\n... [truncated 34417 chars] ...\n\nransfer\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n    static ref GIGADAT_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = {\n        #[cfg(feature = \"payouts\")]\n        {\n            let mut flows = vec![enums::EventClass::Payments];\n            flows.push(enums::EventClass::Payouts);\n            flows\n        }\n        #[cfg(not(feature = \"payouts\"))]\n        {\n            vec![enums::EventClass::Payments]\n        }\n    };\n}\n\nimpl ConnectorSpecifications for Gigadat {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*GIGADAT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GIGADAT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*GIGADAT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "file": "crates__hyperswitch_connectors__src__connectors__gigadat.rs"}, {"query": "Interac e-Transfer payment gateway Rust", "code": "pub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    crypto::Encryptable,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoCreate, PoFulfill, PoQuote, PoSync},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCreateType, PayoutFulfillType, PayoutQuoteType, PayoutSyncType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts as api_consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\n#[cfg(feature = \"payouts\")]\nuse\n\n... [truncated 34417 chars] ...\n\nransfer\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n    static ref GIGADAT_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = {\n        #[cfg(feature = \"payouts\")]\n        {\n            let mut flows = vec![enums::EventClass::Payments];\n            flows.push(enums::EventClass::Payouts);\n            flows\n        }\n        #[cfg(not(feature = \"payouts\"))]\n        {\n            vec![enums::EventClass::Payments]\n        }\n    };\n}\n\nimpl ConnectorSpecifications for Gigadat {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*GIGADAT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GIGADAT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*GIGADAT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "file": "crates__hyperswitch_connectors__src__connectors__gigadat.rs"}, {"query": "Gigadat connector API traits", "code": "pub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    crypto::Encryptable,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoCreate, PoFulfill, PoQuote, PoSync},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCreateType, PayoutFulfillType, PayoutQuoteType, PayoutSyncType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts as api_consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\n#[cfg(feature = \"payouts\")]\nuse\n\n... [truncated 34417 chars] ...\n\nransfer\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n    static ref GIGADAT_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = {\n        #[cfg(feature = \"payouts\")]\n        {\n            let mut flows = vec![enums::EventClass::Payments];\n            flows.push(enums::EventClass::Payouts);\n            flows\n        }\n        #[cfg(not(feature = \"payouts\"))]\n        {\n            vec![enums::EventClass::Payments]\n        }\n    };\n}\n\nimpl ConnectorSpecifications for Gigadat {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*GIGADAT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GIGADAT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*GIGADAT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "file": "crates__hyperswitch_connectors__src__connectors__gigadat.rs"}, {"query": "hyperswitch stax connector implementation", "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as stax;\n\nuse self::stax::StaxWebhookEventType;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n#[derive(Debug, Clone)]\npub struct Stax;\n\nimpl api::Payment for Stax {}\nimpl api::\n\n... [truncated 32374 chars] ...\n\nent processing platform that helps businesses accept payments and manage their payment ecosystem \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic STAX_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Stax {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STAX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*STAX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&STAX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stax.rs", "file": "crates__hyperswitch_connectors__src__connectors__stax.rs"}, {"query": "Stax payment gateway integration rust", "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as stax;\n\nuse self::stax::StaxWebhookEventType;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n#[derive(Debug, Clone)]\npub struct Stax;\n\nimpl api::Payment for Stax {}\nimpl api::\n\n... [truncated 32374 chars] ...\n\nent processing platform that helps businesses accept payments and manage their payment ecosystem \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic STAX_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Stax {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STAX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*STAX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&STAX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stax.rs", "file": "crates__hyperswitch_connectors__src__connectors__stax.rs"}, {"query": "how to implement Stax payment connector", "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as stax;\n\nuse self::stax::StaxWebhookEventType;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n#[derive(Debug, Clone)]\npub struct Stax;\n\nimpl api::Payment for Stax {}\nimpl api::\n\n... [truncated 32374 chars] ...\n\nent processing platform that helps businesses accept payments and manage their payment ecosystem \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic STAX_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Stax {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STAX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*STAX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&STAX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stax.rs", "file": "crates__hyperswitch_connectors__src__connectors__stax.rs"}, {"query": "hyperswitch stax webhook handling", "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as stax;\n\nuse self::stax::StaxWebhookEventType;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n#[derive(Debug, Clone)]\npub struct Stax;\n\nimpl api::Payment for Stax {}\nimpl api::\n\n... [truncated 32374 chars] ...\n\nent processing platform that helps businesses accept payments and manage their payment ecosystem \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic STAX_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Stax {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STAX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*STAX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&STAX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stax.rs", "file": "crates__hyperswitch_connectors__src__connectors__stax.rs"}, {"query": "how does itaubank connector work", "code": "pub mod transformers;\nuse std::{fmt::Write, sync::LazyLock};\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{ACCEPT_HEADER, NO_ERROR_CODE, NO_ERROR_MESSAGE, USER_AGENT},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::PeekInterface;\nuse transformers as itaubank;\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{convert_amount, RefundsRequestData},\n};\n\n\n\n... [truncated 26904 chars] ...\n\nsupported_payment_methods\n    });\n\nstatic ITAUBANK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Itaubank\",\n        description: \"Itau Bank is a leading Brazilian financial institution offering a wide range of banking services, including retail banking, loans, and investment solutions.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic ITAUBANK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Itaubank {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ITAUBANK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ITAUBANK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ITAUBANK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__itaubank.rs", "file": "crates__hyperswitch_connectors__src__connectors__itaubank.rs"}, {"query": "Itaubank struct implementation", "code": "pub mod transformers;\nuse std::{fmt::Write, sync::LazyLock};\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{ACCEPT_HEADER, NO_ERROR_CODE, NO_ERROR_MESSAGE, USER_AGENT},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::PeekInterface;\nuse transformers as itaubank;\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{convert_amount, RefundsRequestData},\n};\n\n\n\n... [truncated 26904 chars] ...\n\nsupported_payment_methods\n    });\n\nstatic ITAUBANK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Itaubank\",\n        description: \"Itau Bank is a leading Brazilian financial institution offering a wide range of banking services, including retail banking, loans, and investment solutions.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic ITAUBANK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Itaubank {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ITAUBANK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ITAUBANK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ITAUBANK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__itaubank.rs", "file": "crates__hyperswitch_connectors__src__connectors__itaubank.rs"}, {"query": "implement pix payment connector", "code": "pub mod transformers;\nuse std::{fmt::Write, sync::LazyLock};\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{ACCEPT_HEADER, NO_ERROR_CODE, NO_ERROR_MESSAGE, USER_AGENT},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::PeekInterface;\nuse transformers as itaubank;\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{convert_amount, RefundsRequestData},\n};\n\n\n\n... [truncated 26904 chars] ...\n\nsupported_payment_methods\n    });\n\nstatic ITAUBANK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Itaubank\",\n        description: \"Itau Bank is a leading Brazilian financial institution offering a wide range of banking services, including retail banking, loans, and investment solutions.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic ITAUBANK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Itaubank {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ITAUBANK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ITAUBANK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ITAUBANK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__itaubank.rs", "file": "crates__hyperswitch_connectors__src__connectors__itaubank.rs"}, {"query": "hyperswitch itau bank integration", "code": "pub mod transformers;\nuse std::{fmt::Write, sync::LazyLock};\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{ACCEPT_HEADER, NO_ERROR_CODE, NO_ERROR_MESSAGE, USER_AGENT},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::PeekInterface;\nuse transformers as itaubank;\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{convert_amount, RefundsRequestData},\n};\n\n\n\n... [truncated 26904 chars] ...\n\nsupported_payment_methods\n    });\n\nstatic ITAUBANK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Itaubank\",\n        description: \"Itau Bank is a leading Brazilian financial institution offering a wide range of banking services, including retail banking, loans, and investment solutions.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic ITAUBANK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Itaubank {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ITAUBANK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ITAUBANK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ITAUBANK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__itaubank.rs", "file": "crates__hyperswitch_connectors__src__connectors__itaubank.rs"}, {"query": "how to configure payment connectors in hyperswitch", "code": "use std::{\n    collections::{HashMap, HashSet},\n    path::PathBuf,\n    sync::Arc,\n};\n\n#[cfg(feature = \"olap\")]\nuse analytics::{opensearch::OpenSearchConfig, ReportConfig};\nuse api_models::enums;\nuse common_enums;\nuse common_utils::{ext_traits::ConfigExt, id_type, types::user::EmailThemeConfig};\nuse config::{Environment, File};\nuse error_stack::ResultExt;\n#[cfg(feature = \"email\")]\nuse external_services::email::EmailSettings;\nuse external_services::{\n    crm::CrmManagerConfig,\n    file_storage::FileStorageConfig,\n    grpc_client::GrpcClientSettings,\n    managers::{\n        encryption_management::EncryptionManagementConfig,\n        secrets_management::SecretsManagementConfig,\n    },\n    superposition::SuperpositionClientConfig,\n};\npub use hyperswitch_interfaces::{\n    configs::{\n        Connectors, GlobalTenant, InternalMerchantIdProfileIdAuthSettings, InternalServicesConfig,\n        Tenant, TenantUserConfig,\n    },\n    secrets_interface::secret_state::{\n        RawSecret, SecretState, SecretStateContainer, SecuredSecret,\n    },\n    types::{ComparisonServiceConfig, Proxy},\n};\nuse masking::{Maskable, Secret};\npub use payment_methods::configs::settings::{\n    BankRedirectConfig, BanksVector, ConnectorBankNames, ConnectorFields, EligiblePaymentMethods,\n    Mandates, PaymentMethodAuth, PaymentMethodType, RequiredFieldFinal, RequiredFields,\n    SupportedConnectorsForMandate, SupportedPaymentMethodTypesForMandate,\n    SupportedPaymentMethodsForMandate, ZeroMandates,\n};\nuse payment_methods::configs::MicroServicesConfig;\nuse rand::seq::IteratorRandom;\nuse redis_interface::RedisSettings;\npub use router_env::config::{Log, LogConsole, LogFile, LogTelemetry};\nuse rust_decimal::Decimal;\nuse scheduler::SchedulerSettings;\nuse serde::Deserialize;\nuse storage_impl::config::QueueStrategy;\n\n#[cfg(feature = \"olap\")]\nuse crate::analytics::{AnalyticsConfig, AnalyticsProvider};\n#[cfg(feature = \"v2\")]\nuse crate::types::storage::revenue_recovery;\nuse crate::{\n    configs,\n    core::errors::{ApplicationE\n\n... [truncated 54427 chars] ...\n\n test_payment_method_hashset_deserializer_with_spaces() {\n        use diesel_models::enums::PaymentMethod;\n\n        let deserializer: StrDeserializer<'_, ValueError> =\n            \"wallet, card, bank_debit\".into_deserializer();\n        let payment_methods = deserialize_hashset::<'_, _, PaymentMethod>(deserializer);\n        let expected_payment_methods = HashSet::from([\n            PaymentMethod::Wallet,\n            PaymentMethod::Card,\n            PaymentMethod::BankDebit,\n        ]);\n\n        assert!(payment_methods.is_ok());\n        assert_eq!(payment_methods.unwrap(), expected_payment_methods);\n    }\n\n    #[test]\n    fn test_payment_method_hashset_deserializer_error() {\n        use diesel_models::enums::PaymentMethod;\n\n        let deserializer: StrDeserializer<'_, ValueError> =\n            \"wallet, card, unknown\".into_deserializer();\n        let payment_methods = deserialize_hashset::<'_, _, PaymentMethod>(deserializer);\n\n        assert!(payment_methods.is_err());\n    }\n}\n", "function_name": "crates__router__src__configs__settings.rs", "file": "crates__router__src__configs__settings.rs"}, {"query": "settings struct definition rust", "code": "use std::{\n    collections::{HashMap, HashSet},\n    path::PathBuf,\n    sync::Arc,\n};\n\n#[cfg(feature = \"olap\")]\nuse analytics::{opensearch::OpenSearchConfig, ReportConfig};\nuse api_models::enums;\nuse common_enums;\nuse common_utils::{ext_traits::ConfigExt, id_type, types::user::EmailThemeConfig};\nuse config::{Environment, File};\nuse error_stack::ResultExt;\n#[cfg(feature = \"email\")]\nuse external_services::email::EmailSettings;\nuse external_services::{\n    crm::CrmManagerConfig,\n    file_storage::FileStorageConfig,\n    grpc_client::GrpcClientSettings,\n    managers::{\n        encryption_management::EncryptionManagementConfig,\n        secrets_management::SecretsManagementConfig,\n    },\n    superposition::SuperpositionClientConfig,\n};\npub use hyperswitch_interfaces::{\n    configs::{\n        Connectors, GlobalTenant, InternalMerchantIdProfileIdAuthSettings, InternalServicesConfig,\n        Tenant, TenantUserConfig,\n    },\n    secrets_interface::secret_state::{\n        RawSecret, SecretState, SecretStateContainer, SecuredSecret,\n    },\n    types::{ComparisonServiceConfig, Proxy},\n};\nuse masking::{Maskable, Secret};\npub use payment_methods::configs::settings::{\n    BankRedirectConfig, BanksVector, ConnectorBankNames, ConnectorFields, EligiblePaymentMethods,\n    Mandates, PaymentMethodAuth, PaymentMethodType, RequiredFieldFinal, RequiredFields,\n    SupportedConnectorsForMandate, SupportedPaymentMethodTypesForMandate,\n    SupportedPaymentMethodsForMandate, ZeroMandates,\n};\nuse payment_methods::configs::MicroServicesConfig;\nuse rand::seq::IteratorRandom;\nuse redis_interface::RedisSettings;\npub use router_env::config::{Log, LogConsole, LogFile, LogTelemetry};\nuse rust_decimal::Decimal;\nuse scheduler::SchedulerSettings;\nuse serde::Deserialize;\nuse storage_impl::config::QueueStrategy;\n\n#[cfg(feature = \"olap\")]\nuse crate::analytics::{AnalyticsConfig, AnalyticsProvider};\n#[cfg(feature = \"v2\")]\nuse crate::types::storage::revenue_recovery;\nuse crate::{\n    configs,\n    core::errors::{ApplicationE\n\n... [truncated 54427 chars] ...\n\n test_payment_method_hashset_deserializer_with_spaces() {\n        use diesel_models::enums::PaymentMethod;\n\n        let deserializer: StrDeserializer<'_, ValueError> =\n            \"wallet, card, bank_debit\".into_deserializer();\n        let payment_methods = deserialize_hashset::<'_, _, PaymentMethod>(deserializer);\n        let expected_payment_methods = HashSet::from([\n            PaymentMethod::Wallet,\n            PaymentMethod::Card,\n            PaymentMethod::BankDebit,\n        ]);\n\n        assert!(payment_methods.is_ok());\n        assert_eq!(payment_methods.unwrap(), expected_payment_methods);\n    }\n\n    #[test]\n    fn test_payment_method_hashset_deserializer_error() {\n        use diesel_models::enums::PaymentMethod;\n\n        let deserializer: StrDeserializer<'_, ValueError> =\n            \"wallet, card, unknown\".into_deserializer();\n        let payment_methods = deserialize_hashset::<'_, _, PaymentMethod>(deserializer);\n\n        assert!(payment_methods.is_err());\n    }\n}\n", "function_name": "crates__router__src__configs__settings.rs", "file": "crates__router__src__configs__settings.rs"}, {"query": "how to initialize hyperswitch router configuration", "code": "use std::{\n    collections::{HashMap, HashSet},\n    path::PathBuf,\n    sync::Arc,\n};\n\n#[cfg(feature = \"olap\")]\nuse analytics::{opensearch::OpenSearchConfig, ReportConfig};\nuse api_models::enums;\nuse common_enums;\nuse common_utils::{ext_traits::ConfigExt, id_type, types::user::EmailThemeConfig};\nuse config::{Environment, File};\nuse error_stack::ResultExt;\n#[cfg(feature = \"email\")]\nuse external_services::email::EmailSettings;\nuse external_services::{\n    crm::CrmManagerConfig,\n    file_storage::FileStorageConfig,\n    grpc_client::GrpcClientSettings,\n    managers::{\n        encryption_management::EncryptionManagementConfig,\n        secrets_management::SecretsManagementConfig,\n    },\n    superposition::SuperpositionClientConfig,\n};\npub use hyperswitch_interfaces::{\n    configs::{\n        Connectors, GlobalTenant, InternalMerchantIdProfileIdAuthSettings, InternalServicesConfig,\n        Tenant, TenantUserConfig,\n    },\n    secrets_interface::secret_state::{\n        RawSecret, SecretState, SecretStateContainer, SecuredSecret,\n    },\n    types::{ComparisonServiceConfig, Proxy},\n};\nuse masking::{Maskable, Secret};\npub use payment_methods::configs::settings::{\n    BankRedirectConfig, BanksVector, ConnectorBankNames, ConnectorFields, EligiblePaymentMethods,\n    Mandates, PaymentMethodAuth, PaymentMethodType, RequiredFieldFinal, RequiredFields,\n    SupportedConnectorsForMandate, SupportedPaymentMethodTypesForMandate,\n    SupportedPaymentMethodsForMandate, ZeroMandates,\n};\nuse payment_methods::configs::MicroServicesConfig;\nuse rand::seq::IteratorRandom;\nuse redis_interface::RedisSettings;\npub use router_env::config::{Log, LogConsole, LogFile, LogTelemetry};\nuse rust_decimal::Decimal;\nuse scheduler::SchedulerSettings;\nuse serde::Deserialize;\nuse storage_impl::config::QueueStrategy;\n\n#[cfg(feature = \"olap\")]\nuse crate::analytics::{AnalyticsConfig, AnalyticsProvider};\n#[cfg(feature = \"v2\")]\nuse crate::types::storage::revenue_recovery;\nuse crate::{\n    configs,\n    core::errors::{ApplicationE\n\n... [truncated 54427 chars] ...\n\n test_payment_method_hashset_deserializer_with_spaces() {\n        use diesel_models::enums::PaymentMethod;\n\n        let deserializer: StrDeserializer<'_, ValueError> =\n            \"wallet, card, bank_debit\".into_deserializer();\n        let payment_methods = deserialize_hashset::<'_, _, PaymentMethod>(deserializer);\n        let expected_payment_methods = HashSet::from([\n            PaymentMethod::Wallet,\n            PaymentMethod::Card,\n            PaymentMethod::BankDebit,\n        ]);\n\n        assert!(payment_methods.is_ok());\n        assert_eq!(payment_methods.unwrap(), expected_payment_methods);\n    }\n\n    #[test]\n    fn test_payment_method_hashset_deserializer_error() {\n        use diesel_models::enums::PaymentMethod;\n\n        let deserializer: StrDeserializer<'_, ValueError> =\n            \"wallet, card, unknown\".into_deserializer();\n        let payment_methods = deserialize_hashset::<'_, _, PaymentMethod>(deserializer);\n\n        assert!(payment_methods.is_err());\n    }\n}\n", "function_name": "crates__router__src__configs__settings.rs", "file": "crates__router__src__configs__settings.rs"}, {"query": "payment method configuration deserialization", "code": "use std::{\n    collections::{HashMap, HashSet},\n    path::PathBuf,\n    sync::Arc,\n};\n\n#[cfg(feature = \"olap\")]\nuse analytics::{opensearch::OpenSearchConfig, ReportConfig};\nuse api_models::enums;\nuse common_enums;\nuse common_utils::{ext_traits::ConfigExt, id_type, types::user::EmailThemeConfig};\nuse config::{Environment, File};\nuse error_stack::ResultExt;\n#[cfg(feature = \"email\")]\nuse external_services::email::EmailSettings;\nuse external_services::{\n    crm::CrmManagerConfig,\n    file_storage::FileStorageConfig,\n    grpc_client::GrpcClientSettings,\n    managers::{\n        encryption_management::EncryptionManagementConfig,\n        secrets_management::SecretsManagementConfig,\n    },\n    superposition::SuperpositionClientConfig,\n};\npub use hyperswitch_interfaces::{\n    configs::{\n        Connectors, GlobalTenant, InternalMerchantIdProfileIdAuthSettings, InternalServicesConfig,\n        Tenant, TenantUserConfig,\n    },\n    secrets_interface::secret_state::{\n        RawSecret, SecretState, SecretStateContainer, SecuredSecret,\n    },\n    types::{ComparisonServiceConfig, Proxy},\n};\nuse masking::{Maskable, Secret};\npub use payment_methods::configs::settings::{\n    BankRedirectConfig, BanksVector, ConnectorBankNames, ConnectorFields, EligiblePaymentMethods,\n    Mandates, PaymentMethodAuth, PaymentMethodType, RequiredFieldFinal, RequiredFields,\n    SupportedConnectorsForMandate, SupportedPaymentMethodTypesForMandate,\n    SupportedPaymentMethodsForMandate, ZeroMandates,\n};\nuse payment_methods::configs::MicroServicesConfig;\nuse rand::seq::IteratorRandom;\nuse redis_interface::RedisSettings;\npub use router_env::config::{Log, LogConsole, LogFile, LogTelemetry};\nuse rust_decimal::Decimal;\nuse scheduler::SchedulerSettings;\nuse serde::Deserialize;\nuse storage_impl::config::QueueStrategy;\n\n#[cfg(feature = \"olap\")]\nuse crate::analytics::{AnalyticsConfig, AnalyticsProvider};\n#[cfg(feature = \"v2\")]\nuse crate::types::storage::revenue_recovery;\nuse crate::{\n    configs,\n    core::errors::{ApplicationE\n\n... [truncated 54427 chars] ...\n\n test_payment_method_hashset_deserializer_with_spaces() {\n        use diesel_models::enums::PaymentMethod;\n\n        let deserializer: StrDeserializer<'_, ValueError> =\n            \"wallet, card, bank_debit\".into_deserializer();\n        let payment_methods = deserialize_hashset::<'_, _, PaymentMethod>(deserializer);\n        let expected_payment_methods = HashSet::from([\n            PaymentMethod::Wallet,\n            PaymentMethod::Card,\n            PaymentMethod::BankDebit,\n        ]);\n\n        assert!(payment_methods.is_ok());\n        assert_eq!(payment_methods.unwrap(), expected_payment_methods);\n    }\n\n    #[test]\n    fn test_payment_method_hashset_deserializer_error() {\n        use diesel_models::enums::PaymentMethod;\n\n        let deserializer: StrDeserializer<'_, ValueError> =\n            \"wallet, card, unknown\".into_deserializer();\n        let payment_methods = deserialize_hashset::<'_, _, PaymentMethod>(deserializer);\n\n        assert!(payment_methods.is_err());\n    }\n}\n", "function_name": "crates__router__src__configs__settings.rs", "file": "crates__router__src__configs__settings.rs"}, {"query": "Cybersource Decision Manager API integration", "code": "use api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_utils::{pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{FrmCheckoutRouterData, FrmTransactionRouterData, ResponseRouterData},\n    utils::{\n        AddressDetailsData as _, FrmTransactionRouterDataRequest, RouterData as OtherRouterData,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct CybersourcedecisionmanagerRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for CybersourcedecisionmanagerRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CybersourcedecisionmanagerTransactionRequest {\n    decision_information: DecisionInformation,\n    processing_information: TransactionProcessingInformation,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DecisionInformation {\n    decision: TransactionDecision,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TransactionProcessingInformation {\n    action_list: Vec<ActionList>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TransactionDecision {\n    Accept,\n    Reject,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ActionList {\n    Capture,\n    Reverse,\n}\n\n// Auth Struct\npub struct CybersourcedecisionmanagerAuthType {\n    pub(super) api_key: Secret<String>,\n    pub(super) merchant_account: Secret<Stri\n\n... [truncated 14469 chars] ...\n\nn<&'static str> {\n    match card_network {\n        common_enums::CardNetwork::Visa => Some(\"001\"),\n        common_enums::CardNetwork::Mastercard => Some(\"002\"),\n        common_enums::CardNetwork::AmericanExpress => Some(\"003\"),\n        common_enums::CardNetwork::JCB => Some(\"007\"),\n        common_enums::CardNetwork::DinersClub => Some(\"005\"),\n        common_enums::CardNetwork::Discover => Some(\"004\"),\n        common_enums::CardNetwork::CartesBancaires => Some(\"036\"),\n        common_enums::CardNetwork::UnionPay => Some(\"062\"),\n        //\"042\" is the type code for Masetro Cards(International). For Maestro Cards(UK-Domestic) the mapping should be \"024\"\n        common_enums::CardNetwork::Maestro => Some(\"042\"),\n        common_enums::CardNetwork::Interac\n        | common_enums::CardNetwork::RuPay\n        | common_enums::CardNetwork::Star\n        | common_enums::CardNetwork::Accel\n        | common_enums::CardNetwork::Pulse\n        | common_enums::CardNetwork::Nyce => None,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager__transformers.rs"}, {"query": "CybersourcedecisionmanagerTransactionRequest struct", "code": "use api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_utils::{pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{FrmCheckoutRouterData, FrmTransactionRouterData, ResponseRouterData},\n    utils::{\n        AddressDetailsData as _, FrmTransactionRouterDataRequest, RouterData as OtherRouterData,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct CybersourcedecisionmanagerRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for CybersourcedecisionmanagerRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CybersourcedecisionmanagerTransactionRequest {\n    decision_information: DecisionInformation,\n    processing_information: TransactionProcessingInformation,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DecisionInformation {\n    decision: TransactionDecision,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TransactionProcessingInformation {\n    action_list: Vec<ActionList>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TransactionDecision {\n    Accept,\n    Reject,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ActionList {\n    Capture,\n    Reverse,\n}\n\n// Auth Struct\npub struct CybersourcedecisionmanagerAuthType {\n    pub(super) api_key: Secret<String>,\n    pub(super) merchant_account: Secret<Stri\n\n... [truncated 14469 chars] ...\n\nn<&'static str> {\n    match card_network {\n        common_enums::CardNetwork::Visa => Some(\"001\"),\n        common_enums::CardNetwork::Mastercard => Some(\"002\"),\n        common_enums::CardNetwork::AmericanExpress => Some(\"003\"),\n        common_enums::CardNetwork::JCB => Some(\"007\"),\n        common_enums::CardNetwork::DinersClub => Some(\"005\"),\n        common_enums::CardNetwork::Discover => Some(\"004\"),\n        common_enums::CardNetwork::CartesBancaires => Some(\"036\"),\n        common_enums::CardNetwork::UnionPay => Some(\"062\"),\n        //\"042\" is the type code for Masetro Cards(International). For Maestro Cards(UK-Domestic) the mapping should be \"024\"\n        common_enums::CardNetwork::Maestro => Some(\"042\"),\n        common_enums::CardNetwork::Interac\n        | common_enums::CardNetwork::RuPay\n        | common_enums::CardNetwork::Star\n        | common_enums::CardNetwork::Accel\n        | common_enums::CardNetwork::Pulse\n        | common_enums::CardNetwork::Nyce => None,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager__transformers.rs"}, {"query": "transform Cybersource fraud check response", "code": "use api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_utils::{pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{FrmCheckoutRouterData, FrmTransactionRouterData, ResponseRouterData},\n    utils::{\n        AddressDetailsData as _, FrmTransactionRouterDataRequest, RouterData as OtherRouterData,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct CybersourcedecisionmanagerRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for CybersourcedecisionmanagerRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CybersourcedecisionmanagerTransactionRequest {\n    decision_information: DecisionInformation,\n    processing_information: TransactionProcessingInformation,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DecisionInformation {\n    decision: TransactionDecision,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TransactionProcessingInformation {\n    action_list: Vec<ActionList>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TransactionDecision {\n    Accept,\n    Reject,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ActionList {\n    Capture,\n    Reverse,\n}\n\n// Auth Struct\npub struct CybersourcedecisionmanagerAuthType {\n    pub(super) api_key: Secret<String>,\n    pub(super) merchant_account: Secret<Stri\n\n... [truncated 14469 chars] ...\n\nn<&'static str> {\n    match card_network {\n        common_enums::CardNetwork::Visa => Some(\"001\"),\n        common_enums::CardNetwork::Mastercard => Some(\"002\"),\n        common_enums::CardNetwork::AmericanExpress => Some(\"003\"),\n        common_enums::CardNetwork::JCB => Some(\"007\"),\n        common_enums::CardNetwork::DinersClub => Some(\"005\"),\n        common_enums::CardNetwork::Discover => Some(\"004\"),\n        common_enums::CardNetwork::CartesBancaires => Some(\"036\"),\n        common_enums::CardNetwork::UnionPay => Some(\"062\"),\n        //\"042\" is the type code for Masetro Cards(International). For Maestro Cards(UK-Domestic) the mapping should be \"024\"\n        common_enums::CardNetwork::Maestro => Some(\"042\"),\n        common_enums::CardNetwork::Interac\n        | common_enums::CardNetwork::RuPay\n        | common_enums::CardNetwork::Star\n        | common_enums::CardNetwork::Accel\n        | common_enums::CardNetwork::Pulse\n        | common_enums::CardNetwork::Nyce => None,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager__transformers.rs"}, {"query": "how to implement Cybersource fraud detection", "code": "use api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_utils::{pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{FrmCheckoutRouterData, FrmTransactionRouterData, ResponseRouterData},\n    utils::{\n        AddressDetailsData as _, FrmTransactionRouterDataRequest, RouterData as OtherRouterData,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct CybersourcedecisionmanagerRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for CybersourcedecisionmanagerRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CybersourcedecisionmanagerTransactionRequest {\n    decision_information: DecisionInformation,\n    processing_information: TransactionProcessingInformation,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DecisionInformation {\n    decision: TransactionDecision,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TransactionProcessingInformation {\n    action_list: Vec<ActionList>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TransactionDecision {\n    Accept,\n    Reject,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ActionList {\n    Capture,\n    Reverse,\n}\n\n// Auth Struct\npub struct CybersourcedecisionmanagerAuthType {\n    pub(super) api_key: Secret<String>,\n    pub(super) merchant_account: Secret<Stri\n\n... [truncated 14469 chars] ...\n\nn<&'static str> {\n    match card_network {\n        common_enums::CardNetwork::Visa => Some(\"001\"),\n        common_enums::CardNetwork::Mastercard => Some(\"002\"),\n        common_enums::CardNetwork::AmericanExpress => Some(\"003\"),\n        common_enums::CardNetwork::JCB => Some(\"007\"),\n        common_enums::CardNetwork::DinersClub => Some(\"005\"),\n        common_enums::CardNetwork::Discover => Some(\"004\"),\n        common_enums::CardNetwork::CartesBancaires => Some(\"036\"),\n        common_enums::CardNetwork::UnionPay => Some(\"062\"),\n        //\"042\" is the type code for Masetro Cards(International). For Maestro Cards(UK-Domestic) the mapping should be \"024\"\n        common_enums::CardNetwork::Maestro => Some(\"042\"),\n        common_enums::CardNetwork::Interac\n        | common_enums::CardNetwork::RuPay\n        | common_enums::CardNetwork::Star\n        | common_enums::CardNetwork::Accel\n        | common_enums::CardNetwork::Pulse\n        | common_enums::CardNetwork::Nyce => None,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager__transformers.rs"}, {"query": "how to create payment intent", "code": "use api_models::customers::CustomerDocumentDetails;\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_utils::consts::PAYMENTS_LIST_MAX_LIMIT_V2;\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::ParsingError;\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::{Encode, ValueExt};\nuse common_utils::{\n    consts::PAYMENTS_LIST_MAX_LIMIT_V1,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type,\n    pii::{self, Email},\n    type_name,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        CreatedBy, MinorUnit,\n    },\n};\nuse diesel_models::{\n    PaymentIntent as DieselPaymentIntent, PaymentIntentNew as DieselPaymentIntentNew,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{Deserialize, PeekInterface, Secret};\nuse serde::Serialize;\nuse time::PrimitiveDateTime;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::payment_attempt::PaymentAttempt;\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v2\")]\nuse crate::routing;\nuse crate::{\n    behaviour,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{errors, RemoteStorageObject};\n\n#[async_trait::async_trait]\npub trait PaymentIntentInterface {\n    type Error;\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_intent_by_pa\n\n... [truncated 108307 chars] ...\n\nce_3ds_challenge_trigger: self.force_3ds_challenge_trigger,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            extended_return_url: self.return_url,\n            is_payment_id_from_merchant: self.is_payment_id_from_merchant,\n            payment_channel: self.payment_channel,\n            tax_status: self.tax_status,\n            discount_amount: self.discount_amount,\n            order_date: self.order_date,\n            shipping_amount_tax: self.shipping_amount_tax,\n            duty_amount: self.duty_amount,\n            enable_partial_authorization: self.enable_partial_authorization,\n            enable_overcapture: self.enable_overcapture,\n            mit_category: self.mit_category,\n            billing_descriptor: self.billing_descriptor,\n            tokenization: self.tokenization,\n            partner_merchant_identifier_details: self.partner_merchant_identifier_details,\n            state_metadata: self.state_metadata,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "file": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs"}, {"query": "PaymentIntent struct definition", "code": "use api_models::customers::CustomerDocumentDetails;\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_utils::consts::PAYMENTS_LIST_MAX_LIMIT_V2;\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::ParsingError;\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::{Encode, ValueExt};\nuse common_utils::{\n    consts::PAYMENTS_LIST_MAX_LIMIT_V1,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type,\n    pii::{self, Email},\n    type_name,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        CreatedBy, MinorUnit,\n    },\n};\nuse diesel_models::{\n    PaymentIntent as DieselPaymentIntent, PaymentIntentNew as DieselPaymentIntentNew,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{Deserialize, PeekInterface, Secret};\nuse serde::Serialize;\nuse time::PrimitiveDateTime;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::payment_attempt::PaymentAttempt;\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v2\")]\nuse crate::routing;\nuse crate::{\n    behaviour,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{errors, RemoteStorageObject};\n\n#[async_trait::async_trait]\npub trait PaymentIntentInterface {\n    type Error;\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_intent_by_pa\n\n... [truncated 108307 chars] ...\n\nce_3ds_challenge_trigger: self.force_3ds_challenge_trigger,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            extended_return_url: self.return_url,\n            is_payment_id_from_merchant: self.is_payment_id_from_merchant,\n            payment_channel: self.payment_channel,\n            tax_status: self.tax_status,\n            discount_amount: self.discount_amount,\n            order_date: self.order_date,\n            shipping_amount_tax: self.shipping_amount_tax,\n            duty_amount: self.duty_amount,\n            enable_partial_authorization: self.enable_partial_authorization,\n            enable_overcapture: self.enable_overcapture,\n            mit_category: self.mit_category,\n            billing_descriptor: self.billing_descriptor,\n            tokenization: self.tokenization,\n            partner_merchant_identifier_details: self.partner_merchant_identifier_details,\n            state_metadata: self.state_metadata,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "file": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs"}, {"query": "implement payment intent interface", "code": "use api_models::customers::CustomerDocumentDetails;\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_utils::consts::PAYMENTS_LIST_MAX_LIMIT_V2;\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::ParsingError;\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::{Encode, ValueExt};\nuse common_utils::{\n    consts::PAYMENTS_LIST_MAX_LIMIT_V1,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type,\n    pii::{self, Email},\n    type_name,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        CreatedBy, MinorUnit,\n    },\n};\nuse diesel_models::{\n    PaymentIntent as DieselPaymentIntent, PaymentIntentNew as DieselPaymentIntentNew,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{Deserialize, PeekInterface, Secret};\nuse serde::Serialize;\nuse time::PrimitiveDateTime;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::payment_attempt::PaymentAttempt;\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v2\")]\nuse crate::routing;\nuse crate::{\n    behaviour,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{errors, RemoteStorageObject};\n\n#[async_trait::async_trait]\npub trait PaymentIntentInterface {\n    type Error;\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_intent_by_pa\n\n... [truncated 108307 chars] ...\n\nce_3ds_challenge_trigger: self.force_3ds_challenge_trigger,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            extended_return_url: self.return_url,\n            is_payment_id_from_merchant: self.is_payment_id_from_merchant,\n            payment_channel: self.payment_channel,\n            tax_status: self.tax_status,\n            discount_amount: self.discount_amount,\n            order_date: self.order_date,\n            shipping_amount_tax: self.shipping_amount_tax,\n            duty_amount: self.duty_amount,\n            enable_partial_authorization: self.enable_partial_authorization,\n            enable_overcapture: self.enable_overcapture,\n            mit_category: self.mit_category,\n            billing_descriptor: self.billing_descriptor,\n            tokenization: self.tokenization,\n            partner_merchant_identifier_details: self.partner_merchant_identifier_details,\n            state_metadata: self.state_metadata,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "file": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs"}, {"query": "payment orchestration payment intent model", "code": "use api_models::customers::CustomerDocumentDetails;\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_utils::consts::PAYMENTS_LIST_MAX_LIMIT_V2;\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::ParsingError;\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::{Encode, ValueExt};\nuse common_utils::{\n    consts::PAYMENTS_LIST_MAX_LIMIT_V1,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type,\n    pii::{self, Email},\n    type_name,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        CreatedBy, MinorUnit,\n    },\n};\nuse diesel_models::{\n    PaymentIntent as DieselPaymentIntent, PaymentIntentNew as DieselPaymentIntentNew,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{Deserialize, PeekInterface, Secret};\nuse serde::Serialize;\nuse time::PrimitiveDateTime;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::payment_attempt::PaymentAttempt;\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v2\")]\nuse crate::routing;\nuse crate::{\n    behaviour,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{errors, RemoteStorageObject};\n\n#[async_trait::async_trait]\npub trait PaymentIntentInterface {\n    type Error;\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_intent_by_pa\n\n... [truncated 108307 chars] ...\n\nce_3ds_challenge_trigger: self.force_3ds_challenge_trigger,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            extended_return_url: self.return_url,\n            is_payment_id_from_merchant: self.is_payment_id_from_merchant,\n            payment_channel: self.payment_channel,\n            tax_status: self.tax_status,\n            discount_amount: self.discount_amount,\n            order_date: self.order_date,\n            shipping_amount_tax: self.shipping_amount_tax,\n            duty_amount: self.duty_amount,\n            enable_partial_authorization: self.enable_partial_authorization,\n            enable_overcapture: self.enable_overcapture,\n            mit_category: self.mit_category,\n            billing_descriptor: self.billing_descriptor,\n            tokenization: self.tokenization,\n            partner_merchant_identifier_details: self.partner_merchant_identifier_details,\n            state_metadata: self.state_metadata,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "file": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs"}, {"query": "how to validate user email and name", "code": "use std::{\n    collections::HashSet,\n    ops::{Deref, Not},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    admin as admin_api, organization as api_org, user as user_api, user_role as user_role_api,\n};\nuse common_enums::EntityType;\nuse common_utils::{\n    crypto::Encryptable, id_type, new_type::MerchantName, pii, type_name,\n    types::keymanager::Identifier,\n};\nuse diesel_models::{\n    enums::{TotpStatus, UserRoleVersion, UserStatus},\n    organization::{self as diesel_org, Organization, OrganizationBridge},\n    user as storage_user,\n    user_role::{UserRole, UserRoleNew},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::api::ApplicationResponse;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse time::PrimitiveDateTime;\nuse unicode_segmentation::UnicodeSegmentation;\n#[cfg(feature = \"keymanager_create\")]\nuse {base64::Engine, common_utils::types::keymanager::EncryptionTransferRequest};\n\nuse crate::{\n    consts,\n    core::{\n        admin,\n        errors::{UserErrors, UserResult},\n    },\n    db::GlobalStorageInterface,\n    routes::SessionState,\n    services::{\n        self,\n        authentication::{AuthenticationDataWithOrg, UserFromToken},\n    },\n    types::{domain, transformers::ForeignFrom},\n    utils::{self, user::password},\n};\n\npub mod dashboard_metadata;\npub mod decision_manager;\npub use decision_manager::*;\npub mod oidc;\npub mod user_authentication_method;\n\nuse super::{types as domain_types, UserKeyStore};\n\n#[derive(Clone)]\npub struct UserName(Secret<String>);\n\nimpl UserName {\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_char\n\n... [truncated 48640 chars] ...\n\n UserRoleNew {\n            user_id: self.user_id,\n            role_id: self.role_id,\n            status: self.status,\n            created_by: self.created_by,\n            last_modified_by: self.last_modified_by,\n            created_at: self.created_at,\n            last_modified: self.last_modified,\n            org_id: entity.org_id,\n            merchant_id: entity.merchant_id,\n            profile_id: entity.profile_id,\n            entity_id: Some(entity.entity_id),\n            entity_type: Some(entity.entity_type),\n            version: UserRoleVersion::V2,\n            tenant_id: entity.tenant_id,\n        }\n    }\n\n    pub async fn insert_in_v2(self, state: &SessionState) -> UserResult<UserRole> {\n        let entity = self.entity.clone();\n\n        let new_v2_role = self.convert_to_new_v2_role(entity.into());\n\n        state\n            .global_store\n            .insert_user_role(new_v2_role)\n            .await\n            .change_context(UserErrors::InternalServerError)\n    }\n}\n", "function_name": "crates__router__src__types__domain__user.rs", "file": "crates__router__src__types__domain__user.rs"}, {"query": "UserStatus enum definition", "code": "use std::{\n    collections::HashSet,\n    ops::{Deref, Not},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    admin as admin_api, organization as api_org, user as user_api, user_role as user_role_api,\n};\nuse common_enums::EntityType;\nuse common_utils::{\n    crypto::Encryptable, id_type, new_type::MerchantName, pii, type_name,\n    types::keymanager::Identifier,\n};\nuse diesel_models::{\n    enums::{TotpStatus, UserRoleVersion, UserStatus},\n    organization::{self as diesel_org, Organization, OrganizationBridge},\n    user as storage_user,\n    user_role::{UserRole, UserRoleNew},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::api::ApplicationResponse;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse time::PrimitiveDateTime;\nuse unicode_segmentation::UnicodeSegmentation;\n#[cfg(feature = \"keymanager_create\")]\nuse {base64::Engine, common_utils::types::keymanager::EncryptionTransferRequest};\n\nuse crate::{\n    consts,\n    core::{\n        admin,\n        errors::{UserErrors, UserResult},\n    },\n    db::GlobalStorageInterface,\n    routes::SessionState,\n    services::{\n        self,\n        authentication::{AuthenticationDataWithOrg, UserFromToken},\n    },\n    types::{domain, transformers::ForeignFrom},\n    utils::{self, user::password},\n};\n\npub mod dashboard_metadata;\npub mod decision_manager;\npub use decision_manager::*;\npub mod oidc;\npub mod user_authentication_method;\n\nuse super::{types as domain_types, UserKeyStore};\n\n#[derive(Clone)]\npub struct UserName(Secret<String>);\n\nimpl UserName {\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_char\n\n... [truncated 48640 chars] ...\n\n UserRoleNew {\n            user_id: self.user_id,\n            role_id: self.role_id,\n            status: self.status,\n            created_by: self.created_by,\n            last_modified_by: self.last_modified_by,\n            created_at: self.created_at,\n            last_modified: self.last_modified,\n            org_id: entity.org_id,\n            merchant_id: entity.merchant_id,\n            profile_id: entity.profile_id,\n            entity_id: Some(entity.entity_id),\n            entity_type: Some(entity.entity_type),\n            version: UserRoleVersion::V2,\n            tenant_id: entity.tenant_id,\n        }\n    }\n\n    pub async fn insert_in_v2(self, state: &SessionState) -> UserResult<UserRole> {\n        let entity = self.entity.clone();\n\n        let new_v2_role = self.convert_to_new_v2_role(entity.into());\n\n        state\n            .global_store\n            .insert_user_role(new_v2_role)\n            .await\n            .change_context(UserErrors::InternalServerError)\n    }\n}\n", "function_name": "crates__router__src__types__domain__user.rs", "file": "crates__router__src__types__domain__user.rs"}, {"query": "how to convert user role to V2", "code": "use std::{\n    collections::HashSet,\n    ops::{Deref, Not},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    admin as admin_api, organization as api_org, user as user_api, user_role as user_role_api,\n};\nuse common_enums::EntityType;\nuse common_utils::{\n    crypto::Encryptable, id_type, new_type::MerchantName, pii, type_name,\n    types::keymanager::Identifier,\n};\nuse diesel_models::{\n    enums::{TotpStatus, UserRoleVersion, UserStatus},\n    organization::{self as diesel_org, Organization, OrganizationBridge},\n    user as storage_user,\n    user_role::{UserRole, UserRoleNew},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::api::ApplicationResponse;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse time::PrimitiveDateTime;\nuse unicode_segmentation::UnicodeSegmentation;\n#[cfg(feature = \"keymanager_create\")]\nuse {base64::Engine, common_utils::types::keymanager::EncryptionTransferRequest};\n\nuse crate::{\n    consts,\n    core::{\n        admin,\n        errors::{UserErrors, UserResult},\n    },\n    db::GlobalStorageInterface,\n    routes::SessionState,\n    services::{\n        self,\n        authentication::{AuthenticationDataWithOrg, UserFromToken},\n    },\n    types::{domain, transformers::ForeignFrom},\n    utils::{self, user::password},\n};\n\npub mod dashboard_metadata;\npub mod decision_manager;\npub use decision_manager::*;\npub mod oidc;\npub mod user_authentication_method;\n\nuse super::{types as domain_types, UserKeyStore};\n\n#[derive(Clone)]\npub struct UserName(Secret<String>);\n\nimpl UserName {\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_char\n\n... [truncated 48640 chars] ...\n\n UserRoleNew {\n            user_id: self.user_id,\n            role_id: self.role_id,\n            status: self.status,\n            created_by: self.created_by,\n            last_modified_by: self.last_modified_by,\n            created_at: self.created_at,\n            last_modified: self.last_modified,\n            org_id: entity.org_id,\n            merchant_id: entity.merchant_id,\n            profile_id: entity.profile_id,\n            entity_id: Some(entity.entity_id),\n            entity_type: Some(entity.entity_type),\n            version: UserRoleVersion::V2,\n            tenant_id: entity.tenant_id,\n        }\n    }\n\n    pub async fn insert_in_v2(self, state: &SessionState) -> UserResult<UserRole> {\n        let entity = self.entity.clone();\n\n        let new_v2_role = self.convert_to_new_v2_role(entity.into());\n\n        state\n            .global_store\n            .insert_user_role(new_v2_role)\n            .await\n            .change_context(UserErrors::InternalServerError)\n    }\n}\n", "function_name": "crates__router__src__types__domain__user.rs", "file": "crates__router__src__types__domain__user.rs"}, {"query": "user domain types and validation", "code": "use std::{\n    collections::HashSet,\n    ops::{Deref, Not},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    admin as admin_api, organization as api_org, user as user_api, user_role as user_role_api,\n};\nuse common_enums::EntityType;\nuse common_utils::{\n    crypto::Encryptable, id_type, new_type::MerchantName, pii, type_name,\n    types::keymanager::Identifier,\n};\nuse diesel_models::{\n    enums::{TotpStatus, UserRoleVersion, UserStatus},\n    organization::{self as diesel_org, Organization, OrganizationBridge},\n    user as storage_user,\n    user_role::{UserRole, UserRoleNew},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::api::ApplicationResponse;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse time::PrimitiveDateTime;\nuse unicode_segmentation::UnicodeSegmentation;\n#[cfg(feature = \"keymanager_create\")]\nuse {base64::Engine, common_utils::types::keymanager::EncryptionTransferRequest};\n\nuse crate::{\n    consts,\n    core::{\n        admin,\n        errors::{UserErrors, UserResult},\n    },\n    db::GlobalStorageInterface,\n    routes::SessionState,\n    services::{\n        self,\n        authentication::{AuthenticationDataWithOrg, UserFromToken},\n    },\n    types::{domain, transformers::ForeignFrom},\n    utils::{self, user::password},\n};\n\npub mod dashboard_metadata;\npub mod decision_manager;\npub use decision_manager::*;\npub mod oidc;\npub mod user_authentication_method;\n\nuse super::{types as domain_types, UserKeyStore};\n\n#[derive(Clone)]\npub struct UserName(Secret<String>);\n\nimpl UserName {\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_char\n\n... [truncated 48640 chars] ...\n\n UserRoleNew {\n            user_id: self.user_id,\n            role_id: self.role_id,\n            status: self.status,\n            created_by: self.created_by,\n            last_modified_by: self.last_modified_by,\n            created_at: self.created_at,\n            last_modified: self.last_modified,\n            org_id: entity.org_id,\n            merchant_id: entity.merchant_id,\n            profile_id: entity.profile_id,\n            entity_id: Some(entity.entity_id),\n            entity_type: Some(entity.entity_type),\n            version: UserRoleVersion::V2,\n            tenant_id: entity.tenant_id,\n        }\n    }\n\n    pub async fn insert_in_v2(self, state: &SessionState) -> UserResult<UserRole> {\n        let entity = self.entity.clone();\n\n        let new_v2_role = self.convert_to_new_v2_role(entity.into());\n\n        state\n            .global_store\n            .insert_user_role(new_v2_role)\n            .await\n            .change_context(UserErrors::InternalServerError)\n    }\n}\n", "function_name": "crates__router__src__types__domain__user.rs", "file": "crates__router__src__types__domain__user.rs"}, {"query": "Inespay connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as inespay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Inespay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Inespay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMi\n\n... [truncated 24162 chars] ...\n\ned_payment_methods\n});\n\nstatic INESPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Inespay\",\n    description:\n        \"INESPAY is a payment method system that allows online shops to receive money in their bank accounts through a SEPA bank transfer \",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic INESPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Inespay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&INESPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*INESPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&INESPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__inespay.rs", "file": "crates__hyperswitch_connectors__src__connectors__inespay.rs"}, {"query": "Inespay SEPA payment integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as inespay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Inespay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Inespay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMi\n\n... [truncated 24162 chars] ...\n\ned_payment_methods\n});\n\nstatic INESPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Inespay\",\n    description:\n        \"INESPAY is a payment method system that allows online shops to receive money in their bank accounts through a SEPA bank transfer \",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic INESPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Inespay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&INESPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*INESPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&INESPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__inespay.rs", "file": "crates__hyperswitch_connectors__src__connectors__inespay.rs"}, {"query": "how to configure Inespay connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as inespay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Inespay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Inespay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMi\n\n... [truncated 24162 chars] ...\n\ned_payment_methods\n});\n\nstatic INESPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Inespay\",\n    description:\n        \"INESPAY is a payment method system that allows online shops to receive money in their bank accounts through a SEPA bank transfer \",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic INESPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Inespay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&INESPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*INESPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&INESPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__inespay.rs", "file": "crates__hyperswitch_connectors__src__connectors__inespay.rs"}, {"query": "hyperswitch bank debit connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as inespay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Inespay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Inespay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMi\n\n... [truncated 24162 chars] ...\n\ned_payment_methods\n});\n\nstatic INESPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Inespay\",\n    description:\n        \"INESPAY is a payment method system that allows online shops to receive money in their bank accounts through a SEPA bank transfer \",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic INESPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Inespay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&INESPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*INESPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&INESPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__inespay.rs", "file": "crates__hyperswitch_connectors__src__connectors__inespay.rs"}, {"query": "Trustpayments payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::Mask;\nuse transformers as trustpayments;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Trustpayments {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Trustpayments {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n\n... [truncated 27592 chars] ...\n\n,\n                        }\n                    }),\n                ),\n            },\n        );\n\n        trustpayments_supported_payment_methods\n    });\n\nstatic TRUSTPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Trustpayments\",\n    description: \"Trustpayments connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic TRUSTPAYMENTS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Trustpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TRUSTPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TRUSTPAYMENTS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TRUSTPAYMENTS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpayments.rs"}, {"query": "hyperswitch connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::Mask;\nuse transformers as trustpayments;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Trustpayments {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Trustpayments {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n\n... [truncated 27592 chars] ...\n\n,\n                        }\n                    }),\n                ),\n            },\n        );\n\n        trustpayments_supported_payment_methods\n    });\n\nstatic TRUSTPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Trustpayments\",\n    description: \"Trustpayments connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic TRUSTPAYMENTS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Trustpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TRUSTPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TRUSTPAYMENTS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TRUSTPAYMENTS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpayments.rs"}, {"query": "how to process payments with Trustpayments", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::Mask;\nuse transformers as trustpayments;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Trustpayments {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Trustpayments {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n\n... [truncated 27592 chars] ...\n\n,\n                        }\n                    }),\n                ),\n            },\n        );\n\n        trustpayments_supported_payment_methods\n    });\n\nstatic TRUSTPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Trustpayments\",\n    description: \"Trustpayments connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic TRUSTPAYMENTS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Trustpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TRUSTPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TRUSTPAYMENTS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TRUSTPAYMENTS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpayments.rs"}, {"query": "Trustpayments API authentication", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::Mask;\nuse transformers as trustpayments;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Trustpayments {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Trustpayments {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n\n... [truncated 27592 chars] ...\n\n,\n                        }\n                    }),\n                ),\n            },\n        );\n\n        trustpayments_supported_payment_methods\n    });\n\nstatic TRUSTPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Trustpayments\",\n    description: \"Trustpayments connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic TRUSTPAYMENTS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Trustpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TRUSTPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TRUSTPAYMENTS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TRUSTPAYMENTS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpayments.rs"}, {"query": "how to transform Authorize.Net API requests", "code": "use std::collections::BTreeMap;\n\nuse api_models::{payments::AdditionalPaymentData, webhooks::IncomingWebhookEvent};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, OptionExt, ValueExt},\n    id_type::CustomerId,\n    pii::Email,\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData, WalletData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, RouterData,\n    },\n    router_flow_types::RSync,\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret, StrongSecret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RefundsRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 20;\nconst ADDRESS_MAX_LENGTH: usize = 60;\n\nfn get_random_string() -> String {\n    Alphanumeric.sample_string(&mut rand::thread_rng(), MAX_ID_LENGTH)\n}\n\n#[derive(Debug, Serialize)]\npub enum TransactionType {\n    #[serde(rename = \"authCaptureTransaction\")]\n    Payment,\n    #[serde(rename = \"authOnlyTransaction\")]\n    Authorization,\n    #[serde(rename = \"priorAuthCapture\n\n... [truncated 89221 chars] ...\n\nCaptureMethod::ManualMultiple.to_string(),\n                    connector: \"authorizedotnet\",\n                })\n            }\n            Some(enums::CaptureMethod::Scheduled) => Err(errors::ConnectorError::NotSupported {\n                message: enums::CaptureMethod::Scheduled.to_string(),\n                connector: \"authorizedotnet\",\n            }),\n        }?;\n        let transaction_request = TransactionConfirmRequest {\n            transaction_type,\n            payment: PaypalPaymentConfirm {\n                pay_pal: Paypal { payer_id },\n            },\n            ref_trans_id: item.router_data.request.connector_transaction_id.clone(),\n        };\n\n        let merchant_authentication =\n            AuthorizedotnetAuthType::try_from(&item.router_data.connector_auth_type)?;\n\n        Ok(Self {\n            create_transaction_request: PaypalConfirmTransactionRequest {\n                merchant_authentication,\n                transaction_request,\n            },\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authorizedotnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__authorizedotnet__transformers.rs"}, {"query": "AuthorizedotnetRouterData struct", "code": "use std::collections::BTreeMap;\n\nuse api_models::{payments::AdditionalPaymentData, webhooks::IncomingWebhookEvent};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, OptionExt, ValueExt},\n    id_type::CustomerId,\n    pii::Email,\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData, WalletData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, RouterData,\n    },\n    router_flow_types::RSync,\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret, StrongSecret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RefundsRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 20;\nconst ADDRESS_MAX_LENGTH: usize = 60;\n\nfn get_random_string() -> String {\n    Alphanumeric.sample_string(&mut rand::thread_rng(), MAX_ID_LENGTH)\n}\n\n#[derive(Debug, Serialize)]\npub enum TransactionType {\n    #[serde(rename = \"authCaptureTransaction\")]\n    Payment,\n    #[serde(rename = \"authOnlyTransaction\")]\n    Authorization,\n    #[serde(rename = \"priorAuthCapture\n\n... [truncated 89221 chars] ...\n\nCaptureMethod::ManualMultiple.to_string(),\n                    connector: \"authorizedotnet\",\n                })\n            }\n            Some(enums::CaptureMethod::Scheduled) => Err(errors::ConnectorError::NotSupported {\n                message: enums::CaptureMethod::Scheduled.to_string(),\n                connector: \"authorizedotnet\",\n            }),\n        }?;\n        let transaction_request = TransactionConfirmRequest {\n            transaction_type,\n            payment: PaypalPaymentConfirm {\n                pay_pal: Paypal { payer_id },\n            },\n            ref_trans_id: item.router_data.request.connector_transaction_id.clone(),\n        };\n\n        let merchant_authentication =\n            AuthorizedotnetAuthType::try_from(&item.router_data.connector_auth_type)?;\n\n        Ok(Self {\n            create_transaction_request: PaypalConfirmTransactionRequest {\n                merchant_authentication,\n                transaction_request,\n            },\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authorizedotnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__authorizedotnet__transformers.rs"}, {"query": "how to implement payments capture for Authorize.Net", "code": "use std::collections::BTreeMap;\n\nuse api_models::{payments::AdditionalPaymentData, webhooks::IncomingWebhookEvent};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, OptionExt, ValueExt},\n    id_type::CustomerId,\n    pii::Email,\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData, WalletData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, RouterData,\n    },\n    router_flow_types::RSync,\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret, StrongSecret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RefundsRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 20;\nconst ADDRESS_MAX_LENGTH: usize = 60;\n\nfn get_random_string() -> String {\n    Alphanumeric.sample_string(&mut rand::thread_rng(), MAX_ID_LENGTH)\n}\n\n#[derive(Debug, Serialize)]\npub enum TransactionType {\n    #[serde(rename = \"authCaptureTransaction\")]\n    Payment,\n    #[serde(rename = \"authOnlyTransaction\")]\n    Authorization,\n    #[serde(rename = \"priorAuthCapture\n\n... [truncated 89221 chars] ...\n\nCaptureMethod::ManualMultiple.to_string(),\n                    connector: \"authorizedotnet\",\n                })\n            }\n            Some(enums::CaptureMethod::Scheduled) => Err(errors::ConnectorError::NotSupported {\n                message: enums::CaptureMethod::Scheduled.to_string(),\n                connector: \"authorizedotnet\",\n            }),\n        }?;\n        let transaction_request = TransactionConfirmRequest {\n            transaction_type,\n            payment: PaypalPaymentConfirm {\n                pay_pal: Paypal { payer_id },\n            },\n            ref_trans_id: item.router_data.request.connector_transaction_id.clone(),\n        };\n\n        let merchant_authentication =\n            AuthorizedotnetAuthType::try_from(&item.router_data.connector_auth_type)?;\n\n        Ok(Self {\n            create_transaction_request: PaypalConfirmTransactionRequest {\n                merchant_authentication,\n                transaction_request,\n            },\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authorizedotnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__authorizedotnet__transformers.rs"}, {"query": "Authorize.Net webhook response parsing", "code": "use std::collections::BTreeMap;\n\nuse api_models::{payments::AdditionalPaymentData, webhooks::IncomingWebhookEvent};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, OptionExt, ValueExt},\n    id_type::CustomerId,\n    pii::Email,\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData, WalletData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, RouterData,\n    },\n    router_flow_types::RSync,\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret, StrongSecret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RefundsRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 20;\nconst ADDRESS_MAX_LENGTH: usize = 60;\n\nfn get_random_string() -> String {\n    Alphanumeric.sample_string(&mut rand::thread_rng(), MAX_ID_LENGTH)\n}\n\n#[derive(Debug, Serialize)]\npub enum TransactionType {\n    #[serde(rename = \"authCaptureTransaction\")]\n    Payment,\n    #[serde(rename = \"authOnlyTransaction\")]\n    Authorization,\n    #[serde(rename = \"priorAuthCapture\n\n... [truncated 89221 chars] ...\n\nCaptureMethod::ManualMultiple.to_string(),\n                    connector: \"authorizedotnet\",\n                })\n            }\n            Some(enums::CaptureMethod::Scheduled) => Err(errors::ConnectorError::NotSupported {\n                message: enums::CaptureMethod::Scheduled.to_string(),\n                connector: \"authorizedotnet\",\n            }),\n        }?;\n        let transaction_request = TransactionConfirmRequest {\n            transaction_type,\n            payment: PaypalPaymentConfirm {\n                pay_pal: Paypal { payer_id },\n            },\n            ref_trans_id: item.router_data.request.connector_transaction_id.clone(),\n        };\n\n        let merchant_authentication =\n            AuthorizedotnetAuthType::try_from(&item.router_data.connector_auth_type)?;\n\n        Ok(Self {\n            create_transaction_request: PaypalConfirmTransactionRequest {\n                merchant_authentication,\n                transaction_request,\n            },\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authorizedotnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__authorizedotnet__transformers.rs"}, {"query": "Worldpay connector implementation", "code": "#[cfg(feature = \"payouts\")]\nmod payout_requests;\n#[cfg(feature = \"payouts\")]\nmod payout_response;\n#[cfg(feature = \"payouts\")]\npub mod payout_transformers;\nmod requests;\nmod response;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{payments::PaymentIdType, webhooks::IncomingWebhookEvent};\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundExecuteRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n \n\n... [truncated 53997 chars] ...\n\n          specific_features: None,\n            },\n        );\n\n        worldpay_supported_payment_methods\n    });\n\nstatic WORLDPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldpay\",\n    description: \"Worldpay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic WORLDPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Worldpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpay.rs"}, {"query": "WorldpayPaymentsRequest struct", "code": "#[cfg(feature = \"payouts\")]\nmod payout_requests;\n#[cfg(feature = \"payouts\")]\nmod payout_response;\n#[cfg(feature = \"payouts\")]\npub mod payout_transformers;\nmod requests;\nmod response;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{payments::PaymentIdType, webhooks::IncomingWebhookEvent};\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundExecuteRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n \n\n... [truncated 53997 chars] ...\n\n          specific_features: None,\n            },\n        );\n\n        worldpay_supported_payment_methods\n    });\n\nstatic WORLDPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldpay\",\n    description: \"Worldpay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic WORLDPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Worldpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpay.rs"}, {"query": "Hyperswitch Worldpay integration", "code": "#[cfg(feature = \"payouts\")]\nmod payout_requests;\n#[cfg(feature = \"payouts\")]\nmod payout_response;\n#[cfg(feature = \"payouts\")]\npub mod payout_transformers;\nmod requests;\nmod response;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{payments::PaymentIdType, webhooks::IncomingWebhookEvent};\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundExecuteRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n \n\n... [truncated 53997 chars] ...\n\n          specific_features: None,\n            },\n        );\n\n        worldpay_supported_payment_methods\n    });\n\nstatic WORLDPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldpay\",\n    description: \"Worldpay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic WORLDPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Worldpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpay.rs"}, {"query": "Worldpay webhook handling", "code": "#[cfg(feature = \"payouts\")]\nmod payout_requests;\n#[cfg(feature = \"payouts\")]\nmod payout_response;\n#[cfg(feature = \"payouts\")]\npub mod payout_transformers;\nmod requests;\nmod response;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{payments::PaymentIdType, webhooks::IncomingWebhookEvent};\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundExecuteRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n \n\n... [truncated 53997 chars] ...\n\n          specific_features: None,\n            },\n        );\n\n        worldpay_supported_payment_methods\n    });\n\nstatic WORLDPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldpay\",\n    description: \"Worldpay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic WORLDPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Worldpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpay.rs"}, {"query": "how to create a newtype in Rust", "code": "//! Utility macros\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! newtype_impl {\n    ($is_pub:vis, $name:ident, $ty_path:path) => {\n        impl core::ops::Deref for $name {\n            type Target = $ty_path;\n\n            fn deref(&self) -> &Self::Target {\n                &self.0\n            }\n        }\n\n        impl core::ops::DerefMut for $name {\n            fn deref_mut(&mut self) -> &mut Self::Target {\n                &mut self.0\n            }\n        }\n\n        impl From<$ty_path> for $name {\n            fn from(ty: $ty_path) -> Self {\n                Self(ty)\n            }\n        }\n\n        impl $name {\n            pub fn into_inner(self) -> $ty_path {\n                self.0\n            }\n        }\n    };\n}\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! newtype {\n    ($is_pub:vis $name:ident = $ty_path:path) => {\n        $is_pub struct $name(pub $ty_path);\n\n        $crate::newtype_impl!($is_pub, $name, $ty_path);\n    };\n\n    ($is_pub:vis $name:ident = $ty_path:path, derives = ($($trt:path),*)) => {\n        #[derive($($trt),*)]\n        $is_pub struct $name(pub $ty_path);\n\n        $crate::newtype_impl!($is_pub, $name, $ty_path);\n    };\n}\n\n/// Use this to ensure that the corresponding\n/// openapi route has been implemented in the openapi crate\n#[macro_export]\nmacro_rules! openapi_route {\n    ($route_name: ident) => {{\n        #[cfg(feature = \"openapi\")]\n        use openapi::routes::$route_name as _;\n\n        $route_name\n    }};\n}\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! fallback_reverse_lookup_not_found {\n    ($a:expr,$b:expr) => {\n        match $a {\n            Ok(res) => res,\n            Err(err) => {\n                router_env::logger::error!(reverse_lookup_fallback = ?err);\n                match err.current_context() {\n                    errors::StorageError::ValueNotFound(_) => return $b,\n                    errors::StorageError::DatabaseError(data_err) => {\n                        match data_err.current_context() {\n                         \n\n... [truncated 29620 chars] ...\n\nstEnum::VariantA { value: 123 });\n\n        // Deserialize explicit \"Invalid\"\n        let input_invalid = \"\\\"Invalid\\\"\";\n        let deserialized_invalid: TestEnum =\n            serde_json::from_str(input_invalid).expect(\"Deserialize Invalid failed\");\n        assert_eq!(deserialized_invalid, TestEnum::Invalid);\n\n        // Deserialize malformed string (according to macro rules) -> Invalid\n        let input_malformed = \"\\\"VariantA_no_delimiter\\\"\";\n        let deserialized_malformed: TestEnum =\n            serde_json::from_str(input_malformed).expect(\"Deserialize malformed should succeed\");\n        assert_eq!(deserialized_malformed, TestEnum::Invalid);\n\n        // Deserialize string with bad field data -> Invalid\n        let input_bad_data = \"\\\"VariantA:not_a_number\\\"\";\n        let deserialized_bad_data: TestEnum =\n            serde_json::from_str(input_bad_data).expect(\"Deserialize bad data should succeed\");\n        assert_eq!(deserialized_bad_data, TestEnum::Invalid);\n    }\n}\n", "function_name": "crates__common_utils__src__macros.rs", "file": "crates__common_utils__src__macros.rs"}, {"query": "newtype macro implementation Rust", "code": "//! Utility macros\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! newtype_impl {\n    ($is_pub:vis, $name:ident, $ty_path:path) => {\n        impl core::ops::Deref for $name {\n            type Target = $ty_path;\n\n            fn deref(&self) -> &Self::Target {\n                &self.0\n            }\n        }\n\n        impl core::ops::DerefMut for $name {\n            fn deref_mut(&mut self) -> &mut Self::Target {\n                &mut self.0\n            }\n        }\n\n        impl From<$ty_path> for $name {\n            fn from(ty: $ty_path) -> Self {\n                Self(ty)\n            }\n        }\n\n        impl $name {\n            pub fn into_inner(self) -> $ty_path {\n                self.0\n            }\n        }\n    };\n}\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! newtype {\n    ($is_pub:vis $name:ident = $ty_path:path) => {\n        $is_pub struct $name(pub $ty_path);\n\n        $crate::newtype_impl!($is_pub, $name, $ty_path);\n    };\n\n    ($is_pub:vis $name:ident = $ty_path:path, derives = ($($trt:path),*)) => {\n        #[derive($($trt),*)]\n        $is_pub struct $name(pub $ty_path);\n\n        $crate::newtype_impl!($is_pub, $name, $ty_path);\n    };\n}\n\n/// Use this to ensure that the corresponding\n/// openapi route has been implemented in the openapi crate\n#[macro_export]\nmacro_rules! openapi_route {\n    ($route_name: ident) => {{\n        #[cfg(feature = \"openapi\")]\n        use openapi::routes::$route_name as _;\n\n        $route_name\n    }};\n}\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! fallback_reverse_lookup_not_found {\n    ($a:expr,$b:expr) => {\n        match $a {\n            Ok(res) => res,\n            Err(err) => {\n                router_env::logger::error!(reverse_lookup_fallback = ?err);\n                match err.current_context() {\n                    errors::StorageError::ValueNotFound(_) => return $b,\n                    errors::StorageError::DatabaseError(data_err) => {\n                        match data_err.current_context() {\n                         \n\n... [truncated 29620 chars] ...\n\nstEnum::VariantA { value: 123 });\n\n        // Deserialize explicit \"Invalid\"\n        let input_invalid = \"\\\"Invalid\\\"\";\n        let deserialized_invalid: TestEnum =\n            serde_json::from_str(input_invalid).expect(\"Deserialize Invalid failed\");\n        assert_eq!(deserialized_invalid, TestEnum::Invalid);\n\n        // Deserialize malformed string (according to macro rules) -> Invalid\n        let input_malformed = \"\\\"VariantA_no_delimiter\\\"\";\n        let deserialized_malformed: TestEnum =\n            serde_json::from_str(input_malformed).expect(\"Deserialize malformed should succeed\");\n        assert_eq!(deserialized_malformed, TestEnum::Invalid);\n\n        // Deserialize string with bad field data -> Invalid\n        let input_bad_data = \"\\\"VariantA:not_a_number\\\"\";\n        let deserialized_bad_data: TestEnum =\n            serde_json::from_str(input_bad_data).expect(\"Deserialize bad data should succeed\");\n        assert_eq!(deserialized_bad_data, TestEnum::Invalid);\n    }\n}\n", "function_name": "crates__common_utils__src__macros.rs", "file": "crates__common_utils__src__macros.rs"}, {"query": "Rust macro for Diesel JSON serialization", "code": "//! Utility macros\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! newtype_impl {\n    ($is_pub:vis, $name:ident, $ty_path:path) => {\n        impl core::ops::Deref for $name {\n            type Target = $ty_path;\n\n            fn deref(&self) -> &Self::Target {\n                &self.0\n            }\n        }\n\n        impl core::ops::DerefMut for $name {\n            fn deref_mut(&mut self) -> &mut Self::Target {\n                &mut self.0\n            }\n        }\n\n        impl From<$ty_path> for $name {\n            fn from(ty: $ty_path) -> Self {\n                Self(ty)\n            }\n        }\n\n        impl $name {\n            pub fn into_inner(self) -> $ty_path {\n                self.0\n            }\n        }\n    };\n}\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! newtype {\n    ($is_pub:vis $name:ident = $ty_path:path) => {\n        $is_pub struct $name(pub $ty_path);\n\n        $crate::newtype_impl!($is_pub, $name, $ty_path);\n    };\n\n    ($is_pub:vis $name:ident = $ty_path:path, derives = ($($trt:path),*)) => {\n        #[derive($($trt),*)]\n        $is_pub struct $name(pub $ty_path);\n\n        $crate::newtype_impl!($is_pub, $name, $ty_path);\n    };\n}\n\n/// Use this to ensure that the corresponding\n/// openapi route has been implemented in the openapi crate\n#[macro_export]\nmacro_rules! openapi_route {\n    ($route_name: ident) => {{\n        #[cfg(feature = \"openapi\")]\n        use openapi::routes::$route_name as _;\n\n        $route_name\n    }};\n}\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! fallback_reverse_lookup_not_found {\n    ($a:expr,$b:expr) => {\n        match $a {\n            Ok(res) => res,\n            Err(err) => {\n                router_env::logger::error!(reverse_lookup_fallback = ?err);\n                match err.current_context() {\n                    errors::StorageError::ValueNotFound(_) => return $b,\n                    errors::StorageError::DatabaseError(data_err) => {\n                        match data_err.current_context() {\n                         \n\n... [truncated 29620 chars] ...\n\nstEnum::VariantA { value: 123 });\n\n        // Deserialize explicit \"Invalid\"\n        let input_invalid = \"\\\"Invalid\\\"\";\n        let deserialized_invalid: TestEnum =\n            serde_json::from_str(input_invalid).expect(\"Deserialize Invalid failed\");\n        assert_eq!(deserialized_invalid, TestEnum::Invalid);\n\n        // Deserialize malformed string (according to macro rules) -> Invalid\n        let input_malformed = \"\\\"VariantA_no_delimiter\\\"\";\n        let deserialized_malformed: TestEnum =\n            serde_json::from_str(input_malformed).expect(\"Deserialize malformed should succeed\");\n        assert_eq!(deserialized_malformed, TestEnum::Invalid);\n\n        // Deserialize string with bad field data -> Invalid\n        let input_bad_data = \"\\\"VariantA:not_a_number\\\"\";\n        let deserialized_bad_data: TestEnum =\n            serde_json::from_str(input_bad_data).expect(\"Deserialize bad data should succeed\");\n        assert_eq!(deserialized_bad_data, TestEnum::Invalid);\n    }\n}\n", "function_name": "crates__common_utils__src__macros.rs", "file": "crates__common_utils__src__macros.rs"}, {"query": "Hyperswitch payment orchestration macros", "code": "//! Utility macros\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! newtype_impl {\n    ($is_pub:vis, $name:ident, $ty_path:path) => {\n        impl core::ops::Deref for $name {\n            type Target = $ty_path;\n\n            fn deref(&self) -> &Self::Target {\n                &self.0\n            }\n        }\n\n        impl core::ops::DerefMut for $name {\n            fn deref_mut(&mut self) -> &mut Self::Target {\n                &mut self.0\n            }\n        }\n\n        impl From<$ty_path> for $name {\n            fn from(ty: $ty_path) -> Self {\n                Self(ty)\n            }\n        }\n\n        impl $name {\n            pub fn into_inner(self) -> $ty_path {\n                self.0\n            }\n        }\n    };\n}\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! newtype {\n    ($is_pub:vis $name:ident = $ty_path:path) => {\n        $is_pub struct $name(pub $ty_path);\n\n        $crate::newtype_impl!($is_pub, $name, $ty_path);\n    };\n\n    ($is_pub:vis $name:ident = $ty_path:path, derives = ($($trt:path),*)) => {\n        #[derive($($trt),*)]\n        $is_pub struct $name(pub $ty_path);\n\n        $crate::newtype_impl!($is_pub, $name, $ty_path);\n    };\n}\n\n/// Use this to ensure that the corresponding\n/// openapi route has been implemented in the openapi crate\n#[macro_export]\nmacro_rules! openapi_route {\n    ($route_name: ident) => {{\n        #[cfg(feature = \"openapi\")]\n        use openapi::routes::$route_name as _;\n\n        $route_name\n    }};\n}\n\n#[allow(missing_docs)]\n#[macro_export]\nmacro_rules! fallback_reverse_lookup_not_found {\n    ($a:expr,$b:expr) => {\n        match $a {\n            Ok(res) => res,\n            Err(err) => {\n                router_env::logger::error!(reverse_lookup_fallback = ?err);\n                match err.current_context() {\n                    errors::StorageError::ValueNotFound(_) => return $b,\n                    errors::StorageError::DatabaseError(data_err) => {\n                        match data_err.current_context() {\n                         \n\n... [truncated 29620 chars] ...\n\nstEnum::VariantA { value: 123 });\n\n        // Deserialize explicit \"Invalid\"\n        let input_invalid = \"\\\"Invalid\\\"\";\n        let deserialized_invalid: TestEnum =\n            serde_json::from_str(input_invalid).expect(\"Deserialize Invalid failed\");\n        assert_eq!(deserialized_invalid, TestEnum::Invalid);\n\n        // Deserialize malformed string (according to macro rules) -> Invalid\n        let input_malformed = \"\\\"VariantA_no_delimiter\\\"\";\n        let deserialized_malformed: TestEnum =\n            serde_json::from_str(input_malformed).expect(\"Deserialize malformed should succeed\");\n        assert_eq!(deserialized_malformed, TestEnum::Invalid);\n\n        // Deserialize string with bad field data -> Invalid\n        let input_bad_data = \"\\\"VariantA:not_a_number\\\"\";\n        let deserialized_bad_data: TestEnum =\n            serde_json::from_str(input_bad_data).expect(\"Deserialize bad data should succeed\");\n        assert_eq!(deserialized_bad_data, TestEnum::Invalid);\n    }\n}\n", "function_name": "crates__common_utils__src__macros.rs", "file": "crates__common_utils__src__macros.rs"}, {"query": "Airwallex API request transformation", "code": "use common_enums::enums;\nuse common_utils::{\n    errors::ParsingError,\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        PSync,\n    },\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{CreateOrderResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData as _, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\npub struct AirwallexAuthType {\n    pub x_api_key: Secret<String>,\n    pub x_client_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for AirwallexAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::BodyKey { api_key, key1 } = auth_type {\n            Ok(Self {\n                x_api_key: api_key.clone(),\n                x_client_id: key1.clone(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ReferrerData {\n    #[serde(rename = \"type\")]\n    r_type: String,\n    version: String,\n}\n\n#[derive(Default, Debug, Serialize\n\n... [truncated 73393 chars] ...\n\n           last_name: item.request.name.to_owned(),\n            merchant_customer_id: item.customer_id.to_owned().ok_or(\n                errors::ConnectorError::MissingRequiredField {\n                    field_name: \"customer_id\",\n                },\n            )?,\n        })\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct AirwallexCustomerResponse {\n    pub id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, AirwallexCustomerResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: ResponseRouterData<F, AirwallexCustomerResponse, T, PaymentsResponseData>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(PaymentsResponseData::ConnectorCustomerResponse(\n                ConnectorCustomerResponseData::new_with_customer_id(item.response.id),\n            )),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs"}, {"query": "AirwallexAuthType struct", "code": "use common_enums::enums;\nuse common_utils::{\n    errors::ParsingError,\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        PSync,\n    },\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{CreateOrderResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData as _, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\npub struct AirwallexAuthType {\n    pub x_api_key: Secret<String>,\n    pub x_client_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for AirwallexAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::BodyKey { api_key, key1 } = auth_type {\n            Ok(Self {\n                x_api_key: api_key.clone(),\n                x_client_id: key1.clone(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ReferrerData {\n    #[serde(rename = \"type\")]\n    r_type: String,\n    version: String,\n}\n\n#[derive(Default, Debug, Serialize\n\n... [truncated 73393 chars] ...\n\n           last_name: item.request.name.to_owned(),\n            merchant_customer_id: item.customer_id.to_owned().ok_or(\n                errors::ConnectorError::MissingRequiredField {\n                    field_name: \"customer_id\",\n                },\n            )?,\n        })\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct AirwallexCustomerResponse {\n    pub id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, AirwallexCustomerResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: ResponseRouterData<F, AirwallexCustomerResponse, T, PaymentsResponseData>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(PaymentsResponseData::ConnectorCustomerResponse(\n                ConnectorCustomerResponseData::new_with_customer_id(item.response.id),\n            )),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs"}, {"query": "how to implement Airwallex connector", "code": "use common_enums::enums;\nuse common_utils::{\n    errors::ParsingError,\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        PSync,\n    },\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{CreateOrderResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData as _, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\npub struct AirwallexAuthType {\n    pub x_api_key: Secret<String>,\n    pub x_client_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for AirwallexAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::BodyKey { api_key, key1 } = auth_type {\n            Ok(Self {\n                x_api_key: api_key.clone(),\n                x_client_id: key1.clone(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ReferrerData {\n    #[serde(rename = \"type\")]\n    r_type: String,\n    version: String,\n}\n\n#[derive(Default, Debug, Serialize\n\n... [truncated 73393 chars] ...\n\n           last_name: item.request.name.to_owned(),\n            merchant_customer_id: item.customer_id.to_owned().ok_or(\n                errors::ConnectorError::MissingRequiredField {\n                    field_name: \"customer_id\",\n                },\n            )?,\n        })\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct AirwallexCustomerResponse {\n    pub id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, AirwallexCustomerResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: ResponseRouterData<F, AirwallexCustomerResponse, T, PaymentsResponseData>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(PaymentsResponseData::ConnectorCustomerResponse(\n                ConnectorCustomerResponseData::new_with_customer_id(item.response.id),\n            )),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs"}, {"query": "Airwallex payment intent mapping", "code": "use common_enums::enums;\nuse common_utils::{\n    errors::ParsingError,\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        PSync,\n    },\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{CreateOrderResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData as _, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\npub struct AirwallexAuthType {\n    pub x_api_key: Secret<String>,\n    pub x_client_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for AirwallexAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::BodyKey { api_key, key1 } = auth_type {\n            Ok(Self {\n                x_api_key: api_key.clone(),\n                x_client_id: key1.clone(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ReferrerData {\n    #[serde(rename = \"type\")]\n    r_type: String,\n    version: String,\n}\n\n#[derive(Default, Debug, Serialize\n\n... [truncated 73393 chars] ...\n\n           last_name: item.request.name.to_owned(),\n            merchant_customer_id: item.customer_id.to_owned().ok_or(\n                errors::ConnectorError::MissingRequiredField {\n                    field_name: \"customer_id\",\n                },\n            )?,\n        })\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct AirwallexCustomerResponse {\n    pub id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, AirwallexCustomerResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: ResponseRouterData<F, AirwallexCustomerResponse, T, PaymentsResponseData>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(PaymentsResponseData::ConnectorCustomerResponse(\n                ConnectorCustomerResponseData::new_with_customer_id(item.response.id),\n            )),\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs"}, {"query": "Airwallex payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        CreateOrderRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connecto\n\n... [truncated 49099 chars] ...\n\nlass::Disputes,\n];\n\nimpl ConnectorSpecifications for Airwallex {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AIRWALLEX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AIRWALLEX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AIRWALLEX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "file": "crates__hyperswitch_connectors__src__connectors__airwallex.rs"}, {"query": "Airwallex connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        CreateOrderRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connecto\n\n... [truncated 49099 chars] ...\n\nlass::Disputes,\n];\n\nimpl ConnectorSpecifications for Airwallex {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AIRWALLEX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AIRWALLEX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AIRWALLEX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "file": "crates__hyperswitch_connectors__src__connectors__airwallex.rs"}, {"query": "how to add Airwallex to Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        CreateOrderRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connecto\n\n... [truncated 49099 chars] ...\n\nlass::Disputes,\n];\n\nimpl ConnectorSpecifications for Airwallex {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AIRWALLEX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AIRWALLEX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AIRWALLEX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "file": "crates__hyperswitch_connectors__src__connectors__airwallex.rs"}, {"query": "Airwallex webhook handling", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        CreateOrderRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connecto\n\n... [truncated 49099 chars] ...\n\nlass::Disputes,\n];\n\nimpl ConnectorSpecifications for Airwallex {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AIRWALLEX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AIRWALLEX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AIRWALLEX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "file": "crates__hyperswitch_connectors__src__connectors__airwallex.rs"}, {"query": "how to create payment method API", "code": "#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse std::collections::HashMap;\n\nuse ::payment_methods::{\n    controller::PaymentMethodsController,\n    core::{migration, migration::payment_methods::migrate_payment_method},\n};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse actix_multipart::form::MultipartForm;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse common_utils::{errors::CustomResult, id_type, transformers::ForeignFrom};\nuse diesel_models::enums::IntentStatus;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    bulk_tokenization::CardNetworkTokenizeRequest, merchant_key_store::MerchantKeyStore,\n    payment_methods::PaymentMethodCustomerMigrate, transformers::ForeignTryFrom,\n};\nuse router_env::{instrument, logger, tracing, Flow};\n\nuse super::app::{AppState, SessionState};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse crate::core::{\n    customers,\n    payment_methods::{batch_retrieve, tokenize},\n};\nuse crate::{\n    core::{\n        api_locking,\n        errors::{self, utils::StorageErrorExt},\n        payment_methods::{self as payment_methods_routes, cards, migration as update_migration},\n    },\n    services::{self, api, authentication as auth, authorization::permissions::Permission},\n    types::{\n        api::payment_methods::{self, PaymentMethodId},\n        domain,\n        storage::payment_method::PaymentTokenData,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _| async move {\n            Box::pin(cards::get_client_secret_or_add_payment_method(\n   \n\n... [truncated 59291 chars] ...\n\n: false,\n    };\n\n    let (auth_type, api_key_type) = match auth::check_internal_api_key_auth_no_client_secret(\n        req.headers(),\n        api_auth,\n        state.conf.internal_merchant_id_profile_id_auth.clone(),\n    ) {\n        Ok(auth) => auth,\n        Err(err) => return api::log_and_return_error_response(error_stack::report!(err)),\n    };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        (),\n        |state, auth: auth::AuthenticationData, _, _| {\n            let temporary_token = temporary_token.clone();\n            async move {\n                let platform: domain::Platform = auth.platform;\n                payment_methods_routes::payment_method_get_token_details_core(\n                    state,\n                    platform.get_provider().clone(),\n                    temporary_token,\n                )\n                .await\n            }\n        },\n        &*auth_type,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n", "function_name": "crates__router__src__routes__payment_methods.rs", "file": "crates__router__src__routes__payment_methods.rs"}, {"query": "payment methods controller", "code": "#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse std::collections::HashMap;\n\nuse ::payment_methods::{\n    controller::PaymentMethodsController,\n    core::{migration, migration::payment_methods::migrate_payment_method},\n};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse actix_multipart::form::MultipartForm;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse common_utils::{errors::CustomResult, id_type, transformers::ForeignFrom};\nuse diesel_models::enums::IntentStatus;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    bulk_tokenization::CardNetworkTokenizeRequest, merchant_key_store::MerchantKeyStore,\n    payment_methods::PaymentMethodCustomerMigrate, transformers::ForeignTryFrom,\n};\nuse router_env::{instrument, logger, tracing, Flow};\n\nuse super::app::{AppState, SessionState};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse crate::core::{\n    customers,\n    payment_methods::{batch_retrieve, tokenize},\n};\nuse crate::{\n    core::{\n        api_locking,\n        errors::{self, utils::StorageErrorExt},\n        payment_methods::{self as payment_methods_routes, cards, migration as update_migration},\n    },\n    services::{self, api, authentication as auth, authorization::permissions::Permission},\n    types::{\n        api::payment_methods::{self, PaymentMethodId},\n        domain,\n        storage::payment_method::PaymentTokenData,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _| async move {\n            Box::pin(cards::get_client_secret_or_add_payment_method(\n   \n\n... [truncated 59291 chars] ...\n\n: false,\n    };\n\n    let (auth_type, api_key_type) = match auth::check_internal_api_key_auth_no_client_secret(\n        req.headers(),\n        api_auth,\n        state.conf.internal_merchant_id_profile_id_auth.clone(),\n    ) {\n        Ok(auth) => auth,\n        Err(err) => return api::log_and_return_error_response(error_stack::report!(err)),\n    };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        (),\n        |state, auth: auth::AuthenticationData, _, _| {\n            let temporary_token = temporary_token.clone();\n            async move {\n                let platform: domain::Platform = auth.platform;\n                payment_methods_routes::payment_method_get_token_details_core(\n                    state,\n                    platform.get_provider().clone(),\n                    temporary_token,\n                )\n                .await\n            }\n        },\n        &*auth_type,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n", "function_name": "crates__router__src__routes__payment_methods.rs", "file": "crates__router__src__routes__payment_methods.rs"}, {"query": "how to tokenize card hyperswitch", "code": "#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse std::collections::HashMap;\n\nuse ::payment_methods::{\n    controller::PaymentMethodsController,\n    core::{migration, migration::payment_methods::migrate_payment_method},\n};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse actix_multipart::form::MultipartForm;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse common_utils::{errors::CustomResult, id_type, transformers::ForeignFrom};\nuse diesel_models::enums::IntentStatus;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    bulk_tokenization::CardNetworkTokenizeRequest, merchant_key_store::MerchantKeyStore,\n    payment_methods::PaymentMethodCustomerMigrate, transformers::ForeignTryFrom,\n};\nuse router_env::{instrument, logger, tracing, Flow};\n\nuse super::app::{AppState, SessionState};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse crate::core::{\n    customers,\n    payment_methods::{batch_retrieve, tokenize},\n};\nuse crate::{\n    core::{\n        api_locking,\n        errors::{self, utils::StorageErrorExt},\n        payment_methods::{self as payment_methods_routes, cards, migration as update_migration},\n    },\n    services::{self, api, authentication as auth, authorization::permissions::Permission},\n    types::{\n        api::payment_methods::{self, PaymentMethodId},\n        domain,\n        storage::payment_method::PaymentTokenData,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _| async move {\n            Box::pin(cards::get_client_secret_or_add_payment_method(\n   \n\n... [truncated 59291 chars] ...\n\n: false,\n    };\n\n    let (auth_type, api_key_type) = match auth::check_internal_api_key_auth_no_client_secret(\n        req.headers(),\n        api_auth,\n        state.conf.internal_merchant_id_profile_id_auth.clone(),\n    ) {\n        Ok(auth) => auth,\n        Err(err) => return api::log_and_return_error_response(error_stack::report!(err)),\n    };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        (),\n        |state, auth: auth::AuthenticationData, _, _| {\n            let temporary_token = temporary_token.clone();\n            async move {\n                let platform: domain::Platform = auth.platform;\n                payment_methods_routes::payment_method_get_token_details_core(\n                    state,\n                    platform.get_provider().clone(),\n                    temporary_token,\n                )\n                .await\n            }\n        },\n        &*auth_type,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n", "function_name": "crates__router__src__routes__payment_methods.rs", "file": "crates__router__src__routes__payment_methods.rs"}, {"query": "payment method delete endpoint", "code": "#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse std::collections::HashMap;\n\nuse ::payment_methods::{\n    controller::PaymentMethodsController,\n    core::{migration, migration::payment_methods::migrate_payment_method},\n};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse actix_multipart::form::MultipartForm;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse common_utils::{errors::CustomResult, id_type, transformers::ForeignFrom};\nuse diesel_models::enums::IntentStatus;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    bulk_tokenization::CardNetworkTokenizeRequest, merchant_key_store::MerchantKeyStore,\n    payment_methods::PaymentMethodCustomerMigrate, transformers::ForeignTryFrom,\n};\nuse router_env::{instrument, logger, tracing, Flow};\n\nuse super::app::{AppState, SessionState};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse crate::core::{\n    customers,\n    payment_methods::{batch_retrieve, tokenize},\n};\nuse crate::{\n    core::{\n        api_locking,\n        errors::{self, utils::StorageErrorExt},\n        payment_methods::{self as payment_methods_routes, cards, migration as update_migration},\n    },\n    services::{self, api, authentication as auth, authorization::permissions::Permission},\n    types::{\n        api::payment_methods::{self, PaymentMethodId},\n        domain,\n        storage::payment_method::PaymentTokenData,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _| async move {\n            Box::pin(cards::get_client_secret_or_add_payment_method(\n   \n\n... [truncated 59291 chars] ...\n\n: false,\n    };\n\n    let (auth_type, api_key_type) = match auth::check_internal_api_key_auth_no_client_secret(\n        req.headers(),\n        api_auth,\n        state.conf.internal_merchant_id_profile_id_auth.clone(),\n    ) {\n        Ok(auth) => auth,\n        Err(err) => return api::log_and_return_error_response(error_stack::report!(err)),\n    };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        (),\n        |state, auth: auth::AuthenticationData, _, _| {\n            let temporary_token = temporary_token.clone();\n            async move {\n                let platform: domain::Platform = auth.platform;\n                payment_methods_routes::payment_method_get_token_details_core(\n                    state,\n                    platform.get_provider().clone(),\n                    temporary_token,\n                )\n                .await\n            }\n        },\n        &*auth_type,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n", "function_name": "crates__router__src__routes__payment_methods.rs", "file": "crates__router__src__routes__payment_methods.rs"}, {"query": "CashToCode payment gateway connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{PaymentsAuthorizeRouterData, PaymentsSyncRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, Response},\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as cashtocode;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Cashtocode {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Cashtocode {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Cashtocode {}\nimpl api::Payment\n\n... [truncated 15922 chars] ...\n\ned_payment_methods\n    });\n\nstatic CASHTOCODE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"CashToCode\",\n        description:\n            \"CashToCode is a payment solution that enables users to convert cash into digital vouchers for online transactions\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic CASHTOCODE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Cashtocode {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CASHTOCODE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CASHTOCODE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CASHTOCODE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cashtocode.rs", "file": "crates__hyperswitch_connectors__src__connectors__cashtocode.rs"}, {"query": "hyperswitch cash to voucher payment method", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{PaymentsAuthorizeRouterData, PaymentsSyncRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, Response},\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as cashtocode;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Cashtocode {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Cashtocode {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Cashtocode {}\nimpl api::Payment\n\n... [truncated 15922 chars] ...\n\ned_payment_methods\n    });\n\nstatic CASHTOCODE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"CashToCode\",\n        description:\n            \"CashToCode is a payment solution that enables users to convert cash into digital vouchers for online transactions\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic CASHTOCODE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Cashtocode {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CASHTOCODE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CASHTOCODE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CASHTOCODE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cashtocode.rs", "file": "crates__hyperswitch_connectors__src__connectors__cashtocode.rs"}, {"query": "how to implement cash to code payment", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{PaymentsAuthorizeRouterData, PaymentsSyncRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, Response},\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as cashtocode;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Cashtocode {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Cashtocode {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Cashtocode {}\nimpl api::Payment\n\n... [truncated 15922 chars] ...\n\ned_payment_methods\n    });\n\nstatic CASHTOCODE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"CashToCode\",\n        description:\n            \"CashToCode is a payment solution that enables users to convert cash into digital vouchers for online transactions\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic CASHTOCODE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Cashtocode {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CASHTOCODE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CASHTOCODE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CASHTOCODE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cashtocode.rs", "file": "crates__hyperswitch_connectors__src__connectors__cashtocode.rs"}, {"query": "cashtocode authentication base64 credentials", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{PaymentsAuthorizeRouterData, PaymentsSyncRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, Response},\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as cashtocode;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Cashtocode {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Cashtocode {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Cashtocode {}\nimpl api::Payment\n\n... [truncated 15922 chars] ...\n\ned_payment_methods\n    });\n\nstatic CASHTOCODE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"CashToCode\",\n        description:\n            \"CashToCode is a payment solution that enables users to convert cash into digital vouchers for online transactions\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic CASHTOCODE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Cashtocode {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CASHTOCODE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CASHTOCODE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CASHTOCODE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cashtocode.rs", "file": "crates__hyperswitch_connectors__src__connectors__cashtocode.rs"}, {"query": "revenue recovery webhook processing", "code": "use std::{collections::HashMap, marker::PhantomData, str::FromStr};\n\nuse api_models::{enums as api_enums, payments as api_payments, webhooks};\nuse common_utils::{\n    ext_traits::{AsyncExt, ValueExt},\n    id_type,\n};\nuse diesel_models::process_tracker as storage;\nuse error_stack::{report, ResultExt};\nuse futures::stream::SelectNextSome;\nuse hyperswitch_domain_models::{\n    payments as domain_payments,\n    revenue_recovery::{self, RecoveryPaymentIntent},\n    router_data_v2::flow_common_types,\n    router_flow_types,\n    router_request_types::revenue_recovery as revenue_recovery_request,\n    router_response_types::revenue_recovery as revenue_recovery_response,\n    types as router_types,\n};\nuse hyperswitch_interfaces::webhooks as interface_webhooks;\nuse masking::{PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse services::kafka;\nuse storage::business_status;\n\nuse crate::{\n    consts,\n    core::{\n        self, admin,\n        errors::{self, CustomResult},\n        payments::{self, helpers},\n    },\n    db::{errors::RevenueRecoveryError, StorageInterface},\n    routes::{app::ReqState, metrics, SessionState},\n    services::{\n        self,\n        connector_integration_interface::{self, RouterDataConversion},\n    },\n    types::{\n        self, api, domain,\n        storage::{\n            revenue_recovery as storage_revenue_recovery,\n            revenue_recovery_redis_operation::{\n                PaymentProcessorTokenDetails, PaymentProcessorTokenStatus, RedisTokenManager,\n            },\n        },\n        transformers::ForeignFrom,\n    },\n    workflows::revenue_recovery as revenue_recovery_flow,\n};\n#[cfg(feature = \"v2\")]\npub const REVENUE_RECOVERY: &str = \"revenue_recovery\";\n\n#[allow(clippy::too_many_arguments)]\n#[instrument(skip_all)]\n#[cfg(feature = \"revenue_recovery\")]\npub async fn recovery_incoming_webhook_flow(\n    state: SessionState,\n    platform: domain::Platform,\n    business_profile: domain::Profile,\n    source_verified: bool,\n    connector_enum: &connect\n\n... [truncated 65608 chars] ...\n\n      logger::info!(\"Payment has been succeeded via external system\");\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::PendingPayment => {\n                logger::info!(\n                    \"Pending transactions are not consumed by the revenue recovery webhooks\"\n                );\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::NoAction => {\n                logger::info!(\n                    \"No Recovery action is taken place for recovery event and attempt triggered_by\"\n                );\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::InvalidAction => {\n                logger::error!(\"Invalid Revenue recovery action state has been received\");\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n        }\n    }\n}\n", "function_name": "crates__router__src__core__webhooks__recovery_incoming.rs", "file": "crates__router__src__core__webhooks__recovery_incoming.rs"}, {"query": "hyperswitch recovery_incoming_webhook_flow", "code": "use std::{collections::HashMap, marker::PhantomData, str::FromStr};\n\nuse api_models::{enums as api_enums, payments as api_payments, webhooks};\nuse common_utils::{\n    ext_traits::{AsyncExt, ValueExt},\n    id_type,\n};\nuse diesel_models::process_tracker as storage;\nuse error_stack::{report, ResultExt};\nuse futures::stream::SelectNextSome;\nuse hyperswitch_domain_models::{\n    payments as domain_payments,\n    revenue_recovery::{self, RecoveryPaymentIntent},\n    router_data_v2::flow_common_types,\n    router_flow_types,\n    router_request_types::revenue_recovery as revenue_recovery_request,\n    router_response_types::revenue_recovery as revenue_recovery_response,\n    types as router_types,\n};\nuse hyperswitch_interfaces::webhooks as interface_webhooks;\nuse masking::{PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse services::kafka;\nuse storage::business_status;\n\nuse crate::{\n    consts,\n    core::{\n        self, admin,\n        errors::{self, CustomResult},\n        payments::{self, helpers},\n    },\n    db::{errors::RevenueRecoveryError, StorageInterface},\n    routes::{app::ReqState, metrics, SessionState},\n    services::{\n        self,\n        connector_integration_interface::{self, RouterDataConversion},\n    },\n    types::{\n        self, api, domain,\n        storage::{\n            revenue_recovery as storage_revenue_recovery,\n            revenue_recovery_redis_operation::{\n                PaymentProcessorTokenDetails, PaymentProcessorTokenStatus, RedisTokenManager,\n            },\n        },\n        transformers::ForeignFrom,\n    },\n    workflows::revenue_recovery as revenue_recovery_flow,\n};\n#[cfg(feature = \"v2\")]\npub const REVENUE_RECOVERY: &str = \"revenue_recovery\";\n\n#[allow(clippy::too_many_arguments)]\n#[instrument(skip_all)]\n#[cfg(feature = \"revenue_recovery\")]\npub async fn recovery_incoming_webhook_flow(\n    state: SessionState,\n    platform: domain::Platform,\n    business_profile: domain::Profile,\n    source_verified: bool,\n    connector_enum: &connect\n\n... [truncated 65608 chars] ...\n\n      logger::info!(\"Payment has been succeeded via external system\");\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::PendingPayment => {\n                logger::info!(\n                    \"Pending transactions are not consumed by the revenue recovery webhooks\"\n                );\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::NoAction => {\n                logger::info!(\n                    \"No Recovery action is taken place for recovery event and attempt triggered_by\"\n                );\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::InvalidAction => {\n                logger::error!(\"Invalid Revenue recovery action state has been received\");\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n        }\n    }\n}\n", "function_name": "crates__router__src__core__webhooks__recovery_incoming.rs", "file": "crates__router__src__core__webhooks__recovery_incoming.rs"}, {"query": "how to handle failed payment retries", "code": "use std::{collections::HashMap, marker::PhantomData, str::FromStr};\n\nuse api_models::{enums as api_enums, payments as api_payments, webhooks};\nuse common_utils::{\n    ext_traits::{AsyncExt, ValueExt},\n    id_type,\n};\nuse diesel_models::process_tracker as storage;\nuse error_stack::{report, ResultExt};\nuse futures::stream::SelectNextSome;\nuse hyperswitch_domain_models::{\n    payments as domain_payments,\n    revenue_recovery::{self, RecoveryPaymentIntent},\n    router_data_v2::flow_common_types,\n    router_flow_types,\n    router_request_types::revenue_recovery as revenue_recovery_request,\n    router_response_types::revenue_recovery as revenue_recovery_response,\n    types as router_types,\n};\nuse hyperswitch_interfaces::webhooks as interface_webhooks;\nuse masking::{PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse services::kafka;\nuse storage::business_status;\n\nuse crate::{\n    consts,\n    core::{\n        self, admin,\n        errors::{self, CustomResult},\n        payments::{self, helpers},\n    },\n    db::{errors::RevenueRecoveryError, StorageInterface},\n    routes::{app::ReqState, metrics, SessionState},\n    services::{\n        self,\n        connector_integration_interface::{self, RouterDataConversion},\n    },\n    types::{\n        self, api, domain,\n        storage::{\n            revenue_recovery as storage_revenue_recovery,\n            revenue_recovery_redis_operation::{\n                PaymentProcessorTokenDetails, PaymentProcessorTokenStatus, RedisTokenManager,\n            },\n        },\n        transformers::ForeignFrom,\n    },\n    workflows::revenue_recovery as revenue_recovery_flow,\n};\n#[cfg(feature = \"v2\")]\npub const REVENUE_RECOVERY: &str = \"revenue_recovery\";\n\n#[allow(clippy::too_many_arguments)]\n#[instrument(skip_all)]\n#[cfg(feature = \"revenue_recovery\")]\npub async fn recovery_incoming_webhook_flow(\n    state: SessionState,\n    platform: domain::Platform,\n    business_profile: domain::Profile,\n    source_verified: bool,\n    connector_enum: &connect\n\n... [truncated 65608 chars] ...\n\n      logger::info!(\"Payment has been succeeded via external system\");\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::PendingPayment => {\n                logger::info!(\n                    \"Pending transactions are not consumed by the revenue recovery webhooks\"\n                );\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::NoAction => {\n                logger::info!(\n                    \"No Recovery action is taken place for recovery event and attempt triggered_by\"\n                );\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::InvalidAction => {\n                logger::error!(\"Invalid Revenue recovery action state has been received\");\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n        }\n    }\n}\n", "function_name": "crates__router__src__core__webhooks__recovery_incoming.rs", "file": "crates__router__src__core__webhooks__recovery_incoming.rs"}, {"query": "revenue recovery payment intent state machine", "code": "use std::{collections::HashMap, marker::PhantomData, str::FromStr};\n\nuse api_models::{enums as api_enums, payments as api_payments, webhooks};\nuse common_utils::{\n    ext_traits::{AsyncExt, ValueExt},\n    id_type,\n};\nuse diesel_models::process_tracker as storage;\nuse error_stack::{report, ResultExt};\nuse futures::stream::SelectNextSome;\nuse hyperswitch_domain_models::{\n    payments as domain_payments,\n    revenue_recovery::{self, RecoveryPaymentIntent},\n    router_data_v2::flow_common_types,\n    router_flow_types,\n    router_request_types::revenue_recovery as revenue_recovery_request,\n    router_response_types::revenue_recovery as revenue_recovery_response,\n    types as router_types,\n};\nuse hyperswitch_interfaces::webhooks as interface_webhooks;\nuse masking::{PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse services::kafka;\nuse storage::business_status;\n\nuse crate::{\n    consts,\n    core::{\n        self, admin,\n        errors::{self, CustomResult},\n        payments::{self, helpers},\n    },\n    db::{errors::RevenueRecoveryError, StorageInterface},\n    routes::{app::ReqState, metrics, SessionState},\n    services::{\n        self,\n        connector_integration_interface::{self, RouterDataConversion},\n    },\n    types::{\n        self, api, domain,\n        storage::{\n            revenue_recovery as storage_revenue_recovery,\n            revenue_recovery_redis_operation::{\n                PaymentProcessorTokenDetails, PaymentProcessorTokenStatus, RedisTokenManager,\n            },\n        },\n        transformers::ForeignFrom,\n    },\n    workflows::revenue_recovery as revenue_recovery_flow,\n};\n#[cfg(feature = \"v2\")]\npub const REVENUE_RECOVERY: &str = \"revenue_recovery\";\n\n#[allow(clippy::too_many_arguments)]\n#[instrument(skip_all)]\n#[cfg(feature = \"revenue_recovery\")]\npub async fn recovery_incoming_webhook_flow(\n    state: SessionState,\n    platform: domain::Platform,\n    business_profile: domain::Profile,\n    source_verified: bool,\n    connector_enum: &connect\n\n... [truncated 65608 chars] ...\n\n      logger::info!(\"Payment has been succeeded via external system\");\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::PendingPayment => {\n                logger::info!(\n                    \"Pending transactions are not consumed by the revenue recovery webhooks\"\n                );\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::NoAction => {\n                logger::info!(\n                    \"No Recovery action is taken place for recovery event and attempt triggered_by\"\n                );\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n            common_types::payments::RecoveryAction::InvalidAction => {\n                logger::error!(\"Invalid Revenue recovery action state has been received\");\n                Ok(webhooks::WebhookResponseTracker::NoEffect)\n            }\n        }\n    }\n}\n", "function_name": "crates__router__src__core__webhooks__recovery_incoming.rs", "file": "crates__router__src__core__webhooks__recovery_incoming.rs"}, {"query": "how to insert payment attempt", "code": "use common_utils::{errors::CustomResult, ext_traits::AsyncExt};\n#[cfg(feature = \"v1\")]\nuse common_utils::{fallback_reverse_lookup_not_found, types::ConnectorTransactionId};\nuse diesel_models::{\n    enums::{\n        MandateAmountData as DieselMandateAmountData, MandateDataType as DieselMandateType,\n        MandateDetails as DieselMandateDetails, MerchantStorageScheme,\n    },\n    kv,\n    payment_attempt::PaymentAttempt as DieselPaymentAttempt,\n    reverse_lookup::{ReverseLookup, ReverseLookupNew},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse futures::future::{try_join_all, FutureExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    mandates::{MandateAmountData, MandateDataType, MandateDetails},\n    merchant_key_store::MerchantKeyStore,\n    payments::payment_attempt::{PaymentAttempt, PaymentAttemptInterface, PaymentAttemptUpdate},\n};\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse hyperswitch_domain_models::{\n    payments::payment_attempt::PaymentListFilters, payments::PaymentIntent,\n};\n#[cfg(feature = \"v2\")]\nuse label::*;\nuse redis_interface::HsetnxReply;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::kv_router_store::{FilterResourceParams, FindResourceBy, UpdateResourceParams};\nuse crate::{\n    diesel_error_to_data_error, errors,\n    errors::RedisErrorExt,\n    kv_router_store::KVRouterStore,\n    lookup::ReverseLookupInterface,\n    redis::kv_store::{decide_storage_scheme, kv_wrapper, KvOperation, Op, PartitionKey},\n    utils::{pg_connection_read, pg_connection_write, try_redis_get_else_try_database_get},\n    DataModelExt, DatabaseStore, RouterStore,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentAttemptInterface for RouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: \n\n... [truncated 87123 chars] ...\n\nookupNew {\n        lookup_id: format!(\n            \"pa_preprocessing_{}_{}\",\n            merchant_id.get_string_repr(),\n            preprocessing_id\n        ),\n        pk_id: key.to_owned(),\n        sk_id: field.clone(),\n        source: \"payment_attempt\".to_string(),\n        updated_by: storage_scheme.to_string(),\n    };\n    store\n        .insert_reverse_lookup(reverse_lookup_new, storage_scheme)\n        .await\n}\n\n#[cfg(feature = \"v2\")]\nmod label {\n    pub(super) const MODEL_NAME: &str = \"payment_attempt_v2\";\n    pub(super) const CLUSTER_LABEL: &str = \"pa\";\n\n    pub(super) fn get_profile_id_connector_transaction_label(\n        profile_id: &str,\n        connector_transaction_id: &str,\n    ) -> String {\n        format!(\"profile_{profile_id}_conn_txn_{connector_transaction_id}\")\n    }\n\n    pub(super) fn get_global_id_label(\n        attempt_id: &common_utils::id_type::GlobalAttemptId,\n    ) -> String {\n        format!(\"attempt_global_id_{}\", attempt_id.get_string_repr())\n    }\n}\n", "function_name": "crates__storage_impl__src__payments__payment_attempt.rs", "file": "crates__storage_impl__src__payments__payment_attempt.rs"}, {"query": "PaymentAttemptInterface implementation", "code": "use common_utils::{errors::CustomResult, ext_traits::AsyncExt};\n#[cfg(feature = \"v1\")]\nuse common_utils::{fallback_reverse_lookup_not_found, types::ConnectorTransactionId};\nuse diesel_models::{\n    enums::{\n        MandateAmountData as DieselMandateAmountData, MandateDataType as DieselMandateType,\n        MandateDetails as DieselMandateDetails, MerchantStorageScheme,\n    },\n    kv,\n    payment_attempt::PaymentAttempt as DieselPaymentAttempt,\n    reverse_lookup::{ReverseLookup, ReverseLookupNew},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse futures::future::{try_join_all, FutureExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    mandates::{MandateAmountData, MandateDataType, MandateDetails},\n    merchant_key_store::MerchantKeyStore,\n    payments::payment_attempt::{PaymentAttempt, PaymentAttemptInterface, PaymentAttemptUpdate},\n};\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse hyperswitch_domain_models::{\n    payments::payment_attempt::PaymentListFilters, payments::PaymentIntent,\n};\n#[cfg(feature = \"v2\")]\nuse label::*;\nuse redis_interface::HsetnxReply;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::kv_router_store::{FilterResourceParams, FindResourceBy, UpdateResourceParams};\nuse crate::{\n    diesel_error_to_data_error, errors,\n    errors::RedisErrorExt,\n    kv_router_store::KVRouterStore,\n    lookup::ReverseLookupInterface,\n    redis::kv_store::{decide_storage_scheme, kv_wrapper, KvOperation, Op, PartitionKey},\n    utils::{pg_connection_read, pg_connection_write, try_redis_get_else_try_database_get},\n    DataModelExt, DatabaseStore, RouterStore,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentAttemptInterface for RouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: \n\n... [truncated 87123 chars] ...\n\nookupNew {\n        lookup_id: format!(\n            \"pa_preprocessing_{}_{}\",\n            merchant_id.get_string_repr(),\n            preprocessing_id\n        ),\n        pk_id: key.to_owned(),\n        sk_id: field.clone(),\n        source: \"payment_attempt\".to_string(),\n        updated_by: storage_scheme.to_string(),\n    };\n    store\n        .insert_reverse_lookup(reverse_lookup_new, storage_scheme)\n        .await\n}\n\n#[cfg(feature = \"v2\")]\nmod label {\n    pub(super) const MODEL_NAME: &str = \"payment_attempt_v2\";\n    pub(super) const CLUSTER_LABEL: &str = \"pa\";\n\n    pub(super) fn get_profile_id_connector_transaction_label(\n        profile_id: &str,\n        connector_transaction_id: &str,\n    ) -> String {\n        format!(\"profile_{profile_id}_conn_txn_{connector_transaction_id}\")\n    }\n\n    pub(super) fn get_global_id_label(\n        attempt_id: &common_utils::id_type::GlobalAttemptId,\n    ) -> String {\n        format!(\"attempt_global_id_{}\", attempt_id.get_string_repr())\n    }\n}\n", "function_name": "crates__storage_impl__src__payments__payment_attempt.rs", "file": "crates__storage_impl__src__payments__payment_attempt.rs"}, {"query": "how to update payment attempt status", "code": "use common_utils::{errors::CustomResult, ext_traits::AsyncExt};\n#[cfg(feature = \"v1\")]\nuse common_utils::{fallback_reverse_lookup_not_found, types::ConnectorTransactionId};\nuse diesel_models::{\n    enums::{\n        MandateAmountData as DieselMandateAmountData, MandateDataType as DieselMandateType,\n        MandateDetails as DieselMandateDetails, MerchantStorageScheme,\n    },\n    kv,\n    payment_attempt::PaymentAttempt as DieselPaymentAttempt,\n    reverse_lookup::{ReverseLookup, ReverseLookupNew},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse futures::future::{try_join_all, FutureExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    mandates::{MandateAmountData, MandateDataType, MandateDetails},\n    merchant_key_store::MerchantKeyStore,\n    payments::payment_attempt::{PaymentAttempt, PaymentAttemptInterface, PaymentAttemptUpdate},\n};\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse hyperswitch_domain_models::{\n    payments::payment_attempt::PaymentListFilters, payments::PaymentIntent,\n};\n#[cfg(feature = \"v2\")]\nuse label::*;\nuse redis_interface::HsetnxReply;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::kv_router_store::{FilterResourceParams, FindResourceBy, UpdateResourceParams};\nuse crate::{\n    diesel_error_to_data_error, errors,\n    errors::RedisErrorExt,\n    kv_router_store::KVRouterStore,\n    lookup::ReverseLookupInterface,\n    redis::kv_store::{decide_storage_scheme, kv_wrapper, KvOperation, Op, PartitionKey},\n    utils::{pg_connection_read, pg_connection_write, try_redis_get_else_try_database_get},\n    DataModelExt, DatabaseStore, RouterStore,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentAttemptInterface for RouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: \n\n... [truncated 87123 chars] ...\n\nookupNew {\n        lookup_id: format!(\n            \"pa_preprocessing_{}_{}\",\n            merchant_id.get_string_repr(),\n            preprocessing_id\n        ),\n        pk_id: key.to_owned(),\n        sk_id: field.clone(),\n        source: \"payment_attempt\".to_string(),\n        updated_by: storage_scheme.to_string(),\n    };\n    store\n        .insert_reverse_lookup(reverse_lookup_new, storage_scheme)\n        .await\n}\n\n#[cfg(feature = \"v2\")]\nmod label {\n    pub(super) const MODEL_NAME: &str = \"payment_attempt_v2\";\n    pub(super) const CLUSTER_LABEL: &str = \"pa\";\n\n    pub(super) fn get_profile_id_connector_transaction_label(\n        profile_id: &str,\n        connector_transaction_id: &str,\n    ) -> String {\n        format!(\"profile_{profile_id}_conn_txn_{connector_transaction_id}\")\n    }\n\n    pub(super) fn get_global_id_label(\n        attempt_id: &common_utils::id_type::GlobalAttemptId,\n    ) -> String {\n        format!(\"attempt_global_id_{}\", attempt_id.get_string_repr())\n    }\n}\n", "function_name": "crates__storage_impl__src__payments__payment_attempt.rs", "file": "crates__storage_impl__src__payments__payment_attempt.rs"}, {"query": "payment_attempt storage diesel redis", "code": "use common_utils::{errors::CustomResult, ext_traits::AsyncExt};\n#[cfg(feature = \"v1\")]\nuse common_utils::{fallback_reverse_lookup_not_found, types::ConnectorTransactionId};\nuse diesel_models::{\n    enums::{\n        MandateAmountData as DieselMandateAmountData, MandateDataType as DieselMandateType,\n        MandateDetails as DieselMandateDetails, MerchantStorageScheme,\n    },\n    kv,\n    payment_attempt::PaymentAttempt as DieselPaymentAttempt,\n    reverse_lookup::{ReverseLookup, ReverseLookupNew},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse futures::future::{try_join_all, FutureExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    mandates::{MandateAmountData, MandateDataType, MandateDetails},\n    merchant_key_store::MerchantKeyStore,\n    payments::payment_attempt::{PaymentAttempt, PaymentAttemptInterface, PaymentAttemptUpdate},\n};\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse hyperswitch_domain_models::{\n    payments::payment_attempt::PaymentListFilters, payments::PaymentIntent,\n};\n#[cfg(feature = \"v2\")]\nuse label::*;\nuse redis_interface::HsetnxReply;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::kv_router_store::{FilterResourceParams, FindResourceBy, UpdateResourceParams};\nuse crate::{\n    diesel_error_to_data_error, errors,\n    errors::RedisErrorExt,\n    kv_router_store::KVRouterStore,\n    lookup::ReverseLookupInterface,\n    redis::kv_store::{decide_storage_scheme, kv_wrapper, KvOperation, Op, PartitionKey},\n    utils::{pg_connection_read, pg_connection_write, try_redis_get_else_try_database_get},\n    DataModelExt, DatabaseStore, RouterStore,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentAttemptInterface for RouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: \n\n... [truncated 87123 chars] ...\n\nookupNew {\n        lookup_id: format!(\n            \"pa_preprocessing_{}_{}\",\n            merchant_id.get_string_repr(),\n            preprocessing_id\n        ),\n        pk_id: key.to_owned(),\n        sk_id: field.clone(),\n        source: \"payment_attempt\".to_string(),\n        updated_by: storage_scheme.to_string(),\n    };\n    store\n        .insert_reverse_lookup(reverse_lookup_new, storage_scheme)\n        .await\n}\n\n#[cfg(feature = \"v2\")]\nmod label {\n    pub(super) const MODEL_NAME: &str = \"payment_attempt_v2\";\n    pub(super) const CLUSTER_LABEL: &str = \"pa\";\n\n    pub(super) fn get_profile_id_connector_transaction_label(\n        profile_id: &str,\n        connector_transaction_id: &str,\n    ) -> String {\n        format!(\"profile_{profile_id}_conn_txn_{connector_transaction_id}\")\n    }\n\n    pub(super) fn get_global_id_label(\n        attempt_id: &common_utils::id_type::GlobalAttemptId,\n    ) -> String {\n        format!(\"attempt_global_id_{}\", attempt_id.get_string_repr())\n    }\n}\n", "function_name": "crates__storage_impl__src__payments__payment_attempt.rs", "file": "crates__storage_impl__src__payments__payment_attempt.rs"}, {"query": "payment analytics request types", "code": "use std::collections::HashSet;\n\npub use common_utils::types::TimeRange;\nuse common_utils::{events::ApiEventMetric, pii::EmailStrategy, types::authentication::AuthInfo};\nuse masking::Secret;\n\nuse self::{\n    active_payments::ActivePaymentsMetrics,\n    api_event::{ApiEventDimensions, ApiEventMetrics},\n    auth_events::{AuthEventDimensions, AuthEventFilters, AuthEventMetrics},\n    disputes::{DisputeDimensions, DisputeMetrics},\n    frm::{FrmDimensions, FrmMetrics},\n    payment_intents::{PaymentIntentDimensions, PaymentIntentMetrics},\n    payments::{PaymentDimensions, PaymentDistributions, PaymentMetrics},\n    refunds::{RefundDimensions, RefundDistributions, RefundMetrics},\n    sdk_events::{SdkEventDimensions, SdkEventMetrics},\n};\npub mod active_payments;\npub mod api_event;\npub mod auth_events;\npub mod connector_events;\npub mod disputes;\npub mod frm;\npub mod outgoing_webhook_event;\npub mod payment_intents;\npub mod payments;\npub mod refunds;\npub mod routing_events;\npub mod sdk_events;\npub mod search;\n\n#[derive(Debug, serde::Serialize)]\npub struct NameDescription {\n    pub name: String,\n    pub desc: String,\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetInfoResponse {\n    pub metrics: Vec<NameDescription>,\n    pub download_dimensions: Option<Vec<NameDescription>>,\n    pub dimensions: Vec<NameDescription>,\n}\n\n#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]\npub struct TimeSeries {\n    pub granularity: Granularity,\n}\n\n#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]\npub enum Granularity {\n    #[serde(rename = \"G_ONEMIN\")]\n    OneMin,\n    #[serde(rename = \"G_FIVEMIN\")]\n    FiveMin,\n    #[serde(rename = \"G_FIFTEENMIN\")]\n    FifteenMin,\n    #[serde(rename = \"G_THIRTYMIN\")]\n    ThirtyMin,\n    #[serde(rename = \"G_ONEHOUR\")]\n    OneHour,\n    #[serde(rename = \"G_ONEDAY\")]\n    OneDay,\n}\npub trait ForexMetric {\n    fn is_forex_metric(&self) -> bool;\n}\n\n#[derive(Clone, Debug, Default, serde::Deserialize, serde::Seria\n\n... [truncated 13808 chars] ...\n\nspute_status: Option<String>,\n    pub first_attempt: i64,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetAuthEventFilterRequest {\n    pub time_range: TimeRange,\n    #[serde(default)]\n    pub group_by_names: Vec<AuthEventDimensions>,\n}\n\n#[derive(Debug, Default, serde::Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventFiltersResponse {\n    pub query_data: Vec<AuthEventFilterValue>,\n}\n\n#[derive(Debug, serde::Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventFilterValue {\n    pub dimension: AuthEventDimensions,\n    pub values: Vec<String>,\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventMetricsResponse<T> {\n    pub query_data: Vec<T>,\n    pub meta_data: [AuthEventsAnalyticsMetadata; 1],\n}\n\n#[derive(Debug, serde::Serialize)]\npub struct AuthEventsAnalyticsMetadata {\n    pub total_error_message_count: Option<u64>,\n}\n", "function_name": "crates__api_models__src__analytics.rs", "file": "crates__api_models__src__analytics.rs"}, {"query": "GetPaymentMetricRequest struct", "code": "use std::collections::HashSet;\n\npub use common_utils::types::TimeRange;\nuse common_utils::{events::ApiEventMetric, pii::EmailStrategy, types::authentication::AuthInfo};\nuse masking::Secret;\n\nuse self::{\n    active_payments::ActivePaymentsMetrics,\n    api_event::{ApiEventDimensions, ApiEventMetrics},\n    auth_events::{AuthEventDimensions, AuthEventFilters, AuthEventMetrics},\n    disputes::{DisputeDimensions, DisputeMetrics},\n    frm::{FrmDimensions, FrmMetrics},\n    payment_intents::{PaymentIntentDimensions, PaymentIntentMetrics},\n    payments::{PaymentDimensions, PaymentDistributions, PaymentMetrics},\n    refunds::{RefundDimensions, RefundDistributions, RefundMetrics},\n    sdk_events::{SdkEventDimensions, SdkEventMetrics},\n};\npub mod active_payments;\npub mod api_event;\npub mod auth_events;\npub mod connector_events;\npub mod disputes;\npub mod frm;\npub mod outgoing_webhook_event;\npub mod payment_intents;\npub mod payments;\npub mod refunds;\npub mod routing_events;\npub mod sdk_events;\npub mod search;\n\n#[derive(Debug, serde::Serialize)]\npub struct NameDescription {\n    pub name: String,\n    pub desc: String,\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetInfoResponse {\n    pub metrics: Vec<NameDescription>,\n    pub download_dimensions: Option<Vec<NameDescription>>,\n    pub dimensions: Vec<NameDescription>,\n}\n\n#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]\npub struct TimeSeries {\n    pub granularity: Granularity,\n}\n\n#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]\npub enum Granularity {\n    #[serde(rename = \"G_ONEMIN\")]\n    OneMin,\n    #[serde(rename = \"G_FIVEMIN\")]\n    FiveMin,\n    #[serde(rename = \"G_FIFTEENMIN\")]\n    FifteenMin,\n    #[serde(rename = \"G_THIRTYMIN\")]\n    ThirtyMin,\n    #[serde(rename = \"G_ONEHOUR\")]\n    OneHour,\n    #[serde(rename = \"G_ONEDAY\")]\n    OneDay,\n}\npub trait ForexMetric {\n    fn is_forex_metric(&self) -> bool;\n}\n\n#[derive(Clone, Debug, Default, serde::Deserialize, serde::Seria\n\n... [truncated 13808 chars] ...\n\nspute_status: Option<String>,\n    pub first_attempt: i64,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetAuthEventFilterRequest {\n    pub time_range: TimeRange,\n    #[serde(default)]\n    pub group_by_names: Vec<AuthEventDimensions>,\n}\n\n#[derive(Debug, Default, serde::Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventFiltersResponse {\n    pub query_data: Vec<AuthEventFilterValue>,\n}\n\n#[derive(Debug, serde::Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventFilterValue {\n    pub dimension: AuthEventDimensions,\n    pub values: Vec<String>,\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventMetricsResponse<T> {\n    pub query_data: Vec<T>,\n    pub meta_data: [AuthEventsAnalyticsMetadata; 1],\n}\n\n#[derive(Debug, serde::Serialize)]\npub struct AuthEventsAnalyticsMetadata {\n    pub total_error_message_count: Option<u64>,\n}\n", "function_name": "crates__api_models__src__analytics.rs", "file": "crates__api_models__src__analytics.rs"}, {"query": "how to query payment metrics", "code": "use std::collections::HashSet;\n\npub use common_utils::types::TimeRange;\nuse common_utils::{events::ApiEventMetric, pii::EmailStrategy, types::authentication::AuthInfo};\nuse masking::Secret;\n\nuse self::{\n    active_payments::ActivePaymentsMetrics,\n    api_event::{ApiEventDimensions, ApiEventMetrics},\n    auth_events::{AuthEventDimensions, AuthEventFilters, AuthEventMetrics},\n    disputes::{DisputeDimensions, DisputeMetrics},\n    frm::{FrmDimensions, FrmMetrics},\n    payment_intents::{PaymentIntentDimensions, PaymentIntentMetrics},\n    payments::{PaymentDimensions, PaymentDistributions, PaymentMetrics},\n    refunds::{RefundDimensions, RefundDistributions, RefundMetrics},\n    sdk_events::{SdkEventDimensions, SdkEventMetrics},\n};\npub mod active_payments;\npub mod api_event;\npub mod auth_events;\npub mod connector_events;\npub mod disputes;\npub mod frm;\npub mod outgoing_webhook_event;\npub mod payment_intents;\npub mod payments;\npub mod refunds;\npub mod routing_events;\npub mod sdk_events;\npub mod search;\n\n#[derive(Debug, serde::Serialize)]\npub struct NameDescription {\n    pub name: String,\n    pub desc: String,\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetInfoResponse {\n    pub metrics: Vec<NameDescription>,\n    pub download_dimensions: Option<Vec<NameDescription>>,\n    pub dimensions: Vec<NameDescription>,\n}\n\n#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]\npub struct TimeSeries {\n    pub granularity: Granularity,\n}\n\n#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]\npub enum Granularity {\n    #[serde(rename = \"G_ONEMIN\")]\n    OneMin,\n    #[serde(rename = \"G_FIVEMIN\")]\n    FiveMin,\n    #[serde(rename = \"G_FIFTEENMIN\")]\n    FifteenMin,\n    #[serde(rename = \"G_THIRTYMIN\")]\n    ThirtyMin,\n    #[serde(rename = \"G_ONEHOUR\")]\n    OneHour,\n    #[serde(rename = \"G_ONEDAY\")]\n    OneDay,\n}\npub trait ForexMetric {\n    fn is_forex_metric(&self) -> bool;\n}\n\n#[derive(Clone, Debug, Default, serde::Deserialize, serde::Seria\n\n... [truncated 13808 chars] ...\n\nspute_status: Option<String>,\n    pub first_attempt: i64,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetAuthEventFilterRequest {\n    pub time_range: TimeRange,\n    #[serde(default)]\n    pub group_by_names: Vec<AuthEventDimensions>,\n}\n\n#[derive(Debug, Default, serde::Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventFiltersResponse {\n    pub query_data: Vec<AuthEventFilterValue>,\n}\n\n#[derive(Debug, serde::Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventFilterValue {\n    pub dimension: AuthEventDimensions,\n    pub values: Vec<String>,\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventMetricsResponse<T> {\n    pub query_data: Vec<T>,\n    pub meta_data: [AuthEventsAnalyticsMetadata; 1],\n}\n\n#[derive(Debug, serde::Serialize)]\npub struct AuthEventsAnalyticsMetadata {\n    pub total_error_message_count: Option<u64>,\n}\n", "function_name": "crates__api_models__src__analytics.rs", "file": "crates__api_models__src__analytics.rs"}, {"query": "dispute analytics data structures", "code": "use std::collections::HashSet;\n\npub use common_utils::types::TimeRange;\nuse common_utils::{events::ApiEventMetric, pii::EmailStrategy, types::authentication::AuthInfo};\nuse masking::Secret;\n\nuse self::{\n    active_payments::ActivePaymentsMetrics,\n    api_event::{ApiEventDimensions, ApiEventMetrics},\n    auth_events::{AuthEventDimensions, AuthEventFilters, AuthEventMetrics},\n    disputes::{DisputeDimensions, DisputeMetrics},\n    frm::{FrmDimensions, FrmMetrics},\n    payment_intents::{PaymentIntentDimensions, PaymentIntentMetrics},\n    payments::{PaymentDimensions, PaymentDistributions, PaymentMetrics},\n    refunds::{RefundDimensions, RefundDistributions, RefundMetrics},\n    sdk_events::{SdkEventDimensions, SdkEventMetrics},\n};\npub mod active_payments;\npub mod api_event;\npub mod auth_events;\npub mod connector_events;\npub mod disputes;\npub mod frm;\npub mod outgoing_webhook_event;\npub mod payment_intents;\npub mod payments;\npub mod refunds;\npub mod routing_events;\npub mod sdk_events;\npub mod search;\n\n#[derive(Debug, serde::Serialize)]\npub struct NameDescription {\n    pub name: String,\n    pub desc: String,\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetInfoResponse {\n    pub metrics: Vec<NameDescription>,\n    pub download_dimensions: Option<Vec<NameDescription>>,\n    pub dimensions: Vec<NameDescription>,\n}\n\n#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]\npub struct TimeSeries {\n    pub granularity: Granularity,\n}\n\n#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]\npub enum Granularity {\n    #[serde(rename = \"G_ONEMIN\")]\n    OneMin,\n    #[serde(rename = \"G_FIVEMIN\")]\n    FiveMin,\n    #[serde(rename = \"G_FIFTEENMIN\")]\n    FifteenMin,\n    #[serde(rename = \"G_THIRTYMIN\")]\n    ThirtyMin,\n    #[serde(rename = \"G_ONEHOUR\")]\n    OneHour,\n    #[serde(rename = \"G_ONEDAY\")]\n    OneDay,\n}\npub trait ForexMetric {\n    fn is_forex_metric(&self) -> bool;\n}\n\n#[derive(Clone, Debug, Default, serde::Deserialize, serde::Seria\n\n... [truncated 13808 chars] ...\n\nspute_status: Option<String>,\n    pub first_attempt: i64,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetAuthEventFilterRequest {\n    pub time_range: TimeRange,\n    #[serde(default)]\n    pub group_by_names: Vec<AuthEventDimensions>,\n}\n\n#[derive(Debug, Default, serde::Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventFiltersResponse {\n    pub query_data: Vec<AuthEventFilterValue>,\n}\n\n#[derive(Debug, serde::Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventFilterValue {\n    pub dimension: AuthEventDimensions,\n    pub values: Vec<String>,\n}\n\n#[derive(Debug, serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthEventMetricsResponse<T> {\n    pub query_data: Vec<T>,\n    pub meta_data: [AuthEventsAnalyticsMetadata; 1],\n}\n\n#[derive(Debug, serde::Serialize)]\npub struct AuthEventsAnalyticsMetadata {\n    pub total_error_message_count: Option<u64>,\n}\n", "function_name": "crates__api_models__src__analytics.rs", "file": "crates__api_models__src__analytics.rs"}, {"query": "Klarna payment gateway connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSessionRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as klarna;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils:\n\n... [truncated 66472 chars] ...\n\nure_methods,\n            specific_features: None,\n        },\n    );\n\n    klarna_supported_payment_methods\n});\n\nstatic KLARNA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Klarna\",\n    description: \"Klarna provides payment processing services for the e-commerce industry, managing store claims and customer payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic KLARNA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Klarna {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&KLARNA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*KLARNA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&KLARNA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__klarna.rs", "file": "crates__hyperswitch_connectors__src__connectors__klarna.rs"}, {"query": "hyperswitch Klarna connector authentication", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSessionRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as klarna;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils:\n\n... [truncated 66472 chars] ...\n\nure_methods,\n            specific_features: None,\n        },\n    );\n\n    klarna_supported_payment_methods\n});\n\nstatic KLARNA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Klarna\",\n    description: \"Klarna provides payment processing services for the e-commerce industry, managing store claims and customer payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic KLARNA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Klarna {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&KLARNA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*KLARNA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&KLARNA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__klarna.rs", "file": "crates__hyperswitch_connectors__src__connectors__klarna.rs"}, {"query": "how to integrate Klarna with hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSessionRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as klarna;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils:\n\n... [truncated 66472 chars] ...\n\nure_methods,\n            specific_features: None,\n        },\n    );\n\n    klarna_supported_payment_methods\n});\n\nstatic KLARNA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Klarna\",\n    description: \"Klarna provides payment processing services for the e-commerce industry, managing store claims and customer payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic KLARNA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Klarna {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&KLARNA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*KLARNA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&KLARNA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__klarna.rs", "file": "crates__hyperswitch_connectors__src__connectors__klarna.rs"}, {"query": "Klarna payment method details configuration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSessionRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as klarna;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils:\n\n... [truncated 66472 chars] ...\n\nure_methods,\n            specific_features: None,\n        },\n    );\n\n    klarna_supported_payment_methods\n});\n\nstatic KLARNA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Klarna\",\n    description: \"Klarna provides payment processing services for the e-commerce industry, managing store claims and customer payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic KLARNA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Klarna {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&KLARNA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*KLARNA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&KLARNA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__klarna.rs", "file": "crates__hyperswitch_connectors__src__connectors__klarna.rs"}, {"query": "Powertranz connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as powertranz;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, PaymentsAuthorizeRequestDa\n\n... [truncated 22932 chars] ...\n\n    }),\n                ),\n            },\n        );\n\n        powertranz_supported_payment_methods\n    });\n\nstatic POWERTRANZ_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Powertranz\",\n    description: \"Powertranz is a leading payment gateway serving the Caribbean and parts of Central America \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic POWERTRANZ_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Powertranz {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&POWERTRANZ_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*POWERTRANZ_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&POWERTRANZ_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "file": "crates__hyperswitch_connectors__src__connectors__powertranz.rs"}, {"query": "Powertranz payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as powertranz;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, PaymentsAuthorizeRequestDa\n\n... [truncated 22932 chars] ...\n\n    }),\n                ),\n            },\n        );\n\n        powertranz_supported_payment_methods\n    });\n\nstatic POWERTRANZ_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Powertranz\",\n    description: \"Powertranz is a leading payment gateway serving the Caribbean and parts of Central America \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic POWERTRANZ_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Powertranz {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&POWERTRANZ_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*POWERTRANZ_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&POWERTRANZ_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "file": "crates__hyperswitch_connectors__src__connectors__powertranz.rs"}, {"query": "how to add new payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as powertranz;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, PaymentsAuthorizeRequestDa\n\n... [truncated 22932 chars] ...\n\n    }),\n                ),\n            },\n        );\n\n        powertranz_supported_payment_methods\n    });\n\nstatic POWERTRANZ_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Powertranz\",\n    description: \"Powertranz is a leading payment gateway serving the Caribbean and parts of Central America \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic POWERTRANZ_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Powertranz {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&POWERTRANZ_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*POWERTRANZ_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&POWERTRANZ_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "file": "crates__hyperswitch_connectors__src__connectors__powertranz.rs"}, {"query": "Powertranz API integration hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as powertranz;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, PaymentsAuthorizeRequestDa\n\n... [truncated 22932 chars] ...\n\n    }),\n                ),\n            },\n        );\n\n        powertranz_supported_payment_methods\n    });\n\nstatic POWERTRANZ_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Powertranz\",\n    description: \"Powertranz is a leading payment gateway serving the Caribbean and parts of Central America \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic POWERTRANZ_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Powertranz {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&POWERTRANZ_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*POWERTRANZ_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&POWERTRANZ_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "file": "crates__hyperswitch_connectors__src__connectors__powertranz.rs"}, {"query": "how to transform Hyperswitch payments to Elavon", "code": "use cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_utils::{pii::Email, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Deserializer, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{CardData, PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _},\n};\n\npub struct ElavonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for ElavonRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum ElavonPaymentsRequest {\n    Card(CardPaymentRequest),\n    MandatePayment(MandatePaymentRequest),\n}\n#[derive(Debug, Serialize)]\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Sec\n\n... [truncated 23765 chars] ...\n\nnse,\n) -> enums::AttemptStatus {\n    match item.ssl_trans_status {\n        TransactionSyncStatus::REV | TransactionSyncStatus::OPN | TransactionSyncStatus::PEN => {\n            prev_status\n        }\n        TransactionSyncStatus::STL => match item.ssl_transaction_type {\n            SyncTransactionType::Sale => enums::AttemptStatus::Charged,\n            SyncTransactionType::AuthOnly => enums::AttemptStatus::Authorized,\n            SyncTransactionType::Return => enums::AttemptStatus::Pending,\n        },\n        TransactionSyncStatus::PST | TransactionSyncStatus::FPR | TransactionSyncStatus::PRE => {\n            enums::AttemptStatus::Failure\n        }\n    }\n}\n\nfn get_payment_status(item: &ElavonResult, is_auto_capture: bool) -> enums::AttemptStatus {\n    if item.is_successful() {\n        if is_auto_capture {\n            enums::AttemptStatus::Charged\n        } else {\n            enums::AttemptStatus::Authorized\n        }\n    } else {\n        enums::AttemptStatus::Failure\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs"}, {"query": "ElavonPaymentsRequest struct definition", "code": "use cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_utils::{pii::Email, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Deserializer, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{CardData, PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _},\n};\n\npub struct ElavonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for ElavonRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum ElavonPaymentsRequest {\n    Card(CardPaymentRequest),\n    MandatePayment(MandatePaymentRequest),\n}\n#[derive(Debug, Serialize)]\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Sec\n\n... [truncated 23765 chars] ...\n\nnse,\n) -> enums::AttemptStatus {\n    match item.ssl_trans_status {\n        TransactionSyncStatus::REV | TransactionSyncStatus::OPN | TransactionSyncStatus::PEN => {\n            prev_status\n        }\n        TransactionSyncStatus::STL => match item.ssl_transaction_type {\n            SyncTransactionType::Sale => enums::AttemptStatus::Charged,\n            SyncTransactionType::AuthOnly => enums::AttemptStatus::Authorized,\n            SyncTransactionType::Return => enums::AttemptStatus::Pending,\n        },\n        TransactionSyncStatus::PST | TransactionSyncStatus::FPR | TransactionSyncStatus::PRE => {\n            enums::AttemptStatus::Failure\n        }\n    }\n}\n\nfn get_payment_status(item: &ElavonResult, is_auto_capture: bool) -> enums::AttemptStatus {\n    if item.is_successful() {\n        if is_auto_capture {\n            enums::AttemptStatus::Charged\n        } else {\n            enums::AttemptStatus::Authorized\n        }\n    } else {\n        enums::AttemptStatus::Failure\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs"}, {"query": "implement Elavon refund sync", "code": "use cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_utils::{pii::Email, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Deserializer, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{CardData, PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _},\n};\n\npub struct ElavonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for ElavonRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum ElavonPaymentsRequest {\n    Card(CardPaymentRequest),\n    MandatePayment(MandatePaymentRequest),\n}\n#[derive(Debug, Serialize)]\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Sec\n\n... [truncated 23765 chars] ...\n\nnse,\n) -> enums::AttemptStatus {\n    match item.ssl_trans_status {\n        TransactionSyncStatus::REV | TransactionSyncStatus::OPN | TransactionSyncStatus::PEN => {\n            prev_status\n        }\n        TransactionSyncStatus::STL => match item.ssl_transaction_type {\n            SyncTransactionType::Sale => enums::AttemptStatus::Charged,\n            SyncTransactionType::AuthOnly => enums::AttemptStatus::Authorized,\n            SyncTransactionType::Return => enums::AttemptStatus::Pending,\n        },\n        TransactionSyncStatus::PST | TransactionSyncStatus::FPR | TransactionSyncStatus::PRE => {\n            enums::AttemptStatus::Failure\n        }\n    }\n}\n\nfn get_payment_status(item: &ElavonResult, is_auto_capture: bool) -> enums::AttemptStatus {\n    if item.is_successful() {\n        if is_auto_capture {\n            enums::AttemptStatus::Charged\n        } else {\n            enums::AttemptStatus::Authorized\n        }\n    } else {\n        enums::AttemptStatus::Failure\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs"}, {"query": "Elavon payment authorization request format", "code": "use cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_utils::{pii::Email, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Deserializer, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{CardData, PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _},\n};\n\npub struct ElavonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for ElavonRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum ElavonPaymentsRequest {\n    Card(CardPaymentRequest),\n    MandatePayment(MandatePaymentRequest),\n}\n#[derive(Debug, Serialize)]\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Sec\n\n... [truncated 23765 chars] ...\n\nnse,\n) -> enums::AttemptStatus {\n    match item.ssl_trans_status {\n        TransactionSyncStatus::REV | TransactionSyncStatus::OPN | TransactionSyncStatus::PEN => {\n            prev_status\n        }\n        TransactionSyncStatus::STL => match item.ssl_transaction_type {\n            SyncTransactionType::Sale => enums::AttemptStatus::Charged,\n            SyncTransactionType::AuthOnly => enums::AttemptStatus::Authorized,\n            SyncTransactionType::Return => enums::AttemptStatus::Pending,\n        },\n        TransactionSyncStatus::PST | TransactionSyncStatus::FPR | TransactionSyncStatus::PRE => {\n            enums::AttemptStatus::Failure\n        }\n    }\n}\n\nfn get_payment_status(item: &ElavonResult, is_auto_capture: bool) -> enums::AttemptStatus {\n    if item.is_successful() {\n        if is_auto_capture {\n            enums::AttemptStatus::Charged\n        } else {\n            enums::AttemptStatus::Authorized\n        }\n    } else {\n        enums::AttemptStatus::Failure\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs"}, {"query": "Hyperswitch router data trait implementation", "code": "use std::{\n    collections::{HashMap, HashSet},\n    ops::Deref,\n    str::FromStr,\n    sync::LazyLock,\n};\n\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::{self, PayoutVendorAccountDetails};\nuse api_models::{\n    enums::{CanadaStatesAbbreviation, UsStatesAbbreviation},\n    payments,\n};\nuse base64::Engine;\nuse cards::NetworkToken;\nuse common_utils::{\n    date_time,\n    errors::{ParsingError, ReportSwitchExt},\n    ext_traits::StringExt,\n    id_type,\n    pii::{self, Email, IpAddress},\n    types::{AmountConvertor, MinorUnit},\n};\nuse diesel_models::{enums, types::OrderDetailsWithAmount};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt;\nuse masking::{Deserialize, ExposeInterface, Secret};\nuse regex::Regex;\n\n#[cfg(feature = \"frm\")]\nuse crate::types::fraud_check;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, ApiErrorResponse, CustomResult},\n        payments::{types::AuthenticationData, PaymentData},\n    },\n    pii::PeekInterface,\n    types::{\n        self, api, domain,\n        storage::enums as storage_enums,\n        transformers::{ForeignFrom, ForeignTryFrom},\n        BrowserInformation, PaymentsCancelData, ResponseId,\n    },\n    utils::{OptionExt, ValueExt},\n};\n\npub fn missing_field_err(\n    message: &'static str,\n) -> Box<dyn Fn() -> error_stack::Report<errors::ConnectorError> + 'static> {\n    Box::new(move || {\n        errors::ConnectorError::MissingRequiredField {\n            field_name: message,\n        }\n        .into()\n    })\n}\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub trait AccessTokenRequestInfo {\n    fn get_request_id(&self) -> Result<Secret<String>, Error>;\n}\n\nimpl AccessTokenRequestInfo for types::RefreshTokenRouterData {\n    fn get_request_id(&self) -> Result<Secret<String>, Error> {\n        self.request\n            .id\n            .clone()\n            .ok_or_else(missing_field_err(\"request.id\"))\n    }\n}\n\npub trait RouterData {\n    fn get_billing(&self) -> Result<&hype\n\n... [truncated 113213 chars] ...\n\n\")]\n    fn get_network_token_expiry_month(&self) -> Secret<String> {\n        self.network_token_exp_month.clone()\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn get_network_token_expiry_year(&self) -> Secret<String> {\n        self.token_exp_year.clone()\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn get_network_token_expiry_year(&self) -> Secret<String> {\n        self.network_token_exp_year.clone()\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn get_cryptogram(&self) -> Option<Secret<String>> {\n        self.token_cryptogram.clone()\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn get_cryptogram(&self) -> Option<Secret<String>> {\n        self.cryptogram.clone()\n    }\n}\n\npub fn convert_uppercase<'de, D, T>(v: D) -> Result<T, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n    T: FromStr,\n    <T as FromStr>::Err: std::fmt::Debug + std::fmt::Display + std::error::Error,\n{\n    use serde::de::Error;\n    let output = <&str>::deserialize(v)?;\n    output.to_uppercase().parse::<T>().map_err(D::Error::custom)\n}\n", "function_name": "crates__router__src__connector__utils.rs", "file": "crates__router__src__connector__utils.rs"}, {"query": "how to access billing information in payment requests", "code": "use std::{\n    collections::{HashMap, HashSet},\n    ops::Deref,\n    str::FromStr,\n    sync::LazyLock,\n};\n\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::{self, PayoutVendorAccountDetails};\nuse api_models::{\n    enums::{CanadaStatesAbbreviation, UsStatesAbbreviation},\n    payments,\n};\nuse base64::Engine;\nuse cards::NetworkToken;\nuse common_utils::{\n    date_time,\n    errors::{ParsingError, ReportSwitchExt},\n    ext_traits::StringExt,\n    id_type,\n    pii::{self, Email, IpAddress},\n    types::{AmountConvertor, MinorUnit},\n};\nuse diesel_models::{enums, types::OrderDetailsWithAmount};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt;\nuse masking::{Deserialize, ExposeInterface, Secret};\nuse regex::Regex;\n\n#[cfg(feature = \"frm\")]\nuse crate::types::fraud_check;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, ApiErrorResponse, CustomResult},\n        payments::{types::AuthenticationData, PaymentData},\n    },\n    pii::PeekInterface,\n    types::{\n        self, api, domain,\n        storage::enums as storage_enums,\n        transformers::{ForeignFrom, ForeignTryFrom},\n        BrowserInformation, PaymentsCancelData, ResponseId,\n    },\n    utils::{OptionExt, ValueExt},\n};\n\npub fn missing_field_err(\n    message: &'static str,\n) -> Box<dyn Fn() -> error_stack::Report<errors::ConnectorError> + 'static> {\n    Box::new(move || {\n        errors::ConnectorError::MissingRequiredField {\n            field_name: message,\n        }\n        .into()\n    })\n}\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub trait AccessTokenRequestInfo {\n    fn get_request_id(&self) -> Result<Secret<String>, Error>;\n}\n\nimpl AccessTokenRequestInfo for types::RefreshTokenRouterData {\n    fn get_request_id(&self) -> Result<Secret<String>, Error> {\n        self.request\n            .id\n            .clone()\n            .ok_or_else(missing_field_err(\"request.id\"))\n    }\n}\n\npub trait RouterData {\n    fn get_billing(&self) -> Result<&hype\n\n... [truncated 113213 chars] ...\n\n\")]\n    fn get_network_token_expiry_month(&self) -> Secret<String> {\n        self.network_token_exp_month.clone()\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn get_network_token_expiry_year(&self) -> Secret<String> {\n        self.token_exp_year.clone()\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn get_network_token_expiry_year(&self) -> Secret<String> {\n        self.network_token_exp_year.clone()\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn get_cryptogram(&self) -> Option<Secret<String>> {\n        self.token_cryptogram.clone()\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn get_cryptogram(&self) -> Option<Secret<String>> {\n        self.cryptogram.clone()\n    }\n}\n\npub fn convert_uppercase<'de, D, T>(v: D) -> Result<T, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n    T: FromStr,\n    <T as FromStr>::Err: std::fmt::Debug + std::fmt::Display + std::error::Error,\n{\n    use serde::de::Error;\n    let output = <&str>::deserialize(v)?;\n    output.to_uppercase().parse::<T>().map_err(D::Error::custom)\n}\n", "function_name": "crates__router__src__connector__utils.rs", "file": "crates__router__src__connector__utils.rs"}, {"query": "convert uppercase string serde deserializer", "code": "use std::{\n    collections::{HashMap, HashSet},\n    ops::Deref,\n    str::FromStr,\n    sync::LazyLock,\n};\n\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::{self, PayoutVendorAccountDetails};\nuse api_models::{\n    enums::{CanadaStatesAbbreviation, UsStatesAbbreviation},\n    payments,\n};\nuse base64::Engine;\nuse cards::NetworkToken;\nuse common_utils::{\n    date_time,\n    errors::{ParsingError, ReportSwitchExt},\n    ext_traits::StringExt,\n    id_type,\n    pii::{self, Email, IpAddress},\n    types::{AmountConvertor, MinorUnit},\n};\nuse diesel_models::{enums, types::OrderDetailsWithAmount};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt;\nuse masking::{Deserialize, ExposeInterface, Secret};\nuse regex::Regex;\n\n#[cfg(feature = \"frm\")]\nuse crate::types::fraud_check;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, ApiErrorResponse, CustomResult},\n        payments::{types::AuthenticationData, PaymentData},\n    },\n    pii::PeekInterface,\n    types::{\n        self, api, domain,\n        storage::enums as storage_enums,\n        transformers::{ForeignFrom, ForeignTryFrom},\n        BrowserInformation, PaymentsCancelData, ResponseId,\n    },\n    utils::{OptionExt, ValueExt},\n};\n\npub fn missing_field_err(\n    message: &'static str,\n) -> Box<dyn Fn() -> error_stack::Report<errors::ConnectorError> + 'static> {\n    Box::new(move || {\n        errors::ConnectorError::MissingRequiredField {\n            field_name: message,\n        }\n        .into()\n    })\n}\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub trait AccessTokenRequestInfo {\n    fn get_request_id(&self) -> Result<Secret<String>, Error>;\n}\n\nimpl AccessTokenRequestInfo for types::RefreshTokenRouterData {\n    fn get_request_id(&self) -> Result<Secret<String>, Error> {\n        self.request\n            .id\n            .clone()\n            .ok_or_else(missing_field_err(\"request.id\"))\n    }\n}\n\npub trait RouterData {\n    fn get_billing(&self) -> Result<&hype\n\n... [truncated 113213 chars] ...\n\n\")]\n    fn get_network_token_expiry_month(&self) -> Secret<String> {\n        self.network_token_exp_month.clone()\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn get_network_token_expiry_year(&self) -> Secret<String> {\n        self.token_exp_year.clone()\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn get_network_token_expiry_year(&self) -> Secret<String> {\n        self.network_token_exp_year.clone()\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn get_cryptogram(&self) -> Option<Secret<String>> {\n        self.token_cryptogram.clone()\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn get_cryptogram(&self) -> Option<Secret<String>> {\n        self.cryptogram.clone()\n    }\n}\n\npub fn convert_uppercase<'de, D, T>(v: D) -> Result<T, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n    T: FromStr,\n    <T as FromStr>::Err: std::fmt::Debug + std::fmt::Display + std::error::Error,\n{\n    use serde::de::Error;\n    let output = <&str>::deserialize(v)?;\n    output.to_uppercase().parse::<T>().map_err(D::Error::custom)\n}\n", "function_name": "crates__router__src__connector__utils.rs", "file": "crates__router__src__connector__utils.rs"}, {"query": "payment connector metadata utility functions", "code": "use std::{\n    collections::{HashMap, HashSet},\n    ops::Deref,\n    str::FromStr,\n    sync::LazyLock,\n};\n\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::{self, PayoutVendorAccountDetails};\nuse api_models::{\n    enums::{CanadaStatesAbbreviation, UsStatesAbbreviation},\n    payments,\n};\nuse base64::Engine;\nuse cards::NetworkToken;\nuse common_utils::{\n    date_time,\n    errors::{ParsingError, ReportSwitchExt},\n    ext_traits::StringExt,\n    id_type,\n    pii::{self, Email, IpAddress},\n    types::{AmountConvertor, MinorUnit},\n};\nuse diesel_models::{enums, types::OrderDetailsWithAmount};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt;\nuse masking::{Deserialize, ExposeInterface, Secret};\nuse regex::Regex;\n\n#[cfg(feature = \"frm\")]\nuse crate::types::fraud_check;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, ApiErrorResponse, CustomResult},\n        payments::{types::AuthenticationData, PaymentData},\n    },\n    pii::PeekInterface,\n    types::{\n        self, api, domain,\n        storage::enums as storage_enums,\n        transformers::{ForeignFrom, ForeignTryFrom},\n        BrowserInformation, PaymentsCancelData, ResponseId,\n    },\n    utils::{OptionExt, ValueExt},\n};\n\npub fn missing_field_err(\n    message: &'static str,\n) -> Box<dyn Fn() -> error_stack::Report<errors::ConnectorError> + 'static> {\n    Box::new(move || {\n        errors::ConnectorError::MissingRequiredField {\n            field_name: message,\n        }\n        .into()\n    })\n}\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub trait AccessTokenRequestInfo {\n    fn get_request_id(&self) -> Result<Secret<String>, Error>;\n}\n\nimpl AccessTokenRequestInfo for types::RefreshTokenRouterData {\n    fn get_request_id(&self) -> Result<Secret<String>, Error> {\n        self.request\n            .id\n            .clone()\n            .ok_or_else(missing_field_err(\"request.id\"))\n    }\n}\n\npub trait RouterData {\n    fn get_billing(&self) -> Result<&hype\n\n... [truncated 113213 chars] ...\n\n\")]\n    fn get_network_token_expiry_month(&self) -> Secret<String> {\n        self.network_token_exp_month.clone()\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn get_network_token_expiry_year(&self) -> Secret<String> {\n        self.token_exp_year.clone()\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn get_network_token_expiry_year(&self) -> Secret<String> {\n        self.network_token_exp_year.clone()\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn get_cryptogram(&self) -> Option<Secret<String>> {\n        self.token_cryptogram.clone()\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn get_cryptogram(&self) -> Option<Secret<String>> {\n        self.cryptogram.clone()\n    }\n}\n\npub fn convert_uppercase<'de, D, T>(v: D) -> Result<T, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n    T: FromStr,\n    <T as FromStr>::Err: std::fmt::Debug + std::fmt::Display + std::error::Error,\n{\n    use serde::de::Error;\n    let output = <&str>::deserialize(v)?;\n    output.to_uppercase().parse::<T>().map_err(D::Error::custom)\n}\n", "function_name": "crates__router__src__connector__utils.rs", "file": "crates__router__src__connector__utils.rs"}, {"query": "Calida payment connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse serde_json::Value;\nuse transformers as calida;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst CALIDA_API_VERSION: &str = \"v1\";\n#[derive(Clone)]\npub struct Calida {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Calida {\n    pub fn new() -> &'static Self {\n        &S\n\n... [truncated 23405 chars] ...\n\niption: \"Calida Financial is a licensed e-money institution based in Malta and they provide customized financial infrastructure and payment solutions across the EU and EEA. As part of The Payments Group, it focuses on embedded finance, prepaid services, and next-generation digital payment products.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic CALIDA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Calida {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CALIDA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CALIDA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CALIDA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__calida.rs", "file": "crates__hyperswitch_connectors__src__connectors__calida.rs"}, {"query": "how to integrate Calida with Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse serde_json::Value;\nuse transformers as calida;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst CALIDA_API_VERSION: &str = \"v1\";\n#[derive(Clone)]\npub struct Calida {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Calida {\n    pub fn new() -> &'static Self {\n        &S\n\n... [truncated 23405 chars] ...\n\niption: \"Calida Financial is a licensed e-money institution based in Malta and they provide customized financial infrastructure and payment solutions across the EU and EEA. As part of The Payments Group, it focuses on embedded finance, prepaid services, and next-generation digital payment products.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic CALIDA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Calida {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CALIDA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CALIDA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CALIDA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__calida.rs", "file": "crates__hyperswitch_connectors__src__connectors__calida.rs"}, {"query": "CalidaAuthorize function", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse serde_json::Value;\nuse transformers as calida;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst CALIDA_API_VERSION: &str = \"v1\";\n#[derive(Clone)]\npub struct Calida {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Calida {\n    pub fn new() -> &'static Self {\n        &S\n\n... [truncated 23405 chars] ...\n\niption: \"Calida Financial is a licensed e-money institution based in Malta and they provide customized financial infrastructure and payment solutions across the EU and EEA. As part of The Payments Group, it focuses on embedded finance, prepaid services, and next-generation digital payment products.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic CALIDA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Calida {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CALIDA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CALIDA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CALIDA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__calida.rs", "file": "crates__hyperswitch_connectors__src__connectors__calida.rs"}, {"query": "Calida refund execute", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse serde_json::Value;\nuse transformers as calida;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst CALIDA_API_VERSION: &str = \"v1\";\n#[derive(Clone)]\npub struct Calida {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Calida {\n    pub fn new() -> &'static Self {\n        &S\n\n... [truncated 23405 chars] ...\n\niption: \"Calida Financial is a licensed e-money institution based in Malta and they provide customized financial infrastructure and payment solutions across the EU and EEA. As part of The Payments Group, it focuses on embedded finance, prepaid services, and next-generation digital payment products.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic CALIDA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Calida {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CALIDA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CALIDA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CALIDA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__calida.rs", "file": "crates__hyperswitch_connectors__src__connectors__calida.rs"}, {"query": "Signifyd fraud connector implementation", "code": "pub mod transformers;\nuse std::fmt::Debug;\n\n#[cfg(feature = \"frm\")]\nuse api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"frm\")]\nuse base64::Engine;\n#[cfg(feature = \"frm\")]\nuse common_utils::{\n    consts,\n    request::{Method, RequestBuilder},\n};\n#[cfg(feature = \"frm\")]\nuse common_utils::{crypto, ext_traits::ByteSliceExt, request::RequestContent};\nuse common_utils::{errors::CustomResult, request::Request};\n#[cfg(feature = \"frm\")]\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::{Checkout, Fulfillment, RecordReturn, Sale, Transaction},\n    router_request_types::fraud_check::{\n        FraudCheckCheckoutData, FraudCheckFulfillmentData, FraudCheckRecordReturnData,\n        FraudCheckSaleData, FraudCheckTransactionData,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, MandateSetup, Payment, PaymentAuthorize,\n        PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid, Refund,\n        RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_interfaces::{\n    a\n\n... [truncated 22759 chars] ...\n\nbhookBody\")\n            .change_context(ConnectorError::WebhookResourceObjectNotFound)?;\n        Ok(Box::new(resource))\n    }\n}\n\nstatic SYGNIFYD_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Signifyd\",\n    description: \"Signifyd fraud and risk management provider with AI-driven commerce protection platform for maximizing conversions and eliminating fraud risk with guaranteed fraud liability coverage\",\n    connector_type: common_enums::HyperswitchConnectorCategory::FraudAndRiskManagementProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Signifyd {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SYGNIFYD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__signifyd.rs", "file": "crates__hyperswitch_connectors__src__connectors__signifyd.rs"}, {"query": "hyperswitch Signifyd webhook handler", "code": "pub mod transformers;\nuse std::fmt::Debug;\n\n#[cfg(feature = \"frm\")]\nuse api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"frm\")]\nuse base64::Engine;\n#[cfg(feature = \"frm\")]\nuse common_utils::{\n    consts,\n    request::{Method, RequestBuilder},\n};\n#[cfg(feature = \"frm\")]\nuse common_utils::{crypto, ext_traits::ByteSliceExt, request::RequestContent};\nuse common_utils::{errors::CustomResult, request::Request};\n#[cfg(feature = \"frm\")]\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::{Checkout, Fulfillment, RecordReturn, Sale, Transaction},\n    router_request_types::fraud_check::{\n        FraudCheckCheckoutData, FraudCheckFulfillmentData, FraudCheckRecordReturnData,\n        FraudCheckSaleData, FraudCheckTransactionData,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, MandateSetup, Payment, PaymentAuthorize,\n        PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid, Refund,\n        RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_interfaces::{\n    a\n\n... [truncated 22759 chars] ...\n\nbhookBody\")\n            .change_context(ConnectorError::WebhookResourceObjectNotFound)?;\n        Ok(Box::new(resource))\n    }\n}\n\nstatic SYGNIFYD_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Signifyd\",\n    description: \"Signifyd fraud and risk management provider with AI-driven commerce protection platform for maximizing conversions and eliminating fraud risk with guaranteed fraud liability coverage\",\n    connector_type: common_enums::HyperswitchConnectorCategory::FraudAndRiskManagementProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Signifyd {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SYGNIFYD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__signifyd.rs", "file": "crates__hyperswitch_connectors__src__connectors__signifyd.rs"}, {"query": "how to integrate Signifyd with Hyperswitch", "code": "pub mod transformers;\nuse std::fmt::Debug;\n\n#[cfg(feature = \"frm\")]\nuse api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"frm\")]\nuse base64::Engine;\n#[cfg(feature = \"frm\")]\nuse common_utils::{\n    consts,\n    request::{Method, RequestBuilder},\n};\n#[cfg(feature = \"frm\")]\nuse common_utils::{crypto, ext_traits::ByteSliceExt, request::RequestContent};\nuse common_utils::{errors::CustomResult, request::Request};\n#[cfg(feature = \"frm\")]\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::{Checkout, Fulfillment, RecordReturn, Sale, Transaction},\n    router_request_types::fraud_check::{\n        FraudCheckCheckoutData, FraudCheckFulfillmentData, FraudCheckRecordReturnData,\n        FraudCheckSaleData, FraudCheckTransactionData,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, MandateSetup, Payment, PaymentAuthorize,\n        PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid, Refund,\n        RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_interfaces::{\n    a\n\n... [truncated 22759 chars] ...\n\nbhookBody\")\n            .change_context(ConnectorError::WebhookResourceObjectNotFound)?;\n        Ok(Box::new(resource))\n    }\n}\n\nstatic SYGNIFYD_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Signifyd\",\n    description: \"Signifyd fraud and risk management provider with AI-driven commerce protection platform for maximizing conversions and eliminating fraud risk with guaranteed fraud liability coverage\",\n    connector_type: common_enums::HyperswitchConnectorCategory::FraudAndRiskManagementProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Signifyd {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SYGNIFYD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__signifyd.rs", "file": "crates__hyperswitch_connectors__src__connectors__signifyd.rs"}, {"query": "Signifyd fraud check API integration", "code": "pub mod transformers;\nuse std::fmt::Debug;\n\n#[cfg(feature = \"frm\")]\nuse api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"frm\")]\nuse base64::Engine;\n#[cfg(feature = \"frm\")]\nuse common_utils::{\n    consts,\n    request::{Method, RequestBuilder},\n};\n#[cfg(feature = \"frm\")]\nuse common_utils::{crypto, ext_traits::ByteSliceExt, request::RequestContent};\nuse common_utils::{errors::CustomResult, request::Request};\n#[cfg(feature = \"frm\")]\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::{Checkout, Fulfillment, RecordReturn, Sale, Transaction},\n    router_request_types::fraud_check::{\n        FraudCheckCheckoutData, FraudCheckFulfillmentData, FraudCheckRecordReturnData,\n        FraudCheckSaleData, FraudCheckTransactionData,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, MandateSetup, Payment, PaymentAuthorize,\n        PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid, Refund,\n        RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_interfaces::{\n    a\n\n... [truncated 22759 chars] ...\n\nbhookBody\")\n            .change_context(ConnectorError::WebhookResourceObjectNotFound)?;\n        Ok(Box::new(resource))\n    }\n}\n\nstatic SYGNIFYD_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Signifyd\",\n    description: \"Signifyd fraud and risk management provider with AI-driven commerce protection platform for maximizing conversions and eliminating fraud risk with guaranteed fraud liability coverage\",\n    connector_type: common_enums::HyperswitchConnectorCategory::FraudAndRiskManagementProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Signifyd {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SYGNIFYD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__signifyd.rs", "file": "crates__hyperswitch_connectors__src__connectors__signifyd.rs"}, {"query": "business profile data model rust", "code": "use std::borrow::Cow;\n\nuse common_enums::enums as api_enums;\nuse common_types::{domain::AcquirerConfig, primitive_wrappers};\nuse common_utils::{\n    crypto::{OptionalEncryptableName, OptionalEncryptableValue},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    pii, type_name,\n    types::keymanager,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::business_profile::RevenueRecoveryAlgorithmData;\nuse diesel_models::business_profile::{\n    self as storage_types, AuthenticationConnectorDetails, BusinessPaymentLinkConfig,\n    BusinessPayoutLinkConfig, CardTestingGuardConfig, ExternalVaultConnectorDetails,\n    ProfileUpdateInternal, WebhookDetails,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::logger;\n\nuse crate::{\n    behaviour::Conversion,\n    errors::api_error_response,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, AsyncLift, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    \n\n... [truncated 127329 chars] ...\n\nutils::id_type::ProfileId,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn find_business_profile_by_profile_name_merchant_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        profile_name: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn update_profile_by_profile_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        current_state: Profile,\n        profile_update: ProfileUpdate,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn delete_profile_by_profile_id_merchant_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<bool, Self::Error>;\n\n    async fn list_profile_by_merchant_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<Vec<Profile>, Self::Error>;\n}\n", "function_name": "crates__hyperswitch_domain_models__src__business_profile.rs", "file": "crates__hyperswitch_domain_models__src__business_profile.rs"}, {"query": "how to insert business profile hyperswitch", "code": "use std::borrow::Cow;\n\nuse common_enums::enums as api_enums;\nuse common_types::{domain::AcquirerConfig, primitive_wrappers};\nuse common_utils::{\n    crypto::{OptionalEncryptableName, OptionalEncryptableValue},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    pii, type_name,\n    types::keymanager,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::business_profile::RevenueRecoveryAlgorithmData;\nuse diesel_models::business_profile::{\n    self as storage_types, AuthenticationConnectorDetails, BusinessPaymentLinkConfig,\n    BusinessPayoutLinkConfig, CardTestingGuardConfig, ExternalVaultConnectorDetails,\n    ProfileUpdateInternal, WebhookDetails,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::logger;\n\nuse crate::{\n    behaviour::Conversion,\n    errors::api_error_response,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, AsyncLift, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    \n\n... [truncated 127329 chars] ...\n\nutils::id_type::ProfileId,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn find_business_profile_by_profile_name_merchant_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        profile_name: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn update_profile_by_profile_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        current_state: Profile,\n        profile_update: ProfileUpdate,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn delete_profile_by_profile_id_merchant_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<bool, Self::Error>;\n\n    async fn list_profile_by_merchant_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<Vec<Profile>, Self::Error>;\n}\n", "function_name": "crates__hyperswitch_domain_models__src__business_profile.rs", "file": "crates__hyperswitch_domain_models__src__business_profile.rs"}, {"query": "BusinessProfileRepository trait definition", "code": "use std::borrow::Cow;\n\nuse common_enums::enums as api_enums;\nuse common_types::{domain::AcquirerConfig, primitive_wrappers};\nuse common_utils::{\n    crypto::{OptionalEncryptableName, OptionalEncryptableValue},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    pii, type_name,\n    types::keymanager,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::business_profile::RevenueRecoveryAlgorithmData;\nuse diesel_models::business_profile::{\n    self as storage_types, AuthenticationConnectorDetails, BusinessPaymentLinkConfig,\n    BusinessPayoutLinkConfig, CardTestingGuardConfig, ExternalVaultConnectorDetails,\n    ProfileUpdateInternal, WebhookDetails,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::logger;\n\nuse crate::{\n    behaviour::Conversion,\n    errors::api_error_response,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, AsyncLift, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    \n\n... [truncated 127329 chars] ...\n\nutils::id_type::ProfileId,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn find_business_profile_by_profile_name_merchant_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        profile_name: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn update_profile_by_profile_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        current_state: Profile,\n        profile_update: ProfileUpdate,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn delete_profile_by_profile_id_merchant_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<bool, Self::Error>;\n\n    async fn list_profile_by_merchant_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<Vec<Profile>, Self::Error>;\n}\n", "function_name": "crates__hyperswitch_domain_models__src__business_profile.rs", "file": "crates__hyperswitch_domain_models__src__business_profile.rs"}, {"query": "payment profile routing algorithm configuration", "code": "use std::borrow::Cow;\n\nuse common_enums::enums as api_enums;\nuse common_types::{domain::AcquirerConfig, primitive_wrappers};\nuse common_utils::{\n    crypto::{OptionalEncryptableName, OptionalEncryptableValue},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    pii, type_name,\n    types::keymanager,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::business_profile::RevenueRecoveryAlgorithmData;\nuse diesel_models::business_profile::{\n    self as storage_types, AuthenticationConnectorDetails, BusinessPaymentLinkConfig,\n    BusinessPayoutLinkConfig, CardTestingGuardConfig, ExternalVaultConnectorDetails,\n    ProfileUpdateInternal, WebhookDetails,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::logger;\n\nuse crate::{\n    behaviour::Conversion,\n    errors::api_error_response,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, AsyncLift, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    \n\n... [truncated 127329 chars] ...\n\nutils::id_type::ProfileId,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn find_business_profile_by_profile_name_merchant_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        profile_name: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn update_profile_by_profile_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        current_state: Profile,\n        profile_update: ProfileUpdate,\n    ) -> CustomResult<Profile, Self::Error>;\n\n    async fn delete_profile_by_profile_id_merchant_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<bool, Self::Error>;\n\n    async fn list_profile_by_merchant_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> CustomResult<Vec<Profile>, Self::Error>;\n}\n", "function_name": "crates__hyperswitch_domain_models__src__business_profile.rs", "file": "crates__hyperswitch_domain_models__src__business_profile.rs"}, {"query": "ProphetPay connector implementation", "code": "use std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    consts::{PROPHETPAY_REDIRECT_URL, PROPHETPAY_TOKEN},\n    errors::CustomResult,\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{CardRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{api, consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, to_connector_meta},\n};\n\npub struct ProphetpayRouterData<T> {\n    pub amount: f64,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ProphetpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_f64(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub struct ProphetpayAuthType {\n    pub(super) user_name: Secret<String>,\n    pub(super) password: Secret<String>,\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ProphetpayAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } =\n\n... [truncated 22648 chars] ...\n\n.item.data\n            })\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProphetpayRefundSyncRequest {\n    transaction_id: String,\n    inquiry_reference: String,\n    ref_info: String,\n    profile: Secret<String>,\n    action_type: i8,\n}\n\nimpl TryFrom<&types::RefundSyncRouterData> for ProphetpayRefundSyncRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::RefundSyncRouterData) -> Result<Self, Self::Error> {\n        let auth_data = ProphetpayAuthType::try_from(&item.connector_auth_type)?;\n        Ok(Self {\n            transaction_id: item.request.connector_transaction_id.clone(),\n            ref_info: item.connector_request_reference_id.to_owned(),\n            inquiry_reference: item.connector_request_reference_id.clone(),\n            profile: auth_data.profile_id,\n            action_type: ProphetpayActionType::get_action_type(&ProphetpayActionType::Inquiry),\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs"}, {"query": "ProphetpayRouterData struct", "code": "use std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    consts::{PROPHETPAY_REDIRECT_URL, PROPHETPAY_TOKEN},\n    errors::CustomResult,\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{CardRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{api, consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, to_connector_meta},\n};\n\npub struct ProphetpayRouterData<T> {\n    pub amount: f64,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ProphetpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_f64(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub struct ProphetpayAuthType {\n    pub(super) user_name: Secret<String>,\n    pub(super) password: Secret<String>,\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ProphetpayAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } =\n\n... [truncated 22648 chars] ...\n\n.item.data\n            })\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProphetpayRefundSyncRequest {\n    transaction_id: String,\n    inquiry_reference: String,\n    ref_info: String,\n    profile: Secret<String>,\n    action_type: i8,\n}\n\nimpl TryFrom<&types::RefundSyncRouterData> for ProphetpayRefundSyncRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::RefundSyncRouterData) -> Result<Self, Self::Error> {\n        let auth_data = ProphetpayAuthType::try_from(&item.connector_auth_type)?;\n        Ok(Self {\n            transaction_id: item.request.connector_transaction_id.clone(),\n            ref_info: item.connector_request_reference_id.to_owned(),\n            inquiry_reference: item.connector_request_reference_id.clone(),\n            profile: auth_data.profile_id,\n            action_type: ProphetpayActionType::get_action_type(&ProphetpayActionType::Inquiry),\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs"}, {"query": "how to implement ProphetPay payment integration", "code": "use std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    consts::{PROPHETPAY_REDIRECT_URL, PROPHETPAY_TOKEN},\n    errors::CustomResult,\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{CardRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{api, consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, to_connector_meta},\n};\n\npub struct ProphetpayRouterData<T> {\n    pub amount: f64,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ProphetpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_f64(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub struct ProphetpayAuthType {\n    pub(super) user_name: Secret<String>,\n    pub(super) password: Secret<String>,\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ProphetpayAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } =\n\n... [truncated 22648 chars] ...\n\n.item.data\n            })\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProphetpayRefundSyncRequest {\n    transaction_id: String,\n    inquiry_reference: String,\n    ref_info: String,\n    profile: Secret<String>,\n    action_type: i8,\n}\n\nimpl TryFrom<&types::RefundSyncRouterData> for ProphetpayRefundSyncRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::RefundSyncRouterData) -> Result<Self, Self::Error> {\n        let auth_data = ProphetpayAuthType::try_from(&item.connector_auth_type)?;\n        Ok(Self {\n            transaction_id: item.request.connector_transaction_id.clone(),\n            ref_info: item.connector_request_reference_id.to_owned(),\n            inquiry_reference: item.connector_request_reference_id.clone(),\n            profile: auth_data.profile_id,\n            action_type: ProphetpayActionType::get_action_type(&ProphetpayActionType::Inquiry),\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs"}, {"query": "ProphetPay API request transformation", "code": "use std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    consts::{PROPHETPAY_REDIRECT_URL, PROPHETPAY_TOKEN},\n    errors::CustomResult,\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{CardRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{api, consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, to_connector_meta},\n};\n\npub struct ProphetpayRouterData<T> {\n    pub amount: f64,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ProphetpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_f64(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub struct ProphetpayAuthType {\n    pub(super) user_name: Secret<String>,\n    pub(super) password: Secret<String>,\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ProphetpayAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } =\n\n... [truncated 22648 chars] ...\n\n.item.data\n            })\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProphetpayRefundSyncRequest {\n    transaction_id: String,\n    inquiry_reference: String,\n    ref_info: String,\n    profile: Secret<String>,\n    action_type: i8,\n}\n\nimpl TryFrom<&types::RefundSyncRouterData> for ProphetpayRefundSyncRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::RefundSyncRouterData) -> Result<Self, Self::Error> {\n        let auth_data = ProphetpayAuthType::try_from(&item.connector_auth_type)?;\n        Ok(Self {\n            transaction_id: item.request.connector_transaction_id.clone(),\n            ref_info: item.connector_request_reference_id.to_owned(),\n            inquiry_reference: item.connector_request_reference_id.clone(),\n            profile: auth_data.profile_id,\n            action_type: ProphetpayActionType::get_action_type(&ProphetpayActionType::Inquiry),\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs"}, {"query": "Paystack payment gateway integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as paystack;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Paystack {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Paystack {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paystack {}\nimpl api::PaymentSe\n\n... [truncated 21884 chars] ...\n\nent_methods\n    });\n\nstatic PAYSTACK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Paystack\",\n    description: \"Paystack is a Nigerian financial technology company that provides online and offline payment solutions to businesses across Africa.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYSTACK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Paystack {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYSTACK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYSTACK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYSTACK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paystack.rs", "file": "crates__hyperswitch_connectors__src__connectors__paystack.rs"}, {"query": "Paystack connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as paystack;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Paystack {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Paystack {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paystack {}\nimpl api::PaymentSe\n\n... [truncated 21884 chars] ...\n\nent_methods\n    });\n\nstatic PAYSTACK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Paystack\",\n    description: \"Paystack is a Nigerian financial technology company that provides online and offline payment solutions to businesses across Africa.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYSTACK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Paystack {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYSTACK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYSTACK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYSTACK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paystack.rs", "file": "crates__hyperswitch_connectors__src__connectors__paystack.rs"}, {"query": "how to add new payment gateway", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as paystack;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Paystack {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Paystack {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paystack {}\nimpl api::PaymentSe\n\n... [truncated 21884 chars] ...\n\nent_methods\n    });\n\nstatic PAYSTACK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Paystack\",\n    description: \"Paystack is a Nigerian financial technology company that provides online and offline payment solutions to businesses across Africa.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYSTACK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Paystack {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYSTACK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYSTACK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYSTACK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paystack.rs", "file": "crates__hyperswitch_connectors__src__connectors__paystack.rs"}, {"query": "Paystack API authentication", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as paystack;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Paystack {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Paystack {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paystack {}\nimpl api::PaymentSe\n\n... [truncated 21884 chars] ...\n\nent_methods\n    });\n\nstatic PAYSTACK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Paystack\",\n    description: \"Paystack is a Nigerian financial technology company that provides online and offline payment solutions to businesses across Africa.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYSTACK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Paystack {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYSTACK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYSTACK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYSTACK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paystack.rs", "file": "crates__hyperswitch_connectors__src__connectors__paystack.rs"}, {"query": "Trustpay connector implementation", "code": "use std::collections::HashMap;\n\nuse api_models::payments::SessionToken;\nuse cards::NetworkToken;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::OptionExt,\n    pii::{self, Email},\n    request::Method,\n    types::{FloatMajorUnit, StringMajorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, BankTransferData, Card, PaymentMethodData},\n    router_data::{\n        AccessToken, AdditionalPaymentMethodConnectorResponse, ConnectorAuthType,\n        ConnectorResponseData, ErrorResponse, RouterData,\n    },\n    router_request_types::{BrowserInformation, PaymentsPreProcessingData, ResponseId},\n    router_response_types::{\n        PaymentsResponseData, PreprocessingResponseId, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        RefreshTokenRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::Url;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData, NetworkTokenData,\n        PaymentsAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct TrustpayRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for TrustpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n      \n\n... [truncated 80017 chars] ...\n\n\n                .as_ref()\n                .and_then(|agent| agent.bic.clone()),\n            self.debtor.as_ref().and_then(|debtor| debtor.name.clone()),\n            self.debtor.as_ref().and_then(|debtor| debtor.email.clone()),\n        );\n\n        if debitor_iban.is_some()\n            || debitor_bic.is_some()\n            || debitor_name.is_some()\n            || debitor_email.is_some()\n        {\n            Some(ConnectorResponseData::with_additional_payment_method_data(\n                AdditionalPaymentMethodConnectorResponse::SepaBankTransfer {\n                    debitor_iban,\n                    debitor_bic,\n                    debitor_name,\n                    debitor_email,\n                },\n            ))\n        } else {\n            None\n        }\n    }\n}\n\nimpl From<Errors> for utils::ErrorCodeAndMessage {\n    fn from(error: Errors) -> Self {\n        Self {\n            error_code: error.code.to_string(),\n            error_message: error.description,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpay__transformers.rs"}, {"query": "TrustpayAuthType struct", "code": "use std::collections::HashMap;\n\nuse api_models::payments::SessionToken;\nuse cards::NetworkToken;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::OptionExt,\n    pii::{self, Email},\n    request::Method,\n    types::{FloatMajorUnit, StringMajorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, BankTransferData, Card, PaymentMethodData},\n    router_data::{\n        AccessToken, AdditionalPaymentMethodConnectorResponse, ConnectorAuthType,\n        ConnectorResponseData, ErrorResponse, RouterData,\n    },\n    router_request_types::{BrowserInformation, PaymentsPreProcessingData, ResponseId},\n    router_response_types::{\n        PaymentsResponseData, PreprocessingResponseId, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        RefreshTokenRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::Url;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData, NetworkTokenData,\n        PaymentsAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct TrustpayRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for TrustpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n      \n\n... [truncated 80017 chars] ...\n\n\n                .as_ref()\n                .and_then(|agent| agent.bic.clone()),\n            self.debtor.as_ref().and_then(|debtor| debtor.name.clone()),\n            self.debtor.as_ref().and_then(|debtor| debtor.email.clone()),\n        );\n\n        if debitor_iban.is_some()\n            || debitor_bic.is_some()\n            || debitor_name.is_some()\n            || debitor_email.is_some()\n        {\n            Some(ConnectorResponseData::with_additional_payment_method_data(\n                AdditionalPaymentMethodConnectorResponse::SepaBankTransfer {\n                    debitor_iban,\n                    debitor_bic,\n                    debitor_name,\n                    debitor_email,\n                },\n            ))\n        } else {\n            None\n        }\n    }\n}\n\nimpl From<Errors> for utils::ErrorCodeAndMessage {\n    fn from(error: Errors) -> Self {\n        Self {\n            error_code: error.code.to_string(),\n            error_message: error.description,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpay__transformers.rs"}, {"query": "how to configure Trustpay payment methods", "code": "use std::collections::HashMap;\n\nuse api_models::payments::SessionToken;\nuse cards::NetworkToken;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::OptionExt,\n    pii::{self, Email},\n    request::Method,\n    types::{FloatMajorUnit, StringMajorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, BankTransferData, Card, PaymentMethodData},\n    router_data::{\n        AccessToken, AdditionalPaymentMethodConnectorResponse, ConnectorAuthType,\n        ConnectorResponseData, ErrorResponse, RouterData,\n    },\n    router_request_types::{BrowserInformation, PaymentsPreProcessingData, ResponseId},\n    router_response_types::{\n        PaymentsResponseData, PreprocessingResponseId, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        RefreshTokenRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::Url;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData, NetworkTokenData,\n        PaymentsAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct TrustpayRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for TrustpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n      \n\n... [truncated 80017 chars] ...\n\n\n                .as_ref()\n                .and_then(|agent| agent.bic.clone()),\n            self.debtor.as_ref().and_then(|debtor| debtor.name.clone()),\n            self.debtor.as_ref().and_then(|debtor| debtor.email.clone()),\n        );\n\n        if debitor_iban.is_some()\n            || debitor_bic.is_some()\n            || debitor_name.is_some()\n            || debitor_email.is_some()\n        {\n            Some(ConnectorResponseData::with_additional_payment_method_data(\n                AdditionalPaymentMethodConnectorResponse::SepaBankTransfer {\n                    debitor_iban,\n                    debitor_bic,\n                    debitor_name,\n                    debitor_email,\n                },\n            ))\n        } else {\n            None\n        }\n    }\n}\n\nimpl From<Errors> for utils::ErrorCodeAndMessage {\n    fn from(error: Errors) -> Self {\n        Self {\n            error_code: error.code.to_string(),\n            error_message: error.description,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpay__transformers.rs"}, {"query": "Trustpay bank transfer data transformation", "code": "use std::collections::HashMap;\n\nuse api_models::payments::SessionToken;\nuse cards::NetworkToken;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::OptionExt,\n    pii::{self, Email},\n    request::Method,\n    types::{FloatMajorUnit, StringMajorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, BankTransferData, Card, PaymentMethodData},\n    router_data::{\n        AccessToken, AdditionalPaymentMethodConnectorResponse, ConnectorAuthType,\n        ConnectorResponseData, ErrorResponse, RouterData,\n    },\n    router_request_types::{BrowserInformation, PaymentsPreProcessingData, ResponseId},\n    router_response_types::{\n        PaymentsResponseData, PreprocessingResponseId, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        RefreshTokenRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::Url;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData, NetworkTokenData,\n        PaymentsAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct TrustpayRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for TrustpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n      \n\n... [truncated 80017 chars] ...\n\n\n                .as_ref()\n                .and_then(|agent| agent.bic.clone()),\n            self.debtor.as_ref().and_then(|debtor| debtor.name.clone()),\n            self.debtor.as_ref().and_then(|debtor| debtor.email.clone()),\n        );\n\n        if debitor_iban.is_some()\n            || debitor_bic.is_some()\n            || debitor_name.is_some()\n            || debitor_email.is_some()\n        {\n            Some(ConnectorResponseData::with_additional_payment_method_data(\n                AdditionalPaymentMethodConnectorResponse::SepaBankTransfer {\n                    debitor_iban,\n                    debitor_bic,\n                    debitor_name,\n                    debitor_email,\n                },\n            ))\n        } else {\n            None\n        }\n    }\n}\n\nimpl From<Errors> for utils::ErrorCodeAndMessage {\n    fn from(error: Errors) -> Self {\n        Self {\n            error_code: error.code.to_string(),\n            error_message: error.description,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__trustpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__trustpay__transformers.rs"}, {"query": "how to implement GPayments authentication in Hyperswitch", "code": "pub mod gpayments_types;\npub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse gpayments_types::GpaymentsConnectorMetaData;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nu\n\n... [truncated 18950 chars] ...\n\n  event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\nstatic GPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"GPayments\",\n    description: \"GPayments authentication connector for 3D Secure MPI/ACS services supporting Visa Secure, Mastercard SecureCode, and global card authentication standards\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Gpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__gpayments.rs"}, {"query": "Gpayments connector implementation", "code": "pub mod gpayments_types;\npub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse gpayments_types::GpaymentsConnectorMetaData;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nu\n\n... [truncated 18950 chars] ...\n\n  event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\nstatic GPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"GPayments\",\n    description: \"GPayments authentication connector for 3D Secure MPI/ACS services supporting Visa Secure, Mastercard SecureCode, and global card authentication standards\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Gpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__gpayments.rs"}, {"query": "how to add GPayments 3D Secure support", "code": "pub mod gpayments_types;\npub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse gpayments_types::GpaymentsConnectorMetaData;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nu\n\n... [truncated 18950 chars] ...\n\n  event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\nstatic GPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"GPayments\",\n    description: \"GPayments authentication connector for 3D Secure MPI/ACS services supporting Visa Secure, Mastercard SecureCode, and global card authentication standards\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Gpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__gpayments.rs"}, {"query": "hyperswitch authentication provider connector", "code": "pub mod gpayments_types;\npub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse gpayments_types::GpaymentsConnectorMetaData;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nu\n\n... [truncated 18950 chars] ...\n\n  event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\nstatic GPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"GPayments\",\n    description: \"GPayments authentication connector for 3D Secure MPI/ACS services supporting Visa Secure, Mastercard SecureCode, and global card authentication standards\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Gpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__gpayments.rs"}, {"query": "how to handle JSON payload errors in actix-web", "code": "pub mod chat;\n#[cfg(feature = \"olap\")]\npub mod connector_onboarding;\npub mod currency;\npub mod db_utils;\npub mod ext_traits;\n#[cfg(feature = \"olap\")]\npub mod oidc;\n#[cfg(feature = \"kv_store\")]\npub mod storage_partitioning;\n#[cfg(feature = \"olap\")]\npub mod user;\n#[cfg(feature = \"olap\")]\npub mod user_role;\n#[cfg(feature = \"olap\")]\npub mod verify_connector;\nuse std::fmt::Debug;\n\nuse api_models::{\n    enums,\n    payments::{self},\n    subscription as subscription_types, webhooks,\n};\npub use common_utils::{\n    crypto::{self, Encryptable},\n    ext_traits::{ByteSliceExt, BytesExt, Encode, StringExt, ValueExt},\n    fp_utils::when,\n    id_type, pii,\n    validation::validate_email,\n};\n#[cfg(feature = \"v1\")]\nuse common_utils::{\n    type_name,\n    types::keymanager::{Identifier, ToEncryptable},\n};\nuse error_stack::ResultExt;\npub use hyperswitch_connectors::utils::QrImage;\nuse hyperswitch_domain_models::payments::PaymentIntent;\n#[cfg(feature = \"v1\")]\nuse hyperswitch_domain_models::type_encryption::{crypto_operation, CryptoOperation};\nuse masking::{ExposeInterface, SwitchStrategy};\nuse nanoid::nanoid;\nuse serde::de::DeserializeOwned;\nuse serde_json::Value;\n#[cfg(feature = \"v1\")]\nuse subscriptions::{subscription_handler::SubscriptionHandler, workflows::InvoiceSyncHandler};\nuse tracing_futures::Instrument;\n\npub use self::ext_traits::{OptionExt, ValidateCall};\nuse crate::{\n    consts,\n    core::{\n        authentication::types::ExternalThreeDSConnectorMetadata,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        payments as payments_core,\n    },\n    headers::ACCEPT_LANGUAGE,\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, authentication::get_header_value_by_key},\n    types::{self, domain, transformers::ForeignInto},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{core::webhooks as webhooks_core, types::storage};\n\npub mod error_parser {\n    use std::fmt::Display;\n\n    use actix_web::{\n        error::{Error, JsonPayloadError},\n        http::StatusCode,\n      \n\n... [truncated 54221 chars] ...\n\nook\")?;\n\n    let platform = domain::Platform::new(\n        merchant_account.clone(),\n        key_store.clone(),\n        merchant_account.clone(),\n        key_store.clone(),\n        None,\n    );\n\n    let cloned_state = state.clone();\n    let cloned_profile = profile.clone();\n    let invoice_id = invoice.id.get_string_repr().to_owned();\n    let created_at = subscription.created_at;\n    let processor = platform.get_processor().clone();\n\n    tokio::spawn(async move {\n        Box::pin(webhooks_core::create_event_and_trigger_outgoing_webhook(\n            cloned_state,\n            processor,\n            cloned_profile,\n            common_enums::enums::EventType::InvoicePaid,\n            common_enums::enums::EventClass::Subscriptions,\n            invoice_id,\n            common_enums::EventObjectType::SubscriptionDetails,\n            webhooks::OutgoingWebhookContent::SubscriptionDetails(Box::new(response)),\n            Some(created_at),\n        ))\n        .await\n    });\n\n    Ok(())\n}\n", "function_name": "crates__router__src__utils.rs", "file": "crates__router__src__utils.rs"}, {"query": "hyperswitch router error handling utilities", "code": "pub mod chat;\n#[cfg(feature = \"olap\")]\npub mod connector_onboarding;\npub mod currency;\npub mod db_utils;\npub mod ext_traits;\n#[cfg(feature = \"olap\")]\npub mod oidc;\n#[cfg(feature = \"kv_store\")]\npub mod storage_partitioning;\n#[cfg(feature = \"olap\")]\npub mod user;\n#[cfg(feature = \"olap\")]\npub mod user_role;\n#[cfg(feature = \"olap\")]\npub mod verify_connector;\nuse std::fmt::Debug;\n\nuse api_models::{\n    enums,\n    payments::{self},\n    subscription as subscription_types, webhooks,\n};\npub use common_utils::{\n    crypto::{self, Encryptable},\n    ext_traits::{ByteSliceExt, BytesExt, Encode, StringExt, ValueExt},\n    fp_utils::when,\n    id_type, pii,\n    validation::validate_email,\n};\n#[cfg(feature = \"v1\")]\nuse common_utils::{\n    type_name,\n    types::keymanager::{Identifier, ToEncryptable},\n};\nuse error_stack::ResultExt;\npub use hyperswitch_connectors::utils::QrImage;\nuse hyperswitch_domain_models::payments::PaymentIntent;\n#[cfg(feature = \"v1\")]\nuse hyperswitch_domain_models::type_encryption::{crypto_operation, CryptoOperation};\nuse masking::{ExposeInterface, SwitchStrategy};\nuse nanoid::nanoid;\nuse serde::de::DeserializeOwned;\nuse serde_json::Value;\n#[cfg(feature = \"v1\")]\nuse subscriptions::{subscription_handler::SubscriptionHandler, workflows::InvoiceSyncHandler};\nuse tracing_futures::Instrument;\n\npub use self::ext_traits::{OptionExt, ValidateCall};\nuse crate::{\n    consts,\n    core::{\n        authentication::types::ExternalThreeDSConnectorMetadata,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        payments as payments_core,\n    },\n    headers::ACCEPT_LANGUAGE,\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, authentication::get_header_value_by_key},\n    types::{self, domain, transformers::ForeignInto},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{core::webhooks as webhooks_core, types::storage};\n\npub mod error_parser {\n    use std::fmt::Display;\n\n    use actix_web::{\n        error::{Error, JsonPayloadError},\n        http::StatusCode,\n      \n\n... [truncated 54221 chars] ...\n\nook\")?;\n\n    let platform = domain::Platform::new(\n        merchant_account.clone(),\n        key_store.clone(),\n        merchant_account.clone(),\n        key_store.clone(),\n        None,\n    );\n\n    let cloned_state = state.clone();\n    let cloned_profile = profile.clone();\n    let invoice_id = invoice.id.get_string_repr().to_owned();\n    let created_at = subscription.created_at;\n    let processor = platform.get_processor().clone();\n\n    tokio::spawn(async move {\n        Box::pin(webhooks_core::create_event_and_trigger_outgoing_webhook(\n            cloned_state,\n            processor,\n            cloned_profile,\n            common_enums::enums::EventType::InvoicePaid,\n            common_enums::enums::EventClass::Subscriptions,\n            invoice_id,\n            common_enums::EventObjectType::SubscriptionDetails,\n            webhooks::OutgoingWebhookContent::SubscriptionDetails(Box::new(response)),\n            Some(created_at),\n        ))\n        .await\n    });\n\n    Ok(())\n}\n", "function_name": "crates__router__src__utils.rs", "file": "crates__router__src__utils.rs"}, {"query": "how to implement outgoing webhook triggers", "code": "pub mod chat;\n#[cfg(feature = \"olap\")]\npub mod connector_onboarding;\npub mod currency;\npub mod db_utils;\npub mod ext_traits;\n#[cfg(feature = \"olap\")]\npub mod oidc;\n#[cfg(feature = \"kv_store\")]\npub mod storage_partitioning;\n#[cfg(feature = \"olap\")]\npub mod user;\n#[cfg(feature = \"olap\")]\npub mod user_role;\n#[cfg(feature = \"olap\")]\npub mod verify_connector;\nuse std::fmt::Debug;\n\nuse api_models::{\n    enums,\n    payments::{self},\n    subscription as subscription_types, webhooks,\n};\npub use common_utils::{\n    crypto::{self, Encryptable},\n    ext_traits::{ByteSliceExt, BytesExt, Encode, StringExt, ValueExt},\n    fp_utils::when,\n    id_type, pii,\n    validation::validate_email,\n};\n#[cfg(feature = \"v1\")]\nuse common_utils::{\n    type_name,\n    types::keymanager::{Identifier, ToEncryptable},\n};\nuse error_stack::ResultExt;\npub use hyperswitch_connectors::utils::QrImage;\nuse hyperswitch_domain_models::payments::PaymentIntent;\n#[cfg(feature = \"v1\")]\nuse hyperswitch_domain_models::type_encryption::{crypto_operation, CryptoOperation};\nuse masking::{ExposeInterface, SwitchStrategy};\nuse nanoid::nanoid;\nuse serde::de::DeserializeOwned;\nuse serde_json::Value;\n#[cfg(feature = \"v1\")]\nuse subscriptions::{subscription_handler::SubscriptionHandler, workflows::InvoiceSyncHandler};\nuse tracing_futures::Instrument;\n\npub use self::ext_traits::{OptionExt, ValidateCall};\nuse crate::{\n    consts,\n    core::{\n        authentication::types::ExternalThreeDSConnectorMetadata,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        payments as payments_core,\n    },\n    headers::ACCEPT_LANGUAGE,\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, authentication::get_header_value_by_key},\n    types::{self, domain, transformers::ForeignInto},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{core::webhooks as webhooks_core, types::storage};\n\npub mod error_parser {\n    use std::fmt::Display;\n\n    use actix_web::{\n        error::{Error, JsonPayloadError},\n        http::StatusCode,\n      \n\n... [truncated 54221 chars] ...\n\nook\")?;\n\n    let platform = domain::Platform::new(\n        merchant_account.clone(),\n        key_store.clone(),\n        merchant_account.clone(),\n        key_store.clone(),\n        None,\n    );\n\n    let cloned_state = state.clone();\n    let cloned_profile = profile.clone();\n    let invoice_id = invoice.id.get_string_repr().to_owned();\n    let created_at = subscription.created_at;\n    let processor = platform.get_processor().clone();\n\n    tokio::spawn(async move {\n        Box::pin(webhooks_core::create_event_and_trigger_outgoing_webhook(\n            cloned_state,\n            processor,\n            cloned_profile,\n            common_enums::enums::EventType::InvoicePaid,\n            common_enums::enums::EventClass::Subscriptions,\n            invoice_id,\n            common_enums::EventObjectType::SubscriptionDetails,\n            webhooks::OutgoingWebhookContent::SubscriptionDetails(Box::new(response)),\n            Some(created_at),\n        ))\n        .await\n    });\n\n    Ok(())\n}\n", "function_name": "crates__router__src__utils.rs", "file": "crates__router__src__utils.rs"}, {"query": "invoice payment status webhook handler", "code": "pub mod chat;\n#[cfg(feature = \"olap\")]\npub mod connector_onboarding;\npub mod currency;\npub mod db_utils;\npub mod ext_traits;\n#[cfg(feature = \"olap\")]\npub mod oidc;\n#[cfg(feature = \"kv_store\")]\npub mod storage_partitioning;\n#[cfg(feature = \"olap\")]\npub mod user;\n#[cfg(feature = \"olap\")]\npub mod user_role;\n#[cfg(feature = \"olap\")]\npub mod verify_connector;\nuse std::fmt::Debug;\n\nuse api_models::{\n    enums,\n    payments::{self},\n    subscription as subscription_types, webhooks,\n};\npub use common_utils::{\n    crypto::{self, Encryptable},\n    ext_traits::{ByteSliceExt, BytesExt, Encode, StringExt, ValueExt},\n    fp_utils::when,\n    id_type, pii,\n    validation::validate_email,\n};\n#[cfg(feature = \"v1\")]\nuse common_utils::{\n    type_name,\n    types::keymanager::{Identifier, ToEncryptable},\n};\nuse error_stack::ResultExt;\npub use hyperswitch_connectors::utils::QrImage;\nuse hyperswitch_domain_models::payments::PaymentIntent;\n#[cfg(feature = \"v1\")]\nuse hyperswitch_domain_models::type_encryption::{crypto_operation, CryptoOperation};\nuse masking::{ExposeInterface, SwitchStrategy};\nuse nanoid::nanoid;\nuse serde::de::DeserializeOwned;\nuse serde_json::Value;\n#[cfg(feature = \"v1\")]\nuse subscriptions::{subscription_handler::SubscriptionHandler, workflows::InvoiceSyncHandler};\nuse tracing_futures::Instrument;\n\npub use self::ext_traits::{OptionExt, ValidateCall};\nuse crate::{\n    consts,\n    core::{\n        authentication::types::ExternalThreeDSConnectorMetadata,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        payments as payments_core,\n    },\n    headers::ACCEPT_LANGUAGE,\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, authentication::get_header_value_by_key},\n    types::{self, domain, transformers::ForeignInto},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{core::webhooks as webhooks_core, types::storage};\n\npub mod error_parser {\n    use std::fmt::Display;\n\n    use actix_web::{\n        error::{Error, JsonPayloadError},\n        http::StatusCode,\n      \n\n... [truncated 54221 chars] ...\n\nook\")?;\n\n    let platform = domain::Platform::new(\n        merchant_account.clone(),\n        key_store.clone(),\n        merchant_account.clone(),\n        key_store.clone(),\n        None,\n    );\n\n    let cloned_state = state.clone();\n    let cloned_profile = profile.clone();\n    let invoice_id = invoice.id.get_string_repr().to_owned();\n    let created_at = subscription.created_at;\n    let processor = platform.get_processor().clone();\n\n    tokio::spawn(async move {\n        Box::pin(webhooks_core::create_event_and_trigger_outgoing_webhook(\n            cloned_state,\n            processor,\n            cloned_profile,\n            common_enums::enums::EventType::InvoicePaid,\n            common_enums::enums::EventClass::Subscriptions,\n            invoice_id,\n            common_enums::EventObjectType::SubscriptionDetails,\n            webhooks::OutgoingWebhookContent::SubscriptionDetails(Box::new(response)),\n            Some(created_at),\n        ))\n        .await\n    });\n\n    Ok(())\n}\n", "function_name": "crates__router__src__utils.rs", "file": "crates__router__src__utils.rs"}, {"query": "bambora payment gateway integration rust", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        self, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsSyncType, PaymentsVoidType, Response,\n    },\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as bambora;\n\nuse crate::{\n    connectors::bambora::transformers::BamboraRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n\n\n... [truncated 27932 chars] ...\n\n),\n                ),\n            },\n        );\n\n        bambora_supported_payment_methods\n    };\n    static ref BAMBORA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bambora\",\n        description: \"Bambora is a leading online payment provider in Canada and United States.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n    static ref BAMBORA_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n}\n\nimpl ConnectorSpecifications for Bambora {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*BAMBORA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BAMBORA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*BAMBORA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bambora.rs", "file": "crates__hyperswitch_connectors__src__connectors__bambora.rs"}, {"query": "hyperswitch connector bambora implementation", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        self, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsSyncType, PaymentsVoidType, Response,\n    },\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as bambora;\n\nuse crate::{\n    connectors::bambora::transformers::BamboraRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n\n\n... [truncated 27932 chars] ...\n\n),\n                ),\n            },\n        );\n\n        bambora_supported_payment_methods\n    };\n    static ref BAMBORA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bambora\",\n        description: \"Bambora is a leading online payment provider in Canada and United States.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n    static ref BAMBORA_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n}\n\nimpl ConnectorSpecifications for Bambora {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*BAMBORA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BAMBORA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*BAMBORA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bambora.rs", "file": "crates__hyperswitch_connectors__src__connectors__bambora.rs"}, {"query": "how to add new payment gateway connector", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        self, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsSyncType, PaymentsVoidType, Response,\n    },\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as bambora;\n\nuse crate::{\n    connectors::bambora::transformers::BamboraRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n\n\n... [truncated 27932 chars] ...\n\n),\n                ),\n            },\n        );\n\n        bambora_supported_payment_methods\n    };\n    static ref BAMBORA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bambora\",\n        description: \"Bambora is a leading online payment provider in Canada and United States.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n    static ref BAMBORA_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n}\n\nimpl ConnectorSpecifications for Bambora {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*BAMBORA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BAMBORA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*BAMBORA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bambora.rs", "file": "crates__hyperswitch_connectors__src__connectors__bambora.rs"}, {"query": "bambora authorize capture refund flow", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        self, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsSyncType, PaymentsVoidType, Response,\n    },\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as bambora;\n\nuse crate::{\n    connectors::bambora::transformers::BamboraRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n\n\n... [truncated 27932 chars] ...\n\n),\n                ),\n            },\n        );\n\n        bambora_supported_payment_methods\n    };\n    static ref BAMBORA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bambora\",\n        description: \"Bambora is a leading online payment provider in Canada and United States.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n    static ref BAMBORA_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n}\n\nimpl ConnectorSpecifications for Bambora {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*BAMBORA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BAMBORA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*BAMBORA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bambora.rs", "file": "crates__hyperswitch_connectors__src__connectors__bambora.rs"}, {"query": "how to implement crypto payment connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers::{self as coingate, CoingateWebhookBody};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Coingate {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coingate {\n    pub fn n\n\n... [truncated 20688 chars] ...\n\nhods\n    });\n\nstatic COINGATE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Coingate\",\n    description: \"CoinGate's online payment solution makes it easy for businesses to accept Bitcoin, Ethereum, stablecoins and other cryptocurrencies for payments on any website.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic COINGATE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Coingate {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&COINGATE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*COINGATE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&COINGATE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__coingate.rs", "file": "crates__hyperswitch_connectors__src__connectors__coingate.rs"}, {"query": "Coingate payment integration Rust", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers::{self as coingate, CoingateWebhookBody};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Coingate {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coingate {\n    pub fn n\n\n... [truncated 20688 chars] ...\n\nhods\n    });\n\nstatic COINGATE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Coingate\",\n    description: \"CoinGate's online payment solution makes it easy for businesses to accept Bitcoin, Ethereum, stablecoins and other cryptocurrencies for payments on any website.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic COINGATE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Coingate {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&COINGATE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*COINGATE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&COINGATE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__coingate.rs", "file": "crates__hyperswitch_connectors__src__connectors__coingate.rs"}, {"query": "hyperswitch connector specifications", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers::{self as coingate, CoingateWebhookBody};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Coingate {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coingate {\n    pub fn n\n\n... [truncated 20688 chars] ...\n\nhods\n    });\n\nstatic COINGATE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Coingate\",\n    description: \"CoinGate's online payment solution makes it easy for businesses to accept Bitcoin, Ethereum, stablecoins and other cryptocurrencies for payments on any website.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic COINGATE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Coingate {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&COINGATE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*COINGATE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&COINGATE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__coingate.rs", "file": "crates__hyperswitch_connectors__src__connectors__coingate.rs"}, {"query": "coingate webhook handling", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers::{self as coingate, CoingateWebhookBody};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Coingate {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coingate {\n    pub fn n\n\n... [truncated 20688 chars] ...\n\nhods\n    });\n\nstatic COINGATE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Coingate\",\n    description: \"CoinGate's online payment solution makes it easy for businesses to accept Bitcoin, Ethereum, stablecoins and other cryptocurrencies for payments on any website.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic COINGATE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Coingate {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&COINGATE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*COINGATE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&COINGATE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__coingate.rs", "file": "crates__hyperswitch_connectors__src__connectors__coingate.rs"}, {"query": "how to handle payment void operations", "code": "use std::{collections::HashMap, marker::PhantomData};\n\nuse api_models::customers::CustomerDocumentDetails;\nuse cards::NetworkToken;\nuse common_types::{payments as common_payment_types, primitive_wrappers};\nuse common_utils::{\n    errors::IntegrityCheckError,\n    ext_traits::{OptionExt, ValueExt},\n    id_type::{self},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    address::AddressDetails, payment_address::PaymentAddress, payment_method_data, payments,\n    router_response_types,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    payments::{\n        payment_attempt::{ErrorDetails, PaymentAttemptUpdate},\n        payment_intent::PaymentIntentUpdate,\n    },\n    router_flow_types, router_request_types,\n};\n\n#[derive(Debug, Clone, Serialize)]\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_m\n\n... [truncated 101556 chars] ...\n\n, no amount is capturable\n        Some(MinorUnit::zero())\n    }\n\n    fn get_captured_amount(\n        &self,\n        _payment_data: &payments::PaymentCancelData<router_flow_types::Void>,\n    ) -> Option<MinorUnit> {\n        // For void operations, no amount is captured\n        Some(MinorUnit::zero())\n    }\n\n    fn get_attempt_status_for_db_update(\n        &self,\n        _payment_data: &payments::PaymentCancelData<router_flow_types::Void>,\n    ) -> common_enums::AttemptStatus {\n        // For void operations, determine status based on response\n        match &self.response {\n            Err(ref error_response) => match error_response.attempt_status {\n                Some(status) => status,\n                None => match error_response.status_code {\n                    500..=511 => common_enums::AttemptStatus::Pending,\n                    _ => common_enums::AttemptStatus::VoidFailed,\n                },\n            },\n            Ok(ref _response) => self.status,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_data.rs", "file": "crates__hyperswitch_domain_models__src__router_data.rs"}, {"query": "RouterData struct definition", "code": "use std::{collections::HashMap, marker::PhantomData};\n\nuse api_models::customers::CustomerDocumentDetails;\nuse cards::NetworkToken;\nuse common_types::{payments as common_payment_types, primitive_wrappers};\nuse common_utils::{\n    errors::IntegrityCheckError,\n    ext_traits::{OptionExt, ValueExt},\n    id_type::{self},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    address::AddressDetails, payment_address::PaymentAddress, payment_method_data, payments,\n    router_response_types,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    payments::{\n        payment_attempt::{ErrorDetails, PaymentAttemptUpdate},\n        payment_intent::PaymentIntentUpdate,\n    },\n    router_flow_types, router_request_types,\n};\n\n#[derive(Debug, Clone, Serialize)]\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_m\n\n... [truncated 101556 chars] ...\n\n, no amount is capturable\n        Some(MinorUnit::zero())\n    }\n\n    fn get_captured_amount(\n        &self,\n        _payment_data: &payments::PaymentCancelData<router_flow_types::Void>,\n    ) -> Option<MinorUnit> {\n        // For void operations, no amount is captured\n        Some(MinorUnit::zero())\n    }\n\n    fn get_attempt_status_for_db_update(\n        &self,\n        _payment_data: &payments::PaymentCancelData<router_flow_types::Void>,\n    ) -> common_enums::AttemptStatus {\n        // For void operations, determine status based on response\n        match &self.response {\n            Err(ref error_response) => match error_response.attempt_status {\n                Some(status) => status,\n                None => match error_response.status_code {\n                    500..=511 => common_enums::AttemptStatus::Pending,\n                    _ => common_enums::AttemptStatus::VoidFailed,\n                },\n            },\n            Ok(ref _response) => self.status,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_data.rs", "file": "crates__hyperswitch_domain_models__src__router_data.rs"}, {"query": "implement payment cancellation logic", "code": "use std::{collections::HashMap, marker::PhantomData};\n\nuse api_models::customers::CustomerDocumentDetails;\nuse cards::NetworkToken;\nuse common_types::{payments as common_payment_types, primitive_wrappers};\nuse common_utils::{\n    errors::IntegrityCheckError,\n    ext_traits::{OptionExt, ValueExt},\n    id_type::{self},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    address::AddressDetails, payment_address::PaymentAddress, payment_method_data, payments,\n    router_response_types,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    payments::{\n        payment_attempt::{ErrorDetails, PaymentAttemptUpdate},\n        payment_intent::PaymentIntentUpdate,\n    },\n    router_flow_types, router_request_types,\n};\n\n#[derive(Debug, Clone, Serialize)]\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_m\n\n... [truncated 101556 chars] ...\n\n, no amount is capturable\n        Some(MinorUnit::zero())\n    }\n\n    fn get_captured_amount(\n        &self,\n        _payment_data: &payments::PaymentCancelData<router_flow_types::Void>,\n    ) -> Option<MinorUnit> {\n        // For void operations, no amount is captured\n        Some(MinorUnit::zero())\n    }\n\n    fn get_attempt_status_for_db_update(\n        &self,\n        _payment_data: &payments::PaymentCancelData<router_flow_types::Void>,\n    ) -> common_enums::AttemptStatus {\n        // For void operations, determine status based on response\n        match &self.response {\n            Err(ref error_response) => match error_response.attempt_status {\n                Some(status) => status,\n                None => match error_response.status_code {\n                    500..=511 => common_enums::AttemptStatus::Pending,\n                    _ => common_enums::AttemptStatus::VoidFailed,\n                },\n            },\n            Ok(ref _response) => self.status,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_data.rs", "file": "crates__hyperswitch_domain_models__src__router_data.rs"}, {"query": "payment orchestration data structure", "code": "use std::{collections::HashMap, marker::PhantomData};\n\nuse api_models::customers::CustomerDocumentDetails;\nuse cards::NetworkToken;\nuse common_types::{payments as common_payment_types, primitive_wrappers};\nuse common_utils::{\n    errors::IntegrityCheckError,\n    ext_traits::{OptionExt, ValueExt},\n    id_type::{self},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    address::AddressDetails, payment_address::PaymentAddress, payment_method_data, payments,\n    router_response_types,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    payments::{\n        payment_attempt::{ErrorDetails, PaymentAttemptUpdate},\n        payment_intent::PaymentIntentUpdate,\n    },\n    router_flow_types, router_request_types,\n};\n\n#[derive(Debug, Clone, Serialize)]\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_m\n\n... [truncated 101556 chars] ...\n\n, no amount is capturable\n        Some(MinorUnit::zero())\n    }\n\n    fn get_captured_amount(\n        &self,\n        _payment_data: &payments::PaymentCancelData<router_flow_types::Void>,\n    ) -> Option<MinorUnit> {\n        // For void operations, no amount is captured\n        Some(MinorUnit::zero())\n    }\n\n    fn get_attempt_status_for_db_update(\n        &self,\n        _payment_data: &payments::PaymentCancelData<router_flow_types::Void>,\n    ) -> common_enums::AttemptStatus {\n        // For void operations, determine status based on response\n        match &self.response {\n            Err(ref error_response) => match error_response.attempt_status {\n                Some(status) => status,\n                None => match error_response.status_code {\n                    500..=511 => common_enums::AttemptStatus::Pending,\n                    _ => common_enums::AttemptStatus::VoidFailed,\n                },\n            },\n            Ok(ref _response) => self.status,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_data.rs", "file": "crates__hyperswitch_domain_models__src__router_data.rs"}, {"query": "Wells Fargo payment connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, IncrementalAuthorization, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, MandateRevokeRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, RefundExecuteRouterData, RefundSyncRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        refunds::{Refund, RefundExecute, RefundSync},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        Increm\n\n... [truncated 51042 chars] ...\n\nspecific_features: None,\n            },\n        );\n\n        wellsfargo_supported_payment_methods\n    });\n\nstatic WELLSFARGO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wells Fargo\",\n    description:\n        \"Wells Fargo is a major bank offering retail, commercial, and wealth management services\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic WELLSFARGO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Wellsfargo {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WELLSFARGO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WELLSFARGO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WELLSFARGO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs"}, {"query": "hyperswitch wellsfargo authorize", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, IncrementalAuthorization, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, MandateRevokeRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, RefundExecuteRouterData, RefundSyncRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        refunds::{Refund, RefundExecute, RefundSync},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        Increm\n\n... [truncated 51042 chars] ...\n\nspecific_features: None,\n            },\n        );\n\n        wellsfargo_supported_payment_methods\n    });\n\nstatic WELLSFARGO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wells Fargo\",\n    description:\n        \"Wells Fargo is a major bank offering retail, commercial, and wealth management services\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic WELLSFARGO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Wellsfargo {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WELLSFARGO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WELLSFARGO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WELLSFARGO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs"}, {"query": "how to integrate Wells Fargo API", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, IncrementalAuthorization, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, MandateRevokeRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, RefundExecuteRouterData, RefundSyncRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        refunds::{Refund, RefundExecute, RefundSync},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        Increm\n\n... [truncated 51042 chars] ...\n\nspecific_features: None,\n            },\n        );\n\n        wellsfargo_supported_payment_methods\n    });\n\nstatic WELLSFARGO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wells Fargo\",\n    description:\n        \"Wells Fargo is a major bank offering retail, commercial, and wealth management services\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic WELLSFARGO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Wellsfargo {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WELLSFARGO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WELLSFARGO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WELLSFARGO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs"}, {"query": "bank debit connector wellsfargo", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, IncrementalAuthorization, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, MandateRevokeRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, RefundExecuteRouterData, RefundSyncRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        refunds::{Refund, RefundExecute, RefundSync},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        Increm\n\n... [truncated 51042 chars] ...\n\nspecific_features: None,\n            },\n        );\n\n        wellsfargo_supported_payment_methods\n    });\n\nstatic WELLSFARGO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wells Fargo\",\n    description:\n        \"Wells Fargo is a major bank offering retail, commercial, and wealth management services\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic WELLSFARGO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Wellsfargo {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WELLSFARGO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WELLSFARGO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WELLSFARGO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs"}, {"query": "Worldpay payment response parsing", "code": "use error_stack::ResultExt;\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::requests::*;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    pub transaction_reference: Option<String>,\n    #[serde(flatten)]\n    pub other_fields: Option<WorldpayPaymentResponseFields>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayPaymentResponseFields {\n    RefusedResponse(RefusedResponse),\n    DDCResponse(DDCResponse),\n    ThreeDsChallenged(ThreeDsChallengedResponse),\n    FraudHighRisk(FraudHighRiskResponse),\n    AuthorizedResponse(Box<AuthorizedResponse>),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthorizedResponse {\n    pub payment_instrument: PaymentsResPaymentInstrument,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<SelfLink>,\n    #[serde(rename = \"_actions\")]\n    pub actions: Option<ActionLinks>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    pub fraud: Option<Fraud>,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MandateToken {\n    pub href: Secret<String>,\n    pub token_id: String,\n    pub token_expiry_date_time: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct FraudHighRiskResponse {\n    pub score: f32,\n    pub reason: V\n\n... [truncated 10471 chars] ...\n\n error_name: code.to_string(),\n                message: \"Unknown error\".to_string(),\n                validation_errors: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayWebhookTransactionId {\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EventDetails {\n    #[serde(rename = \"type\")]\n    pub event_type: EventType,\n    pub transaction_reference: String,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayWebhookEventType {\n    pub event_id: String,\n    pub event_timestamp: String,\n    pub event_details: EventDetails,\n}\n\n/// Worldpay's unique reference ID for a request\npub(super) const WP_CORRELATION_ID: &str = \"WP-CorrelationId\";\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs"}, {"query": "WorldpayAuthorizedResponse struct", "code": "use error_stack::ResultExt;\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::requests::*;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    pub transaction_reference: Option<String>,\n    #[serde(flatten)]\n    pub other_fields: Option<WorldpayPaymentResponseFields>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayPaymentResponseFields {\n    RefusedResponse(RefusedResponse),\n    DDCResponse(DDCResponse),\n    ThreeDsChallenged(ThreeDsChallengedResponse),\n    FraudHighRisk(FraudHighRiskResponse),\n    AuthorizedResponse(Box<AuthorizedResponse>),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthorizedResponse {\n    pub payment_instrument: PaymentsResPaymentInstrument,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<SelfLink>,\n    #[serde(rename = \"_actions\")]\n    pub actions: Option<ActionLinks>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    pub fraud: Option<Fraud>,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MandateToken {\n    pub href: Secret<String>,\n    pub token_id: String,\n    pub token_expiry_date_time: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct FraudHighRiskResponse {\n    pub score: f32,\n    pub reason: V\n\n... [truncated 10471 chars] ...\n\n error_name: code.to_string(),\n                message: \"Unknown error\".to_string(),\n                validation_errors: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayWebhookTransactionId {\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EventDetails {\n    #[serde(rename = \"type\")]\n    pub event_type: EventType,\n    pub transaction_reference: String,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayWebhookEventType {\n    pub event_id: String,\n    pub event_timestamp: String,\n    pub event_details: EventDetails,\n}\n\n/// Worldpay's unique reference ID for a request\npub(super) const WP_CORRELATION_ID: &str = \"WP-CorrelationId\";\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs"}, {"query": "how to handle Worldpay 3DS challenge", "code": "use error_stack::ResultExt;\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::requests::*;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    pub transaction_reference: Option<String>,\n    #[serde(flatten)]\n    pub other_fields: Option<WorldpayPaymentResponseFields>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayPaymentResponseFields {\n    RefusedResponse(RefusedResponse),\n    DDCResponse(DDCResponse),\n    ThreeDsChallenged(ThreeDsChallengedResponse),\n    FraudHighRisk(FraudHighRiskResponse),\n    AuthorizedResponse(Box<AuthorizedResponse>),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthorizedResponse {\n    pub payment_instrument: PaymentsResPaymentInstrument,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<SelfLink>,\n    #[serde(rename = \"_actions\")]\n    pub actions: Option<ActionLinks>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    pub fraud: Option<Fraud>,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MandateToken {\n    pub href: Secret<String>,\n    pub token_id: String,\n    pub token_expiry_date_time: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct FraudHighRiskResponse {\n    pub score: f32,\n    pub reason: V\n\n... [truncated 10471 chars] ...\n\n error_name: code.to_string(),\n                message: \"Unknown error\".to_string(),\n                validation_errors: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayWebhookTransactionId {\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EventDetails {\n    #[serde(rename = \"type\")]\n    pub event_type: EventType,\n    pub transaction_reference: String,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayWebhookEventType {\n    pub event_id: String,\n    pub event_timestamp: String,\n    pub event_details: EventDetails,\n}\n\n/// Worldpay's unique reference ID for a request\npub(super) const WP_CORRELATION_ID: &str = \"WP-CorrelationId\";\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs"}, {"query": "Worldpay fraud high risk response", "code": "use error_stack::ResultExt;\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::requests::*;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    pub transaction_reference: Option<String>,\n    #[serde(flatten)]\n    pub other_fields: Option<WorldpayPaymentResponseFields>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayPaymentResponseFields {\n    RefusedResponse(RefusedResponse),\n    DDCResponse(DDCResponse),\n    ThreeDsChallenged(ThreeDsChallengedResponse),\n    FraudHighRisk(FraudHighRiskResponse),\n    AuthorizedResponse(Box<AuthorizedResponse>),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthorizedResponse {\n    pub payment_instrument: PaymentsResPaymentInstrument,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<SelfLink>,\n    #[serde(rename = \"_actions\")]\n    pub actions: Option<ActionLinks>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    pub fraud: Option<Fraud>,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MandateToken {\n    pub href: Secret<String>,\n    pub token_id: String,\n    pub token_expiry_date_time: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct FraudHighRiskResponse {\n    pub score: f32,\n    pub reason: V\n\n... [truncated 10471 chars] ...\n\n error_name: code.to_string(),\n                message: \"Unknown error\".to_string(),\n                validation_errors: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayWebhookTransactionId {\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EventDetails {\n    #[serde(rename = \"type\")]\n    pub event_type: EventType,\n    pub transaction_reference: String,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayWebhookEventType {\n    pub event_id: String,\n    pub event_timestamp: String,\n    pub event_details: EventDetails,\n}\n\n/// Worldpay's unique reference ID for a request\npub(super) const WP_CORRELATION_ID: &str = \"WP-CorrelationId\";\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs"}, {"query": "Affirm payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as affirm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Affirm {\n    amount_converter: &'static (dyn AmountConvertor<Output = M\n\n... [truncated 25795 chars] ...\n\nm_supported_payment_methods\n});\n\nstatic AFFIRM_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Affirm\",\n    description: \"Affirm connector is a payment gateway integration that processes Affirms buy now, pay later financing by managing payment authorization, capture, refunds, and transaction sync via Affirms API.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic AFFIRM_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Affirm {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AFFIRM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AFFIRM_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AFFIRM_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__affirm.rs", "file": "crates__hyperswitch_connectors__src__connectors__affirm.rs"}, {"query": "Affirm authorize and capture", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as affirm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Affirm {\n    amount_converter: &'static (dyn AmountConvertor<Output = M\n\n... [truncated 25795 chars] ...\n\nm_supported_payment_methods\n});\n\nstatic AFFIRM_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Affirm\",\n    description: \"Affirm connector is a payment gateway integration that processes Affirms buy now, pay later financing by managing payment authorization, capture, refunds, and transaction sync via Affirms API.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic AFFIRM_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Affirm {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AFFIRM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AFFIRM_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AFFIRM_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__affirm.rs", "file": "crates__hyperswitch_connectors__src__connectors__affirm.rs"}, {"query": "how to add Affirm connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as affirm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Affirm {\n    amount_converter: &'static (dyn AmountConvertor<Output = M\n\n... [truncated 25795 chars] ...\n\nm_supported_payment_methods\n});\n\nstatic AFFIRM_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Affirm\",\n    description: \"Affirm connector is a payment gateway integration that processes Affirms buy now, pay later financing by managing payment authorization, capture, refunds, and transaction sync via Affirms API.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic AFFIRM_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Affirm {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AFFIRM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AFFIRM_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AFFIRM_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__affirm.rs", "file": "crates__hyperswitch_connectors__src__connectors__affirm.rs"}, {"query": "Affirm payment method type", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as affirm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Affirm {\n    amount_converter: &'static (dyn AmountConvertor<Output = M\n\n... [truncated 25795 chars] ...\n\nm_supported_payment_methods\n});\n\nstatic AFFIRM_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Affirm\",\n    description: \"Affirm connector is a payment gateway integration that processes Affirms buy now, pay later financing by managing payment authorization, capture, refunds, and transaction sync via Affirms API.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic AFFIRM_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Affirm {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AFFIRM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AFFIRM_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AFFIRM_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__affirm.rs", "file": "crates__hyperswitch_connectors__src__connectors__affirm.rs"}, {"query": "Mifinity payment gateway integration hyperswitch", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask};\nuse router_env::logger;\nuse transformers::{self as mifinity, auth_headers};\n\nuse crate::{\n    constants::{headers, CONNECTOR_UNAUTHORIZED_ERROR},\n    types::ResponseRouterData,\n    utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Mifinity {\n  \n\n... [truncated 16730 chars] ...\n\nnectorInfo {\n        display_name: \"MIFINITY\",\n        description:\n            \"Mifinity is a payment gateway empowering you to pay online, receive funds, and send money globally, the MiFinity eWallet supports super-low fees, offering infinite possibilities to do more of the things you love.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\n    static ref MIFINITY_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Mifinity {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*MIFINITY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MIFINITY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*MIFINITY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mifinity.rs", "file": "crates__hyperswitch_connectors__src__connectors__mifinity.rs"}, {"query": "Mifinity connector implementation Rust", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask};\nuse router_env::logger;\nuse transformers::{self as mifinity, auth_headers};\n\nuse crate::{\n    constants::{headers, CONNECTOR_UNAUTHORIZED_ERROR},\n    types::ResponseRouterData,\n    utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Mifinity {\n  \n\n... [truncated 16730 chars] ...\n\nnectorInfo {\n        display_name: \"MIFINITY\",\n        description:\n            \"Mifinity is a payment gateway empowering you to pay online, receive funds, and send money globally, the MiFinity eWallet supports super-low fees, offering infinite possibilities to do more of the things you love.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\n    static ref MIFINITY_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Mifinity {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*MIFINITY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MIFINITY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*MIFINITY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mifinity.rs", "file": "crates__hyperswitch_connectors__src__connectors__mifinity.rs"}, {"query": "how to add Mifinity payment method", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask};\nuse router_env::logger;\nuse transformers::{self as mifinity, auth_headers};\n\nuse crate::{\n    constants::{headers, CONNECTOR_UNAUTHORIZED_ERROR},\n    types::ResponseRouterData,\n    utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Mifinity {\n  \n\n... [truncated 16730 chars] ...\n\nnectorInfo {\n        display_name: \"MIFINITY\",\n        description:\n            \"Mifinity is a payment gateway empowering you to pay online, receive funds, and send money globally, the MiFinity eWallet supports super-low fees, offering infinite possibilities to do more of the things you love.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\n    static ref MIFINITY_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Mifinity {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*MIFINITY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MIFINITY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*MIFINITY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mifinity.rs", "file": "crates__hyperswitch_connectors__src__connectors__mifinity.rs"}, {"query": "Mifinity webhook handling hyperswitch", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{ExposeInterface, Mask};\nuse router_env::logger;\nuse transformers::{self as mifinity, auth_headers};\n\nuse crate::{\n    constants::{headers, CONNECTOR_UNAUTHORIZED_ERROR},\n    types::ResponseRouterData,\n    utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Mifinity {\n  \n\n... [truncated 16730 chars] ...\n\nnectorInfo {\n        display_name: \"MIFINITY\",\n        description:\n            \"Mifinity is a payment gateway empowering you to pay online, receive funds, and send money globally, the MiFinity eWallet supports super-low fees, offering infinite possibilities to do more of the things you love.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\n    static ref MIFINITY_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Mifinity {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*MIFINITY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MIFINITY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*MIFINITY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mifinity.rs", "file": "crates__hyperswitch_connectors__src__connectors__mifinity.rs"}, {"query": "Riskified API request transformation", "code": "use api_models::{payments::AdditionalPaymentData, webhooks::IncomingWebhookEvent};\nuse common_enums::{Currency, FraudCheckStatus};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::Email,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{self, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::Fulfillment,\n    router_request_types::{\n        fraud_check::{FraudCheckFulfillmentData, FulfillmentStatus},\n        BrowserInformation, ResponseId,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        FrmCheckoutRouterData, FrmFulfillmentRouterData, FrmTransactionRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        convert_amount, AddressDetailsData as _, FraudCheckCheckoutRequest,\n        FraudCheckTransactionRequest, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<ConnectorError>;\n\npub struct RiskifiedRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl<T> From<(StringMajorUnit, T)> for RiskifiedRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\npub struct RiskifiedPaymentsCheckoutRequest {\n    order: CheckoutRequest,\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\npub struct CheckoutRequest {\n    id: String,\n    note: Option<String>,\n    email: Option<Email>,\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    currency: Option<Currency>,\n    #[serde\n\n... [truncated 19159 chars] ...\n\nlone()\n                .and_then(|phone_data| phone_data.number),\n        })\n    }\n}\n\nfn get_fulfillment_status(status: FulfillmentStatus) -> Option<FulfillmentRequestStatus> {\n    match status {\n        FulfillmentStatus::COMPLETE => Some(FulfillmentRequestStatus::Success),\n        FulfillmentStatus::CANCELED => Some(FulfillmentRequestStatus::Cancelled),\n        FulfillmentStatus::PARTIAL | FulfillmentStatus::REPLACEMENT => None,\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct RiskifiedWebhookBody {\n    pub id: String,\n    pub status: RiskifiedWebhookStatus,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub enum RiskifiedWebhookStatus {\n    Approved,\n    Declined,\n}\n\nimpl From<RiskifiedWebhookStatus> for IncomingWebhookEvent {\n    fn from(value: RiskifiedWebhookStatus) -> Self {\n        match value {\n            RiskifiedWebhookStatus::Declined => Self::FrmRejected,\n            RiskifiedWebhookStatus::Approved => Self::FrmApproved,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__riskified__transformers__api.rs", "file": "crates__hyperswitch_connectors__src__connectors__riskified__transformers__api.rs"}, {"query": "map fulfillment status to Riskified", "code": "use api_models::{payments::AdditionalPaymentData, webhooks::IncomingWebhookEvent};\nuse common_enums::{Currency, FraudCheckStatus};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::Email,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{self, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::Fulfillment,\n    router_request_types::{\n        fraud_check::{FraudCheckFulfillmentData, FulfillmentStatus},\n        BrowserInformation, ResponseId,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        FrmCheckoutRouterData, FrmFulfillmentRouterData, FrmTransactionRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        convert_amount, AddressDetailsData as _, FraudCheckCheckoutRequest,\n        FraudCheckTransactionRequest, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<ConnectorError>;\n\npub struct RiskifiedRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl<T> From<(StringMajorUnit, T)> for RiskifiedRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\npub struct RiskifiedPaymentsCheckoutRequest {\n    order: CheckoutRequest,\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\npub struct CheckoutRequest {\n    id: String,\n    note: Option<String>,\n    email: Option<Email>,\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    currency: Option<Currency>,\n    #[serde\n\n... [truncated 19159 chars] ...\n\nlone()\n                .and_then(|phone_data| phone_data.number),\n        })\n    }\n}\n\nfn get_fulfillment_status(status: FulfillmentStatus) -> Option<FulfillmentRequestStatus> {\n    match status {\n        FulfillmentStatus::COMPLETE => Some(FulfillmentRequestStatus::Success),\n        FulfillmentStatus::CANCELED => Some(FulfillmentRequestStatus::Cancelled),\n        FulfillmentStatus::PARTIAL | FulfillmentStatus::REPLACEMENT => None,\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct RiskifiedWebhookBody {\n    pub id: String,\n    pub status: RiskifiedWebhookStatus,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub enum RiskifiedWebhookStatus {\n    Approved,\n    Declined,\n}\n\nimpl From<RiskifiedWebhookStatus> for IncomingWebhookEvent {\n    fn from(value: RiskifiedWebhookStatus) -> Self {\n        match value {\n            RiskifiedWebhookStatus::Declined => Self::FrmRejected,\n            RiskifiedWebhookStatus::Approved => Self::FrmApproved,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__riskified__transformers__api.rs", "file": "crates__hyperswitch_connectors__src__connectors__riskified__transformers__api.rs"}, {"query": "convert router data to Riskified format", "code": "use api_models::{payments::AdditionalPaymentData, webhooks::IncomingWebhookEvent};\nuse common_enums::{Currency, FraudCheckStatus};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::Email,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{self, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::Fulfillment,\n    router_request_types::{\n        fraud_check::{FraudCheckFulfillmentData, FulfillmentStatus},\n        BrowserInformation, ResponseId,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        FrmCheckoutRouterData, FrmFulfillmentRouterData, FrmTransactionRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        convert_amount, AddressDetailsData as _, FraudCheckCheckoutRequest,\n        FraudCheckTransactionRequest, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<ConnectorError>;\n\npub struct RiskifiedRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl<T> From<(StringMajorUnit, T)> for RiskifiedRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\npub struct RiskifiedPaymentsCheckoutRequest {\n    order: CheckoutRequest,\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\npub struct CheckoutRequest {\n    id: String,\n    note: Option<String>,\n    email: Option<Email>,\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    currency: Option<Currency>,\n    #[serde\n\n... [truncated 19159 chars] ...\n\nlone()\n                .and_then(|phone_data| phone_data.number),\n        })\n    }\n}\n\nfn get_fulfillment_status(status: FulfillmentStatus) -> Option<FulfillmentRequestStatus> {\n    match status {\n        FulfillmentStatus::COMPLETE => Some(FulfillmentRequestStatus::Success),\n        FulfillmentStatus::CANCELED => Some(FulfillmentRequestStatus::Cancelled),\n        FulfillmentStatus::PARTIAL | FulfillmentStatus::REPLACEMENT => None,\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct RiskifiedWebhookBody {\n    pub id: String,\n    pub status: RiskifiedWebhookStatus,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub enum RiskifiedWebhookStatus {\n    Approved,\n    Declined,\n}\n\nimpl From<RiskifiedWebhookStatus> for IncomingWebhookEvent {\n    fn from(value: RiskifiedWebhookStatus) -> Self {\n        match value {\n            RiskifiedWebhookStatus::Declined => Self::FrmRejected,\n            RiskifiedWebhookStatus::Approved => Self::FrmApproved,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__riskified__transformers__api.rs", "file": "crates__hyperswitch_connectors__src__connectors__riskified__transformers__api.rs"}, {"query": "handle Riskified webhook status", "code": "use api_models::{payments::AdditionalPaymentData, webhooks::IncomingWebhookEvent};\nuse common_enums::{Currency, FraudCheckStatus};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::Email,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{self, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::Fulfillment,\n    router_request_types::{\n        fraud_check::{FraudCheckFulfillmentData, FulfillmentStatus},\n        BrowserInformation, ResponseId,\n    },\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        FrmCheckoutRouterData, FrmFulfillmentRouterData, FrmTransactionRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        convert_amount, AddressDetailsData as _, FraudCheckCheckoutRequest,\n        FraudCheckTransactionRequest, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<ConnectorError>;\n\npub struct RiskifiedRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl<T> From<(StringMajorUnit, T)> for RiskifiedRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\npub struct RiskifiedPaymentsCheckoutRequest {\n    order: CheckoutRequest,\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\npub struct CheckoutRequest {\n    id: String,\n    note: Option<String>,\n    email: Option<Email>,\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    currency: Option<Currency>,\n    #[serde\n\n... [truncated 19159 chars] ...\n\nlone()\n                .and_then(|phone_data| phone_data.number),\n        })\n    }\n}\n\nfn get_fulfillment_status(status: FulfillmentStatus) -> Option<FulfillmentRequestStatus> {\n    match status {\n        FulfillmentStatus::COMPLETE => Some(FulfillmentRequestStatus::Success),\n        FulfillmentStatus::CANCELED => Some(FulfillmentRequestStatus::Cancelled),\n        FulfillmentStatus::PARTIAL | FulfillmentStatus::REPLACEMENT => None,\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct RiskifiedWebhookBody {\n    pub id: String,\n    pub status: RiskifiedWebhookStatus,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub enum RiskifiedWebhookStatus {\n    Approved,\n    Declined,\n}\n\nimpl From<RiskifiedWebhookStatus> for IncomingWebhookEvent {\n    fn from(value: RiskifiedWebhookStatus) -> Self {\n        match value {\n            RiskifiedWebhookStatus::Declined => Self::FrmRejected,\n            RiskifiedWebhookStatus::Approved => Self::FrmApproved,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__riskified__transformers__api.rs", "file": "crates__hyperswitch_connectors__src__connectors__riskified__transformers__api.rs"}, {"query": "how to implement Tesouro payment gateway integration", "code": "pub mod tesouro_queries;\nuse api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_types::payments::{ApplePayPredecryptData, GPayPredecryptData};\nuse common_utils::types::FloatMajorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, Card, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsSyncData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, AdditionalCardInfo, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSyncRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub mod tesouro_constants {\n    pub const MAX_PAYMENT_REFERENCE_ID_LENGTH: usize = 28;\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GenericTesouroRequest<T> {\n    query: String,\n    variables: T,\n}\n\npub type TesouroAuthorizeRequest = GenericTesouroRequest<TesouroPaymentRequest>;\npub type TesouroSetupMandateRequest = GenericTesouroRequest<TesouroVerifyAccountRequest>;\npub type TesouroCaptureRequest = GenericTesouroRequest<TesouroCaptureInput>;\npub type TesouroVoidRequest = GenericTesouroRequest\n\n... [truncated 88737 chars] ...\n\nempt_status: None,\n                        connector_transaction_id: None,\n                        connector_response_reference_id: None,\n                        network_advice_code: None,\n                        network_decline_code: None,\n                        network_error_message: None,\n                        connector_metadata: None,\n                    }),\n                    ..item.data\n                })\n            }\n        }\n    }\n}\n\nfn get_valid_transaction_id(\n    id: String,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    if id.len() <= tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH {\n        Ok(id.clone())\n    } else {\n        Err(errors::ConnectorError::MaxFieldLengthViolated {\n            connector: \"Tesouro\".to_string(),\n            field_name: \"transaction_reference\".to_string(),\n            max_length: tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH,\n            received_length: id.len(),\n        }\n        .into())\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tesouro__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__tesouro__transformers.rs"}, {"query": "Tesouro payment gateway API request transformation", "code": "pub mod tesouro_queries;\nuse api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_types::payments::{ApplePayPredecryptData, GPayPredecryptData};\nuse common_utils::types::FloatMajorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, Card, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsSyncData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, AdditionalCardInfo, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSyncRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub mod tesouro_constants {\n    pub const MAX_PAYMENT_REFERENCE_ID_LENGTH: usize = 28;\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GenericTesouroRequest<T> {\n    query: String,\n    variables: T,\n}\n\npub type TesouroAuthorizeRequest = GenericTesouroRequest<TesouroPaymentRequest>;\npub type TesouroSetupMandateRequest = GenericTesouroRequest<TesouroVerifyAccountRequest>;\npub type TesouroCaptureRequest = GenericTesouroRequest<TesouroCaptureInput>;\npub type TesouroVoidRequest = GenericTesouroRequest\n\n... [truncated 88737 chars] ...\n\nempt_status: None,\n                        connector_transaction_id: None,\n                        connector_response_reference_id: None,\n                        network_advice_code: None,\n                        network_decline_code: None,\n                        network_error_message: None,\n                        connector_metadata: None,\n                    }),\n                    ..item.data\n                })\n            }\n        }\n    }\n}\n\nfn get_valid_transaction_id(\n    id: String,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    if id.len() <= tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH {\n        Ok(id.clone())\n    } else {\n        Err(errors::ConnectorError::MaxFieldLengthViolated {\n            connector: \"Tesouro\".to_string(),\n            field_name: \"transaction_reference\".to_string(),\n            max_length: tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH,\n            received_length: id.len(),\n        }\n        .into())\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tesouro__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__tesouro__transformers.rs"}, {"query": "Tesouro payment gateway error handling", "code": "pub mod tesouro_queries;\nuse api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_types::payments::{ApplePayPredecryptData, GPayPredecryptData};\nuse common_utils::types::FloatMajorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, Card, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsSyncData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, AdditionalCardInfo, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSyncRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub mod tesouro_constants {\n    pub const MAX_PAYMENT_REFERENCE_ID_LENGTH: usize = 28;\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GenericTesouroRequest<T> {\n    query: String,\n    variables: T,\n}\n\npub type TesouroAuthorizeRequest = GenericTesouroRequest<TesouroPaymentRequest>;\npub type TesouroSetupMandateRequest = GenericTesouroRequest<TesouroVerifyAccountRequest>;\npub type TesouroCaptureRequest = GenericTesouroRequest<TesouroCaptureInput>;\npub type TesouroVoidRequest = GenericTesouroRequest\n\n... [truncated 88737 chars] ...\n\nempt_status: None,\n                        connector_transaction_id: None,\n                        connector_response_reference_id: None,\n                        network_advice_code: None,\n                        network_decline_code: None,\n                        network_error_message: None,\n                        connector_metadata: None,\n                    }),\n                    ..item.data\n                })\n            }\n        }\n    }\n}\n\nfn get_valid_transaction_id(\n    id: String,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    if id.len() <= tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH {\n        Ok(id.clone())\n    } else {\n        Err(errors::ConnectorError::MaxFieldLengthViolated {\n            connector: \"Tesouro\".to_string(),\n            field_name: \"transaction_reference\".to_string(),\n            max_length: tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH,\n            received_length: id.len(),\n        }\n        .into())\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tesouro__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__tesouro__transformers.rs"}, {"query": "Tesouro payment gateway response parsing", "code": "pub mod tesouro_queries;\nuse api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_types::payments::{ApplePayPredecryptData, GPayPredecryptData};\nuse common_utils::types::FloatMajorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, Card, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsSyncData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, AdditionalCardInfo, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSyncRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub mod tesouro_constants {\n    pub const MAX_PAYMENT_REFERENCE_ID_LENGTH: usize = 28;\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GenericTesouroRequest<T> {\n    query: String,\n    variables: T,\n}\n\npub type TesouroAuthorizeRequest = GenericTesouroRequest<TesouroPaymentRequest>;\npub type TesouroSetupMandateRequest = GenericTesouroRequest<TesouroVerifyAccountRequest>;\npub type TesouroCaptureRequest = GenericTesouroRequest<TesouroCaptureInput>;\npub type TesouroVoidRequest = GenericTesouroRequest\n\n... [truncated 88737 chars] ...\n\nempt_status: None,\n                        connector_transaction_id: None,\n                        connector_response_reference_id: None,\n                        network_advice_code: None,\n                        network_decline_code: None,\n                        network_error_message: None,\n                        connector_metadata: None,\n                    }),\n                    ..item.data\n                })\n            }\n        }\n    }\n}\n\nfn get_valid_transaction_id(\n    id: String,\n) -> Result<String, error_stack::Report<errors::ConnectorError>> {\n    if id.len() <= tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH {\n        Ok(id.clone())\n    } else {\n        Err(errors::ConnectorError::MaxFieldLengthViolated {\n            connector: \"Tesouro\".to_string(),\n            field_name: \"transaction_reference\".to_string(),\n            max_length: tesouro_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH,\n            received_length: id.len(),\n        }\n        .into())\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tesouro__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__tesouro__transformers.rs"}, {"query": "how to implement user signup in hyperswitch", "code": "pub mod theme;\n\nuse actix_web::{web, HttpRequest, HttpResponse};\n#[cfg(feature = \"dummy_connector\")]\nuse api_models::user::sample_data::SampleDataRequest;\nuse api_models::{\n    errors::types::ApiErrorResponse,\n    user::{self as user_api},\n};\nuse common_enums::TokenPurpose;\nuse common_utils::errors::ReportSwitchExt;\nuse router_env::Flow;\n\nuse super::AppState;\nuse crate::{\n    core::{api_locking, user as user_core},\n    services::{\n        api,\n        authentication::{self as auth},\n        authorization::permissions::Permission,\n    },\n    utils::user::dashboard_metadata::{parse_string_to_enums, set_ip_address_if_required},\n};\n\npub async fn get_user_details(state: web::Data<AppState>, req: HttpRequest) -> HttpResponse {\n    let flow = Flow::GetUserDetails;\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        (),\n        |state, user, _, _| user_core::get_user_details(state, user),\n        &auth::DashboardNoPermissionAuth,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"email\")]\npub async fn user_signup_with_merchant_id(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n    json_payload: web::Json<user_api::SignUpWithMerchantIdRequest>,\n    query: web::Query<user_api::AuthIdAndThemeIdQueryParam>,\n) -> HttpResponse {\n    let flow = Flow::UserSignUpWithMerchantId;\n    let req_payload = json_payload.into_inner();\n    let query_params = query.into_inner();\n    Box::pin(api::server_wrap(\n        flow.clone(),\n        state,\n        &http_req,\n        req_payload.clone(),\n        |state, _, req_body, _| {\n            user_core::signup_with_merchant_id(\n                state,\n                req_body,\n                query_params.auth_id.clone(),\n                query_params.theme_id.clone(),\n            )\n        },\n        &auth::AdminApiAuth,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\npub async fn user_signup(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n    json_pa\n\n... [truncated 28942 chars] ...\n\na.platform.get_processor().clone(),\n                auth_data.profile,\n            )\n        },\n        &auth::ApiKeyAuth {\n            allow_platform_self_operation: false,\n            allow_connected_scope_operation: false,\n        },\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v1\")]\npub async fn embedded_token_info(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n) -> HttpResponse {\n    let flow = Flow::EmbeddedTokenInfo;\n    Box::pin(api::server_wrap(\n        flow,\n        state.clone(),\n        &http_req,\n        (),\n        |state, auth_data, _, _| {\n            user_core::embedded_token_info(\n                state,\n                auth_data.platform.get_processor().clone(),\n                auth_data.profile,\n            )\n        },\n        &auth::JWTAndEmbeddedAuth {\n            merchant_id_from_route: None,\n            permission: None,\n        },\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n", "function_name": "crates__router__src__routes__user.rs", "file": "crates__router__src__routes__user.rs"}, {"query": "user authentication routes rust hyperswitch", "code": "pub mod theme;\n\nuse actix_web::{web, HttpRequest, HttpResponse};\n#[cfg(feature = \"dummy_connector\")]\nuse api_models::user::sample_data::SampleDataRequest;\nuse api_models::{\n    errors::types::ApiErrorResponse,\n    user::{self as user_api},\n};\nuse common_enums::TokenPurpose;\nuse common_utils::errors::ReportSwitchExt;\nuse router_env::Flow;\n\nuse super::AppState;\nuse crate::{\n    core::{api_locking, user as user_core},\n    services::{\n        api,\n        authentication::{self as auth},\n        authorization::permissions::Permission,\n    },\n    utils::user::dashboard_metadata::{parse_string_to_enums, set_ip_address_if_required},\n};\n\npub async fn get_user_details(state: web::Data<AppState>, req: HttpRequest) -> HttpResponse {\n    let flow = Flow::GetUserDetails;\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        (),\n        |state, user, _, _| user_core::get_user_details(state, user),\n        &auth::DashboardNoPermissionAuth,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"email\")]\npub async fn user_signup_with_merchant_id(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n    json_payload: web::Json<user_api::SignUpWithMerchantIdRequest>,\n    query: web::Query<user_api::AuthIdAndThemeIdQueryParam>,\n) -> HttpResponse {\n    let flow = Flow::UserSignUpWithMerchantId;\n    let req_payload = json_payload.into_inner();\n    let query_params = query.into_inner();\n    Box::pin(api::server_wrap(\n        flow.clone(),\n        state,\n        &http_req,\n        req_payload.clone(),\n        |state, _, req_body, _| {\n            user_core::signup_with_merchant_id(\n                state,\n                req_body,\n                query_params.auth_id.clone(),\n                query_params.theme_id.clone(),\n            )\n        },\n        &auth::AdminApiAuth,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\npub async fn user_signup(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n    json_pa\n\n... [truncated 28942 chars] ...\n\na.platform.get_processor().clone(),\n                auth_data.profile,\n            )\n        },\n        &auth::ApiKeyAuth {\n            allow_platform_self_operation: false,\n            allow_connected_scope_operation: false,\n        },\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v1\")]\npub async fn embedded_token_info(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n) -> HttpResponse {\n    let flow = Flow::EmbeddedTokenInfo;\n    Box::pin(api::server_wrap(\n        flow,\n        state.clone(),\n        &http_req,\n        (),\n        |state, auth_data, _, _| {\n            user_core::embedded_token_info(\n                state,\n                auth_data.platform.get_processor().clone(),\n                auth_data.profile,\n            )\n        },\n        &auth::JWTAndEmbeddedAuth {\n            merchant_id_from_route: None,\n            permission: None,\n        },\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n", "function_name": "crates__router__src__routes__user.rs", "file": "crates__router__src__routes__user.rs"}, {"query": "get_user_details function implementation", "code": "pub mod theme;\n\nuse actix_web::{web, HttpRequest, HttpResponse};\n#[cfg(feature = \"dummy_connector\")]\nuse api_models::user::sample_data::SampleDataRequest;\nuse api_models::{\n    errors::types::ApiErrorResponse,\n    user::{self as user_api},\n};\nuse common_enums::TokenPurpose;\nuse common_utils::errors::ReportSwitchExt;\nuse router_env::Flow;\n\nuse super::AppState;\nuse crate::{\n    core::{api_locking, user as user_core},\n    services::{\n        api,\n        authentication::{self as auth},\n        authorization::permissions::Permission,\n    },\n    utils::user::dashboard_metadata::{parse_string_to_enums, set_ip_address_if_required},\n};\n\npub async fn get_user_details(state: web::Data<AppState>, req: HttpRequest) -> HttpResponse {\n    let flow = Flow::GetUserDetails;\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        (),\n        |state, user, _, _| user_core::get_user_details(state, user),\n        &auth::DashboardNoPermissionAuth,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"email\")]\npub async fn user_signup_with_merchant_id(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n    json_payload: web::Json<user_api::SignUpWithMerchantIdRequest>,\n    query: web::Query<user_api::AuthIdAndThemeIdQueryParam>,\n) -> HttpResponse {\n    let flow = Flow::UserSignUpWithMerchantId;\n    let req_payload = json_payload.into_inner();\n    let query_params = query.into_inner();\n    Box::pin(api::server_wrap(\n        flow.clone(),\n        state,\n        &http_req,\n        req_payload.clone(),\n        |state, _, req_body, _| {\n            user_core::signup_with_merchant_id(\n                state,\n                req_body,\n                query_params.auth_id.clone(),\n                query_params.theme_id.clone(),\n            )\n        },\n        &auth::AdminApiAuth,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\npub async fn user_signup(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n    json_pa\n\n... [truncated 28942 chars] ...\n\na.platform.get_processor().clone(),\n                auth_data.profile,\n            )\n        },\n        &auth::ApiKeyAuth {\n            allow_platform_self_operation: false,\n            allow_connected_scope_operation: false,\n        },\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v1\")]\npub async fn embedded_token_info(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n) -> HttpResponse {\n    let flow = Flow::EmbeddedTokenInfo;\n    Box::pin(api::server_wrap(\n        flow,\n        state.clone(),\n        &http_req,\n        (),\n        |state, auth_data, _, _| {\n            user_core::embedded_token_info(\n                state,\n                auth_data.platform.get_processor().clone(),\n                auth_data.profile,\n            )\n        },\n        &auth::JWTAndEmbeddedAuth {\n            merchant_id_from_route: None,\n            permission: None,\n        },\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n", "function_name": "crates__router__src__routes__user.rs", "file": "crates__router__src__routes__user.rs"}, {"query": "user signup with merchant id api", "code": "pub mod theme;\n\nuse actix_web::{web, HttpRequest, HttpResponse};\n#[cfg(feature = \"dummy_connector\")]\nuse api_models::user::sample_data::SampleDataRequest;\nuse api_models::{\n    errors::types::ApiErrorResponse,\n    user::{self as user_api},\n};\nuse common_enums::TokenPurpose;\nuse common_utils::errors::ReportSwitchExt;\nuse router_env::Flow;\n\nuse super::AppState;\nuse crate::{\n    core::{api_locking, user as user_core},\n    services::{\n        api,\n        authentication::{self as auth},\n        authorization::permissions::Permission,\n    },\n    utils::user::dashboard_metadata::{parse_string_to_enums, set_ip_address_if_required},\n};\n\npub async fn get_user_details(state: web::Data<AppState>, req: HttpRequest) -> HttpResponse {\n    let flow = Flow::GetUserDetails;\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        (),\n        |state, user, _, _| user_core::get_user_details(state, user),\n        &auth::DashboardNoPermissionAuth,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"email\")]\npub async fn user_signup_with_merchant_id(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n    json_payload: web::Json<user_api::SignUpWithMerchantIdRequest>,\n    query: web::Query<user_api::AuthIdAndThemeIdQueryParam>,\n) -> HttpResponse {\n    let flow = Flow::UserSignUpWithMerchantId;\n    let req_payload = json_payload.into_inner();\n    let query_params = query.into_inner();\n    Box::pin(api::server_wrap(\n        flow.clone(),\n        state,\n        &http_req,\n        req_payload.clone(),\n        |state, _, req_body, _| {\n            user_core::signup_with_merchant_id(\n                state,\n                req_body,\n                query_params.auth_id.clone(),\n                query_params.theme_id.clone(),\n            )\n        },\n        &auth::AdminApiAuth,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\npub async fn user_signup(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n    json_pa\n\n... [truncated 28942 chars] ...\n\na.platform.get_processor().clone(),\n                auth_data.profile,\n            )\n        },\n        &auth::ApiKeyAuth {\n            allow_platform_self_operation: false,\n            allow_connected_scope_operation: false,\n        },\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v1\")]\npub async fn embedded_token_info(\n    state: web::Data<AppState>,\n    http_req: HttpRequest,\n) -> HttpResponse {\n    let flow = Flow::EmbeddedTokenInfo;\n    Box::pin(api::server_wrap(\n        flow,\n        state.clone(),\n        &http_req,\n        (),\n        |state, auth_data, _, _| {\n            user_core::embedded_token_info(\n                state,\n                auth_data.platform.get_processor().clone(),\n                auth_data.profile,\n            )\n        },\n        &auth::JWTAndEmbeddedAuth {\n            merchant_id_from_route: None,\n            permission: None,\n        },\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n", "function_name": "crates__router__src__routes__user.rs", "file": "crates__router__src__routes__user.rs"}, {"query": "Worldpay XML connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{\n        payouts::{PoCancel, PoFulfill},\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self,\n\n... [truncated 49518 chars] ...\n\nnfo {\n    display_name: \"Worldpay XML\",\n    description: \"Worldpay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic WORLDPAYXML_SUPPORTED_WEBHOOK_FLOWS: &[common_enums::EventClass] = &[\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n    #[cfg(feature = \"payouts\")]\n    common_enums::EventClass::Payouts,\n];\n\nimpl ConnectorSpecifications for Worldpayxml {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAYXML_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAYXML_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(WORLDPAYXML_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayxml.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayxml.rs"}, {"query": "Worldpayxml struct Rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{\n        payouts::{PoCancel, PoFulfill},\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self,\n\n... [truncated 49518 chars] ...\n\nnfo {\n    display_name: \"Worldpay XML\",\n    description: \"Worldpay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic WORLDPAYXML_SUPPORTED_WEBHOOK_FLOWS: &[common_enums::EventClass] = &[\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n    #[cfg(feature = \"payouts\")]\n    common_enums::EventClass::Payouts,\n];\n\nimpl ConnectorSpecifications for Worldpayxml {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAYXML_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAYXML_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(WORLDPAYXML_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayxml.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayxml.rs"}, {"query": "how to integrate Worldpay XML with Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{\n        payouts::{PoCancel, PoFulfill},\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self,\n\n... [truncated 49518 chars] ...\n\nnfo {\n    display_name: \"Worldpay XML\",\n    description: \"Worldpay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic WORLDPAYXML_SUPPORTED_WEBHOOK_FLOWS: &[common_enums::EventClass] = &[\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n    #[cfg(feature = \"payouts\")]\n    common_enums::EventClass::Payouts,\n];\n\nimpl ConnectorSpecifications for Worldpayxml {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAYXML_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAYXML_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(WORLDPAYXML_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayxml.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayxml.rs"}, {"query": "Worldpay XML API request builder", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{\n        payouts::{PoCancel, PoFulfill},\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self,\n\n... [truncated 49518 chars] ...\n\nnfo {\n    display_name: \"Worldpay XML\",\n    description: \"Worldpay is a payment gateway and PSP enabling secure online transactions\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic WORLDPAYXML_SUPPORTED_WEBHOOK_FLOWS: &[common_enums::EventClass] = &[\n    common_enums::EventClass::Payments,\n    common_enums::EventClass::Refunds,\n    #[cfg(feature = \"payouts\")]\n    common_enums::EventClass::Payouts,\n];\n\nimpl ConnectorSpecifications for Worldpayxml {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAYXML_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAYXML_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n        Some(WORLDPAYXML_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayxml.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayxml.rs"}, {"query": "Helcim payment request transformation", "code": "use common_enums::enums;\nuse common_utils::{\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCaptureRequestData, PaymentsSetupMandateRequestData,\n        RefundsRequestData, RouterData as RouterDataUtils,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct HelcimRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for HelcimRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub fn check_currency(\n    currency: enums::Currency,\n) -> Result<enums::Currency, errors::ConnectorError> {\n    if currency == enums::Currency::USD {\n        Ok(currency)\n    } else {\n        Err(errors::ConnectorError::NotSupported {\n            message: format!(\"currency {currency} is not supported for this merchant account\"),\n            c\n\n... [truncated 23364 chars] ...\n\nimpl TryFrom<RefundsResponseRouterData<RSync, RefundResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.transaction_id.to_string(),\n                refund_status: enums::RefundStatus::from(item.response),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, strum::Display, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum HelcimErrorTypes {\n    StringType(String),\n    JsonType(serde_json::Value),\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct HelcimPaymentsErrorResponse {\n    pub errors: HelcimErrorTypes,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum HelcimErrorResponse {\n    Payment(HelcimPaymentsErrorResponse),\n    General(String),\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__helcim__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__helcim__transformers.rs"}, {"query": "HelcimVerifyRequest struct definition", "code": "use common_enums::enums;\nuse common_utils::{\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCaptureRequestData, PaymentsSetupMandateRequestData,\n        RefundsRequestData, RouterData as RouterDataUtils,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct HelcimRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for HelcimRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub fn check_currency(\n    currency: enums::Currency,\n) -> Result<enums::Currency, errors::ConnectorError> {\n    if currency == enums::Currency::USD {\n        Ok(currency)\n    } else {\n        Err(errors::ConnectorError::NotSupported {\n            message: format!(\"currency {currency} is not supported for this merchant account\"),\n            c\n\n... [truncated 23364 chars] ...\n\nimpl TryFrom<RefundsResponseRouterData<RSync, RefundResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.transaction_id.to_string(),\n                refund_status: enums::RefundStatus::from(item.response),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, strum::Display, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum HelcimErrorTypes {\n    StringType(String),\n    JsonType(serde_json::Value),\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct HelcimPaymentsErrorResponse {\n    pub errors: HelcimErrorTypes,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum HelcimErrorResponse {\n    Payment(HelcimPaymentsErrorResponse),\n    General(String),\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__helcim__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__helcim__transformers.rs"}, {"query": "how to transform router data for Helcim", "code": "use common_enums::enums;\nuse common_utils::{\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCaptureRequestData, PaymentsSetupMandateRequestData,\n        RefundsRequestData, RouterData as RouterDataUtils,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct HelcimRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for HelcimRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub fn check_currency(\n    currency: enums::Currency,\n) -> Result<enums::Currency, errors::ConnectorError> {\n    if currency == enums::Currency::USD {\n        Ok(currency)\n    } else {\n        Err(errors::ConnectorError::NotSupported {\n            message: format!(\"currency {currency} is not supported for this merchant account\"),\n            c\n\n... [truncated 23364 chars] ...\n\nimpl TryFrom<RefundsResponseRouterData<RSync, RefundResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.transaction_id.to_string(),\n                refund_status: enums::RefundStatus::from(item.response),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, strum::Display, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum HelcimErrorTypes {\n    StringType(String),\n    JsonType(serde_json::Value),\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct HelcimPaymentsErrorResponse {\n    pub errors: HelcimErrorTypes,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum HelcimErrorResponse {\n    Payment(HelcimPaymentsErrorResponse),\n    General(String),\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__helcim__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__helcim__transformers.rs"}, {"query": "Helcim response to router data conversion", "code": "use common_enums::enums;\nuse common_utils::{\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCaptureRequestData, PaymentsSetupMandateRequestData,\n        RefundsRequestData, RouterData as RouterDataUtils,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct HelcimRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(FloatMajorUnit, T)> for HelcimRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (FloatMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub fn check_currency(\n    currency: enums::Currency,\n) -> Result<enums::Currency, errors::ConnectorError> {\n    if currency == enums::Currency::USD {\n        Ok(currency)\n    } else {\n        Err(errors::ConnectorError::NotSupported {\n            message: format!(\"currency {currency} is not supported for this merchant account\"),\n            c\n\n... [truncated 23364 chars] ...\n\nimpl TryFrom<RefundsResponseRouterData<RSync, RefundResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.transaction_id.to_string(),\n                refund_status: enums::RefundStatus::from(item.response),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, strum::Display, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum HelcimErrorTypes {\n    StringType(String),\n    JsonType(serde_json::Value),\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct HelcimPaymentsErrorResponse {\n    pub errors: HelcimErrorTypes,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum HelcimErrorResponse {\n    Payment(HelcimPaymentsErrorResponse),\n    General(String),\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__helcim__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__helcim__transformers.rs"}, {"query": "Token.io connector implementation", "code": "pub mod transformers;\nuse std::{\n    sync::LazyLock,\n    time::{SystemTime, UNIX_EPOCH},\n};\n\nuse base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine as _};\nuse common_enums::{enums, FeatureStatus, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, VerifySignature},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse openssl::{ec::EcKey, hash::MessageDigest, pkey::PKey, rsa::Rsa, sign::Signer};\nuse transformers::{self as tokenio, TokenioPaymentStatus};\n\nuse crate::{constants::headers, types::ResponseRouterData, u\n\n... [truncated 26547 chars] ...\n\n  display_name: \"Token.io\",\n    description: \"Token.io is a financial technology company that provides Open Banking and real-time payment solutions across Europe. They enable secure bank-to-bank transfers using various payment rails including SEPA, Faster Payments, and other regional payment systems.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic TOKENIO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Tokenio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TOKENIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TOKENIO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TOKENIO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenio.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenio.rs"}, {"query": "hyperswitch open banking sepa", "code": "pub mod transformers;\nuse std::{\n    sync::LazyLock,\n    time::{SystemTime, UNIX_EPOCH},\n};\n\nuse base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine as _};\nuse common_enums::{enums, FeatureStatus, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, VerifySignature},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse openssl::{ec::EcKey, hash::MessageDigest, pkey::PKey, rsa::Rsa, sign::Signer};\nuse transformers::{self as tokenio, TokenioPaymentStatus};\n\nuse crate::{constants::headers, types::ResponseRouterData, u\n\n... [truncated 26547 chars] ...\n\n  display_name: \"Token.io\",\n    description: \"Token.io is a financial technology company that provides Open Banking and real-time payment solutions across Europe. They enable secure bank-to-bank transfers using various payment rails including SEPA, Faster Payments, and other regional payment systems.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic TOKENIO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Tokenio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TOKENIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TOKENIO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TOKENIO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenio.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenio.rs"}, {"query": "how to add new payment connector", "code": "pub mod transformers;\nuse std::{\n    sync::LazyLock,\n    time::{SystemTime, UNIX_EPOCH},\n};\n\nuse base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine as _};\nuse common_enums::{enums, FeatureStatus, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, VerifySignature},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse openssl::{ec::EcKey, hash::MessageDigest, pkey::PKey, rsa::Rsa, sign::Signer};\nuse transformers::{self as tokenio, TokenioPaymentStatus};\n\nuse crate::{constants::headers, types::ResponseRouterData, u\n\n... [truncated 26547 chars] ...\n\n  display_name: \"Token.io\",\n    description: \"Token.io is a financial technology company that provides Open Banking and real-time payment solutions across Europe. They enable secure bank-to-bank transfers using various payment rails including SEPA, Faster Payments, and other regional payment systems.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic TOKENIO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Tokenio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TOKENIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TOKENIO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TOKENIO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenio.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenio.rs"}, {"query": "Tokenio payment method tokenization", "code": "pub mod transformers;\nuse std::{\n    sync::LazyLock,\n    time::{SystemTime, UNIX_EPOCH},\n};\n\nuse base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine as _};\nuse common_enums::{enums, FeatureStatus, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, VerifySignature},\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse openssl::{ec::EcKey, hash::MessageDigest, pkey::PKey, rsa::Rsa, sign::Signer};\nuse transformers::{self as tokenio, TokenioPaymentStatus};\n\nuse crate::{constants::headers, types::ResponseRouterData, u\n\n... [truncated 26547 chars] ...\n\n  display_name: \"Token.io\",\n    description: \"Token.io is a financial technology company that provides Open Banking and real-time payment solutions across Europe. They enable secure bank-to-bank transfers using various payment rails including SEPA, Faster Payments, and other regional payment systems.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic TOKENIO_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Tokenio {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TOKENIO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TOKENIO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TOKENIO_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenio.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenio.rs"}, {"query": "ACI Payments connector implementation", "code": "mod aci_result_codes;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::{CryptoError, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse ring::aead::{self, UnboundKey};\nuse transformers as aci;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouter\n\n... [truncated 41958 chars] ...\n\npecific_features: None,\n        },\n    );\n\n    aci_supported_payment_methods\n});\n\nstatic ACI_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"ACI\",\n    description:\n        \"ACI Payments delivers secure, real-time electronic payment solutions for businesses, banks, and governments, enabling seamless transactions across channels.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic ACI_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Aci {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ACI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ACI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ACI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__aci.rs", "file": "crates__hyperswitch_connectors__src__connectors__aci.rs"}, {"query": "how to integrate ACI payments with Hyperswitch", "code": "mod aci_result_codes;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::{CryptoError, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse ring::aead::{self, UnboundKey};\nuse transformers as aci;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouter\n\n... [truncated 41958 chars] ...\n\npecific_features: None,\n        },\n    );\n\n    aci_supported_payment_methods\n});\n\nstatic ACI_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"ACI\",\n    description:\n        \"ACI Payments delivers secure, real-time electronic payment solutions for businesses, banks, and governments, enabling seamless transactions across channels.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic ACI_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Aci {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ACI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ACI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ACI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__aci.rs", "file": "crates__hyperswitch_connectors__src__connectors__aci.rs"}, {"query": "ACI connector authentication and API integration", "code": "mod aci_result_codes;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::{CryptoError, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse ring::aead::{self, UnboundKey};\nuse transformers as aci;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouter\n\n... [truncated 41958 chars] ...\n\npecific_features: None,\n        },\n    );\n\n    aci_supported_payment_methods\n});\n\nstatic ACI_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"ACI\",\n    description:\n        \"ACI Payments delivers secure, real-time electronic payment solutions for businesses, banks, and governments, enabling seamless transactions across channels.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic ACI_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Aci {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ACI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ACI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ACI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__aci.rs", "file": "crates__hyperswitch_connectors__src__connectors__aci.rs"}, {"query": "ACI payment method types supported", "code": "mod aci_result_codes;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::{CryptoError, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse ring::aead::{self, UnboundKey};\nuse transformers as aci;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouter\n\n... [truncated 41958 chars] ...\n\npecific_features: None,\n        },\n    );\n\n    aci_supported_payment_methods\n});\n\nstatic ACI_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"ACI\",\n    description:\n        \"ACI Payments delivers secure, real-time electronic payment solutions for businesses, banks, and governments, enabling seamless transactions across channels.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic ACI_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Aci {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ACI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ACI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ACI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__aci.rs", "file": "crates__hyperswitch_connectors__src__connectors__aci.rs"}, {"query": "how to process Redsys payments", "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://\n\n... [truncated 93506 chars] ...\n\nk_advice_code: None,\n                            network_decline_code: None,\n                            network_error_message: None,\n                            connector_metadata: None,\n                        })\n                    } else {\n                        Ok(RefundsResponseData {\n                            connector_refund_id: response.ds_order,\n                            refund_status,\n                        })\n                    }\n                } else {\n                    // When the refund is pending\n                    Ok(RefundsResponseData {\n                        connector_refund_id: response.ds_order,\n                        refund_status: enums::RefundStatus::Pending,\n                    })\n                }\n            }\n            (Some(_), Some(_)) | (None, None) => {\n                Err(errors::ConnectorError::ResponseHandlingFailed)?\n            }\n        };\n\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs"}, {"query": "Redsys SOAP request transformation", "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://\n\n... [truncated 93506 chars] ...\n\nk_advice_code: None,\n                            network_decline_code: None,\n                            network_error_message: None,\n                            connector_metadata: None,\n                        })\n                    } else {\n                        Ok(RefundsResponseData {\n                            connector_refund_id: response.ds_order,\n                            refund_status,\n                        })\n                    }\n                } else {\n                    // When the refund is pending\n                    Ok(RefundsResponseData {\n                        connector_refund_id: response.ds_order,\n                        refund_status: enums::RefundStatus::Pending,\n                    })\n                }\n            }\n            (Some(_), Some(_)) | (None, None) => {\n                Err(errors::ConnectorError::ResponseHandlingFailed)?\n            }\n        };\n\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs"}, {"query": "implement Redsys connector", "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://\n\n... [truncated 93506 chars] ...\n\nk_advice_code: None,\n                            network_decline_code: None,\n                            network_error_message: None,\n                            connector_metadata: None,\n                        })\n                    } else {\n                        Ok(RefundsResponseData {\n                            connector_refund_id: response.ds_order,\n                            refund_status,\n                        })\n                    }\n                } else {\n                    // When the refund is pending\n                    Ok(RefundsResponseData {\n                        connector_refund_id: response.ds_order,\n                        refund_status: enums::RefundStatus::Pending,\n                    })\n                }\n            }\n            (Some(_), Some(_)) | (None, None) => {\n                Err(errors::ConnectorError::ResponseHandlingFailed)?\n            }\n        };\n\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs"}, {"query": "Redsys payment response handling", "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://\n\n... [truncated 93506 chars] ...\n\nk_advice_code: None,\n                            network_decline_code: None,\n                            network_error_message: None,\n                            connector_metadata: None,\n                        })\n                    } else {\n                        Ok(RefundsResponseData {\n                            connector_refund_id: response.ds_order,\n                            refund_status,\n                        })\n                    }\n                } else {\n                    // When the refund is pending\n                    Ok(RefundsResponseData {\n                        connector_refund_id: response.ds_order,\n                        refund_status: enums::RefundStatus::Pending,\n                    })\n                }\n            }\n            (Some(_), Some(_)) | (None, None) => {\n                Err(errors::ConnectorError::ResponseHandlingFailed)?\n            }\n        };\n\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs"}, {"query": "Tokenex payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        ExternalVaultInsertFlow, ExternalVaultRetrieveFlow,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData, VaultRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n        VaultResponseData,\n    },\n    types::VaultRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as tokenex;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Tokenex;\n\nimpl api::Payment for Tokenex {}\nimpl api::PaymentSession for Tokenex {}\nimpl api::ConnectorAccessToken for Tokenex {}\nimpl api::MandateSetup for Tokenex {}\nimpl api::PaymentAuthorize for Tokenex {}\nimpl api::PaymentSync for Tokenex {}\nimpl api::PaymentCapture for Tokenex {}\nimpl api::PaymentVoid for Tokenex {}\nimpl api::Refund for Tokenex {}\nimpl api::RefundExecute for Tokenex {}\nimpl api::RefundSync for Tokenex {}\nimpl api::PaymentToken for Tok\n\n... [truncated 10975 chars] ...\n\n     Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic TOKENEX_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic TOKENEX_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Tokenex\",\n    description: \"Tokenex connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic TOKENEX_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Tokenex {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TOKENEX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TOKENEX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TOKENEX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenex.rs"}, {"query": "hyperswitch tokenex connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        ExternalVaultInsertFlow, ExternalVaultRetrieveFlow,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData, VaultRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n        VaultResponseData,\n    },\n    types::VaultRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as tokenex;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Tokenex;\n\nimpl api::Payment for Tokenex {}\nimpl api::PaymentSession for Tokenex {}\nimpl api::ConnectorAccessToken for Tokenex {}\nimpl api::MandateSetup for Tokenex {}\nimpl api::PaymentAuthorize for Tokenex {}\nimpl api::PaymentSync for Tokenex {}\nimpl api::PaymentCapture for Tokenex {}\nimpl api::PaymentVoid for Tokenex {}\nimpl api::Refund for Tokenex {}\nimpl api::RefundExecute for Tokenex {}\nimpl api::RefundSync for Tokenex {}\nimpl api::PaymentToken for Tok\n\n... [truncated 10975 chars] ...\n\n     Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic TOKENEX_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic TOKENEX_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Tokenex\",\n    description: \"Tokenex connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic TOKENEX_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Tokenex {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TOKENEX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TOKENEX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TOKENEX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenex.rs"}, {"query": "how to configure tokenex connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        ExternalVaultInsertFlow, ExternalVaultRetrieveFlow,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData, VaultRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n        VaultResponseData,\n    },\n    types::VaultRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as tokenex;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Tokenex;\n\nimpl api::Payment for Tokenex {}\nimpl api::PaymentSession for Tokenex {}\nimpl api::ConnectorAccessToken for Tokenex {}\nimpl api::MandateSetup for Tokenex {}\nimpl api::PaymentAuthorize for Tokenex {}\nimpl api::PaymentSync for Tokenex {}\nimpl api::PaymentCapture for Tokenex {}\nimpl api::PaymentVoid for Tokenex {}\nimpl api::Refund for Tokenex {}\nimpl api::RefundExecute for Tokenex {}\nimpl api::RefundSync for Tokenex {}\nimpl api::PaymentToken for Tok\n\n... [truncated 10975 chars] ...\n\n     Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic TOKENEX_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic TOKENEX_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Tokenex\",\n    description: \"Tokenex connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic TOKENEX_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Tokenex {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TOKENEX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TOKENEX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TOKENEX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenex.rs"}, {"query": "TokenexAuthType header configuration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        ExternalVaultInsertFlow, ExternalVaultRetrieveFlow,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData, VaultRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n        VaultResponseData,\n    },\n    types::VaultRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as tokenex;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Tokenex;\n\nimpl api::Payment for Tokenex {}\nimpl api::PaymentSession for Tokenex {}\nimpl api::ConnectorAccessToken for Tokenex {}\nimpl api::MandateSetup for Tokenex {}\nimpl api::PaymentAuthorize for Tokenex {}\nimpl api::PaymentSync for Tokenex {}\nimpl api::PaymentCapture for Tokenex {}\nimpl api::PaymentVoid for Tokenex {}\nimpl api::Refund for Tokenex {}\nimpl api::RefundExecute for Tokenex {}\nimpl api::RefundSync for Tokenex {}\nimpl api::PaymentToken for Tok\n\n... [truncated 10975 chars] ...\n\n     Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic TOKENEX_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic TOKENEX_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Tokenex\",\n    description: \"Tokenex connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic TOKENEX_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Tokenex {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TOKENEX_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TOKENEX_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TOKENEX_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenex.rs"}, {"query": "Hyperswitch authentication request structure", "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is r\n\n... [truncated 33304 chars] ...\n\nment\n    #[schema(value_type = String)]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The list of session token object\n    pub session_token: Vec<AuthenticationSessionToken>,\n}\n\n#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, ToSchema)]\n#[serde(tag = \"wallet_name\")]\n#[serde(rename_all = \"snake_case\")]\npub enum AuthenticationSessionToken {\n    /// The sessions response structure for ClickToPay\n    ClickToPay(Box<ClickToPaySessionResponse>),\n    NoSessionTokenReceived,\n}\n\nimpl ApiEventMetric for AuthenticationSessionTokenRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Authentication {\n            authentication_id: self.authentication_id.clone(),\n        })\n    }\n}\n\nimpl ApiEventMetric for AuthenticationSessionResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Authentication {\n            authentication_id: self.authentication_id.clone(),\n        })\n    }\n}\n", "function_name": "crates__api_models__src__authentication.rs", "file": "crates__api_models__src__authentication.rs"}, {"query": "AuthenticationCreateRequest implementation", "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is r\n\n... [truncated 33304 chars] ...\n\nment\n    #[schema(value_type = String)]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The list of session token object\n    pub session_token: Vec<AuthenticationSessionToken>,\n}\n\n#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, ToSchema)]\n#[serde(tag = \"wallet_name\")]\n#[serde(rename_all = \"snake_case\")]\npub enum AuthenticationSessionToken {\n    /// The sessions response structure for ClickToPay\n    ClickToPay(Box<ClickToPaySessionResponse>),\n    NoSessionTokenReceived,\n}\n\nimpl ApiEventMetric for AuthenticationSessionTokenRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Authentication {\n            authentication_id: self.authentication_id.clone(),\n        })\n    }\n}\n\nimpl ApiEventMetric for AuthenticationSessionResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Authentication {\n            authentication_id: self.authentication_id.clone(),\n        })\n    }\n}\n", "function_name": "crates__api_models__src__authentication.rs", "file": "crates__api_models__src__authentication.rs"}, {"query": "how to handle 3DS challenge in Hyperswitch", "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is r\n\n... [truncated 33304 chars] ...\n\nment\n    #[schema(value_type = String)]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The list of session token object\n    pub session_token: Vec<AuthenticationSessionToken>,\n}\n\n#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, ToSchema)]\n#[serde(tag = \"wallet_name\")]\n#[serde(rename_all = \"snake_case\")]\npub enum AuthenticationSessionToken {\n    /// The sessions response structure for ClickToPay\n    ClickToPay(Box<ClickToPaySessionResponse>),\n    NoSessionTokenReceived,\n}\n\nimpl ApiEventMetric for AuthenticationSessionTokenRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Authentication {\n            authentication_id: self.authentication_id.clone(),\n        })\n    }\n}\n\nimpl ApiEventMetric for AuthenticationSessionResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Authentication {\n            authentication_id: self.authentication_id.clone(),\n        })\n    }\n}\n", "function_name": "crates__api_models__src__authentication.rs", "file": "crates__api_models__src__authentication.rs"}, {"query": "AuthenticationSessionToken enum definition", "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is r\n\n... [truncated 33304 chars] ...\n\nment\n    #[schema(value_type = String)]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The list of session token object\n    pub session_token: Vec<AuthenticationSessionToken>,\n}\n\n#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize, ToSchema)]\n#[serde(tag = \"wallet_name\")]\n#[serde(rename_all = \"snake_case\")]\npub enum AuthenticationSessionToken {\n    /// The sessions response structure for ClickToPay\n    ClickToPay(Box<ClickToPaySessionResponse>),\n    NoSessionTokenReceived,\n}\n\nimpl ApiEventMetric for AuthenticationSessionTokenRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Authentication {\n            authentication_id: self.authentication_id.clone(),\n        })\n    }\n}\n\nimpl ApiEventMetric for AuthenticationSessionResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Authentication {\n            authentication_id: self.authentication_id.clone(),\n        })\n    }\n}\n", "function_name": "crates__api_models__src__authentication.rs", "file": "crates__api_models__src__authentication.rs"}, {"query": "how to define payment method data model", "code": "use std::collections::HashMap;\n\nuse common_enums::MerchantStorageScheme;\nuse common_utils::{\n    encryption::Encryption,\n    errors::{CustomResult, ParsingError},\n    pii,\n};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse masking::ExposeInterface;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::{enums as storage_enums, schema::payment_methods};\n#[cfg(feature = \"v2\")]\nuse crate::{enums as storage_enums, schema_v2::payment_methods};\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Identifiable, Queryable, Selectable, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods, primary_key(payment_method_id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    #[diesel(deserialize_as = super::OptionalDieselArray<storage_enums::Currency>)]\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    #[diesel(deserialize_as = super::OptionalDieselArray<String>)]\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub payment_method_data: Option<Encryption>,\n\n\n... [truncated 54209 chars] ...\n\nse payments data\",\n                ))\n            })\n            .transpose()?;\n\n        let payouts_data = serde_json::from_value::<Option<Self>>(value)\n            .inspect_err(|err| {\n                router_env::logger::error!(\"Failed to parse payouts data: {}\", err);\n            })\n            .change_context(ParsingError::StructParseFailure(\n                \"Failed to parse payouts data\",\n            ))\n            .map(|optional_common_mandate_details| {\n                optional_common_mandate_details\n                    .and_then(|common_mandate_details| common_mandate_details.payouts)\n            })?;\n\n        Ok(Self {\n            payments: payments_data,\n            payouts: payouts_data,\n        })\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<PaymentsMandateReference> for CommonMandateReference {\n    fn from(payment_reference: PaymentsMandateReference) -> Self {\n        Self {\n            payments: Some(payment_reference),\n            payouts: None,\n        }\n    }\n}\n", "function_name": "crates__diesel_models__src__payment_method.rs", "file": "crates__diesel_models__src__payment_method.rs"}, {"query": "PaymentMethod struct diesel", "code": "use std::collections::HashMap;\n\nuse common_enums::MerchantStorageScheme;\nuse common_utils::{\n    encryption::Encryption,\n    errors::{CustomResult, ParsingError},\n    pii,\n};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse masking::ExposeInterface;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::{enums as storage_enums, schema::payment_methods};\n#[cfg(feature = \"v2\")]\nuse crate::{enums as storage_enums, schema_v2::payment_methods};\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Identifiable, Queryable, Selectable, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods, primary_key(payment_method_id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    #[diesel(deserialize_as = super::OptionalDieselArray<storage_enums::Currency>)]\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    #[diesel(deserialize_as = super::OptionalDieselArray<String>)]\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub payment_method_data: Option<Encryption>,\n\n\n... [truncated 54209 chars] ...\n\nse payments data\",\n                ))\n            })\n            .transpose()?;\n\n        let payouts_data = serde_json::from_value::<Option<Self>>(value)\n            .inspect_err(|err| {\n                router_env::logger::error!(\"Failed to parse payouts data: {}\", err);\n            })\n            .change_context(ParsingError::StructParseFailure(\n                \"Failed to parse payouts data\",\n            ))\n            .map(|optional_common_mandate_details| {\n                optional_common_mandate_details\n                    .and_then(|common_mandate_details| common_mandate_details.payouts)\n            })?;\n\n        Ok(Self {\n            payments: payments_data,\n            payouts: payouts_data,\n        })\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<PaymentsMandateReference> for CommonMandateReference {\n    fn from(payment_reference: PaymentsMandateReference) -> Self {\n        Self {\n            payments: Some(payment_reference),\n            payouts: None,\n        }\n    }\n}\n", "function_name": "crates__diesel_models__src__payment_method.rs", "file": "crates__diesel_models__src__payment_method.rs"}, {"query": "how to implement payment method storage", "code": "use std::collections::HashMap;\n\nuse common_enums::MerchantStorageScheme;\nuse common_utils::{\n    encryption::Encryption,\n    errors::{CustomResult, ParsingError},\n    pii,\n};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse masking::ExposeInterface;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::{enums as storage_enums, schema::payment_methods};\n#[cfg(feature = \"v2\")]\nuse crate::{enums as storage_enums, schema_v2::payment_methods};\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Identifiable, Queryable, Selectable, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods, primary_key(payment_method_id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    #[diesel(deserialize_as = super::OptionalDieselArray<storage_enums::Currency>)]\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    #[diesel(deserialize_as = super::OptionalDieselArray<String>)]\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub payment_method_data: Option<Encryption>,\n\n\n... [truncated 54209 chars] ...\n\nse payments data\",\n                ))\n            })\n            .transpose()?;\n\n        let payouts_data = serde_json::from_value::<Option<Self>>(value)\n            .inspect_err(|err| {\n                router_env::logger::error!(\"Failed to parse payouts data: {}\", err);\n            })\n            .change_context(ParsingError::StructParseFailure(\n                \"Failed to parse payouts data\",\n            ))\n            .map(|optional_common_mandate_details| {\n                optional_common_mandate_details\n                    .and_then(|common_mandate_details| common_mandate_details.payouts)\n            })?;\n\n        Ok(Self {\n            payments: payments_data,\n            payouts: payouts_data,\n        })\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<PaymentsMandateReference> for CommonMandateReference {\n    fn from(payment_reference: PaymentsMandateReference) -> Self {\n        Self {\n            payments: Some(payment_reference),\n            payouts: None,\n        }\n    }\n}\n", "function_name": "crates__diesel_models__src__payment_method.rs", "file": "crates__diesel_models__src__payment_method.rs"}, {"query": "diesel models payment method schema", "code": "use std::collections::HashMap;\n\nuse common_enums::MerchantStorageScheme;\nuse common_utils::{\n    encryption::Encryption,\n    errors::{CustomResult, ParsingError},\n    pii,\n};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse masking::ExposeInterface;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::{enums as storage_enums, schema::payment_methods};\n#[cfg(feature = \"v2\")]\nuse crate::{enums as storage_enums, schema_v2::payment_methods};\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Identifiable, Queryable, Selectable, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods, primary_key(payment_method_id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    #[diesel(deserialize_as = super::OptionalDieselArray<storage_enums::Currency>)]\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    #[diesel(deserialize_as = super::OptionalDieselArray<String>)]\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub payment_method_data: Option<Encryption>,\n\n\n... [truncated 54209 chars] ...\n\nse payments data\",\n                ))\n            })\n            .transpose()?;\n\n        let payouts_data = serde_json::from_value::<Option<Self>>(value)\n            .inspect_err(|err| {\n                router_env::logger::error!(\"Failed to parse payouts data: {}\", err);\n            })\n            .change_context(ParsingError::StructParseFailure(\n                \"Failed to parse payouts data\",\n            ))\n            .map(|optional_common_mandate_details| {\n                optional_common_mandate_details\n                    .and_then(|common_mandate_details| common_mandate_details.payouts)\n            })?;\n\n        Ok(Self {\n            payments: payments_data,\n            payouts: payouts_data,\n        })\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<PaymentsMandateReference> for CommonMandateReference {\n    fn from(payment_reference: PaymentsMandateReference) -> Self {\n        Self {\n            payments: Some(payment_reference),\n            payouts: None,\n        }\n    }\n}\n", "function_name": "crates__diesel_models__src__payment_method.rs", "file": "crates__diesel_models__src__payment_method.rs"}, {"query": "Worldpay Modular response transformation", "code": "use hyperswitch_domain_models::{router_request_types::*, router_response_types::*};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface as _, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::utils::ForeignTryFrom;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum RefundOutcome {\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub str\n\n... [truncated 10203 chars] ...\n\n  validation_errors: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularWebhookTransactionId {\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EventDetails {\n    pub transaction_reference: String,\n    #[serde(rename = \"type\")]\n    pub event_type: EventType,\n    pub reference: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularWebhookEventType {\n    pub event_id: String,\n    pub event_timestamp: String,\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub enum WorldpaymodularWebhookStatus {\n    SentForSettlement,\n    Authorized,\n    SentForAuthorization,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    SentForRefund,\n    RefundFailed,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs"}, {"query": "WorldpaymodularPaymentsResponse struct", "code": "use hyperswitch_domain_models::{router_request_types::*, router_response_types::*};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface as _, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::utils::ForeignTryFrom;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum RefundOutcome {\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub str\n\n... [truncated 10203 chars] ...\n\n  validation_errors: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularWebhookTransactionId {\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EventDetails {\n    pub transaction_reference: String,\n    #[serde(rename = \"type\")]\n    pub event_type: EventType,\n    pub reference: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularWebhookEventType {\n    pub event_id: String,\n    pub event_timestamp: String,\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub enum WorldpaymodularWebhookStatus {\n    SentForSettlement,\n    Authorized,\n    SentForAuthorization,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    SentForRefund,\n    RefundFailed,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs"}, {"query": "how to handle Worldpay webhook events", "code": "use hyperswitch_domain_models::{router_request_types::*, router_response_types::*};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface as _, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::utils::ForeignTryFrom;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum RefundOutcome {\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub str\n\n... [truncated 10203 chars] ...\n\n  validation_errors: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularWebhookTransactionId {\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EventDetails {\n    pub transaction_reference: String,\n    #[serde(rename = \"type\")]\n    pub event_type: EventType,\n    pub reference: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularWebhookEventType {\n    pub event_id: String,\n    pub event_timestamp: String,\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub enum WorldpaymodularWebhookStatus {\n    SentForSettlement,\n    Authorized,\n    SentForAuthorization,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    SentForRefund,\n    RefundFailed,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs"}, {"query": "Worldpay Modular API integration", "code": "use hyperswitch_domain_models::{router_request_types::*, router_response_types::*};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface as _, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::utils::ForeignTryFrom;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum RefundOutcome {\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub str\n\n... [truncated 10203 chars] ...\n\n  validation_errors: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularWebhookTransactionId {\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EventDetails {\n    pub transaction_reference: String,\n    #[serde(rename = \"type\")]\n    pub event_type: EventType,\n    pub reference: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularWebhookEventType {\n    pub event_id: String,\n    pub event_timestamp: String,\n    pub event_details: EventDetails,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub enum WorldpaymodularWebhookStatus {\n    SentForSettlement,\n    Authorized,\n    SentForAuthorization,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    SentForRefund,\n    RefundFailed,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs"}, {"query": "how to represent payment method data in hyperswitch", "code": "#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse api_models::{\n    mandates,\n    payment_methods::{self},\n    payments::{\n        additional_info as payment_additional_types, AdditionalNetworkTokenInfo, ExtendedCardInfo,\n    },\n};\nuse common_enums::{enums as api_enums, GooglePayCardFundingSource};\nuse common_utils::{\n    ext_traits::{OptionExt, StringExt},\n    id_type,\n    new_type::{\n        MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode, MaskedUpiVpaId,\n    },\n    payout_method_utils,\n    pii::{self, Email},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::Date;\n\nuse crate::router_data::PaymentMethodToken;\n\n// We need to derive Serialize and Deserialize because some parts of payment method data are being\n// stored in the database as serde_json::Value\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]\npub enum ExternalVaultPaymentMethodData {\n    Card(Box<ExternalVaultCard>),\n    VaultToken(VaultToken),\n}\n\n#[derive(Debug, Clone, serde::Serialize, ser\n\n... [truncated 142321 chars] ...\n\nd_and_card_details))\n            }\n            Self::NetworkTransactionIdAndNetworkTokenDetails(network_transaction_id_and_network_token_details) => {\n                Some(NetworkTokenDetailsForNetworkTransactionId::get_nti_and_network_token_details_for_mit_flow(*network_transaction_id_and_network_token_details))\n            }\n            Self::CardWithLimitedData(card_with_limited_data) => {\n                Some(CardWithLimitedDetails::get_card_details_for_mit_flow(*card_with_limited_data))\n            }\n            Self::NetworkTransactionIdAndDecryptedWalletTokenDetails(network_transaction_id_and_decrypted_wallet_token_details) => {\n                Some(DecryptedWalletTokenDetailsForNetworkTransactionId::get_nti_and_decrypted_wallet_token_details_for_mit_flow(*network_transaction_id_and_decrypted_wallet_token_details))\n            }\n            Self::PaymentMethodId(_)\n            | Self::MandateId(_)\n            | Self::ProcessorPaymentToken(_) => None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "file": "crates__hyperswitch_domain_models__src__payment_method_data.rs"}, {"query": "PaymentMethodData enum definition", "code": "#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse api_models::{\n    mandates,\n    payment_methods::{self},\n    payments::{\n        additional_info as payment_additional_types, AdditionalNetworkTokenInfo, ExtendedCardInfo,\n    },\n};\nuse common_enums::{enums as api_enums, GooglePayCardFundingSource};\nuse common_utils::{\n    ext_traits::{OptionExt, StringExt},\n    id_type,\n    new_type::{\n        MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode, MaskedUpiVpaId,\n    },\n    payout_method_utils,\n    pii::{self, Email},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::Date;\n\nuse crate::router_data::PaymentMethodToken;\n\n// We need to derive Serialize and Deserialize because some parts of payment method data are being\n// stored in the database as serde_json::Value\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]\npub enum ExternalVaultPaymentMethodData {\n    Card(Box<ExternalVaultCard>),\n    VaultToken(VaultToken),\n}\n\n#[derive(Debug, Clone, serde::Serialize, ser\n\n... [truncated 142321 chars] ...\n\nd_and_card_details))\n            }\n            Self::NetworkTransactionIdAndNetworkTokenDetails(network_transaction_id_and_network_token_details) => {\n                Some(NetworkTokenDetailsForNetworkTransactionId::get_nti_and_network_token_details_for_mit_flow(*network_transaction_id_and_network_token_details))\n            }\n            Self::CardWithLimitedData(card_with_limited_data) => {\n                Some(CardWithLimitedDetails::get_card_details_for_mit_flow(*card_with_limited_data))\n            }\n            Self::NetworkTransactionIdAndDecryptedWalletTokenDetails(network_transaction_id_and_decrypted_wallet_token_details) => {\n                Some(DecryptedWalletTokenDetailsForNetworkTransactionId::get_nti_and_decrypted_wallet_token_details_for_mit_flow(*network_transaction_id_and_decrypted_wallet_token_details))\n            }\n            Self::PaymentMethodId(_)\n            | Self::MandateId(_)\n            | Self::ProcessorPaymentToken(_) => None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "file": "crates__hyperswitch_domain_models__src__payment_method_data.rs"}, {"query": "how to convert card details for MIT flow", "code": "#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse api_models::{\n    mandates,\n    payment_methods::{self},\n    payments::{\n        additional_info as payment_additional_types, AdditionalNetworkTokenInfo, ExtendedCardInfo,\n    },\n};\nuse common_enums::{enums as api_enums, GooglePayCardFundingSource};\nuse common_utils::{\n    ext_traits::{OptionExt, StringExt},\n    id_type,\n    new_type::{\n        MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode, MaskedUpiVpaId,\n    },\n    payout_method_utils,\n    pii::{self, Email},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::Date;\n\nuse crate::router_data::PaymentMethodToken;\n\n// We need to derive Serialize and Deserialize because some parts of payment method data are being\n// stored in the database as serde_json::Value\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]\npub enum ExternalVaultPaymentMethodData {\n    Card(Box<ExternalVaultCard>),\n    VaultToken(VaultToken),\n}\n\n#[derive(Debug, Clone, serde::Serialize, ser\n\n... [truncated 142321 chars] ...\n\nd_and_card_details))\n            }\n            Self::NetworkTransactionIdAndNetworkTokenDetails(network_transaction_id_and_network_token_details) => {\n                Some(NetworkTokenDetailsForNetworkTransactionId::get_nti_and_network_token_details_for_mit_flow(*network_transaction_id_and_network_token_details))\n            }\n            Self::CardWithLimitedData(card_with_limited_data) => {\n                Some(CardWithLimitedDetails::get_card_details_for_mit_flow(*card_with_limited_data))\n            }\n            Self::NetworkTransactionIdAndDecryptedWalletTokenDetails(network_transaction_id_and_decrypted_wallet_token_details) => {\n                Some(DecryptedWalletTokenDetailsForNetworkTransactionId::get_nti_and_decrypted_wallet_token_details_for_mit_flow(*network_transaction_id_and_decrypted_wallet_token_details))\n            }\n            Self::PaymentMethodId(_)\n            | Self::MandateId(_)\n            | Self::ProcessorPaymentToken(_) => None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "file": "crates__hyperswitch_domain_models__src__payment_method_data.rs"}, {"query": "hyperswitch recurring payment details structure", "code": "#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse api_models::{\n    mandates,\n    payment_methods::{self},\n    payments::{\n        additional_info as payment_additional_types, AdditionalNetworkTokenInfo, ExtendedCardInfo,\n    },\n};\nuse common_enums::{enums as api_enums, GooglePayCardFundingSource};\nuse common_utils::{\n    ext_traits::{OptionExt, StringExt},\n    id_type,\n    new_type::{\n        MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode, MaskedUpiVpaId,\n    },\n    payout_method_utils,\n    pii::{self, Email},\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::Date;\n\nuse crate::router_data::PaymentMethodToken;\n\n// We need to derive Serialize and Deserialize because some parts of payment method data are being\n// stored in the database as serde_json::Value\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]\npub enum ExternalVaultPaymentMethodData {\n    Card(Box<ExternalVaultCard>),\n    VaultToken(VaultToken),\n}\n\n#[derive(Debug, Clone, serde::Serialize, ser\n\n... [truncated 142321 chars] ...\n\nd_and_card_details))\n            }\n            Self::NetworkTransactionIdAndNetworkTokenDetails(network_transaction_id_and_network_token_details) => {\n                Some(NetworkTokenDetailsForNetworkTransactionId::get_nti_and_network_token_details_for_mit_flow(*network_transaction_id_and_network_token_details))\n            }\n            Self::CardWithLimitedData(card_with_limited_data) => {\n                Some(CardWithLimitedDetails::get_card_details_for_mit_flow(*card_with_limited_data))\n            }\n            Self::NetworkTransactionIdAndDecryptedWalletTokenDetails(network_transaction_id_and_decrypted_wallet_token_details) => {\n                Some(DecryptedWalletTokenDetailsForNetworkTransactionId::get_nti_and_decrypted_wallet_token_details_for_mit_flow(*network_transaction_id_and_decrypted_wallet_token_details))\n            }\n            Self::PaymentMethodId(_)\n            | Self::MandateId(_)\n            | Self::ProcessorPaymentToken(_) => None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "file": "crates__hyperswitch_domain_models__src__payment_method_data.rs"}, {"query": "how to query payment metrics in hyperswitch", "code": "pub use analytics::*;\n\npub mod routes {\n    use std::{\n        collections::{HashMap, HashSet},\n        sync::Arc,\n    };\n\n    use actix_web::{web, Responder, Scope};\n    use analytics::{\n        api_event::api_events_core, connector_events::connector_events_core, enums::AuthInfo,\n        errors::AnalyticsError, lambda_utils::invoke_lambda, opensearch::OpenSearchError,\n        outgoing_webhook_event::outgoing_webhook_events_core, routing_events::routing_events_core,\n        sdk_events::sdk_events_core, AnalyticsFlow,\n    };\n    use api_models::analytics::{\n        api_event::QueryType,\n        search::{\n            GetGlobalSearchRequest, GetSearchRequest, GetSearchRequestWithIndex, SearchIndex,\n        },\n        AnalyticsRequest, GenerateReportRequest, GetActivePaymentsMetricRequest,\n        GetApiEventFiltersRequest, GetApiEventMetricRequest, GetAuthEventFilterRequest,\n        GetAuthEventMetricRequest, GetDisputeMetricRequest, GetFrmFilterRequest,\n        GetFrmMetricRequest, GetPaymentFiltersRequest, GetPaymentIntentFiltersRequest,\n        GetPaymentIntentMetricRequest, GetPaymentMetricRequest, GetRefundFilterRequest,\n        GetRefundMetricRequest, GetSdkEventFiltersRequest, GetSdkEventMetricRequest, ReportRequest,\n    };\n    use common_enums::EntityType;\n    use common_utils::types::TimeRange;\n    use error_stack::{report, ResultExt};\n    use futures::{stream::FuturesUnordered, StreamExt};\n\n    use crate::{\n        analytics_validator::request_validator,\n        consts::opensearch::SEARCH_INDEXES,\n        core::{api_locking, errors::user::UserErrors, verification::utils},\n        db::{user::UserInterface, user_role::ListUserRolesByUserIdPayload},\n        routes::AppState,\n        services::{\n            api,\n            authentication::{self as auth, AuthenticationData, UserFromToken},\n            authorization::{permissions::Permission, roles::RoleInfo},\n            ApplicationResponse,\n        },\n        types::{domain::UserEmail, storage::UserRole},\n    };\n\n    pub \n\n... [truncated 140104 chars] ...\n\net_account().get_org_id();\n                let merchant_id = auth.platform.get_processor().get_account().get_id();\n                let profile_id = auth\n                    .profile\n                    .ok_or(report!(UserErrors::JwtProfileIdMissing))\n                    .change_context(AnalyticsError::AccessForbiddenError)?\n                    .get_id()\n                    .clone();\n                let auth: AuthInfo = AuthInfo::ProfileLevel {\n                    org_id: org_id.clone(),\n                    merchant_id: merchant_id.clone(),\n                    profile_ids: vec![profile_id.clone()],\n                };\n                analytics::payment_intents::get_sankey(&state.pool, &auth, req)\n                    .await\n                    .map(ApplicationResponse::Json)\n            },\n            &auth::JWTAuth {\n                permission: Permission::ProfileAnalyticsRead,\n            },\n            api_locking::LockAction::NotApplicable,\n        ))\n        .await\n    }\n}\n", "function_name": "crates__router__src__analytics.rs", "file": "crates__router__src__analytics.rs"}, {"query": "analytics API route definitions", "code": "pub use analytics::*;\n\npub mod routes {\n    use std::{\n        collections::{HashMap, HashSet},\n        sync::Arc,\n    };\n\n    use actix_web::{web, Responder, Scope};\n    use analytics::{\n        api_event::api_events_core, connector_events::connector_events_core, enums::AuthInfo,\n        errors::AnalyticsError, lambda_utils::invoke_lambda, opensearch::OpenSearchError,\n        outgoing_webhook_event::outgoing_webhook_events_core, routing_events::routing_events_core,\n        sdk_events::sdk_events_core, AnalyticsFlow,\n    };\n    use api_models::analytics::{\n        api_event::QueryType,\n        search::{\n            GetGlobalSearchRequest, GetSearchRequest, GetSearchRequestWithIndex, SearchIndex,\n        },\n        AnalyticsRequest, GenerateReportRequest, GetActivePaymentsMetricRequest,\n        GetApiEventFiltersRequest, GetApiEventMetricRequest, GetAuthEventFilterRequest,\n        GetAuthEventMetricRequest, GetDisputeMetricRequest, GetFrmFilterRequest,\n        GetFrmMetricRequest, GetPaymentFiltersRequest, GetPaymentIntentFiltersRequest,\n        GetPaymentIntentMetricRequest, GetPaymentMetricRequest, GetRefundFilterRequest,\n        GetRefundMetricRequest, GetSdkEventFiltersRequest, GetSdkEventMetricRequest, ReportRequest,\n    };\n    use common_enums::EntityType;\n    use common_utils::types::TimeRange;\n    use error_stack::{report, ResultExt};\n    use futures::{stream::FuturesUnordered, StreamExt};\n\n    use crate::{\n        analytics_validator::request_validator,\n        consts::opensearch::SEARCH_INDEXES,\n        core::{api_locking, errors::user::UserErrors, verification::utils},\n        db::{user::UserInterface, user_role::ListUserRolesByUserIdPayload},\n        routes::AppState,\n        services::{\n            api,\n            authentication::{self as auth, AuthenticationData, UserFromToken},\n            authorization::{permissions::Permission, roles::RoleInfo},\n            ApplicationResponse,\n        },\n        types::{domain::UserEmail, storage::UserRole},\n    };\n\n    pub \n\n... [truncated 140104 chars] ...\n\net_account().get_org_id();\n                let merchant_id = auth.platform.get_processor().get_account().get_id();\n                let profile_id = auth\n                    .profile\n                    .ok_or(report!(UserErrors::JwtProfileIdMissing))\n                    .change_context(AnalyticsError::AccessForbiddenError)?\n                    .get_id()\n                    .clone();\n                let auth: AuthInfo = AuthInfo::ProfileLevel {\n                    org_id: org_id.clone(),\n                    merchant_id: merchant_id.clone(),\n                    profile_ids: vec![profile_id.clone()],\n                };\n                analytics::payment_intents::get_sankey(&state.pool, &auth, req)\n                    .await\n                    .map(ApplicationResponse::Json)\n            },\n            &auth::JWTAuth {\n                permission: Permission::ProfileAnalyticsRead,\n            },\n            api_locking::LockAction::NotApplicable,\n        ))\n        .await\n    }\n}\n", "function_name": "crates__router__src__analytics.rs", "file": "crates__router__src__analytics.rs"}, {"query": "get_merchant_payment_metrics function", "code": "pub use analytics::*;\n\npub mod routes {\n    use std::{\n        collections::{HashMap, HashSet},\n        sync::Arc,\n    };\n\n    use actix_web::{web, Responder, Scope};\n    use analytics::{\n        api_event::api_events_core, connector_events::connector_events_core, enums::AuthInfo,\n        errors::AnalyticsError, lambda_utils::invoke_lambda, opensearch::OpenSearchError,\n        outgoing_webhook_event::outgoing_webhook_events_core, routing_events::routing_events_core,\n        sdk_events::sdk_events_core, AnalyticsFlow,\n    };\n    use api_models::analytics::{\n        api_event::QueryType,\n        search::{\n            GetGlobalSearchRequest, GetSearchRequest, GetSearchRequestWithIndex, SearchIndex,\n        },\n        AnalyticsRequest, GenerateReportRequest, GetActivePaymentsMetricRequest,\n        GetApiEventFiltersRequest, GetApiEventMetricRequest, GetAuthEventFilterRequest,\n        GetAuthEventMetricRequest, GetDisputeMetricRequest, GetFrmFilterRequest,\n        GetFrmMetricRequest, GetPaymentFiltersRequest, GetPaymentIntentFiltersRequest,\n        GetPaymentIntentMetricRequest, GetPaymentMetricRequest, GetRefundFilterRequest,\n        GetRefundMetricRequest, GetSdkEventFiltersRequest, GetSdkEventMetricRequest, ReportRequest,\n    };\n    use common_enums::EntityType;\n    use common_utils::types::TimeRange;\n    use error_stack::{report, ResultExt};\n    use futures::{stream::FuturesUnordered, StreamExt};\n\n    use crate::{\n        analytics_validator::request_validator,\n        consts::opensearch::SEARCH_INDEXES,\n        core::{api_locking, errors::user::UserErrors, verification::utils},\n        db::{user::UserInterface, user_role::ListUserRolesByUserIdPayload},\n        routes::AppState,\n        services::{\n            api,\n            authentication::{self as auth, AuthenticationData, UserFromToken},\n            authorization::{permissions::Permission, roles::RoleInfo},\n            ApplicationResponse,\n        },\n        types::{domain::UserEmail, storage::UserRole},\n    };\n\n    pub \n\n... [truncated 140104 chars] ...\n\net_account().get_org_id();\n                let merchant_id = auth.platform.get_processor().get_account().get_id();\n                let profile_id = auth\n                    .profile\n                    .ok_or(report!(UserErrors::JwtProfileIdMissing))\n                    .change_context(AnalyticsError::AccessForbiddenError)?\n                    .get_id()\n                    .clone();\n                let auth: AuthInfo = AuthInfo::ProfileLevel {\n                    org_id: org_id.clone(),\n                    merchant_id: merchant_id.clone(),\n                    profile_ids: vec![profile_id.clone()],\n                };\n                analytics::payment_intents::get_sankey(&state.pool, &auth, req)\n                    .await\n                    .map(ApplicationResponse::Json)\n            },\n            &auth::JWTAuth {\n                permission: Permission::ProfileAnalyticsRead,\n            },\n            api_locking::LockAction::NotApplicable,\n        ))\n        .await\n    }\n}\n", "function_name": "crates__router__src__analytics.rs", "file": "crates__router__src__analytics.rs"}, {"query": "OpenSearch analytics integration hyperswitch", "code": "pub use analytics::*;\n\npub mod routes {\n    use std::{\n        collections::{HashMap, HashSet},\n        sync::Arc,\n    };\n\n    use actix_web::{web, Responder, Scope};\n    use analytics::{\n        api_event::api_events_core, connector_events::connector_events_core, enums::AuthInfo,\n        errors::AnalyticsError, lambda_utils::invoke_lambda, opensearch::OpenSearchError,\n        outgoing_webhook_event::outgoing_webhook_events_core, routing_events::routing_events_core,\n        sdk_events::sdk_events_core, AnalyticsFlow,\n    };\n    use api_models::analytics::{\n        api_event::QueryType,\n        search::{\n            GetGlobalSearchRequest, GetSearchRequest, GetSearchRequestWithIndex, SearchIndex,\n        },\n        AnalyticsRequest, GenerateReportRequest, GetActivePaymentsMetricRequest,\n        GetApiEventFiltersRequest, GetApiEventMetricRequest, GetAuthEventFilterRequest,\n        GetAuthEventMetricRequest, GetDisputeMetricRequest, GetFrmFilterRequest,\n        GetFrmMetricRequest, GetPaymentFiltersRequest, GetPaymentIntentFiltersRequest,\n        GetPaymentIntentMetricRequest, GetPaymentMetricRequest, GetRefundFilterRequest,\n        GetRefundMetricRequest, GetSdkEventFiltersRequest, GetSdkEventMetricRequest, ReportRequest,\n    };\n    use common_enums::EntityType;\n    use common_utils::types::TimeRange;\n    use error_stack::{report, ResultExt};\n    use futures::{stream::FuturesUnordered, StreamExt};\n\n    use crate::{\n        analytics_validator::request_validator,\n        consts::opensearch::SEARCH_INDEXES,\n        core::{api_locking, errors::user::UserErrors, verification::utils},\n        db::{user::UserInterface, user_role::ListUserRolesByUserIdPayload},\n        routes::AppState,\n        services::{\n            api,\n            authentication::{self as auth, AuthenticationData, UserFromToken},\n            authorization::{permissions::Permission, roles::RoleInfo},\n            ApplicationResponse,\n        },\n        types::{domain::UserEmail, storage::UserRole},\n    };\n\n    pub \n\n... [truncated 140104 chars] ...\n\net_account().get_org_id();\n                let merchant_id = auth.platform.get_processor().get_account().get_id();\n                let profile_id = auth\n                    .profile\n                    .ok_or(report!(UserErrors::JwtProfileIdMissing))\n                    .change_context(AnalyticsError::AccessForbiddenError)?\n                    .get_id()\n                    .clone();\n                let auth: AuthInfo = AuthInfo::ProfileLevel {\n                    org_id: org_id.clone(),\n                    merchant_id: merchant_id.clone(),\n                    profile_ids: vec![profile_id.clone()],\n                };\n                analytics::payment_intents::get_sankey(&state.pool, &auth, req)\n                    .await\n                    .map(ApplicationResponse::Json)\n            },\n            &auth::JWTAuth {\n                permission: Permission::ProfileAnalyticsRead,\n            },\n            api_locking::LockAction::NotApplicable,\n        ))\n        .await\n    }\n}\n", "function_name": "crates__router__src__analytics.rs", "file": "crates__router__src__analytics.rs"}, {"query": "Datatrans payment gateway integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as datatrans;\n\nuse crate::{\n    constants::headers,\n    types::ResponseR\n\n... [truncated 29057 chars] ...\n\nANS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Datatrans\",\n    description:\n        \"Datatrans is a payment gateway that facilitates the processing of payments, including hosting smart payment forms and correctly routing payment information.\",\n    connector_type: common_enums::enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic DATATRANS_SUPPORTED_WEBHOOK_FLOWS: [common_enums::enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Datatrans {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DATATRANS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DATATRANS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        Some(&DATATRANS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__datatrans.rs", "file": "crates__hyperswitch_connectors__src__connectors__datatrans.rs"}, {"query": "Datatrans connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as datatrans;\n\nuse crate::{\n    constants::headers,\n    types::ResponseR\n\n... [truncated 29057 chars] ...\n\nANS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Datatrans\",\n    description:\n        \"Datatrans is a payment gateway that facilitates the processing of payments, including hosting smart payment forms and correctly routing payment information.\",\n    connector_type: common_enums::enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic DATATRANS_SUPPORTED_WEBHOOK_FLOWS: [common_enums::enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Datatrans {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DATATRANS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DATATRANS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        Some(&DATATRANS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__datatrans.rs", "file": "crates__hyperswitch_connectors__src__connectors__datatrans.rs"}, {"query": "how to process card payments with Datatrans", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as datatrans;\n\nuse crate::{\n    constants::headers,\n    types::ResponseR\n\n... [truncated 29057 chars] ...\n\nANS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Datatrans\",\n    description:\n        \"Datatrans is a payment gateway that facilitates the processing of payments, including hosting smart payment forms and correctly routing payment information.\",\n    connector_type: common_enums::enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic DATATRANS_SUPPORTED_WEBHOOK_FLOWS: [common_enums::enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Datatrans {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DATATRANS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DATATRANS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        Some(&DATATRANS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__datatrans.rs", "file": "crates__hyperswitch_connectors__src__connectors__datatrans.rs"}, {"query": "Datatrans API request mapping", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as datatrans;\n\nuse crate::{\n    constants::headers,\n    types::ResponseR\n\n... [truncated 29057 chars] ...\n\nANS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Datatrans\",\n    description:\n        \"Datatrans is a payment gateway that facilitates the processing of payments, including hosting smart payment forms and correctly routing payment information.\",\n    connector_type: common_enums::enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic DATATRANS_SUPPORTED_WEBHOOK_FLOWS: [common_enums::enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Datatrans {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DATATRANS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DATATRANS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        Some(&DATATRANS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__datatrans.rs", "file": "crates__hyperswitch_connectors__src__connectors__datatrans.rs"}, {"query": "hyperswitch opennode connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks::{self, IncomingWebhook},\n};\nuse masking::{Mask, Maskable};\nuse transformers as opennode;\n\nuse self::opennode::OpennodeWebhookDetails;\nuse crate::{\n    connectors::opennode::transformers::OpennodeRouterData, constants::headers,\n    types::ResponseRouterData, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Opennode {\n    amount_convertor: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Opennode {\n    pub fn new() -> &'stati\n\n... [truncated 14796 chars] ...\n\neatures: None,\n            },\n        );\n\n        opennode_supported_payment_methods\n    });\n\nstatic OPENNODE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Opennode\",\n    description:\n        \"OpenNode offers accessible way for e-commerce businesses to process bitcoin payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic OPENNODE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Opennode {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&OPENNODE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*OPENNODE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&OPENNODE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__opennode.rs", "file": "crates__hyperswitch_connectors__src__connectors__opennode.rs"}, {"query": "Opennode struct definition", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks::{self, IncomingWebhook},\n};\nuse masking::{Mask, Maskable};\nuse transformers as opennode;\n\nuse self::opennode::OpennodeWebhookDetails;\nuse crate::{\n    connectors::opennode::transformers::OpennodeRouterData, constants::headers,\n    types::ResponseRouterData, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Opennode {\n    amount_convertor: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Opennode {\n    pub fn new() -> &'stati\n\n... [truncated 14796 chars] ...\n\neatures: None,\n            },\n        );\n\n        opennode_supported_payment_methods\n    });\n\nstatic OPENNODE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Opennode\",\n    description:\n        \"OpenNode offers accessible way for e-commerce businesses to process bitcoin payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic OPENNODE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Opennode {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&OPENNODE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*OPENNODE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&OPENNODE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__opennode.rs", "file": "crates__hyperswitch_connectors__src__connectors__opennode.rs"}, {"query": "how to integrate crypto payments with hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks::{self, IncomingWebhook},\n};\nuse masking::{Mask, Maskable};\nuse transformers as opennode;\n\nuse self::opennode::OpennodeWebhookDetails;\nuse crate::{\n    connectors::opennode::transformers::OpennodeRouterData, constants::headers,\n    types::ResponseRouterData, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Opennode {\n    amount_convertor: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Opennode {\n    pub fn new() -> &'stati\n\n... [truncated 14796 chars] ...\n\neatures: None,\n            },\n        );\n\n        opennode_supported_payment_methods\n    });\n\nstatic OPENNODE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Opennode\",\n    description:\n        \"OpenNode offers accessible way for e-commerce businesses to process bitcoin payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic OPENNODE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Opennode {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&OPENNODE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*OPENNODE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&OPENNODE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__opennode.rs", "file": "crates__hyperswitch_connectors__src__connectors__opennode.rs"}, {"query": "hyperswitch opennode payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks::{self, IncomingWebhook},\n};\nuse masking::{Mask, Maskable};\nuse transformers as opennode;\n\nuse self::opennode::OpennodeWebhookDetails;\nuse crate::{\n    connectors::opennode::transformers::OpennodeRouterData, constants::headers,\n    types::ResponseRouterData, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Opennode {\n    amount_convertor: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Opennode {\n    pub fn new() -> &'stati\n\n... [truncated 14796 chars] ...\n\neatures: None,\n            },\n        );\n\n        opennode_supported_payment_methods\n    });\n\nstatic OPENNODE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Opennode\",\n    description:\n        \"OpenNode offers accessible way for e-commerce businesses to process bitcoin payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic OPENNODE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Opennode {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&OPENNODE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*OPENNODE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&OPENNODE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__opennode.rs", "file": "crates__hyperswitch_connectors__src__connectors__opennode.rs"}, {"query": "PayJustNow In-Store connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse transformers as payjustnowinstore;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst PAYJUSTNOWINSTORE_MERCHANT_TERMINAL_ID: &str = \"X-PayJustNow-Merchant-Terminal-ID\";\nconst SIGNATURE: &str = \"X-Signature\";\nconst MERCHANT_REFERENCE_NON_UNIQUE: &str = \"X-Merchant-Reference-Non-Unique\";\n\n#[derive(Clone)]\npub struct P\n\n... [truncated 21570 chars] ...\n\nInfo = ConnectorInfo {\n    display_name: \"PayJustNow In-Store\",\n    description: \"PayJustNow provides a BNPL solution for online and in-store payments, enabling customers to pay in three interest-free installments while merchants get paid upfront.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYJUSTNOWINSTORE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Payjustnowinstore {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYJUSTNOWINSTORE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYJUSTNOWINSTORE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYJUSTNOWINSTORE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs"}, {"query": "hyperswitch payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse transformers as payjustnowinstore;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst PAYJUSTNOWINSTORE_MERCHANT_TERMINAL_ID: &str = \"X-PayJustNow-Merchant-Terminal-ID\";\nconst SIGNATURE: &str = \"X-Signature\";\nconst MERCHANT_REFERENCE_NON_UNIQUE: &str = \"X-Merchant-Reference-Non-Unique\";\n\n#[derive(Clone)]\npub struct P\n\n... [truncated 21570 chars] ...\n\nInfo = ConnectorInfo {\n    display_name: \"PayJustNow In-Store\",\n    description: \"PayJustNow provides a BNPL solution for online and in-store payments, enabling customers to pay in three interest-free installments while merchants get paid upfront.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYJUSTNOWINSTORE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Payjustnowinstore {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYJUSTNOWINSTORE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYJUSTNOWINSTORE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYJUSTNOWINSTORE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs"}, {"query": "how to add new payment connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse transformers as payjustnowinstore;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst PAYJUSTNOWINSTORE_MERCHANT_TERMINAL_ID: &str = \"X-PayJustNow-Merchant-Terminal-ID\";\nconst SIGNATURE: &str = \"X-Signature\";\nconst MERCHANT_REFERENCE_NON_UNIQUE: &str = \"X-Merchant-Reference-Non-Unique\";\n\n#[derive(Clone)]\npub struct P\n\n... [truncated 21570 chars] ...\n\nInfo = ConnectorInfo {\n    display_name: \"PayJustNow In-Store\",\n    description: \"PayJustNow provides a BNPL solution for online and in-store payments, enabling customers to pay in three interest-free installments while merchants get paid upfront.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYJUSTNOWINSTORE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Payjustnowinstore {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYJUSTNOWINSTORE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYJUSTNOWINSTORE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYJUSTNOWINSTORE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs"}, {"query": "PayJustNow BNPL payment method", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse transformers as payjustnowinstore;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst PAYJUSTNOWINSTORE_MERCHANT_TERMINAL_ID: &str = \"X-PayJustNow-Merchant-Terminal-ID\";\nconst SIGNATURE: &str = \"X-Signature\";\nconst MERCHANT_REFERENCE_NON_UNIQUE: &str = \"X-Merchant-Reference-Non-Unique\";\n\n#[derive(Clone)]\npub struct P\n\n... [truncated 21570 chars] ...\n\nInfo = ConnectorInfo {\n    display_name: \"PayJustNow In-Store\",\n    description: \"PayJustNow provides a BNPL solution for online and in-store payments, enabling customers to pay in three interest-free installments while merchants get paid upfront.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PAYJUSTNOWINSTORE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Payjustnowinstore {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYJUSTNOWINSTORE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYJUSTNOWINSTORE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYJUSTNOWINSTORE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs", "file": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs"}, {"query": "Adyen payout webhook status mapping", "code": "use api_models::{payouts, webhooks};\nuse common_enums::enums;\nuse common_utils::pii;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::types::{self, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse super::{AdyenPlatformRouterData, Error};\nuse crate::{\n    connectors::adyen::transformers as adyen,\n    types::PayoutsResponseRouterData,\n    utils::{\n        self, AdditionalPayoutMethodData as _, AddressDetailsData, CardData,\n        PayoutFulfillRequestData, PayoutsData as _, RouterData as _,\n    },\n};\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct AdyenPlatformConnectorMetadataObject {\n    source_balance_account: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for AdyenPlatformConnectorMetadataObject {\n    type Error = Error;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(ConnectorError::InvalidConnectorConfig { config: \"metadata\" })?;\n        Ok(metadata)\n    }\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferRequest {\n    amount: adyen::Amount,\n    balance_account_id: Secret<String>,\n    category: AdyenPayoutMethod,\n    counterparty: AdyenPayoutMethodDetails,\n    priority: Option<AdyenPayoutPriority>,\n    reference: String,\n    reference_for_beneficiary: String,\n    description: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethod {\n    Bank,\n    Card,\n    PlatformPayment,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethodDetails {\n    BankAccount(AdyenBankAccountDetails),\n    Card(AdyenCardDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(ren\n\n... [truncated 25494 chars] ...\n\n:PayoutCreated\n            }\n            AdyenplatformWebhookStatus::Booked | AdyenplatformWebhookStatus::Pending => {\n                webhooks::IncomingWebhookEvent::PayoutProcessing\n            }\n            AdyenplatformWebhookStatus::Failed => webhooks::IncomingWebhookEvent::PayoutFailure,\n            AdyenplatformWebhookStatus::Returned => webhooks::IncomingWebhookEvent::PayoutReversed,\n        },\n    }\n}\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferErrorResponse {\n    pub error_code: String,\n    #[serde(rename = \"type\")]\n    pub error_type: String,\n    pub status: u16,\n    pub title: String,\n    pub detail: Option<String>,\n    pub request_id: Option<String>,\n    pub invalid_fields: Option<Vec<AdyenInvalidField>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenInvalidField {\n    pub name: Option<String>,\n    pub value: Option<String>,\n    pub message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs"}, {"query": "AdyenTransferRequest struct definition", "code": "use api_models::{payouts, webhooks};\nuse common_enums::enums;\nuse common_utils::pii;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::types::{self, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse super::{AdyenPlatformRouterData, Error};\nuse crate::{\n    connectors::adyen::transformers as adyen,\n    types::PayoutsResponseRouterData,\n    utils::{\n        self, AdditionalPayoutMethodData as _, AddressDetailsData, CardData,\n        PayoutFulfillRequestData, PayoutsData as _, RouterData as _,\n    },\n};\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct AdyenPlatformConnectorMetadataObject {\n    source_balance_account: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for AdyenPlatformConnectorMetadataObject {\n    type Error = Error;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(ConnectorError::InvalidConnectorConfig { config: \"metadata\" })?;\n        Ok(metadata)\n    }\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferRequest {\n    amount: adyen::Amount,\n    balance_account_id: Secret<String>,\n    category: AdyenPayoutMethod,\n    counterparty: AdyenPayoutMethodDetails,\n    priority: Option<AdyenPayoutPriority>,\n    reference: String,\n    reference_for_beneficiary: String,\n    description: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethod {\n    Bank,\n    Card,\n    PlatformPayment,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethodDetails {\n    BankAccount(AdyenBankAccountDetails),\n    Card(AdyenCardDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(ren\n\n... [truncated 25494 chars] ...\n\n:PayoutCreated\n            }\n            AdyenplatformWebhookStatus::Booked | AdyenplatformWebhookStatus::Pending => {\n                webhooks::IncomingWebhookEvent::PayoutProcessing\n            }\n            AdyenplatformWebhookStatus::Failed => webhooks::IncomingWebhookEvent::PayoutFailure,\n            AdyenplatformWebhookStatus::Returned => webhooks::IncomingWebhookEvent::PayoutReversed,\n        },\n    }\n}\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferErrorResponse {\n    pub error_code: String,\n    #[serde(rename = \"type\")]\n    pub error_type: String,\n    pub status: u16,\n    pub title: String,\n    pub detail: Option<String>,\n    pub request_id: Option<String>,\n    pub invalid_fields: Option<Vec<AdyenInvalidField>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenInvalidField {\n    pub name: Option<String>,\n    pub value: Option<String>,\n    pub message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs"}, {"query": "how to handle Adyen payout failures", "code": "use api_models::{payouts, webhooks};\nuse common_enums::enums;\nuse common_utils::pii;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::types::{self, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse super::{AdyenPlatformRouterData, Error};\nuse crate::{\n    connectors::adyen::transformers as adyen,\n    types::PayoutsResponseRouterData,\n    utils::{\n        self, AdditionalPayoutMethodData as _, AddressDetailsData, CardData,\n        PayoutFulfillRequestData, PayoutsData as _, RouterData as _,\n    },\n};\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct AdyenPlatformConnectorMetadataObject {\n    source_balance_account: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for AdyenPlatformConnectorMetadataObject {\n    type Error = Error;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(ConnectorError::InvalidConnectorConfig { config: \"metadata\" })?;\n        Ok(metadata)\n    }\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferRequest {\n    amount: adyen::Amount,\n    balance_account_id: Secret<String>,\n    category: AdyenPayoutMethod,\n    counterparty: AdyenPayoutMethodDetails,\n    priority: Option<AdyenPayoutPriority>,\n    reference: String,\n    reference_for_beneficiary: String,\n    description: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethod {\n    Bank,\n    Card,\n    PlatformPayment,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethodDetails {\n    BankAccount(AdyenBankAccountDetails),\n    Card(AdyenCardDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(ren\n\n... [truncated 25494 chars] ...\n\n:PayoutCreated\n            }\n            AdyenplatformWebhookStatus::Booked | AdyenplatformWebhookStatus::Pending => {\n                webhooks::IncomingWebhookEvent::PayoutProcessing\n            }\n            AdyenplatformWebhookStatus::Failed => webhooks::IncomingWebhookEvent::PayoutFailure,\n            AdyenplatformWebhookStatus::Returned => webhooks::IncomingWebhookEvent::PayoutReversed,\n        },\n    }\n}\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferErrorResponse {\n    pub error_code: String,\n    #[serde(rename = \"type\")]\n    pub error_type: String,\n    pub status: u16,\n    pub title: String,\n    pub detail: Option<String>,\n    pub request_id: Option<String>,\n    pub invalid_fields: Option<Vec<AdyenInvalidField>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenInvalidField {\n    pub name: Option<String>,\n    pub value: Option<String>,\n    pub message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs"}, {"query": "Adyen platform payout transformer", "code": "use api_models::{payouts, webhooks};\nuse common_enums::enums;\nuse common_utils::pii;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::types::{self, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse super::{AdyenPlatformRouterData, Error};\nuse crate::{\n    connectors::adyen::transformers as adyen,\n    types::PayoutsResponseRouterData,\n    utils::{\n        self, AdditionalPayoutMethodData as _, AddressDetailsData, CardData,\n        PayoutFulfillRequestData, PayoutsData as _, RouterData as _,\n    },\n};\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct AdyenPlatformConnectorMetadataObject {\n    source_balance_account: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for AdyenPlatformConnectorMetadataObject {\n    type Error = Error;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(ConnectorError::InvalidConnectorConfig { config: \"metadata\" })?;\n        Ok(metadata)\n    }\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferRequest {\n    amount: adyen::Amount,\n    balance_account_id: Secret<String>,\n    category: AdyenPayoutMethod,\n    counterparty: AdyenPayoutMethodDetails,\n    priority: Option<AdyenPayoutPriority>,\n    reference: String,\n    reference_for_beneficiary: String,\n    description: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethod {\n    Bank,\n    Card,\n    PlatformPayment,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethodDetails {\n    BankAccount(AdyenBankAccountDetails),\n    Card(AdyenCardDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(ren\n\n... [truncated 25494 chars] ...\n\n:PayoutCreated\n            }\n            AdyenplatformWebhookStatus::Booked | AdyenplatformWebhookStatus::Pending => {\n                webhooks::IncomingWebhookEvent::PayoutProcessing\n            }\n            AdyenplatformWebhookStatus::Failed => webhooks::IncomingWebhookEvent::PayoutFailure,\n            AdyenplatformWebhookStatus::Returned => webhooks::IncomingWebhookEvent::PayoutReversed,\n        },\n    }\n}\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferErrorResponse {\n    pub error_code: String,\n    #[serde(rename = \"type\")]\n    pub error_type: String,\n    pub status: u16,\n    pub title: String,\n    pub detail: Option<String>,\n    pub request_id: Option<String>,\n    pub invalid_fields: Option<Vec<AdyenInvalidField>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenInvalidField {\n    pub name: Option<String>,\n    pub value: Option<String>,\n    pub message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs"}, {"query": "Getnet payment connector integration", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus, CaptureMethod, CountryAlpha2};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::ConnectorAuthType,\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    connectors::paybox::transformers::parse_url_encoded_to_struct,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        BrowserInformationData, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\npub struct GetnetRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GetnetRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Amount {\n    pub value: FloatMajorUnit,\n    pub currency: enums::Currency,\n}\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Address {\n    #[serde(rename = \"street1\")]\n    pub street1: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[d\n\n... [truncated 39950 chars] ...\n\n GetnetPaymentStatus::Success => IncomingWebhookEvent::RefundSuccess,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::RefundFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::RefundFailure,\n        },\n\n        GetnetTransactionType::VoidAuthorization => match transaction_status {\n            GetnetPaymentStatus::Success => IncomingWebhookEvent::PaymentIntentCancelled,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::PaymentIntentCancelFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::PaymentIntentCancelFailure,\n        },\n\n        GetnetTransactionType::VoidPurchase => match transaction_status {\n            GetnetPaymentStatus::Success => IncomingWebhookEvent::PaymentIntentCancelled,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::PaymentIntentCancelFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::PaymentIntentCancelFailure,\n        },\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs"}, {"query": "Getnet webhook status mapping", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus, CaptureMethod, CountryAlpha2};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::ConnectorAuthType,\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    connectors::paybox::transformers::parse_url_encoded_to_struct,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        BrowserInformationData, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\npub struct GetnetRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GetnetRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Amount {\n    pub value: FloatMajorUnit,\n    pub currency: enums::Currency,\n}\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Address {\n    #[serde(rename = \"street1\")]\n    pub street1: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[d\n\n... [truncated 39950 chars] ...\n\n GetnetPaymentStatus::Success => IncomingWebhookEvent::RefundSuccess,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::RefundFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::RefundFailure,\n        },\n\n        GetnetTransactionType::VoidAuthorization => match transaction_status {\n            GetnetPaymentStatus::Success => IncomingWebhookEvent::PaymentIntentCancelled,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::PaymentIntentCancelFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::PaymentIntentCancelFailure,\n        },\n\n        GetnetTransactionType::VoidPurchase => match transaction_status {\n            GetnetPaymentStatus::Success => IncomingWebhookEvent::PaymentIntentCancelled,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::PaymentIntentCancelFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::PaymentIntentCancelFailure,\n        },\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs"}, {"query": "transform Getnet payment request", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus, CaptureMethod, CountryAlpha2};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::ConnectorAuthType,\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    connectors::paybox::transformers::parse_url_encoded_to_struct,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        BrowserInformationData, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\npub struct GetnetRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GetnetRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Amount {\n    pub value: FloatMajorUnit,\n    pub currency: enums::Currency,\n}\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Address {\n    #[serde(rename = \"street1\")]\n    pub street1: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[d\n\n... [truncated 39950 chars] ...\n\n GetnetPaymentStatus::Success => IncomingWebhookEvent::RefundSuccess,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::RefundFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::RefundFailure,\n        },\n\n        GetnetTransactionType::VoidAuthorization => match transaction_status {\n            GetnetPaymentStatus::Success => IncomingWebhookEvent::PaymentIntentCancelled,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::PaymentIntentCancelFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::PaymentIntentCancelFailure,\n        },\n\n        GetnetTransactionType::VoidPurchase => match transaction_status {\n            GetnetPaymentStatus::Success => IncomingWebhookEvent::PaymentIntentCancelled,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::PaymentIntentCancelFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::PaymentIntentCancelFailure,\n        },\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs"}, {"query": "Getnet transaction status enum", "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus, CaptureMethod, CountryAlpha2};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::ConnectorAuthType,\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    connectors::paybox::transformers::parse_url_encoded_to_struct,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        BrowserInformationData, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\npub struct GetnetRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GetnetRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Amount {\n    pub value: FloatMajorUnit,\n    pub currency: enums::Currency,\n}\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Address {\n    #[serde(rename = \"street1\")]\n    pub street1: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[d\n\n... [truncated 39950 chars] ...\n\n GetnetPaymentStatus::Success => IncomingWebhookEvent::RefundSuccess,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::RefundFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::RefundFailure,\n        },\n\n        GetnetTransactionType::VoidAuthorization => match transaction_status {\n            GetnetPaymentStatus::Success => IncomingWebhookEvent::PaymentIntentCancelled,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::PaymentIntentCancelFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::PaymentIntentCancelFailure,\n        },\n\n        GetnetTransactionType::VoidPurchase => match transaction_status {\n            GetnetPaymentStatus::Success => IncomingWebhookEvent::PaymentIntentCancelled,\n            GetnetPaymentStatus::Failed => IncomingWebhookEvent::PaymentIntentCancelFailure,\n            GetnetPaymentStatus::InProgress => IncomingWebhookEvent::PaymentIntentCancelFailure,\n        },\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs"}, {"query": "hyperswitch billwerk connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers::{\n    self as billwerk, BillwerkAuthType, BillwerkCaptureRequest, BillwerkErrorResponse,\n    BillwerkPaymentsRequest, BillwerkPaymentsResp\n\n... [truncated 28113 chars] ...\n\n    },\n        );\n\n        billwerk_supported_payment_methods\n    });\n\nstatic BILLWERK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Billwerk\",\n    description: \"Billwerk+ Pay is an acquirer independent payment gateway that's easy to setup with more than 50 recurring and non-recurring payment methods.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic BILLWERK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Billwerk {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BILLWERK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BILLWERK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BILLWERK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__billwerk.rs", "file": "crates__hyperswitch_connectors__src__connectors__billwerk.rs"}, {"query": "Billwerk struct definition", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers::{\n    self as billwerk, BillwerkAuthType, BillwerkCaptureRequest, BillwerkErrorResponse,\n    BillwerkPaymentsRequest, BillwerkPaymentsResp\n\n... [truncated 28113 chars] ...\n\n    },\n        );\n\n        billwerk_supported_payment_methods\n    });\n\nstatic BILLWERK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Billwerk\",\n    description: \"Billwerk+ Pay is an acquirer independent payment gateway that's easy to setup with more than 50 recurring and non-recurring payment methods.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic BILLWERK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Billwerk {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BILLWERK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BILLWERK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BILLWERK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__billwerk.rs", "file": "crates__hyperswitch_connectors__src__connectors__billwerk.rs"}, {"query": "how to add new payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers::{\n    self as billwerk, BillwerkAuthType, BillwerkCaptureRequest, BillwerkErrorResponse,\n    BillwerkPaymentsRequest, BillwerkPaymentsResp\n\n... [truncated 28113 chars] ...\n\n    },\n        );\n\n        billwerk_supported_payment_methods\n    });\n\nstatic BILLWERK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Billwerk\",\n    description: \"Billwerk+ Pay is an acquirer independent payment gateway that's easy to setup with more than 50 recurring and non-recurring payment methods.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic BILLWERK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Billwerk {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BILLWERK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BILLWERK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BILLWERK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__billwerk.rs", "file": "crates__hyperswitch_connectors__src__connectors__billwerk.rs"}, {"query": "billwerk payment method configuration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers::{\n    self as billwerk, BillwerkAuthType, BillwerkCaptureRequest, BillwerkErrorResponse,\n    BillwerkPaymentsRequest, BillwerkPaymentsResp\n\n... [truncated 28113 chars] ...\n\n    },\n        );\n\n        billwerk_supported_payment_methods\n    });\n\nstatic BILLWERK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Billwerk\",\n    description: \"Billwerk+ Pay is an acquirer independent payment gateway that's easy to setup with more than 50 recurring and non-recurring payment methods.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic BILLWERK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Billwerk {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BILLWERK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BILLWERK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BILLWERK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__billwerk.rs", "file": "crates__hyperswitch_connectors__src__connectors__billwerk.rs"}, {"query": "Worldline connector data transformation", "code": "use common_enums::enums::{AttemptStatus, BankNames, CaptureMethod, CountryAlpha2, Currency};\nuse common_utils::{pii::Email, request::Method};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{api::CurrencyUnit, errors};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData, RouterData as RouterDataUtils},\n};\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Card {\n    pub card_number: cards::CardNumber,\n    pub cardholder_name: Secret<String>,\n    pub cvv: Secret<String>,\n    pub expiry_date: Secret<String>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct CardPaymentMethod {\n    pub card: Card,\n    pub requires_approval: bool,\n    pub payment_product_id: u16,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmountOfMoney {\n    pub amount: i64,\n    pub currency_code: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct References {\n    pub merchant_reference: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Order {\n    pub amount_of_money: AmountOfMoney,\n    pub customer: Customer,\n    pub references: References,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingAddres\n\n... [truncated 23018 chars] ...\n\npub property_name: Option<String>,\n    pub message: Option<String>,\n}\n\n#[derive(Default, Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ErrorResponse {\n    pub error_id: Option<String>,\n    pub errors: Vec<Error>,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WebhookBody {\n    pub api_version: Option<String>,\n    pub id: String,\n    pub created: String,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    #[serde(rename = \"type\")]\n    pub event_type: WebhookEvent,\n    pub payment: Option<serde_json::Value>,\n    pub refund: Option<serde_json::Value>,\n    pub payout: Option<serde_json::Value>,\n    pub token: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Deserialize)]\npub enum WebhookEvent {\n    #[serde(rename = \"payment.rejected\")]\n    Rejected,\n    #[serde(rename = \"payment.rejected_capture\")]\n    RejectedCapture,\n    #[serde(rename = \"payment.paid\")]\n    Paid,\n    #[serde(other)]\n    Unknown,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldline__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldline__transformers.rs"}, {"query": "Worldline refund response types", "code": "use common_enums::enums::{AttemptStatus, BankNames, CaptureMethod, CountryAlpha2, Currency};\nuse common_utils::{pii::Email, request::Method};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{api::CurrencyUnit, errors};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData, RouterData as RouterDataUtils},\n};\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Card {\n    pub card_number: cards::CardNumber,\n    pub cardholder_name: Secret<String>,\n    pub cvv: Secret<String>,\n    pub expiry_date: Secret<String>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct CardPaymentMethod {\n    pub card: Card,\n    pub requires_approval: bool,\n    pub payment_product_id: u16,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmountOfMoney {\n    pub amount: i64,\n    pub currency_code: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct References {\n    pub merchant_reference: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Order {\n    pub amount_of_money: AmountOfMoney,\n    pub customer: Customer,\n    pub references: References,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingAddres\n\n... [truncated 23018 chars] ...\n\npub property_name: Option<String>,\n    pub message: Option<String>,\n}\n\n#[derive(Default, Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ErrorResponse {\n    pub error_id: Option<String>,\n    pub errors: Vec<Error>,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WebhookBody {\n    pub api_version: Option<String>,\n    pub id: String,\n    pub created: String,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    #[serde(rename = \"type\")]\n    pub event_type: WebhookEvent,\n    pub payment: Option<serde_json::Value>,\n    pub refund: Option<serde_json::Value>,\n    pub payout: Option<serde_json::Value>,\n    pub token: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Deserialize)]\npub enum WebhookEvent {\n    #[serde(rename = \"payment.rejected\")]\n    Rejected,\n    #[serde(rename = \"payment.rejected_capture\")]\n    RejectedCapture,\n    #[serde(rename = \"payment.paid\")]\n    Paid,\n    #[serde(other)]\n    Unknown,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldline__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldline__transformers.rs"}, {"query": "hyperswitch Worldline integration", "code": "use common_enums::enums::{AttemptStatus, BankNames, CaptureMethod, CountryAlpha2, Currency};\nuse common_utils::{pii::Email, request::Method};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{api::CurrencyUnit, errors};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData, RouterData as RouterDataUtils},\n};\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Card {\n    pub card_number: cards::CardNumber,\n    pub cardholder_name: Secret<String>,\n    pub cvv: Secret<String>,\n    pub expiry_date: Secret<String>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct CardPaymentMethod {\n    pub card: Card,\n    pub requires_approval: bool,\n    pub payment_product_id: u16,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmountOfMoney {\n    pub amount: i64,\n    pub currency_code: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct References {\n    pub merchant_reference: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Order {\n    pub amount_of_money: AmountOfMoney,\n    pub customer: Customer,\n    pub references: References,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingAddres\n\n... [truncated 23018 chars] ...\n\npub property_name: Option<String>,\n    pub message: Option<String>,\n}\n\n#[derive(Default, Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ErrorResponse {\n    pub error_id: Option<String>,\n    pub errors: Vec<Error>,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WebhookBody {\n    pub api_version: Option<String>,\n    pub id: String,\n    pub created: String,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    #[serde(rename = \"type\")]\n    pub event_type: WebhookEvent,\n    pub payment: Option<serde_json::Value>,\n    pub refund: Option<serde_json::Value>,\n    pub payout: Option<serde_json::Value>,\n    pub token: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Deserialize)]\npub enum WebhookEvent {\n    #[serde(rename = \"payment.rejected\")]\n    Rejected,\n    #[serde(rename = \"payment.rejected_capture\")]\n    RejectedCapture,\n    #[serde(rename = \"payment.paid\")]\n    Paid,\n    #[serde(other)]\n    Unknown,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldline__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldline__transformers.rs"}, {"query": "Worldline payment request mapping", "code": "use common_enums::enums::{AttemptStatus, BankNames, CaptureMethod, CountryAlpha2, Currency};\nuse common_utils::{pii::Email, request::Method};\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{api::CurrencyUnit, errors};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData, RouterData as RouterDataUtils},\n};\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Card {\n    pub card_number: cards::CardNumber,\n    pub cardholder_name: Secret<String>,\n    pub cvv: Secret<String>,\n    pub expiry_date: Secret<String>,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct CardPaymentMethod {\n    pub card: Card,\n    pub requires_approval: bool,\n    pub payment_product_id: u16,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmountOfMoney {\n    pub amount: i64,\n    pub currency_code: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct References {\n    pub merchant_reference: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Order {\n    pub amount_of_money: AmountOfMoney,\n    pub customer: Customer,\n    pub references: References,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingAddres\n\n... [truncated 23018 chars] ...\n\npub property_name: Option<String>,\n    pub message: Option<String>,\n}\n\n#[derive(Default, Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ErrorResponse {\n    pub error_id: Option<String>,\n    pub errors: Vec<Error>,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WebhookBody {\n    pub api_version: Option<String>,\n    pub id: String,\n    pub created: String,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    #[serde(rename = \"type\")]\n    pub event_type: WebhookEvent,\n    pub payment: Option<serde_json::Value>,\n    pub refund: Option<serde_json::Value>,\n    pub payout: Option<serde_json::Value>,\n    pub token: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Deserialize)]\npub enum WebhookEvent {\n    #[serde(rename = \"payment.rejected\")]\n    Rejected,\n    #[serde(rename = \"payment.rejected_capture\")]\n    RejectedCapture,\n    #[serde(rename = \"payment.paid\")]\n    Paid,\n    #[serde(other)]\n    Unknown,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldline__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldline__transformers.rs"}, {"query": "how to implement Zen payment gateway connector", "code": "pub mod transformers;\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers::{self as zen, ZenPaymentStatus, ZenWebhookTxnType};\nuse uu\n\n... [truncated 29632 chars] ...\n\nmethods\n});\n\nstatic ZEN_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Zen\",\n        description: \"Zen Payment Gateway is a secure and scalable payment solution that enables businesses to accept online payments globally with various methods and currencies.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic ZEN_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Zen {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ZEN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZEN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ZEN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zen.rs", "file": "crates__hyperswitch_connectors__src__connectors__zen.rs"}, {"query": "Zen connector authentication header", "code": "pub mod transformers;\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers::{self as zen, ZenPaymentStatus, ZenWebhookTxnType};\nuse uu\n\n... [truncated 29632 chars] ...\n\nmethods\n});\n\nstatic ZEN_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Zen\",\n        description: \"Zen Payment Gateway is a secure and scalable payment solution that enables businesses to accept online payments globally with various methods and currencies.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic ZEN_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Zen {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ZEN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZEN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ZEN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zen.rs", "file": "crates__hyperswitch_connectors__src__connectors__zen.rs"}, {"query": "Zen webhook event handling", "code": "pub mod transformers;\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers::{self as zen, ZenPaymentStatus, ZenWebhookTxnType};\nuse uu\n\n... [truncated 29632 chars] ...\n\nmethods\n});\n\nstatic ZEN_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Zen\",\n        description: \"Zen Payment Gateway is a secure and scalable payment solution that enables businesses to accept online payments globally with various methods and currencies.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic ZEN_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Zen {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ZEN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZEN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ZEN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zen.rs", "file": "crates__hyperswitch_connectors__src__connectors__zen.rs"}, {"query": "Zen payment method configuration", "code": "pub mod transformers;\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers::{self as zen, ZenPaymentStatus, ZenWebhookTxnType};\nuse uu\n\n... [truncated 29632 chars] ...\n\nmethods\n});\n\nstatic ZEN_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Zen\",\n        description: \"Zen Payment Gateway is a secure and scalable payment solution that enables businesses to accept online payments globally with various methods and currencies.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic ZEN_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Zen {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ZEN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ZEN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ZEN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zen.rs", "file": "crates__hyperswitch_connectors__src__connectors__zen.rs"}, {"query": "how to configure pre-routing skip rules", "code": "use std::{\n    collections::{HashMap, HashSet},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    open_router as or_types,\n    routing::{\n        self as api_routing, ComparisonType, ConnectorSelection, ConnectorVolumeSplit,\n        DeRoutableConnectorChoice, MetadataValue, NumberComparison, RoutableConnectorChoice,\n        RoutingEvaluateRequest, RoutingEvaluateResponse, ValueType,\n    },\n};\nuse async_trait::async_trait;\nuse common_enums::TransactionType;\nuse common_utils::{\n    ext_traits::{BytesExt, StringExt},\n    id_type,\n};\nuse diesel_models::{enums, routing_algorithm};\nuse error_stack::ResultExt;\nuse euclid::{\n    backend::BackendInput,\n    enums::RoutableConnectors,\n    frontend::{\n        ast::{self},\n        dir::{self, transformers::IntoDirValue},\n    },\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing as ir_client;\nuse hyperswitch_domain_models::business_profile;\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\nuse router_env::RequestId;\nuse serde::{Deserialize, Serialize};\n\nuse super::RoutingResult;\nuse crate::{\n    core::errors,\n    db::domain,\n    routes::{app::SessionStateInfo, SessionState},\n    services::{self, logger},\n    types::transformers::ForeignInto,\n};\n\n// New Trait for handling Euclid API calls\n#[async_trait]\npub trait DecisionEngineApiHandler {\n    async fn send_decision_engine_request<Req, Res>(\n        state: &SessionState,\n        http_method: services::Method,\n        path: &str,\n        request_body: Option<Req>, // Option to handle GET/DELETE requests without body\n        timeout: Option<u64>,\n        events_wrapper: Option<RoutingEventsWrapper<Req>>,\n    ) -> RoutingResult<RoutingEventsResponse<Res>>\n    where\n        Req: Serialize + Send + Sync + 'static + Clone,\n        Res: Serialize + serde::de::DeserializeOwned + Send + 'static + std::fmt::Debug + Clone;\n}\n\n// Struct to implement the DecisionEngineApiHandler trait\npub struct EuclidApiCli\n\n... [truncated 75836 chars] ...\n\nir.\npub fn should_skip_prerouting(\n    skip_map: &HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n    pm: &enums::PaymentMethod,\n    pmt: &enums::PaymentMethodType,\n) -> bool {\n    skip_map\n        .get(pm)\n        .map(|set| set.contains(pmt))\n        .unwrap_or(false)\n}\n\npub fn perform_pre_routing(\n    allowed_pm_for_pre_routing: &LazyLock<HashSet<enums::PaymentMethod>>,\n    allowed_pmt_for_pre_routing: &LazyLock<HashSet<enums::PaymentMethodType>>,\n    payment_method: &enums::PaymentMethod,\n    payment_method_type: &enums::PaymentMethodType,\n    skip_map: &HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n) -> bool {\n    let should_skip_prerouting =\n        should_skip_prerouting(skip_map, payment_method, payment_method_type);\n\n    let pm_allowed = allowed_pm_for_pre_routing.contains(payment_method);\n    let pmt_allowed = allowed_pmt_for_pre_routing.contains(payment_method_type);\n    (pm_allowed || pmt_allowed) && !should_skip_prerouting\n}\n", "function_name": "crates__router__src__core__payments__routing__utils.rs", "file": "crates__router__src__core__payments__routing__utils.rs"}, {"query": "EuclidApiClient implementation", "code": "use std::{\n    collections::{HashMap, HashSet},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    open_router as or_types,\n    routing::{\n        self as api_routing, ComparisonType, ConnectorSelection, ConnectorVolumeSplit,\n        DeRoutableConnectorChoice, MetadataValue, NumberComparison, RoutableConnectorChoice,\n        RoutingEvaluateRequest, RoutingEvaluateResponse, ValueType,\n    },\n};\nuse async_trait::async_trait;\nuse common_enums::TransactionType;\nuse common_utils::{\n    ext_traits::{BytesExt, StringExt},\n    id_type,\n};\nuse diesel_models::{enums, routing_algorithm};\nuse error_stack::ResultExt;\nuse euclid::{\n    backend::BackendInput,\n    enums::RoutableConnectors,\n    frontend::{\n        ast::{self},\n        dir::{self, transformers::IntoDirValue},\n    },\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing as ir_client;\nuse hyperswitch_domain_models::business_profile;\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\nuse router_env::RequestId;\nuse serde::{Deserialize, Serialize};\n\nuse super::RoutingResult;\nuse crate::{\n    core::errors,\n    db::domain,\n    routes::{app::SessionStateInfo, SessionState},\n    services::{self, logger},\n    types::transformers::ForeignInto,\n};\n\n// New Trait for handling Euclid API calls\n#[async_trait]\npub trait DecisionEngineApiHandler {\n    async fn send_decision_engine_request<Req, Res>(\n        state: &SessionState,\n        http_method: services::Method,\n        path: &str,\n        request_body: Option<Req>, // Option to handle GET/DELETE requests without body\n        timeout: Option<u64>,\n        events_wrapper: Option<RoutingEventsWrapper<Req>>,\n    ) -> RoutingResult<RoutingEventsResponse<Res>>\n    where\n        Req: Serialize + Send + Sync + 'static + Clone,\n        Res: Serialize + serde::de::DeserializeOwned + Send + 'static + std::fmt::Debug + Clone;\n}\n\n// Struct to implement the DecisionEngineApiHandler trait\npub struct EuclidApiCli\n\n... [truncated 75836 chars] ...\n\nir.\npub fn should_skip_prerouting(\n    skip_map: &HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n    pm: &enums::PaymentMethod,\n    pmt: &enums::PaymentMethodType,\n) -> bool {\n    skip_map\n        .get(pm)\n        .map(|set| set.contains(pmt))\n        .unwrap_or(false)\n}\n\npub fn perform_pre_routing(\n    allowed_pm_for_pre_routing: &LazyLock<HashSet<enums::PaymentMethod>>,\n    allowed_pmt_for_pre_routing: &LazyLock<HashSet<enums::PaymentMethodType>>,\n    payment_method: &enums::PaymentMethod,\n    payment_method_type: &enums::PaymentMethodType,\n    skip_map: &HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n) -> bool {\n    let should_skip_prerouting =\n        should_skip_prerouting(skip_map, payment_method, payment_method_type);\n\n    let pm_allowed = allowed_pm_for_pre_routing.contains(payment_method);\n    let pmt_allowed = allowed_pmt_for_pre_routing.contains(payment_method_type);\n    (pm_allowed || pmt_allowed) && !should_skip_prerouting\n}\n", "function_name": "crates__router__src__core__payments__routing__utils.rs", "file": "crates__router__src__core__payments__routing__utils.rs"}, {"query": "DecisionEngineApiHandler trait", "code": "use std::{\n    collections::{HashMap, HashSet},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    open_router as or_types,\n    routing::{\n        self as api_routing, ComparisonType, ConnectorSelection, ConnectorVolumeSplit,\n        DeRoutableConnectorChoice, MetadataValue, NumberComparison, RoutableConnectorChoice,\n        RoutingEvaluateRequest, RoutingEvaluateResponse, ValueType,\n    },\n};\nuse async_trait::async_trait;\nuse common_enums::TransactionType;\nuse common_utils::{\n    ext_traits::{BytesExt, StringExt},\n    id_type,\n};\nuse diesel_models::{enums, routing_algorithm};\nuse error_stack::ResultExt;\nuse euclid::{\n    backend::BackendInput,\n    enums::RoutableConnectors,\n    frontend::{\n        ast::{self},\n        dir::{self, transformers::IntoDirValue},\n    },\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing as ir_client;\nuse hyperswitch_domain_models::business_profile;\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\nuse router_env::RequestId;\nuse serde::{Deserialize, Serialize};\n\nuse super::RoutingResult;\nuse crate::{\n    core::errors,\n    db::domain,\n    routes::{app::SessionStateInfo, SessionState},\n    services::{self, logger},\n    types::transformers::ForeignInto,\n};\n\n// New Trait for handling Euclid API calls\n#[async_trait]\npub trait DecisionEngineApiHandler {\n    async fn send_decision_engine_request<Req, Res>(\n        state: &SessionState,\n        http_method: services::Method,\n        path: &str,\n        request_body: Option<Req>, // Option to handle GET/DELETE requests without body\n        timeout: Option<u64>,\n        events_wrapper: Option<RoutingEventsWrapper<Req>>,\n    ) -> RoutingResult<RoutingEventsResponse<Res>>\n    where\n        Req: Serialize + Send + Sync + 'static + Clone,\n        Res: Serialize + serde::de::DeserializeOwned + Send + 'static + std::fmt::Debug + Clone;\n}\n\n// Struct to implement the DecisionEngineApiHandler trait\npub struct EuclidApiCli\n\n... [truncated 75836 chars] ...\n\nir.\npub fn should_skip_prerouting(\n    skip_map: &HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n    pm: &enums::PaymentMethod,\n    pmt: &enums::PaymentMethodType,\n) -> bool {\n    skip_map\n        .get(pm)\n        .map(|set| set.contains(pmt))\n        .unwrap_or(false)\n}\n\npub fn perform_pre_routing(\n    allowed_pm_for_pre_routing: &LazyLock<HashSet<enums::PaymentMethod>>,\n    allowed_pmt_for_pre_routing: &LazyLock<HashSet<enums::PaymentMethodType>>,\n    payment_method: &enums::PaymentMethod,\n    payment_method_type: &enums::PaymentMethodType,\n    skip_map: &HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n) -> bool {\n    let should_skip_prerouting =\n        should_skip_prerouting(skip_map, payment_method, payment_method_type);\n\n    let pm_allowed = allowed_pm_for_pre_routing.contains(payment_method);\n    let pmt_allowed = allowed_pmt_for_pre_routing.contains(payment_method_type);\n    (pm_allowed || pmt_allowed) && !should_skip_prerouting\n}\n", "function_name": "crates__router__src__core__payments__routing__utils.rs", "file": "crates__router__src__core__payments__routing__utils.rs"}, {"query": "merchant pre-routing configuration", "code": "use std::{\n    collections::{HashMap, HashSet},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    open_router as or_types,\n    routing::{\n        self as api_routing, ComparisonType, ConnectorSelection, ConnectorVolumeSplit,\n        DeRoutableConnectorChoice, MetadataValue, NumberComparison, RoutableConnectorChoice,\n        RoutingEvaluateRequest, RoutingEvaluateResponse, ValueType,\n    },\n};\nuse async_trait::async_trait;\nuse common_enums::TransactionType;\nuse common_utils::{\n    ext_traits::{BytesExt, StringExt},\n    id_type,\n};\nuse diesel_models::{enums, routing_algorithm};\nuse error_stack::ResultExt;\nuse euclid::{\n    backend::BackendInput,\n    enums::RoutableConnectors,\n    frontend::{\n        ast::{self},\n        dir::{self, transformers::IntoDirValue},\n    },\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse external_services::grpc_client::dynamic_routing as ir_client;\nuse hyperswitch_domain_models::business_profile;\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\nuse router_env::RequestId;\nuse serde::{Deserialize, Serialize};\n\nuse super::RoutingResult;\nuse crate::{\n    core::errors,\n    db::domain,\n    routes::{app::SessionStateInfo, SessionState},\n    services::{self, logger},\n    types::transformers::ForeignInto,\n};\n\n// New Trait for handling Euclid API calls\n#[async_trait]\npub trait DecisionEngineApiHandler {\n    async fn send_decision_engine_request<Req, Res>(\n        state: &SessionState,\n        http_method: services::Method,\n        path: &str,\n        request_body: Option<Req>, // Option to handle GET/DELETE requests without body\n        timeout: Option<u64>,\n        events_wrapper: Option<RoutingEventsWrapper<Req>>,\n    ) -> RoutingResult<RoutingEventsResponse<Res>>\n    where\n        Req: Serialize + Send + Sync + 'static + Clone,\n        Res: Serialize + serde::de::DeserializeOwned + Send + 'static + std::fmt::Debug + Clone;\n}\n\n// Struct to implement the DecisionEngineApiHandler trait\npub struct EuclidApiCli\n\n... [truncated 75836 chars] ...\n\nir.\npub fn should_skip_prerouting(\n    skip_map: &HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n    pm: &enums::PaymentMethod,\n    pmt: &enums::PaymentMethodType,\n) -> bool {\n    skip_map\n        .get(pm)\n        .map(|set| set.contains(pmt))\n        .unwrap_or(false)\n}\n\npub fn perform_pre_routing(\n    allowed_pm_for_pre_routing: &LazyLock<HashSet<enums::PaymentMethod>>,\n    allowed_pmt_for_pre_routing: &LazyLock<HashSet<enums::PaymentMethodType>>,\n    payment_method: &enums::PaymentMethod,\n    payment_method_type: &enums::PaymentMethodType,\n    skip_map: &HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n) -> bool {\n    let should_skip_prerouting =\n        should_skip_prerouting(skip_map, payment_method, payment_method_type);\n\n    let pm_allowed = allowed_pm_for_pre_routing.contains(payment_method);\n    let pmt_allowed = allowed_pmt_for_pre_routing.contains(payment_method_type);\n    (pm_allowed || pmt_allowed) && !should_skip_prerouting\n}\n", "function_name": "crates__router__src__core__payments__routing__utils.rs", "file": "crates__router__src__core__payments__routing__utils.rs"}, {"query": "BitPay connector implementation hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as bitpay;\n\nuse self::bitpay::BitpayWebhookDetails;\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Bitpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bitpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amo\n\n... [truncated 13338 chars] ...\n\n  bitpay_supported_payment_methods\n});\n\nstatic BITPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bitpay\",\n        description:\n            \"BitPay is a cryptocurrency payment processor that enables businesses to accept Bitcoin and other digital currencies \",\n        connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic BITPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Bitpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BITPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BITPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BITPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bitpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__bitpay.rs"}, {"query": "Bitpay struct definition", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as bitpay;\n\nuse self::bitpay::BitpayWebhookDetails;\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Bitpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bitpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amo\n\n... [truncated 13338 chars] ...\n\n  bitpay_supported_payment_methods\n});\n\nstatic BITPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bitpay\",\n        description:\n            \"BitPay is a cryptocurrency payment processor that enables businesses to accept Bitcoin and other digital currencies \",\n        connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic BITPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Bitpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BITPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BITPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BITPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bitpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__bitpay.rs"}, {"query": "how to implement crypto payment connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as bitpay;\n\nuse self::bitpay::BitpayWebhookDetails;\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Bitpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bitpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amo\n\n... [truncated 13338 chars] ...\n\n  bitpay_supported_payment_methods\n});\n\nstatic BITPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bitpay\",\n        description:\n            \"BitPay is a cryptocurrency payment processor that enables businesses to accept Bitcoin and other digital currencies \",\n        connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic BITPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Bitpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BITPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BITPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BITPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bitpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__bitpay.rs"}, {"query": "BitPay webhook handling hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as bitpay;\n\nuse self::bitpay::BitpayWebhookDetails;\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Bitpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bitpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amo\n\n... [truncated 13338 chars] ...\n\n  bitpay_supported_payment_methods\n});\n\nstatic BITPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bitpay\",\n        description:\n            \"BitPay is a cryptocurrency payment processor that enables businesses to accept Bitcoin and other digital currencies \",\n        connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic BITPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Bitpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BITPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BITPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BITPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bitpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__bitpay.rs"}, {"query": "Bank of America payment integration hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response, SetupMandateType,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::{digest, hmac};\nuse time::OffsetDateTime;\nuse transformers as bankofamerica;\nuse url::Url;\n\nuse crate::{\n    connectors::bankofam\n\n... [truncated 41647 chars] ...\n\n   });\n\nstatic BANKOFAMERICA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bank Of America\",\n        description:\n            \"It is the second-largest banking institution in the United States and the second-largest bank in the world by market capitalization \",\n        connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic BANKOFAMERICA_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Bankofamerica {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BANKOFAMERICA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BANKOFAMERICA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BANKOFAMERICA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bankofamerica.rs", "file": "crates__hyperswitch_connectors__src__connectors__bankofamerica.rs"}, {"query": "Bankofamerica struct implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response, SetupMandateType,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::{digest, hmac};\nuse time::OffsetDateTime;\nuse transformers as bankofamerica;\nuse url::Url;\n\nuse crate::{\n    connectors::bankofam\n\n... [truncated 41647 chars] ...\n\n   });\n\nstatic BANKOFAMERICA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bank Of America\",\n        description:\n            \"It is the second-largest banking institution in the United States and the second-largest bank in the world by market capitalization \",\n        connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic BANKOFAMERICA_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Bankofamerica {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BANKOFAMERICA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BANKOFAMERICA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BANKOFAMERICA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bankofamerica.rs", "file": "crates__hyperswitch_connectors__src__connectors__bankofamerica.rs"}, {"query": "how to configure Bank of America connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response, SetupMandateType,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::{digest, hmac};\nuse time::OffsetDateTime;\nuse transformers as bankofamerica;\nuse url::Url;\n\nuse crate::{\n    connectors::bankofam\n\n... [truncated 41647 chars] ...\n\n   });\n\nstatic BANKOFAMERICA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bank Of America\",\n        description:\n            \"It is the second-largest banking institution in the United States and the second-largest bank in the world by market capitalization \",\n        connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic BANKOFAMERICA_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Bankofamerica {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BANKOFAMERICA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BANKOFAMERICA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BANKOFAMERICA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bankofamerica.rs", "file": "crates__hyperswitch_connectors__src__connectors__bankofamerica.rs"}, {"query": "hyperswitch bank of america refund capture", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response, SetupMandateType,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::{digest, hmac};\nuse time::OffsetDateTime;\nuse transformers as bankofamerica;\nuse url::Url;\n\nuse crate::{\n    connectors::bankofam\n\n... [truncated 41647 chars] ...\n\n   });\n\nstatic BANKOFAMERICA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Bank Of America\",\n        description:\n            \"It is the second-largest banking institution in the United States and the second-largest bank in the world by market capitalization \",\n        connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic BANKOFAMERICA_SUPPORTED_WEBHOOK_FLOWS: [common_enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Bankofamerica {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BANKOFAMERICA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BANKOFAMERICA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BANKOFAMERICA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bankofamerica.rs", "file": "crates__hyperswitch_connectors__src__connectors__bankofamerica.rs"}, {"query": "how to integrate Coinbase payments", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    connector_endpoints::Connectors,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as coinbase;\n\nuse self::coinbase::CoinbaseWebhookDetails;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Coinbase {\n    amount_convertor: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coinbase {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convert\n\n... [truncated 15090 chars] ...\n\ndType::CryptoCurrency,\n            PaymentMethodDetails {\n                mandates: common_enums::FeatureStatus::NotSupported,\n                refunds: common_enums::FeatureStatus::NotSupported,\n                supported_capture_methods: supported_capture_methods.clone(),\n                specific_features: None,\n            },\n        );\n\n        coinbase_supported_payment_methods\n    };\n    static ref COINBASE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> =\n        vec![enums::EventClass::Payments, enums::EventClass::Refunds,];\n}\n\nimpl ConnectorSpecifications for Coinbase {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*COINBASE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*COINBASE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*COINBASE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__coinbase.rs", "file": "crates__hyperswitch_connectors__src__connectors__coinbase.rs"}, {"query": "Coinbase connector implementation", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    connector_endpoints::Connectors,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as coinbase;\n\nuse self::coinbase::CoinbaseWebhookDetails;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Coinbase {\n    amount_convertor: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coinbase {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convert\n\n... [truncated 15090 chars] ...\n\ndType::CryptoCurrency,\n            PaymentMethodDetails {\n                mandates: common_enums::FeatureStatus::NotSupported,\n                refunds: common_enums::FeatureStatus::NotSupported,\n                supported_capture_methods: supported_capture_methods.clone(),\n                specific_features: None,\n            },\n        );\n\n        coinbase_supported_payment_methods\n    };\n    static ref COINBASE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> =\n        vec![enums::EventClass::Payments, enums::EventClass::Refunds,];\n}\n\nimpl ConnectorSpecifications for Coinbase {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*COINBASE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*COINBASE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*COINBASE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__coinbase.rs", "file": "crates__hyperswitch_connectors__src__connectors__coinbase.rs"}, {"query": "implement crypto payment gateway", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    connector_endpoints::Connectors,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as coinbase;\n\nuse self::coinbase::CoinbaseWebhookDetails;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Coinbase {\n    amount_convertor: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coinbase {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convert\n\n... [truncated 15090 chars] ...\n\ndType::CryptoCurrency,\n            PaymentMethodDetails {\n                mandates: common_enums::FeatureStatus::NotSupported,\n                refunds: common_enums::FeatureStatus::NotSupported,\n                supported_capture_methods: supported_capture_methods.clone(),\n                specific_features: None,\n            },\n        );\n\n        coinbase_supported_payment_methods\n    };\n    static ref COINBASE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> =\n        vec![enums::EventClass::Payments, enums::EventClass::Refunds,];\n}\n\nimpl ConnectorSpecifications for Coinbase {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*COINBASE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*COINBASE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*COINBASE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__coinbase.rs", "file": "crates__hyperswitch_connectors__src__connectors__coinbase.rs"}, {"query": "Hyperswitch Coinbase webhook handling", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    connector_endpoints::Connectors,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as coinbase;\n\nuse self::coinbase::CoinbaseWebhookDetails;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Coinbase {\n    amount_convertor: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coinbase {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convert\n\n... [truncated 15090 chars] ...\n\ndType::CryptoCurrency,\n            PaymentMethodDetails {\n                mandates: common_enums::FeatureStatus::NotSupported,\n                refunds: common_enums::FeatureStatus::NotSupported,\n                supported_capture_methods: supported_capture_methods.clone(),\n                specific_features: None,\n            },\n        );\n\n        coinbase_supported_payment_methods\n    };\n    static ref COINBASE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> =\n        vec![enums::EventClass::Payments, enums::EventClass::Refunds,];\n}\n\nimpl ConnectorSpecifications for Coinbase {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*COINBASE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*COINBASE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*COINBASE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__coinbase.rs", "file": "crates__hyperswitch_connectors__src__connectors__coinbase.rs"}, {"query": "hyperswitch checkbook connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{enums, payments::PaymentIdType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as checkbook;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Checkbook {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Checkbook {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Pa\n\n... [truncated 20186 chars] ...\n\n,\n            },\n        );\n        checkbook_supported_payment_methods\n    });\n\nstatic CHECKBOOK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Checkbook\",\n    description:\n        \"Checkbook is a payment platform that allows users to send and receive digital checks.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic CHECKBOOK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Checkbook {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHECKBOOK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CHECKBOOK_SUPPORTED_PAYMENT_METHODS)\n    }\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHECKBOOK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkbook.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkbook.rs"}, {"query": "Checkbook struct trait implementations", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{enums, payments::PaymentIdType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as checkbook;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Checkbook {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Checkbook {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Pa\n\n... [truncated 20186 chars] ...\n\n,\n            },\n        );\n        checkbook_supported_payment_methods\n    });\n\nstatic CHECKBOOK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Checkbook\",\n    description:\n        \"Checkbook is a payment platform that allows users to send and receive digital checks.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic CHECKBOOK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Checkbook {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHECKBOOK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CHECKBOOK_SUPPORTED_PAYMENT_METHODS)\n    }\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHECKBOOK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkbook.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkbook.rs"}, {"query": "how to add a new payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{enums, payments::PaymentIdType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as checkbook;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Checkbook {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Checkbook {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Pa\n\n... [truncated 20186 chars] ...\n\n,\n            },\n        );\n        checkbook_supported_payment_methods\n    });\n\nstatic CHECKBOOK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Checkbook\",\n    description:\n        \"Checkbook is a payment platform that allows users to send and receive digital checks.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic CHECKBOOK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Checkbook {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHECKBOOK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CHECKBOOK_SUPPORTED_PAYMENT_METHODS)\n    }\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHECKBOOK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkbook.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkbook.rs"}, {"query": "digital check payment processing hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{enums, payments::PaymentIdType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as checkbook;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Checkbook {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Checkbook {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Pa\n\n... [truncated 20186 chars] ...\n\n,\n            },\n        );\n        checkbook_supported_payment_methods\n    });\n\nstatic CHECKBOOK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Checkbook\",\n    description:\n        \"Checkbook is a payment platform that allows users to send and receive digital checks.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic CHECKBOOK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Checkbook {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHECKBOOK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CHECKBOOK_SUPPORTED_PAYMENT_METHODS)\n    }\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHECKBOOK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkbook.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkbook.rs"}, {"query": "how to add a new payment gateway connector", "code": "use std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        IncrementalAuthorization,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse router_env::{error, info};\nuse transformers::{\n    self as archipel, Archipe\n\n... [truncated 37361 chars] ...\n\natures: None,\n            },\n        );\n\n        archipel_supported_payment_methods\n    });\n\nstatic ARCHIPEL_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Archipel\",\n    description: \"Full-service processor offering secure payment solutions and innovative banking technologies for businesses of all sizes.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic ARCHIPEL_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Archipel {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ARCHIPEL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ARCHIPEL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ARCHIPEL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__archipel.rs", "file": "crates__hyperswitch_connectors__src__connectors__archipel.rs"}, {"query": "Archipel payment gateway integration", "code": "use std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        IncrementalAuthorization,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse router_env::{error, info};\nuse transformers::{\n    self as archipel, Archipe\n\n... [truncated 37361 chars] ...\n\natures: None,\n            },\n        );\n\n        archipel_supported_payment_methods\n    });\n\nstatic ARCHIPEL_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Archipel\",\n    description: \"Full-service processor offering secure payment solutions and innovative banking technologies for businesses of all sizes.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic ARCHIPEL_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Archipel {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ARCHIPEL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ARCHIPEL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ARCHIPEL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__archipel.rs", "file": "crates__hyperswitch_connectors__src__connectors__archipel.rs"}, {"query": "implement payment capture with Archipel", "code": "use std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        IncrementalAuthorization,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse router_env::{error, info};\nuse transformers::{\n    self as archipel, Archipe\n\n... [truncated 37361 chars] ...\n\natures: None,\n            },\n        );\n\n        archipel_supported_payment_methods\n    });\n\nstatic ARCHIPEL_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Archipel\",\n    description: \"Full-service processor offering secure payment solutions and innovative banking technologies for businesses of all sizes.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic ARCHIPEL_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Archipel {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ARCHIPEL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ARCHIPEL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ARCHIPEL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__archipel.rs", "file": "crates__hyperswitch_connectors__src__connectors__archipel.rs"}, {"query": "Hyperswitch Archipel connector authentication", "code": "use std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        IncrementalAuthorization,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse router_env::{error, info};\nuse transformers::{\n    self as archipel, Archipe\n\n... [truncated 37361 chars] ...\n\natures: None,\n            },\n        );\n\n        archipel_supported_payment_methods\n    });\n\nstatic ARCHIPEL_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Archipel\",\n    description: \"Full-service processor offering secure payment solutions and innovative banking technologies for businesses of all sizes.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic ARCHIPEL_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Archipel {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ARCHIPEL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ARCHIPEL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&ARCHIPEL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__archipel.rs", "file": "crates__hyperswitch_connectors__src__connectors__archipel.rs"}, {"query": "Fiserv payment gateway integration hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types, webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse time::OffsetDateTime;\nuse transformers as fiserv;\nuse uuid::Uuid;\n\nuse crate::{\n    constants::headers, types::ResponseRouterData, utils as connector_utils, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Fiserv {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> \n\n... [truncated 33504 chars] ...\n\ne,\n        },\n    );\n\n    fiserv_supported_payment_methods\n});\n\nstatic FISERV_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Fiserv\",\n    description:\n        \"Fiserv is a global fintech and payments company with solutions for banking, global commerce, merchant acquiring, billing and payments, and point-of-sale \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FISERV_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Fiserv {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FISERV_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FISERV_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FISERV_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiserv.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiserv.rs"}, {"query": "how to implement Fiserv connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types, webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse time::OffsetDateTime;\nuse transformers as fiserv;\nuse uuid::Uuid;\n\nuse crate::{\n    constants::headers, types::ResponseRouterData, utils as connector_utils, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Fiserv {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> \n\n... [truncated 33504 chars] ...\n\ne,\n        },\n    );\n\n    fiserv_supported_payment_methods\n});\n\nstatic FISERV_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Fiserv\",\n    description:\n        \"Fiserv is a global fintech and payments company with solutions for banking, global commerce, merchant acquiring, billing and payments, and point-of-sale \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FISERV_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Fiserv {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FISERV_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FISERV_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FISERV_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiserv.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiserv.rs"}, {"query": "generate_authorization_signature function", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types, webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse time::OffsetDateTime;\nuse transformers as fiserv;\nuse uuid::Uuid;\n\nuse crate::{\n    constants::headers, types::ResponseRouterData, utils as connector_utils, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Fiserv {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> \n\n... [truncated 33504 chars] ...\n\ne,\n        },\n    );\n\n    fiserv_supported_payment_methods\n});\n\nstatic FISERV_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Fiserv\",\n    description:\n        \"Fiserv is a global fintech and payments company with solutions for banking, global commerce, merchant acquiring, billing and payments, and point-of-sale \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FISERV_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Fiserv {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FISERV_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FISERV_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FISERV_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiserv.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiserv.rs"}, {"query": "Fiserv HMAC-SHA256 signature generation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types, webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse time::OffsetDateTime;\nuse transformers as fiserv;\nuse uuid::Uuid;\n\nuse crate::{\n    constants::headers, types::ResponseRouterData, utils as connector_utils, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Fiserv {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> \n\n... [truncated 33504 chars] ...\n\ne,\n        },\n    );\n\n    fiserv_supported_payment_methods\n});\n\nstatic FISERV_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Fiserv\",\n    description:\n        \"Fiserv is a global fintech and payments company with solutions for banking, global commerce, merchant acquiring, billing and payments, and point-of-sale \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FISERV_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Fiserv {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FISERV_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FISERV_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FISERV_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiserv.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiserv.rs"}, {"query": "Razorpay payment gateway integration", "code": "pub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, CreateOrderType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse router_env::logger;\nuse transformers as razorpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, handl\n\n... [truncated 28028 chars] ...\n\n{\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*RAZORPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*RAZORPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*RAZORPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        // The length of receipt for Razorpay order request should not exceed 40 characters.\n        payment_intent\n            .merchant_reference_id\n            .as_ref()\n            .map(|id| id.get_string_repr().to_owned())\n            .unwrap_or_else(|| uuid::Uuid::now_v7().to_string())\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__razorpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__razorpay.rs"}, {"query": "hyperswitch razorpay connector implementation", "code": "pub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, CreateOrderType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse router_env::logger;\nuse transformers as razorpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, handl\n\n... [truncated 28028 chars] ...\n\n{\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*RAZORPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*RAZORPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*RAZORPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        // The length of receipt for Razorpay order request should not exceed 40 characters.\n        payment_intent\n            .merchant_reference_id\n            .as_ref()\n            .map(|id| id.get_string_repr().to_owned())\n            .unwrap_or_else(|| uuid::Uuid::now_v7().to_string())\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__razorpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__razorpay.rs"}, {"query": "how to configure razorpay payments", "code": "pub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, CreateOrderType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse router_env::logger;\nuse transformers as razorpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, handl\n\n... [truncated 28028 chars] ...\n\n{\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*RAZORPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*RAZORPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*RAZORPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        // The length of receipt for Razorpay order request should not exceed 40 characters.\n        payment_intent\n            .merchant_reference_id\n            .as_ref()\n            .map(|id| id.get_string_repr().to_owned())\n            .unwrap_or_else(|| uuid::Uuid::now_v7().to_string())\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__razorpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__razorpay.rs"}, {"query": "razorpay authorize capture void flow", "code": "pub mod transformers;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, CreateOrderType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse router_env::logger;\nuse transformers as razorpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, handl\n\n... [truncated 28028 chars] ...\n\n{\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*RAZORPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*RAZORPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*RAZORPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        // The length of receipt for Razorpay order request should not exceed 40 characters.\n        payment_intent\n            .merchant_reference_id\n            .as_ref()\n            .map(|id| id.get_string_repr().to_owned())\n            .unwrap_or_else(|| uuid::Uuid::now_v7().to_string())\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__razorpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__razorpay.rs"}, {"query": "Hyperwallet connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as hyperwallet;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Hyperwallet {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Hyperwallet {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hyperwallet {}\nimpl api::Paym\n\n... [truncated 18565 chars] ...\n\nor::WebhooksNotImplemented))\n    }\n}\n\nstatic HYPERWALLET_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic HYPERWALLET_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Hyperwallet\",\n    description: \"Hyperwallet connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic HYPERWALLET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Hyperwallet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&HYPERWALLET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*HYPERWALLET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&HYPERWALLET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__hyperwallet.rs", "file": "crates__hyperswitch_connectors__src__connectors__hyperwallet.rs"}, {"query": "hyperswitch Hyperwallet struct", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as hyperwallet;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Hyperwallet {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Hyperwallet {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hyperwallet {}\nimpl api::Paym\n\n... [truncated 18565 chars] ...\n\nor::WebhooksNotImplemented))\n    }\n}\n\nstatic HYPERWALLET_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic HYPERWALLET_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Hyperwallet\",\n    description: \"Hyperwallet connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic HYPERWALLET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Hyperwallet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&HYPERWALLET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*HYPERWALLET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&HYPERWALLET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__hyperwallet.rs", "file": "crates__hyperswitch_connectors__src__connectors__hyperwallet.rs"}, {"query": "how to configure Hyperwallet payout connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as hyperwallet;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Hyperwallet {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Hyperwallet {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hyperwallet {}\nimpl api::Paym\n\n... [truncated 18565 chars] ...\n\nor::WebhooksNotImplemented))\n    }\n}\n\nstatic HYPERWALLET_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic HYPERWALLET_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Hyperwallet\",\n    description: \"Hyperwallet connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic HYPERWALLET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Hyperwallet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&HYPERWALLET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*HYPERWALLET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&HYPERWALLET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__hyperwallet.rs", "file": "crates__hyperswitch_connectors__src__connectors__hyperwallet.rs"}, {"query": "Hyperwallet API integration Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as hyperwallet;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Hyperwallet {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Hyperwallet {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hyperwallet {}\nimpl api::Paym\n\n... [truncated 18565 chars] ...\n\nor::WebhooksNotImplemented))\n    }\n}\n\nstatic HYPERWALLET_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic HYPERWALLET_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Hyperwallet\",\n    description: \"Hyperwallet connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic HYPERWALLET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Hyperwallet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&HYPERWALLET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*HYPERWALLET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&HYPERWALLET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__hyperwallet.rs", "file": "crates__hyperswitch_connectors__src__connectors__hyperwallet.rs"}, {"query": "Flexiti payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n      \n\n... [truncated 23314 chars] ...\n\nported,\n            refunds: enums::FeatureStatus::NotSupported,\n            supported_capture_methods,\n            specific_features: None,\n        },\n    );\n\n    flexiti_supported_payment_methods\n});\n\nstatic FLEXITI_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Flexiti\",\n    description: \"Flexiti connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic FLEXITI_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Flexiti {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FLEXITI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FLEXITI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FLEXITI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__flexiti.rs", "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs"}, {"query": "Flexiti connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n      \n\n... [truncated 23314 chars] ...\n\nported,\n            refunds: enums::FeatureStatus::NotSupported,\n            supported_capture_methods,\n            specific_features: None,\n        },\n    );\n\n    flexiti_supported_payment_methods\n});\n\nstatic FLEXITI_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Flexiti\",\n    description: \"Flexiti connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic FLEXITI_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Flexiti {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FLEXITI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FLEXITI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FLEXITI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__flexiti.rs", "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs"}, {"query": "how to add new payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n      \n\n... [truncated 23314 chars] ...\n\nported,\n            refunds: enums::FeatureStatus::NotSupported,\n            supported_capture_methods,\n            specific_features: None,\n        },\n    );\n\n    flexiti_supported_payment_methods\n});\n\nstatic FLEXITI_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Flexiti\",\n    description: \"Flexiti connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic FLEXITI_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Flexiti {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FLEXITI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FLEXITI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FLEXITI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__flexiti.rs", "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs"}, {"query": "Klarna PayLater connector Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n      \n\n... [truncated 23314 chars] ...\n\nported,\n            refunds: enums::FeatureStatus::NotSupported,\n            supported_capture_methods,\n            specific_features: None,\n        },\n    );\n\n    flexiti_supported_payment_methods\n});\n\nstatic FLEXITI_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Flexiti\",\n    description: \"Flexiti connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic FLEXITI_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Flexiti {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FLEXITI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FLEXITI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FLEXITI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__flexiti.rs", "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs"}, {"query": "how to integrate Peach Payments with Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::{self, enums, CaptureMethod};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    id_type,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse transformers as peachpayments;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\nconst REFUND: &str = \"Refund\";\n#[derive(Clone)]\npub struct Peachpayments {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Peachpayments {\n    pub fn new() -> &'static S\n\n... [truncated 30698 chars] ...\n\npayments_supported_payment_methods\n    });\n\nstatic PEACHPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Peach Payments\",\n    description: \"The secure African payment gateway with easy integrations, 365-day support, and advanced orchestration.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic PEACHPAYMENTS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Peachpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PEACHPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PEACHPAYMENTS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PEACHPAYMENTS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__peachpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__peachpayments.rs"}, {"query": "Peachpayments struct implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::{self, enums, CaptureMethod};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    id_type,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse transformers as peachpayments;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\nconst REFUND: &str = \"Refund\";\n#[derive(Clone)]\npub struct Peachpayments {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Peachpayments {\n    pub fn new() -> &'static S\n\n... [truncated 30698 chars] ...\n\npayments_supported_payment_methods\n    });\n\nstatic PEACHPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Peach Payments\",\n    description: \"The secure African payment gateway with easy integrations, 365-day support, and advanced orchestration.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic PEACHPAYMENTS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Peachpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PEACHPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PEACHPAYMENTS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PEACHPAYMENTS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__peachpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__peachpayments.rs"}, {"query": "implement payment gateway connector in Rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::{self, enums, CaptureMethod};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    id_type,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse transformers as peachpayments;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\nconst REFUND: &str = \"Refund\";\n#[derive(Clone)]\npub struct Peachpayments {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Peachpayments {\n    pub fn new() -> &'static S\n\n... [truncated 30698 chars] ...\n\npayments_supported_payment_methods\n    });\n\nstatic PEACHPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Peach Payments\",\n    description: \"The secure African payment gateway with easy integrations, 365-day support, and advanced orchestration.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic PEACHPAYMENTS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Peachpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PEACHPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PEACHPAYMENTS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PEACHPAYMENTS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__peachpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__peachpayments.rs"}, {"query": "Peach Payments API integration hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::{self, enums, CaptureMethod};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    id_type,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse transformers as peachpayments;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\nconst REFUND: &str = \"Refund\";\n#[derive(Clone)]\npub struct Peachpayments {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Peachpayments {\n    pub fn new() -> &'static S\n\n... [truncated 30698 chars] ...\n\npayments_supported_payment_methods\n    });\n\nstatic PEACHPAYMENTS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Peach Payments\",\n    description: \"The secure African payment gateway with easy integrations, 365-day support, and advanced orchestration.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic PEACHPAYMENTS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Peachpayments {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PEACHPAYMENTS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PEACHPAYMENTS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PEACHPAYMENTS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__peachpayments.rs", "file": "crates__hyperswitch_connectors__src__connectors__peachpayments.rs"}, {"query": "how does the Netcetera payment connector work", "code": "pub mod netcetera_types;\npub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{AuthenticationIdType, IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        *,\n    },\n    authentication::ExternalAuthenticationPayload,\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse transformers as netcetera;\n\nuse crate::{\n    constants::headers,\n    types::{\n        ConnectorAuthenticationRouterData, ConnectorAuthenticationType,\n\n... [truncated 13966 chars] ...\n\n\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticationVersionCall,\n        PreAuthNRequestData,\n        AuthenticationResponseData,\n    > for Netcetera\n{\n}\n\nstatic NETCETERA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Netcetera\",\n    description: \"Netcetera authentication provider for comprehensive 3D Secure solutions including certified ACS, Directory Server, and multi-protocol EMV 3DS supports\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Netcetera {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NETCETERA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "file": "crates__hyperswitch_connectors__src__connectors__netcetera.rs"}, {"query": "NetceteraConnector struct implementation", "code": "pub mod netcetera_types;\npub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{AuthenticationIdType, IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        *,\n    },\n    authentication::ExternalAuthenticationPayload,\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse transformers as netcetera;\n\nuse crate::{\n    constants::headers,\n    types::{\n        ConnectorAuthenticationRouterData, ConnectorAuthenticationType,\n\n... [truncated 13966 chars] ...\n\n\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticationVersionCall,\n        PreAuthNRequestData,\n        AuthenticationResponseData,\n    > for Netcetera\n{\n}\n\nstatic NETCETERA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Netcetera\",\n    description: \"Netcetera authentication provider for comprehensive 3D Secure solutions including certified ACS, Directory Server, and multi-protocol EMV 3DS supports\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Netcetera {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NETCETERA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "file": "crates__hyperswitch_connectors__src__connectors__netcetera.rs"}, {"query": "how to implement a payment gateway connector", "code": "pub mod netcetera_types;\npub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{AuthenticationIdType, IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        *,\n    },\n    authentication::ExternalAuthenticationPayload,\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse transformers as netcetera;\n\nuse crate::{\n    constants::headers,\n    types::{\n        ConnectorAuthenticationRouterData, ConnectorAuthenticationType,\n\n... [truncated 13966 chars] ...\n\n\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticationVersionCall,\n        PreAuthNRequestData,\n        AuthenticationResponseData,\n    > for Netcetera\n{\n}\n\nstatic NETCETERA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Netcetera\",\n    description: \"Netcetera authentication provider for comprehensive 3D Secure solutions including certified ACS, Directory Server, and multi-protocol EMV 3DS supports\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Netcetera {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NETCETERA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "file": "crates__hyperswitch_connectors__src__connectors__netcetera.rs"}, {"query": "3D Secure authentication provider integration", "code": "pub mod netcetera_types;\npub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::webhooks::{AuthenticationIdType, IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        authentication::{\n            Authentication, PostAuthentication, PreAuthentication, PreAuthenticationVersionCall,\n        },\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        authentication::{\n            ConnectorAuthenticationRequestData, ConnectorPostAuthenticationRequestData,\n            PreAuthNRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        AuthenticationResponseData, ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        authentication::{\n            ConnectorAuthentication, ConnectorPostAuthentication, ConnectorPreAuthentication,\n            ConnectorPreAuthenticationVersionCall, ExternalAuthentication,\n        },\n        *,\n    },\n    authentication::ExternalAuthenticationPayload,\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse transformers as netcetera;\n\nuse crate::{\n    constants::headers,\n    types::{\n        ConnectorAuthenticationRouterData, ConnectorAuthenticationType,\n\n... [truncated 13966 chars] ...\n\n\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticationVersionCall,\n        PreAuthNRequestData,\n        AuthenticationResponseData,\n    > for Netcetera\n{\n}\n\nstatic NETCETERA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Netcetera\",\n    description: \"Netcetera authentication provider for comprehensive 3D Secure solutions including certified ACS, Directory Server, and multi-protocol EMV 3DS supports\",\n    connector_type: common_enums::HyperswitchConnectorCategory::AuthenticationProvider,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Netcetera {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NETCETERA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "file": "crates__hyperswitch_connectors__src__connectors__netcetera.rs"}, {"query": "Cybersource decision manager connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{Checkout, Transaction},\n    router_request_types::fraud_check::{FraudCheckCheckoutData, FraudCheckTransactionData},\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_interfaces::api::{FraudCheck, FraudCheckCheckout, FraudCheckTransaction};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::{digest, hmac};\nuse time::OffsetDateTime;\nuse transformers as cybersourcedecisionmanager;\nuse url::Url;\n\n#[cfg(feature = \"frm\")]\nuse crate::types::{\n    FrmCheckout\n\n... [truncated 22291 chars] ...\n\n=\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic CYBERSOURCEDECISIONMANAGER_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Cybersourcedecisionmanager\",\n    description: \"Cybersourcedecisionmanager connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic CYBERSOURCEDECISIONMANAGER_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Cybersourcedecisionmanager {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CYBERSOURCEDECISIONMANAGER_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CYBERSOURCEDECISIONMANAGER_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CYBERSOURCEDECISIONMANAGER_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager.rs"}, {"query": "CybersourcedecisionmanagerAuthType struct", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{Checkout, Transaction},\n    router_request_types::fraud_check::{FraudCheckCheckoutData, FraudCheckTransactionData},\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_interfaces::api::{FraudCheck, FraudCheckCheckout, FraudCheckTransaction};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::{digest, hmac};\nuse time::OffsetDateTime;\nuse transformers as cybersourcedecisionmanager;\nuse url::Url;\n\n#[cfg(feature = \"frm\")]\nuse crate::types::{\n    FrmCheckout\n\n... [truncated 22291 chars] ...\n\n=\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic CYBERSOURCEDECISIONMANAGER_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Cybersourcedecisionmanager\",\n    description: \"Cybersourcedecisionmanager connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic CYBERSOURCEDECISIONMANAGER_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Cybersourcedecisionmanager {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CYBERSOURCEDECISIONMANAGER_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CYBERSOURCEDECISIONMANAGER_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CYBERSOURCEDECISIONMANAGER_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager.rs"}, {"query": "how to configure Cybersource connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{Checkout, Transaction},\n    router_request_types::fraud_check::{FraudCheckCheckoutData, FraudCheckTransactionData},\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_interfaces::api::{FraudCheck, FraudCheckCheckout, FraudCheckTransaction};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::{digest, hmac};\nuse time::OffsetDateTime;\nuse transformers as cybersourcedecisionmanager;\nuse url::Url;\n\n#[cfg(feature = \"frm\")]\nuse crate::types::{\n    FrmCheckout\n\n... [truncated 22291 chars] ...\n\n=\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic CYBERSOURCEDECISIONMANAGER_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Cybersourcedecisionmanager\",\n    description: \"Cybersourcedecisionmanager connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic CYBERSOURCEDECISIONMANAGER_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Cybersourcedecisionmanager {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CYBERSOURCEDECISIONMANAGER_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CYBERSOURCEDECISIONMANAGER_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CYBERSOURCEDECISIONMANAGER_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager.rs"}, {"query": "HMAC-SHA256 signature generation Cybersource", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{Checkout, Transaction},\n    router_request_types::fraud_check::{FraudCheckCheckoutData, FraudCheckTransactionData},\n    router_response_types::fraud_check::FraudCheckResponseData,\n};\n#[cfg(feature = \"frm\")]\nuse hyperswitch_interfaces::api::{FraudCheck, FraudCheckCheckout, FraudCheckTransaction};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::{digest, hmac};\nuse time::OffsetDateTime;\nuse transformers as cybersourcedecisionmanager;\nuse url::Url;\n\n#[cfg(feature = \"frm\")]\nuse crate::types::{\n    FrmCheckout\n\n... [truncated 22291 chars] ...\n\n=\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic CYBERSOURCEDECISIONMANAGER_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Cybersourcedecisionmanager\",\n    description: \"Cybersourcedecisionmanager connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic CYBERSOURCEDECISIONMANAGER_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Cybersourcedecisionmanager {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CYBERSOURCEDECISIONMANAGER_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CYBERSOURCEDECISIONMANAGER_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CYBERSOURCEDECISIONMANAGER_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager.rs", "file": "crates__hyperswitch_connectors__src__connectors__cybersourcedecisionmanager.rs"}, {"query": "Chargebee connector implementation hyperswitch", "code": "pub mod transformers;\n\nuse api_models::subscription::SubscriptionItemType;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{revenue_recovery, router_data_v2::RouterDataV2};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::flow_common_types::{\n        GetSubscriptionItemPricesData, GetSubscriptionItemsData, SubscriptionCreateData,\n        SubscriptionCustomerData,\n    },\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery::InvoiceRecordBack,\n        subscriptions::{\n            GetSubscriptionEstimate, GetSubscriptionItemPrices, GetSubscriptionItems,\n            SubscriptionCancel, SubscriptionCreate, SubscriptionPause, SubscriptionResume,\n        },\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        revenue_recovery::InvoiceRecordBackRequest,\n        subscriptions::{\n            GetSubscriptionEstimateRequest, GetSubscriptionItemPricesRequest,\n            GetSubscriptionItemsRequest, SubscriptionCancelRequest, SubscriptionCreateRequest,\n            SubscriptionPauseRequest, SubscriptionResumeRequest,\n        },\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n  \n\n... [truncated 31275 chars] ...\n\nce: chargebee_mit_data.first_invoice,\n            },\n        )\n    }\n}\n\nstatic CHARGEBEE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Chargebee\",\n    description: \"Chargebee is a Revenue Growth Management (RGM) platform that helps subscription businesses manage subscriptions, billing, revenue recognition, collections, and customer retention, essentially streamlining the entire subscription lifecycle.\",\n    connector_type: enums::HyperswitchConnectorCategory::RevenueGrowthManagementPlatform,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic CHARGEBEE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Chargebee {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHARGEBEE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHARGEBEE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__chargebee.rs", "file": "crates__hyperswitch_connectors__src__connectors__chargebee.rs"}, {"query": "Chargebee struct definition", "code": "pub mod transformers;\n\nuse api_models::subscription::SubscriptionItemType;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{revenue_recovery, router_data_v2::RouterDataV2};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::flow_common_types::{\n        GetSubscriptionItemPricesData, GetSubscriptionItemsData, SubscriptionCreateData,\n        SubscriptionCustomerData,\n    },\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery::InvoiceRecordBack,\n        subscriptions::{\n            GetSubscriptionEstimate, GetSubscriptionItemPrices, GetSubscriptionItems,\n            SubscriptionCancel, SubscriptionCreate, SubscriptionPause, SubscriptionResume,\n        },\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        revenue_recovery::InvoiceRecordBackRequest,\n        subscriptions::{\n            GetSubscriptionEstimateRequest, GetSubscriptionItemPricesRequest,\n            GetSubscriptionItemsRequest, SubscriptionCancelRequest, SubscriptionCreateRequest,\n            SubscriptionPauseRequest, SubscriptionResumeRequest,\n        },\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n  \n\n... [truncated 31275 chars] ...\n\nce: chargebee_mit_data.first_invoice,\n            },\n        )\n    }\n}\n\nstatic CHARGEBEE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Chargebee\",\n    description: \"Chargebee is a Revenue Growth Management (RGM) platform that helps subscription businesses manage subscriptions, billing, revenue recognition, collections, and customer retention, essentially streamlining the entire subscription lifecycle.\",\n    connector_type: enums::HyperswitchConnectorCategory::RevenueGrowthManagementPlatform,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic CHARGEBEE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Chargebee {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHARGEBEE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHARGEBEE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__chargebee.rs", "file": "crates__hyperswitch_connectors__src__connectors__chargebee.rs"}, {"query": "how to implement Chargebee webhook handler", "code": "pub mod transformers;\n\nuse api_models::subscription::SubscriptionItemType;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{revenue_recovery, router_data_v2::RouterDataV2};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::flow_common_types::{\n        GetSubscriptionItemPricesData, GetSubscriptionItemsData, SubscriptionCreateData,\n        SubscriptionCustomerData,\n    },\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery::InvoiceRecordBack,\n        subscriptions::{\n            GetSubscriptionEstimate, GetSubscriptionItemPrices, GetSubscriptionItems,\n            SubscriptionCancel, SubscriptionCreate, SubscriptionPause, SubscriptionResume,\n        },\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        revenue_recovery::InvoiceRecordBackRequest,\n        subscriptions::{\n            GetSubscriptionEstimateRequest, GetSubscriptionItemPricesRequest,\n            GetSubscriptionItemsRequest, SubscriptionCancelRequest, SubscriptionCreateRequest,\n            SubscriptionPauseRequest, SubscriptionResumeRequest,\n        },\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n  \n\n... [truncated 31275 chars] ...\n\nce: chargebee_mit_data.first_invoice,\n            },\n        )\n    }\n}\n\nstatic CHARGEBEE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Chargebee\",\n    description: \"Chargebee is a Revenue Growth Management (RGM) platform that helps subscription businesses manage subscriptions, billing, revenue recognition, collections, and customer retention, essentially streamlining the entire subscription lifecycle.\",\n    connector_type: enums::HyperswitchConnectorCategory::RevenueGrowthManagementPlatform,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic CHARGEBEE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Chargebee {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHARGEBEE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHARGEBEE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__chargebee.rs", "file": "crates__hyperswitch_connectors__src__connectors__chargebee.rs"}, {"query": "Chargebee subscription lifecycle integration", "code": "pub mod transformers;\n\nuse api_models::subscription::SubscriptionItemType;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{revenue_recovery, router_data_v2::RouterDataV2};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::flow_common_types::{\n        GetSubscriptionItemPricesData, GetSubscriptionItemsData, SubscriptionCreateData,\n        SubscriptionCustomerData,\n    },\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery::InvoiceRecordBack,\n        subscriptions::{\n            GetSubscriptionEstimate, GetSubscriptionItemPrices, GetSubscriptionItems,\n            SubscriptionCancel, SubscriptionCreate, SubscriptionPause, SubscriptionResume,\n        },\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        revenue_recovery::InvoiceRecordBackRequest,\n        subscriptions::{\n            GetSubscriptionEstimateRequest, GetSubscriptionItemPricesRequest,\n            GetSubscriptionItemsRequest, SubscriptionCancelRequest, SubscriptionCreateRequest,\n            SubscriptionPauseRequest, SubscriptionResumeRequest,\n        },\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n  \n\n... [truncated 31275 chars] ...\n\nce: chargebee_mit_data.first_invoice,\n            },\n        )\n    }\n}\n\nstatic CHARGEBEE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Chargebee\",\n    description: \"Chargebee is a Revenue Growth Management (RGM) platform that helps subscription businesses manage subscriptions, billing, revenue recognition, collections, and customer retention, essentially streamlining the entire subscription lifecycle.\",\n    connector_type: enums::HyperswitchConnectorCategory::RevenueGrowthManagementPlatform,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic CHARGEBEE_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] = [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Chargebee {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHARGEBEE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHARGEBEE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__chargebee.rs", "file": "crates__hyperswitch_connectors__src__connectors__chargebee.rs"}, {"query": "Noon payment connector implementation", "code": "use common_enums::enums::{self, AttemptStatus};\nuse common_utils::{ext_traits::Encode, pii, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::{MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, GooglePayWalletData, PaymentsAuthorizeRequestData,\n        RevokeMandateRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\n#[derive(Debug, Serialize)]\npub struct NoonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    pub mandate_amount: Option<StringMajorUnit>,\n}\n\nimpl<T> From<(StringMajorUnit, T, Option<StringMajorUnit>)> for NoonRouterData<T> {\n    fn from(\n        (amount, router_data, mandate_amount): (StringMajorUnit, T, Option<StringMajorUnit>),\n    ) -> Self {\n        Self {\n            amount,\n            router_data,\n            mandate_amount,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonChannels {\n    Web,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonSubscriptionType {\n    Unscheduled,\n}\n\n#\n\n... [truncated 32153 chars] ...\n\nbject {\n    pub order_status: NoonPaymentStatus,\n    pub order_id: u64,\n}\n\n/// This from will ensure that webhook body would be properly parsed into PSync response\nimpl From<NoonWebhookObject> for NoonPaymentsResponse {\n    fn from(value: NoonWebhookObject) -> Self {\n        Self {\n            result: NoonPaymentsResponseResult {\n                order: NoonPaymentsOrderResponse {\n                    status: value.order_status,\n                    id: value.order_id,\n                    //For successful payments Noon Always populates error_code as 0.\n                    error_code: 0,\n                    error_message: None,\n                    reference: None,\n                },\n                checkout_data: None,\n                subscription: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonErrorResponse {\n    pub result_code: u32,\n    pub message: String,\n    pub class_description: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs"}, {"query": "NoonRouterData struct", "code": "use common_enums::enums::{self, AttemptStatus};\nuse common_utils::{ext_traits::Encode, pii, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::{MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, GooglePayWalletData, PaymentsAuthorizeRequestData,\n        RevokeMandateRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\n#[derive(Debug, Serialize)]\npub struct NoonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    pub mandate_amount: Option<StringMajorUnit>,\n}\n\nimpl<T> From<(StringMajorUnit, T, Option<StringMajorUnit>)> for NoonRouterData<T> {\n    fn from(\n        (amount, router_data, mandate_amount): (StringMajorUnit, T, Option<StringMajorUnit>),\n    ) -> Self {\n        Self {\n            amount,\n            router_data,\n            mandate_amount,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonChannels {\n    Web,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonSubscriptionType {\n    Unscheduled,\n}\n\n#\n\n... [truncated 32153 chars] ...\n\nbject {\n    pub order_status: NoonPaymentStatus,\n    pub order_id: u64,\n}\n\n/// This from will ensure that webhook body would be properly parsed into PSync response\nimpl From<NoonWebhookObject> for NoonPaymentsResponse {\n    fn from(value: NoonWebhookObject) -> Self {\n        Self {\n            result: NoonPaymentsResponseResult {\n                order: NoonPaymentsOrderResponse {\n                    status: value.order_status,\n                    id: value.order_id,\n                    //For successful payments Noon Always populates error_code as 0.\n                    error_code: 0,\n                    error_message: None,\n                    reference: None,\n                },\n                checkout_data: None,\n                subscription: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonErrorResponse {\n    pub result_code: u32,\n    pub message: String,\n    pub class_description: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs"}, {"query": "how to handle Noon webhook events", "code": "use common_enums::enums::{self, AttemptStatus};\nuse common_utils::{ext_traits::Encode, pii, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::{MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, GooglePayWalletData, PaymentsAuthorizeRequestData,\n        RevokeMandateRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\n#[derive(Debug, Serialize)]\npub struct NoonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    pub mandate_amount: Option<StringMajorUnit>,\n}\n\nimpl<T> From<(StringMajorUnit, T, Option<StringMajorUnit>)> for NoonRouterData<T> {\n    fn from(\n        (amount, router_data, mandate_amount): (StringMajorUnit, T, Option<StringMajorUnit>),\n    ) -> Self {\n        Self {\n            amount,\n            router_data,\n            mandate_amount,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonChannels {\n    Web,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonSubscriptionType {\n    Unscheduled,\n}\n\n#\n\n... [truncated 32153 chars] ...\n\nbject {\n    pub order_status: NoonPaymentStatus,\n    pub order_id: u64,\n}\n\n/// This from will ensure that webhook body would be properly parsed into PSync response\nimpl From<NoonWebhookObject> for NoonPaymentsResponse {\n    fn from(value: NoonWebhookObject) -> Self {\n        Self {\n            result: NoonPaymentsResponseResult {\n                order: NoonPaymentsOrderResponse {\n                    status: value.order_status,\n                    id: value.order_id,\n                    //For successful payments Noon Always populates error_code as 0.\n                    error_code: 0,\n                    error_message: None,\n                    reference: None,\n                },\n                checkout_data: None,\n                subscription: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonErrorResponse {\n    pub result_code: u32,\n    pub message: String,\n    pub class_description: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs"}, {"query": "Noon mandate revoke request data", "code": "use common_enums::enums::{self, AttemptStatus};\nuse common_utils::{ext_traits::Encode, pii, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::{MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, GooglePayWalletData, PaymentsAuthorizeRequestData,\n        RevokeMandateRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\n#[derive(Debug, Serialize)]\npub struct NoonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    pub mandate_amount: Option<StringMajorUnit>,\n}\n\nimpl<T> From<(StringMajorUnit, T, Option<StringMajorUnit>)> for NoonRouterData<T> {\n    fn from(\n        (amount, router_data, mandate_amount): (StringMajorUnit, T, Option<StringMajorUnit>),\n    ) -> Self {\n        Self {\n            amount,\n            router_data,\n            mandate_amount,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonChannels {\n    Web,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonSubscriptionType {\n    Unscheduled,\n}\n\n#\n\n... [truncated 32153 chars] ...\n\nbject {\n    pub order_status: NoonPaymentStatus,\n    pub order_id: u64,\n}\n\n/// This from will ensure that webhook body would be properly parsed into PSync response\nimpl From<NoonWebhookObject> for NoonPaymentsResponse {\n    fn from(value: NoonWebhookObject) -> Self {\n        Self {\n            result: NoonPaymentsResponseResult {\n                order: NoonPaymentsOrderResponse {\n                    status: value.order_status,\n                    id: value.order_id,\n                    //For successful payments Noon Always populates error_code as 0.\n                    error_code: 0,\n                    error_message: None,\n                    reference: None,\n                },\n                checkout_data: None,\n                subscription: None,\n            },\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonErrorResponse {\n    pub result_code: u32,\n    pub message: String,\n    pub class_description: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs"}, {"query": "Archipel payment gateway integration", "code": "use bytes::Bytes;\nuse common_enums::{\n    self, AttemptStatus, AuthorizationStatus, CaptureMethod, Currency, FutureUsage,\n    PaymentMethodStatus, RefundStatus,\n};\nuse common_utils::{date_time, ext_traits::Encode, pii, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{Card, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        AuthenticationData, PaymentsIncrementalAuthorizationData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressData, AddressDetailsData, CardData, CardIssuer, PaymentsAuthorizeRequestData,\n        RouterData as _,\n    },\n};\n\nconst THREE_DS_MAX_SUPPORTED_VERSION: &str = \"2.2.0\";\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\n#[serde(transparent)]\npub struct ArchipelTenantId(pub String);\n\nimpl From<String> for ArchipelTenantId {\n    fn from(value: String) -> Self {\n        Self(value)\n    }\n}\n\npub struct ArchipelRouterData<T> {\n    pub amount: MinorUnit,\n    pub tenant_id: ArchipelTenantId,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, ArchipelTenantId, T)> for ArchipelRouterData<T> {\n    fn from((am\n\n... [truncated 47271 chars] ...\n\nhipelErrorMessageWithHttpCode::new(error, item.http_code).into()),\n        };\n\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n\nimpl From<ArchipelErrorMessageWithHttpCode> for ErrorResponse {\n    fn from(\n        ArchipelErrorMessageWithHttpCode {\n            error_message,\n            http_code,\n        }: ArchipelErrorMessageWithHttpCode,\n    ) -> Self {\n        Self {\n            status_code: http_code,\n            code: error_message.code,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            message: error_message\n                .description\n                .clone()\n                .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n            reason: error_message.description,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs"}, {"query": "ArchipelRouterData struct definition", "code": "use bytes::Bytes;\nuse common_enums::{\n    self, AttemptStatus, AuthorizationStatus, CaptureMethod, Currency, FutureUsage,\n    PaymentMethodStatus, RefundStatus,\n};\nuse common_utils::{date_time, ext_traits::Encode, pii, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{Card, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        AuthenticationData, PaymentsIncrementalAuthorizationData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressData, AddressDetailsData, CardData, CardIssuer, PaymentsAuthorizeRequestData,\n        RouterData as _,\n    },\n};\n\nconst THREE_DS_MAX_SUPPORTED_VERSION: &str = \"2.2.0\";\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\n#[serde(transparent)]\npub struct ArchipelTenantId(pub String);\n\nimpl From<String> for ArchipelTenantId {\n    fn from(value: String) -> Self {\n        Self(value)\n    }\n}\n\npub struct ArchipelRouterData<T> {\n    pub amount: MinorUnit,\n    pub tenant_id: ArchipelTenantId,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, ArchipelTenantId, T)> for ArchipelRouterData<T> {\n    fn from((am\n\n... [truncated 47271 chars] ...\n\nhipelErrorMessageWithHttpCode::new(error, item.http_code).into()),\n        };\n\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n\nimpl From<ArchipelErrorMessageWithHttpCode> for ErrorResponse {\n    fn from(\n        ArchipelErrorMessageWithHttpCode {\n            error_message,\n            http_code,\n        }: ArchipelErrorMessageWithHttpCode,\n    ) -> Self {\n        Self {\n            status_code: http_code,\n            code: error_message.code,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            message: error_message\n                .description\n                .clone()\n                .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n            reason: error_message.description,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs"}, {"query": "how to implement Archipel connector", "code": "use bytes::Bytes;\nuse common_enums::{\n    self, AttemptStatus, AuthorizationStatus, CaptureMethod, Currency, FutureUsage,\n    PaymentMethodStatus, RefundStatus,\n};\nuse common_utils::{date_time, ext_traits::Encode, pii, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{Card, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        AuthenticationData, PaymentsIncrementalAuthorizationData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressData, AddressDetailsData, CardData, CardIssuer, PaymentsAuthorizeRequestData,\n        RouterData as _,\n    },\n};\n\nconst THREE_DS_MAX_SUPPORTED_VERSION: &str = \"2.2.0\";\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\n#[serde(transparent)]\npub struct ArchipelTenantId(pub String);\n\nimpl From<String> for ArchipelTenantId {\n    fn from(value: String) -> Self {\n        Self(value)\n    }\n}\n\npub struct ArchipelRouterData<T> {\n    pub amount: MinorUnit,\n    pub tenant_id: ArchipelTenantId,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, ArchipelTenantId, T)> for ArchipelRouterData<T> {\n    fn from((am\n\n... [truncated 47271 chars] ...\n\nhipelErrorMessageWithHttpCode::new(error, item.http_code).into()),\n        };\n\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n\nimpl From<ArchipelErrorMessageWithHttpCode> for ErrorResponse {\n    fn from(\n        ArchipelErrorMessageWithHttpCode {\n            error_message,\n            http_code,\n        }: ArchipelErrorMessageWithHttpCode,\n    ) -> Self {\n        Self {\n            status_code: http_code,\n            code: error_message.code,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            message: error_message\n                .description\n                .clone()\n                .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n            reason: error_message.description,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs"}, {"query": "ArchipelRefundResponse transformation", "code": "use bytes::Bytes;\nuse common_enums::{\n    self, AttemptStatus, AuthorizationStatus, CaptureMethod, Currency, FutureUsage,\n    PaymentMethodStatus, RefundStatus,\n};\nuse common_utils::{date_time, ext_traits::Encode, pii, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{Card, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        AuthenticationData, PaymentsIncrementalAuthorizationData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressData, AddressDetailsData, CardData, CardIssuer, PaymentsAuthorizeRequestData,\n        RouterData as _,\n    },\n};\n\nconst THREE_DS_MAX_SUPPORTED_VERSION: &str = \"2.2.0\";\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]\n#[serde(transparent)]\npub struct ArchipelTenantId(pub String);\n\nimpl From<String> for ArchipelTenantId {\n    fn from(value: String) -> Self {\n        Self(value)\n    }\n}\n\npub struct ArchipelRouterData<T> {\n    pub amount: MinorUnit,\n    pub tenant_id: ArchipelTenantId,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, ArchipelTenantId, T)> for ArchipelRouterData<T> {\n    fn from((am\n\n... [truncated 47271 chars] ...\n\nhipelErrorMessageWithHttpCode::new(error, item.http_code).into()),\n        };\n\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n\nimpl From<ArchipelErrorMessageWithHttpCode> for ErrorResponse {\n    fn from(\n        ArchipelErrorMessageWithHttpCode {\n            error_message,\n            http_code,\n        }: ArchipelErrorMessageWithHttpCode,\n    ) -> Self {\n        Self {\n            status_code: http_code,\n            code: error_message.code,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            message: error_message\n                .description\n                .clone()\n                .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n            reason: error_message.description,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs"}, {"query": "Payme payment connector implementation", "code": "use std::collections::HashMap;\n\nuse api_models::enums::{AuthenticationType, PaymentMethod};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    pii,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::{Execute, Void},\n    router_request_types::{\n        CreateOrderRequestData, PaymentsCancelData, PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, PreprocessingResponseId, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsCancelResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSyncRequestData, RouterData as OtherRouterData,\n    },\n};\n\nconst LANGUAGE: &str = \"en\";\n\n#[derive(Debug, Serialize)]\npub struct PaymeRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PaymeRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data:\n\n... [truncated 57034 chars] ...\n\nrror_details,\n        }\n    }\n}\n\n/// This try_from will ensure that webhook body would be properly parsed into RSync response\nimpl From<WebhookEventDataResource> for PaymeQueryTransactionResponse {\n    fn from(value: WebhookEventDataResource) -> Self {\n        let item = TransactionQuery {\n            sale_status: value.sale_status,\n            payme_transaction_id: value.payme_transaction_id,\n        };\n        Self { items: vec![item] }\n    }\n}\n\nimpl From<NotifyType> for api_models::webhooks::IncomingWebhookEvent {\n    fn from(value: NotifyType) -> Self {\n        match value {\n            NotifyType::SaleComplete => Self::PaymentIntentSuccess,\n            NotifyType::Refund => Self::RefundSuccess,\n            NotifyType::SaleFailure => Self::PaymentIntentFailure,\n            NotifyType::SaleChargeback => Self::DisputeOpened,\n            NotifyType::SaleChargebackRefund => Self::DisputeWon,\n            NotifyType::SaleAuthorized => Self::EventNotSupported,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs"}, {"query": "PaymeRouterData struct", "code": "use std::collections::HashMap;\n\nuse api_models::enums::{AuthenticationType, PaymentMethod};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    pii,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::{Execute, Void},\n    router_request_types::{\n        CreateOrderRequestData, PaymentsCancelData, PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, PreprocessingResponseId, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsCancelResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSyncRequestData, RouterData as OtherRouterData,\n    },\n};\n\nconst LANGUAGE: &str = \"en\";\n\n#[derive(Debug, Serialize)]\npub struct PaymeRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PaymeRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data:\n\n... [truncated 57034 chars] ...\n\nrror_details,\n        }\n    }\n}\n\n/// This try_from will ensure that webhook body would be properly parsed into RSync response\nimpl From<WebhookEventDataResource> for PaymeQueryTransactionResponse {\n    fn from(value: WebhookEventDataResource) -> Self {\n        let item = TransactionQuery {\n            sale_status: value.sale_status,\n            payme_transaction_id: value.payme_transaction_id,\n        };\n        Self { items: vec![item] }\n    }\n}\n\nimpl From<NotifyType> for api_models::webhooks::IncomingWebhookEvent {\n    fn from(value: NotifyType) -> Self {\n        match value {\n            NotifyType::SaleComplete => Self::PaymentIntentSuccess,\n            NotifyType::Refund => Self::RefundSuccess,\n            NotifyType::SaleFailure => Self::PaymentIntentFailure,\n            NotifyType::SaleChargeback => Self::DisputeOpened,\n            NotifyType::SaleChargebackRefund => Self::DisputeWon,\n            NotifyType::SaleAuthorized => Self::EventNotSupported,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs"}, {"query": "how to process Payme refunds", "code": "use std::collections::HashMap;\n\nuse api_models::enums::{AuthenticationType, PaymentMethod};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    pii,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::{Execute, Void},\n    router_request_types::{\n        CreateOrderRequestData, PaymentsCancelData, PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, PreprocessingResponseId, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsCancelResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSyncRequestData, RouterData as OtherRouterData,\n    },\n};\n\nconst LANGUAGE: &str = \"en\";\n\n#[derive(Debug, Serialize)]\npub struct PaymeRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PaymeRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data:\n\n... [truncated 57034 chars] ...\n\nrror_details,\n        }\n    }\n}\n\n/// This try_from will ensure that webhook body would be properly parsed into RSync response\nimpl From<WebhookEventDataResource> for PaymeQueryTransactionResponse {\n    fn from(value: WebhookEventDataResource) -> Self {\n        let item = TransactionQuery {\n            sale_status: value.sale_status,\n            payme_transaction_id: value.payme_transaction_id,\n        };\n        Self { items: vec![item] }\n    }\n}\n\nimpl From<NotifyType> for api_models::webhooks::IncomingWebhookEvent {\n    fn from(value: NotifyType) -> Self {\n        match value {\n            NotifyType::SaleComplete => Self::PaymentIntentSuccess,\n            NotifyType::Refund => Self::RefundSuccess,\n            NotifyType::SaleFailure => Self::PaymentIntentFailure,\n            NotifyType::SaleChargeback => Self::DisputeOpened,\n            NotifyType::SaleChargebackRefund => Self::DisputeWon,\n            NotifyType::SaleAuthorized => Self::EventNotSupported,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs"}, {"query": "Payme webhook event handling", "code": "use std::collections::HashMap;\n\nuse api_models::enums::{AuthenticationType, PaymentMethod};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    pii,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::{Execute, Void},\n    router_request_types::{\n        CreateOrderRequestData, PaymentsCancelData, PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, PreprocessingResponseId, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsCancelResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSyncRequestData, RouterData as OtherRouterData,\n    },\n};\n\nconst LANGUAGE: &str = \"en\";\n\n#[derive(Debug, Serialize)]\npub struct PaymeRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PaymeRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data:\n\n... [truncated 57034 chars] ...\n\nrror_details,\n        }\n    }\n}\n\n/// This try_from will ensure that webhook body would be properly parsed into RSync response\nimpl From<WebhookEventDataResource> for PaymeQueryTransactionResponse {\n    fn from(value: WebhookEventDataResource) -> Self {\n        let item = TransactionQuery {\n            sale_status: value.sale_status,\n            payme_transaction_id: value.payme_transaction_id,\n        };\n        Self { items: vec![item] }\n    }\n}\n\nimpl From<NotifyType> for api_models::webhooks::IncomingWebhookEvent {\n    fn from(value: NotifyType) -> Self {\n        match value {\n            NotifyType::SaleComplete => Self::PaymentIntentSuccess,\n            NotifyType::Refund => Self::RefundSuccess,\n            NotifyType::SaleFailure => Self::PaymentIntentFailure,\n            NotifyType::SaleChargeback => Self::DisputeOpened,\n            NotifyType::SaleChargebackRefund => Self::DisputeWon,\n            NotifyType::SaleAuthorized => Self::EventNotSupported,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs"}, {"query": "Mollie payment gateway integration", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, PeekInterface};\nuse transformers as mollie;\n\n// use self::mollie::{webhook_headers, MollieWebhookBodyEventType};\nuse crate::{\n    constants\n\n... [truncated 35459 chars] ...\n\nEventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Mollie {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*MOLLIE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MOLLIE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*MOLLIE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mollie.rs", "file": "crates__hyperswitch_connectors__src__connectors__mollie.rs"}, {"query": "hyperswitch mollie connector implementation", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, PeekInterface};\nuse transformers as mollie;\n\n// use self::mollie::{webhook_headers, MollieWebhookBodyEventType};\nuse crate::{\n    constants\n\n... [truncated 35459 chars] ...\n\nEventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Mollie {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*MOLLIE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MOLLIE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*MOLLIE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mollie.rs", "file": "crates__hyperswitch_connectors__src__connectors__mollie.rs"}, {"query": "how to add new payment gateway to hyperswitch", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, PeekInterface};\nuse transformers as mollie;\n\n// use self::mollie::{webhook_headers, MollieWebhookBodyEventType};\nuse crate::{\n    constants\n\n... [truncated 35459 chars] ...\n\nEventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Mollie {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*MOLLIE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MOLLIE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*MOLLIE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mollie.rs", "file": "crates__hyperswitch_connectors__src__connectors__mollie.rs"}, {"query": "mollie payment method types hyperswitch", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, PeekInterface};\nuse transformers as mollie;\n\n// use self::mollie::{webhook_headers, MollieWebhookBodyEventType};\nuse crate::{\n    constants\n\n... [truncated 35459 chars] ...\n\nEventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Mollie {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*MOLLIE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*MOLLIE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*MOLLIE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    #[cfg(feature = \"v1\")]\n    fn should_call_connector_customer(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        matches!(\n            payment_attempt.setup_future_usage_applied,\n            Some(enums::FutureUsage::OffSession)\n        ) && payment_attempt.customer_acceptance.is_some()\n            && matches!(\n                payment_attempt.payment_method,\n                Some(enums::PaymentMethod::Card)\n            )\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mollie.rs", "file": "crates__hyperswitch_connectors__src__connectors__mollie.rs"}, {"query": "how to integrate GoCardless with Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as gocardless;\n\nuse crate::{\n    constants::headers,\n  \n\n... [truncated 31679 chars] ...\n\ncluding recurring payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic GOCARDLESS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Gocardless {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GOCARDLESS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GOCARDLESS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GOCARDLESS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gocardless.rs", "file": "crates__hyperswitch_connectors__src__connectors__gocardless.rs"}, {"query": "Gocardless connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as gocardless;\n\nuse crate::{\n    constants::headers,\n  \n\n... [truncated 31679 chars] ...\n\ncluding recurring payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic GOCARDLESS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Gocardless {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GOCARDLESS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GOCARDLESS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GOCARDLESS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gocardless.rs", "file": "crates__hyperswitch_connectors__src__connectors__gocardless.rs"}, {"query": "implement payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as gocardless;\n\nuse crate::{\n    constants::headers,\n  \n\n... [truncated 31679 chars] ...\n\ncluding recurring payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic GOCARDLESS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Gocardless {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GOCARDLESS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GOCARDLESS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GOCARDLESS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gocardless.rs", "file": "crates__hyperswitch_connectors__src__connectors__gocardless.rs"}, {"query": "GoCardless webhook handling", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as gocardless;\n\nuse crate::{\n    constants::headers,\n  \n\n... [truncated 31679 chars] ...\n\ncluding recurring payments.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic GOCARDLESS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Gocardless {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GOCARDLESS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GOCARDLESS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GOCARDLESS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__gocardless.rs", "file": "crates__hyperswitch_connectors__src__connectors__gocardless.rs"}, {"query": "Netcetera 3DS protocol types", "code": "use std::collections::HashMap;\n\nuse common_utils::{pii::Email, types::SemanticVersion};\nuse hyperswitch_domain_models::router_request_types::{\n    authentication::MessageCategory, BrowserInformation,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::ExposeInterface;\nuse serde::{Deserialize, Serialize};\nuse unidecode::unidecode;\n\nuse crate::utils::{AddressDetailsData as _, PhoneDetailsData as _};\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\n#[serde(untagged)]\npub enum SingleOrListElement<T> {\n    Single(T),\n    List(Vec<T>),\n}\n\nimpl<T> SingleOrListElement<T> {\n    fn get_version_checked(message_version: SemanticVersion, value: T) -> Self {\n        if message_version.get_major() >= 2 && message_version.get_minor() >= 3 {\n            Self::List(vec![value])\n        } else {\n            Self::Single(value)\n        }\n    }\n}\n\nimpl<T> SingleOrListElement<T> {\n    pub fn new_single(value: T) -> Self {\n        Self::Single(value)\n    }\n\n    pub fn new_list(value: Vec<T>) -> Self {\n        Self::List(value)\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub enum NetceteraDeviceChannel {\n    #[serde(rename = \"01\")]\n    AppBased,\n    #[serde(rename = \"02\")]\n    Browser,\n    #[serde(rename = \"03\")]\n    ThreeDsRequestorInitiated,\n}\n\nimpl From<api_models::payments::DeviceChannel> for NetceteraDeviceChannel {\n    fn from(value: api_models::payments::DeviceChannel) -> Self {\n        match value {\n            api_models::payments::DeviceChannel::App => Self::AppBased,\n            api_models::payments::DeviceChannel::Browser => Self::Browser,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub enum NetceteraMessageCategory {\n    #[serde(rename = \"01\")]\n    PaymentAuthentication,\n    #[serde(rename = \"02\")]\n    NonPaymentAuthentication,\n}\n\nimpl From<MessageCategory> for NetceteraMessageCategory {\n    fn from(value: MessageCategory) -> Self {\n        match value {\n            MessageCategory::NonPayment => Self::NonPaymentAuthentication,\n       \n\n... [truncated 80543 chars] ...\n\ne Data.\n    #[serde(rename = \"08\")]\n    SRCAssuranceData,\n    /// Additionally, 80-99 can be used for PS-specific values, regardless of protocol version.\n    #[serde(untagged)]\n    PsSpecificValue(String),\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DeviceRenderingOptionsSupported {\n    pub sdk_interface: SdkInterface,\n    /// For Native UI SDK Interface accepted values are 01-04 and for HTML UI accepted values are 01-05.\n    pub sdk_ui_type: Vec<SdkUiType>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SdkInterface {\n    #[serde(rename = \"01\")]\n    Native,\n    #[serde(rename = \"02\")]\n    Html,\n    #[serde(rename = \"03\")]\n    Both,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SdkUiType {\n    #[serde(rename = \"01\")]\n    Text,\n    #[serde(rename = \"02\")]\n    SingleSelect,\n    #[serde(rename = \"03\")]\n    MultiSelect,\n    #[serde(rename = \"04\")]\n    Oob,\n    #[serde(rename = \"05\")]\n    HtmlOther,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__netcetera__netcetera_types.rs", "file": "crates__hyperswitch_connectors__src__connectors__netcetera__netcetera_types.rs"}, {"query": "NetceteraDeviceChannel enum", "code": "use std::collections::HashMap;\n\nuse common_utils::{pii::Email, types::SemanticVersion};\nuse hyperswitch_domain_models::router_request_types::{\n    authentication::MessageCategory, BrowserInformation,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::ExposeInterface;\nuse serde::{Deserialize, Serialize};\nuse unidecode::unidecode;\n\nuse crate::utils::{AddressDetailsData as _, PhoneDetailsData as _};\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\n#[serde(untagged)]\npub enum SingleOrListElement<T> {\n    Single(T),\n    List(Vec<T>),\n}\n\nimpl<T> SingleOrListElement<T> {\n    fn get_version_checked(message_version: SemanticVersion, value: T) -> Self {\n        if message_version.get_major() >= 2 && message_version.get_minor() >= 3 {\n            Self::List(vec![value])\n        } else {\n            Self::Single(value)\n        }\n    }\n}\n\nimpl<T> SingleOrListElement<T> {\n    pub fn new_single(value: T) -> Self {\n        Self::Single(value)\n    }\n\n    pub fn new_list(value: Vec<T>) -> Self {\n        Self::List(value)\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub enum NetceteraDeviceChannel {\n    #[serde(rename = \"01\")]\n    AppBased,\n    #[serde(rename = \"02\")]\n    Browser,\n    #[serde(rename = \"03\")]\n    ThreeDsRequestorInitiated,\n}\n\nimpl From<api_models::payments::DeviceChannel> for NetceteraDeviceChannel {\n    fn from(value: api_models::payments::DeviceChannel) -> Self {\n        match value {\n            api_models::payments::DeviceChannel::App => Self::AppBased,\n            api_models::payments::DeviceChannel::Browser => Self::Browser,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub enum NetceteraMessageCategory {\n    #[serde(rename = \"01\")]\n    PaymentAuthentication,\n    #[serde(rename = \"02\")]\n    NonPaymentAuthentication,\n}\n\nimpl From<MessageCategory> for NetceteraMessageCategory {\n    fn from(value: MessageCategory) -> Self {\n        match value {\n            MessageCategory::NonPayment => Self::NonPaymentAuthentication,\n       \n\n... [truncated 80543 chars] ...\n\ne Data.\n    #[serde(rename = \"08\")]\n    SRCAssuranceData,\n    /// Additionally, 80-99 can be used for PS-specific values, regardless of protocol version.\n    #[serde(untagged)]\n    PsSpecificValue(String),\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DeviceRenderingOptionsSupported {\n    pub sdk_interface: SdkInterface,\n    /// For Native UI SDK Interface accepted values are 01-04 and for HTML UI accepted values are 01-05.\n    pub sdk_ui_type: Vec<SdkUiType>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SdkInterface {\n    #[serde(rename = \"01\")]\n    Native,\n    #[serde(rename = \"02\")]\n    Html,\n    #[serde(rename = \"03\")]\n    Both,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SdkUiType {\n    #[serde(rename = \"01\")]\n    Text,\n    #[serde(rename = \"02\")]\n    SingleSelect,\n    #[serde(rename = \"03\")]\n    MultiSelect,\n    #[serde(rename = \"04\")]\n    Oob,\n    #[serde(rename = \"05\")]\n    HtmlOther,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__netcetera__netcetera_types.rs", "file": "crates__hyperswitch_connectors__src__connectors__netcetera__netcetera_types.rs"}, {"query": "how to implement Netcetera connector", "code": "use std::collections::HashMap;\n\nuse common_utils::{pii::Email, types::SemanticVersion};\nuse hyperswitch_domain_models::router_request_types::{\n    authentication::MessageCategory, BrowserInformation,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::ExposeInterface;\nuse serde::{Deserialize, Serialize};\nuse unidecode::unidecode;\n\nuse crate::utils::{AddressDetailsData as _, PhoneDetailsData as _};\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\n#[serde(untagged)]\npub enum SingleOrListElement<T> {\n    Single(T),\n    List(Vec<T>),\n}\n\nimpl<T> SingleOrListElement<T> {\n    fn get_version_checked(message_version: SemanticVersion, value: T) -> Self {\n        if message_version.get_major() >= 2 && message_version.get_minor() >= 3 {\n            Self::List(vec![value])\n        } else {\n            Self::Single(value)\n        }\n    }\n}\n\nimpl<T> SingleOrListElement<T> {\n    pub fn new_single(value: T) -> Self {\n        Self::Single(value)\n    }\n\n    pub fn new_list(value: Vec<T>) -> Self {\n        Self::List(value)\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub enum NetceteraDeviceChannel {\n    #[serde(rename = \"01\")]\n    AppBased,\n    #[serde(rename = \"02\")]\n    Browser,\n    #[serde(rename = \"03\")]\n    ThreeDsRequestorInitiated,\n}\n\nimpl From<api_models::payments::DeviceChannel> for NetceteraDeviceChannel {\n    fn from(value: api_models::payments::DeviceChannel) -> Self {\n        match value {\n            api_models::payments::DeviceChannel::App => Self::AppBased,\n            api_models::payments::DeviceChannel::Browser => Self::Browser,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub enum NetceteraMessageCategory {\n    #[serde(rename = \"01\")]\n    PaymentAuthentication,\n    #[serde(rename = \"02\")]\n    NonPaymentAuthentication,\n}\n\nimpl From<MessageCategory> for NetceteraMessageCategory {\n    fn from(value: MessageCategory) -> Self {\n        match value {\n            MessageCategory::NonPayment => Self::NonPaymentAuthentication,\n       \n\n... [truncated 80543 chars] ...\n\ne Data.\n    #[serde(rename = \"08\")]\n    SRCAssuranceData,\n    /// Additionally, 80-99 can be used for PS-specific values, regardless of protocol version.\n    #[serde(untagged)]\n    PsSpecificValue(String),\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DeviceRenderingOptionsSupported {\n    pub sdk_interface: SdkInterface,\n    /// For Native UI SDK Interface accepted values are 01-04 and for HTML UI accepted values are 01-05.\n    pub sdk_ui_type: Vec<SdkUiType>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SdkInterface {\n    #[serde(rename = \"01\")]\n    Native,\n    #[serde(rename = \"02\")]\n    Html,\n    #[serde(rename = \"03\")]\n    Both,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SdkUiType {\n    #[serde(rename = \"01\")]\n    Text,\n    #[serde(rename = \"02\")]\n    SingleSelect,\n    #[serde(rename = \"03\")]\n    MultiSelect,\n    #[serde(rename = \"04\")]\n    Oob,\n    #[serde(rename = \"05\")]\n    HtmlOther,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__netcetera__netcetera_types.rs", "file": "crates__hyperswitch_connectors__src__connectors__netcetera__netcetera_types.rs"}, {"query": "EMV 3DS 2.3.1 request structure", "code": "use std::collections::HashMap;\n\nuse common_utils::{pii::Email, types::SemanticVersion};\nuse hyperswitch_domain_models::router_request_types::{\n    authentication::MessageCategory, BrowserInformation,\n};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::ExposeInterface;\nuse serde::{Deserialize, Serialize};\nuse unidecode::unidecode;\n\nuse crate::utils::{AddressDetailsData as _, PhoneDetailsData as _};\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\n#[serde(untagged)]\npub enum SingleOrListElement<T> {\n    Single(T),\n    List(Vec<T>),\n}\n\nimpl<T> SingleOrListElement<T> {\n    fn get_version_checked(message_version: SemanticVersion, value: T) -> Self {\n        if message_version.get_major() >= 2 && message_version.get_minor() >= 3 {\n            Self::List(vec![value])\n        } else {\n            Self::Single(value)\n        }\n    }\n}\n\nimpl<T> SingleOrListElement<T> {\n    pub fn new_single(value: T) -> Self {\n        Self::Single(value)\n    }\n\n    pub fn new_list(value: Vec<T>) -> Self {\n        Self::List(value)\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub enum NetceteraDeviceChannel {\n    #[serde(rename = \"01\")]\n    AppBased,\n    #[serde(rename = \"02\")]\n    Browser,\n    #[serde(rename = \"03\")]\n    ThreeDsRequestorInitiated,\n}\n\nimpl From<api_models::payments::DeviceChannel> for NetceteraDeviceChannel {\n    fn from(value: api_models::payments::DeviceChannel) -> Self {\n        match value {\n            api_models::payments::DeviceChannel::App => Self::AppBased,\n            api_models::payments::DeviceChannel::Browser => Self::Browser,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub enum NetceteraMessageCategory {\n    #[serde(rename = \"01\")]\n    PaymentAuthentication,\n    #[serde(rename = \"02\")]\n    NonPaymentAuthentication,\n}\n\nimpl From<MessageCategory> for NetceteraMessageCategory {\n    fn from(value: MessageCategory) -> Self {\n        match value {\n            MessageCategory::NonPayment => Self::NonPaymentAuthentication,\n       \n\n... [truncated 80543 chars] ...\n\ne Data.\n    #[serde(rename = \"08\")]\n    SRCAssuranceData,\n    /// Additionally, 80-99 can be used for PS-specific values, regardless of protocol version.\n    #[serde(untagged)]\n    PsSpecificValue(String),\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DeviceRenderingOptionsSupported {\n    pub sdk_interface: SdkInterface,\n    /// For Native UI SDK Interface accepted values are 01-04 and for HTML UI accepted values are 01-05.\n    pub sdk_ui_type: Vec<SdkUiType>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SdkInterface {\n    #[serde(rename = \"01\")]\n    Native,\n    #[serde(rename = \"02\")]\n    Html,\n    #[serde(rename = \"03\")]\n    Both,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SdkUiType {\n    #[serde(rename = \"01\")]\n    Text,\n    #[serde(rename = \"02\")]\n    SingleSelect,\n    #[serde(rename = \"03\")]\n    MultiSelect,\n    #[serde(rename = \"04\")]\n    Oob,\n    #[serde(rename = \"05\")]\n    HtmlOther,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__netcetera__netcetera_types.rs", "file": "crates__hyperswitch_connectors__src__connectors__netcetera__netcetera_types.rs"}, {"query": "Stripe Billing API request transformation", "code": "#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse common_enums::enums;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse common_utils::id_type;\nuse common_utils::{errors::CustomResult, ext_traits::ByteSliceExt, types::StringMinorUnit};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse hyperswitch_domain_models::revenue_recovery;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{\n    router_flow_types::revenue_recovery as recovery_router_flows,\n    router_request_types::revenue_recovery as recovery_request_types,\n    router_response_types::revenue_recovery as recovery_response_types,\n    types as recovery_router_data_types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{convert_uppercase, PaymentsAuthorizeRequestData},\n};\npub mod auth_headers {\n    pub const STRIPE_API_VERSION: &str = \"stripe-version\";\n    pub const STRIPE_VERSION: &str = \"2022-11-15\";\n}\n\n//TODO: Fill the struct with respective fields\npub struct StripebillingRouterData<T> {\n    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for StripebillingRouterData<T> {\n    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n  \n\n... [truncated 21511 chars] ...\n\n{\n            StripebillingCardNetwork::Visa => Self::Visa,\n            StripebillingCardNetwork::Mastercard => Self::Mastercard,\n            StripebillingCardNetwork::AmericanExpress => Self::AmericanExpress,\n            StripebillingCardNetwork::JCB => Self::JCB,\n            StripebillingCardNetwork::DinersClub => Self::DinersClub,\n            StripebillingCardNetwork::Discover => Self::Discover,\n            StripebillingCardNetwork::CartesBancaires => Self::CartesBancaires,\n            StripebillingCardNetwork::UnionPay => Self::UnionPay,\n            StripebillingCardNetwork::Interac => Self::Interac,\n            StripebillingCardNetwork::RuPay => Self::RuPay,\n            StripebillingCardNetwork::Maestro => Self::Maestro,\n            StripebillingCardNetwork::Star => Self::Star,\n            StripebillingCardNetwork::Pulse => Self::Pulse,\n            StripebillingCardNetwork::Accel => Self::Accel,\n            StripebillingCardNetwork::Nyce => Self::Nyce,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripebilling__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripebilling__transformers.rs"}, {"query": "StripebillingPaymentsRequest struct", "code": "#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse common_enums::enums;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse common_utils::id_type;\nuse common_utils::{errors::CustomResult, ext_traits::ByteSliceExt, types::StringMinorUnit};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse hyperswitch_domain_models::revenue_recovery;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{\n    router_flow_types::revenue_recovery as recovery_router_flows,\n    router_request_types::revenue_recovery as recovery_request_types,\n    router_response_types::revenue_recovery as recovery_response_types,\n    types as recovery_router_data_types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{convert_uppercase, PaymentsAuthorizeRequestData},\n};\npub mod auth_headers {\n    pub const STRIPE_API_VERSION: &str = \"stripe-version\";\n    pub const STRIPE_VERSION: &str = \"2022-11-15\";\n}\n\n//TODO: Fill the struct with respective fields\npub struct StripebillingRouterData<T> {\n    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for StripebillingRouterData<T> {\n    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n  \n\n... [truncated 21511 chars] ...\n\n{\n            StripebillingCardNetwork::Visa => Self::Visa,\n            StripebillingCardNetwork::Mastercard => Self::Mastercard,\n            StripebillingCardNetwork::AmericanExpress => Self::AmericanExpress,\n            StripebillingCardNetwork::JCB => Self::JCB,\n            StripebillingCardNetwork::DinersClub => Self::DinersClub,\n            StripebillingCardNetwork::Discover => Self::Discover,\n            StripebillingCardNetwork::CartesBancaires => Self::CartesBancaires,\n            StripebillingCardNetwork::UnionPay => Self::UnionPay,\n            StripebillingCardNetwork::Interac => Self::Interac,\n            StripebillingCardNetwork::RuPay => Self::RuPay,\n            StripebillingCardNetwork::Maestro => Self::Maestro,\n            StripebillingCardNetwork::Star => Self::Star,\n            StripebillingCardNetwork::Pulse => Self::Pulse,\n            StripebillingCardNetwork::Accel => Self::Accel,\n            StripebillingCardNetwork::Nyce => Self::Nyce,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripebilling__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripebilling__transformers.rs"}, {"query": "how to implement Stripe Billing refunds", "code": "#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse common_enums::enums;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse common_utils::id_type;\nuse common_utils::{errors::CustomResult, ext_traits::ByteSliceExt, types::StringMinorUnit};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse hyperswitch_domain_models::revenue_recovery;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{\n    router_flow_types::revenue_recovery as recovery_router_flows,\n    router_request_types::revenue_recovery as recovery_request_types,\n    router_response_types::revenue_recovery as recovery_response_types,\n    types as recovery_router_data_types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{convert_uppercase, PaymentsAuthorizeRequestData},\n};\npub mod auth_headers {\n    pub const STRIPE_API_VERSION: &str = \"stripe-version\";\n    pub const STRIPE_VERSION: &str = \"2022-11-15\";\n}\n\n//TODO: Fill the struct with respective fields\npub struct StripebillingRouterData<T> {\n    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for StripebillingRouterData<T> {\n    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n  \n\n... [truncated 21511 chars] ...\n\n{\n            StripebillingCardNetwork::Visa => Self::Visa,\n            StripebillingCardNetwork::Mastercard => Self::Mastercard,\n            StripebillingCardNetwork::AmericanExpress => Self::AmericanExpress,\n            StripebillingCardNetwork::JCB => Self::JCB,\n            StripebillingCardNetwork::DinersClub => Self::DinersClub,\n            StripebillingCardNetwork::Discover => Self::Discover,\n            StripebillingCardNetwork::CartesBancaires => Self::CartesBancaires,\n            StripebillingCardNetwork::UnionPay => Self::UnionPay,\n            StripebillingCardNetwork::Interac => Self::Interac,\n            StripebillingCardNetwork::RuPay => Self::RuPay,\n            StripebillingCardNetwork::Maestro => Self::Maestro,\n            StripebillingCardNetwork::Star => Self::Star,\n            StripebillingCardNetwork::Pulse => Self::Pulse,\n            StripebillingCardNetwork::Accel => Self::Accel,\n            StripebillingCardNetwork::Nyce => Self::Nyce,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripebilling__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripebilling__transformers.rs"}, {"query": "hyperswitch revenue recovery transformer", "code": "#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse common_enums::enums;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse common_utils::id_type;\nuse common_utils::{errors::CustomResult, ext_traits::ByteSliceExt, types::StringMinorUnit};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nuse hyperswitch_domain_models::revenue_recovery;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{\n    router_flow_types::revenue_recovery as recovery_router_flows,\n    router_request_types::revenue_recovery as recovery_request_types,\n    router_response_types::revenue_recovery as recovery_response_types,\n    types as recovery_router_data_types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{convert_uppercase, PaymentsAuthorizeRequestData},\n};\npub mod auth_headers {\n    pub const STRIPE_API_VERSION: &str = \"stripe-version\";\n    pub const STRIPE_VERSION: &str = \"2022-11-15\";\n}\n\n//TODO: Fill the struct with respective fields\npub struct StripebillingRouterData<T> {\n    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for StripebillingRouterData<T> {\n    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n  \n\n... [truncated 21511 chars] ...\n\n{\n            StripebillingCardNetwork::Visa => Self::Visa,\n            StripebillingCardNetwork::Mastercard => Self::Mastercard,\n            StripebillingCardNetwork::AmericanExpress => Self::AmericanExpress,\n            StripebillingCardNetwork::JCB => Self::JCB,\n            StripebillingCardNetwork::DinersClub => Self::DinersClub,\n            StripebillingCardNetwork::Discover => Self::Discover,\n            StripebillingCardNetwork::CartesBancaires => Self::CartesBancaires,\n            StripebillingCardNetwork::UnionPay => Self::UnionPay,\n            StripebillingCardNetwork::Interac => Self::Interac,\n            StripebillingCardNetwork::RuPay => Self::RuPay,\n            StripebillingCardNetwork::Maestro => Self::Maestro,\n            StripebillingCardNetwork::Star => Self::Star,\n            StripebillingCardNetwork::Pulse => Self::Pulse,\n            StripebillingCardNetwork::Accel => Self::Accel,\n            StripebillingCardNetwork::Nyce => Self::Nyce,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripebilling__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripebilling__transformers.rs"}, {"query": "Stripe Billing connector implementation", "code": "pub mod transformers;\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::revenue_recovery;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::types as recovery_router_data_types;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery as recovery_router_flows, subscriptions as subscription_flow_types,\n    },\n    router_request_types::{\n        revenue_recovery as recovery_request_types, subscriptions as subscription_request_types,\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery as recovery_response_types, subscriptions as subscription_response_types,\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, subscriptions as subscriptions_api, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Respon\n\n... [truncated 34027 chars] ...\n\ngnatureNotFound)?;\n        header_hashmap.insert(header_key.to_string(), header_value.bytes().collect());\n    }\n\n    Ok(header_hashmap)\n}\n\nstatic STRIPEBILLING_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Stripebilling\",\n    description: \"Stripe Billing manages subscriptions, recurring payments, and invoicing. It supports trials, usage-based billing, coupons, and automated retries.\",\n    connector_type: enums::HyperswitchConnectorCategory::RevenueGrowthManagementPlatform,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic STRIPEBILLING_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Stripebilling {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STRIPEBILLING_CONNECTOR_INFO)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&STRIPEBILLING_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs"}, {"query": "Stripebilling struct definition", "code": "pub mod transformers;\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::revenue_recovery;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::types as recovery_router_data_types;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery as recovery_router_flows, subscriptions as subscription_flow_types,\n    },\n    router_request_types::{\n        revenue_recovery as recovery_request_types, subscriptions as subscription_request_types,\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery as recovery_response_types, subscriptions as subscription_response_types,\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, subscriptions as subscriptions_api, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Respon\n\n... [truncated 34027 chars] ...\n\ngnatureNotFound)?;\n        header_hashmap.insert(header_key.to_string(), header_value.bytes().collect());\n    }\n\n    Ok(header_hashmap)\n}\n\nstatic STRIPEBILLING_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Stripebilling\",\n    description: \"Stripe Billing manages subscriptions, recurring payments, and invoicing. It supports trials, usage-based billing, coupons, and automated retries.\",\n    connector_type: enums::HyperswitchConnectorCategory::RevenueGrowthManagementPlatform,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic STRIPEBILLING_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Stripebilling {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STRIPEBILLING_CONNECTOR_INFO)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&STRIPEBILLING_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs"}, {"query": "how to configure Stripe Billing", "code": "pub mod transformers;\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::revenue_recovery;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::types as recovery_router_data_types;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery as recovery_router_flows, subscriptions as subscription_flow_types,\n    },\n    router_request_types::{\n        revenue_recovery as recovery_request_types, subscriptions as subscription_request_types,\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery as recovery_response_types, subscriptions as subscription_response_types,\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, subscriptions as subscriptions_api, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Respon\n\n... [truncated 34027 chars] ...\n\ngnatureNotFound)?;\n        header_hashmap.insert(header_key.to_string(), header_value.bytes().collect());\n    }\n\n    Ok(header_hashmap)\n}\n\nstatic STRIPEBILLING_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Stripebilling\",\n    description: \"Stripe Billing manages subscriptions, recurring payments, and invoicing. It supports trials, usage-based billing, coupons, and automated retries.\",\n    connector_type: enums::HyperswitchConnectorCategory::RevenueGrowthManagementPlatform,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic STRIPEBILLING_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Stripebilling {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STRIPEBILLING_CONNECTOR_INFO)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&STRIPEBILLING_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs"}, {"query": "hyperswitch stripe billing webhook signature", "code": "pub mod transformers;\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::revenue_recovery;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::types as recovery_router_data_types;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery as recovery_router_flows, subscriptions as subscription_flow_types,\n    },\n    router_request_types::{\n        revenue_recovery as recovery_request_types, subscriptions as subscription_request_types,\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery as recovery_response_types, subscriptions as subscription_response_types,\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, subscriptions as subscriptions_api, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Respon\n\n... [truncated 34027 chars] ...\n\ngnatureNotFound)?;\n        header_hashmap.insert(header_key.to_string(), header_value.bytes().collect());\n    }\n\n    Ok(header_hashmap)\n}\n\nstatic STRIPEBILLING_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Stripebilling\",\n    description: \"Stripe Billing manages subscriptions, recurring payments, and invoicing. It supports trials, usage-based billing, coupons, and automated retries.\",\n    connector_type: enums::HyperswitchConnectorCategory::RevenueGrowthManagementPlatform,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic STRIPEBILLING_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 1] =\n    [enums::EventClass::Payments];\n\nimpl ConnectorSpecifications for Stripebilling {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&STRIPEBILLING_CONNECTOR_INFO)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&STRIPEBILLING_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs", "file": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs"}, {"query": "how does Amazon Pay integration work in Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::{engine::general_purpose::STANDARD, Engine};\nuse chrono::Utc;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{RsaPssSha256, SignMessage},\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData as WalletDataPaymentMethod},\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface, Secret};\nuse sha2::{Digest, Sha256};\nuse transformers as amazonpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentsSyncRequestData},\n};\n\nconst\n\n... [truncated 24795 chars] ...\n\n  });\n\nstatic AMAZONPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Amazon Pay\",\n    description: \"Amazon Pay is an Alternative Payment Method (APM) connector that allows merchants to accept payments using customers' stored Amazon account details, providing a seamless checkout experience.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic AMAZONPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Amazonpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AMAZONPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&AMAZONPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AMAZONPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs"}, {"query": "Amazonpay struct implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::{engine::general_purpose::STANDARD, Engine};\nuse chrono::Utc;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{RsaPssSha256, SignMessage},\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData as WalletDataPaymentMethod},\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface, Secret};\nuse sha2::{Digest, Sha256};\nuse transformers as amazonpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentsSyncRequestData},\n};\n\nconst\n\n... [truncated 24795 chars] ...\n\n  });\n\nstatic AMAZONPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Amazon Pay\",\n    description: \"Amazon Pay is an Alternative Payment Method (APM) connector that allows merchants to accept payments using customers' stored Amazon account details, providing a seamless checkout experience.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic AMAZONPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Amazonpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AMAZONPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&AMAZONPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AMAZONPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs"}, {"query": "how to implement Amazon Pay connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::{engine::general_purpose::STANDARD, Engine};\nuse chrono::Utc;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{RsaPssSha256, SignMessage},\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData as WalletDataPaymentMethod},\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface, Secret};\nuse sha2::{Digest, Sha256};\nuse transformers as amazonpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentsSyncRequestData},\n};\n\nconst\n\n... [truncated 24795 chars] ...\n\n  });\n\nstatic AMAZONPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Amazon Pay\",\n    description: \"Amazon Pay is an Alternative Payment Method (APM) connector that allows merchants to accept payments using customers' stored Amazon account details, providing a seamless checkout experience.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic AMAZONPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Amazonpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AMAZONPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&AMAZONPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AMAZONPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs"}, {"query": "Amazon Pay API signature generation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::{engine::general_purpose::STANDARD, Engine};\nuse chrono::Utc;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{RsaPssSha256, SignMessage},\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData as WalletDataPaymentMethod},\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface, Secret};\nuse sha2::{Digest, Sha256};\nuse transformers as amazonpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentsSyncRequestData},\n};\n\nconst\n\n... [truncated 24795 chars] ...\n\n  });\n\nstatic AMAZONPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Amazon Pay\",\n    description: \"Amazon Pay is an Alternative Payment Method (APM) connector that allows merchants to accept payments using customers' stored Amazon account details, providing a seamless checkout experience.\",\n    connector_type: enums::HyperswitchConnectorCategory::AlternativePaymentMethod,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic AMAZONPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Amazonpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AMAZONPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&AMAZONPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AMAZONPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs"}, {"query": "how does unified authentication service work", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        UasAuthenticationConfirmationRouterData, UasAuthenticationRouterData,\n        UasPostAuthenticationRouterData, UasPreAuthenticationRouterData,\n        UasProcessWebhookRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as unified_authentication_service;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct UnifiedAuthenticationServ\n\n... [truncated 24784 chars] ...\n\nion_service WebhookResponse\")\n            .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.peek().get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.peek().get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(\n            hyperswitch_interfaces::authentication::ExternalAuthenticationPayload {\n                trans_status: webhook_body.trans_status,\n                authentication_value: webhook_body.authentication_value,\n                eci: webhook_body.eci,\n                challenge_cancel,\n                challenge_code_reason,\n            },\n        )\n    }\n}\n\nimpl ConnectorSpecifications for UnifiedAuthenticationService {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs", "file": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs"}, {"query": "UnifiedAuthenticationService struct definition", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        UasAuthenticationConfirmationRouterData, UasAuthenticationRouterData,\n        UasPostAuthenticationRouterData, UasPreAuthenticationRouterData,\n        UasProcessWebhookRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as unified_authentication_service;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct UnifiedAuthenticationServ\n\n... [truncated 24784 chars] ...\n\nion_service WebhookResponse\")\n            .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.peek().get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.peek().get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(\n            hyperswitch_interfaces::authentication::ExternalAuthenticationPayload {\n                trans_status: webhook_body.trans_status,\n                authentication_value: webhook_body.authentication_value,\n                eci: webhook_body.eci,\n                challenge_cancel,\n                challenge_code_reason,\n            },\n        )\n    }\n}\n\nimpl ConnectorSpecifications for UnifiedAuthenticationService {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs", "file": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs"}, {"query": "implement 3d secure authentication connector", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        UasAuthenticationConfirmationRouterData, UasAuthenticationRouterData,\n        UasPostAuthenticationRouterData, UasPreAuthenticationRouterData,\n        UasProcessWebhookRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as unified_authentication_service;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct UnifiedAuthenticationServ\n\n... [truncated 24784 chars] ...\n\nion_service WebhookResponse\")\n            .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.peek().get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.peek().get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(\n            hyperswitch_interfaces::authentication::ExternalAuthenticationPayload {\n                trans_status: webhook_body.trans_status,\n                authentication_value: webhook_body.authentication_value,\n                eci: webhook_body.eci,\n                challenge_cancel,\n                challenge_code_reason,\n            },\n        )\n    }\n}\n\nimpl ConnectorSpecifications for UnifiedAuthenticationService {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs", "file": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs"}, {"query": "UasAuthenticationRequestData struct", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        UasAuthenticationConfirmationRouterData, UasAuthenticationRouterData,\n        UasPostAuthenticationRouterData, UasPreAuthenticationRouterData,\n        UasProcessWebhookRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as unified_authentication_service;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct UnifiedAuthenticationServ\n\n... [truncated 24784 chars] ...\n\nion_service WebhookResponse\")\n            .change_context(errors::ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.peek().get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.peek().get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(\n            hyperswitch_interfaces::authentication::ExternalAuthenticationPayload {\n                trans_status: webhook_body.trans_status,\n                authentication_value: webhook_body.authentication_value,\n                eci: webhook_body.eci,\n                challenge_cancel,\n                challenge_code_reason,\n            },\n        )\n    }\n}\n\nimpl ConnectorSpecifications for UnifiedAuthenticationService {}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs", "file": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs"}, {"query": "how to handle Multisafepay payment errors", "code": "use common_enums::{enums, AttemptStatus, BankNames};\nuse common_utils::{\n    errors::ParsingError,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{self},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct MultisafepayRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for MultisafepayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Type {\n    Direct,\n    Redirect,\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum Gateway {\n    Amex,\n    CreditCard,\n    Discover,\n    Maestro,\n    MasterCard,\n    Visa,\n    Klarna,\n    Googlepay,\n    Paypal,\n    Ideal,\n    Giropay,\n    Trustly,\n    Alipay,\n    #[serde(rename = \"WECHAT\")]\n    WeChatPay,\n    Eps,\n    MbWay,\n    #[serde(rename = \"DIRECTBANK\")]\n    Sofort,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Coupons {\n    p\n\n... [truncated 48400 chars] ...\n\nInvalidCountryCode\n            | 1025 // MultisafepayErrorCodes::IncorrectCustomerIPAddress\n            | 1026 // MultisafepayErrorCodes::MultipleCurrenciesInCart\n            | 1027 // MultisafepayErrorCodes::CartCurrencyDifferentToOrderCurrency\n            | 1028 // IncorrectCustomTaxRate\n            | 1029 // IncorrectItemTaxRate\n            | 1030 // IncorrectItemCurrency\n            | 1031 // IncorrectItemPrice\n            | 1035 // InvalidSignatureRefund\n            | 1036 // InvalidIdealIssuerID\n            | 5001 // CartDataNotValidated\n            | 1032 // InvalidAPIKey\n            => {\n                Some(AttemptStatus::AuthenticationFailed)\n            }\n\n            1034 // CannotRefundTransaction\n            | 1022 // CannotInitiateTransaction\n            | 1024 //TransactionDeclined\n            => Some(AttemptStatus::Failure),\n            1017 // InsufficientFunds\n            => Some(AttemptStatus::AuthorizationFailed),\n            _ => None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs"}, {"query": "MultisafepayRouterData struct", "code": "use common_enums::{enums, AttemptStatus, BankNames};\nuse common_utils::{\n    errors::ParsingError,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{self},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct MultisafepayRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for MultisafepayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Type {\n    Direct,\n    Redirect,\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum Gateway {\n    Amex,\n    CreditCard,\n    Discover,\n    Maestro,\n    MasterCard,\n    Visa,\n    Klarna,\n    Googlepay,\n    Paypal,\n    Ideal,\n    Giropay,\n    Trustly,\n    Alipay,\n    #[serde(rename = \"WECHAT\")]\n    WeChatPay,\n    Eps,\n    MbWay,\n    #[serde(rename = \"DIRECTBANK\")]\n    Sofort,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Coupons {\n    p\n\n... [truncated 48400 chars] ...\n\nInvalidCountryCode\n            | 1025 // MultisafepayErrorCodes::IncorrectCustomerIPAddress\n            | 1026 // MultisafepayErrorCodes::MultipleCurrenciesInCart\n            | 1027 // MultisafepayErrorCodes::CartCurrencyDifferentToOrderCurrency\n            | 1028 // IncorrectCustomTaxRate\n            | 1029 // IncorrectItemTaxRate\n            | 1030 // IncorrectItemCurrency\n            | 1031 // IncorrectItemPrice\n            | 1035 // InvalidSignatureRefund\n            | 1036 // InvalidIdealIssuerID\n            | 5001 // CartDataNotValidated\n            | 1032 // InvalidAPIKey\n            => {\n                Some(AttemptStatus::AuthenticationFailed)\n            }\n\n            1034 // CannotRefundTransaction\n            | 1022 // CannotInitiateTransaction\n            | 1024 //TransactionDeclined\n            => Some(AttemptStatus::Failure),\n            1017 // InsufficientFunds\n            => Some(AttemptStatus::AuthorizationFailed),\n            _ => None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs"}, {"query": "transform Multisafepay response to router data", "code": "use common_enums::{enums, AttemptStatus, BankNames};\nuse common_utils::{\n    errors::ParsingError,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{self},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct MultisafepayRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for MultisafepayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Type {\n    Direct,\n    Redirect,\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum Gateway {\n    Amex,\n    CreditCard,\n    Discover,\n    Maestro,\n    MasterCard,\n    Visa,\n    Klarna,\n    Googlepay,\n    Paypal,\n    Ideal,\n    Giropay,\n    Trustly,\n    Alipay,\n    #[serde(rename = \"WECHAT\")]\n    WeChatPay,\n    Eps,\n    MbWay,\n    #[serde(rename = \"DIRECTBANK\")]\n    Sofort,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Coupons {\n    p\n\n... [truncated 48400 chars] ...\n\nInvalidCountryCode\n            | 1025 // MultisafepayErrorCodes::IncorrectCustomerIPAddress\n            | 1026 // MultisafepayErrorCodes::MultipleCurrenciesInCart\n            | 1027 // MultisafepayErrorCodes::CartCurrencyDifferentToOrderCurrency\n            | 1028 // IncorrectCustomTaxRate\n            | 1029 // IncorrectItemTaxRate\n            | 1030 // IncorrectItemCurrency\n            | 1031 // IncorrectItemPrice\n            | 1035 // InvalidSignatureRefund\n            | 1036 // InvalidIdealIssuerID\n            | 5001 // CartDataNotValidated\n            | 1032 // InvalidAPIKey\n            => {\n                Some(AttemptStatus::AuthenticationFailed)\n            }\n\n            1034 // CannotRefundTransaction\n            | 1022 // CannotInitiateTransaction\n            | 1024 //TransactionDeclined\n            => Some(AttemptStatus::Failure),\n            1017 // InsufficientFunds\n            => Some(AttemptStatus::AuthorizationFailed),\n            _ => None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs"}, {"query": "map Multisafepay error codes to AttemptStatus", "code": "use common_enums::{enums, AttemptStatus, BankNames};\nuse common_utils::{\n    errors::ParsingError,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{self},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct MultisafepayRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for MultisafepayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Type {\n    Direct,\n    Redirect,\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum Gateway {\n    Amex,\n    CreditCard,\n    Discover,\n    Maestro,\n    MasterCard,\n    Visa,\n    Klarna,\n    Googlepay,\n    Paypal,\n    Ideal,\n    Giropay,\n    Trustly,\n    Alipay,\n    #[serde(rename = \"WECHAT\")]\n    WeChatPay,\n    Eps,\n    MbWay,\n    #[serde(rename = \"DIRECTBANK\")]\n    Sofort,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Coupons {\n    p\n\n... [truncated 48400 chars] ...\n\nInvalidCountryCode\n            | 1025 // MultisafepayErrorCodes::IncorrectCustomerIPAddress\n            | 1026 // MultisafepayErrorCodes::MultipleCurrenciesInCart\n            | 1027 // MultisafepayErrorCodes::CartCurrencyDifferentToOrderCurrency\n            | 1028 // IncorrectCustomTaxRate\n            | 1029 // IncorrectItemTaxRate\n            | 1030 // IncorrectItemCurrency\n            | 1031 // IncorrectItemPrice\n            | 1035 // InvalidSignatureRefund\n            | 1036 // InvalidIdealIssuerID\n            | 5001 // CartDataNotValidated\n            | 1032 // InvalidAPIKey\n            => {\n                Some(AttemptStatus::AuthenticationFailed)\n            }\n\n            1034 // CannotRefundTransaction\n            | 1022 // CannotInitiateTransaction\n            | 1024 //TransactionDeclined\n            => Some(AttemptStatus::Failure),\n            1017 // InsufficientFunds\n            => Some(AttemptStatus::AuthorizationFailed),\n            _ => None,\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs"}, {"query": "hyperswitch payment domain models", "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    \n\n... [truncated 27972 chars] ...\n\n       surcharge_amount: amount.surcharge_amount,\n            tax_on_surcharge: amount.tax_on_surcharge,\n            amount_capturable: amount.amount_capturable,\n            shipping_cost: amount.shipping_cost,\n            order_tax_amount: amount.order_tax_amount,\n            amount_captured: amount.amount_captured,\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl From<&api_models::payments::RecordAttemptErrorDetails>\n    for payments::payment_attempt::ErrorDetails\n{\n    fn from(error: &api_models::payments::RecordAttemptErrorDetails) -> Self {\n        Self {\n            code: error.code.clone(),\n            message: error.message.clone(),\n            reason: Some(error.message.clone()),\n            unified_code: None,\n            unified_message: None,\n            network_advice_code: error.network_advice_code.clone(),\n            network_decline_code: error.network_decline_code.clone(),\n            network_error_message: error.network_error_message.clone(),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__lib.rs", "file": "crates__hyperswitch_domain_models__src__lib.rs"}, {"query": "RemoteStorageObject trait implementation", "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    \n\n... [truncated 27972 chars] ...\n\n       surcharge_amount: amount.surcharge_amount,\n            tax_on_surcharge: amount.tax_on_surcharge,\n            amount_capturable: amount.amount_capturable,\n            shipping_cost: amount.shipping_cost,\n            order_tax_amount: amount.order_tax_amount,\n            amount_captured: amount.amount_captured,\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl From<&api_models::payments::RecordAttemptErrorDetails>\n    for payments::payment_attempt::ErrorDetails\n{\n    fn from(error: &api_models::payments::RecordAttemptErrorDetails) -> Self {\n        Self {\n            code: error.code.clone(),\n            message: error.message.clone(),\n            reason: Some(error.message.clone()),\n            unified_code: None,\n            unified_message: None,\n            network_advice_code: error.network_advice_code.clone(),\n            network_decline_code: error.network_decline_code.clone(),\n            network_error_message: error.network_error_message.clone(),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__lib.rs", "file": "crates__hyperswitch_domain_models__src__lib.rs"}, {"query": "convert api model to diesel model", "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    \n\n... [truncated 27972 chars] ...\n\n       surcharge_amount: amount.surcharge_amount,\n            tax_on_surcharge: amount.tax_on_surcharge,\n            amount_capturable: amount.amount_capturable,\n            shipping_cost: amount.shipping_cost,\n            order_tax_amount: amount.order_tax_amount,\n            amount_captured: amount.amount_captured,\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl From<&api_models::payments::RecordAttemptErrorDetails>\n    for payments::payment_attempt::ErrorDetails\n{\n    fn from(error: &api_models::payments::RecordAttemptErrorDetails) -> Self {\n        Self {\n            code: error.code.clone(),\n            message: error.message.clone(),\n            reason: Some(error.message.clone()),\n            unified_code: None,\n            unified_message: None,\n            network_advice_code: error.network_advice_code.clone(),\n            network_decline_code: error.network_decline_code.clone(),\n            network_error_message: error.network_error_message.clone(),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__lib.rs", "file": "crates__hyperswitch_domain_models__src__lib.rs"}, {"query": "hyperswitch payment orchestration data structures", "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    \n\n... [truncated 27972 chars] ...\n\n       surcharge_amount: amount.surcharge_amount,\n            tax_on_surcharge: amount.tax_on_surcharge,\n            amount_capturable: amount.amount_capturable,\n            shipping_cost: amount.shipping_cost,\n            order_tax_amount: amount.order_tax_amount,\n            amount_captured: amount.amount_captured,\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl From<&api_models::payments::RecordAttemptErrorDetails>\n    for payments::payment_attempt::ErrorDetails\n{\n    fn from(error: &api_models::payments::RecordAttemptErrorDetails) -> Self {\n        Self {\n            code: error.code.clone(),\n            message: error.message.clone(),\n            reason: Some(error.message.clone()),\n            unified_code: None,\n            unified_message: None,\n            network_advice_code: error.network_advice_code.clone(),\n            network_decline_code: error.network_decline_code.clone(),\n            network_error_message: error.network_error_message.clone(),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__lib.rs", "file": "crates__hyperswitch_domain_models__src__lib.rs"}, {"query": "how does Novalnet payment integration work", "code": "pub mod transformers;\nuse core::str;\nuse std::{collections::HashSet, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as novalnet;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentMethodDataType, PaymentsAuthorizeRequestData},\n};\n\n#[derive(Clone)]\npub struct Novalnet {\n\n\n... [truncated 39514 chars] ...\n\nay_name: \"Novalnet\",\n    description: \"Novalnet provides tailored, data-driven payment solutions that maximize acceptance, boost conversions, and deliver seamless customer experiences worldwide.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic NOVALNET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 4] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Novalnet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NOVALNET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NOVALNET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&NOVALNET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__novalnet.rs", "file": "crates__hyperswitch_connectors__src__connectors__novalnet.rs"}, {"query": "hyperswitch Novalnet connector implementation", "code": "pub mod transformers;\nuse core::str;\nuse std::{collections::HashSet, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as novalnet;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentMethodDataType, PaymentsAuthorizeRequestData},\n};\n\n#[derive(Clone)]\npub struct Novalnet {\n\n\n... [truncated 39514 chars] ...\n\nay_name: \"Novalnet\",\n    description: \"Novalnet provides tailored, data-driven payment solutions that maximize acceptance, boost conversions, and deliver seamless customer experiences worldwide.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic NOVALNET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 4] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Novalnet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NOVALNET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NOVALNET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&NOVALNET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__novalnet.rs", "file": "crates__hyperswitch_connectors__src__connectors__novalnet.rs"}, {"query": "how to add Novalnet payment gateway", "code": "pub mod transformers;\nuse core::str;\nuse std::{collections::HashSet, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as novalnet;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentMethodDataType, PaymentsAuthorizeRequestData},\n};\n\n#[derive(Clone)]\npub struct Novalnet {\n\n\n... [truncated 39514 chars] ...\n\nay_name: \"Novalnet\",\n    description: \"Novalnet provides tailored, data-driven payment solutions that maximize acceptance, boost conversions, and deliver seamless customer experiences worldwide.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic NOVALNET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 4] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Novalnet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NOVALNET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NOVALNET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&NOVALNET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__novalnet.rs", "file": "crates__hyperswitch_connectors__src__connectors__novalnet.rs"}, {"query": "Novalnet payment method types hyperswitch", "code": "pub mod transformers;\nuse core::str;\nuse std::{collections::HashSet, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as novalnet;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentMethodDataType, PaymentsAuthorizeRequestData},\n};\n\n#[derive(Clone)]\npub struct Novalnet {\n\n\n... [truncated 39514 chars] ...\n\nay_name: \"Novalnet\",\n    description: \"Novalnet provides tailored, data-driven payment solutions that maximize acceptance, boost conversions, and deliver seamless customer experiences worldwide.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic NOVALNET_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 4] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Novalnet {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NOVALNET_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NOVALNET_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&NOVALNET_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__novalnet.rs", "file": "crates__hyperswitch_connectors__src__connectors__novalnet.rs"}, {"query": "how to integrate Breadpay with Hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse transformers::{\n    self as breadpay, BreadpayTransactionRequest, BreadpayTransactionResponse,\n    BreadpayTransactionType,\n};\n\nuse crate::{\n    connectors::br\n\n... [truncated 26707 chars] ...\n\n::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Breadpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BREADPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BREADPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BREADPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n\nimpl ConnectorRedirectResponse for Breadpay {\n    fn get_flow_type(\n        &self,\n        _query_params: &str,\n        _json_payload: Option<serde_json::Value>,\n        action: PaymentAction,\n    ) -> CustomResult<CallConnectorAction, errors::ConnectorError> {\n        match action {\n            PaymentAction::PSync\n            | PaymentAction::CompleteAuthorize\n            | PaymentAction::PaymentAuthenticateCompleteAuthorize => {\n                Ok(CallConnectorAction::Trigger)\n            }\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__breadpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__breadpay.rs"}, {"query": "Breadpay payment gateway connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse transformers::{\n    self as breadpay, BreadpayTransactionRequest, BreadpayTransactionResponse,\n    BreadpayTransactionType,\n};\n\nuse crate::{\n    connectors::br\n\n... [truncated 26707 chars] ...\n\n::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Breadpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BREADPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BREADPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BREADPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n\nimpl ConnectorRedirectResponse for Breadpay {\n    fn get_flow_type(\n        &self,\n        _query_params: &str,\n        _json_payload: Option<serde_json::Value>,\n        action: PaymentAction,\n    ) -> CustomResult<CallConnectorAction, errors::ConnectorError> {\n        match action {\n            PaymentAction::PSync\n            | PaymentAction::CompleteAuthorize\n            | PaymentAction::PaymentAuthenticateCompleteAuthorize => {\n                Ok(CallConnectorAction::Trigger)\n            }\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__breadpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__breadpay.rs"}, {"query": "implement payment capture using Breadpay", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse transformers::{\n    self as breadpay, BreadpayTransactionRequest, BreadpayTransactionResponse,\n    BreadpayTransactionType,\n};\n\nuse crate::{\n    connectors::br\n\n... [truncated 26707 chars] ...\n\n::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Breadpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BREADPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BREADPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BREADPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n\nimpl ConnectorRedirectResponse for Breadpay {\n    fn get_flow_type(\n        &self,\n        _query_params: &str,\n        _json_payload: Option<serde_json::Value>,\n        action: PaymentAction,\n    ) -> CustomResult<CallConnectorAction, errors::ConnectorError> {\n        match action {\n            PaymentAction::PSync\n            | PaymentAction::CompleteAuthorize\n            | PaymentAction::PaymentAuthenticateCompleteAuthorize => {\n                Ok(CallConnectorAction::Trigger)\n            }\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__breadpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__breadpay.rs"}, {"query": "Breadpay authorization and refund flow", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse transformers::{\n    self as breadpay, BreadpayTransactionRequest, BreadpayTransactionResponse,\n    BreadpayTransactionType,\n};\n\nuse crate::{\n    connectors::br\n\n... [truncated 26707 chars] ...\n\n::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Breadpay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BREADPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BREADPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BREADPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n\nimpl ConnectorRedirectResponse for Breadpay {\n    fn get_flow_type(\n        &self,\n        _query_params: &str,\n        _json_payload: Option<serde_json::Value>,\n        action: PaymentAction,\n    ) -> CustomResult<CallConnectorAction, errors::ConnectorError> {\n        match action {\n            PaymentAction::PSync\n            | PaymentAction::CompleteAuthorize\n            | PaymentAction::PaymentAuthenticateCompleteAuthorize => {\n                Ok(CallConnectorAction::Trigger)\n            }\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__breadpay.rs", "file": "crates__hyperswitch_connectors__src__connectors__breadpay.rs"}, {"query": "Adyen Platform connector implementation", "code": "pub mod transformers;\nuse api_models::{self, webhooks::IncomingWebhookEvent};\n#[cfg(feature = \"payouts\")]\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::crypto;\nuse common_utils::errors::CustomResult;\n#[cfg(feature = \"payouts\")]\nuse common_utils::ext_traits::{ByteSliceExt as _, BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, Request, RequestBuilder};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::MinorUnitForConnector;\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, MinorUnit};\n#[cfg(not(feature = \"payouts\"))]\nuse error_stack::report;\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse http::HeaderName;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::router_data::{ErrorResponse, RouterData};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::router_flow_types::PoFulfill;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsData, PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ConnectorAuthType},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::events::connector_api_logs::ConnectorEvent;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutFulfillType, Response};\nuse hyperswitch_interfaces::{\n    api::{self, ConnectorCommon, ConnectorIntegration,\n\n... [truncated 15423 chars] ...\n\n   connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Adyenplatform {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ADYENPLATFORM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_customer_id(\n        &self,\n        customer_id: &Option<common_utils::id_type::CustomerId>,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> Option<String> {\n        customer_id.as_ref().map(|cid| {\n            format!(\n                \"{}_{}\",\n                merchant_id.get_string_repr(),\n                cid.get_string_repr()\n            )\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyenplatform.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform.rs"}, {"query": "Adyenplatform struct Hyperswitch", "code": "pub mod transformers;\nuse api_models::{self, webhooks::IncomingWebhookEvent};\n#[cfg(feature = \"payouts\")]\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::crypto;\nuse common_utils::errors::CustomResult;\n#[cfg(feature = \"payouts\")]\nuse common_utils::ext_traits::{ByteSliceExt as _, BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, Request, RequestBuilder};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::MinorUnitForConnector;\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, MinorUnit};\n#[cfg(not(feature = \"payouts\"))]\nuse error_stack::report;\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse http::HeaderName;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::router_data::{ErrorResponse, RouterData};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::router_flow_types::PoFulfill;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsData, PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ConnectorAuthType},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::events::connector_api_logs::ConnectorEvent;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutFulfillType, Response};\nuse hyperswitch_interfaces::{\n    api::{self, ConnectorCommon, ConnectorIntegration,\n\n... [truncated 15423 chars] ...\n\n   connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Adyenplatform {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ADYENPLATFORM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_customer_id(\n        &self,\n        customer_id: &Option<common_utils::id_type::CustomerId>,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> Option<String> {\n        customer_id.as_ref().map(|cid| {\n            format!(\n                \"{}_{}\",\n                merchant_id.get_string_repr(),\n                cid.get_string_repr()\n            )\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyenplatform.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform.rs"}, {"query": "how to implement Adyen payouts", "code": "pub mod transformers;\nuse api_models::{self, webhooks::IncomingWebhookEvent};\n#[cfg(feature = \"payouts\")]\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::crypto;\nuse common_utils::errors::CustomResult;\n#[cfg(feature = \"payouts\")]\nuse common_utils::ext_traits::{ByteSliceExt as _, BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, Request, RequestBuilder};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::MinorUnitForConnector;\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, MinorUnit};\n#[cfg(not(feature = \"payouts\"))]\nuse error_stack::report;\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse http::HeaderName;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::router_data::{ErrorResponse, RouterData};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::router_flow_types::PoFulfill;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsData, PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ConnectorAuthType},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::events::connector_api_logs::ConnectorEvent;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutFulfillType, Response};\nuse hyperswitch_interfaces::{\n    api::{self, ConnectorCommon, ConnectorIntegration,\n\n... [truncated 15423 chars] ...\n\n   connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Adyenplatform {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ADYENPLATFORM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_customer_id(\n        &self,\n        customer_id: &Option<common_utils::id_type::CustomerId>,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> Option<String> {\n        customer_id.as_ref().map(|cid| {\n            format!(\n                \"{}_{}\",\n                merchant_id.get_string_repr(),\n                cid.get_string_repr()\n            )\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyenplatform.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform.rs"}, {"query": "Adyen webhook verification", "code": "pub mod transformers;\nuse api_models::{self, webhooks::IncomingWebhookEvent};\n#[cfg(feature = \"payouts\")]\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::crypto;\nuse common_utils::errors::CustomResult;\n#[cfg(feature = \"payouts\")]\nuse common_utils::ext_traits::{ByteSliceExt as _, BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, Request, RequestBuilder};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::MinorUnitForConnector;\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, MinorUnit};\n#[cfg(not(feature = \"payouts\"))]\nuse error_stack::report;\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse http::HeaderName;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::router_data::{ErrorResponse, RouterData};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::router_flow_types::PoFulfill;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsData, PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    router_data::{AccessToken, ConnectorAuthType},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::events::connector_api_logs::ConnectorEvent;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{PayoutFulfillType, Response};\nuse hyperswitch_interfaces::{\n    api::{self, ConnectorCommon, ConnectorIntegration,\n\n... [truncated 15423 chars] ...\n\n   connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Adyenplatform {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ADYENPLATFORM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n    #[cfg(feature = \"v1\")]\n    fn generate_connector_customer_id(\n        &self,\n        customer_id: &Option<common_utils::id_type::CustomerId>,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> Option<String> {\n        customer_id.as_ref().map(|cid| {\n            format!(\n                \"{}_{}\",\n                merchant_id.get_string_repr(),\n                cid.get_string_repr()\n            )\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyenplatform.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform.rs"}, {"query": "ACI Worldpay connector integration", "code": "use std::str::FromStr;\n\nuse cards::NetworkToken;\nuse common_enums::enums;\nuse common_utils::{id_type, pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::report;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, NetworkTokenData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    payment_methods::storage_enums::MitCategory,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::SetupMandate,\n    router_request_types::{\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsSyncData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::aci_result_codes::{FAILURE_CODES, PENDING_CODES, SUCCESSFUL_CODES};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, NetworkTokenData as NetworkTokenDataTrait, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait GetCaptureMethod {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod>;\n}\n\nimpl GetCaptureMethod for PaymentsAuthorizeData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        self.capture_method\n    }\n}\n\nimpl GetCaptureMethod for PaymentsSyncData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        self.capture_method\n    }\n}\n\nimpl GetCaptureMethod for PaymentsCancelData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        None\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AciRouterData<T> {\n    pub amount\n\n... [truncated 54096 chars] ...\n\n,\n    pub presentation_currency: Option<String>,\n    pub descriptor: Option<String>,\n    pub result: ResultCode,\n    pub authentication: Option<AciWebhookAuthenticationDetails>,\n    pub card: Option<AciWebhookCardDetails>,\n    pub customer: Option<AciWebhookCustomerDetails>,\n    #[serde(rename = \"customParameters\")]\n    pub custom_parameters: Option<serde_json::Value>,\n    pub risk: Option<AciWebhookRiskDetails>,\n    pub build_number: Option<String>,\n    pub timestamp: String,\n    pub ndc: String,\n    #[serde(rename = \"channelName\")]\n    pub channel_name: Option<String>,\n    pub source: Option<String>,\n    pub payment_method: Option<String>,\n    #[serde(rename = \"shortId\")]\n    pub short_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AciWebhookNotification {\n    #[serde(rename = \"type\")]\n    pub event_type: AciWebhookEventType,\n    pub action: Option<AciWebhookAction>,\n    pub payload: serde_json::Value,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__aci__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__aci__transformers.rs"}, {"query": "AciPaymentsRequest struct definition", "code": "use std::str::FromStr;\n\nuse cards::NetworkToken;\nuse common_enums::enums;\nuse common_utils::{id_type, pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::report;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, NetworkTokenData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    payment_methods::storage_enums::MitCategory,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::SetupMandate,\n    router_request_types::{\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsSyncData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::aci_result_codes::{FAILURE_CODES, PENDING_CODES, SUCCESSFUL_CODES};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, NetworkTokenData as NetworkTokenDataTrait, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait GetCaptureMethod {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod>;\n}\n\nimpl GetCaptureMethod for PaymentsAuthorizeData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        self.capture_method\n    }\n}\n\nimpl GetCaptureMethod for PaymentsSyncData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        self.capture_method\n    }\n}\n\nimpl GetCaptureMethod for PaymentsCancelData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        None\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AciRouterData<T> {\n    pub amount\n\n... [truncated 54096 chars] ...\n\n,\n    pub presentation_currency: Option<String>,\n    pub descriptor: Option<String>,\n    pub result: ResultCode,\n    pub authentication: Option<AciWebhookAuthenticationDetails>,\n    pub card: Option<AciWebhookCardDetails>,\n    pub customer: Option<AciWebhookCustomerDetails>,\n    #[serde(rename = \"customParameters\")]\n    pub custom_parameters: Option<serde_json::Value>,\n    pub risk: Option<AciWebhookRiskDetails>,\n    pub build_number: Option<String>,\n    pub timestamp: String,\n    pub ndc: String,\n    #[serde(rename = \"channelName\")]\n    pub channel_name: Option<String>,\n    pub source: Option<String>,\n    pub payment_method: Option<String>,\n    #[serde(rename = \"shortId\")]\n    pub short_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AciWebhookNotification {\n    #[serde(rename = \"type\")]\n    pub event_type: AciWebhookEventType,\n    pub action: Option<AciWebhookAction>,\n    pub payload: serde_json::Value,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__aci__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__aci__transformers.rs"}, {"query": "how to handle ACI payment webhooks", "code": "use std::str::FromStr;\n\nuse cards::NetworkToken;\nuse common_enums::enums;\nuse common_utils::{id_type, pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::report;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, NetworkTokenData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    payment_methods::storage_enums::MitCategory,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::SetupMandate,\n    router_request_types::{\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsSyncData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::aci_result_codes::{FAILURE_CODES, PENDING_CODES, SUCCESSFUL_CODES};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, NetworkTokenData as NetworkTokenDataTrait, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait GetCaptureMethod {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod>;\n}\n\nimpl GetCaptureMethod for PaymentsAuthorizeData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        self.capture_method\n    }\n}\n\nimpl GetCaptureMethod for PaymentsSyncData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        self.capture_method\n    }\n}\n\nimpl GetCaptureMethod for PaymentsCancelData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        None\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AciRouterData<T> {\n    pub amount\n\n... [truncated 54096 chars] ...\n\n,\n    pub presentation_currency: Option<String>,\n    pub descriptor: Option<String>,\n    pub result: ResultCode,\n    pub authentication: Option<AciWebhookAuthenticationDetails>,\n    pub card: Option<AciWebhookCardDetails>,\n    pub customer: Option<AciWebhookCustomerDetails>,\n    #[serde(rename = \"customParameters\")]\n    pub custom_parameters: Option<serde_json::Value>,\n    pub risk: Option<AciWebhookRiskDetails>,\n    pub build_number: Option<String>,\n    pub timestamp: String,\n    pub ndc: String,\n    #[serde(rename = \"channelName\")]\n    pub channel_name: Option<String>,\n    pub source: Option<String>,\n    pub payment_method: Option<String>,\n    #[serde(rename = \"shortId\")]\n    pub short_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AciWebhookNotification {\n    #[serde(rename = \"type\")]\n    pub event_type: AciWebhookEventType,\n    pub action: Option<AciWebhookAction>,\n    pub payload: serde_json::Value,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__aci__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__aci__transformers.rs"}, {"query": "ACI Worldpay refund request format", "code": "use std::str::FromStr;\n\nuse cards::NetworkToken;\nuse common_enums::enums;\nuse common_utils::{id_type, pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::report;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, NetworkTokenData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    payment_methods::storage_enums::MitCategory,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::SetupMandate,\n    router_request_types::{\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsSyncData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::aci_result_codes::{FAILURE_CODES, PENDING_CODES, SUCCESSFUL_CODES};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, NetworkTokenData as NetworkTokenDataTrait, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait GetCaptureMethod {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod>;\n}\n\nimpl GetCaptureMethod for PaymentsAuthorizeData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        self.capture_method\n    }\n}\n\nimpl GetCaptureMethod for PaymentsSyncData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        self.capture_method\n    }\n}\n\nimpl GetCaptureMethod for PaymentsCancelData {\n    fn get_capture_method(&self) -> Option<enums::CaptureMethod> {\n        None\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AciRouterData<T> {\n    pub amount\n\n... [truncated 54096 chars] ...\n\n,\n    pub presentation_currency: Option<String>,\n    pub descriptor: Option<String>,\n    pub result: ResultCode,\n    pub authentication: Option<AciWebhookAuthenticationDetails>,\n    pub card: Option<AciWebhookCardDetails>,\n    pub customer: Option<AciWebhookCustomerDetails>,\n    #[serde(rename = \"customParameters\")]\n    pub custom_parameters: Option<serde_json::Value>,\n    pub risk: Option<AciWebhookRiskDetails>,\n    pub build_number: Option<String>,\n    pub timestamp: String,\n    pub ndc: String,\n    #[serde(rename = \"channelName\")]\n    pub channel_name: Option<String>,\n    pub source: Option<String>,\n    pub payment_method: Option<String>,\n    #[serde(rename = \"shortId\")]\n    pub short_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AciWebhookNotification {\n    #[serde(rename = \"type\")]\n    pub event_type: AciWebhookEventType,\n    pub action: Option<AciWebhookAction>,\n    pub payload: serde_json::Value,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__aci__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__aci__transformers.rs"}, {"query": "Xendit payment request data structure", "code": "use std::collections::HashMap;\n\nuse api_models::payments::QrCodeInformation;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    errors::CustomResult, ext_traits::Encode, pii, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSettlementSplitCreateRouterData, PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSettlementSplitCreateResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSyncRequestData, QrImage, RouterData as OtherRouterData,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct XenditRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\npub enum PaymentMethodType {\n    CARD,\n}\n#[derive(Serialize, Deserialize, Debug)]\npub struct ChannelProperties {\n    pub success_return_url: String,\n    pub failure_return_url: String,\n    pub skip_three_d_secure: bool,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(\n\n... [truncated 39101 chars] ...\n\nb payment_request_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum XenditEventType {\n    #[serde(rename = \"payment.succeeded\")]\n    PaymentSucceeded,\n    #[serde(rename = \"payment.awaiting_capture\")]\n    PaymentAwaitingCapture,\n    #[serde(rename = \"payment.failed\")]\n    PaymentFailed,\n    #[serde(rename = \"capture.succeeded\")]\n    CaptureSucceeded,\n    #[serde(rename = \"capture.failed\")]\n    CaptureFailed,\n    #[serde(rename = \"qr.payment\")]\n    QrPayment,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum QRPaymentStatus {\n    Completed,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct QrData {\n    pub id: String,\n    pub external_id: String,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(untagged)]\npub enum XenditWebhookEvent {\n    CommonEvent(XenditCommonWebhookEvent),\n    QrEvent(XenditQRWebhookEvent),\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__xendit__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__xendit__transformers.rs"}, {"query": "how to handle Xendit webhook events", "code": "use std::collections::HashMap;\n\nuse api_models::payments::QrCodeInformation;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    errors::CustomResult, ext_traits::Encode, pii, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSettlementSplitCreateRouterData, PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSettlementSplitCreateResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSyncRequestData, QrImage, RouterData as OtherRouterData,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct XenditRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\npub enum PaymentMethodType {\n    CARD,\n}\n#[derive(Serialize, Deserialize, Debug)]\npub struct ChannelProperties {\n    pub success_return_url: String,\n    pub failure_return_url: String,\n    pub skip_three_d_secure: bool,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(\n\n... [truncated 39101 chars] ...\n\nb payment_request_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum XenditEventType {\n    #[serde(rename = \"payment.succeeded\")]\n    PaymentSucceeded,\n    #[serde(rename = \"payment.awaiting_capture\")]\n    PaymentAwaitingCapture,\n    #[serde(rename = \"payment.failed\")]\n    PaymentFailed,\n    #[serde(rename = \"capture.succeeded\")]\n    CaptureSucceeded,\n    #[serde(rename = \"capture.failed\")]\n    CaptureFailed,\n    #[serde(rename = \"qr.payment\")]\n    QrPayment,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum QRPaymentStatus {\n    Completed,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct QrData {\n    pub id: String,\n    pub external_id: String,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(untagged)]\npub enum XenditWebhookEvent {\n    CommonEvent(XenditCommonWebhookEvent),\n    QrEvent(XenditQRWebhookEvent),\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__xendit__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__xendit__transformers.rs"}, {"query": "Xendit connector response transformer", "code": "use std::collections::HashMap;\n\nuse api_models::payments::QrCodeInformation;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    errors::CustomResult, ext_traits::Encode, pii, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSettlementSplitCreateRouterData, PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSettlementSplitCreateResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSyncRequestData, QrImage, RouterData as OtherRouterData,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct XenditRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\npub enum PaymentMethodType {\n    CARD,\n}\n#[derive(Serialize, Deserialize, Debug)]\npub struct ChannelProperties {\n    pub success_return_url: String,\n    pub failure_return_url: String,\n    pub skip_three_d_secure: bool,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(\n\n... [truncated 39101 chars] ...\n\nb payment_request_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum XenditEventType {\n    #[serde(rename = \"payment.succeeded\")]\n    PaymentSucceeded,\n    #[serde(rename = \"payment.awaiting_capture\")]\n    PaymentAwaitingCapture,\n    #[serde(rename = \"payment.failed\")]\n    PaymentFailed,\n    #[serde(rename = \"capture.succeeded\")]\n    CaptureSucceeded,\n    #[serde(rename = \"capture.failed\")]\n    CaptureFailed,\n    #[serde(rename = \"qr.payment\")]\n    QrPayment,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum QRPaymentStatus {\n    Completed,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct QrData {\n    pub id: String,\n    pub external_id: String,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(untagged)]\npub enum XenditWebhookEvent {\n    CommonEvent(XenditCommonWebhookEvent),\n    QrEvent(XenditQRWebhookEvent),\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__xendit__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__xendit__transformers.rs"}, {"query": "Xendit payment capture request", "code": "use std::collections::HashMap;\n\nuse api_models::payments::QrCodeInformation;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    errors::CustomResult, ext_traits::Encode, pii, request::Method, types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSettlementSplitCreateRouterData, PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSettlementSplitCreateResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSyncRequestData, QrImage, RouterData as OtherRouterData,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct XenditRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\npub enum PaymentMethodType {\n    CARD,\n}\n#[derive(Serialize, Deserialize, Debug)]\npub struct ChannelProperties {\n    pub success_return_url: String,\n    pub failure_return_url: String,\n    pub skip_three_d_secure: bool,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(\n\n... [truncated 39101 chars] ...\n\nb payment_request_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum XenditEventType {\n    #[serde(rename = \"payment.succeeded\")]\n    PaymentSucceeded,\n    #[serde(rename = \"payment.awaiting_capture\")]\n    PaymentAwaitingCapture,\n    #[serde(rename = \"payment.failed\")]\n    PaymentFailed,\n    #[serde(rename = \"capture.succeeded\")]\n    CaptureSucceeded,\n    #[serde(rename = \"capture.failed\")]\n    CaptureFailed,\n    #[serde(rename = \"qr.payment\")]\n    QrPayment,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum QRPaymentStatus {\n    Completed,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct QrData {\n    pub id: String,\n    pub external_id: String,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(untagged)]\npub enum XenditWebhookEvent {\n    CommonEvent(XenditCommonWebhookEvent),\n    QrEvent(XenditQRWebhookEvent),\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__xendit__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__xendit__transformers.rs"}, {"query": "how to integrate Bluesnap payment gateway", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{BytesExt, StringExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RedirectForm,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSessionRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload\n\n... [truncated 59230 chars] ...\n\n;\n\nstatic BLUESNAP_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"BlueSnap\",\n    description:\n        \"BlueSnap is a payment platform that helps businesses accept payments from customers in over 200 regions \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic BLUESNAP_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Bluesnap {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BLUESNAP_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BLUESNAP_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BLUESNAP_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs", "file": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs"}, {"query": "Bluesnap connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{BytesExt, StringExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RedirectForm,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSessionRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload\n\n... [truncated 59230 chars] ...\n\n;\n\nstatic BLUESNAP_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"BlueSnap\",\n    description:\n        \"BlueSnap is a payment platform that helps businesses accept payments from customers in over 200 regions \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic BLUESNAP_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Bluesnap {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BLUESNAP_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BLUESNAP_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BLUESNAP_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs", "file": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs"}, {"query": "implement payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{BytesExt, StringExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RedirectForm,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSessionRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload\n\n... [truncated 59230 chars] ...\n\n;\n\nstatic BLUESNAP_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"BlueSnap\",\n    description:\n        \"BlueSnap is a payment platform that helps businesses accept payments from customers in over 200 regions \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic BLUESNAP_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Bluesnap {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BLUESNAP_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BLUESNAP_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BLUESNAP_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs", "file": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs"}, {"query": "BlueSnap API key authentication", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{BytesExt, StringExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RedirectForm,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSessionRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload\n\n... [truncated 59230 chars] ...\n\n;\n\nstatic BLUESNAP_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"BlueSnap\",\n    description:\n        \"BlueSnap is a payment platform that helps businesses accept payments from customers in over 200 regions \",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nstatic BLUESNAP_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Bluesnap {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BLUESNAP_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BLUESNAP_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BLUESNAP_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs", "file": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs"}, {"query": "Dwolla payment gateway integration Rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::engine::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, PaymentMethodToken as PMT, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, ConnectorInfo, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as dwolla;\nuse transformers::extract_token_from_body;\n\nuse crate::{\n    constants::headers,\n \n\n... [truncated 32584 chars] ...\n\nnancial technology company offering financial services and software as a service (SaaS)\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic DWOLLA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Dwolla {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DWOLLA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DWOLLA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DWOLLA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__dwolla.rs", "file": "crates__hyperswitch_connectors__src__connectors__dwolla.rs"}, {"query": "hyperswitch connector implementation Dwolla", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::engine::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, PaymentMethodToken as PMT, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, ConnectorInfo, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as dwolla;\nuse transformers::extract_token_from_body;\n\nuse crate::{\n    constants::headers,\n \n\n... [truncated 32584 chars] ...\n\nnancial technology company offering financial services and software as a service (SaaS)\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic DWOLLA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Dwolla {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DWOLLA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DWOLLA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DWOLLA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__dwolla.rs", "file": "crates__hyperswitch_connectors__src__connectors__dwolla.rs"}, {"query": "how to add new payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::engine::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, PaymentMethodToken as PMT, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, ConnectorInfo, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as dwolla;\nuse transformers::extract_token_from_body;\n\nuse crate::{\n    constants::headers,\n \n\n... [truncated 32584 chars] ...\n\nnancial technology company offering financial services and software as a service (SaaS)\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic DWOLLA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Dwolla {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DWOLLA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DWOLLA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DWOLLA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__dwolla.rs", "file": "crates__hyperswitch_connectors__src__connectors__dwolla.rs"}, {"query": "ACH payment processing Rust hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::engine::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, PaymentMethodToken as PMT, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, ConnectorInfo, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as dwolla;\nuse transformers::extract_token_from_body;\n\nuse crate::{\n    constants::headers,\n \n\n... [truncated 32584 chars] ...\n\nnancial technology company offering financial services and software as a service (SaaS)\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic DWOLLA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 2] =\n    [enums::EventClass::Payments, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Dwolla {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DWOLLA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DWOLLA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DWOLLA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn should_call_connector_customer(\n        &self,\n        _payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__dwolla.rs", "file": "crates__hyperswitch_connectors__src__connectors__dwolla.rs"}, {"query": "BamboraAPAC SOAP request format", "code": "use common_enums::enums;\nuse common_utils::types::MinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{RefundsData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub struct BamboraapacRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for BamboraapacRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BamboraapacMeta {\n    pub authorize_id: String,\n}\n\n// request body in soap format\npub fn get_payment_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<Vec<u8>, Error> {\n    let transaction_data = get_transaction_body(req)?;\n    let body = format!(\n        r#\"\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n            xmlns:dts=\"http://www.ippayments.com.au/interface/api/dts\">\n                <soapenv:Body>\n                    <dts:SubmitSinglePayment>\n                        <dts:trnXML>\n                            <![CDATA[\n                                {transaction_data}\n                \n\n... [truncated 33390 chars] ...\n\n BamboraapacSyncResponse, RefundsData, RefundsResponseData>,\n    ) -> Result<Self, Self::Error> {\n        let response_code = item\n            .response\n            .body\n            .query_transaction_response\n            .query_transaction_result\n            .query_response\n            .response\n            .response_code;\n        let connector_refund_id = item\n            .response\n            .body\n            .query_transaction_response\n            .query_transaction_result\n            .query_response\n            .response\n            .receipt;\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: connector_refund_id.to_owned(),\n                refund_status: get_status(response_code),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct BamboraapacErrorResponse {\n    pub declined_code: Option<String>,\n    pub declined_message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs"}, {"query": "BamboraapacRouterData struct definition", "code": "use common_enums::enums;\nuse common_utils::types::MinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{RefundsData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub struct BamboraapacRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for BamboraapacRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BamboraapacMeta {\n    pub authorize_id: String,\n}\n\n// request body in soap format\npub fn get_payment_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<Vec<u8>, Error> {\n    let transaction_data = get_transaction_body(req)?;\n    let body = format!(\n        r#\"\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n            xmlns:dts=\"http://www.ippayments.com.au/interface/api/dts\">\n                <soapenv:Body>\n                    <dts:SubmitSinglePayment>\n                        <dts:trnXML>\n                            <![CDATA[\n                                {transaction_data}\n                \n\n... [truncated 33390 chars] ...\n\n BamboraapacSyncResponse, RefundsData, RefundsResponseData>,\n    ) -> Result<Self, Self::Error> {\n        let response_code = item\n            .response\n            .body\n            .query_transaction_response\n            .query_transaction_result\n            .query_response\n            .response\n            .response_code;\n        let connector_refund_id = item\n            .response\n            .body\n            .query_transaction_response\n            .query_transaction_result\n            .query_response\n            .response\n            .receipt;\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: connector_refund_id.to_owned(),\n                refund_status: get_status(response_code),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct BamboraapacErrorResponse {\n    pub declined_code: Option<String>,\n    pub declined_message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs"}, {"query": "how to implement BamboraAPAC refunds", "code": "use common_enums::enums;\nuse common_utils::types::MinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{RefundsData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub struct BamboraapacRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for BamboraapacRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BamboraapacMeta {\n    pub authorize_id: String,\n}\n\n// request body in soap format\npub fn get_payment_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<Vec<u8>, Error> {\n    let transaction_data = get_transaction_body(req)?;\n    let body = format!(\n        r#\"\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n            xmlns:dts=\"http://www.ippayments.com.au/interface/api/dts\">\n                <soapenv:Body>\n                    <dts:SubmitSinglePayment>\n                        <dts:trnXML>\n                            <![CDATA[\n                                {transaction_data}\n                \n\n... [truncated 33390 chars] ...\n\n BamboraapacSyncResponse, RefundsData, RefundsResponseData>,\n    ) -> Result<Self, Self::Error> {\n        let response_code = item\n            .response\n            .body\n            .query_transaction_response\n            .query_transaction_result\n            .query_response\n            .response\n            .response_code;\n        let connector_refund_id = item\n            .response\n            .body\n            .query_transaction_response\n            .query_transaction_result\n            .query_response\n            .response\n            .receipt;\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: connector_refund_id.to_owned(),\n                refund_status: get_status(response_code),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct BamboraapacErrorResponse {\n    pub declined_code: Option<String>,\n    pub declined_message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs"}, {"query": "hyperswitch BamboraAPAC transaction sync", "code": "use common_enums::enums;\nuse common_utils::types::MinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{RefundsData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub struct BamboraapacRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for BamboraapacRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BamboraapacMeta {\n    pub authorize_id: String,\n}\n\n// request body in soap format\npub fn get_payment_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<Vec<u8>, Error> {\n    let transaction_data = get_transaction_body(req)?;\n    let body = format!(\n        r#\"\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n            xmlns:dts=\"http://www.ippayments.com.au/interface/api/dts\">\n                <soapenv:Body>\n                    <dts:SubmitSinglePayment>\n                        <dts:trnXML>\n                            <![CDATA[\n                                {transaction_data}\n                \n\n... [truncated 33390 chars] ...\n\n BamboraapacSyncResponse, RefundsData, RefundsResponseData>,\n    ) -> Result<Self, Self::Error> {\n        let response_code = item\n            .response\n            .body\n            .query_transaction_response\n            .query_transaction_result\n            .query_response\n            .response\n            .response_code;\n        let connector_refund_id = item\n            .response\n            .body\n            .query_transaction_response\n            .query_transaction_result\n            .query_response\n            .response\n            .receipt;\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: connector_refund_id.to_owned(),\n                refund_status: get_status(response_code),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Default, Debug, Serialize, Deserialize, PartialEq)]\npub struct BamboraapacErrorResponse {\n    pub declined_code: Option<String>,\n    pub declined_message: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs"}, {"query": "Razorpay payment integration Hyperswitch", "code": "use std::collections::HashMap;\n\nuse api_models::payments::PollConfig;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    pii::{self, Email, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, UpiData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::{Duration, OffsetDateTime};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, missing_field_err,\n        PaymentsAuthorizeRequestData, RouterData as OtherRouterData,\n    },\n};\n\npub struct RazorpayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for RazorpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub const VERSION: i32 = 1;\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderRequest {\n    pub amount: MinorUnit,\n    pub currency: enums::Currency,\n    pub receipt: String,\n    pub partial_payment: Option<bool>,\n    pub first_payment_min_amount: Option<MinorUnit>,\n    pub notes: Option<RazorpayNotes>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum RazorpayNotes {\n    Map(HashMap<String, String>),\n    EmptyMap(HashMap<String, String>),\n}\n\nimpl TryFrom<&RazorpayRouterData<&types::CreateOrderRouterData>> for RazorpayOrderRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n\n... [truncated 19628 chars] ...\n\nookEventType) -> Result<Self, Self::Error> {\n//         match event_type {\n//             RazorpayWebhookEventType::Payments(payment_event) => match payment_event {\n//                 RazorpayWebhookPaymentEvent::Authorized => {\n//                     Ok(Self::PaymentIntentAuthorizationSuccess)\n//                 }\n//                 RazorpayWebhookPaymentEvent::Captured => Ok(Self::PaymentIntentSuccess),\n//                 RazorpayWebhookPaymentEvent::Failed => Ok(Self::PaymentIntentFailure),\n//             },\n//             RazorpayWebhookEventType::Refunds(refund_event) => match refund_event {\n//                 RazorpayWebhookRefundEvent::Processed => Ok(Self::RefundSuccess),\n//                 RazorpayWebhookRefundEvent::Created => Ok(Self::RefundSuccess),\n//                 RazorpayWebhookRefundEvent::Failed => Ok(Self::RefundFailure),\n//                 RazorpayWebhookRefundEvent::SpeedChange => Ok(Self::EventNotSupported),\n//             },\n//         }\n//     }\n// }\n", "function_name": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs"}, {"query": "RazorpayOrderRequest struct definition", "code": "use std::collections::HashMap;\n\nuse api_models::payments::PollConfig;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    pii::{self, Email, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, UpiData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::{Duration, OffsetDateTime};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, missing_field_err,\n        PaymentsAuthorizeRequestData, RouterData as OtherRouterData,\n    },\n};\n\npub struct RazorpayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for RazorpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub const VERSION: i32 = 1;\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderRequest {\n    pub amount: MinorUnit,\n    pub currency: enums::Currency,\n    pub receipt: String,\n    pub partial_payment: Option<bool>,\n    pub first_payment_min_amount: Option<MinorUnit>,\n    pub notes: Option<RazorpayNotes>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum RazorpayNotes {\n    Map(HashMap<String, String>),\n    EmptyMap(HashMap<String, String>),\n}\n\nimpl TryFrom<&RazorpayRouterData<&types::CreateOrderRouterData>> for RazorpayOrderRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n\n... [truncated 19628 chars] ...\n\nookEventType) -> Result<Self, Self::Error> {\n//         match event_type {\n//             RazorpayWebhookEventType::Payments(payment_event) => match payment_event {\n//                 RazorpayWebhookPaymentEvent::Authorized => {\n//                     Ok(Self::PaymentIntentAuthorizationSuccess)\n//                 }\n//                 RazorpayWebhookPaymentEvent::Captured => Ok(Self::PaymentIntentSuccess),\n//                 RazorpayWebhookPaymentEvent::Failed => Ok(Self::PaymentIntentFailure),\n//             },\n//             RazorpayWebhookEventType::Refunds(refund_event) => match refund_event {\n//                 RazorpayWebhookRefundEvent::Processed => Ok(Self::RefundSuccess),\n//                 RazorpayWebhookRefundEvent::Created => Ok(Self::RefundSuccess),\n//                 RazorpayWebhookRefundEvent::Failed => Ok(Self::RefundFailure),\n//                 RazorpayWebhookRefundEvent::SpeedChange => Ok(Self::EventNotSupported),\n//             },\n//         }\n//     }\n// }\n", "function_name": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs"}, {"query": "transform payments to Razorpay format", "code": "use std::collections::HashMap;\n\nuse api_models::payments::PollConfig;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    pii::{self, Email, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, UpiData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::{Duration, OffsetDateTime};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, missing_field_err,\n        PaymentsAuthorizeRequestData, RouterData as OtherRouterData,\n    },\n};\n\npub struct RazorpayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for RazorpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub const VERSION: i32 = 1;\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderRequest {\n    pub amount: MinorUnit,\n    pub currency: enums::Currency,\n    pub receipt: String,\n    pub partial_payment: Option<bool>,\n    pub first_payment_min_amount: Option<MinorUnit>,\n    pub notes: Option<RazorpayNotes>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum RazorpayNotes {\n    Map(HashMap<String, String>),\n    EmptyMap(HashMap<String, String>),\n}\n\nimpl TryFrom<&RazorpayRouterData<&types::CreateOrderRouterData>> for RazorpayOrderRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n\n... [truncated 19628 chars] ...\n\nookEventType) -> Result<Self, Self::Error> {\n//         match event_type {\n//             RazorpayWebhookEventType::Payments(payment_event) => match payment_event {\n//                 RazorpayWebhookPaymentEvent::Authorized => {\n//                     Ok(Self::PaymentIntentAuthorizationSuccess)\n//                 }\n//                 RazorpayWebhookPaymentEvent::Captured => Ok(Self::PaymentIntentSuccess),\n//                 RazorpayWebhookPaymentEvent::Failed => Ok(Self::PaymentIntentFailure),\n//             },\n//             RazorpayWebhookEventType::Refunds(refund_event) => match refund_event {\n//                 RazorpayWebhookRefundEvent::Processed => Ok(Self::RefundSuccess),\n//                 RazorpayWebhookRefundEvent::Created => Ok(Self::RefundSuccess),\n//                 RazorpayWebhookRefundEvent::Failed => Ok(Self::RefundFailure),\n//                 RazorpayWebhookRefundEvent::SpeedChange => Ok(Self::EventNotSupported),\n//             },\n//         }\n//     }\n// }\n", "function_name": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs"}, {"query": "Razorpay UPI payment method handling", "code": "use std::collections::HashMap;\n\nuse api_models::payments::PollConfig;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    pii::{self, Email, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, UpiData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::{Duration, OffsetDateTime};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, missing_field_err,\n        PaymentsAuthorizeRequestData, RouterData as OtherRouterData,\n    },\n};\n\npub struct RazorpayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for RazorpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub const VERSION: i32 = 1;\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderRequest {\n    pub amount: MinorUnit,\n    pub currency: enums::Currency,\n    pub receipt: String,\n    pub partial_payment: Option<bool>,\n    pub first_payment_min_amount: Option<MinorUnit>,\n    pub notes: Option<RazorpayNotes>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum RazorpayNotes {\n    Map(HashMap<String, String>),\n    EmptyMap(HashMap<String, String>),\n}\n\nimpl TryFrom<&RazorpayRouterData<&types::CreateOrderRouterData>> for RazorpayOrderRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n\n... [truncated 19628 chars] ...\n\nookEventType) -> Result<Self, Self::Error> {\n//         match event_type {\n//             RazorpayWebhookEventType::Payments(payment_event) => match payment_event {\n//                 RazorpayWebhookPaymentEvent::Authorized => {\n//                     Ok(Self::PaymentIntentAuthorizationSuccess)\n//                 }\n//                 RazorpayWebhookPaymentEvent::Captured => Ok(Self::PaymentIntentSuccess),\n//                 RazorpayWebhookPaymentEvent::Failed => Ok(Self::PaymentIntentFailure),\n//             },\n//             RazorpayWebhookEventType::Refunds(refund_event) => match refund_event {\n//                 RazorpayWebhookRefundEvent::Processed => Ok(Self::RefundSuccess),\n//                 RazorpayWebhookRefundEvent::Created => Ok(Self::RefundSuccess),\n//                 RazorpayWebhookRefundEvent::Failed => Ok(Self::RefundFailure),\n//                 RazorpayWebhookRefundEvent::SpeedChange => Ok(Self::EventNotSupported),\n//             },\n//         }\n//     }\n// }\n", "function_name": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs"}, {"query": "how to serialize secrets in hyperswitch", "code": "//! Serde-related.\n\npub use erased_serde::Serialize as ErasedSerialize;\npub use serde::{de, Deserialize, Serialize, Serializer};\nuse serde_json::{value::Serializer as JsonValueSerializer, Value};\n\nuse crate::{Secret, Strategy, StrongSecret, ZeroizableSecret};\n\n/// Marker trait for secret types which can be [`Serialize`]-d by [`serde`].\n///\n/// When the `serde` feature of this crate is enabled and types are marked with\n/// this trait, they receive a [`Serialize` impl] for `Secret<T>`.\n/// (NOTE: all types which impl `DeserializeOwned` receive a [`Deserialize`]\n/// impl)\n///\n/// This is done deliberately to prevent accidental exfiltration of secrets\n/// via `serde` serialization.\n#[cfg_attr(docsrs, cfg(feature = \"serde\"))]\npub trait SerializableSecret: Serialize {}\n// #[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n// pub trait NonSerializableSecret: Serialize {}\n\nimpl SerializableSecret for Value {}\nimpl SerializableSecret for u8 {}\nimpl SerializableSecret for u16 {}\nimpl SerializableSecret for i8 {}\nimpl SerializableSecret for i32 {}\nimpl SerializableSecret for i64 {}\nimpl SerializableSecret for url::Url {}\n\n#[cfg(feature = \"time\")]\nimpl SerializableSecret for time::Date {}\n\nimpl<T: SerializableSecret> SerializableSecret for &T {}\n\nimpl<'de, T, I> Deserialize<'de> for Secret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for Secret<T, I>\nwhere\n    T: SerializableSecret + Serialize + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\nimpl<'de, T, I> Deserialize<'de> for StrongSecret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized + ZeroizableSecret,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(de\n\n... [truncated 13925 chars] ...\n\n   self.inner.serialize_key(key)?;\n            Ok(())\n        }\n\n        fn serialize_value<V>(&mut self, value: &V) -> Result<(), Self::Error>\n        where\n            V: ?Sized + Serialize,\n        {\n            let value = value.serialize(self.ser.clone())?;\n            self.inner.serialize_value(&value)?;\n            Ok(())\n        }\n\n        fn end(self) -> Result<Value, Self::Error> {\n            self.inner.end()\n        }\n    }\n\n    impl<T: Serializer<Ok = Value, Error = serde_json::Error> + Clone> serde::ser::SerializeStruct\n        for SerializeMap<T>\n    {\n        type Ok = Value;\n        type Error = T::Error;\n\n        fn serialize_field<V>(&mut self, key: &'static str, value: &V) -> Result<(), Self::Error>\n        where\n            V: ?Sized + Serialize,\n        {\n            serde::ser::SerializeMap::serialize_entry(self, key, value)\n        }\n\n        fn end(self) -> Result<Value, Self::Error> {\n            serde::ser::SerializeMap::end(self)\n        }\n    }\n}\n", "function_name": "crates__masking__src__serde.rs", "file": "crates__masking__src__serde.rs"}, {"query": "Secret trait implementation", "code": "//! Serde-related.\n\npub use erased_serde::Serialize as ErasedSerialize;\npub use serde::{de, Deserialize, Serialize, Serializer};\nuse serde_json::{value::Serializer as JsonValueSerializer, Value};\n\nuse crate::{Secret, Strategy, StrongSecret, ZeroizableSecret};\n\n/// Marker trait for secret types which can be [`Serialize`]-d by [`serde`].\n///\n/// When the `serde` feature of this crate is enabled and types are marked with\n/// this trait, they receive a [`Serialize` impl] for `Secret<T>`.\n/// (NOTE: all types which impl `DeserializeOwned` receive a [`Deserialize`]\n/// impl)\n///\n/// This is done deliberately to prevent accidental exfiltration of secrets\n/// via `serde` serialization.\n#[cfg_attr(docsrs, cfg(feature = \"serde\"))]\npub trait SerializableSecret: Serialize {}\n// #[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n// pub trait NonSerializableSecret: Serialize {}\n\nimpl SerializableSecret for Value {}\nimpl SerializableSecret for u8 {}\nimpl SerializableSecret for u16 {}\nimpl SerializableSecret for i8 {}\nimpl SerializableSecret for i32 {}\nimpl SerializableSecret for i64 {}\nimpl SerializableSecret for url::Url {}\n\n#[cfg(feature = \"time\")]\nimpl SerializableSecret for time::Date {}\n\nimpl<T: SerializableSecret> SerializableSecret for &T {}\n\nimpl<'de, T, I> Deserialize<'de> for Secret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for Secret<T, I>\nwhere\n    T: SerializableSecret + Serialize + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\nimpl<'de, T, I> Deserialize<'de> for StrongSecret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized + ZeroizableSecret,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(de\n\n... [truncated 13925 chars] ...\n\n   self.inner.serialize_key(key)?;\n            Ok(())\n        }\n\n        fn serialize_value<V>(&mut self, value: &V) -> Result<(), Self::Error>\n        where\n            V: ?Sized + Serialize,\n        {\n            let value = value.serialize(self.ser.clone())?;\n            self.inner.serialize_value(&value)?;\n            Ok(())\n        }\n\n        fn end(self) -> Result<Value, Self::Error> {\n            self.inner.end()\n        }\n    }\n\n    impl<T: Serializer<Ok = Value, Error = serde_json::Error> + Clone> serde::ser::SerializeStruct\n        for SerializeMap<T>\n    {\n        type Ok = Value;\n        type Error = T::Error;\n\n        fn serialize_field<V>(&mut self, key: &'static str, value: &V) -> Result<(), Self::Error>\n        where\n            V: ?Sized + Serialize,\n        {\n            serde::ser::SerializeMap::serialize_entry(self, key, value)\n        }\n\n        fn end(self) -> Result<Value, Self::Error> {\n            serde::ser::SerializeMap::end(self)\n        }\n    }\n}\n", "function_name": "crates__masking__src__serde.rs", "file": "crates__masking__src__serde.rs"}, {"query": "how to implement masked serialization", "code": "//! Serde-related.\n\npub use erased_serde::Serialize as ErasedSerialize;\npub use serde::{de, Deserialize, Serialize, Serializer};\nuse serde_json::{value::Serializer as JsonValueSerializer, Value};\n\nuse crate::{Secret, Strategy, StrongSecret, ZeroizableSecret};\n\n/// Marker trait for secret types which can be [`Serialize`]-d by [`serde`].\n///\n/// When the `serde` feature of this crate is enabled and types are marked with\n/// this trait, they receive a [`Serialize` impl] for `Secret<T>`.\n/// (NOTE: all types which impl `DeserializeOwned` receive a [`Deserialize`]\n/// impl)\n///\n/// This is done deliberately to prevent accidental exfiltration of secrets\n/// via `serde` serialization.\n#[cfg_attr(docsrs, cfg(feature = \"serde\"))]\npub trait SerializableSecret: Serialize {}\n// #[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n// pub trait NonSerializableSecret: Serialize {}\n\nimpl SerializableSecret for Value {}\nimpl SerializableSecret for u8 {}\nimpl SerializableSecret for u16 {}\nimpl SerializableSecret for i8 {}\nimpl SerializableSecret for i32 {}\nimpl SerializableSecret for i64 {}\nimpl SerializableSecret for url::Url {}\n\n#[cfg(feature = \"time\")]\nimpl SerializableSecret for time::Date {}\n\nimpl<T: SerializableSecret> SerializableSecret for &T {}\n\nimpl<'de, T, I> Deserialize<'de> for Secret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for Secret<T, I>\nwhere\n    T: SerializableSecret + Serialize + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\nimpl<'de, T, I> Deserialize<'de> for StrongSecret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized + ZeroizableSecret,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(de\n\n... [truncated 13925 chars] ...\n\n   self.inner.serialize_key(key)?;\n            Ok(())\n        }\n\n        fn serialize_value<V>(&mut self, value: &V) -> Result<(), Self::Error>\n        where\n            V: ?Sized + Serialize,\n        {\n            let value = value.serialize(self.ser.clone())?;\n            self.inner.serialize_value(&value)?;\n            Ok(())\n        }\n\n        fn end(self) -> Result<Value, Self::Error> {\n            self.inner.end()\n        }\n    }\n\n    impl<T: Serializer<Ok = Value, Error = serde_json::Error> + Clone> serde::ser::SerializeStruct\n        for SerializeMap<T>\n    {\n        type Ok = Value;\n        type Error = T::Error;\n\n        fn serialize_field<V>(&mut self, key: &'static str, value: &V) -> Result<(), Self::Error>\n        where\n            V: ?Sized + Serialize,\n        {\n            serde::ser::SerializeMap::serialize_entry(self, key, value)\n        }\n\n        fn end(self) -> Result<Value, Self::Error> {\n            serde::ser::SerializeMap::end(self)\n        }\n    }\n}\n", "function_name": "crates__masking__src__serde.rs", "file": "crates__masking__src__serde.rs"}, {"query": "pii_serializer usage", "code": "//! Serde-related.\n\npub use erased_serde::Serialize as ErasedSerialize;\npub use serde::{de, Deserialize, Serialize, Serializer};\nuse serde_json::{value::Serializer as JsonValueSerializer, Value};\n\nuse crate::{Secret, Strategy, StrongSecret, ZeroizableSecret};\n\n/// Marker trait for secret types which can be [`Serialize`]-d by [`serde`].\n///\n/// When the `serde` feature of this crate is enabled and types are marked with\n/// this trait, they receive a [`Serialize` impl] for `Secret<T>`.\n/// (NOTE: all types which impl `DeserializeOwned` receive a [`Deserialize`]\n/// impl)\n///\n/// This is done deliberately to prevent accidental exfiltration of secrets\n/// via `serde` serialization.\n#[cfg_attr(docsrs, cfg(feature = \"serde\"))]\npub trait SerializableSecret: Serialize {}\n// #[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n// pub trait NonSerializableSecret: Serialize {}\n\nimpl SerializableSecret for Value {}\nimpl SerializableSecret for u8 {}\nimpl SerializableSecret for u16 {}\nimpl SerializableSecret for i8 {}\nimpl SerializableSecret for i32 {}\nimpl SerializableSecret for i64 {}\nimpl SerializableSecret for url::Url {}\n\n#[cfg(feature = \"time\")]\nimpl SerializableSecret for time::Date {}\n\nimpl<T: SerializableSecret> SerializableSecret for &T {}\n\nimpl<'de, T, I> Deserialize<'de> for Secret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for Secret<T, I>\nwhere\n    T: SerializableSecret + Serialize + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\nimpl<'de, T, I> Deserialize<'de> for StrongSecret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized + ZeroizableSecret,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(de\n\n... [truncated 13925 chars] ...\n\n   self.inner.serialize_key(key)?;\n            Ok(())\n        }\n\n        fn serialize_value<V>(&mut self, value: &V) -> Result<(), Self::Error>\n        where\n            V: ?Sized + Serialize,\n        {\n            let value = value.serialize(self.ser.clone())?;\n            self.inner.serialize_value(&value)?;\n            Ok(())\n        }\n\n        fn end(self) -> Result<Value, Self::Error> {\n            self.inner.end()\n        }\n    }\n\n    impl<T: Serializer<Ok = Value, Error = serde_json::Error> + Clone> serde::ser::SerializeStruct\n        for SerializeMap<T>\n    {\n        type Ok = Value;\n        type Error = T::Error;\n\n        fn serialize_field<V>(&mut self, key: &'static str, value: &V) -> Result<(), Self::Error>\n        where\n            V: ?Sized + Serialize,\n        {\n            serde::ser::SerializeMap::serialize_entry(self, key, value)\n        }\n\n        fn end(self) -> Result<Value, Self::Error> {\n            serde::ser::SerializeMap::end(self)\n        }\n    }\n}\n", "function_name": "crates__masking__src__serde.rs", "file": "crates__masking__src__serde.rs"}, {"query": "how to calculate percentage value in rust", "code": "//! Types that can be used in other crates\npub mod keymanager;\n\n/// Enum for Authentication Level\npub mod authentication;\n/// User related types\npub mod user;\n\n/// types that are wrappers around primitive types\npub mod primitive_wrappers;\n\nuse std::{\n    borrow::Cow,\n    fmt::Display,\n    iter::Sum,\n    num::NonZeroI64,\n    ops::{Add, Mul, Sub},\n    primitive::i64,\n    str::FromStr,\n};\n\nuse common_enums::enums;\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    serialize::{Output, ToSql},\n    sql_types,\n    sql_types::Jsonb,\n    AsExpression, FromSqlRow, Queryable,\n};\nuse error_stack::{report, ResultExt};\npub use primitive_wrappers::bool_wrappers::{\n    AlwaysRequestExtendedAuthorization, ExtendedAuthorizationAppliedBool,\n    RequestExtendedAuthorizationBool,\n};\nuse rust_decimal::{\n    prelude::{FromPrimitive, ToPrimitive},\n    Decimal,\n};\nuse semver::Version;\nuse serde::{de::Visitor, Deserialize, Deserializer, Serialize};\nuse thiserror::Error;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    consts::{\n        self, MAX_DESCRIPTION_LENGTH, MAX_STATEMENT_DESCRIPTOR_LENGTH, PUBLISHABLE_KEY_LENGTH,\n    },\n    errors::{CustomResult, ParsingError, PercentageError, ValidationError},\n    fp_utils::when,\n    id_type, impl_enum_str,\n};\n\n/// Represents Percentage Value between 0 and 100 both inclusive\n#[derive(Clone, Default, Debug, PartialEq, Serialize)]\npub struct Percentage<const PRECISION: u8> {\n    // this value will range from 0 to 100, decimal length defined by precision macro\n    /// Percentage value ranging between 0 and 100\n    percentage: f32,\n}\n\nfn get_invalid_percentage_error_message(precision: u8) -> String {\n    format!(\n        \"value should be a float between 0 to 100 and precise to only upto {precision} decimal digits\",\n\n    )\n}\n\nimpl<const PRECISION: u8> Percentage<PRECISION> {\n    /// construct percentage using a string representation of float value\n    pub fn from_string(value: String) -> CustomResult<Self, Percen\n\n... [truncated 42461 chars] ...\n\n enum CreatedBy {\n        /// Api variant\n        Api {\n            /// merchant id of creator.\n            merchant_id: String,\n        },\n        /// Jwt variant\n        Jwt {\n            /// user id of creator.\n            user_id: String,\n        },\n        /// EmbeddedToken variant\n        EmbeddedToken {\n            /// merchant id of creator.\n            merchant_id: String,\n        },\n    }\n);\n\n/// Trait for enums created with `impl_enum_str!` macro that have an `Invalid` variant.\n/// This trait allows generic functions to check if a parsed enum value is invalid.\npub trait HasInvalidVariant {\n    /// Returns true if this instance is the `Invalid` variant\n    fn is_invalid(&self) -> bool;\n}\n\n#[allow(missing_docs)]\npub trait TenantConfig: Send + Sync {\n    fn get_tenant_id(&self) -> &id_type::TenantId;\n    fn get_schema(&self) -> &str;\n    fn get_accounts_schema(&self) -> &str;\n    fn get_redis_key_prefix(&self) -> &str;\n    fn get_clickhouse_database(&self) -> &str;\n}\n", "function_name": "crates__common_utils__src__types.rs", "file": "crates__common_utils__src__types.rs"}, {"query": "PublishableKey type definition", "code": "//! Types that can be used in other crates\npub mod keymanager;\n\n/// Enum for Authentication Level\npub mod authentication;\n/// User related types\npub mod user;\n\n/// types that are wrappers around primitive types\npub mod primitive_wrappers;\n\nuse std::{\n    borrow::Cow,\n    fmt::Display,\n    iter::Sum,\n    num::NonZeroI64,\n    ops::{Add, Mul, Sub},\n    primitive::i64,\n    str::FromStr,\n};\n\nuse common_enums::enums;\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    serialize::{Output, ToSql},\n    sql_types,\n    sql_types::Jsonb,\n    AsExpression, FromSqlRow, Queryable,\n};\nuse error_stack::{report, ResultExt};\npub use primitive_wrappers::bool_wrappers::{\n    AlwaysRequestExtendedAuthorization, ExtendedAuthorizationAppliedBool,\n    RequestExtendedAuthorizationBool,\n};\nuse rust_decimal::{\n    prelude::{FromPrimitive, ToPrimitive},\n    Decimal,\n};\nuse semver::Version;\nuse serde::{de::Visitor, Deserialize, Deserializer, Serialize};\nuse thiserror::Error;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    consts::{\n        self, MAX_DESCRIPTION_LENGTH, MAX_STATEMENT_DESCRIPTOR_LENGTH, PUBLISHABLE_KEY_LENGTH,\n    },\n    errors::{CustomResult, ParsingError, PercentageError, ValidationError},\n    fp_utils::when,\n    id_type, impl_enum_str,\n};\n\n/// Represents Percentage Value between 0 and 100 both inclusive\n#[derive(Clone, Default, Debug, PartialEq, Serialize)]\npub struct Percentage<const PRECISION: u8> {\n    // this value will range from 0 to 100, decimal length defined by precision macro\n    /// Percentage value ranging between 0 and 100\n    percentage: f32,\n}\n\nfn get_invalid_percentage_error_message(precision: u8) -> String {\n    format!(\n        \"value should be a float between 0 to 100 and precise to only upto {precision} decimal digits\",\n\n    )\n}\n\nimpl<const PRECISION: u8> Percentage<PRECISION> {\n    /// construct percentage using a string representation of float value\n    pub fn from_string(value: String) -> CustomResult<Self, Percen\n\n... [truncated 42461 chars] ...\n\n enum CreatedBy {\n        /// Api variant\n        Api {\n            /// merchant id of creator.\n            merchant_id: String,\n        },\n        /// Jwt variant\n        Jwt {\n            /// user id of creator.\n            user_id: String,\n        },\n        /// EmbeddedToken variant\n        EmbeddedToken {\n            /// merchant id of creator.\n            merchant_id: String,\n        },\n    }\n);\n\n/// Trait for enums created with `impl_enum_str!` macro that have an `Invalid` variant.\n/// This trait allows generic functions to check if a parsed enum value is invalid.\npub trait HasInvalidVariant {\n    /// Returns true if this instance is the `Invalid` variant\n    fn is_invalid(&self) -> bool;\n}\n\n#[allow(missing_docs)]\npub trait TenantConfig: Send + Sync {\n    fn get_tenant_id(&self) -> &id_type::TenantId;\n    fn get_schema(&self) -> &str;\n    fn get_accounts_schema(&self) -> &str;\n    fn get_redis_key_prefix(&self) -> &str;\n    fn get_clickhouse_database(&self) -> &str;\n}\n", "function_name": "crates__common_utils__src__types.rs", "file": "crates__common_utils__src__types.rs"}, {"query": "implement custom string length validation", "code": "//! Types that can be used in other crates\npub mod keymanager;\n\n/// Enum for Authentication Level\npub mod authentication;\n/// User related types\npub mod user;\n\n/// types that are wrappers around primitive types\npub mod primitive_wrappers;\n\nuse std::{\n    borrow::Cow,\n    fmt::Display,\n    iter::Sum,\n    num::NonZeroI64,\n    ops::{Add, Mul, Sub},\n    primitive::i64,\n    str::FromStr,\n};\n\nuse common_enums::enums;\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    serialize::{Output, ToSql},\n    sql_types,\n    sql_types::Jsonb,\n    AsExpression, FromSqlRow, Queryable,\n};\nuse error_stack::{report, ResultExt};\npub use primitive_wrappers::bool_wrappers::{\n    AlwaysRequestExtendedAuthorization, ExtendedAuthorizationAppliedBool,\n    RequestExtendedAuthorizationBool,\n};\nuse rust_decimal::{\n    prelude::{FromPrimitive, ToPrimitive},\n    Decimal,\n};\nuse semver::Version;\nuse serde::{de::Visitor, Deserialize, Deserializer, Serialize};\nuse thiserror::Error;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    consts::{\n        self, MAX_DESCRIPTION_LENGTH, MAX_STATEMENT_DESCRIPTOR_LENGTH, PUBLISHABLE_KEY_LENGTH,\n    },\n    errors::{CustomResult, ParsingError, PercentageError, ValidationError},\n    fp_utils::when,\n    id_type, impl_enum_str,\n};\n\n/// Represents Percentage Value between 0 and 100 both inclusive\n#[derive(Clone, Default, Debug, PartialEq, Serialize)]\npub struct Percentage<const PRECISION: u8> {\n    // this value will range from 0 to 100, decimal length defined by precision macro\n    /// Percentage value ranging between 0 and 100\n    percentage: f32,\n}\n\nfn get_invalid_percentage_error_message(precision: u8) -> String {\n    format!(\n        \"value should be a float between 0 to 100 and precise to only upto {precision} decimal digits\",\n\n    )\n}\n\nimpl<const PRECISION: u8> Percentage<PRECISION> {\n    /// construct percentage using a string representation of float value\n    pub fn from_string(value: String) -> CustomResult<Self, Percen\n\n... [truncated 42461 chars] ...\n\n enum CreatedBy {\n        /// Api variant\n        Api {\n            /// merchant id of creator.\n            merchant_id: String,\n        },\n        /// Jwt variant\n        Jwt {\n            /// user id of creator.\n            user_id: String,\n        },\n        /// EmbeddedToken variant\n        EmbeddedToken {\n            /// merchant id of creator.\n            merchant_id: String,\n        },\n    }\n);\n\n/// Trait for enums created with `impl_enum_str!` macro that have an `Invalid` variant.\n/// This trait allows generic functions to check if a parsed enum value is invalid.\npub trait HasInvalidVariant {\n    /// Returns true if this instance is the `Invalid` variant\n    fn is_invalid(&self) -> bool;\n}\n\n#[allow(missing_docs)]\npub trait TenantConfig: Send + Sync {\n    fn get_tenant_id(&self) -> &id_type::TenantId;\n    fn get_schema(&self) -> &str;\n    fn get_accounts_schema(&self) -> &str;\n    fn get_redis_key_prefix(&self) -> &str;\n    fn get_clickhouse_database(&self) -> &str;\n}\n", "function_name": "crates__common_utils__src__types.rs", "file": "crates__common_utils__src__types.rs"}, {"query": "payment orchestration platform data types", "code": "//! Types that can be used in other crates\npub mod keymanager;\n\n/// Enum for Authentication Level\npub mod authentication;\n/// User related types\npub mod user;\n\n/// types that are wrappers around primitive types\npub mod primitive_wrappers;\n\nuse std::{\n    borrow::Cow,\n    fmt::Display,\n    iter::Sum,\n    num::NonZeroI64,\n    ops::{Add, Mul, Sub},\n    primitive::i64,\n    str::FromStr,\n};\n\nuse common_enums::enums;\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    serialize::{Output, ToSql},\n    sql_types,\n    sql_types::Jsonb,\n    AsExpression, FromSqlRow, Queryable,\n};\nuse error_stack::{report, ResultExt};\npub use primitive_wrappers::bool_wrappers::{\n    AlwaysRequestExtendedAuthorization, ExtendedAuthorizationAppliedBool,\n    RequestExtendedAuthorizationBool,\n};\nuse rust_decimal::{\n    prelude::{FromPrimitive, ToPrimitive},\n    Decimal,\n};\nuse semver::Version;\nuse serde::{de::Visitor, Deserialize, Deserializer, Serialize};\nuse thiserror::Error;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    consts::{\n        self, MAX_DESCRIPTION_LENGTH, MAX_STATEMENT_DESCRIPTOR_LENGTH, PUBLISHABLE_KEY_LENGTH,\n    },\n    errors::{CustomResult, ParsingError, PercentageError, ValidationError},\n    fp_utils::when,\n    id_type, impl_enum_str,\n};\n\n/// Represents Percentage Value between 0 and 100 both inclusive\n#[derive(Clone, Default, Debug, PartialEq, Serialize)]\npub struct Percentage<const PRECISION: u8> {\n    // this value will range from 0 to 100, decimal length defined by precision macro\n    /// Percentage value ranging between 0 and 100\n    percentage: f32,\n}\n\nfn get_invalid_percentage_error_message(precision: u8) -> String {\n    format!(\n        \"value should be a float between 0 to 100 and precise to only upto {precision} decimal digits\",\n\n    )\n}\n\nimpl<const PRECISION: u8> Percentage<PRECISION> {\n    /// construct percentage using a string representation of float value\n    pub fn from_string(value: String) -> CustomResult<Self, Percen\n\n... [truncated 42461 chars] ...\n\n enum CreatedBy {\n        /// Api variant\n        Api {\n            /// merchant id of creator.\n            merchant_id: String,\n        },\n        /// Jwt variant\n        Jwt {\n            /// user id of creator.\n            user_id: String,\n        },\n        /// EmbeddedToken variant\n        EmbeddedToken {\n            /// merchant id of creator.\n            merchant_id: String,\n        },\n    }\n);\n\n/// Trait for enums created with `impl_enum_str!` macro that have an `Invalid` variant.\n/// This trait allows generic functions to check if a parsed enum value is invalid.\npub trait HasInvalidVariant {\n    /// Returns true if this instance is the `Invalid` variant\n    fn is_invalid(&self) -> bool;\n}\n\n#[allow(missing_docs)]\npub trait TenantConfig: Send + Sync {\n    fn get_tenant_id(&self) -> &id_type::TenantId;\n    fn get_schema(&self) -> &str;\n    fn get_accounts_schema(&self) -> &str;\n    fn get_redis_key_prefix(&self) -> &str;\n    fn get_clickhouse_database(&self) -> &str;\n}\n", "function_name": "crates__common_utils__src__types.rs", "file": "crates__common_utils__src__types.rs"}, {"query": "Santander payment response types", "code": "use common_utils::types::StringMajorUnit;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::connectors::santander::requests;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Payer {\n    pub name: Secret<String>,\n    pub document_type: SantanderDocumentKind,\n    pub document_number: Option<Secret<String>>,\n    pub address: Option<Secret<String>>,\n    pub neighborhood: Option<Secret<String>>,\n    pub city: Option<Secret<String>>,\n    pub state: Option<Secret<String>>,\n    pub zip_code: Option<Secret<String>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum SantanderDocumentKind {\n    Cnpj,\n    Cpf,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Beneficiary {\n    pub name: Option<Secret<String>>,\n    pub document_type: Option<String>,\n    pub document_number: Option<Secret<String>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SantanderBoletoDocumentKind {\n    // Used when selling goods/products (commercial invoice).\n    DuplicataMercantil,\n    // Used when selling services (service invoice).\n    DuplicataServico,\n    // A standard promissory note  customer promises to pay later.\n    NotaPromissoria,\n    // Promissory note related to rural/agricultural operations.\n    NotaPromissoriaRural,\n    // A receipt, usually when the boleto is tied to a receipt-type transaction.\n    Recibo,\n    // Related to insurance policy payments.\n    ApoliceSeguro,\n    // Used when the boleto is tied to credit card operations (e.g., card invoice).\n    BoletoCartaoCredito,\n    // For payments related to commercial proposals/quotes.\n    BoletoProposta,\n    // For deposit or funding (aporte) into an account (e.g., prepaid wallet top-up).\n    BoletoDepositoAporte,\n    // Payment related to a cheque transaction.\n    Cheque,\n    // A direct promissory note \n\n... [truncated 20114 chars] ...\n\nnterest_value: Option<StringMajorUnit>,\n    pub fine_value: Option<StringMajorUnit>,\n    pub deduction_value: Option<StringMajorUnit>,\n    pub rebate_value: Option<StringMajorUnit>,\n    pub iof_value: Option<StringMajorUnit>,\n    pub date: Option<String>,\n    #[serde(rename = \"type\")]\n    pub bank_type: Option<String>,\n    pub bank_code: Option<String>,\n    pub channel: Option<String>,\n    pub kind: Option<String>,\n    pub credit_date: Option<String>,\n    pub tx_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SantanderBoletoStatus {\n    /// The boleto is registered and waiting for payment.\n    /// It is currently valid and within its expiration period.\n    Ativo,\n    /// The boleto has been cancelled or removed from the bank's\n    Baixado,\n    /// The boleto has been paid in full. The funds have been cleared and settled.\n    Liquidado,\n    /// A partial payment was made\n    LiquidadoParcialmente,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__santander__responses.rs", "file": "crates__hyperswitch_connectors__src__connectors__santander__responses.rs"}, {"query": "how to parse Santander boleto API", "code": "use common_utils::types::StringMajorUnit;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::connectors::santander::requests;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Payer {\n    pub name: Secret<String>,\n    pub document_type: SantanderDocumentKind,\n    pub document_number: Option<Secret<String>>,\n    pub address: Option<Secret<String>>,\n    pub neighborhood: Option<Secret<String>>,\n    pub city: Option<Secret<String>>,\n    pub state: Option<Secret<String>>,\n    pub zip_code: Option<Secret<String>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum SantanderDocumentKind {\n    Cnpj,\n    Cpf,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Beneficiary {\n    pub name: Option<Secret<String>>,\n    pub document_type: Option<String>,\n    pub document_number: Option<Secret<String>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SantanderBoletoDocumentKind {\n    // Used when selling goods/products (commercial invoice).\n    DuplicataMercantil,\n    // Used when selling services (service invoice).\n    DuplicataServico,\n    // A standard promissory note  customer promises to pay later.\n    NotaPromissoria,\n    // Promissory note related to rural/agricultural operations.\n    NotaPromissoriaRural,\n    // A receipt, usually when the boleto is tied to a receipt-type transaction.\n    Recibo,\n    // Related to insurance policy payments.\n    ApoliceSeguro,\n    // Used when the boleto is tied to credit card operations (e.g., card invoice).\n    BoletoCartaoCredito,\n    // For payments related to commercial proposals/quotes.\n    BoletoProposta,\n    // For deposit or funding (aporte) into an account (e.g., prepaid wallet top-up).\n    BoletoDepositoAporte,\n    // Payment related to a cheque transaction.\n    Cheque,\n    // A direct promissory note \n\n... [truncated 20114 chars] ...\n\nnterest_value: Option<StringMajorUnit>,\n    pub fine_value: Option<StringMajorUnit>,\n    pub deduction_value: Option<StringMajorUnit>,\n    pub rebate_value: Option<StringMajorUnit>,\n    pub iof_value: Option<StringMajorUnit>,\n    pub date: Option<String>,\n    #[serde(rename = \"type\")]\n    pub bank_type: Option<String>,\n    pub bank_code: Option<String>,\n    pub channel: Option<String>,\n    pub kind: Option<String>,\n    pub credit_date: Option<String>,\n    pub tx_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SantanderBoletoStatus {\n    /// The boleto is registered and waiting for payment.\n    /// It is currently valid and within its expiration period.\n    Ativo,\n    /// The boleto has been cancelled or removed from the bank's\n    Baixado,\n    /// The boleto has been paid in full. The funds have been cleared and settled.\n    Liquidado,\n    /// A partial payment was made\n    LiquidadoParcialmente,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__santander__responses.rs", "file": "crates__hyperswitch_connectors__src__connectors__santander__responses.rs"}, {"query": "SantanderBeneficiary struct definition", "code": "use common_utils::types::StringMajorUnit;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::connectors::santander::requests;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Payer {\n    pub name: Secret<String>,\n    pub document_type: SantanderDocumentKind,\n    pub document_number: Option<Secret<String>>,\n    pub address: Option<Secret<String>>,\n    pub neighborhood: Option<Secret<String>>,\n    pub city: Option<Secret<String>>,\n    pub state: Option<Secret<String>>,\n    pub zip_code: Option<Secret<String>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum SantanderDocumentKind {\n    Cnpj,\n    Cpf,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Beneficiary {\n    pub name: Option<Secret<String>>,\n    pub document_type: Option<String>,\n    pub document_number: Option<Secret<String>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SantanderBoletoDocumentKind {\n    // Used when selling goods/products (commercial invoice).\n    DuplicataMercantil,\n    // Used when selling services (service invoice).\n    DuplicataServico,\n    // A standard promissory note  customer promises to pay later.\n    NotaPromissoria,\n    // Promissory note related to rural/agricultural operations.\n    NotaPromissoriaRural,\n    // A receipt, usually when the boleto is tied to a receipt-type transaction.\n    Recibo,\n    // Related to insurance policy payments.\n    ApoliceSeguro,\n    // Used when the boleto is tied to credit card operations (e.g., card invoice).\n    BoletoCartaoCredito,\n    // For payments related to commercial proposals/quotes.\n    BoletoProposta,\n    // For deposit or funding (aporte) into an account (e.g., prepaid wallet top-up).\n    BoletoDepositoAporte,\n    // Payment related to a cheque transaction.\n    Cheque,\n    // A direct promissory note \n\n... [truncated 20114 chars] ...\n\nnterest_value: Option<StringMajorUnit>,\n    pub fine_value: Option<StringMajorUnit>,\n    pub deduction_value: Option<StringMajorUnit>,\n    pub rebate_value: Option<StringMajorUnit>,\n    pub iof_value: Option<StringMajorUnit>,\n    pub date: Option<String>,\n    #[serde(rename = \"type\")]\n    pub bank_type: Option<String>,\n    pub bank_code: Option<String>,\n    pub channel: Option<String>,\n    pub kind: Option<String>,\n    pub credit_date: Option<String>,\n    pub tx_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SantanderBoletoStatus {\n    /// The boleto is registered and waiting for payment.\n    /// It is currently valid and within its expiration period.\n    Ativo,\n    /// The boleto has been cancelled or removed from the bank's\n    Baixado,\n    /// The boleto has been paid in full. The funds have been cleared and settled.\n    Liquidado,\n    /// A partial payment was made\n    LiquidadoParcialmente,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__santander__responses.rs", "file": "crates__hyperswitch_connectors__src__connectors__santander__responses.rs"}, {"query": "SantanderPaymentStatus enum values", "code": "use common_utils::types::StringMajorUnit;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\nuse crate::connectors::santander::requests;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Payer {\n    pub name: Secret<String>,\n    pub document_type: SantanderDocumentKind,\n    pub document_number: Option<Secret<String>>,\n    pub address: Option<Secret<String>>,\n    pub neighborhood: Option<Secret<String>>,\n    pub city: Option<Secret<String>>,\n    pub state: Option<Secret<String>>,\n    pub zip_code: Option<Secret<String>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum SantanderDocumentKind {\n    Cnpj,\n    Cpf,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Beneficiary {\n    pub name: Option<Secret<String>>,\n    pub document_type: Option<String>,\n    pub document_number: Option<Secret<String>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SantanderBoletoDocumentKind {\n    // Used when selling goods/products (commercial invoice).\n    DuplicataMercantil,\n    // Used when selling services (service invoice).\n    DuplicataServico,\n    // A standard promissory note  customer promises to pay later.\n    NotaPromissoria,\n    // Promissory note related to rural/agricultural operations.\n    NotaPromissoriaRural,\n    // A receipt, usually when the boleto is tied to a receipt-type transaction.\n    Recibo,\n    // Related to insurance policy payments.\n    ApoliceSeguro,\n    // Used when the boleto is tied to credit card operations (e.g., card invoice).\n    BoletoCartaoCredito,\n    // For payments related to commercial proposals/quotes.\n    BoletoProposta,\n    // For deposit or funding (aporte) into an account (e.g., prepaid wallet top-up).\n    BoletoDepositoAporte,\n    // Payment related to a cheque transaction.\n    Cheque,\n    // A direct promissory note \n\n... [truncated 20114 chars] ...\n\nnterest_value: Option<StringMajorUnit>,\n    pub fine_value: Option<StringMajorUnit>,\n    pub deduction_value: Option<StringMajorUnit>,\n    pub rebate_value: Option<StringMajorUnit>,\n    pub iof_value: Option<StringMajorUnit>,\n    pub date: Option<String>,\n    #[serde(rename = \"type\")]\n    pub bank_type: Option<String>,\n    pub bank_code: Option<String>,\n    pub channel: Option<String>,\n    pub kind: Option<String>,\n    pub credit_date: Option<String>,\n    pub tx_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SantanderBoletoStatus {\n    /// The boleto is registered and waiting for payment.\n    /// It is currently valid and within its expiration period.\n    Ativo,\n    /// The boleto has been cancelled or removed from the bank's\n    Baixado,\n    /// The boleto has been paid in full. The funds have been cleared and settled.\n    Liquidado,\n    /// A partial payment was made\n    LiquidadoParcialmente,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__santander__responses.rs", "file": "crates__hyperswitch_connectors__src__connectors__santander__responses.rs"}, {"query": "Nomupay connector implementation", "code": "pub mod transformers;\n\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    pii,\n    request::{Method, RequestContent},\n};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Request, RequestBuilder},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoRecipientAccount,\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types;\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse josekit::{\n    jws::{self, JwsHeader, ES256},\n    jwt::{self, JwtPayload},\n    Map, Value,\n};\nuse masking::{ExposeInterface, Mask};\n#\n\n... [truncated 25889 chars] ...\n\nequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic NOMUPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Nomupay\",\n    description: \"Nomupay payouts connector for disbursements to recipients' bank accounts and alternative payment methods in Southeast Asia and the Pacific Islands\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Nomupay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NOMUPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nomupay.rs", "file": "crates__hyperswitch_connectors__src__connectors__nomupay.rs"}, {"query": "how to configure Nomupay payouts", "code": "pub mod transformers;\n\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    pii,\n    request::{Method, RequestContent},\n};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Request, RequestBuilder},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoRecipientAccount,\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types;\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse josekit::{\n    jws::{self, JwsHeader, ES256},\n    jwt::{self, JwtPayload},\n    Map, Value,\n};\nuse masking::{ExposeInterface, Mask};\n#\n\n... [truncated 25889 chars] ...\n\nequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic NOMUPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Nomupay\",\n    description: \"Nomupay payouts connector for disbursements to recipients' bank accounts and alternative payment methods in Southeast Asia and the Pacific Islands\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Nomupay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NOMUPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nomupay.rs", "file": "crates__hyperswitch_connectors__src__connectors__nomupay.rs"}, {"query": "Nomupay webhook handling", "code": "pub mod transformers;\n\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    pii,\n    request::{Method, RequestContent},\n};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Request, RequestBuilder},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoRecipientAccount,\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types;\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse josekit::{\n    jws::{self, JwsHeader, ES256},\n    jwt::{self, JwtPayload},\n    Map, Value,\n};\nuse masking::{ExposeInterface, Mask};\n#\n\n... [truncated 25889 chars] ...\n\nequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic NOMUPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Nomupay\",\n    description: \"Nomupay payouts connector for disbursements to recipients' bank accounts and alternative payment methods in Southeast Asia and the Pacific Islands\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Nomupay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NOMUPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nomupay.rs", "file": "crates__hyperswitch_connectors__src__connectors__nomupay.rs"}, {"query": "Hyperswitch Southeast Asia payout connector", "code": "pub mod transformers;\n\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    pii,\n    request::{Method, RequestContent},\n};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Request, RequestBuilder},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoRecipientAccount,\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types;\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse josekit::{\n    jws::{self, JwsHeader, ES256},\n    jwt::{self, JwtPayload},\n    Map, Value,\n};\nuse masking::{ExposeInterface, Mask};\n#\n\n... [truncated 25889 chars] ...\n\nequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic NOMUPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Nomupay\",\n    description: \"Nomupay payouts connector for disbursements to recipients' bank accounts and alternative payment methods in Southeast Asia and the Pacific Islands\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Nomupay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NOMUPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nomupay.rs", "file": "crates__hyperswitch_connectors__src__connectors__nomupay.rs"}, {"query": "hyperswitch euclid graph implementation", "code": "use std::{fmt::Debug, sync::Weak};\n\nuse hyperswitch_constraint_graph as cgraph;\nuse rustc_hash::{FxHashMap, FxHashSet};\n\nuse crate::{\n    dssa::types,\n    frontend::dir,\n    types::{DataType, Metadata},\n};\n\npub mod euclid_graph_prelude {\n    pub use hyperswitch_constraint_graph as cgraph;\n    pub use rustc_hash::{FxHashMap, FxHashSet};\n    pub use strum::EnumIter;\n\n    pub use crate::{\n        dssa::graph::*,\n        frontend::dir::{enums::*, DirKey, DirKeyKind, DirValue},\n        types::*,\n    };\n}\n\nimpl cgraph::KeyNode for dir::DirKey {}\n\nimpl cgraph::NodeViz for dir::DirKey {\n    fn viz(&self) -> String {\n        self.kind.to_string()\n    }\n}\n\nimpl cgraph::ValueNode for dir::DirValue {\n    type Key = dir::DirKey;\n\n    fn get_key(&self) -> Self::Key {\n        Self::get_key(self)\n    }\n}\n\nimpl cgraph::NodeViz for dir::DirValue {\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.\n\n... [truncated 34212 chars] ...\n\nelation::Positive,\n                None::<cgraph::DomainId>,\n            )\n            .expect(\"Failed to make an edge\");\n        let _edge_7 = builder\n            .make_edge(\n                _node_4,\n                _node_0,\n                cgraph::Strength::Normal,\n                cgraph::Relation::Positive,\n                None::<cgraph::DomainId>,\n            )\n            .expect(\"Failed to make an edge\");\n\n        let graph = builder.build();\n        let _result = graph.key_value_analysis(\n            dirval!(BillingCountry = Afghanistan),\n            &AnalysisContext::from_dir_values([\n                dirval!(PaymentCurrency = USD),\n                dirval!(PaymentMethod = Card),\n                dirval!(PaymentMethod = Wallet),\n                dirval!(CaptureMethod = Automatic),\n                dirval!(BillingCountry = Afghanistan),\n            ]),\n            &mut memo,\n            &mut cycle_map,\n            None,\n        );\n\n        assert!(_result.is_ok());\n    }\n}\n", "function_name": "crates__euclid__src__dssa__graph.rs", "file": "crates__euclid__src__dssa__graph.rs"}, {"query": "how to build constraint graph edges", "code": "use std::{fmt::Debug, sync::Weak};\n\nuse hyperswitch_constraint_graph as cgraph;\nuse rustc_hash::{FxHashMap, FxHashSet};\n\nuse crate::{\n    dssa::types,\n    frontend::dir,\n    types::{DataType, Metadata},\n};\n\npub mod euclid_graph_prelude {\n    pub use hyperswitch_constraint_graph as cgraph;\n    pub use rustc_hash::{FxHashMap, FxHashSet};\n    pub use strum::EnumIter;\n\n    pub use crate::{\n        dssa::graph::*,\n        frontend::dir::{enums::*, DirKey, DirKeyKind, DirValue},\n        types::*,\n    };\n}\n\nimpl cgraph::KeyNode for dir::DirKey {}\n\nimpl cgraph::NodeViz for dir::DirKey {\n    fn viz(&self) -> String {\n        self.kind.to_string()\n    }\n}\n\nimpl cgraph::ValueNode for dir::DirValue {\n    type Key = dir::DirKey;\n\n    fn get_key(&self) -> Self::Key {\n        Self::get_key(self)\n    }\n}\n\nimpl cgraph::NodeViz for dir::DirValue {\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.\n\n... [truncated 34212 chars] ...\n\nelation::Positive,\n                None::<cgraph::DomainId>,\n            )\n            .expect(\"Failed to make an edge\");\n        let _edge_7 = builder\n            .make_edge(\n                _node_4,\n                _node_0,\n                cgraph::Strength::Normal,\n                cgraph::Relation::Positive,\n                None::<cgraph::DomainId>,\n            )\n            .expect(\"Failed to make an edge\");\n\n        let graph = builder.build();\n        let _result = graph.key_value_analysis(\n            dirval!(BillingCountry = Afghanistan),\n            &AnalysisContext::from_dir_values([\n                dirval!(PaymentCurrency = USD),\n                dirval!(PaymentMethod = Card),\n                dirval!(PaymentMethod = Wallet),\n                dirval!(CaptureMethod = Automatic),\n                dirval!(BillingCountry = Afghanistan),\n            ]),\n            &mut memo,\n            &mut cycle_map,\n            None,\n        );\n\n        assert!(_result.is_ok());\n    }\n}\n", "function_name": "crates__euclid__src__dssa__graph.rs", "file": "crates__euclid__src__dssa__graph.rs"}, {"query": "DirValue node types definition", "code": "use std::{fmt::Debug, sync::Weak};\n\nuse hyperswitch_constraint_graph as cgraph;\nuse rustc_hash::{FxHashMap, FxHashSet};\n\nuse crate::{\n    dssa::types,\n    frontend::dir,\n    types::{DataType, Metadata},\n};\n\npub mod euclid_graph_prelude {\n    pub use hyperswitch_constraint_graph as cgraph;\n    pub use rustc_hash::{FxHashMap, FxHashSet};\n    pub use strum::EnumIter;\n\n    pub use crate::{\n        dssa::graph::*,\n        frontend::dir::{enums::*, DirKey, DirKeyKind, DirValue},\n        types::*,\n    };\n}\n\nimpl cgraph::KeyNode for dir::DirKey {}\n\nimpl cgraph::NodeViz for dir::DirKey {\n    fn viz(&self) -> String {\n        self.kind.to_string()\n    }\n}\n\nimpl cgraph::ValueNode for dir::DirValue {\n    type Key = dir::DirKey;\n\n    fn get_key(&self) -> Self::Key {\n        Self::get_key(self)\n    }\n}\n\nimpl cgraph::NodeViz for dir::DirValue {\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.\n\n... [truncated 34212 chars] ...\n\nelation::Positive,\n                None::<cgraph::DomainId>,\n            )\n            .expect(\"Failed to make an edge\");\n        let _edge_7 = builder\n            .make_edge(\n                _node_4,\n                _node_0,\n                cgraph::Strength::Normal,\n                cgraph::Relation::Positive,\n                None::<cgraph::DomainId>,\n            )\n            .expect(\"Failed to make an edge\");\n\n        let graph = builder.build();\n        let _result = graph.key_value_analysis(\n            dirval!(BillingCountry = Afghanistan),\n            &AnalysisContext::from_dir_values([\n                dirval!(PaymentCurrency = USD),\n                dirval!(PaymentMethod = Card),\n                dirval!(PaymentMethod = Wallet),\n                dirval!(CaptureMethod = Automatic),\n                dirval!(BillingCountry = Afghanistan),\n            ]),\n            &mut memo,\n            &mut cycle_map,\n            None,\n        );\n\n        assert!(_result.is_ok());\n    }\n}\n", "function_name": "crates__euclid__src__dssa__graph.rs", "file": "crates__euclid__src__dssa__graph.rs"}, {"query": "payment orchestration graph analysis", "code": "use std::{fmt::Debug, sync::Weak};\n\nuse hyperswitch_constraint_graph as cgraph;\nuse rustc_hash::{FxHashMap, FxHashSet};\n\nuse crate::{\n    dssa::types,\n    frontend::dir,\n    types::{DataType, Metadata},\n};\n\npub mod euclid_graph_prelude {\n    pub use hyperswitch_constraint_graph as cgraph;\n    pub use rustc_hash::{FxHashMap, FxHashSet};\n    pub use strum::EnumIter;\n\n    pub use crate::{\n        dssa::graph::*,\n        frontend::dir::{enums::*, DirKey, DirKeyKind, DirValue},\n        types::*,\n    };\n}\n\nimpl cgraph::KeyNode for dir::DirKey {}\n\nimpl cgraph::NodeViz for dir::DirKey {\n    fn viz(&self) -> String {\n        self.kind.to_string()\n    }\n}\n\nimpl cgraph::ValueNode for dir::DirValue {\n    type Key = dir::DirKey;\n\n    fn get_key(&self) -> Self::Key {\n        Self::get_key(self)\n    }\n}\n\nimpl cgraph::NodeViz for dir::DirValue {\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.\n\n... [truncated 34212 chars] ...\n\nelation::Positive,\n                None::<cgraph::DomainId>,\n            )\n            .expect(\"Failed to make an edge\");\n        let _edge_7 = builder\n            .make_edge(\n                _node_4,\n                _node_0,\n                cgraph::Strength::Normal,\n                cgraph::Relation::Positive,\n                None::<cgraph::DomainId>,\n            )\n            .expect(\"Failed to make an edge\");\n\n        let graph = builder.build();\n        let _result = graph.key_value_analysis(\n            dirval!(BillingCountry = Afghanistan),\n            &AnalysisContext::from_dir_values([\n                dirval!(PaymentCurrency = USD),\n                dirval!(PaymentMethod = Card),\n                dirval!(PaymentMethod = Wallet),\n                dirval!(CaptureMethod = Automatic),\n                dirval!(BillingCountry = Afghanistan),\n            ]),\n            &mut memo,\n            &mut cycle_map,\n            None,\n        );\n\n        assert!(_result.is_ok());\n    }\n}\n", "function_name": "crates__euclid__src__dssa__graph.rs", "file": "crates__euclid__src__dssa__graph.rs"}, {"query": "how to implement Zift payment connector", "code": "use api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{refunds::Execute, PSync},\n    router_request_types::{\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{AdditionalCardInfo, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZiftAuthType {\n    user_name: Secret<String>,\n    password: Secret<String>,\n    account_id: Secret<String>,\n}\nimpl TryFrom<&ConnectorAuthType> for ZiftAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                user_name: api_key.to_owned(),\n                password: api_secret.to_owned(),\n                account_id: key1.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType.into())\n        }\n    }\n}\n\npub struct ZiftRouterData<T> {\n    pub amount: \n\n... [truncated 36800 chars] ...\n\ntion_data: None,\n                    charges: None,\n                }),\n                ..item.data\n            })\n        } else {\n            Ok(Self {\n                status: common_enums::AttemptStatus::Failure,\n                response: Err(ErrorResponse {\n                    code: item.response.response_code.clone(),\n                    message: item.response.response_message.clone(),\n                    reason: Some(item.response.response_message.clone()),\n                    status_code: item.http_code,\n                    attempt_status: None,\n                    connector_transaction_id: item.response.transaction_id.map(|id| id.to_string()),\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..item.data\n            })\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zift__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__zift__transformers.rs"}, {"query": "ZiftRouterData struct definition", "code": "use api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{refunds::Execute, PSync},\n    router_request_types::{\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{AdditionalCardInfo, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZiftAuthType {\n    user_name: Secret<String>,\n    password: Secret<String>,\n    account_id: Secret<String>,\n}\nimpl TryFrom<&ConnectorAuthType> for ZiftAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                user_name: api_key.to_owned(),\n                password: api_secret.to_owned(),\n                account_id: key1.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType.into())\n        }\n    }\n}\n\npub struct ZiftRouterData<T> {\n    pub amount: \n\n... [truncated 36800 chars] ...\n\ntion_data: None,\n                    charges: None,\n                }),\n                ..item.data\n            })\n        } else {\n            Ok(Self {\n                status: common_enums::AttemptStatus::Failure,\n                response: Err(ErrorResponse {\n                    code: item.response.response_code.clone(),\n                    message: item.response.response_message.clone(),\n                    reason: Some(item.response.response_message.clone()),\n                    status_code: item.http_code,\n                    attempt_status: None,\n                    connector_transaction_id: item.response.transaction_id.map(|id| id.to_string()),\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..item.data\n            })\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zift__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__zift__transformers.rs"}, {"query": "transform Zift API response to hyperswitch", "code": "use api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{refunds::Execute, PSync},\n    router_request_types::{\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{AdditionalCardInfo, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZiftAuthType {\n    user_name: Secret<String>,\n    password: Secret<String>,\n    account_id: Secret<String>,\n}\nimpl TryFrom<&ConnectorAuthType> for ZiftAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                user_name: api_key.to_owned(),\n                password: api_secret.to_owned(),\n                account_id: key1.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType.into())\n        }\n    }\n}\n\npub struct ZiftRouterData<T> {\n    pub amount: \n\n... [truncated 36800 chars] ...\n\ntion_data: None,\n                    charges: None,\n                }),\n                ..item.data\n            })\n        } else {\n            Ok(Self {\n                status: common_enums::AttemptStatus::Failure,\n                response: Err(ErrorResponse {\n                    code: item.response.response_code.clone(),\n                    message: item.response.response_message.clone(),\n                    reason: Some(item.response.response_message.clone()),\n                    status_code: item.http_code,\n                    attempt_status: None,\n                    connector_transaction_id: item.response.transaction_id.map(|id| id.to_string()),\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..item.data\n            })\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zift__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__zift__transformers.rs"}, {"query": "Zift payment request types", "code": "use api_models::payments::AdditionalPaymentData;\nuse common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{refunds::Execute, PSync},\n    router_request_types::{\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{AdditionalCardInfo, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZiftAuthType {\n    user_name: Secret<String>,\n    password: Secret<String>,\n    account_id: Secret<String>,\n}\nimpl TryFrom<&ConnectorAuthType> for ZiftAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                user_name: api_key.to_owned(),\n                password: api_secret.to_owned(),\n                account_id: key1.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType.into())\n        }\n    }\n}\n\npub struct ZiftRouterData<T> {\n    pub amount: \n\n... [truncated 36800 chars] ...\n\ntion_data: None,\n                    charges: None,\n                }),\n                ..item.data\n            })\n        } else {\n            Ok(Self {\n                status: common_enums::AttemptStatus::Failure,\n                response: Err(ErrorResponse {\n                    code: item.response.response_code.clone(),\n                    message: item.response.response_message.clone(),\n                    reason: Some(item.response.response_message.clone()),\n                    status_code: item.http_code,\n                    attempt_status: None,\n                    connector_transaction_id: item.response.transaction_id.map(|id| id.to_string()),\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..item.data\n            })\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zift__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__zift__transformers.rs"}, {"query": "how does Tsys payment connector work", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse transformers as tsys;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n#[derive(Clone)]\npub struct Tsys {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Tsys {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &String\n\n... [truncated 21752 chars] ...\n\nrted_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    tsys_supported_payment_methods\n});\n\nstatic TSYS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Tsys\",\n    description: \"TSYS, a Global Payments company, is the payment stack for the future, powered by unmatched expertise.\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic TSYS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Tsys {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TSYS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TSYS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TSYS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tsys.rs", "file": "crates__hyperswitch_connectors__src__connectors__tsys.rs"}, {"query": "Tsys struct implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse transformers as tsys;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n#[derive(Clone)]\npub struct Tsys {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Tsys {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &String\n\n... [truncated 21752 chars] ...\n\nrted_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    tsys_supported_payment_methods\n});\n\nstatic TSYS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Tsys\",\n    description: \"TSYS, a Global Payments company, is the payment stack for the future, powered by unmatched expertise.\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic TSYS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Tsys {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TSYS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TSYS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TSYS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tsys.rs", "file": "crates__hyperswitch_connectors__src__connectors__tsys.rs"}, {"query": "how to implement Tsys payment integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse transformers as tsys;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n#[derive(Clone)]\npub struct Tsys {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Tsys {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &String\n\n... [truncated 21752 chars] ...\n\nrted_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    tsys_supported_payment_methods\n});\n\nstatic TSYS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Tsys\",\n    description: \"TSYS, a Global Payments company, is the payment stack for the future, powered by unmatched expertise.\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic TSYS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Tsys {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TSYS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TSYS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TSYS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tsys.rs", "file": "crates__hyperswitch_connectors__src__connectors__tsys.rs"}, {"query": "hyperswitch Tsys supported payment methods", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse transformers as tsys;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n#[derive(Clone)]\npub struct Tsys {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Tsys {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &String\n\n... [truncated 21752 chars] ...\n\nrted_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    tsys_supported_payment_methods\n});\n\nstatic TSYS_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Tsys\",\n    description: \"TSYS, a Global Payments company, is the payment stack for the future, powered by unmatched expertise.\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic TSYS_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Tsys {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&TSYS_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*TSYS_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&TSYS_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tsys.rs", "file": "crates__hyperswitch_connectors__src__connectors__tsys.rs"}, {"query": "how to implement custom payment connector", "code": "use api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::PaymentAction;\nuse common_utils::{crypto, errors::CustomResult, request::Request};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    connector_endpoints::Connectors,\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::RouterDataV2,\n    router_response_types::{ConnectorInfo, SupportedPaymentMethods},\n};\n\nuse crate::{\n    api,\n    api::{\n        BoxedConnectorIntegration, CaptureSyncMethod, Connector, ConnectorAccessTokenSuffix,\n        ConnectorCommon, ConnectorIntegration, ConnectorRedirectResponse, ConnectorSpecifications,\n        ConnectorValidation, CurrencyUnit,\n    },\n    authentication::ExternalAuthenticationPayload,\n    connector_integration_v2::{BoxedConnectorIntegrationV2, ConnectorIntegrationV2, ConnectorV2},\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types,\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\n\n/// RouterDataConversion trait\n///\n/// This trait must be implemented for conversion between Router data and RouterDataV2\npub trait RouterDataConversion<T, Req: Clone, Resp: Clone> {\n    /// Convert RouterData to RouterDataV2\n    ///\n    /// # Arguments\n    ///\n    /// * `old_router_data` - A reference to the old RouterData\n    ///\n    /// # Returns\n    ///\n    /// A `CustomResult` containing the new RouterDataV2 or a ConnectorError\n    fn from_old_router_data(\n        old_router_data: &RouterData<T, Req, Resp>,\n    ) -> CustomResult<RouterDataV2<T, Self, Req, Resp>, errors::ConnectorError>\n    where\n        Self: Sized;\n    /// Convert RouterDataV2 back to RouterData\n    ///\n    /// # Arguments\n    ///\n    /// * `new_router_data` - The new RouterDataV2\n    ///\n    /// # Returns\n    ///\n    /// A `CustomResult` containing the old Ro\n\n... [truncated 35296 chars] ...\n\n   }\n        }\n    }\n\n    fn clone_box(\n        &self,\n    ) -> Box<dyn ConnectorIntegrationInterface<T, ResourceCommonData, Req, Resp> + Send + Sync>\n    {\n        Box::new(self.clone())\n    }\n}\n\nimpl api::ConnectorTransactionId for ConnectorEnum {\n    /// Get the connector transaction ID\n    ///\n    /// # Arguments\n    ///\n    /// * `payment_attempt` - The payment attempt\n    ///\n    /// # Returns\n    ///\n    /// A `Result` containing an optional transaction ID or an ApiErrorResponse\n    fn connector_transaction_id(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> Result<Option<String>, ApiErrorResponse> {\n        match self {\n            Self::Old(connector) => connector.connector_transaction_id(payment_attempt),\n            Self::New(connector) => connector.connector_transaction_id(payment_attempt),\n        }\n    }\n}\n\n//re-add if stops working\n// impl ConnectorAccessTokenSuffix for BoxedConnectorV2 {}\n", "function_name": "crates__hyperswitch_interfaces__src__connector_integration_interface.rs", "file": "crates__hyperswitch_interfaces__src__connector_integration_interface.rs"}, {"query": "ConnectorIntegrationInterface trait", "code": "use api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::PaymentAction;\nuse common_utils::{crypto, errors::CustomResult, request::Request};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    connector_endpoints::Connectors,\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::RouterDataV2,\n    router_response_types::{ConnectorInfo, SupportedPaymentMethods},\n};\n\nuse crate::{\n    api,\n    api::{\n        BoxedConnectorIntegration, CaptureSyncMethod, Connector, ConnectorAccessTokenSuffix,\n        ConnectorCommon, ConnectorIntegration, ConnectorRedirectResponse, ConnectorSpecifications,\n        ConnectorValidation, CurrencyUnit,\n    },\n    authentication::ExternalAuthenticationPayload,\n    connector_integration_v2::{BoxedConnectorIntegrationV2, ConnectorIntegrationV2, ConnectorV2},\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types,\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\n\n/// RouterDataConversion trait\n///\n/// This trait must be implemented for conversion between Router data and RouterDataV2\npub trait RouterDataConversion<T, Req: Clone, Resp: Clone> {\n    /// Convert RouterData to RouterDataV2\n    ///\n    /// # Arguments\n    ///\n    /// * `old_router_data` - A reference to the old RouterData\n    ///\n    /// # Returns\n    ///\n    /// A `CustomResult` containing the new RouterDataV2 or a ConnectorError\n    fn from_old_router_data(\n        old_router_data: &RouterData<T, Req, Resp>,\n    ) -> CustomResult<RouterDataV2<T, Self, Req, Resp>, errors::ConnectorError>\n    where\n        Self: Sized;\n    /// Convert RouterDataV2 back to RouterData\n    ///\n    /// # Arguments\n    ///\n    /// * `new_router_data` - The new RouterDataV2\n    ///\n    /// # Returns\n    ///\n    /// A `CustomResult` containing the old Ro\n\n... [truncated 35296 chars] ...\n\n   }\n        }\n    }\n\n    fn clone_box(\n        &self,\n    ) -> Box<dyn ConnectorIntegrationInterface<T, ResourceCommonData, Req, Resp> + Send + Sync>\n    {\n        Box::new(self.clone())\n    }\n}\n\nimpl api::ConnectorTransactionId for ConnectorEnum {\n    /// Get the connector transaction ID\n    ///\n    /// # Arguments\n    ///\n    /// * `payment_attempt` - The payment attempt\n    ///\n    /// # Returns\n    ///\n    /// A `Result` containing an optional transaction ID or an ApiErrorResponse\n    fn connector_transaction_id(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> Result<Option<String>, ApiErrorResponse> {\n        match self {\n            Self::Old(connector) => connector.connector_transaction_id(payment_attempt),\n            Self::New(connector) => connector.connector_transaction_id(payment_attempt),\n        }\n    }\n}\n\n//re-add if stops working\n// impl ConnectorAccessTokenSuffix for BoxedConnectorV2 {}\n", "function_name": "crates__hyperswitch_interfaces__src__connector_integration_interface.rs", "file": "crates__hyperswitch_interfaces__src__connector_integration_interface.rs"}, {"query": "RouterDataConversion trait", "code": "use api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::PaymentAction;\nuse common_utils::{crypto, errors::CustomResult, request::Request};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    connector_endpoints::Connectors,\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::RouterDataV2,\n    router_response_types::{ConnectorInfo, SupportedPaymentMethods},\n};\n\nuse crate::{\n    api,\n    api::{\n        BoxedConnectorIntegration, CaptureSyncMethod, Connector, ConnectorAccessTokenSuffix,\n        ConnectorCommon, ConnectorIntegration, ConnectorRedirectResponse, ConnectorSpecifications,\n        ConnectorValidation, CurrencyUnit,\n    },\n    authentication::ExternalAuthenticationPayload,\n    connector_integration_v2::{BoxedConnectorIntegrationV2, ConnectorIntegrationV2, ConnectorV2},\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types,\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\n\n/// RouterDataConversion trait\n///\n/// This trait must be implemented for conversion between Router data and RouterDataV2\npub trait RouterDataConversion<T, Req: Clone, Resp: Clone> {\n    /// Convert RouterData to RouterDataV2\n    ///\n    /// # Arguments\n    ///\n    /// * `old_router_data` - A reference to the old RouterData\n    ///\n    /// # Returns\n    ///\n    /// A `CustomResult` containing the new RouterDataV2 or a ConnectorError\n    fn from_old_router_data(\n        old_router_data: &RouterData<T, Req, Resp>,\n    ) -> CustomResult<RouterDataV2<T, Self, Req, Resp>, errors::ConnectorError>\n    where\n        Self: Sized;\n    /// Convert RouterDataV2 back to RouterData\n    ///\n    /// # Arguments\n    ///\n    /// * `new_router_data` - The new RouterDataV2\n    ///\n    /// # Returns\n    ///\n    /// A `CustomResult` containing the old Ro\n\n... [truncated 35296 chars] ...\n\n   }\n        }\n    }\n\n    fn clone_box(\n        &self,\n    ) -> Box<dyn ConnectorIntegrationInterface<T, ResourceCommonData, Req, Resp> + Send + Sync>\n    {\n        Box::new(self.clone())\n    }\n}\n\nimpl api::ConnectorTransactionId for ConnectorEnum {\n    /// Get the connector transaction ID\n    ///\n    /// # Arguments\n    ///\n    /// * `payment_attempt` - The payment attempt\n    ///\n    /// # Returns\n    ///\n    /// A `Result` containing an optional transaction ID or an ApiErrorResponse\n    fn connector_transaction_id(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> Result<Option<String>, ApiErrorResponse> {\n        match self {\n            Self::Old(connector) => connector.connector_transaction_id(payment_attempt),\n            Self::New(connector) => connector.connector_transaction_id(payment_attempt),\n        }\n    }\n}\n\n//re-add if stops working\n// impl ConnectorAccessTokenSuffix for BoxedConnectorV2 {}\n", "function_name": "crates__hyperswitch_interfaces__src__connector_integration_interface.rs", "file": "crates__hyperswitch_interfaces__src__connector_integration_interface.rs"}, {"query": "hyperswitch connector integration interface", "code": "use api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::PaymentAction;\nuse common_utils::{crypto, errors::CustomResult, request::Request};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    connector_endpoints::Connectors,\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::RouterDataV2,\n    router_response_types::{ConnectorInfo, SupportedPaymentMethods},\n};\n\nuse crate::{\n    api,\n    api::{\n        BoxedConnectorIntegration, CaptureSyncMethod, Connector, ConnectorAccessTokenSuffix,\n        ConnectorCommon, ConnectorIntegration, ConnectorRedirectResponse, ConnectorSpecifications,\n        ConnectorValidation, CurrencyUnit,\n    },\n    authentication::ExternalAuthenticationPayload,\n    connector_integration_v2::{BoxedConnectorIntegrationV2, ConnectorIntegrationV2, ConnectorV2},\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types,\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\n\n/// RouterDataConversion trait\n///\n/// This trait must be implemented for conversion between Router data and RouterDataV2\npub trait RouterDataConversion<T, Req: Clone, Resp: Clone> {\n    /// Convert RouterData to RouterDataV2\n    ///\n    /// # Arguments\n    ///\n    /// * `old_router_data` - A reference to the old RouterData\n    ///\n    /// # Returns\n    ///\n    /// A `CustomResult` containing the new RouterDataV2 or a ConnectorError\n    fn from_old_router_data(\n        old_router_data: &RouterData<T, Req, Resp>,\n    ) -> CustomResult<RouterDataV2<T, Self, Req, Resp>, errors::ConnectorError>\n    where\n        Self: Sized;\n    /// Convert RouterDataV2 back to RouterData\n    ///\n    /// # Arguments\n    ///\n    /// * `new_router_data` - The new RouterDataV2\n    ///\n    /// # Returns\n    ///\n    /// A `CustomResult` containing the old Ro\n\n... [truncated 35296 chars] ...\n\n   }\n        }\n    }\n\n    fn clone_box(\n        &self,\n    ) -> Box<dyn ConnectorIntegrationInterface<T, ResourceCommonData, Req, Resp> + Send + Sync>\n    {\n        Box::new(self.clone())\n    }\n}\n\nimpl api::ConnectorTransactionId for ConnectorEnum {\n    /// Get the connector transaction ID\n    ///\n    /// # Arguments\n    ///\n    /// * `payment_attempt` - The payment attempt\n    ///\n    /// # Returns\n    ///\n    /// A `Result` containing an optional transaction ID or an ApiErrorResponse\n    fn connector_transaction_id(\n        &self,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> Result<Option<String>, ApiErrorResponse> {\n        match self {\n            Self::Old(connector) => connector.connector_transaction_id(payment_attempt),\n            Self::New(connector) => connector.connector_transaction_id(payment_attempt),\n        }\n    }\n}\n\n//re-add if stops working\n// impl ConnectorAccessTokenSuffix for BoxedConnectorV2 {}\n", "function_name": "crates__hyperswitch_interfaces__src__connector_integration_interface.rs", "file": "crates__hyperswitch_interfaces__src__connector_integration_interface.rs"}, {"query": "Mollie payment connector integration", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        convert_amount, get_unimplemented_payment_method_error_message, AddressData,\n        AddressDetailsData, BrowserInformationData, CardData as CardDataUtil, CustomerData,\n        OrderDetailsWithAmountData, PaymentMethodTokenizationRequestData,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct MollieRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for MollieRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MolliePaymentsRequest {\n    amount: Amount,\n    description: String,\n    redirect_url: String,\n    cancel_url: Option<String>,\n    webhook_url: String,\n    locale: Option<String>,\n    #[serde(flatten)]\n    payment_method_data: MolliePaymentMethodData,\n    metadata: Option<MollieMetadata>,\n    sequence_type: SequenceType,\n\n... [truncated 32448 chars] ...\n\n     match item {\n            MollieRefundStatus::Queued\n            | MollieRefundStatus::Pending\n            | MollieRefundStatus::Processing => Self::Pending,\n            MollieRefundStatus::Refunded => Self::Success,\n            MollieRefundStatus::Failed | MollieRefundStatus::Canceled => Self::Failure,\n        }\n    }\n}\n\nimpl<T> TryFrom<RefundsResponseRouterData<T, RefundResponse>> for types::RefundsRouterData<T> {\n    type Error = Error;\n    fn try_from(item: RefundsResponseRouterData<T, RefundResponse>) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.id,\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct MollieErrorResponse {\n    pub status: u16,\n    pub title: Option<String>,\n    pub detail: String,\n    pub field: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs"}, {"query": "MolliePaymentsRequest struct definition", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        convert_amount, get_unimplemented_payment_method_error_message, AddressData,\n        AddressDetailsData, BrowserInformationData, CardData as CardDataUtil, CustomerData,\n        OrderDetailsWithAmountData, PaymentMethodTokenizationRequestData,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct MollieRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for MollieRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MolliePaymentsRequest {\n    amount: Amount,\n    description: String,\n    redirect_url: String,\n    cancel_url: Option<String>,\n    webhook_url: String,\n    locale: Option<String>,\n    #[serde(flatten)]\n    payment_method_data: MolliePaymentMethodData,\n    metadata: Option<MollieMetadata>,\n    sequence_type: SequenceType,\n\n... [truncated 32448 chars] ...\n\n     match item {\n            MollieRefundStatus::Queued\n            | MollieRefundStatus::Pending\n            | MollieRefundStatus::Processing => Self::Pending,\n            MollieRefundStatus::Refunded => Self::Success,\n            MollieRefundStatus::Failed | MollieRefundStatus::Canceled => Self::Failure,\n        }\n    }\n}\n\nimpl<T> TryFrom<RefundsResponseRouterData<T, RefundResponse>> for types::RefundsRouterData<T> {\n    type Error = Error;\n    fn try_from(item: RefundsResponseRouterData<T, RefundResponse>) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.id,\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct MollieErrorResponse {\n    pub status: u16,\n    pub title: Option<String>,\n    pub detail: String,\n    pub field: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs"}, {"query": "how to handle Mollie refunds", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        convert_amount, get_unimplemented_payment_method_error_message, AddressData,\n        AddressDetailsData, BrowserInformationData, CardData as CardDataUtil, CustomerData,\n        OrderDetailsWithAmountData, PaymentMethodTokenizationRequestData,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct MollieRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for MollieRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MolliePaymentsRequest {\n    amount: Amount,\n    description: String,\n    redirect_url: String,\n    cancel_url: Option<String>,\n    webhook_url: String,\n    locale: Option<String>,\n    #[serde(flatten)]\n    payment_method_data: MolliePaymentMethodData,\n    metadata: Option<MollieMetadata>,\n    sequence_type: SequenceType,\n\n... [truncated 32448 chars] ...\n\n     match item {\n            MollieRefundStatus::Queued\n            | MollieRefundStatus::Pending\n            | MollieRefundStatus::Processing => Self::Pending,\n            MollieRefundStatus::Refunded => Self::Success,\n            MollieRefundStatus::Failed | MollieRefundStatus::Canceled => Self::Failure,\n        }\n    }\n}\n\nimpl<T> TryFrom<RefundsResponseRouterData<T, RefundResponse>> for types::RefundsRouterData<T> {\n    type Error = Error;\n    fn try_from(item: RefundsResponseRouterData<T, RefundResponse>) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.id,\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct MollieErrorResponse {\n    pub status: u16,\n    pub title: Option<String>,\n    pub detail: String,\n    pub field: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs"}, {"query": "Mollie to Hyperswitch data transformation", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        convert_amount, get_unimplemented_payment_method_error_message, AddressData,\n        AddressDetailsData, BrowserInformationData, CardData as CardDataUtil, CustomerData,\n        OrderDetailsWithAmountData, PaymentMethodTokenizationRequestData,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct MollieRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for MollieRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MolliePaymentsRequest {\n    amount: Amount,\n    description: String,\n    redirect_url: String,\n    cancel_url: Option<String>,\n    webhook_url: String,\n    locale: Option<String>,\n    #[serde(flatten)]\n    payment_method_data: MolliePaymentMethodData,\n    metadata: Option<MollieMetadata>,\n    sequence_type: SequenceType,\n\n... [truncated 32448 chars] ...\n\n     match item {\n            MollieRefundStatus::Queued\n            | MollieRefundStatus::Pending\n            | MollieRefundStatus::Processing => Self::Pending,\n            MollieRefundStatus::Refunded => Self::Success,\n            MollieRefundStatus::Failed | MollieRefundStatus::Canceled => Self::Failure,\n        }\n    }\n}\n\nimpl<T> TryFrom<RefundsResponseRouterData<T, RefundResponse>> for types::RefundsRouterData<T> {\n    type Error = Error;\n    fn try_from(item: RefundsResponseRouterData<T, RefundResponse>) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.id,\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct MollieErrorResponse {\n    pub status: u16,\n    pub title: Option<String>,\n    pub detail: String,\n    pub field: Option<String>,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs"}, {"query": "how to find refund by merchant id", "code": "#[cfg(feature = \"olap\")]\nuse std::collections::{HashMap, HashSet};\n\n#[cfg(feature = \"olap\")]\nuse common_utils::types::{ConnectorTransactionIdTrait, MinorUnit};\nuse diesel_models::{errors::DatabaseError, refund as diesel_refund};\nuse hyperswitch_domain_models::refunds;\n\nuse super::MockDb;\nuse crate::{\n    core::errors::{self, CustomResult},\n    types::storage::enums,\n};\n\n#[cfg(feature = \"olap\")]\nconst MAX_LIMIT: usize = 100;\n\n#[async_trait::async_trait]\npub trait RefundInterface {\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    async fn update_refund(\n        &self,\n        this: diesel_refund::Refund,\n        refund: diesel_refund::RefundUpdate,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Re\n\n... [truncated 74165 chars] ...\n\n              <= MinorUnit::new(amount.end_amount.unwrap_or(i64::MAX))\n                })\n            })\n            .filter(|refund| {\n                unique_connectors.is_empty() || unique_connectors.contains(&refund.connector)\n            })\n            .filter(|refund| {\n                unique_connector_ids.is_empty()\n                    || refund\n                        .connector_id\n                        .as_ref()\n                        .is_some_and(|id| unique_connector_ids.contains(id))\n            })\n            .filter(|refund| {\n                unique_currencies.is_empty() || unique_currencies.contains(&refund.currency)\n            })\n            .filter(|refund| {\n                unique_statuses.is_empty() || unique_statuses.contains(&refund.refund_status)\n            })\n            .cloned()\n            .collect::<Vec<_>>();\n\n        let filtered_refunds_count = filtered_refunds.len().try_into().unwrap_or_default();\n\n        Ok(filtered_refunds_count)\n    }\n}\n", "function_name": "crates__router__src__db__refund.rs", "file": "crates__router__src__db__refund.rs"}, {"query": "RefundInterface trait implementation", "code": "#[cfg(feature = \"olap\")]\nuse std::collections::{HashMap, HashSet};\n\n#[cfg(feature = \"olap\")]\nuse common_utils::types::{ConnectorTransactionIdTrait, MinorUnit};\nuse diesel_models::{errors::DatabaseError, refund as diesel_refund};\nuse hyperswitch_domain_models::refunds;\n\nuse super::MockDb;\nuse crate::{\n    core::errors::{self, CustomResult},\n    types::storage::enums,\n};\n\n#[cfg(feature = \"olap\")]\nconst MAX_LIMIT: usize = 100;\n\n#[async_trait::async_trait]\npub trait RefundInterface {\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    async fn update_refund(\n        &self,\n        this: diesel_refund::Refund,\n        refund: diesel_refund::RefundUpdate,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Re\n\n... [truncated 74165 chars] ...\n\n              <= MinorUnit::new(amount.end_amount.unwrap_or(i64::MAX))\n                })\n            })\n            .filter(|refund| {\n                unique_connectors.is_empty() || unique_connectors.contains(&refund.connector)\n            })\n            .filter(|refund| {\n                unique_connector_ids.is_empty()\n                    || refund\n                        .connector_id\n                        .as_ref()\n                        .is_some_and(|id| unique_connector_ids.contains(id))\n            })\n            .filter(|refund| {\n                unique_currencies.is_empty() || unique_currencies.contains(&refund.currency)\n            })\n            .filter(|refund| {\n                unique_statuses.is_empty() || unique_statuses.contains(&refund.refund_status)\n            })\n            .cloned()\n            .collect::<Vec<_>>();\n\n        let filtered_refunds_count = filtered_refunds.len().try_into().unwrap_or_default();\n\n        Ok(filtered_refunds_count)\n    }\n}\n", "function_name": "crates__router__src__db__refund.rs", "file": "crates__router__src__db__refund.rs"}, {"query": "filter refunds by time range and amount", "code": "#[cfg(feature = \"olap\")]\nuse std::collections::{HashMap, HashSet};\n\n#[cfg(feature = \"olap\")]\nuse common_utils::types::{ConnectorTransactionIdTrait, MinorUnit};\nuse diesel_models::{errors::DatabaseError, refund as diesel_refund};\nuse hyperswitch_domain_models::refunds;\n\nuse super::MockDb;\nuse crate::{\n    core::errors::{self, CustomResult},\n    types::storage::enums,\n};\n\n#[cfg(feature = \"olap\")]\nconst MAX_LIMIT: usize = 100;\n\n#[async_trait::async_trait]\npub trait RefundInterface {\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    async fn update_refund(\n        &self,\n        this: diesel_refund::Refund,\n        refund: diesel_refund::RefundUpdate,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Re\n\n... [truncated 74165 chars] ...\n\n              <= MinorUnit::new(amount.end_amount.unwrap_or(i64::MAX))\n                })\n            })\n            .filter(|refund| {\n                unique_connectors.is_empty() || unique_connectors.contains(&refund.connector)\n            })\n            .filter(|refund| {\n                unique_connector_ids.is_empty()\n                    || refund\n                        .connector_id\n                        .as_ref()\n                        .is_some_and(|id| unique_connector_ids.contains(id))\n            })\n            .filter(|refund| {\n                unique_currencies.is_empty() || unique_currencies.contains(&refund.currency)\n            })\n            .filter(|refund| {\n                unique_statuses.is_empty() || unique_statuses.contains(&refund.refund_status)\n            })\n            .cloned()\n            .collect::<Vec<_>>();\n\n        let filtered_refunds_count = filtered_refunds.len().try_into().unwrap_or_default();\n\n        Ok(filtered_refunds_count)\n    }\n}\n", "function_name": "crates__router__src__db__refund.rs", "file": "crates__router__src__db__refund.rs"}, {"query": "refund storage error handling", "code": "#[cfg(feature = \"olap\")]\nuse std::collections::{HashMap, HashSet};\n\n#[cfg(feature = \"olap\")]\nuse common_utils::types::{ConnectorTransactionIdTrait, MinorUnit};\nuse diesel_models::{errors::DatabaseError, refund as diesel_refund};\nuse hyperswitch_domain_models::refunds;\n\nuse super::MockDb;\nuse crate::{\n    core::errors::{self, CustomResult},\n    types::storage::enums,\n};\n\n#[cfg(feature = \"olap\")]\nconst MAX_LIMIT: usize = 100;\n\n#[async_trait::async_trait]\npub trait RefundInterface {\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    async fn update_refund(\n        &self,\n        this: diesel_refund::Refund,\n        refund: diesel_refund::RefundUpdate,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Re\n\n... [truncated 74165 chars] ...\n\n              <= MinorUnit::new(amount.end_amount.unwrap_or(i64::MAX))\n                })\n            })\n            .filter(|refund| {\n                unique_connectors.is_empty() || unique_connectors.contains(&refund.connector)\n            })\n            .filter(|refund| {\n                unique_connector_ids.is_empty()\n                    || refund\n                        .connector_id\n                        .as_ref()\n                        .is_some_and(|id| unique_connector_ids.contains(id))\n            })\n            .filter(|refund| {\n                unique_currencies.is_empty() || unique_currencies.contains(&refund.currency)\n            })\n            .filter(|refund| {\n                unique_statuses.is_empty() || unique_statuses.contains(&refund.refund_status)\n            })\n            .cloned()\n            .collect::<Vec<_>>();\n\n        let filtered_refunds_count = filtered_refunds.len().try_into().unwrap_or_default();\n\n        Ok(filtered_refunds_count)\n    }\n}\n", "function_name": "crates__router__src__db__refund.rs", "file": "crates__router__src__db__refund.rs"}]