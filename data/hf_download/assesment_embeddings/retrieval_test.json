[{"query": "Square payment integration implementation", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::{\n    enums,\n    webhooks::{IncomingWebhookEvent, ObjectReferenceId},\n};\nuse base64::Engine;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        AuthorizeSessionToken,\n    },\n    router_request_types::{\n        AccessTokenRequestData, AuthorizeSessionTokenData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsAuthorizeSessionTokenRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsAuthorizeType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers::{\n    self as square, SquareAuthType, SquarePaymentsRequest, SquareRefundRequest, SquareTokenRequest,\n};\n\nuse cra\n\n... [truncated 31578 chars] ...\n\n:NotSupported,\n                            no_three_ds: common_enums::FeatureStatus::Supported,\n                            supported_card_networks: supported_card_network,\n                        }\n                    }),\n                ),\n            },\n        );\n\n        square_supported_payment_methods\n    };\n    static ref SQUARE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> =\n        vec![enums::EventClass::Payments, enums::EventClass::Refunds,];\n}\n\nimpl ConnectorSpecifications for Square {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*SQUARE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SQUARE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*SQUARE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    fn is_authorize_session_token_call_required(&self) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__square.rs", "file": "crates__hyperswitch_connectors__src__connectors__square.rs"}, {"query": "Square connector API traits", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::{\n    enums,\n    webhooks::{IncomingWebhookEvent, ObjectReferenceId},\n};\nuse base64::Engine;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        AuthorizeSessionToken,\n    },\n    router_request_types::{\n        AccessTokenRequestData, AuthorizeSessionTokenData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsAuthorizeSessionTokenRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsAuthorizeType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers::{\n    self as square, SquareAuthType, SquarePaymentsRequest, SquareRefundRequest, SquareTokenRequest,\n};\n\nuse cra\n\n... [truncated 31578 chars] ...\n\n:NotSupported,\n                            no_three_ds: common_enums::FeatureStatus::Supported,\n                            supported_card_networks: supported_card_network,\n                        }\n                    }),\n                ),\n            },\n        );\n\n        square_supported_payment_methods\n    };\n    static ref SQUARE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> =\n        vec![enums::EventClass::Payments, enums::EventClass::Refunds,];\n}\n\nimpl ConnectorSpecifications for Square {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*SQUARE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SQUARE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*SQUARE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    fn is_authorize_session_token_call_required(&self) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__square.rs", "file": "crates__hyperswitch_connectors__src__connectors__square.rs"}, {"query": "Hyperswitch Square refund process", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::{\n    enums,\n    webhooks::{IncomingWebhookEvent, ObjectReferenceId},\n};\nuse base64::Engine;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        AuthorizeSessionToken,\n    },\n    router_request_types::{\n        AccessTokenRequestData, AuthorizeSessionTokenData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsAuthorizeSessionTokenRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsAuthorizeType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers::{\n    self as square, SquareAuthType, SquarePaymentsRequest, SquareRefundRequest, SquareTokenRequest,\n};\n\nuse cra\n\n... [truncated 31578 chars] ...\n\n:NotSupported,\n                            no_three_ds: common_enums::FeatureStatus::Supported,\n                            supported_card_networks: supported_card_network,\n                        }\n                    }),\n                ),\n            },\n        );\n\n        square_supported_payment_methods\n    };\n    static ref SQUARE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> =\n        vec![enums::EventClass::Payments, enums::EventClass::Refunds,];\n}\n\nimpl ConnectorSpecifications for Square {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*SQUARE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SQUARE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*SQUARE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    fn is_authorize_session_token_call_required(&self) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__square.rs", "file": "crates__hyperswitch_connectors__src__connectors__square.rs"}, {"query": "Square webhook event handling", "code": "pub mod transformers;\n\nuse std::fmt::Debug;\n\nuse api_models::{\n    enums,\n    webhooks::{IncomingWebhookEvent, ObjectReferenceId},\n};\nuse base64::Engine;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        AuthorizeSessionToken,\n    },\n    router_request_types::{\n        AccessTokenRequestData, AuthorizeSessionTokenData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsAuthorizeSessionTokenRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsAuthorizeType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers::{\n    self as square, SquareAuthType, SquarePaymentsRequest, SquareRefundRequest, SquareTokenRequest,\n};\n\nuse cra\n\n... [truncated 31578 chars] ...\n\n:NotSupported,\n                            no_three_ds: common_enums::FeatureStatus::Supported,\n                            supported_card_networks: supported_card_network,\n                        }\n                    }),\n                ),\n            },\n        );\n\n        square_supported_payment_methods\n    };\n    static ref SQUARE_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> =\n        vec![enums::EventClass::Payments, enums::EventClass::Refunds,];\n}\n\nimpl ConnectorSpecifications for Square {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*SQUARE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SQUARE_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*SQUARE_SUPPORTED_WEBHOOK_FLOWS)\n    }\n    fn is_authorize_session_token_call_required(&self) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__square.rs", "file": "crates__hyperswitch_connectors__src__connectors__square.rs"}, {"query": "how to implement Worldpay Vantiv connector in Rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, PSync, PaymentMethodToken, PostCaptureVoid, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Dsync, Evidence, Fetch, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DisputeSyncData,\n        FetchDisputesRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCancelPostCaptureData, PaymentsCaptureData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, RetrieveFileRequestData,\n        SetupMandateRequestData, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DisputeSyncResponse, FetchDisputesResponse,\n        PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, RetrieveFileResponse,\n        SubmitEvidenceResponse, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n        UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, Dispute, DisputeSync, FetchDisputes, SubmitEvidence},\n        files::{FilePur\n\n... [truncated 60257 chars] ...\n\nng {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            let max_payment_reference_id_length =\n                worldpayvantiv::worldpayvantiv_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH;\n            nanoid::nanoid!(max_payment_reference_id_length)\n        }\n    }\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        if payment_intent.is_payment_id_from_merchant.unwrap_or(false) {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            connector_utils::generate_12_digit_number().to_string()\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs"}, {"query": "Worldpayvantiv struct definition", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, PSync, PaymentMethodToken, PostCaptureVoid, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Dsync, Evidence, Fetch, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DisputeSyncData,\n        FetchDisputesRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCancelPostCaptureData, PaymentsCaptureData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, RetrieveFileRequestData,\n        SetupMandateRequestData, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DisputeSyncResponse, FetchDisputesResponse,\n        PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, RetrieveFileResponse,\n        SubmitEvidenceResponse, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n        UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, Dispute, DisputeSync, FetchDisputes, SubmitEvidence},\n        files::{FilePur\n\n... [truncated 60257 chars] ...\n\nng {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            let max_payment_reference_id_length =\n                worldpayvantiv::worldpayvantiv_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH;\n            nanoid::nanoid!(max_payment_reference_id_length)\n        }\n    }\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        if payment_intent.is_payment_id_from_merchant.unwrap_or(false) {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            connector_utils::generate_12_digit_number().to_string()\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs"}, {"query": "hyperswitch payment capture implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, PSync, PaymentMethodToken, PostCaptureVoid, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Dsync, Evidence, Fetch, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DisputeSyncData,\n        FetchDisputesRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCancelPostCaptureData, PaymentsCaptureData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, RetrieveFileRequestData,\n        SetupMandateRequestData, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DisputeSyncResponse, FetchDisputesResponse,\n        PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, RetrieveFileResponse,\n        SubmitEvidenceResponse, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n        UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, Dispute, DisputeSync, FetchDisputes, SubmitEvidence},\n        files::{FilePur\n\n... [truncated 60257 chars] ...\n\nng {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            let max_payment_reference_id_length =\n                worldpayvantiv::worldpayvantiv_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH;\n            nanoid::nanoid!(max_payment_reference_id_length)\n        }\n    }\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        if payment_intent.is_payment_id_from_merchant.unwrap_or(false) {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            connector_utils::generate_12_digit_number().to_string()\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs"}, {"query": "Worldpay Vantiv refund API integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, PSync, PaymentMethodToken, PostCaptureVoid, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Dsync, Evidence, Fetch, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DisputeSyncData,\n        FetchDisputesRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCancelPostCaptureData, PaymentsCaptureData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, RetrieveFileRequestData,\n        SetupMandateRequestData, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DisputeSyncResponse, FetchDisputesResponse,\n        PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, RetrieveFileResponse,\n        SubmitEvidenceResponse, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n        UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, Dispute, DisputeSync, FetchDisputes, SubmitEvidence},\n        files::{FilePur\n\n... [truncated 60257 chars] ...\n\nng {\n        if is_config_enabled_to_send_payment_id_as_connector_request_id\n            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n        {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            let max_payment_reference_id_length =\n                worldpayvantiv::worldpayvantiv_constants::MAX_PAYMENT_REFERENCE_ID_LENGTH;\n            nanoid::nanoid!(max_payment_reference_id_length)\n        }\n    }\n    #[cfg(feature = \"v2\")]\n    fn generate_connector_request_reference_id(\n        &self,\n        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n    ) -> String {\n        if payment_intent.is_payment_id_from_merchant.unwrap_or(false) {\n            payment_attempt.payment_id.get_string_repr().to_owned()\n        } else {\n            connector_utils::generate_12_digit_number().to_string()\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs"}, {"query": "how to find payment method by id", "code": "pub use diesel_models::payment_method::PaymentMethod;\n\nuse crate::redis::kv_store::KvStorePartition;\n\nimpl KvStorePartition for PaymentMethod {}\n\n#[cfg(feature = \"v1\")]\nuse std::collections::HashSet;\n\nuse common_enums::enums::MerchantStorageScheme;\nuse common_utils::{errors::CustomResult, id_type};\n#[cfg(feature = \"v1\")]\nuse diesel_models::kv;\nuse diesel_models::payment_method::{PaymentMethodUpdate, PaymentMethodUpdateInternal};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    merchant_key_store::MerchantKeyStore,\n    payment_methods::{PaymentMethod as DomainPaymentMethod, PaymentMethodInterface},\n};\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    diesel_error_to_data_error, errors,\n    kv_router_store::{FindResourceBy, KVRouterStore},\n    utils::{pg_connection_read, pg_connection_write},\n    DatabaseStore, RouterStore,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    kv_router_store::{FilterResourceParams, InsertResourceParams, UpdateResourceParams},\n    redis::kv_store::{Op, PartitionKey},\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentMethodInterface for KVRouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_payment_method(\n        &self,\n        key_store: &MerchantKeyStore,\n        payment_method_id: &str,\n        storage_scheme: MerchantStorageScheme,\n    ) -> CustomResult<DomainPaymentMethod, errors::StorageError> {\n        let conn = pg_connection_read(self).await?;\n        self.find_resource_by_id(\n            key_store,\n            storage_scheme,\n            PaymentMethod::find_by_payment_method_id(&conn, payment_method_id),\n            FindResourceBy::LookupId(format!(\"payment_method_{payment_method_id}\")),\n        )\n        .await\n    }\n\n    #[cfg(feature = \"v2\")]\n    #[instrument(skip_all)]\n    async fn find_payment_method(\n  \n\n... [truncated 31918 chars] ...\n\nersion::convert(payment_method.clone())\n                    .await\n                    .change_context(errors::StorageError::EncryptionError)?,\n            );\n        self.update_resource::<PaymentMethod, _>(\n            key_store,\n            self.payment_methods.lock().await,\n            payment_method_updated,\n            |pm| pm.get_id() == payment_method.get_id(),\n            \"cannot find payment method\".to_string(),\n        )\n        .await\n    }\n\n    async fn find_payment_method_by_fingerprint_id(\n        &self,\n        key_store: &MerchantKeyStore,\n        fingerprint_id: &str,\n    ) -> CustomResult<DomainPaymentMethod, errors::StorageError> {\n        let payment_methods = self.payment_methods.lock().await;\n        self.get_resource::<PaymentMethod, _>(\n            key_store,\n            payment_methods,\n            |pm| pm.locker_fingerprint_id == Some(fingerprint_id.to_string()),\n            \"cannot find payment method\".to_string(),\n        )\n        .await\n    }\n}\n", "function_name": "crates__storage_impl__src__payment_method.rs", "file": "crates__storage_impl__src__payment_method.rs"}, {"query": "payment method storage implementation", "code": "pub use diesel_models::payment_method::PaymentMethod;\n\nuse crate::redis::kv_store::KvStorePartition;\n\nimpl KvStorePartition for PaymentMethod {}\n\n#[cfg(feature = \"v1\")]\nuse std::collections::HashSet;\n\nuse common_enums::enums::MerchantStorageScheme;\nuse common_utils::{errors::CustomResult, id_type};\n#[cfg(feature = \"v1\")]\nuse diesel_models::kv;\nuse diesel_models::payment_method::{PaymentMethodUpdate, PaymentMethodUpdateInternal};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    merchant_key_store::MerchantKeyStore,\n    payment_methods::{PaymentMethod as DomainPaymentMethod, PaymentMethodInterface},\n};\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    diesel_error_to_data_error, errors,\n    kv_router_store::{FindResourceBy, KVRouterStore},\n    utils::{pg_connection_read, pg_connection_write},\n    DatabaseStore, RouterStore,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    kv_router_store::{FilterResourceParams, InsertResourceParams, UpdateResourceParams},\n    redis::kv_store::{Op, PartitionKey},\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentMethodInterface for KVRouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_payment_method(\n        &self,\n        key_store: &MerchantKeyStore,\n        payment_method_id: &str,\n        storage_scheme: MerchantStorageScheme,\n    ) -> CustomResult<DomainPaymentMethod, errors::StorageError> {\n        let conn = pg_connection_read(self).await?;\n        self.find_resource_by_id(\n            key_store,\n            storage_scheme,\n            PaymentMethod::find_by_payment_method_id(&conn, payment_method_id),\n            FindResourceBy::LookupId(format!(\"payment_method_{payment_method_id}\")),\n        )\n        .await\n    }\n\n    #[cfg(feature = \"v2\")]\n    #[instrument(skip_all)]\n    async fn find_payment_method(\n  \n\n... [truncated 31918 chars] ...\n\nersion::convert(payment_method.clone())\n                    .await\n                    .change_context(errors::StorageError::EncryptionError)?,\n            );\n        self.update_resource::<PaymentMethod, _>(\n            key_store,\n            self.payment_methods.lock().await,\n            payment_method_updated,\n            |pm| pm.get_id() == payment_method.get_id(),\n            \"cannot find payment method\".to_string(),\n        )\n        .await\n    }\n\n    async fn find_payment_method_by_fingerprint_id(\n        &self,\n        key_store: &MerchantKeyStore,\n        fingerprint_id: &str,\n    ) -> CustomResult<DomainPaymentMethod, errors::StorageError> {\n        let payment_methods = self.payment_methods.lock().await;\n        self.get_resource::<PaymentMethod, _>(\n            key_store,\n            payment_methods,\n            |pm| pm.locker_fingerprint_id == Some(fingerprint_id.to_string()),\n            \"cannot find payment method\".to_string(),\n        )\n        .await\n    }\n}\n", "function_name": "crates__storage_impl__src__payment_method.rs", "file": "crates__storage_impl__src__payment_method.rs"}, {"query": "how to update payment method status", "code": "pub use diesel_models::payment_method::PaymentMethod;\n\nuse crate::redis::kv_store::KvStorePartition;\n\nimpl KvStorePartition for PaymentMethod {}\n\n#[cfg(feature = \"v1\")]\nuse std::collections::HashSet;\n\nuse common_enums::enums::MerchantStorageScheme;\nuse common_utils::{errors::CustomResult, id_type};\n#[cfg(feature = \"v1\")]\nuse diesel_models::kv;\nuse diesel_models::payment_method::{PaymentMethodUpdate, PaymentMethodUpdateInternal};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    merchant_key_store::MerchantKeyStore,\n    payment_methods::{PaymentMethod as DomainPaymentMethod, PaymentMethodInterface},\n};\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    diesel_error_to_data_error, errors,\n    kv_router_store::{FindResourceBy, KVRouterStore},\n    utils::{pg_connection_read, pg_connection_write},\n    DatabaseStore, RouterStore,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    kv_router_store::{FilterResourceParams, InsertResourceParams, UpdateResourceParams},\n    redis::kv_store::{Op, PartitionKey},\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentMethodInterface for KVRouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_payment_method(\n        &self,\n        key_store: &MerchantKeyStore,\n        payment_method_id: &str,\n        storage_scheme: MerchantStorageScheme,\n    ) -> CustomResult<DomainPaymentMethod, errors::StorageError> {\n        let conn = pg_connection_read(self).await?;\n        self.find_resource_by_id(\n            key_store,\n            storage_scheme,\n            PaymentMethod::find_by_payment_method_id(&conn, payment_method_id),\n            FindResourceBy::LookupId(format!(\"payment_method_{payment_method_id}\")),\n        )\n        .await\n    }\n\n    #[cfg(feature = \"v2\")]\n    #[instrument(skip_all)]\n    async fn find_payment_method(\n  \n\n... [truncated 31918 chars] ...\n\nersion::convert(payment_method.clone())\n                    .await\n                    .change_context(errors::StorageError::EncryptionError)?,\n            );\n        self.update_resource::<PaymentMethod, _>(\n            key_store,\n            self.payment_methods.lock().await,\n            payment_method_updated,\n            |pm| pm.get_id() == payment_method.get_id(),\n            \"cannot find payment method\".to_string(),\n        )\n        .await\n    }\n\n    async fn find_payment_method_by_fingerprint_id(\n        &self,\n        key_store: &MerchantKeyStore,\n        fingerprint_id: &str,\n    ) -> CustomResult<DomainPaymentMethod, errors::StorageError> {\n        let payment_methods = self.payment_methods.lock().await;\n        self.get_resource::<PaymentMethod, _>(\n            key_store,\n            payment_methods,\n            |pm| pm.locker_fingerprint_id == Some(fingerprint_id.to_string()),\n            \"cannot find payment method\".to_string(),\n        )\n        .await\n    }\n}\n", "function_name": "crates__storage_impl__src__payment_method.rs", "file": "crates__storage_impl__src__payment_method.rs"}, {"query": "KVRouterStore payment method trait", "code": "pub use diesel_models::payment_method::PaymentMethod;\n\nuse crate::redis::kv_store::KvStorePartition;\n\nimpl KvStorePartition for PaymentMethod {}\n\n#[cfg(feature = \"v1\")]\nuse std::collections::HashSet;\n\nuse common_enums::enums::MerchantStorageScheme;\nuse common_utils::{errors::CustomResult, id_type};\n#[cfg(feature = \"v1\")]\nuse diesel_models::kv;\nuse diesel_models::payment_method::{PaymentMethodUpdate, PaymentMethodUpdateInternal};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    merchant_key_store::MerchantKeyStore,\n    payment_methods::{PaymentMethod as DomainPaymentMethod, PaymentMethodInterface},\n};\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    diesel_error_to_data_error, errors,\n    kv_router_store::{FindResourceBy, KVRouterStore},\n    utils::{pg_connection_read, pg_connection_write},\n    DatabaseStore, RouterStore,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    kv_router_store::{FilterResourceParams, InsertResourceParams, UpdateResourceParams},\n    redis::kv_store::{Op, PartitionKey},\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentMethodInterface for KVRouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_payment_method(\n        &self,\n        key_store: &MerchantKeyStore,\n        payment_method_id: &str,\n        storage_scheme: MerchantStorageScheme,\n    ) -> CustomResult<DomainPaymentMethod, errors::StorageError> {\n        let conn = pg_connection_read(self).await?;\n        self.find_resource_by_id(\n            key_store,\n            storage_scheme,\n            PaymentMethod::find_by_payment_method_id(&conn, payment_method_id),\n            FindResourceBy::LookupId(format!(\"payment_method_{payment_method_id}\")),\n        )\n        .await\n    }\n\n    #[cfg(feature = \"v2\")]\n    #[instrument(skip_all)]\n    async fn find_payment_method(\n  \n\n... [truncated 31918 chars] ...\n\nersion::convert(payment_method.clone())\n                    .await\n                    .change_context(errors::StorageError::EncryptionError)?,\n            );\n        self.update_resource::<PaymentMethod, _>(\n            key_store,\n            self.payment_methods.lock().await,\n            payment_method_updated,\n            |pm| pm.get_id() == payment_method.get_id(),\n            \"cannot find payment method\".to_string(),\n        )\n        .await\n    }\n\n    async fn find_payment_method_by_fingerprint_id(\n        &self,\n        key_store: &MerchantKeyStore,\n        fingerprint_id: &str,\n    ) -> CustomResult<DomainPaymentMethod, errors::StorageError> {\n        let payment_methods = self.payment_methods.lock().await;\n        self.get_resource::<PaymentMethod, _>(\n            key_store,\n            payment_methods,\n            |pm| pm.locker_fingerprint_id == Some(fingerprint_id.to_string()),\n            \"cannot find payment method\".to_string(),\n        )\n        .await\n    }\n}\n", "function_name": "crates__storage_impl__src__payment_method.rs", "file": "crates__storage_impl__src__payment_method.rs"}, {"query": "how to implement Celero payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as celero;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Celero {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Celero {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Celero {}\nimpl api::PaymentSession for Celero {}\nimpl \n\n... [truncated 24940 chars] ...\n\nted_card_networks: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    celero_supported_payment_methods\n});\n\nstatic CELERO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Celero\",\n    description: \"Celero is your trusted provider for payment processing technology and solutions, with a commitment to helping small to mid-sized businesses thrive\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Celero {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CELERO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CELERO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__celero.rs", "file": "crates__hyperswitch_connectors__src__connectors__celero.rs"}, {"query": "Celero payment integration Rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as celero;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Celero {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Celero {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Celero {}\nimpl api::PaymentSession for Celero {}\nimpl \n\n... [truncated 24940 chars] ...\n\nted_card_networks: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    celero_supported_payment_methods\n});\n\nstatic CELERO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Celero\",\n    description: \"Celero is your trusted provider for payment processing technology and solutions, with a commitment to helping small to mid-sized businesses thrive\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Celero {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CELERO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CELERO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__celero.rs", "file": "crates__hyperswitch_connectors__src__connectors__celero.rs"}, {"query": "Hyperswitch Celero connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as celero;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Celero {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Celero {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Celero {}\nimpl api::PaymentSession for Celero {}\nimpl \n\n... [truncated 24940 chars] ...\n\nted_card_networks: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    celero_supported_payment_methods\n});\n\nstatic CELERO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Celero\",\n    description: \"Celero is your trusted provider for payment processing technology and solutions, with a commitment to helping small to mid-sized businesses thrive\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Celero {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CELERO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CELERO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__celero.rs", "file": "crates__hyperswitch_connectors__src__connectors__celero.rs"}, {"query": "Celero authorize capture refund flow", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as celero;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Celero {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Celero {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Celero {}\nimpl api::PaymentSession for Celero {}\nimpl \n\n... [truncated 24940 chars] ...\n\nted_card_networks: supported_card_network.clone(),\n                    }\n                }),\n            ),\n        },\n    );\n\n    celero_supported_payment_methods\n});\n\nstatic CELERO_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Celero\",\n    description: \"Celero is your trusted provider for payment processing technology and solutions, with a commitment to helping small to mid-sized businesses thrive\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: common_enums::ConnectorIntegrationStatus::Alpha,\n};\n\nimpl ConnectorSpecifications for Celero {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CELERO_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CELERO_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__celero.rs", "file": "crates__hyperswitch_connectors__src__connectors__celero.rs"}, {"query": "Worldpaymodular connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::*,\n    router_request_types::*,\n    router_response_types::*,\n    types::*,\n};\nuse hyperswitch_interfaces::{\n    api::{ConnectorCommonExt, ConnectorIntegration, *},\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::*,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, Maskable};\nuse transformers::*;\n\nuse crate::{\n    connectors::worldpaymodular::transformers::request::{\n        WorldpaymodularPartialRefundRequest, WorldpaymodularPaymentsRequest,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, get_header_key_value, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Worldpaymodular {}\n\nimpl Worldpaymodular {\n    pub const fn new() -> &'static Self {\n        &Self {}\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpaymodular\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().in\n\n... [truncated 26012 chars] ...\n\nNNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldpaymodular\",\n    description: \"Worldpaymodular is a payment gateway and PSP enabling secure online transactions, It utilizes modular Api's of worldpay\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic WORLDPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Worldpaymodular {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs"}, {"query": "how to configure Worldpay payments", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::*,\n    router_request_types::*,\n    router_response_types::*,\n    types::*,\n};\nuse hyperswitch_interfaces::{\n    api::{ConnectorCommonExt, ConnectorIntegration, *},\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::*,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, Maskable};\nuse transformers::*;\n\nuse crate::{\n    connectors::worldpaymodular::transformers::request::{\n        WorldpaymodularPartialRefundRequest, WorldpaymodularPaymentsRequest,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, get_header_key_value, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Worldpaymodular {}\n\nimpl Worldpaymodular {\n    pub const fn new() -> &'static Self {\n        &Self {}\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpaymodular\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().in\n\n... [truncated 26012 chars] ...\n\nNNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldpaymodular\",\n    description: \"Worldpaymodular is a payment gateway and PSP enabling secure online transactions, It utilizes modular Api's of worldpay\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic WORLDPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Worldpaymodular {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs"}, {"query": "Worldpay modular API integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::*,\n    router_request_types::*,\n    router_response_types::*,\n    types::*,\n};\nuse hyperswitch_interfaces::{\n    api::{ConnectorCommonExt, ConnectorIntegration, *},\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::*,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, Maskable};\nuse transformers::*;\n\nuse crate::{\n    connectors::worldpaymodular::transformers::request::{\n        WorldpaymodularPartialRefundRequest, WorldpaymodularPaymentsRequest,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, get_header_key_value, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Worldpaymodular {}\n\nimpl Worldpaymodular {\n    pub const fn new() -> &'static Self {\n        &Self {}\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpaymodular\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().in\n\n... [truncated 26012 chars] ...\n\nNNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldpaymodular\",\n    description: \"Worldpaymodular is a payment gateway and PSP enabling secure online transactions, It utilizes modular Api's of worldpay\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic WORLDPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Worldpaymodular {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs"}, {"query": "hyperswitch payment gateway connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::*,\n    router_request_types::*,\n    router_response_types::*,\n    types::*,\n};\nuse hyperswitch_interfaces::{\n    api::{ConnectorCommonExt, ConnectorIntegration, *},\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::*,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, Maskable};\nuse transformers::*;\n\nuse crate::{\n    connectors::worldpaymodular::transformers::request::{\n        WorldpaymodularPartialRefundRequest, WorldpaymodularPaymentsRequest,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, get_header_key_value, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Worldpaymodular {}\n\nimpl Worldpaymodular {\n    pub const fn new() -> &'static Self {\n        &Self {}\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpaymodular\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().in\n\n... [truncated 26012 chars] ...\n\nNNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Worldpaymodular\",\n    description: \"Worldpaymodular is a payment gateway and PSP enabling secure online transactions, It utilizes modular Api's of worldpay\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Beta,\n};\n\nstatic WORLDPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Mandates,\n];\n\nimpl ConnectorSpecifications for Worldpaymodular {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WORLDPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*WORLDPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&WORLDPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs"}, {"query": "Authipay payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as authipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Authipay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Authipay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        \n\n... [truncated 26788 chars] ...\n\no {\n    display_name: \"Authipay\",\n    description: \"Authipay is a Fiserv-powered payment gateway for the EMEA region supporting Visa and Mastercard transactions. Features include flexible capture methods (automatic, manual, sequential), partial captures/refunds, payment tokenization, and secure HMAC SHA256 authentication.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic AUTHIPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Authipay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AUTHIPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AUTHIPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AUTHIPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "file": "crates__hyperswitch_connectors__src__connectors__authipay.rs"}, {"query": "Authipay connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as authipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Authipay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Authipay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        \n\n... [truncated 26788 chars] ...\n\no {\n    display_name: \"Authipay\",\n    description: \"Authipay is a Fiserv-powered payment gateway for the EMEA region supporting Visa and Mastercard transactions. Features include flexible capture methods (automatic, manual, sequential), partial captures/refunds, payment tokenization, and secure HMAC SHA256 authentication.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic AUTHIPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Authipay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AUTHIPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AUTHIPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AUTHIPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "file": "crates__hyperswitch_connectors__src__connectors__authipay.rs"}, {"query": "how to add a new payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as authipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Authipay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Authipay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        \n\n... [truncated 26788 chars] ...\n\no {\n    display_name: \"Authipay\",\n    description: \"Authipay is a Fiserv-powered payment gateway for the EMEA region supporting Visa and Mastercard transactions. Features include flexible capture methods (automatic, manual, sequential), partial captures/refunds, payment tokenization, and secure HMAC SHA256 authentication.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic AUTHIPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Authipay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AUTHIPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AUTHIPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AUTHIPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "file": "crates__hyperswitch_connectors__src__connectors__authipay.rs"}, {"query": "Hyperswitch Authipay HMAC SHA256 authentication", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers as authipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Authipay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Authipay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        \n\n... [truncated 26788 chars] ...\n\no {\n    display_name: \"Authipay\",\n    description: \"Authipay is a Fiserv-powered payment gateway for the EMEA region supporting Visa and Mastercard transactions. Features include flexible capture methods (automatic, manual, sequential), partial captures/refunds, payment tokenization, and secure HMAC SHA256 authentication.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic AUTHIPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Authipay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&AUTHIPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*AUTHIPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&AUTHIPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "file": "crates__hyperswitch_connectors__src__connectors__authipay.rs"}, {"query": "how to configure Payone connector", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\nuse common_utils::{consts::BASE64_ENGINE, errors::CustomResult, ext_traits::BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Method, Request, RequestBuilder},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::PoFulfill,\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::{\n    api::{PayoutFulfill, P\n\n... [truncated 13852 chars] ...\n\n::UserError,\n            \"50001054\" => ConnectorErrorType::TechnicalError,\n            \"50001087\" => ConnectorErrorType::TechnicalError,\n            _ => ConnectorErrorType::UnknownError,\n        }\n    }\n}\n\nstatic PAYONE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Payone\",\n    description: \"Payone payout connector for European market disbursements and automated fund distribution with comprehensive compliance support\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Payone {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYONE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payone.rs", "file": "crates__hyperswitch_connectors__src__connectors__payone.rs"}, {"query": "Payone payout implementation", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\nuse common_utils::{consts::BASE64_ENGINE, errors::CustomResult, ext_traits::BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Method, Request, RequestBuilder},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::PoFulfill,\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::{\n    api::{PayoutFulfill, P\n\n... [truncated 13852 chars] ...\n\n::UserError,\n            \"50001054\" => ConnectorErrorType::TechnicalError,\n            \"50001087\" => ConnectorErrorType::TechnicalError,\n            _ => ConnectorErrorType::UnknownError,\n        }\n    }\n}\n\nstatic PAYONE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Payone\",\n    description: \"Payone payout connector for European market disbursements and automated fund distribution with comprehensive compliance support\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Payone {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYONE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payone.rs", "file": "crates__hyperswitch_connectors__src__connectors__payone.rs"}, {"query": "hyperswitch payout connector", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\nuse common_utils::{consts::BASE64_ENGINE, errors::CustomResult, ext_traits::BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Method, Request, RequestBuilder},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::PoFulfill,\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::{\n    api::{PayoutFulfill, P\n\n... [truncated 13852 chars] ...\n\n::UserError,\n            \"50001054\" => ConnectorErrorType::TechnicalError,\n            \"50001087\" => ConnectorErrorType::TechnicalError,\n            _ => ConnectorErrorType::UnknownError,\n        }\n    }\n}\n\nstatic PAYONE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Payone\",\n    description: \"Payone payout connector for European market disbursements and automated fund distribution with comprehensive compliance support\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Payone {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYONE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payone.rs", "file": "crates__hyperswitch_connectors__src__connectors__payone.rs"}, {"query": "Payone signature generation", "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\nuse common_utils::{consts::BASE64_ENGINE, errors::CustomResult, ext_traits::BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Method, Request, RequestBuilder},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::PoFulfill,\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::{\n    api::{PayoutFulfill, P\n\n... [truncated 13852 chars] ...\n\n::UserError,\n            \"50001054\" => ConnectorErrorType::TechnicalError,\n            \"50001087\" => ConnectorErrorType::TechnicalError,\n            _ => ConnectorErrorType::UnknownError,\n        }\n    }\n}\n\nstatic PAYONE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Payone\",\n    description: \"Payone payout connector for European market disbursements and automated fund distribution with comprehensive compliance support\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Payone {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYONE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__payone.rs", "file": "crates__hyperswitch_connectors__src__connectors__payone.rs"}, {"query": "JPMorgan payment integration hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers::{self as jpmorgan, JpmorganErrorResponse};\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Jpmorgan {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Jpmorgan {\n    pub fn new() -> &'static Self {\n        &Self {\n           \n\n... [truncated 28712 chars] ...\n\n   jpmorgan_supported_payment_methods\n    });\n\nstatic JPMORGAN_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Jpmorgan\",\n        description:\n            \"J.P. Morgan is a global financial services firm and investment bank, offering banking, asset management, and payment processing solutions\",\n        connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n        integration_status: enums::ConnectorIntegrationStatus::Beta,\n    };\n\nstatic JPMORGAN_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Jpmorgan {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&JPMORGAN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*JPMORGAN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&JPMORGAN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__jpmorgan.rs", "file": "crates__hyperswitch_connectors__src__connectors__jpmorgan.rs"}, {"query": "Jpmorgan struct implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers::{self as jpmorgan, JpmorganErrorResponse};\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Jpmorgan {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Jpmorgan {\n    pub fn new() -> &'static Self {\n        &Self {\n           \n\n... [truncated 28712 chars] ...\n\n   jpmorgan_supported_payment_methods\n    });\n\nstatic JPMORGAN_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Jpmorgan\",\n        description:\n            \"J.P. Morgan is a global financial services firm and investment bank, offering banking, asset management, and payment processing solutions\",\n        connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n        integration_status: enums::ConnectorIntegrationStatus::Beta,\n    };\n\nstatic JPMORGAN_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Jpmorgan {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&JPMORGAN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*JPMORGAN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&JPMORGAN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__jpmorgan.rs", "file": "crates__hyperswitch_connectors__src__connectors__jpmorgan.rs"}, {"query": "how to add JPMorgan connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers::{self as jpmorgan, JpmorganErrorResponse};\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Jpmorgan {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Jpmorgan {\n    pub fn new() -> &'static Self {\n        &Self {\n           \n\n... [truncated 28712 chars] ...\n\n   jpmorgan_supported_payment_methods\n    });\n\nstatic JPMORGAN_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Jpmorgan\",\n        description:\n            \"J.P. Morgan is a global financial services firm and investment bank, offering banking, asset management, and payment processing solutions\",\n        connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n        integration_status: enums::ConnectorIntegrationStatus::Beta,\n    };\n\nstatic JPMORGAN_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Jpmorgan {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&JPMORGAN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*JPMORGAN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&JPMORGAN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__jpmorgan.rs", "file": "crates__hyperswitch_connectors__src__connectors__jpmorgan.rs"}, {"query": "JPMorgan bank acquirer connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers::{self as jpmorgan, JpmorganErrorResponse};\n\nuse crate::{\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Jpmorgan {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Jpmorgan {\n    pub fn new() -> &'static Self {\n        &Self {\n           \n\n... [truncated 28712 chars] ...\n\n   jpmorgan_supported_payment_methods\n    });\n\nstatic JPMORGAN_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Jpmorgan\",\n        description:\n            \"J.P. Morgan is a global financial services firm and investment bank, offering banking, asset management, and payment processing solutions\",\n        connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n        integration_status: enums::ConnectorIntegrationStatus::Beta,\n    };\n\nstatic JPMORGAN_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Jpmorgan {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&JPMORGAN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*JPMORGAN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&JPMORGAN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__jpmorgan.rs", "file": "crates__hyperswitch_connectors__src__connectors__jpmorgan.rs"}, {"query": "merchant connector account data model", "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\nuse common_utils::{\n    crypto::Encryptable,\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{StringExt, ValueExt},\n    id_type, pii, type_name,\n    types::keymanager::{Identifier, KeyManagerState, ToEncryptable},\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::merchant_connector_account::{\n    BillingAccountReference as DieselBillingAccountReference,\n    MerchantConnectorAccountFeatureMetadata as DieselMerchantConnectorAccountFeatureMetadata,\n    RevenueRecoveryMetadata as DieselRevenueRecoveryMetadata,\n};\nuse diesel_models::{\n    enums,\n    merchant_connector_account::{self as storage, MerchantConnectorAccountUpdateInternal},\n};\nuse error_stack::ResultExt;\nuse masking::{PeekInterface, Secret};\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\n\nuse super::behaviour;\n#[cfg(feature = \"v2\")]\nuse crate::errors::api_error_response;\nuse crate::{\n    mandates::CommonMandateReference,\n    merchant_key_store::MerchantKeyStore,\n    router_data,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime\n\n... [truncated 43184 chars] ...\n\n\n\n    async fn update_merchant_connector_account(\n        &self,\n        this: MerchantConnectorAccount,\n        merchant_connector_account: MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<MerchantConnectorAccount, Self::Error>;\n\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        this: Vec<(\n            MerchantConnectorAccount,\n            MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn delete_merchant_connector_account_by_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &id_type::MerchantId,\n        merchant_connector_id: &id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn delete_merchant_connector_account_by_id(\n        &self,\n        id: &id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, Self::Error>;\n}\n", "function_name": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "file": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs"}, {"query": "how to update merchant connector account", "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\nuse common_utils::{\n    crypto::Encryptable,\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{StringExt, ValueExt},\n    id_type, pii, type_name,\n    types::keymanager::{Identifier, KeyManagerState, ToEncryptable},\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::merchant_connector_account::{\n    BillingAccountReference as DieselBillingAccountReference,\n    MerchantConnectorAccountFeatureMetadata as DieselMerchantConnectorAccountFeatureMetadata,\n    RevenueRecoveryMetadata as DieselRevenueRecoveryMetadata,\n};\nuse diesel_models::{\n    enums,\n    merchant_connector_account::{self as storage, MerchantConnectorAccountUpdateInternal},\n};\nuse error_stack::ResultExt;\nuse masking::{PeekInterface, Secret};\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\n\nuse super::behaviour;\n#[cfg(feature = \"v2\")]\nuse crate::errors::api_error_response;\nuse crate::{\n    mandates::CommonMandateReference,\n    merchant_key_store::MerchantKeyStore,\n    router_data,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime\n\n... [truncated 43184 chars] ...\n\n\n\n    async fn update_merchant_connector_account(\n        &self,\n        this: MerchantConnectorAccount,\n        merchant_connector_account: MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<MerchantConnectorAccount, Self::Error>;\n\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        this: Vec<(\n            MerchantConnectorAccount,\n            MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn delete_merchant_connector_account_by_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &id_type::MerchantId,\n        merchant_connector_id: &id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn delete_merchant_connector_account_by_id(\n        &self,\n        id: &id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, Self::Error>;\n}\n", "function_name": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "file": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs"}, {"query": "connector account encryption implementation", "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\nuse common_utils::{\n    crypto::Encryptable,\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{StringExt, ValueExt},\n    id_type, pii, type_name,\n    types::keymanager::{Identifier, KeyManagerState, ToEncryptable},\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::merchant_connector_account::{\n    BillingAccountReference as DieselBillingAccountReference,\n    MerchantConnectorAccountFeatureMetadata as DieselMerchantConnectorAccountFeatureMetadata,\n    RevenueRecoveryMetadata as DieselRevenueRecoveryMetadata,\n};\nuse diesel_models::{\n    enums,\n    merchant_connector_account::{self as storage, MerchantConnectorAccountUpdateInternal},\n};\nuse error_stack::ResultExt;\nuse masking::{PeekInterface, Secret};\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\n\nuse super::behaviour;\n#[cfg(feature = \"v2\")]\nuse crate::errors::api_error_response;\nuse crate::{\n    mandates::CommonMandateReference,\n    merchant_key_store::MerchantKeyStore,\n    router_data,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime\n\n... [truncated 43184 chars] ...\n\n\n\n    async fn update_merchant_connector_account(\n        &self,\n        this: MerchantConnectorAccount,\n        merchant_connector_account: MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<MerchantConnectorAccount, Self::Error>;\n\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        this: Vec<(\n            MerchantConnectorAccount,\n            MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn delete_merchant_connector_account_by_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &id_type::MerchantId,\n        merchant_connector_id: &id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn delete_merchant_connector_account_by_id(\n        &self,\n        id: &id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, Self::Error>;\n}\n", "function_name": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "file": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs"}, {"query": "payment provider account configuration", "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\nuse common_utils::{\n    crypto::Encryptable,\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{StringExt, ValueExt},\n    id_type, pii, type_name,\n    types::keymanager::{Identifier, KeyManagerState, ToEncryptable},\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::merchant_connector_account::{\n    BillingAccountReference as DieselBillingAccountReference,\n    MerchantConnectorAccountFeatureMetadata as DieselMerchantConnectorAccountFeatureMetadata,\n    RevenueRecoveryMetadata as DieselRevenueRecoveryMetadata,\n};\nuse diesel_models::{\n    enums,\n    merchant_connector_account::{self as storage, MerchantConnectorAccountUpdateInternal},\n};\nuse error_stack::ResultExt;\nuse masking::{PeekInterface, Secret};\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\n\nuse super::behaviour;\n#[cfg(feature = \"v2\")]\nuse crate::errors::api_error_response;\nuse crate::{\n    mandates::CommonMandateReference,\n    merchant_key_store::MerchantKeyStore,\n    router_data,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime\n\n... [truncated 43184 chars] ...\n\n\n\n    async fn update_merchant_connector_account(\n        &self,\n        this: MerchantConnectorAccount,\n        merchant_connector_account: MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<MerchantConnectorAccount, Self::Error>;\n\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        this: Vec<(\n            MerchantConnectorAccount,\n            MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn delete_merchant_connector_account_by_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &id_type::MerchantId,\n        merchant_connector_id: &id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn delete_merchant_connector_account_by_id(\n        &self,\n        id: &id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, Self::Error>;\n}\n", "function_name": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "file": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs"}, {"query": "how to implement Wise connector", "code": "pub mod transformers;\n\nuse api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, RequestBuilder, RequestContent};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector};\nuse common_utils::{errors::CustomResult, ext_traits::ByteSliceExt, request::Request};\n#[cfg(not(feature = \"payouts\"))]\nuse error_stack::report;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoSync,\n    },\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::PayoutQuoteType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCancelType, PayoutCreateType, PayoutFulfillType, PayoutRecipientType, PayoutSyncType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"\n\n... [truncated 28642 chars] ...\n\nWisePayoutSyncResponse::from(payload.data)))\n        }\n        #[cfg(not(feature = \"payouts\"))]\n        {\n            Err(report!(ConnectorError::WebhooksNotImplemented))\n        }\n    }\n}\n\nstatic WISE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wise\",\n    description: \"The Wise connector enables cross-border money transfers by integrating with Wise's API to initiate, track, and manage international payouts efficiently.\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Wise {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WISE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wise.rs", "file": "crates__hyperswitch_connectors__src__connectors__wise.rs"}, {"query": "Wise connector Rust implementation", "code": "pub mod transformers;\n\nuse api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, RequestBuilder, RequestContent};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector};\nuse common_utils::{errors::CustomResult, ext_traits::ByteSliceExt, request::Request};\n#[cfg(not(feature = \"payouts\"))]\nuse error_stack::report;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoSync,\n    },\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::PayoutQuoteType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCancelType, PayoutCreateType, PayoutFulfillType, PayoutRecipientType, PayoutSyncType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"\n\n... [truncated 28642 chars] ...\n\nWisePayoutSyncResponse::from(payload.data)))\n        }\n        #[cfg(not(feature = \"payouts\"))]\n        {\n            Err(report!(ConnectorError::WebhooksNotImplemented))\n        }\n    }\n}\n\nstatic WISE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wise\",\n    description: \"The Wise connector enables cross-border money transfers by integrating with Wise's API to initiate, track, and manage international payouts efficiently.\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Wise {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WISE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wise.rs", "file": "crates__hyperswitch_connectors__src__connectors__wise.rs"}, {"query": "how to handle Wise payouts", "code": "pub mod transformers;\n\nuse api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, RequestBuilder, RequestContent};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector};\nuse common_utils::{errors::CustomResult, ext_traits::ByteSliceExt, request::Request};\n#[cfg(not(feature = \"payouts\"))]\nuse error_stack::report;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoSync,\n    },\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::PayoutQuoteType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCancelType, PayoutCreateType, PayoutFulfillType, PayoutRecipientType, PayoutSyncType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"\n\n... [truncated 28642 chars] ...\n\nWisePayoutSyncResponse::from(payload.data)))\n        }\n        #[cfg(not(feature = \"payouts\"))]\n        {\n            Err(report!(ConnectorError::WebhooksNotImplemented))\n        }\n    }\n}\n\nstatic WISE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wise\",\n    description: \"The Wise connector enables cross-border money transfers by integrating with Wise's API to initiate, track, and manage international payouts efficiently.\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Wise {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WISE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wise.rs", "file": "crates__hyperswitch_connectors__src__connectors__wise.rs"}, {"query": "Wise webhook integration hyperswitch", "code": "pub mod transformers;\n\nuse api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::{Method, RequestBuilder, RequestContent};\n#[cfg(feature = \"payouts\")]\nuse common_utils::types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector};\nuse common_utils::{errors::CustomResult, ext_traits::ByteSliceExt, request::Request};\n#[cfg(not(feature = \"payouts\"))]\nuse error_stack::report;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoSync,\n    },\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::PayoutQuoteType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCancelType, PayoutCreateType, PayoutFulfillType, PayoutRecipientType, PayoutSyncType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"\n\n... [truncated 28642 chars] ...\n\nWisePayoutSyncResponse::from(payload.data)))\n        }\n        #[cfg(not(feature = \"payouts\"))]\n        {\n            Err(report!(ConnectorError::WebhooksNotImplemented))\n        }\n    }\n}\n\nstatic WISE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Wise\",\n    description: \"The Wise connector enables cross-border money transfers by integrating with Wise's API to initiate, track, and manage international payouts efficiently.\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Wise {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&WISE_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__wise.rs", "file": "crates__hyperswitch_connectors__src__connectors__wise.rs"}, {"query": "how to transform payments data for Placetopay", "code": "use common_enums::{enums, Currency};\nuse common_utils::{consts::BASE64_ENGINE, date_time, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, generate_random_bytes, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct PlacetopayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PlacetopayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPaymentsRequest {\n    auth: PlacetopayAuth,\n    payment: PlacetopayPayment,\n    instrument: PlacetopayInstrument,\n    ip_address: Secret<String, common_utils::pii::IpAddress>,\n    user_agent: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PlacetopayAuthorizeAction {\n    Checkin,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuthType {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuth {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n    nonce: Secret<String>,\n    seed: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPayment {\n    reference: String,\n    description: String,\n    \n\n... [truncated 14883 chars] ...\n\nem\n            .request\n            .connector_transaction_id\n            .parse::<u64>()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let action = PlacetopayNextAction::Checkout;\n        Ok(Self {\n            auth,\n            internal_reference,\n            action,\n        })\n    }\n}\n\nimpl TryFrom<&types::PaymentsCancelRouterData> for PlacetopayNextActionRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(item: &types::PaymentsCancelRouterData) -> Result<Self, Self::Error> {\n        let auth = PlacetopayAuth::try_from(&item.connector_auth_type)?;\n        let internal_reference = item\n            .request\n            .connector_transaction_id\n            .parse::<u64>()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let action = PlacetopayNextAction::Void;\n        Ok(Self {\n            auth,\n            internal_reference,\n            action,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs"}, {"query": "PlacetopayPaymentsRequest struct definition", "code": "use common_enums::{enums, Currency};\nuse common_utils::{consts::BASE64_ENGINE, date_time, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, generate_random_bytes, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct PlacetopayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PlacetopayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPaymentsRequest {\n    auth: PlacetopayAuth,\n    payment: PlacetopayPayment,\n    instrument: PlacetopayInstrument,\n    ip_address: Secret<String, common_utils::pii::IpAddress>,\n    user_agent: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PlacetopayAuthorizeAction {\n    Checkin,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuthType {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuth {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n    nonce: Secret<String>,\n    seed: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPayment {\n    reference: String,\n    description: String,\n    \n\n... [truncated 14883 chars] ...\n\nem\n            .request\n            .connector_transaction_id\n            .parse::<u64>()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let action = PlacetopayNextAction::Checkout;\n        Ok(Self {\n            auth,\n            internal_reference,\n            action,\n        })\n    }\n}\n\nimpl TryFrom<&types::PaymentsCancelRouterData> for PlacetopayNextActionRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(item: &types::PaymentsCancelRouterData) -> Result<Self, Self::Error> {\n        let auth = PlacetopayAuth::try_from(&item.connector_auth_type)?;\n        let internal_reference = item\n            .request\n            .connector_transaction_id\n            .parse::<u64>()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let action = PlacetopayNextAction::Void;\n        Ok(Self {\n            auth,\n            internal_reference,\n            action,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs"}, {"query": "implement Placetopay connector transformer", "code": "use common_enums::{enums, Currency};\nuse common_utils::{consts::BASE64_ENGINE, date_time, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, generate_random_bytes, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct PlacetopayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PlacetopayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPaymentsRequest {\n    auth: PlacetopayAuth,\n    payment: PlacetopayPayment,\n    instrument: PlacetopayInstrument,\n    ip_address: Secret<String, common_utils::pii::IpAddress>,\n    user_agent: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PlacetopayAuthorizeAction {\n    Checkin,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuthType {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuth {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n    nonce: Secret<String>,\n    seed: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPayment {\n    reference: String,\n    description: String,\n    \n\n... [truncated 14883 chars] ...\n\nem\n            .request\n            .connector_transaction_id\n            .parse::<u64>()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let action = PlacetopayNextAction::Checkout;\n        Ok(Self {\n            auth,\n            internal_reference,\n            action,\n        })\n    }\n}\n\nimpl TryFrom<&types::PaymentsCancelRouterData> for PlacetopayNextActionRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(item: &types::PaymentsCancelRouterData) -> Result<Self, Self::Error> {\n        let auth = PlacetopayAuth::try_from(&item.connector_auth_type)?;\n        let internal_reference = item\n            .request\n            .connector_transaction_id\n            .parse::<u64>()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let action = PlacetopayNextAction::Void;\n        Ok(Self {\n            auth,\n            internal_reference,\n            action,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs"}, {"query": "Placetopay API request mapping", "code": "use common_enums::{enums, Currency};\nuse common_utils::{consts::BASE64_ENGINE, date_time, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, generate_random_bytes, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct PlacetopayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PlacetopayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPaymentsRequest {\n    auth: PlacetopayAuth,\n    payment: PlacetopayPayment,\n    instrument: PlacetopayInstrument,\n    ip_address: Secret<String, common_utils::pii::IpAddress>,\n    user_agent: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PlacetopayAuthorizeAction {\n    Checkin,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuthType {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuth {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n    nonce: Secret<String>,\n    seed: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPayment {\n    reference: String,\n    description: String,\n    \n\n... [truncated 14883 chars] ...\n\nem\n            .request\n            .connector_transaction_id\n            .parse::<u64>()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let action = PlacetopayNextAction::Checkout;\n        Ok(Self {\n            auth,\n            internal_reference,\n            action,\n        })\n    }\n}\n\nimpl TryFrom<&types::PaymentsCancelRouterData> for PlacetopayNextActionRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(item: &types::PaymentsCancelRouterData) -> Result<Self, Self::Error> {\n        let auth = PlacetopayAuth::try_from(&item.connector_auth_type)?;\n        let internal_reference = item\n            .request\n            .connector_transaction_id\n            .parse::<u64>()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let action = PlacetopayNextAction::Void;\n        Ok(Self {\n            auth,\n            internal_reference,\n            action,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs"}, {"query": "payment orchestration response types", "code": "pub mod disputes;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\nuse std::collections::HashMap;\n\nuse api_models::payments::AddressDetails;\nuse common_utils::{pii, request::Method, types::MinorUnit};\npub use disputes::{\n    AcceptDisputeResponse, DefendDisputeResponse, DisputeSyncResponse, FetchDisputesResponse,\n    SubmitEvidenceResponse,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    errors::api_error_response::ApiErrorResponse,\n    router_request_types::{authentication::AuthNFlowType, ResponseId, UcsAuthenticationData},\n    vault::PaymentMethodVaultingData,\n};\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct RefundsResponseData {\n    pub connector_refund_id: String,\n    pub refund_status: common_enums::RefundStatus,\n    // pub amount_received: Option<i32>, // Calculation for amount received not in place yet\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConnectorCustomerResponseData {\n    pub connector_customer_id: String,\n    pub name: Option<String>,\n    pub email: Option<String>,\n    pub billing_address: Option<AddressDetails>,\n}\n\nimpl ConnectorCustomerResponseData {\n    pub fn new_with_customer_id(connector_customer_id: String) -> Self {\n        Self::new(connector_customer_id, None, None, None)\n    }\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_r\n\n... [truncated 25615 chars] ...\n\network_token_exp_month,\n                    tokenized_network_token_exp_year,\n                    tokenized_cryptogram,\n                } => Ok(\n                    api_models::authentication::AuthenticationVaultTokenData::NetworkTokenData {\n                        tokenized_network_token,\n                        tokenized_expiry_month: tokenized_network_token_exp_month,\n                        tokenized_expiry_year: tokenized_network_token_exp_year,\n                        tokenized_cryptogram,\n                    },\n                ),\n            },\n            Self::SingleVaultId(_) => Err(ApiErrorResponse::InternalServerError)\n                .attach_printable(\"Unexpected Behaviour, Multi Token Data is missing\"),\n        }\n    }\n}\n\nimpl Default for VaultResponseData {\n    fn default() -> Self {\n        Self::ExternalVaultInsertResponse {\n            connector_vault_id: VaultIdType::SingleVaultId(String::new()),\n            fingerprint_id: String::new(),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_response_types.rs", "file": "crates__hyperswitch_domain_models__src__router_response_types.rs"}, {"query": "RefundsResponseData struct definition", "code": "pub mod disputes;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\nuse std::collections::HashMap;\n\nuse api_models::payments::AddressDetails;\nuse common_utils::{pii, request::Method, types::MinorUnit};\npub use disputes::{\n    AcceptDisputeResponse, DefendDisputeResponse, DisputeSyncResponse, FetchDisputesResponse,\n    SubmitEvidenceResponse,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    errors::api_error_response::ApiErrorResponse,\n    router_request_types::{authentication::AuthNFlowType, ResponseId, UcsAuthenticationData},\n    vault::PaymentMethodVaultingData,\n};\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct RefundsResponseData {\n    pub connector_refund_id: String,\n    pub refund_status: common_enums::RefundStatus,\n    // pub amount_received: Option<i32>, // Calculation for amount received not in place yet\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConnectorCustomerResponseData {\n    pub connector_customer_id: String,\n    pub name: Option<String>,\n    pub email: Option<String>,\n    pub billing_address: Option<AddressDetails>,\n}\n\nimpl ConnectorCustomerResponseData {\n    pub fn new_with_customer_id(connector_customer_id: String) -> Self {\n        Self::new(connector_customer_id, None, None, None)\n    }\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_r\n\n... [truncated 25615 chars] ...\n\network_token_exp_month,\n                    tokenized_network_token_exp_year,\n                    tokenized_cryptogram,\n                } => Ok(\n                    api_models::authentication::AuthenticationVaultTokenData::NetworkTokenData {\n                        tokenized_network_token,\n                        tokenized_expiry_month: tokenized_network_token_exp_month,\n                        tokenized_expiry_year: tokenized_network_token_exp_year,\n                        tokenized_cryptogram,\n                    },\n                ),\n            },\n            Self::SingleVaultId(_) => Err(ApiErrorResponse::InternalServerError)\n                .attach_printable(\"Unexpected Behaviour, Multi Token Data is missing\"),\n        }\n    }\n}\n\nimpl Default for VaultResponseData {\n    fn default() -> Self {\n        Self::ExternalVaultInsertResponse {\n            connector_vault_id: VaultIdType::SingleVaultId(String::new()),\n            fingerprint_id: String::new(),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_response_types.rs", "file": "crates__hyperswitch_domain_models__src__router_response_types.rs"}, {"query": "how to handle connector payment responses", "code": "pub mod disputes;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\nuse std::collections::HashMap;\n\nuse api_models::payments::AddressDetails;\nuse common_utils::{pii, request::Method, types::MinorUnit};\npub use disputes::{\n    AcceptDisputeResponse, DefendDisputeResponse, DisputeSyncResponse, FetchDisputesResponse,\n    SubmitEvidenceResponse,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    errors::api_error_response::ApiErrorResponse,\n    router_request_types::{authentication::AuthNFlowType, ResponseId, UcsAuthenticationData},\n    vault::PaymentMethodVaultingData,\n};\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct RefundsResponseData {\n    pub connector_refund_id: String,\n    pub refund_status: common_enums::RefundStatus,\n    // pub amount_received: Option<i32>, // Calculation for amount received not in place yet\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConnectorCustomerResponseData {\n    pub connector_customer_id: String,\n    pub name: Option<String>,\n    pub email: Option<String>,\n    pub billing_address: Option<AddressDetails>,\n}\n\nimpl ConnectorCustomerResponseData {\n    pub fn new_with_customer_id(connector_customer_id: String) -> Self {\n        Self::new(connector_customer_id, None, None, None)\n    }\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_r\n\n... [truncated 25615 chars] ...\n\network_token_exp_month,\n                    tokenized_network_token_exp_year,\n                    tokenized_cryptogram,\n                } => Ok(\n                    api_models::authentication::AuthenticationVaultTokenData::NetworkTokenData {\n                        tokenized_network_token,\n                        tokenized_expiry_month: tokenized_network_token_exp_month,\n                        tokenized_expiry_year: tokenized_network_token_exp_year,\n                        tokenized_cryptogram,\n                    },\n                ),\n            },\n            Self::SingleVaultId(_) => Err(ApiErrorResponse::InternalServerError)\n                .attach_printable(\"Unexpected Behaviour, Multi Token Data is missing\"),\n        }\n    }\n}\n\nimpl Default for VaultResponseData {\n    fn default() -> Self {\n        Self::ExternalVaultInsertResponse {\n            connector_vault_id: VaultIdType::SingleVaultId(String::new()),\n            fingerprint_id: String::new(),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_response_types.rs", "file": "crates__hyperswitch_domain_models__src__router_response_types.rs"}, {"query": "VaultResponseData authentication token mapping", "code": "pub mod disputes;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\nuse std::collections::HashMap;\n\nuse api_models::payments::AddressDetails;\nuse common_utils::{pii, request::Method, types::MinorUnit};\npub use disputes::{\n    AcceptDisputeResponse, DefendDisputeResponse, DisputeSyncResponse, FetchDisputesResponse,\n    SubmitEvidenceResponse,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    errors::api_error_response::ApiErrorResponse,\n    router_request_types::{authentication::AuthNFlowType, ResponseId, UcsAuthenticationData},\n    vault::PaymentMethodVaultingData,\n};\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct RefundsResponseData {\n    pub connector_refund_id: String,\n    pub refund_status: common_enums::RefundStatus,\n    // pub amount_received: Option<i32>, // Calculation for amount received not in place yet\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConnectorCustomerResponseData {\n    pub connector_customer_id: String,\n    pub name: Option<String>,\n    pub email: Option<String>,\n    pub billing_address: Option<AddressDetails>,\n}\n\nimpl ConnectorCustomerResponseData {\n    pub fn new_with_customer_id(connector_customer_id: String) -> Self {\n        Self::new(connector_customer_id, None, None, None)\n    }\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_r\n\n... [truncated 25615 chars] ...\n\network_token_exp_month,\n                    tokenized_network_token_exp_year,\n                    tokenized_cryptogram,\n                } => Ok(\n                    api_models::authentication::AuthenticationVaultTokenData::NetworkTokenData {\n                        tokenized_network_token,\n                        tokenized_expiry_month: tokenized_network_token_exp_month,\n                        tokenized_expiry_year: tokenized_network_token_exp_year,\n                        tokenized_cryptogram,\n                    },\n                ),\n            },\n            Self::SingleVaultId(_) => Err(ApiErrorResponse::InternalServerError)\n                .attach_printable(\"Unexpected Behaviour, Multi Token Data is missing\"),\n        }\n    }\n}\n\nimpl Default for VaultResponseData {\n    fn default() -> Self {\n        Self::ExternalVaultInsertResponse {\n            connector_vault_id: VaultIdType::SingleVaultId(String::new()),\n            fingerprint_id: String::new(),\n        }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__router_response_types.rs", "file": "crates__hyperswitch_domain_models__src__router_response_types.rs"}, {"query": "payment attempt data model rust", "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, Crypt\n\n... [truncated 161478 chars] ...\n\nFeatureMetadata> for DieselPaymentAttemptFeatureMetadata {\n    fn from(item: &PaymentAttemptFeatureMetadata) -> Self {\n        let revenue_recovery =\n            item.revenue_recovery\n                .as_ref()\n                .map(|recovery_data| DieselPassiveChurnRecoveryData {\n                    attempt_triggered_by: recovery_data.attempt_triggered_by,\n                    charge_id: recovery_data.charge_id.clone(),\n                });\n        Self { revenue_recovery }\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl From<DieselPaymentAttemptFeatureMetadata> for PaymentAttemptFeatureMetadata {\n    fn from(item: DieselPaymentAttemptFeatureMetadata) -> Self {\n        let revenue_recovery =\n            item.revenue_recovery\n                .map(|recovery_data| PaymentAttemptRevenueRecoveryData {\n                    attempt_triggered_by: recovery_data.attempt_triggered_by,\n                    charge_id: recovery_data.charge_id,\n                });\n        Self { revenue_recovery }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs", "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs"}, {"query": "PaymentAttempt struct definition", "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, Crypt\n\n... [truncated 161478 chars] ...\n\nFeatureMetadata> for DieselPaymentAttemptFeatureMetadata {\n    fn from(item: &PaymentAttemptFeatureMetadata) -> Self {\n        let revenue_recovery =\n            item.revenue_recovery\n                .as_ref()\n                .map(|recovery_data| DieselPassiveChurnRecoveryData {\n                    attempt_triggered_by: recovery_data.attempt_triggered_by,\n                    charge_id: recovery_data.charge_id.clone(),\n                });\n        Self { revenue_recovery }\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl From<DieselPaymentAttemptFeatureMetadata> for PaymentAttemptFeatureMetadata {\n    fn from(item: DieselPaymentAttemptFeatureMetadata) -> Self {\n        let revenue_recovery =\n            item.revenue_recovery\n                .map(|recovery_data| PaymentAttemptRevenueRecoveryData {\n                    attempt_triggered_by: recovery_data.attempt_triggered_by,\n                    charge_id: recovery_data.charge_id,\n                });\n        Self { revenue_recovery }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs", "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs"}, {"query": "how to update payment attempt status", "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, Crypt\n\n... [truncated 161478 chars] ...\n\nFeatureMetadata> for DieselPaymentAttemptFeatureMetadata {\n    fn from(item: &PaymentAttemptFeatureMetadata) -> Self {\n        let revenue_recovery =\n            item.revenue_recovery\n                .as_ref()\n                .map(|recovery_data| DieselPassiveChurnRecoveryData {\n                    attempt_triggered_by: recovery_data.attempt_triggered_by,\n                    charge_id: recovery_data.charge_id.clone(),\n                });\n        Self { revenue_recovery }\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl From<DieselPaymentAttemptFeatureMetadata> for PaymentAttemptFeatureMetadata {\n    fn from(item: DieselPaymentAttemptFeatureMetadata) -> Self {\n        let revenue_recovery =\n            item.revenue_recovery\n                .map(|recovery_data| PaymentAttemptRevenueRecoveryData {\n                    attempt_triggered_by: recovery_data.attempt_triggered_by,\n                    charge_id: recovery_data.charge_id,\n                });\n        Self { revenue_recovery }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs", "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs"}, {"query": "payment attempt revenue recovery metadata", "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, Crypt\n\n... [truncated 161478 chars] ...\n\nFeatureMetadata> for DieselPaymentAttemptFeatureMetadata {\n    fn from(item: &PaymentAttemptFeatureMetadata) -> Self {\n        let revenue_recovery =\n            item.revenue_recovery\n                .as_ref()\n                .map(|recovery_data| DieselPassiveChurnRecoveryData {\n                    attempt_triggered_by: recovery_data.attempt_triggered_by,\n                    charge_id: recovery_data.charge_id.clone(),\n                });\n        Self { revenue_recovery }\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl From<DieselPaymentAttemptFeatureMetadata> for PaymentAttemptFeatureMetadata {\n    fn from(item: DieselPaymentAttemptFeatureMetadata) -> Self {\n        let revenue_recovery =\n            item.revenue_recovery\n                .map(|recovery_data| PaymentAttemptRevenueRecoveryData {\n                    attempt_triggered_by: recovery_data.attempt_triggered_by,\n                    charge_id: recovery_data.charge_id,\n                });\n        Self { revenue_recovery }\n    }\n}\n", "function_name": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs", "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs"}, {"query": "WorldPay XML to HyperSwitch model conversion", "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::{ApplePayDecrypt, CardPayout};\nuse base64::Engine;\nuse common_enums::enums;\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse http::HeaderMap;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    address::Address,\n    router_flow_types::payouts::{PoCancel, PoFulfill, PoSync},\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, Card, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse josekit;\nuse masking::{ExposeInterface, Secret, WithType};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, AddressDetailsData, CardData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct WorldpayxmlRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\n\n... [truncated 110907 chars] ...\n\nnt(event_code: LastEvent) -> bool {\n    matches!(\n        event_code,\n        LastEvent::SentForRefund\n            | LastEvent::RefundedByMerchant\n            | LastEvent::RefundRequested\n            | LastEvent::Refunded\n            | LastEvent::RefundFailed\n    )\n}\n\npub fn is_transaction_event(event_code: LastEvent) -> bool {\n    matches!(\n        event_code,\n        LastEvent::Authorised\n            | LastEvent::Settled\n            | LastEvent::Captured\n            | LastEvent::SentForAuthorisation\n            | LastEvent::Cancelled\n            | LastEvent::Refused\n    )\n}\n\nfn get_mandate_type(mit_category: Option<common_enums::MitCategory>) -> MandateType {\n    match mit_category {\n        Some(common_enums::MitCategory::Installment) => MandateType::Instalment,\n        Some(common_enums::MitCategory::Recurring) => MandateType::Recurring,\n        Some(common_enums::MitCategory::Unscheduled) | None => MandateType::Unscheduled,\n        _ => MandateType::Unscheduled,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayxml__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayxml__transformers.rs"}, {"query": "WorldpayxmlRouterData struct definition", "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::{ApplePayDecrypt, CardPayout};\nuse base64::Engine;\nuse common_enums::enums;\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse http::HeaderMap;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    address::Address,\n    router_flow_types::payouts::{PoCancel, PoFulfill, PoSync},\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, Card, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse josekit;\nuse masking::{ExposeInterface, Secret, WithType};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, AddressDetailsData, CardData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct WorldpayxmlRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\n\n... [truncated 110907 chars] ...\n\nnt(event_code: LastEvent) -> bool {\n    matches!(\n        event_code,\n        LastEvent::SentForRefund\n            | LastEvent::RefundedByMerchant\n            | LastEvent::RefundRequested\n            | LastEvent::Refunded\n            | LastEvent::RefundFailed\n    )\n}\n\npub fn is_transaction_event(event_code: LastEvent) -> bool {\n    matches!(\n        event_code,\n        LastEvent::Authorised\n            | LastEvent::Settled\n            | LastEvent::Captured\n            | LastEvent::SentForAuthorisation\n            | LastEvent::Cancelled\n            | LastEvent::Refused\n    )\n}\n\nfn get_mandate_type(mit_category: Option<common_enums::MitCategory>) -> MandateType {\n    match mit_category {\n        Some(common_enums::MitCategory::Installment) => MandateType::Instalment,\n        Some(common_enums::MitCategory::Recurring) => MandateType::Recurring,\n        Some(common_enums::MitCategory::Unscheduled) | None => MandateType::Unscheduled,\n        _ => MandateType::Unscheduled,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayxml__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayxml__transformers.rs"}, {"query": "how to implement WorldPay XML connector", "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::{ApplePayDecrypt, CardPayout};\nuse base64::Engine;\nuse common_enums::enums;\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse http::HeaderMap;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    address::Address,\n    router_flow_types::payouts::{PoCancel, PoFulfill, PoSync},\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, Card, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse josekit;\nuse masking::{ExposeInterface, Secret, WithType};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, AddressDetailsData, CardData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct WorldpayxmlRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\n\n... [truncated 110907 chars] ...\n\nnt(event_code: LastEvent) -> bool {\n    matches!(\n        event_code,\n        LastEvent::SentForRefund\n            | LastEvent::RefundedByMerchant\n            | LastEvent::RefundRequested\n            | LastEvent::Refunded\n            | LastEvent::RefundFailed\n    )\n}\n\npub fn is_transaction_event(event_code: LastEvent) -> bool {\n    matches!(\n        event_code,\n        LastEvent::Authorised\n            | LastEvent::Settled\n            | LastEvent::Captured\n            | LastEvent::SentForAuthorisation\n            | LastEvent::Cancelled\n            | LastEvent::Refused\n    )\n}\n\nfn get_mandate_type(mit_category: Option<common_enums::MitCategory>) -> MandateType {\n    match mit_category {\n        Some(common_enums::MitCategory::Installment) => MandateType::Instalment,\n        Some(common_enums::MitCategory::Recurring) => MandateType::Recurring,\n        Some(common_enums::MitCategory::Unscheduled) | None => MandateType::Unscheduled,\n        _ => MandateType::Unscheduled,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayxml__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayxml__transformers.rs"}, {"query": "WorldPay payment service XML structure", "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::{ApplePayDecrypt, CardPayout};\nuse base64::Engine;\nuse common_enums::enums;\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse http::HeaderMap;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    address::Address,\n    router_flow_types::payouts::{PoCancel, PoFulfill, PoSync},\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, Card, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse josekit;\nuse masking::{ExposeInterface, Secret, WithType};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, AddressDetailsData, CardData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct WorldpayxmlRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\n\n... [truncated 110907 chars] ...\n\nnt(event_code: LastEvent) -> bool {\n    matches!(\n        event_code,\n        LastEvent::SentForRefund\n            | LastEvent::RefundedByMerchant\n            | LastEvent::RefundRequested\n            | LastEvent::Refunded\n            | LastEvent::RefundFailed\n    )\n}\n\npub fn is_transaction_event(event_code: LastEvent) -> bool {\n    matches!(\n        event_code,\n        LastEvent::Authorised\n            | LastEvent::Settled\n            | LastEvent::Captured\n            | LastEvent::SentForAuthorisation\n            | LastEvent::Cancelled\n            | LastEvent::Refused\n    )\n}\n\nfn get_mandate_type(mit_category: Option<common_enums::MitCategory>) -> MandateType {\n    match mit_category {\n        Some(common_enums::MitCategory::Installment) => MandateType::Instalment,\n        Some(common_enums::MitCategory::Recurring) => MandateType::Recurring,\n        Some(common_enums::MitCategory::Unscheduled) | None => MandateType::Unscheduled,\n        _ => MandateType::Unscheduled,\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__worldpayxml__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__worldpayxml__transformers.rs"}, {"query": "Deutsche Bank payment connector implementation", "code": "pub mod transformers;\n\nuse std::{sync::LazyLock, time::SystemTime};\n\nuse actix_web::http::header::Date;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefreshTokenRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse ring::hmac;\nuse transformers as deutschebank;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    ut\n\n... [truncated 36745 chars] ...\n\n   ),\n            },\n        );\n\n        deutschebank_supported_payment_methods\n    });\n\nstatic DEUTSCHEBANK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Deutsche Bank\",\n    description:\n        \"Deutsche Bank is a German multinational investment bank and financial services company \",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic DEUTSCHEBANK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Deutschebank {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DEUTSCHEBANK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DEUTSCHEBANK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DEUTSCHEBANK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__deutschebank.rs", "file": "crates__hyperswitch_connectors__src__connectors__deutschebank.rs"}, {"query": "Deutschebank struct definition", "code": "pub mod transformers;\n\nuse std::{sync::LazyLock, time::SystemTime};\n\nuse actix_web::http::header::Date;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefreshTokenRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse ring::hmac;\nuse transformers as deutschebank;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    ut\n\n... [truncated 36745 chars] ...\n\n   ),\n            },\n        );\n\n        deutschebank_supported_payment_methods\n    });\n\nstatic DEUTSCHEBANK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Deutsche Bank\",\n    description:\n        \"Deutsche Bank is a German multinational investment bank and financial services company \",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic DEUTSCHEBANK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Deutschebank {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DEUTSCHEBANK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DEUTSCHEBANK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DEUTSCHEBANK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__deutschebank.rs", "file": "crates__hyperswitch_connectors__src__connectors__deutschebank.rs"}, {"query": "how to add a new payment connector", "code": "pub mod transformers;\n\nuse std::{sync::LazyLock, time::SystemTime};\n\nuse actix_web::http::header::Date;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefreshTokenRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse ring::hmac;\nuse transformers as deutschebank;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    ut\n\n... [truncated 36745 chars] ...\n\n   ),\n            },\n        );\n\n        deutschebank_supported_payment_methods\n    });\n\nstatic DEUTSCHEBANK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Deutsche Bank\",\n    description:\n        \"Deutsche Bank is a German multinational investment bank and financial services company \",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic DEUTSCHEBANK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Deutschebank {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DEUTSCHEBANK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DEUTSCHEBANK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DEUTSCHEBANK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__deutschebank.rs", "file": "crates__hyperswitch_connectors__src__connectors__deutschebank.rs"}, {"query": "hyperswitch bank acquirer integration", "code": "pub mod transformers;\n\nuse std::{sync::LazyLock, time::SystemTime};\n\nuse actix_web::http::header::Date;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefreshTokenRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse ring::hmac;\nuse transformers as deutschebank;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    ut\n\n... [truncated 36745 chars] ...\n\n   ),\n            },\n        );\n\n        deutschebank_supported_payment_methods\n    });\n\nstatic DEUTSCHEBANK_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Deutsche Bank\",\n    description:\n        \"Deutsche Bank is a German multinational investment bank and financial services company \",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic DEUTSCHEBANK_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Deutschebank {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&DEUTSCHEBANK_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*DEUTSCHEBANK_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&DEUTSCHEBANK_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__deutschebank.rs", "file": "crates__hyperswitch_connectors__src__connectors__deutschebank.rs"}, {"query": "how to integrate katapult payment gateway", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as katapult;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Katapult {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Katapult {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Katapult {}\nimpl api::PaymentSession f\n\n... [truncated 18673 chars] ...\n\nreport!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic KATAPULT_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic KATAPULT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Katapult\",\n    description: \"Katapult connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic KATAPULT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Katapult {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&KATAPULT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*KATAPULT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&KATAPULT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__katapult.rs", "file": "crates__hyperswitch_connectors__src__connectors__katapult.rs"}, {"query": "hyperswitch katapult connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as katapult;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Katapult {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Katapult {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Katapult {}\nimpl api::PaymentSession f\n\n... [truncated 18673 chars] ...\n\nreport!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic KATAPULT_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic KATAPULT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Katapult\",\n    description: \"Katapult connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic KATAPULT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Katapult {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&KATAPULT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*KATAPULT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&KATAPULT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__katapult.rs", "file": "crates__hyperswitch_connectors__src__connectors__katapult.rs"}, {"query": "implement payment gateway connector rust", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as katapult;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Katapult {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Katapult {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Katapult {}\nimpl api::PaymentSession f\n\n... [truncated 18673 chars] ...\n\nreport!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic KATAPULT_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic KATAPULT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Katapult\",\n    description: \"Katapult connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic KATAPULT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Katapult {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&KATAPULT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*KATAPULT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&KATAPULT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__katapult.rs", "file": "crates__hyperswitch_connectors__src__connectors__katapult.rs"}, {"query": "katapult authorize payment method hyperswitch", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as katapult;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Katapult {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Katapult {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Katapult {}\nimpl api::PaymentSession f\n\n... [truncated 18673 chars] ...\n\nreport!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic KATAPULT_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> =\n    LazyLock::new(SupportedPaymentMethods::new);\n\nstatic KATAPULT_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Katapult\",\n    description: \"Katapult connector\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Alpha,\n};\n\nstatic KATAPULT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Katapult {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&KATAPULT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*KATAPULT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&KATAPULT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__katapult.rs", "file": "crates__hyperswitch_connectors__src__connectors__katapult.rs"}, {"query": "PeachPayments payment request transformer", "code": "use std::str::FromStr;\n\nuse cards::{CardNumber, NetworkToken};\nuse common_enums::enums as storage_enums;\nuse common_utils::{errors::CustomResult, pii, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, CardWithLimitedDetails, NetworkTokenData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{RefundsData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::OffsetDateTime;\n\nuse crate::{\n    types::ResponseRouterData,\n    utils::{\n        self, CardData, CardWithLimitedData as _, NetworkTokenData as _,\n        RouterData as OtherRouterData,\n    },\n};\n\npub struct PeachpaymentsRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PeachpaymentsRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for PeachPaymentsConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nconst CHARGE_METHOD: &str = \"ecommerce_card_payment_only\";\n\n// Card Gateway API Transaction Request\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(rename_all = \"camel\n\n... [truncated 38008 chars] ...\n\n    pub error_message: Option<String>,\n    pub transaction_type: TransactionType,\n    pub response_code: Option<ResponseCode>,\n    pub ecommerce_card_payment_only_transaction_data: Option<EcommerceCardPaymentOnlyResponseData>,\n    pub refund_balance_data: Option<RefundBalanceData>,\n    pub payment_method: Secret<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct TransactionType {\n    pub value: i32,\n    pub description: String,\n}\n\n// Error Response\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PeachpaymentsErrorResponse {\n    pub error_ref: String,\n    pub message: String,\n}\n\nimpl TryFrom<ErrorResponse> for PeachpaymentsErrorResponse {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(error_response: ErrorResponse) -> Result<Self, Self::Error> {\n        Ok(Self {\n            error_ref: error_response.code,\n            message: error_response.message,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__peachpayments__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__peachpayments__transformers.rs"}, {"query": "PeachPayments webhook handling", "code": "use std::str::FromStr;\n\nuse cards::{CardNumber, NetworkToken};\nuse common_enums::enums as storage_enums;\nuse common_utils::{errors::CustomResult, pii, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, CardWithLimitedDetails, NetworkTokenData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{RefundsData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::OffsetDateTime;\n\nuse crate::{\n    types::ResponseRouterData,\n    utils::{\n        self, CardData, CardWithLimitedData as _, NetworkTokenData as _,\n        RouterData as OtherRouterData,\n    },\n};\n\npub struct PeachpaymentsRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PeachpaymentsRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for PeachPaymentsConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nconst CHARGE_METHOD: &str = \"ecommerce_card_payment_only\";\n\n// Card Gateway API Transaction Request\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(rename_all = \"camel\n\n... [truncated 38008 chars] ...\n\n    pub error_message: Option<String>,\n    pub transaction_type: TransactionType,\n    pub response_code: Option<ResponseCode>,\n    pub ecommerce_card_payment_only_transaction_data: Option<EcommerceCardPaymentOnlyResponseData>,\n    pub refund_balance_data: Option<RefundBalanceData>,\n    pub payment_method: Secret<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct TransactionType {\n    pub value: i32,\n    pub description: String,\n}\n\n// Error Response\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PeachpaymentsErrorResponse {\n    pub error_ref: String,\n    pub message: String,\n}\n\nimpl TryFrom<ErrorResponse> for PeachpaymentsErrorResponse {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(error_response: ErrorResponse) -> Result<Self, Self::Error> {\n        Ok(Self {\n            error_ref: error_response.code,\n            message: error_response.message,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__peachpayments__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__peachpayments__transformers.rs"}, {"query": "how to process PeachPayments refunds", "code": "use std::str::FromStr;\n\nuse cards::{CardNumber, NetworkToken};\nuse common_enums::enums as storage_enums;\nuse common_utils::{errors::CustomResult, pii, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, CardWithLimitedDetails, NetworkTokenData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{RefundsData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::OffsetDateTime;\n\nuse crate::{\n    types::ResponseRouterData,\n    utils::{\n        self, CardData, CardWithLimitedData as _, NetworkTokenData as _,\n        RouterData as OtherRouterData,\n    },\n};\n\npub struct PeachpaymentsRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PeachpaymentsRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for PeachPaymentsConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nconst CHARGE_METHOD: &str = \"ecommerce_card_payment_only\";\n\n// Card Gateway API Transaction Request\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(rename_all = \"camel\n\n... [truncated 38008 chars] ...\n\n    pub error_message: Option<String>,\n    pub transaction_type: TransactionType,\n    pub response_code: Option<ResponseCode>,\n    pub ecommerce_card_payment_only_transaction_data: Option<EcommerceCardPaymentOnlyResponseData>,\n    pub refund_balance_data: Option<RefundBalanceData>,\n    pub payment_method: Secret<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct TransactionType {\n    pub value: i32,\n    pub description: String,\n}\n\n// Error Response\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PeachpaymentsErrorResponse {\n    pub error_ref: String,\n    pub message: String,\n}\n\nimpl TryFrom<ErrorResponse> for PeachpaymentsErrorResponse {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(error_response: ErrorResponse) -> Result<Self, Self::Error> {\n        Ok(Self {\n            error_ref: error_response.code,\n            message: error_response.message,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__peachpayments__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__peachpayments__transformers.rs"}, {"query": "PeachPayments card payment API mapping", "code": "use std::str::FromStr;\n\nuse cards::{CardNumber, NetworkToken};\nuse common_enums::enums as storage_enums;\nuse common_utils::{errors::CustomResult, pii, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, CardWithLimitedDetails, NetworkTokenData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{RefundsData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::OffsetDateTime;\n\nuse crate::{\n    types::ResponseRouterData,\n    utils::{\n        self, CardData, CardWithLimitedData as _, NetworkTokenData as _,\n        RouterData as OtherRouterData,\n    },\n};\n\npub struct PeachpaymentsRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PeachpaymentsRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for PeachPaymentsConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nconst CHARGE_METHOD: &str = \"ecommerce_card_payment_only\";\n\n// Card Gateway API Transaction Request\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(rename_all = \"camel\n\n... [truncated 38008 chars] ...\n\n    pub error_message: Option<String>,\n    pub transaction_type: TransactionType,\n    pub response_code: Option<ResponseCode>,\n    pub ecommerce_card_payment_only_transaction_data: Option<EcommerceCardPaymentOnlyResponseData>,\n    pub refund_balance_data: Option<RefundBalanceData>,\n    pub payment_method: Secret<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct TransactionType {\n    pub value: i32,\n    pub description: String,\n}\n\n// Error Response\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PeachpaymentsErrorResponse {\n    pub error_ref: String,\n    pub message: String,\n}\n\nimpl TryFrom<ErrorResponse> for PeachpaymentsErrorResponse {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(error_response: ErrorResponse) -> Result<Self, Self::Error> {\n        Ok(Self {\n            error_ref: error_response.code,\n            message: error_response.message,\n        })\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__peachpayments__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__peachpayments__transformers.rs"}, {"query": "Globepay connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hex::encode;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks,\n};\nuse masking::ExposeInterface;\nuse rand::distributions::DistString;\nuse time::OffsetDateTime;\nuse transformers as globepay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Globepay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Globe\n\n... [truncated 18749 chars] ...\n\n None,\n            },\n        );\n\n        globepay_supported_payment_methods\n    });\n\nstatic GLOBEPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Globepay\",\n        description: \"GlobePay Limited is a professional cross-border payment solution provider (WeChat Pay & Alipay) in the UK\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic GLOBEPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Globepay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GLOBEPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GLOBEPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GLOBEPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "file": "crates__hyperswitch_connectors__src__connectors__globepay.rs"}, {"query": "how to integrate GlobePay with Hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hex::encode;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks,\n};\nuse masking::ExposeInterface;\nuse rand::distributions::DistString;\nuse time::OffsetDateTime;\nuse transformers as globepay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Globepay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Globe\n\n... [truncated 18749 chars] ...\n\n None,\n            },\n        );\n\n        globepay_supported_payment_methods\n    });\n\nstatic GLOBEPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Globepay\",\n        description: \"GlobePay Limited is a professional cross-border payment solution provider (WeChat Pay & Alipay) in the UK\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic GLOBEPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Globepay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GLOBEPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GLOBEPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GLOBEPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "file": "crates__hyperswitch_connectors__src__connectors__globepay.rs"}, {"query": "Globepay authorize payment method", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hex::encode;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks,\n};\nuse masking::ExposeInterface;\nuse rand::distributions::DistString;\nuse time::OffsetDateTime;\nuse transformers as globepay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Globepay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Globe\n\n... [truncated 18749 chars] ...\n\n None,\n            },\n        );\n\n        globepay_supported_payment_methods\n    });\n\nstatic GLOBEPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Globepay\",\n        description: \"GlobePay Limited is a professional cross-border payment solution provider (WeChat Pay & Alipay) in the UK\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic GLOBEPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Globepay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GLOBEPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GLOBEPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GLOBEPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "file": "crates__hyperswitch_connectors__src__connectors__globepay.rs"}, {"query": "Globepay WeChat Pay Alipay integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hex::encode;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks,\n};\nuse masking::ExposeInterface;\nuse rand::distributions::DistString;\nuse time::OffsetDateTime;\nuse transformers as globepay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Globepay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Globe\n\n... [truncated 18749 chars] ...\n\n None,\n            },\n        );\n\n        globepay_supported_payment_methods\n    });\n\nstatic GLOBEPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n        display_name: \"Globepay\",\n        description: \"GlobePay Limited is a professional cross-border payment solution provider (WeChat Pay & Alipay) in the UK\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n    };\n\nstatic GLOBEPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Globepay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&GLOBEPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*GLOBEPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&GLOBEPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "file": "crates__hyperswitch_connectors__src__connectors__globepay.rs"}, {"query": "paysafe payment transformation rust", "code": "use std::collections::HashMap;\n\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_types::payments::{ApplePayPaymentData, ApplePayPredecryptData};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, GiftCardData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentMethodTokenizationData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, missing_field_err, to_connector_meta, BrowserInformationData, CardData,\n        PaymentMethodTokenizationRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as RouterDataUtils,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 36;\n\npub struct PaysafeRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: \n\n... [truncated 82123 chars] ...\n\nponseRouterData<RSync, RefundResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.id.to_string(),\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PaysafeErrorResponse {\n    pub error: Error,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Error {\n    pub code: String,\n    pub message: String,\n    pub details: Option<Vec<String>>,\n    #[serde(rename = \"fieldErrors\")]\n    pub field_errors: Option<Vec<FieldError>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FieldError {\n    pub field: Option<String>,\n    pub error: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs"}, {"query": "PaysafeConnectorMetadataObject struct", "code": "use std::collections::HashMap;\n\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_types::payments::{ApplePayPaymentData, ApplePayPredecryptData};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, GiftCardData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentMethodTokenizationData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, missing_field_err, to_connector_meta, BrowserInformationData, CardData,\n        PaymentMethodTokenizationRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as RouterDataUtils,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 36;\n\npub struct PaysafeRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: \n\n... [truncated 82123 chars] ...\n\nponseRouterData<RSync, RefundResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.id.to_string(),\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PaysafeErrorResponse {\n    pub error: Error,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Error {\n    pub code: String,\n    pub message: String,\n    pub details: Option<Vec<String>>,\n    #[serde(rename = \"fieldErrors\")]\n    pub field_errors: Option<Vec<FieldError>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FieldError {\n    pub field: Option<String>,\n    pub error: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs"}, {"query": "how to implement paysafe refund response", "code": "use std::collections::HashMap;\n\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_types::payments::{ApplePayPaymentData, ApplePayPredecryptData};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, GiftCardData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentMethodTokenizationData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, missing_field_err, to_connector_meta, BrowserInformationData, CardData,\n        PaymentMethodTokenizationRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as RouterDataUtils,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 36;\n\npub struct PaysafeRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: \n\n... [truncated 82123 chars] ...\n\nponseRouterData<RSync, RefundResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.id.to_string(),\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PaysafeErrorResponse {\n    pub error: Error,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Error {\n    pub code: String,\n    pub message: String,\n    pub details: Option<Vec<String>>,\n    #[serde(rename = \"fieldErrors\")]\n    pub field_errors: Option<Vec<FieldError>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FieldError {\n    pub field: Option<String>,\n    pub error: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs"}, {"query": "paysafe payment method serialization", "code": "use std::collections::HashMap;\n\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_types::payments::{ApplePayPaymentData, ApplePayPredecryptData};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, GiftCardData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentMethodTokenizationData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, missing_field_err, to_connector_meta, BrowserInformationData, CardData,\n        PaymentMethodTokenizationRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as RouterDataUtils,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 36;\n\npub struct PaysafeRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: \n\n... [truncated 82123 chars] ...\n\nponseRouterData<RSync, RefundResponse>> for RefundsRouterData<RSync> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: RefundsResponseRouterData<RSync, RefundResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(RefundsResponseData {\n                connector_refund_id: item.response.id.to_string(),\n                refund_status: enums::RefundStatus::from(item.response.status),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PaysafeErrorResponse {\n    pub error: Error,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Error {\n    pub code: String,\n    pub message: String,\n    pub details: Option<Vec<String>>,\n    #[serde(rename = \"fieldErrors\")]\n    pub field_errors: Option<Vec<FieldError>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FieldError {\n    pub field: Option<String>,\n    pub error: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs"}, {"query": "how does payment authorization flow work", "code": "use std::str::FromStr;\n\nuse async_trait::async_trait;\nuse common_enums as enums;\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::MinorUnit;\nuse common_utils::{errors, ext_traits::ValueExt, id_type, ucs_types};\nuse error_stack::ResultExt;\nuse external_services::grpc_client;\nuse hyperswitch_connectors::constants as connector_consts;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::PaymentConfirmData;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments as domain_payments, router_data,\n    router_data_v2::{flow_common_types, PaymentFlowData},\n    router_flow_types, router_request_types, router_response_types,\n};\nuse hyperswitch_interfaces::{\n    api::{self as api_interface, gateway, ConnectorSpecifications},\n    consts as interface_consts, errors as interface_errors,\n    unified_connector_service::transformers as ucs_transformers,\n};\nuse masking::ExposeInterface;\nuse unified_connector_service_client::payments as payments_grpc;\nuse unified_connector_service_masking::ExposeInterface as UcsMaskingExposeInterface;\n\n// use router_env::tracing::Instrument;\nuse super::{ConstructFlowSpecificData, Feature};\n#[cfg(feature = \"v2\")]\nuse crate::core::unified_connector_service::{\n    get_access_token_from_ucs_response,\n    handle_unified_connector_service_response_for_payment_authorize,\n    handle_unified_connector_service_response_for_payment_repeat, set_access_token_for_ucs,\n    ucs_logging_wrapper,\n};\nuse crate::{\n    core::{\n        errors::{ConnectorErrorExt, RouterResult},\n        mandate,\n        payments::{\n            self, access_token, customers, flows::gateway_context, gateway as payments_gateway,\n            helpers, session_token, tokenization, transformers, PaymentData,\n        },\n        unified_connector_service,\n    },\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, api::ConnectorValidation},\n    types::{self, api, domain, transformers::Foreign\n\n... [truncated 59053 chars] ...\n\n)| {\n                router_data.status = status;\n                response\n            });\n            let router_data_response = match router_data_response {\n                Ok(response) => Ok(transform_response_for_pre_authenticate_flow(\n                    connector, response,\n                )?),\n                Err(err) => Err(err),\n            };\n            // Extract authentication_data from the response to store in connector_metadata\n            router_data.response = router_data_response;\n            router_data.raw_connector_response = payment_pre_authenticate_response\n                .raw_connector_response\n                .clone()\n                .map(|raw_connector_response| raw_connector_response.expose().into());\n            router_data.connector_http_status_code = Some(status_code);\n\n            Ok((router_data, (), payment_pre_authenticate_response))\n        },\n    ))\n    .await\n    .change_context(interface_errors::ConnectorError::ResponseHandlingFailed)\n}\n", "function_name": "crates__router__src__core__payments__flows__authorize_flow.rs", "file": "crates__router__src__core__payments__flows__authorize_flow.rs"}, {"query": "AuthorizeFlow struct implementation", "code": "use std::str::FromStr;\n\nuse async_trait::async_trait;\nuse common_enums as enums;\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::MinorUnit;\nuse common_utils::{errors, ext_traits::ValueExt, id_type, ucs_types};\nuse error_stack::ResultExt;\nuse external_services::grpc_client;\nuse hyperswitch_connectors::constants as connector_consts;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::PaymentConfirmData;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments as domain_payments, router_data,\n    router_data_v2::{flow_common_types, PaymentFlowData},\n    router_flow_types, router_request_types, router_response_types,\n};\nuse hyperswitch_interfaces::{\n    api::{self as api_interface, gateway, ConnectorSpecifications},\n    consts as interface_consts, errors as interface_errors,\n    unified_connector_service::transformers as ucs_transformers,\n};\nuse masking::ExposeInterface;\nuse unified_connector_service_client::payments as payments_grpc;\nuse unified_connector_service_masking::ExposeInterface as UcsMaskingExposeInterface;\n\n// use router_env::tracing::Instrument;\nuse super::{ConstructFlowSpecificData, Feature};\n#[cfg(feature = \"v2\")]\nuse crate::core::unified_connector_service::{\n    get_access_token_from_ucs_response,\n    handle_unified_connector_service_response_for_payment_authorize,\n    handle_unified_connector_service_response_for_payment_repeat, set_access_token_for_ucs,\n    ucs_logging_wrapper,\n};\nuse crate::{\n    core::{\n        errors::{ConnectorErrorExt, RouterResult},\n        mandate,\n        payments::{\n            self, access_token, customers, flows::gateway_context, gateway as payments_gateway,\n            helpers, session_token, tokenization, transformers, PaymentData,\n        },\n        unified_connector_service,\n    },\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, api::ConnectorValidation},\n    types::{self, api, domain, transformers::Foreign\n\n... [truncated 59053 chars] ...\n\n)| {\n                router_data.status = status;\n                response\n            });\n            let router_data_response = match router_data_response {\n                Ok(response) => Ok(transform_response_for_pre_authenticate_flow(\n                    connector, response,\n                )?),\n                Err(err) => Err(err),\n            };\n            // Extract authentication_data from the response to store in connector_metadata\n            router_data.response = router_data_response;\n            router_data.raw_connector_response = payment_pre_authenticate_response\n                .raw_connector_response\n                .clone()\n                .map(|raw_connector_response| raw_connector_response.expose().into());\n            router_data.connector_http_status_code = Some(status_code);\n\n            Ok((router_data, (), payment_pre_authenticate_response))\n        },\n    ))\n    .await\n    .change_context(interface_errors::ConnectorError::ResponseHandlingFailed)\n}\n", "function_name": "crates__router__src__core__payments__flows__authorize_flow.rs", "file": "crates__router__src__core__payments__flows__authorize_flow.rs"}, {"query": "how to implement payment authorization", "code": "use std::str::FromStr;\n\nuse async_trait::async_trait;\nuse common_enums as enums;\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::MinorUnit;\nuse common_utils::{errors, ext_traits::ValueExt, id_type, ucs_types};\nuse error_stack::ResultExt;\nuse external_services::grpc_client;\nuse hyperswitch_connectors::constants as connector_consts;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::PaymentConfirmData;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments as domain_payments, router_data,\n    router_data_v2::{flow_common_types, PaymentFlowData},\n    router_flow_types, router_request_types, router_response_types,\n};\nuse hyperswitch_interfaces::{\n    api::{self as api_interface, gateway, ConnectorSpecifications},\n    consts as interface_consts, errors as interface_errors,\n    unified_connector_service::transformers as ucs_transformers,\n};\nuse masking::ExposeInterface;\nuse unified_connector_service_client::payments as payments_grpc;\nuse unified_connector_service_masking::ExposeInterface as UcsMaskingExposeInterface;\n\n// use router_env::tracing::Instrument;\nuse super::{ConstructFlowSpecificData, Feature};\n#[cfg(feature = \"v2\")]\nuse crate::core::unified_connector_service::{\n    get_access_token_from_ucs_response,\n    handle_unified_connector_service_response_for_payment_authorize,\n    handle_unified_connector_service_response_for_payment_repeat, set_access_token_for_ucs,\n    ucs_logging_wrapper,\n};\nuse crate::{\n    core::{\n        errors::{ConnectorErrorExt, RouterResult},\n        mandate,\n        payments::{\n            self, access_token, customers, flows::gateway_context, gateway as payments_gateway,\n            helpers, session_token, tokenization, transformers, PaymentData,\n        },\n        unified_connector_service,\n    },\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, api::ConnectorValidation},\n    types::{self, api, domain, transformers::Foreign\n\n... [truncated 59053 chars] ...\n\n)| {\n                router_data.status = status;\n                response\n            });\n            let router_data_response = match router_data_response {\n                Ok(response) => Ok(transform_response_for_pre_authenticate_flow(\n                    connector, response,\n                )?),\n                Err(err) => Err(err),\n            };\n            // Extract authentication_data from the response to store in connector_metadata\n            router_data.response = router_data_response;\n            router_data.raw_connector_response = payment_pre_authenticate_response\n                .raw_connector_response\n                .clone()\n                .map(|raw_connector_response| raw_connector_response.expose().into());\n            router_data.connector_http_status_code = Some(status_code);\n\n            Ok((router_data, (), payment_pre_authenticate_response))\n        },\n    ))\n    .await\n    .change_context(interface_errors::ConnectorError::ResponseHandlingFailed)\n}\n", "function_name": "crates__router__src__core__payments__flows__authorize_flow.rs", "file": "crates__router__src__core__payments__flows__authorize_flow.rs"}, {"query": "unified connector service authorization", "code": "use std::str::FromStr;\n\nuse async_trait::async_trait;\nuse common_enums as enums;\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::MinorUnit;\nuse common_utils::{errors, ext_traits::ValueExt, id_type, ucs_types};\nuse error_stack::ResultExt;\nuse external_services::grpc_client;\nuse hyperswitch_connectors::constants as connector_consts;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::PaymentConfirmData;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments as domain_payments, router_data,\n    router_data_v2::{flow_common_types, PaymentFlowData},\n    router_flow_types, router_request_types, router_response_types,\n};\nuse hyperswitch_interfaces::{\n    api::{self as api_interface, gateway, ConnectorSpecifications},\n    consts as interface_consts, errors as interface_errors,\n    unified_connector_service::transformers as ucs_transformers,\n};\nuse masking::ExposeInterface;\nuse unified_connector_service_client::payments as payments_grpc;\nuse unified_connector_service_masking::ExposeInterface as UcsMaskingExposeInterface;\n\n// use router_env::tracing::Instrument;\nuse super::{ConstructFlowSpecificData, Feature};\n#[cfg(feature = \"v2\")]\nuse crate::core::unified_connector_service::{\n    get_access_token_from_ucs_response,\n    handle_unified_connector_service_response_for_payment_authorize,\n    handle_unified_connector_service_response_for_payment_repeat, set_access_token_for_ucs,\n    ucs_logging_wrapper,\n};\nuse crate::{\n    core::{\n        errors::{ConnectorErrorExt, RouterResult},\n        mandate,\n        payments::{\n            self, access_token, customers, flows::gateway_context, gateway as payments_gateway,\n            helpers, session_token, tokenization, transformers, PaymentData,\n        },\n        unified_connector_service,\n    },\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, api::ConnectorValidation},\n    types::{self, api, domain, transformers::Foreign\n\n... [truncated 59053 chars] ...\n\n)| {\n                router_data.status = status;\n                response\n            });\n            let router_data_response = match router_data_response {\n                Ok(response) => Ok(transform_response_for_pre_authenticate_flow(\n                    connector, response,\n                )?),\n                Err(err) => Err(err),\n            };\n            // Extract authentication_data from the response to store in connector_metadata\n            router_data.response = router_data_response;\n            router_data.raw_connector_response = payment_pre_authenticate_response\n                .raw_connector_response\n                .clone()\n                .map(|raw_connector_response| raw_connector_response.expose().into());\n            router_data.connector_http_status_code = Some(status_code);\n\n            Ok((router_data, (), payment_pre_authenticate_response))\n        },\n    ))\n    .await\n    .change_context(interface_errors::ConnectorError::ResponseHandlingFailed)\n}\n", "function_name": "crates__router__src__core__payments__flows__authorize_flow.rs", "file": "crates__router__src__core__payments__flows__authorize_flow.rs"}, {"query": "Paytm payment gateway integration hyperswitch", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as paytm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Paytm {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Paytm {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paytm {}\nimpl api::Paym\n\n... [truncated 19552 chars] ...\n\nnational fintech company specializing in digital payments and financial services. Initially known for its mobile wallet, it has expanded to include a payment bank, e-commerce, ticketing, and wealth management services.\",\n            connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\n    static ref PAYTM_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Paytm {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*PAYTM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYTM_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*PAYTM_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn is_authorize_session_token_call_required(&self) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paytm.rs", "file": "crates__hyperswitch_connectors__src__connectors__paytm.rs"}, {"query": "Paytm struct implementation hyperswitch", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as paytm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Paytm {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Paytm {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paytm {}\nimpl api::Paym\n\n... [truncated 19552 chars] ...\n\nnational fintech company specializing in digital payments and financial services. Initially known for its mobile wallet, it has expanded to include a payment bank, e-commerce, ticketing, and wealth management services.\",\n            connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\n    static ref PAYTM_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Paytm {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*PAYTM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYTM_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*PAYTM_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn is_authorize_session_token_call_required(&self) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paytm.rs", "file": "crates__hyperswitch_connectors__src__connectors__paytm.rs"}, {"query": "how to add new payment gateway connector hyperswitch", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as paytm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Paytm {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Paytm {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paytm {}\nimpl api::Paym\n\n... [truncated 19552 chars] ...\n\nnational fintech company specializing in digital payments and financial services. Initially known for its mobile wallet, it has expanded to include a payment bank, e-commerce, ticketing, and wealth management services.\",\n            connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\n    static ref PAYTM_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Paytm {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*PAYTM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYTM_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*PAYTM_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn is_authorize_session_token_call_required(&self) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paytm.rs", "file": "crates__hyperswitch_connectors__src__connectors__paytm.rs"}, {"query": "hyperswitch paytm authorization capture", "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as paytm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Paytm {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Paytm {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paytm {}\nimpl api::Paym\n\n... [truncated 19552 chars] ...\n\nnational fintech company specializing in digital payments and financial services. Initially known for its mobile wallet, it has expanded to include a payment bank, e-commerce, ticketing, and wealth management services.\",\n            connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Alpha,\n    };\n\n    static ref PAYTM_SUPPORTED_WEBHOOK_FLOWS: Vec<enums::EventClass> = Vec::new();\n\n}\n\nimpl ConnectorSpecifications for Paytm {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&*PAYTM_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYTM_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&*PAYTM_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn is_authorize_session_token_call_required(&self) -> bool {\n        true\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paytm.rs", "file": "crates__hyperswitch_connectors__src__connectors__paytm.rs"}, {"query": "merchant connector account storage implementation", "code": "use async_bb8_diesel::AsyncConnection;\nuse common_utils::{encryption::Encryption, ext_traits::AsyncExt};\nuse diesel_models::merchant_connector_account as storage;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_connector_account::{self as domain, MerchantConnectorAccountInterface},\n    merchant_key_store::MerchantKeyStore,\n};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"accounts_cache\")]\nuse crate::redis::cache;\nuse crate::{\n    kv_router_store,\n    utils::{pg_accounts_connection_read, pg_accounts_connection_write},\n    CustomResult, DatabaseStore, MockDb, RouterStore, StorageError,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> MerchantConnectorAccountInterface for kv_router_store::KVRouterStore<T> {\n    type Error = StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"\n\n... [truncated 54104 chars] ...\n\n                return Ok(true);\n            }\n            None => {\n                return Err(StorageError::ValueNotFound(\n                    \"cannot find merchant connector account to delete\".to_string(),\n                )\n                .into())\n            }\n        }\n    }\n\n    #[cfg(feature = \"v2\")]\n    async fn delete_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, StorageError> {\n        let mut accounts = self.merchant_connector_accounts.lock().await;\n        match accounts.iter().position(|account| account.get_id() == *id) {\n            Some(index) => {\n                accounts.remove(index);\n                return Ok(true);\n            }\n            None => {\n                return Err(StorageError::ValueNotFound(\n                    \"cannot find merchant connector account to delete\".to_string(),\n                )\n                .into())\n            }\n        }\n    }\n}\n", "function_name": "crates__storage_impl__src__merchant_connector_account.rs", "file": "crates__storage_impl__src__merchant_connector_account.rs"}, {"query": "how to find merchant connector account by id", "code": "use async_bb8_diesel::AsyncConnection;\nuse common_utils::{encryption::Encryption, ext_traits::AsyncExt};\nuse diesel_models::merchant_connector_account as storage;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_connector_account::{self as domain, MerchantConnectorAccountInterface},\n    merchant_key_store::MerchantKeyStore,\n};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"accounts_cache\")]\nuse crate::redis::cache;\nuse crate::{\n    kv_router_store,\n    utils::{pg_accounts_connection_read, pg_accounts_connection_write},\n    CustomResult, DatabaseStore, MockDb, RouterStore, StorageError,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> MerchantConnectorAccountInterface for kv_router_store::KVRouterStore<T> {\n    type Error = StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"\n\n... [truncated 54104 chars] ...\n\n                return Ok(true);\n            }\n            None => {\n                return Err(StorageError::ValueNotFound(\n                    \"cannot find merchant connector account to delete\".to_string(),\n                )\n                .into())\n            }\n        }\n    }\n\n    #[cfg(feature = \"v2\")]\n    async fn delete_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, StorageError> {\n        let mut accounts = self.merchant_connector_accounts.lock().await;\n        match accounts.iter().position(|account| account.get_id() == *id) {\n            Some(index) => {\n                accounts.remove(index);\n                return Ok(true);\n            }\n            None => {\n                return Err(StorageError::ValueNotFound(\n                    \"cannot find merchant connector account to delete\".to_string(),\n                )\n                .into())\n            }\n        }\n    }\n}\n", "function_name": "crates__storage_impl__src__merchant_connector_account.rs", "file": "crates__storage_impl__src__merchant_connector_account.rs"}, {"query": "implement storage trait for merchant accounts", "code": "use async_bb8_diesel::AsyncConnection;\nuse common_utils::{encryption::Encryption, ext_traits::AsyncExt};\nuse diesel_models::merchant_connector_account as storage;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_connector_account::{self as domain, MerchantConnectorAccountInterface},\n    merchant_key_store::MerchantKeyStore,\n};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"accounts_cache\")]\nuse crate::redis::cache;\nuse crate::{\n    kv_router_store,\n    utils::{pg_accounts_connection_read, pg_accounts_connection_write},\n    CustomResult, DatabaseStore, MockDb, RouterStore, StorageError,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> MerchantConnectorAccountInterface for kv_router_store::KVRouterStore<T> {\n    type Error = StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"\n\n... [truncated 54104 chars] ...\n\n                return Ok(true);\n            }\n            None => {\n                return Err(StorageError::ValueNotFound(\n                    \"cannot find merchant connector account to delete\".to_string(),\n                )\n                .into())\n            }\n        }\n    }\n\n    #[cfg(feature = \"v2\")]\n    async fn delete_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, StorageError> {\n        let mut accounts = self.merchant_connector_accounts.lock().await;\n        match accounts.iter().position(|account| account.get_id() == *id) {\n            Some(index) => {\n                accounts.remove(index);\n                return Ok(true);\n            }\n            None => {\n                return Err(StorageError::ValueNotFound(\n                    \"cannot find merchant connector account to delete\".to_string(),\n                )\n                .into())\n            }\n        }\n    }\n}\n", "function_name": "crates__storage_impl__src__merchant_connector_account.rs", "file": "crates__storage_impl__src__merchant_connector_account.rs"}, {"query": "hyperswitch merchant connector account database", "code": "use async_bb8_diesel::AsyncConnection;\nuse common_utils::{encryption::Encryption, ext_traits::AsyncExt};\nuse diesel_models::merchant_connector_account as storage;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_connector_account::{self as domain, MerchantConnectorAccountInterface},\n    merchant_key_store::MerchantKeyStore,\n};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"accounts_cache\")]\nuse crate::redis::cache;\nuse crate::{\n    kv_router_store,\n    utils::{pg_accounts_connection_read, pg_accounts_connection_write},\n    CustomResult, DatabaseStore, MockDb, RouterStore, StorageError,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> MerchantConnectorAccountInterface for kv_router_store::KVRouterStore<T> {\n    type Error = StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"\n\n... [truncated 54104 chars] ...\n\n                return Ok(true);\n            }\n            None => {\n                return Err(StorageError::ValueNotFound(\n                    \"cannot find merchant connector account to delete\".to_string(),\n                )\n                .into())\n            }\n        }\n    }\n\n    #[cfg(feature = \"v2\")]\n    async fn delete_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n    ) -> CustomResult<bool, StorageError> {\n        let mut accounts = self.merchant_connector_accounts.lock().await;\n        match accounts.iter().position(|account| account.get_id() == *id) {\n            Some(index) => {\n                accounts.remove(index);\n                return Ok(true);\n            }\n            None => {\n                return Err(StorageError::ValueNotFound(\n                    \"cannot find merchant connector account to delete\".to_string(),\n                )\n                .into())\n            }\n        }\n    }\n}\n", "function_name": "crates__storage_impl__src__merchant_connector_account.rs", "file": "crates__storage_impl__src__merchant_connector_account.rs"}, {"query": "PlacetoPay payment gateway integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse transformers as placetopay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Placetopay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Placetopay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amoun\n\n... [truncated 23086 chars] ...\n\nay_supported_payment_methods\n    });\n\nstatic PLACETOPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"PlacetoPay\",\n    description:\n        \"PlacetoPay is a Latin American financial technology company's online payment platform, offering various payment methods and integrations for businesses\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PLACETOPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Placetopay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PLACETOPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PLACETOPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PLACETOPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__placetopay.rs", "file": "crates__hyperswitch_connectors__src__connectors__placetopay.rs"}, {"query": "Placetopay connector implementation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse transformers as placetopay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Placetopay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Placetopay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amoun\n\n... [truncated 23086 chars] ...\n\nay_supported_payment_methods\n    });\n\nstatic PLACETOPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"PlacetoPay\",\n    description:\n        \"PlacetoPay is a Latin American financial technology company's online payment platform, offering various payment methods and integrations for businesses\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PLACETOPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Placetopay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PLACETOPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PLACETOPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PLACETOPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__placetopay.rs", "file": "crates__hyperswitch_connectors__src__connectors__placetopay.rs"}, {"query": "how to implement payment gateway connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse transformers as placetopay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Placetopay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Placetopay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amoun\n\n... [truncated 23086 chars] ...\n\nay_supported_payment_methods\n    });\n\nstatic PLACETOPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"PlacetoPay\",\n    description:\n        \"PlacetoPay is a Latin American financial technology company's online payment platform, offering various payment methods and integrations for businesses\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PLACETOPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Placetopay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PLACETOPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PLACETOPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PLACETOPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__placetopay.rs", "file": "crates__hyperswitch_connectors__src__connectors__placetopay.rs"}, {"query": "PlacetoPay supported payment methods", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse transformers as placetopay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Placetopay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Placetopay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amoun\n\n... [truncated 23086 chars] ...\n\nay_supported_payment_methods\n    });\n\nstatic PLACETOPAY_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"PlacetoPay\",\n    description:\n        \"PlacetoPay is a Latin American financial technology company's online payment platform, offering various payment methods and integrations for businesses\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic PLACETOPAY_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Placetopay {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PLACETOPAY_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PLACETOPAY_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PLACETOPAY_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__placetopay.rs", "file": "crates__hyperswitch_connectors__src__connectors__placetopay.rs"}, {"query": "Checkout.com payment gateway integration", "code": "pub mod transformers;\nuse std::{convert::TryFrom, sync::LazyLock};\n\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Accept, Defend, Evidence, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DefendDisputeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        RetrieveFileRequestData, SetupMandateRequestData, SubmitEvidenceRequestData,\n        SyncRequestType, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DefendDisputeResponse, PaymentMethodDetails,\n        PaymentsResponseData, RefundsResponseData, RetrieveFileResponse, SubmitEvidenceResponse,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, DefendDispute, Dispute, SubmitEvidence},\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        CaptureSync\n\n... [truncated 61607 chars] ...\n\n: ConnectorInfo = ConnectorInfo {\n        display_name: \"Checkout\",\n        description:\n            \"Checkout.com is a British multinational financial technology company that processes payments for other companies.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic CHECKOUT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Checkout {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHECKOUT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CHECKOUT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHECKOUT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkout.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkout.rs"}, {"query": "Checkout connector authorize capture methods", "code": "pub mod transformers;\nuse std::{convert::TryFrom, sync::LazyLock};\n\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Accept, Defend, Evidence, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DefendDisputeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        RetrieveFileRequestData, SetupMandateRequestData, SubmitEvidenceRequestData,\n        SyncRequestType, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DefendDisputeResponse, PaymentMethodDetails,\n        PaymentsResponseData, RefundsResponseData, RetrieveFileResponse, SubmitEvidenceResponse,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, DefendDispute, Dispute, SubmitEvidence},\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        CaptureSync\n\n... [truncated 61607 chars] ...\n\n: ConnectorInfo = ConnectorInfo {\n        display_name: \"Checkout\",\n        description:\n            \"Checkout.com is a British multinational financial technology company that processes payments for other companies.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic CHECKOUT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Checkout {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHECKOUT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CHECKOUT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHECKOUT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkout.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkout.rs"}, {"query": "how to implement payment gateway connector", "code": "pub mod transformers;\nuse std::{convert::TryFrom, sync::LazyLock};\n\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Accept, Defend, Evidence, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DefendDisputeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        RetrieveFileRequestData, SetupMandateRequestData, SubmitEvidenceRequestData,\n        SyncRequestType, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DefendDisputeResponse, PaymentMethodDetails,\n        PaymentsResponseData, RefundsResponseData, RetrieveFileResponse, SubmitEvidenceResponse,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, DefendDispute, Dispute, SubmitEvidence},\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        CaptureSync\n\n... [truncated 61607 chars] ...\n\n: ConnectorInfo = ConnectorInfo {\n        display_name: \"Checkout\",\n        description:\n            \"Checkout.com is a British multinational financial technology company that processes payments for other companies.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic CHECKOUT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Checkout {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHECKOUT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CHECKOUT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHECKOUT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkout.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkout.rs"}, {"query": "hyperswitch checkout connector refund sync", "code": "pub mod transformers;\nuse std::{convert::TryFrom, sync::LazyLock};\n\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Accept, Defend, Evidence, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DefendDisputeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        RetrieveFileRequestData, SetupMandateRequestData, SubmitEvidenceRequestData,\n        SyncRequestType, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DefendDisputeResponse, PaymentMethodDetails,\n        PaymentsResponseData, RefundsResponseData, RetrieveFileResponse, SubmitEvidenceResponse,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, DefendDispute, Dispute, SubmitEvidence},\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        CaptureSync\n\n... [truncated 61607 chars] ...\n\n: ConnectorInfo = ConnectorInfo {\n        display_name: \"Checkout\",\n        description:\n            \"Checkout.com is a British multinational financial technology company that processes payments for other companies.\",\n        connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n        integration_status: enums::ConnectorIntegrationStatus::Live,\n    };\n\nstatic CHECKOUT_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 3] = [\n    enums::EventClass::Payments,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Checkout {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&CHECKOUT_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*CHECKOUT_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&CHECKOUT_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__checkout.rs", "file": "crates__hyperswitch_connectors__src__connectors__checkout.rs"}, {"query": "Zen payment gateway integration", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{OptionExt, ValueExt},\n    pii::{self},\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, BankTransferData, Card, CardRedirectData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{BrowserInformation, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    api,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ZenRouterData<T> {\n    pub amount: String,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ZenRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_string(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n// Auth Struct\npub struct ZenAuthType {\n    pub(super) api_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ZenAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n \n\n... [truncated 41170 chars] ...\n\nture {\n    pub hash: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZenWebhookObjectReference {\n    #[serde(rename = \"type\")]\n    pub transaction_type: ZenWebhookTxnType,\n    pub transaction_id: String,\n    pub merchant_transaction_id: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZenWebhookEventType {\n    #[serde(rename = \"type\")]\n    pub transaction_type: ZenWebhookTxnType,\n    pub transaction_id: String,\n    pub status: ZenPaymentStatus,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ZenWebhookTxnType {\n    TrtPurchase,\n    TrtRefund,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ZenErrorResponse {\n    pub error: Option<ZenErrorBody>,\n    pub message: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Clone, Serialize)]\npub struct ZenErrorBody {\n    pub message: String,\n    pub code: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zen__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__zen__transformers.rs"}, {"query": "ZenAuthType struct definition", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{OptionExt, ValueExt},\n    pii::{self},\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, BankTransferData, Card, CardRedirectData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{BrowserInformation, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    api,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ZenRouterData<T> {\n    pub amount: String,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ZenRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_string(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n// Auth Struct\npub struct ZenAuthType {\n    pub(super) api_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ZenAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n \n\n... [truncated 41170 chars] ...\n\nture {\n    pub hash: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZenWebhookObjectReference {\n    #[serde(rename = \"type\")]\n    pub transaction_type: ZenWebhookTxnType,\n    pub transaction_id: String,\n    pub merchant_transaction_id: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZenWebhookEventType {\n    #[serde(rename = \"type\")]\n    pub transaction_type: ZenWebhookTxnType,\n    pub transaction_id: String,\n    pub status: ZenPaymentStatus,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ZenWebhookTxnType {\n    TrtPurchase,\n    TrtRefund,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ZenErrorResponse {\n    pub error: Option<ZenErrorBody>,\n    pub message: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Clone, Serialize)]\npub struct ZenErrorBody {\n    pub message: String,\n    pub code: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zen__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__zen__transformers.rs"}, {"query": "how to implement Zen payment connector", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{OptionExt, ValueExt},\n    pii::{self},\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, BankTransferData, Card, CardRedirectData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{BrowserInformation, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    api,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ZenRouterData<T> {\n    pub amount: String,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ZenRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_string(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n// Auth Struct\npub struct ZenAuthType {\n    pub(super) api_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ZenAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n \n\n... [truncated 41170 chars] ...\n\nture {\n    pub hash: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZenWebhookObjectReference {\n    #[serde(rename = \"type\")]\n    pub transaction_type: ZenWebhookTxnType,\n    pub transaction_id: String,\n    pub merchant_transaction_id: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZenWebhookEventType {\n    #[serde(rename = \"type\")]\n    pub transaction_type: ZenWebhookTxnType,\n    pub transaction_id: String,\n    pub status: ZenPaymentStatus,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ZenWebhookTxnType {\n    TrtPurchase,\n    TrtRefund,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ZenErrorResponse {\n    pub error: Option<ZenErrorBody>,\n    pub message: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Clone, Serialize)]\npub struct ZenErrorBody {\n    pub message: String,\n    pub code: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zen__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__zen__transformers.rs"}, {"query": "Zen webhook handling refunds", "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{OptionExt, ValueExt},\n    pii::{self},\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, BankTransferData, Card, CardRedirectData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{BrowserInformation, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    api,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ZenRouterData<T> {\n    pub amount: String,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ZenRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_string(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n// Auth Struct\npub struct ZenAuthType {\n    pub(super) api_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ZenAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n \n\n... [truncated 41170 chars] ...\n\nture {\n    pub hash: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZenWebhookObjectReference {\n    #[serde(rename = \"type\")]\n    pub transaction_type: ZenWebhookTxnType,\n    pub transaction_id: String,\n    pub merchant_transaction_id: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ZenWebhookEventType {\n    #[serde(rename = \"type\")]\n    pub transaction_type: ZenWebhookTxnType,\n    pub transaction_id: String,\n    pub status: ZenPaymentStatus,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ZenWebhookTxnType {\n    TrtPurchase,\n    TrtRefund,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ZenErrorResponse {\n    pub error: Option<ZenErrorBody>,\n    pub message: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Clone, Serialize)]\npub struct ZenErrorBody {\n    pub message: String,\n    pub code: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__zen__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__zen__transformers.rs"}, {"query": "Thunes connector implementation", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as thunes;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Thunes {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Thunes {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Thunes {}\nimpl api::PaymentSession for Thunes {}\nimpl api::ConnectorAccessToken for Thunes {}\nimpl api::MandateSetup for Thunes {}\nimpl api\n\n... [truncated 17714 chars] ...\n\nSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic THUNES_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Thunes\",\n    description: \"Thunes Payouts is a global payment solution that enables businesses to send instant, secure, and cost-effective cross-border payments to bank accounts, mobile wallets, and cards in over 130 countries using a single API\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Thunes {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&THUNES_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "file": "crates__hyperswitch_connectors__src__connectors__thunes.rs"}, {"query": "how to integrate Thunes payments", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as thunes;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Thunes {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Thunes {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Thunes {}\nimpl api::PaymentSession for Thunes {}\nimpl api::ConnectorAccessToken for Thunes {}\nimpl api::MandateSetup for Thunes {}\nimpl api\n\n... [truncated 17714 chars] ...\n\nSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic THUNES_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Thunes\",\n    description: \"Thunes Payouts is a global payment solution that enables businesses to send instant, secure, and cost-effective cross-border payments to bank accounts, mobile wallets, and cards in over 130 countries using a single API\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Thunes {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&THUNES_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "file": "crates__hyperswitch_connectors__src__connectors__thunes.rs"}, {"query": "hyperswitch payout connector", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as thunes;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Thunes {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Thunes {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Thunes {}\nimpl api::PaymentSession for Thunes {}\nimpl api::ConnectorAccessToken for Thunes {}\nimpl api::MandateSetup for Thunes {}\nimpl api\n\n... [truncated 17714 chars] ...\n\nSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic THUNES_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Thunes\",\n    description: \"Thunes Payouts is a global payment solution that enables businesses to send instant, secure, and cost-effective cross-border payments to bank accounts, mobile wallets, and cards in over 130 countries using a single API\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Thunes {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&THUNES_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "file": "crates__hyperswitch_connectors__src__connectors__thunes.rs"}, {"query": "thunes payment method tokenization", "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as thunes;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Thunes {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Thunes {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Thunes {}\nimpl api::PaymentSession for Thunes {}\nimpl api::ConnectorAccessToken for Thunes {}\nimpl api::MandateSetup for Thunes {}\nimpl api\n\n... [truncated 17714 chars] ...\n\nSerialize>, errors::ConnectorError> {\n        Err(report!(errors::ConnectorError::WebhooksNotImplemented))\n    }\n}\n\nstatic THUNES_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Thunes\",\n    description: \"Thunes Payouts is a global payment solution that enables businesses to send instant, secure, and cost-effective cross-border payments to bank accounts, mobile wallets, and cards in over 130 countries using a single API\",\n    connector_type: common_enums::HyperswitchConnectorCategory::PayoutProcessor,\n    integration_status: common_enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nimpl ConnectorSpecifications for Thunes {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&THUNES_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::enums::EventClass]> {\n        None\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "file": "crates__hyperswitch_connectors__src__connectors__thunes.rs"}, {"query": "NMI payment gateway integration", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        unified_authentication_service::PreAuthenticate, AccessTokenAuth, Authorize, Capture,\n        CompleteAuthorize, Execute, PSync, PaymentMethodToken, PreProcessing, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        P\n\n... [truncated 40588 chars] ...\n\n;\n\nimpl ConnectorSpecifications for Nmi {\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type,\n                request_data,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate {\n                auth_type,\n                request_data,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NMI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NMI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&NMI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nmi.rs", "file": "crates__hyperswitch_connectors__src__connectors__nmi.rs"}, {"query": "hyperswitch Nmi struct", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        unified_authentication_service::PreAuthenticate, AccessTokenAuth, Authorize, Capture,\n        CompleteAuthorize, Execute, PSync, PaymentMethodToken, PreProcessing, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        P\n\n... [truncated 40588 chars] ...\n\n;\n\nimpl ConnectorSpecifications for Nmi {\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type,\n                request_data,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate {\n                auth_type,\n                request_data,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NMI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NMI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&NMI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nmi.rs", "file": "crates__hyperswitch_connectors__src__connectors__nmi.rs"}, {"query": "how to implement NMI connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        unified_authentication_service::PreAuthenticate, AccessTokenAuth, Authorize, Capture,\n        CompleteAuthorize, Execute, PSync, PaymentMethodToken, PreProcessing, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        P\n\n... [truncated 40588 chars] ...\n\n;\n\nimpl ConnectorSpecifications for Nmi {\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type,\n                request_data,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate {\n                auth_type,\n                request_data,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NMI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NMI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&NMI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nmi.rs", "file": "crates__hyperswitch_connectors__src__connectors__nmi.rs"}, {"query": "hyperswitch payment capture NMI", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        unified_authentication_service::PreAuthenticate, AccessTokenAuth, Authorize, Capture,\n        CompleteAuthorize, Execute, PSync, PaymentMethodToken, PreProcessing, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        P\n\n... [truncated 40588 chars] ...\n\n;\n\nimpl ConnectorSpecifications for Nmi {\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                auth_type,\n                request_data,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n            api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n            api::CurrentFlowInfo::SetupMandate {\n                auth_type,\n                request_data,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&NMI_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*NMI_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&NMI_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__nmi.rs", "file": "crates__hyperswitch_connectors__src__connectors__nmi.rs"}, {"query": "hyperswitch payout request structure", "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::BrowserInformation;\nuse common_utils::{\n    consts::default_payouts_list_limit,\n    crypto, id_type, link_utils, payout_method_utils,\n    pii::{self, Email},\n    transformers::ForeignFrom,\n    types::{UnifiedCode, UnifiedMessage},\n};\nuse masking::Secret;\n#[cfg(feature = \"v1\")]\nuse payments::BrowserInformation;\nuse router_derive::FlatStruct;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{admin, enums as api_enums, payment_methods::RequiredFieldInfo, payments};\n\n#[derive(Debug, Serialize, Clone, ToSchema)]\npub enum PayoutRequest {\n    PayoutActionRequest(PayoutActionRequest),\n    PayoutCreateRequest(Box<PayoutCreateRequest>),\n    PayoutRetrieveRequest(PayoutRetrieveRequest),\n}\n\n#[derive(\n    Default, Debug, Deserialize, Serialize, Clone, ToSchema, router_derive::PolymorphicSchema,\n)]\n#[generate_schemas(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n#[serde(deny_unknown_fields)]\npub struct PayoutCreateRequest {\n    /// Unique identifier for the payout. This ensures idempotency for multiple payouts that have been done by a single merchant. This field is auto generated and is returned in the API response, **not required to be included in the Payout Create/Update Request.**\n    #[schema(\n        value_type = Option<String>,\n        min_length = 30,\n        max_length = 30,\n        example = \"187282ab-40ef-47a9-9206-5099ba31e432\"\n    )]\n    #[remove_in(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n    pub payout_id: Option<id_type::PayoutId>,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key provided during the request, **not required to be included in the Payout Create/Update Request.**\n    #[schema(max_length = 255, value_type = Option<String>, example = \"merchant_1668273825\")]\n    #[remove_in(PayoutsCreateRequest, Pa\n\n... [truncated 46680 chars] ...\n\nate_parameter_present(&self) -> bool {\n        self.status.is_some()\n            || self.error_code.is_some()\n            || self.error_message.is_some()\n            || self.connector_payout_id.is_some()\n    }\n}\n\n#[derive(Debug, serde::Serialize, Clone, ToSchema)]\npub struct PayoutsManualUpdateResponse {\n    /// The identifier for the payout\n    #[schema(value_type = String)]\n    pub payout_id: id_type::PayoutId,\n    /// The identifier for the payout attempt\n    pub payout_attempt_id: String,\n    /// Merchant ID\n    #[schema(value_type = String)]\n    pub merchant_id: id_type::MerchantId,\n    /// The status of the payout attempt\n    #[schema(value_type = PayoutStatus)]\n    pub attempt_status: api_enums::PayoutStatus,\n    /// Error code of the connector\n    pub error_code: Option<String>,\n    /// Error message of the connector\n    pub error_message: Option<String>,\n    /// A unique identifier for a payout provided by the connector\n    pub connector_payout_id: Option<String>,\n}\n", "function_name": "crates__api_models__src__payouts.rs", "file": "crates__api_models__src__payouts.rs"}, {"query": "how to create a payout in hyperswitch", "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::BrowserInformation;\nuse common_utils::{\n    consts::default_payouts_list_limit,\n    crypto, id_type, link_utils, payout_method_utils,\n    pii::{self, Email},\n    transformers::ForeignFrom,\n    types::{UnifiedCode, UnifiedMessage},\n};\nuse masking::Secret;\n#[cfg(feature = \"v1\")]\nuse payments::BrowserInformation;\nuse router_derive::FlatStruct;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{admin, enums as api_enums, payment_methods::RequiredFieldInfo, payments};\n\n#[derive(Debug, Serialize, Clone, ToSchema)]\npub enum PayoutRequest {\n    PayoutActionRequest(PayoutActionRequest),\n    PayoutCreateRequest(Box<PayoutCreateRequest>),\n    PayoutRetrieveRequest(PayoutRetrieveRequest),\n}\n\n#[derive(\n    Default, Debug, Deserialize, Serialize, Clone, ToSchema, router_derive::PolymorphicSchema,\n)]\n#[generate_schemas(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n#[serde(deny_unknown_fields)]\npub struct PayoutCreateRequest {\n    /// Unique identifier for the payout. This ensures idempotency for multiple payouts that have been done by a single merchant. This field is auto generated and is returned in the API response, **not required to be included in the Payout Create/Update Request.**\n    #[schema(\n        value_type = Option<String>,\n        min_length = 30,\n        max_length = 30,\n        example = \"187282ab-40ef-47a9-9206-5099ba31e432\"\n    )]\n    #[remove_in(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n    pub payout_id: Option<id_type::PayoutId>,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key provided during the request, **not required to be included in the Payout Create/Update Request.**\n    #[schema(max_length = 255, value_type = Option<String>, example = \"merchant_1668273825\")]\n    #[remove_in(PayoutsCreateRequest, Pa\n\n... [truncated 46680 chars] ...\n\nate_parameter_present(&self) -> bool {\n        self.status.is_some()\n            || self.error_code.is_some()\n            || self.error_message.is_some()\n            || self.connector_payout_id.is_some()\n    }\n}\n\n#[derive(Debug, serde::Serialize, Clone, ToSchema)]\npub struct PayoutsManualUpdateResponse {\n    /// The identifier for the payout\n    #[schema(value_type = String)]\n    pub payout_id: id_type::PayoutId,\n    /// The identifier for the payout attempt\n    pub payout_attempt_id: String,\n    /// Merchant ID\n    #[schema(value_type = String)]\n    pub merchant_id: id_type::MerchantId,\n    /// The status of the payout attempt\n    #[schema(value_type = PayoutStatus)]\n    pub attempt_status: api_enums::PayoutStatus,\n    /// Error code of the connector\n    pub error_code: Option<String>,\n    /// Error message of the connector\n    pub error_message: Option<String>,\n    /// A unique identifier for a payout provided by the connector\n    pub connector_payout_id: Option<String>,\n}\n", "function_name": "crates__api_models__src__payouts.rs", "file": "crates__api_models__src__payouts.rs"}, {"query": "PayoutCreateRequest struct definition", "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::BrowserInformation;\nuse common_utils::{\n    consts::default_payouts_list_limit,\n    crypto, id_type, link_utils, payout_method_utils,\n    pii::{self, Email},\n    transformers::ForeignFrom,\n    types::{UnifiedCode, UnifiedMessage},\n};\nuse masking::Secret;\n#[cfg(feature = \"v1\")]\nuse payments::BrowserInformation;\nuse router_derive::FlatStruct;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{admin, enums as api_enums, payment_methods::RequiredFieldInfo, payments};\n\n#[derive(Debug, Serialize, Clone, ToSchema)]\npub enum PayoutRequest {\n    PayoutActionRequest(PayoutActionRequest),\n    PayoutCreateRequest(Box<PayoutCreateRequest>),\n    PayoutRetrieveRequest(PayoutRetrieveRequest),\n}\n\n#[derive(\n    Default, Debug, Deserialize, Serialize, Clone, ToSchema, router_derive::PolymorphicSchema,\n)]\n#[generate_schemas(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n#[serde(deny_unknown_fields)]\npub struct PayoutCreateRequest {\n    /// Unique identifier for the payout. This ensures idempotency for multiple payouts that have been done by a single merchant. This field is auto generated and is returned in the API response, **not required to be included in the Payout Create/Update Request.**\n    #[schema(\n        value_type = Option<String>,\n        min_length = 30,\n        max_length = 30,\n        example = \"187282ab-40ef-47a9-9206-5099ba31e432\"\n    )]\n    #[remove_in(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n    pub payout_id: Option<id_type::PayoutId>,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key provided during the request, **not required to be included in the Payout Create/Update Request.**\n    #[schema(max_length = 255, value_type = Option<String>, example = \"merchant_1668273825\")]\n    #[remove_in(PayoutsCreateRequest, Pa\n\n... [truncated 46680 chars] ...\n\nate_parameter_present(&self) -> bool {\n        self.status.is_some()\n            || self.error_code.is_some()\n            || self.error_message.is_some()\n            || self.connector_payout_id.is_some()\n    }\n}\n\n#[derive(Debug, serde::Serialize, Clone, ToSchema)]\npub struct PayoutsManualUpdateResponse {\n    /// The identifier for the payout\n    #[schema(value_type = String)]\n    pub payout_id: id_type::PayoutId,\n    /// The identifier for the payout attempt\n    pub payout_attempt_id: String,\n    /// Merchant ID\n    #[schema(value_type = String)]\n    pub merchant_id: id_type::MerchantId,\n    /// The status of the payout attempt\n    #[schema(value_type = PayoutStatus)]\n    pub attempt_status: api_enums::PayoutStatus,\n    /// Error code of the connector\n    pub error_code: Option<String>,\n    /// Error message of the connector\n    pub error_message: Option<String>,\n    /// A unique identifier for a payout provided by the connector\n    pub connector_payout_id: Option<String>,\n}\n", "function_name": "crates__api_models__src__payouts.rs", "file": "crates__api_models__src__payouts.rs"}, {"query": "payout status enums hyperswitch", "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::BrowserInformation;\nuse common_utils::{\n    consts::default_payouts_list_limit,\n    crypto, id_type, link_utils, payout_method_utils,\n    pii::{self, Email},\n    transformers::ForeignFrom,\n    types::{UnifiedCode, UnifiedMessage},\n};\nuse masking::Secret;\n#[cfg(feature = \"v1\")]\nuse payments::BrowserInformation;\nuse router_derive::FlatStruct;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{admin, enums as api_enums, payment_methods::RequiredFieldInfo, payments};\n\n#[derive(Debug, Serialize, Clone, ToSchema)]\npub enum PayoutRequest {\n    PayoutActionRequest(PayoutActionRequest),\n    PayoutCreateRequest(Box<PayoutCreateRequest>),\n    PayoutRetrieveRequest(PayoutRetrieveRequest),\n}\n\n#[derive(\n    Default, Debug, Deserialize, Serialize, Clone, ToSchema, router_derive::PolymorphicSchema,\n)]\n#[generate_schemas(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n#[serde(deny_unknown_fields)]\npub struct PayoutCreateRequest {\n    /// Unique identifier for the payout. This ensures idempotency for multiple payouts that have been done by a single merchant. This field is auto generated and is returned in the API response, **not required to be included in the Payout Create/Update Request.**\n    #[schema(\n        value_type = Option<String>,\n        min_length = 30,\n        max_length = 30,\n        example = \"187282ab-40ef-47a9-9206-5099ba31e432\"\n    )]\n    #[remove_in(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n    pub payout_id: Option<id_type::PayoutId>,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key provided during the request, **not required to be included in the Payout Create/Update Request.**\n    #[schema(max_length = 255, value_type = Option<String>, example = \"merchant_1668273825\")]\n    #[remove_in(PayoutsCreateRequest, Pa\n\n... [truncated 46680 chars] ...\n\nate_parameter_present(&self) -> bool {\n        self.status.is_some()\n            || self.error_code.is_some()\n            || self.error_message.is_some()\n            || self.connector_payout_id.is_some()\n    }\n}\n\n#[derive(Debug, serde::Serialize, Clone, ToSchema)]\npub struct PayoutsManualUpdateResponse {\n    /// The identifier for the payout\n    #[schema(value_type = String)]\n    pub payout_id: id_type::PayoutId,\n    /// The identifier for the payout attempt\n    pub payout_attempt_id: String,\n    /// Merchant ID\n    #[schema(value_type = String)]\n    pub merchant_id: id_type::MerchantId,\n    /// The status of the payout attempt\n    #[schema(value_type = PayoutStatus)]\n    pub attempt_status: api_enums::PayoutStatus,\n    /// Error code of the connector\n    pub error_code: Option<String>,\n    /// Error message of the connector\n    pub error_message: Option<String>,\n    /// A unique identifier for a payout provided by the connector\n    pub connector_payout_id: Option<String>,\n}\n", "function_name": "crates__api_models__src__payouts.rs", "file": "crates__api_models__src__payouts.rs"}, {"query": "Tokenio payment request transformer", "code": "use std::collections::HashMap;\n\nuse api_models::admin::{AdditionalMerchantData, MerchantAccountData, MerchantRecipientData};\nuse common_enums::enums;\nuse common_utils::{id_type::MerchantId, request::Method, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self},\n};\n\n//TODO: Fill the struct with respective fields\npub struct TokenioRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for TokenioRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TokenioPaymentsRequest {\n    pub initiation: PaymentInitiation,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct Amount {\n    pub value: StringMajorUnit,\n    pub currency: enums::Currency,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum LocalI\n\n... [truncated 20513 chars] ...\n\nde(other)]\n    Unknown,\n}\n\n// Base webhook payload structure\n#[derive(Debug, Deserialize, Serialize)]\npub struct TokenioWebhookPayload {\n    #[serde(rename = \"eventType\", skip_serializing_if = \"Option::is_none\")]\n    pub event_type: Option<String>,\n    pub id: String,\n    #[serde(flatten)]\n    pub event_data: TokenioWebhookEventData,\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum TokenioWebhookEventData {\n    PaymentV2 { payment: TokenioPaymentObjectV2 },\n}\n\n// Payment v2 structures\n#[derive(Debug, Deserialize, Serialize)]\npub struct TokenioPaymentObjectV2 {\n    pub id: String,\n    pub status: TokenioPaymentStatus,\n}\n#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TokenioPaymentStatus {\n    InitiationCompleted,\n    PaymentCompleted,\n    PaymentFailed,\n    PaymentCancelled,\n    InitiationRejected,\n    InitiationProcessing,\n    InitiationPendingRedirectHp,\n    #[serde(other)]\n    Other,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs"}, {"query": "how to handle Tokenio webhook events", "code": "use std::collections::HashMap;\n\nuse api_models::admin::{AdditionalMerchantData, MerchantAccountData, MerchantRecipientData};\nuse common_enums::enums;\nuse common_utils::{id_type::MerchantId, request::Method, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self},\n};\n\n//TODO: Fill the struct with respective fields\npub struct TokenioRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for TokenioRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TokenioPaymentsRequest {\n    pub initiation: PaymentInitiation,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct Amount {\n    pub value: StringMajorUnit,\n    pub currency: enums::Currency,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum LocalI\n\n... [truncated 20513 chars] ...\n\nde(other)]\n    Unknown,\n}\n\n// Base webhook payload structure\n#[derive(Debug, Deserialize, Serialize)]\npub struct TokenioWebhookPayload {\n    #[serde(rename = \"eventType\", skip_serializing_if = \"Option::is_none\")]\n    pub event_type: Option<String>,\n    pub id: String,\n    #[serde(flatten)]\n    pub event_data: TokenioWebhookEventData,\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum TokenioWebhookEventData {\n    PaymentV2 { payment: TokenioPaymentObjectV2 },\n}\n\n// Payment v2 structures\n#[derive(Debug, Deserialize, Serialize)]\npub struct TokenioPaymentObjectV2 {\n    pub id: String,\n    pub status: TokenioPaymentStatus,\n}\n#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TokenioPaymentStatus {\n    InitiationCompleted,\n    PaymentCompleted,\n    PaymentFailed,\n    PaymentCancelled,\n    InitiationRejected,\n    InitiationProcessing,\n    InitiationPendingRedirectHp,\n    #[serde(other)]\n    Other,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs"}, {"query": "implement Tokenio refunds response", "code": "use std::collections::HashMap;\n\nuse api_models::admin::{AdditionalMerchantData, MerchantAccountData, MerchantRecipientData};\nuse common_enums::enums;\nuse common_utils::{id_type::MerchantId, request::Method, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self},\n};\n\n//TODO: Fill the struct with respective fields\npub struct TokenioRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for TokenioRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TokenioPaymentsRequest {\n    pub initiation: PaymentInitiation,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct Amount {\n    pub value: StringMajorUnit,\n    pub currency: enums::Currency,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum LocalI\n\n... [truncated 20513 chars] ...\n\nde(other)]\n    Unknown,\n}\n\n// Base webhook payload structure\n#[derive(Debug, Deserialize, Serialize)]\npub struct TokenioWebhookPayload {\n    #[serde(rename = \"eventType\", skip_serializing_if = \"Option::is_none\")]\n    pub event_type: Option<String>,\n    pub id: String,\n    #[serde(flatten)]\n    pub event_data: TokenioWebhookEventData,\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum TokenioWebhookEventData {\n    PaymentV2 { payment: TokenioPaymentObjectV2 },\n}\n\n// Payment v2 structures\n#[derive(Debug, Deserialize, Serialize)]\npub struct TokenioPaymentObjectV2 {\n    pub id: String,\n    pub status: TokenioPaymentStatus,\n}\n#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TokenioPaymentStatus {\n    InitiationCompleted,\n    PaymentCompleted,\n    PaymentFailed,\n    PaymentCancelled,\n    InitiationRejected,\n    InitiationProcessing,\n    InitiationPendingRedirectHp,\n    #[serde(other)]\n    Other,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs"}, {"query": "Tokenio connector data structures", "code": "use std::collections::HashMap;\n\nuse api_models::admin::{AdditionalMerchantData, MerchantAccountData, MerchantRecipientData};\nuse common_enums::enums;\nuse common_utils::{id_type::MerchantId, request::Method, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self},\n};\n\n//TODO: Fill the struct with respective fields\npub struct TokenioRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for TokenioRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TokenioPaymentsRequest {\n    pub initiation: PaymentInitiation,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct Amount {\n    pub value: StringMajorUnit,\n    pub currency: enums::Currency,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum LocalI\n\n... [truncated 20513 chars] ...\n\nde(other)]\n    Unknown,\n}\n\n// Base webhook payload structure\n#[derive(Debug, Deserialize, Serialize)]\npub struct TokenioWebhookPayload {\n    #[serde(rename = \"eventType\", skip_serializing_if = \"Option::is_none\")]\n    pub event_type: Option<String>,\n    pub id: String,\n    #[serde(flatten)]\n    pub event_data: TokenioWebhookEventData,\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum TokenioWebhookEventData {\n    PaymentV2 { payment: TokenioPaymentObjectV2 },\n}\n\n// Payment v2 structures\n#[derive(Debug, Deserialize, Serialize)]\npub struct TokenioPaymentObjectV2 {\n    pub id: String,\n    pub status: TokenioPaymentStatus,\n}\n#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TokenioPaymentStatus {\n    InitiationCompleted,\n    PaymentCompleted,\n    PaymentFailed,\n    PaymentCancelled,\n    InitiationRejected,\n    InitiationProcessing,\n    InitiationPendingRedirectHp,\n    #[serde(other)]\n    Other,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs"}, {"query": "hyperswitch barclaycard connector implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPostAuthenticateRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connect\n\n... [truncated 60951 chars] ...\n\n       // TODO: add logic before deciding the pre processing flow Authenticate or PostAuthenticate\n                let redirection_params = request_data\n                    .redirect_response\n                    .as_ref()\n                    .and_then(|redirect_response| redirect_response.params.as_ref());\n                match redirection_params {\n                    Some(param) if !param.peek().is_empty() => false,\n                    Some(_) | None => true,\n                }\n            }\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BARCLAYCARD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BARCLAYCARD_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BARCLAYCARD_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "file": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs"}, {"query": "BarclaycardAuthType struct", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPostAuthenticateRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connect\n\n... [truncated 60951 chars] ...\n\n       // TODO: add logic before deciding the pre processing flow Authenticate or PostAuthenticate\n                let redirection_params = request_data\n                    .redirect_response\n                    .as_ref()\n                    .and_then(|redirect_response| redirect_response.params.as_ref());\n                match redirection_params {\n                    Some(param) if !param.peek().is_empty() => false,\n                    Some(_) | None => true,\n                }\n            }\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BARCLAYCARD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BARCLAYCARD_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BARCLAYCARD_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "file": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs"}, {"query": "how to integrate Barclays payment gateway", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPostAuthenticateRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connect\n\n... [truncated 60951 chars] ...\n\n       // TODO: add logic before deciding the pre processing flow Authenticate or PostAuthenticate\n                let redirection_params = request_data\n                    .redirect_response\n                    .as_ref()\n                    .and_then(|redirect_response| redirect_response.params.as_ref());\n                match redirection_params {\n                    Some(param) if !param.peek().is_empty() => false,\n                    Some(_) | None => true,\n                }\n            }\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BARCLAYCARD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BARCLAYCARD_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BARCLAYCARD_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "file": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs"}, {"query": "hyperswitch payment orchestration barclaycard", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthenticateData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPostAuthenticateRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connect\n\n... [truncated 60951 chars] ...\n\n       // TODO: add logic before deciding the pre processing flow Authenticate or PostAuthenticate\n                let redirection_params = request_data\n                    .redirect_response\n                    .as_ref()\n                    .and_then(|redirect_response| redirect_response.params.as_ref());\n                match redirection_params {\n                    Some(param) if !param.peek().is_empty() => false,\n                    Some(_) | None => true,\n                }\n            }\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&BARCLAYCARD_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*BARCLAYCARD_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&BARCLAYCARD_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "file": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs"}, {"query": "hyperswitch storage interface trait", "code": "pub mod address;\npub mod api_keys;\npub mod authentication;\npub mod authorization;\npub mod blocklist;\npub mod blocklist_fingerprint;\npub mod blocklist_lookup;\npub mod business_profile;\npub mod callback_mapper;\npub mod capture;\npub mod configs;\npub mod customers;\npub mod dashboard_metadata;\npub mod dispute;\npub mod dynamic_routing_stats;\npub mod ephemeral_key;\npub mod events;\npub mod file;\npub mod fraud_check;\npub mod generic_link;\npub mod gsm;\npub mod health_check;\npub mod hyperswitch_ai_interaction;\npub mod kafka_store;\npub mod locker_mock_up;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod organization;\npub mod payment_link;\npub mod payment_method_session;\npub mod refund;\npub mod relay;\npub mod reverse_lookup;\npub mod role;\npub mod routing_algorithm;\npub mod unified_translations;\npub mod user;\npub mod user_authentication_method;\npub mod user_key_store;\npub mod user_role;\n\nuse ::payment_methods::state::PaymentMethodsStorageInterface;\nuse common_utils::{id_type, types::keymanager::KeyManagerState};\nuse diesel_models::{\n    fraud_check::{FraudCheck, FraudCheckUpdate},\n    organization::{Organization, OrganizationNew, OrganizationUpdate},\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::payouts::{\n    payout_attempt::PayoutAttemptInterface, payouts::PayoutsInterface,\n};\nuse hyperswitch_domain_models::{\n    cards_info::CardsInfoInterface,\n    master_key::MasterKeyInterface,\n    payment_methods::PaymentMethodInterface,\n    payments::{payment_attempt::PaymentAttemptInterface, payment_intent::PaymentIntentInterface},\n};\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\nuse redis_interface::errors::RedisError;\nuse router_env::logger;\nuse storage_impl::{\n    errors::StorageError, redis::kv_store::RedisConnInterface, tokenization, MockDb,\n};\n\npub use self::kafka_store::KafkaStore;\nuse self::{fraud_check::FraudCheckInterfac\n\n... [truncated 11028 chars] ...\n\n .await\n            {\n                logger::error!(message=\"Failed to log analytics event for frm {frm:?}\", error_message=?er);\n            }\n        }\n        Ok(frm)\n    }\n}\n\n#[async_trait::async_trait]\nimpl OrganizationInterface for KafkaStore {\n    async fn insert_organization(\n        &self,\n        organization: OrganizationNew,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store.insert_organization(organization).await\n    }\n    async fn find_organization_by_org_id(\n        &self,\n        org_id: &id_type::OrganizationId,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store.find_organization_by_org_id(org_id).await\n    }\n\n    async fn update_organization_by_org_id(\n        &self,\n        org_id: &id_type::OrganizationId,\n        update: OrganizationUpdate,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store\n            .update_organization_by_org_id(org_id, update)\n            .await\n    }\n}\n", "function_name": "crates__router__src__db.rs", "file": "crates__router__src__db.rs"}, {"query": "how to implement storage backend in rust", "code": "pub mod address;\npub mod api_keys;\npub mod authentication;\npub mod authorization;\npub mod blocklist;\npub mod blocklist_fingerprint;\npub mod blocklist_lookup;\npub mod business_profile;\npub mod callback_mapper;\npub mod capture;\npub mod configs;\npub mod customers;\npub mod dashboard_metadata;\npub mod dispute;\npub mod dynamic_routing_stats;\npub mod ephemeral_key;\npub mod events;\npub mod file;\npub mod fraud_check;\npub mod generic_link;\npub mod gsm;\npub mod health_check;\npub mod hyperswitch_ai_interaction;\npub mod kafka_store;\npub mod locker_mock_up;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod organization;\npub mod payment_link;\npub mod payment_method_session;\npub mod refund;\npub mod relay;\npub mod reverse_lookup;\npub mod role;\npub mod routing_algorithm;\npub mod unified_translations;\npub mod user;\npub mod user_authentication_method;\npub mod user_key_store;\npub mod user_role;\n\nuse ::payment_methods::state::PaymentMethodsStorageInterface;\nuse common_utils::{id_type, types::keymanager::KeyManagerState};\nuse diesel_models::{\n    fraud_check::{FraudCheck, FraudCheckUpdate},\n    organization::{Organization, OrganizationNew, OrganizationUpdate},\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::payouts::{\n    payout_attempt::PayoutAttemptInterface, payouts::PayoutsInterface,\n};\nuse hyperswitch_domain_models::{\n    cards_info::CardsInfoInterface,\n    master_key::MasterKeyInterface,\n    payment_methods::PaymentMethodInterface,\n    payments::{payment_attempt::PaymentAttemptInterface, payment_intent::PaymentIntentInterface},\n};\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\nuse redis_interface::errors::RedisError;\nuse router_env::logger;\nuse storage_impl::{\n    errors::StorageError, redis::kv_store::RedisConnInterface, tokenization, MockDb,\n};\n\npub use self::kafka_store::KafkaStore;\nuse self::{fraud_check::FraudCheckInterfac\n\n... [truncated 11028 chars] ...\n\n .await\n            {\n                logger::error!(message=\"Failed to log analytics event for frm {frm:?}\", error_message=?er);\n            }\n        }\n        Ok(frm)\n    }\n}\n\n#[async_trait::async_trait]\nimpl OrganizationInterface for KafkaStore {\n    async fn insert_organization(\n        &self,\n        organization: OrganizationNew,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store.insert_organization(organization).await\n    }\n    async fn find_organization_by_org_id(\n        &self,\n        org_id: &id_type::OrganizationId,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store.find_organization_by_org_id(org_id).await\n    }\n\n    async fn update_organization_by_org_id(\n        &self,\n        org_id: &id_type::OrganizationId,\n        update: OrganizationUpdate,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store\n            .update_organization_by_org_id(org_id, update)\n            .await\n    }\n}\n", "function_name": "crates__router__src__db.rs", "file": "crates__router__src__db.rs"}, {"query": "kafka store implementation hyperswitch", "code": "pub mod address;\npub mod api_keys;\npub mod authentication;\npub mod authorization;\npub mod blocklist;\npub mod blocklist_fingerprint;\npub mod blocklist_lookup;\npub mod business_profile;\npub mod callback_mapper;\npub mod capture;\npub mod configs;\npub mod customers;\npub mod dashboard_metadata;\npub mod dispute;\npub mod dynamic_routing_stats;\npub mod ephemeral_key;\npub mod events;\npub mod file;\npub mod fraud_check;\npub mod generic_link;\npub mod gsm;\npub mod health_check;\npub mod hyperswitch_ai_interaction;\npub mod kafka_store;\npub mod locker_mock_up;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod organization;\npub mod payment_link;\npub mod payment_method_session;\npub mod refund;\npub mod relay;\npub mod reverse_lookup;\npub mod role;\npub mod routing_algorithm;\npub mod unified_translations;\npub mod user;\npub mod user_authentication_method;\npub mod user_key_store;\npub mod user_role;\n\nuse ::payment_methods::state::PaymentMethodsStorageInterface;\nuse common_utils::{id_type, types::keymanager::KeyManagerState};\nuse diesel_models::{\n    fraud_check::{FraudCheck, FraudCheckUpdate},\n    organization::{Organization, OrganizationNew, OrganizationUpdate},\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::payouts::{\n    payout_attempt::PayoutAttemptInterface, payouts::PayoutsInterface,\n};\nuse hyperswitch_domain_models::{\n    cards_info::CardsInfoInterface,\n    master_key::MasterKeyInterface,\n    payment_methods::PaymentMethodInterface,\n    payments::{payment_attempt::PaymentAttemptInterface, payment_intent::PaymentIntentInterface},\n};\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\nuse redis_interface::errors::RedisError;\nuse router_env::logger;\nuse storage_impl::{\n    errors::StorageError, redis::kv_store::RedisConnInterface, tokenization, MockDb,\n};\n\npub use self::kafka_store::KafkaStore;\nuse self::{fraud_check::FraudCheckInterfac\n\n... [truncated 11028 chars] ...\n\n .await\n            {\n                logger::error!(message=\"Failed to log analytics event for frm {frm:?}\", error_message=?er);\n            }\n        }\n        Ok(frm)\n    }\n}\n\n#[async_trait::async_trait]\nimpl OrganizationInterface for KafkaStore {\n    async fn insert_organization(\n        &self,\n        organization: OrganizationNew,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store.insert_organization(organization).await\n    }\n    async fn find_organization_by_org_id(\n        &self,\n        org_id: &id_type::OrganizationId,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store.find_organization_by_org_id(org_id).await\n    }\n\n    async fn update_organization_by_org_id(\n        &self,\n        org_id: &id_type::OrganizationId,\n        update: OrganizationUpdate,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store\n            .update_organization_by_org_id(org_id, update)\n            .await\n    }\n}\n", "function_name": "crates__router__src__db.rs", "file": "crates__router__src__db.rs"}, {"query": "payment orchestration storage abstraction", "code": "pub mod address;\npub mod api_keys;\npub mod authentication;\npub mod authorization;\npub mod blocklist;\npub mod blocklist_fingerprint;\npub mod blocklist_lookup;\npub mod business_profile;\npub mod callback_mapper;\npub mod capture;\npub mod configs;\npub mod customers;\npub mod dashboard_metadata;\npub mod dispute;\npub mod dynamic_routing_stats;\npub mod ephemeral_key;\npub mod events;\npub mod file;\npub mod fraud_check;\npub mod generic_link;\npub mod gsm;\npub mod health_check;\npub mod hyperswitch_ai_interaction;\npub mod kafka_store;\npub mod locker_mock_up;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod organization;\npub mod payment_link;\npub mod payment_method_session;\npub mod refund;\npub mod relay;\npub mod reverse_lookup;\npub mod role;\npub mod routing_algorithm;\npub mod unified_translations;\npub mod user;\npub mod user_authentication_method;\npub mod user_key_store;\npub mod user_role;\n\nuse ::payment_methods::state::PaymentMethodsStorageInterface;\nuse common_utils::{id_type, types::keymanager::KeyManagerState};\nuse diesel_models::{\n    fraud_check::{FraudCheck, FraudCheckUpdate},\n    organization::{Organization, OrganizationNew, OrganizationUpdate},\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::payouts::{\n    payout_attempt::PayoutAttemptInterface, payouts::PayoutsInterface,\n};\nuse hyperswitch_domain_models::{\n    cards_info::CardsInfoInterface,\n    master_key::MasterKeyInterface,\n    payment_methods::PaymentMethodInterface,\n    payments::{payment_attempt::PaymentAttemptInterface, payment_intent::PaymentIntentInterface},\n};\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\nuse redis_interface::errors::RedisError;\nuse router_env::logger;\nuse storage_impl::{\n    errors::StorageError, redis::kv_store::RedisConnInterface, tokenization, MockDb,\n};\n\npub use self::kafka_store::KafkaStore;\nuse self::{fraud_check::FraudCheckInterfac\n\n... [truncated 11028 chars] ...\n\n .await\n            {\n                logger::error!(message=\"Failed to log analytics event for frm {frm:?}\", error_message=?er);\n            }\n        }\n        Ok(frm)\n    }\n}\n\n#[async_trait::async_trait]\nimpl OrganizationInterface for KafkaStore {\n    async fn insert_organization(\n        &self,\n        organization: OrganizationNew,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store.insert_organization(organization).await\n    }\n    async fn find_organization_by_org_id(\n        &self,\n        org_id: &id_type::OrganizationId,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store.find_organization_by_org_id(org_id).await\n    }\n\n    async fn update_organization_by_org_id(\n        &self,\n        org_id: &id_type::OrganizationId,\n        update: OrganizationUpdate,\n    ) -> CustomResult<Organization, StorageError> {\n        self.diesel_store\n            .update_organization_by_org_id(org_id, update)\n            .await\n    }\n}\n", "function_name": "crates__router__src__db.rs", "file": "crates__router__src__db.rs"}, {"query": "how to implement Shift4 payment gateway connector", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse http::header::ACCEPT;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nus\n\n... [truncated 36206 chars] ...\n\nents, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Shift4 {\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                request_data,\n                auth_type,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n            // No alternate flow for complete authorize and SetupMandate\n            api::CurrentFlowInfo::SetupMandate { .. }\n            | api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SHIFT4_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SHIFT4_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&SHIFT4_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__shift4.rs", "file": "crates__hyperswitch_connectors__src__connectors__shift4.rs"}, {"query": "Shift4PaymentsRequest struct", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse http::header::ACCEPT;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nus\n\n... [truncated 36206 chars] ...\n\nents, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Shift4 {\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                request_data,\n                auth_type,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n            // No alternate flow for complete authorize and SetupMandate\n            api::CurrentFlowInfo::SetupMandate { .. }\n            | api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SHIFT4_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SHIFT4_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&SHIFT4_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__shift4.rs", "file": "crates__hyperswitch_connectors__src__connectors__shift4.rs"}, {"query": "how to handle Shift4 webhooks", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse http::header::ACCEPT;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nus\n\n... [truncated 36206 chars] ...\n\nents, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Shift4 {\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                request_data,\n                auth_type,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n            // No alternate flow for complete authorize and SetupMandate\n            api::CurrentFlowInfo::SetupMandate { .. }\n            | api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SHIFT4_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SHIFT4_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&SHIFT4_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__shift4.rs", "file": "crates__hyperswitch_connectors__src__connectors__shift4.rs"}, {"query": "Shift4 connector integration hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse http::header::ACCEPT;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsPreAuthenticateData, PaymentsPreProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nus\n\n... [truncated 36206 chars] ...\n\nents, enums::EventClass::Refunds];\n\nimpl ConnectorSpecifications for Shift4 {\n    fn is_pre_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize {\n                request_data,\n                auth_type,\n            } => auth_type.is_three_ds() && request_data.is_card(),\n            // No alternate flow for complete authorize and SetupMandate\n            api::CurrentFlowInfo::SetupMandate { .. }\n            | api::CurrentFlowInfo::CompleteAuthorize { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&SHIFT4_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*SHIFT4_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&SHIFT4_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__shift4.rs", "file": "crates__hyperswitch_connectors__src__connectors__shift4.rs"}, {"query": "PayPal connector implementation", "code": "pub mod transformers;\nuse std::{fmt::Write, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, ExtendAuthorization, IncrementalAuthorization, PSync,\n            PaymentMethodToken, PostSessionTokens, PreProcessing, SdkSessionUpdate, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        unified_authentication_service::PostAuthenticate,\n        CompleteAuthorize, VerifyWebhookSource,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsExtendAuthorizationData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPostSessionTokensData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SdkPaymentsSessionUpdateData,\n        SetupMandateRequestData, VerifyWebhookSourceRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt, VerifyWebhookSourceResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsE\n\n... [truncated 96762 chars] ...\n\ns,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Paypal {\n    fn is_post_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize { .. } => false,\n            api::CurrentFlowInfo::CompleteAuthorize {\n                request_data: _,\n                payment_method,\n                ..\n            } => payment_method == Some(enums::PaymentMethod::Card),\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYPAL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYPAL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYPAL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paypal.rs", "file": "crates__hyperswitch_connectors__src__connectors__paypal.rs"}, {"query": "hyperswitch paypal authorize", "code": "pub mod transformers;\nuse std::{fmt::Write, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, ExtendAuthorization, IncrementalAuthorization, PSync,\n            PaymentMethodToken, PostSessionTokens, PreProcessing, SdkSessionUpdate, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        unified_authentication_service::PostAuthenticate,\n        CompleteAuthorize, VerifyWebhookSource,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsExtendAuthorizationData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPostSessionTokensData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SdkPaymentsSessionUpdateData,\n        SetupMandateRequestData, VerifyWebhookSourceRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt, VerifyWebhookSourceResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsE\n\n... [truncated 96762 chars] ...\n\ns,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Paypal {\n    fn is_post_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize { .. } => false,\n            api::CurrentFlowInfo::CompleteAuthorize {\n                request_data: _,\n                payment_method,\n                ..\n            } => payment_method == Some(enums::PaymentMethod::Card),\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYPAL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYPAL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYPAL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paypal.rs", "file": "crates__hyperswitch_connectors__src__connectors__paypal.rs"}, {"query": "how to implement paypal payments", "code": "pub mod transformers;\nuse std::{fmt::Write, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, ExtendAuthorization, IncrementalAuthorization, PSync,\n            PaymentMethodToken, PostSessionTokens, PreProcessing, SdkSessionUpdate, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        unified_authentication_service::PostAuthenticate,\n        CompleteAuthorize, VerifyWebhookSource,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsExtendAuthorizationData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPostSessionTokensData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SdkPaymentsSessionUpdateData,\n        SetupMandateRequestData, VerifyWebhookSourceRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt, VerifyWebhookSourceResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsE\n\n... [truncated 96762 chars] ...\n\ns,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Paypal {\n    fn is_post_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize { .. } => false,\n            api::CurrentFlowInfo::CompleteAuthorize {\n                request_data: _,\n                payment_method,\n                ..\n            } => payment_method == Some(enums::PaymentMethod::Card),\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYPAL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYPAL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYPAL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paypal.rs", "file": "crates__hyperswitch_connectors__src__connectors__paypal.rs"}, {"query": "PayPal webhook event handling", "code": "pub mod transformers;\nuse std::{fmt::Write, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, ExtendAuthorization, IncrementalAuthorization, PSync,\n            PaymentMethodToken, PostSessionTokens, PreProcessing, SdkSessionUpdate, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        unified_authentication_service::PostAuthenticate,\n        CompleteAuthorize, VerifyWebhookSource,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsExtendAuthorizationData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPostSessionTokensData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SdkPaymentsSessionUpdateData,\n        SetupMandateRequestData, VerifyWebhookSourceRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt, VerifyWebhookSourceResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsE\n\n... [truncated 96762 chars] ...\n\ns,\n    enums::EventClass::Refunds,\n    enums::EventClass::Disputes,\n];\n\nimpl ConnectorSpecifications for Paypal {\n    fn is_post_authentication_flow_required(&self, current_flow: api::CurrentFlowInfo<'_>) -> bool {\n        match current_flow {\n            api::CurrentFlowInfo::Authorize { .. } => false,\n            api::CurrentFlowInfo::CompleteAuthorize {\n                request_data: _,\n                payment_method,\n                ..\n            } => payment_method == Some(enums::PaymentMethod::Card),\n            api::CurrentFlowInfo::SetupMandate { .. } => false,\n        }\n    }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&PAYPAL_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*PAYPAL_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&PAYPAL_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__paypal.rs", "file": "crates__hyperswitch_connectors__src__connectors__paypal.rs"}, {"query": "Adyen payment integration implementation", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums::{self, PaymentMethodType};\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        merchant_connector_webhook_management::ConnectorWebhookRegister,\n        payments::{\n            Authorize, Capture, ExtendAuthorization, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Defend, Evidence, GiftCardBalanceCheck, Retrieve, Upload,\n    },\n    router_request_types::{\n        merchant_connector_webhook_management::ConnectorWebhookRegisterRequest,\n        AcceptDisputeRequestData, AccessTokenRequestData, DefendDisputeRequestData,\n        GiftCardBalanceCheckRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsExtendAuthorizationData,\n        PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        RetrieveFileRequestData, SetupMandateRequestData, SubmitEvidenceRequestData,\n        SyncRequestType, UploadFileRequestData,\n    },\n    router_response_types::{\n        merchant_connector_webhook_management::ConnectorWebhookRegisterResponse,\n        AcceptDisputeResponse, ConnectorInfo, DefendDisputeResponse,\n        GiftCardBalanceCheckResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n\n... [truncated 127365 chars] ...\n\n }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ADYEN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ADYEN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(ADYEN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn generate_connector_customer_id(\n        &self,\n        customer_id: &Option<common_utils::id_type::CustomerId>,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> Option<String> {\n        customer_id.as_ref().map(|cid| {\n            format!(\n                \"{}_{}\",\n                merchant_id.get_string_repr(),\n                cid.get_string_repr()\n            )\n        })\n    }\n\n    fn get_api_webhook_config(\n        &self,\n    ) -> &'static common_types::connector_webhook_configuration::WebhookSetupCapabilities {\n        &ADYEN_WEBHOOK_SETUP_CAPABILITIES\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyen.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyen.rs"}, {"query": "AdyenConnector struct definition", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums::{self, PaymentMethodType};\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        merchant_connector_webhook_management::ConnectorWebhookRegister,\n        payments::{\n            Authorize, Capture, ExtendAuthorization, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Defend, Evidence, GiftCardBalanceCheck, Retrieve, Upload,\n    },\n    router_request_types::{\n        merchant_connector_webhook_management::ConnectorWebhookRegisterRequest,\n        AcceptDisputeRequestData, AccessTokenRequestData, DefendDisputeRequestData,\n        GiftCardBalanceCheckRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsExtendAuthorizationData,\n        PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        RetrieveFileRequestData, SetupMandateRequestData, SubmitEvidenceRequestData,\n        SyncRequestType, UploadFileRequestData,\n    },\n    router_response_types::{\n        merchant_connector_webhook_management::ConnectorWebhookRegisterResponse,\n        AcceptDisputeResponse, ConnectorInfo, DefendDisputeResponse,\n        GiftCardBalanceCheckResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n\n... [truncated 127365 chars] ...\n\n }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ADYEN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ADYEN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(ADYEN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn generate_connector_customer_id(\n        &self,\n        customer_id: &Option<common_utils::id_type::CustomerId>,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> Option<String> {\n        customer_id.as_ref().map(|cid| {\n            format!(\n                \"{}_{}\",\n                merchant_id.get_string_repr(),\n                cid.get_string_repr()\n            )\n        })\n    }\n\n    fn get_api_webhook_config(\n        &self,\n    ) -> &'static common_types::connector_webhook_configuration::WebhookSetupCapabilities {\n        &ADYEN_WEBHOOK_SETUP_CAPABILITIES\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyen.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyen.rs"}, {"query": "how to add new payment method to Adyen", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums::{self, PaymentMethodType};\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        merchant_connector_webhook_management::ConnectorWebhookRegister,\n        payments::{\n            Authorize, Capture, ExtendAuthorization, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Defend, Evidence, GiftCardBalanceCheck, Retrieve, Upload,\n    },\n    router_request_types::{\n        merchant_connector_webhook_management::ConnectorWebhookRegisterRequest,\n        AcceptDisputeRequestData, AccessTokenRequestData, DefendDisputeRequestData,\n        GiftCardBalanceCheckRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsExtendAuthorizationData,\n        PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        RetrieveFileRequestData, SetupMandateRequestData, SubmitEvidenceRequestData,\n        SyncRequestType, UploadFileRequestData,\n    },\n    router_response_types::{\n        merchant_connector_webhook_management::ConnectorWebhookRegisterResponse,\n        AcceptDisputeResponse, ConnectorInfo, DefendDisputeResponse,\n        GiftCardBalanceCheckResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n\n... [truncated 127365 chars] ...\n\n }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ADYEN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ADYEN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(ADYEN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn generate_connector_customer_id(\n        &self,\n        customer_id: &Option<common_utils::id_type::CustomerId>,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> Option<String> {\n        customer_id.as_ref().map(|cid| {\n            format!(\n                \"{}_{}\",\n                merchant_id.get_string_repr(),\n                cid.get_string_repr()\n            )\n        })\n    }\n\n    fn get_api_webhook_config(\n        &self,\n    ) -> &'static common_types::connector_webhook_configuration::WebhookSetupCapabilities {\n        &ADYEN_WEBHOOK_SETUP_CAPABILITIES\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyen.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyen.rs"}, {"query": "Adyen webhook handling hyperswitch", "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums::{self, PaymentMethodType};\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        merchant_connector_webhook_management::ConnectorWebhookRegister,\n        payments::{\n            Authorize, Capture, ExtendAuthorization, PSync, PaymentMethodToken, PreProcessing,\n            Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Defend, Evidence, GiftCardBalanceCheck, Retrieve, Upload,\n    },\n    router_request_types::{\n        merchant_connector_webhook_management::ConnectorWebhookRegisterRequest,\n        AcceptDisputeRequestData, AccessTokenRequestData, DefendDisputeRequestData,\n        GiftCardBalanceCheckRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsExtendAuthorizationData,\n        PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        RetrieveFileRequestData, SetupMandateRequestData, SubmitEvidenceRequestData,\n        SyncRequestType, UploadFileRequestData,\n    },\n    router_response_types::{\n        merchant_connector_webhook_management::ConnectorWebhookRegisterResponse,\n        AcceptDisputeResponse, ConnectorInfo, DefendDisputeResponse,\n        GiftCardBalanceCheckResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n\n... [truncated 127365 chars] ...\n\n }\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&ADYEN_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*ADYEN_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(ADYEN_SUPPORTED_WEBHOOK_FLOWS)\n    }\n\n    fn generate_connector_customer_id(\n        &self,\n        customer_id: &Option<common_utils::id_type::CustomerId>,\n        merchant_id: &common_utils::id_type::MerchantId,\n    ) -> Option<String> {\n        customer_id.as_ref().map(|cid| {\n            format!(\n                \"{}_{}\",\n                merchant_id.get_string_repr(),\n                cid.get_string_repr()\n            )\n        })\n    }\n\n    fn get_api_webhook_config(\n        &self,\n    ) -> &'static common_types::connector_webhook_configuration::WebhookSetupCapabilities {\n        &ADYEN_WEBHOOK_SETUP_CAPABILITIES\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__adyen.rs", "file": "crates__hyperswitch_connectors__src__connectors__adyen.rs"}, {"query": "payment orchestration API request handler", "code": "pub mod client;\npub mod generic_link_response;\npub mod request;\nuse std::{\n    collections::{HashMap, HashSet},\n    fmt::Debug,\n    future::Future,\n    str,\n    sync::Arc,\n    time::{Duration, Instant},\n};\n\nuse actix_http::header::HeaderMap;\nuse actix_web::{\n    body,\n    http::header::{HeaderName, HeaderValue},\n    web, FromRequest, HttpRequest, HttpResponse, Responder, ResponseError,\n};\npub use client::{ApiClient, MockApiClient, ProxyClient};\npub use common_enums::enums::PaymentAction;\npub use common_utils::request::{ContentType, Method, Request, RequestBuilder};\nuse common_utils::{\n    consts::{DEFAULT_TENANT, TENANT_HEADER, X_HS_LATENCY},\n    errors::{ErrorSwitch, ReportSwitchExt},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::router_data_v2::flow_common_types as common_types;\npub use hyperswitch_domain_models::{\n    api::{\n        ApplicationResponse, GenericExpiredLinkData, GenericLinkFormData, GenericLinkStatusData,\n        GenericLinks, PaymentLinkAction, RedirectionFormData,\n    },\n    payment_method_data::PaymentMethodData,\n    router_response_types::RedirectForm,\n};\npub use hyperswitch_interfaces::{\n    api::{\n        BoxedConnectorIntegration, CaptureSyncMethod, ConnectorIntegration,\n        ConnectorIntegrationAny, ConnectorRedirectResponse, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    api_client::{\n        call_connector_api, execute_connector_processing_step, handle_response,\n        store_raw_connector_response_if_required,\n    },\n    connector_integration_v2::{\n        BoxedConnectorIntegrationV2, ConnectorIntegrationAnyV2, ConnectorIntegrationV2,\n    },\n};\nuse masking::{Maskable, PeekInterface};\npub use payment_link::{PaymentLinkFormData, PaymentLinkStatusData};\nuse router_env::{instrument, tracing, RequestId, Tag};\nuse serde::Serialize;\n\nuse super::{\n    authentication::AuthenticateAndFetch,\n    connector_integration_interface::BoxedConnectorIntegrationInterface,\n};\nuse crate::{\n    configs::Settings,\n    core::\n\n... [truncated 121649 chars] ...\n\ncement.as_object().is_some_and(|obj| !obj.is_empty()) {\n        Some(enhancement)\n    } else {\n        None\n    }\n}\n\npub fn extract_field_by_dot_path(\n    value: &serde_json::Value,\n    path: &str,\n) -> Option<serde_json::Value> {\n    let parts: Vec<&str> = path.split('.').collect();\n    let mut current = value;\n\n    for part in parts {\n        match current {\n            serde_json::Value::Object(obj) => {\n                current = obj.get(part)?;\n            }\n            serde_json::Value::Array(arr) => {\n                // Try to parse part as array index\n                if let Ok(index) = part.parse::<usize>() {\n                    current = arr.get(index)?;\n                } else {\n                    return None;\n                }\n            }\n            _ => return None,\n        }\n    }\n\n    Some(current.clone())\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_mime_essence() {\n        assert_eq!(mime::APPLICATION_JSON.essence_str(), \"application/json\");\n    }\n}\n", "function_name": "crates__router__src__services__api.rs", "file": "crates__router__src__services__api.rs"}, {"query": "capture payment flow implementation", "code": "pub mod client;\npub mod generic_link_response;\npub mod request;\nuse std::{\n    collections::{HashMap, HashSet},\n    fmt::Debug,\n    future::Future,\n    str,\n    sync::Arc,\n    time::{Duration, Instant},\n};\n\nuse actix_http::header::HeaderMap;\nuse actix_web::{\n    body,\n    http::header::{HeaderName, HeaderValue},\n    web, FromRequest, HttpRequest, HttpResponse, Responder, ResponseError,\n};\npub use client::{ApiClient, MockApiClient, ProxyClient};\npub use common_enums::enums::PaymentAction;\npub use common_utils::request::{ContentType, Method, Request, RequestBuilder};\nuse common_utils::{\n    consts::{DEFAULT_TENANT, TENANT_HEADER, X_HS_LATENCY},\n    errors::{ErrorSwitch, ReportSwitchExt},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::router_data_v2::flow_common_types as common_types;\npub use hyperswitch_domain_models::{\n    api::{\n        ApplicationResponse, GenericExpiredLinkData, GenericLinkFormData, GenericLinkStatusData,\n        GenericLinks, PaymentLinkAction, RedirectionFormData,\n    },\n    payment_method_data::PaymentMethodData,\n    router_response_types::RedirectForm,\n};\npub use hyperswitch_interfaces::{\n    api::{\n        BoxedConnectorIntegration, CaptureSyncMethod, ConnectorIntegration,\n        ConnectorIntegrationAny, ConnectorRedirectResponse, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    api_client::{\n        call_connector_api, execute_connector_processing_step, handle_response,\n        store_raw_connector_response_if_required,\n    },\n    connector_integration_v2::{\n        BoxedConnectorIntegrationV2, ConnectorIntegrationAnyV2, ConnectorIntegrationV2,\n    },\n};\nuse masking::{Maskable, PeekInterface};\npub use payment_link::{PaymentLinkFormData, PaymentLinkStatusData};\nuse router_env::{instrument, tracing, RequestId, Tag};\nuse serde::Serialize;\n\nuse super::{\n    authentication::AuthenticateAndFetch,\n    connector_integration_interface::BoxedConnectorIntegrationInterface,\n};\nuse crate::{\n    configs::Settings,\n    core::\n\n... [truncated 121649 chars] ...\n\ncement.as_object().is_some_and(|obj| !obj.is_empty()) {\n        Some(enhancement)\n    } else {\n        None\n    }\n}\n\npub fn extract_field_by_dot_path(\n    value: &serde_json::Value,\n    path: &str,\n) -> Option<serde_json::Value> {\n    let parts: Vec<&str> = path.split('.').collect();\n    let mut current = value;\n\n    for part in parts {\n        match current {\n            serde_json::Value::Object(obj) => {\n                current = obj.get(part)?;\n            }\n            serde_json::Value::Array(arr) => {\n                // Try to parse part as array index\n                if let Ok(index) = part.parse::<usize>() {\n                    current = arr.get(index)?;\n                } else {\n                    return None;\n                }\n            }\n            _ => return None,\n        }\n    }\n\n    Some(current.clone())\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_mime_essence() {\n        assert_eq!(mime::APPLICATION_JSON.essence_str(), \"application/json\");\n    }\n}\n", "function_name": "crates__router__src__services__api.rs", "file": "crates__router__src__services__api.rs"}, {"query": "refund payment action handler", "code": "pub mod client;\npub mod generic_link_response;\npub mod request;\nuse std::{\n    collections::{HashMap, HashSet},\n    fmt::Debug,\n    future::Future,\n    str,\n    sync::Arc,\n    time::{Duration, Instant},\n};\n\nuse actix_http::header::HeaderMap;\nuse actix_web::{\n    body,\n    http::header::{HeaderName, HeaderValue},\n    web, FromRequest, HttpRequest, HttpResponse, Responder, ResponseError,\n};\npub use client::{ApiClient, MockApiClient, ProxyClient};\npub use common_enums::enums::PaymentAction;\npub use common_utils::request::{ContentType, Method, Request, RequestBuilder};\nuse common_utils::{\n    consts::{DEFAULT_TENANT, TENANT_HEADER, X_HS_LATENCY},\n    errors::{ErrorSwitch, ReportSwitchExt},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::router_data_v2::flow_common_types as common_types;\npub use hyperswitch_domain_models::{\n    api::{\n        ApplicationResponse, GenericExpiredLinkData, GenericLinkFormData, GenericLinkStatusData,\n        GenericLinks, PaymentLinkAction, RedirectionFormData,\n    },\n    payment_method_data::PaymentMethodData,\n    router_response_types::RedirectForm,\n};\npub use hyperswitch_interfaces::{\n    api::{\n        BoxedConnectorIntegration, CaptureSyncMethod, ConnectorIntegration,\n        ConnectorIntegrationAny, ConnectorRedirectResponse, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    api_client::{\n        call_connector_api, execute_connector_processing_step, handle_response,\n        store_raw_connector_response_if_required,\n    },\n    connector_integration_v2::{\n        BoxedConnectorIntegrationV2, ConnectorIntegrationAnyV2, ConnectorIntegrationV2,\n    },\n};\nuse masking::{Maskable, PeekInterface};\npub use payment_link::{PaymentLinkFormData, PaymentLinkStatusData};\nuse router_env::{instrument, tracing, RequestId, Tag};\nuse serde::Serialize;\n\nuse super::{\n    authentication::AuthenticateAndFetch,\n    connector_integration_interface::BoxedConnectorIntegrationInterface,\n};\nuse crate::{\n    configs::Settings,\n    core::\n\n... [truncated 121649 chars] ...\n\ncement.as_object().is_some_and(|obj| !obj.is_empty()) {\n        Some(enhancement)\n    } else {\n        None\n    }\n}\n\npub fn extract_field_by_dot_path(\n    value: &serde_json::Value,\n    path: &str,\n) -> Option<serde_json::Value> {\n    let parts: Vec<&str> = path.split('.').collect();\n    let mut current = value;\n\n    for part in parts {\n        match current {\n            serde_json::Value::Object(obj) => {\n                current = obj.get(part)?;\n            }\n            serde_json::Value::Array(arr) => {\n                // Try to parse part as array index\n                if let Ok(index) = part.parse::<usize>() {\n                    current = arr.get(index)?;\n                } else {\n                    return None;\n                }\n            }\n            _ => return None,\n        }\n    }\n\n    Some(current.clone())\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_mime_essence() {\n        assert_eq!(mime::APPLICATION_JSON.essence_str(), \"application/json\");\n    }\n}\n", "function_name": "crates__router__src__services__api.rs", "file": "crates__router__src__services__api.rs"}, {"query": "connector integration API response builder", "code": "pub mod client;\npub mod generic_link_response;\npub mod request;\nuse std::{\n    collections::{HashMap, HashSet},\n    fmt::Debug,\n    future::Future,\n    str,\n    sync::Arc,\n    time::{Duration, Instant},\n};\n\nuse actix_http::header::HeaderMap;\nuse actix_web::{\n    body,\n    http::header::{HeaderName, HeaderValue},\n    web, FromRequest, HttpRequest, HttpResponse, Responder, ResponseError,\n};\npub use client::{ApiClient, MockApiClient, ProxyClient};\npub use common_enums::enums::PaymentAction;\npub use common_utils::request::{ContentType, Method, Request, RequestBuilder};\nuse common_utils::{\n    consts::{DEFAULT_TENANT, TENANT_HEADER, X_HS_LATENCY},\n    errors::{ErrorSwitch, ReportSwitchExt},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::router_data_v2::flow_common_types as common_types;\npub use hyperswitch_domain_models::{\n    api::{\n        ApplicationResponse, GenericExpiredLinkData, GenericLinkFormData, GenericLinkStatusData,\n        GenericLinks, PaymentLinkAction, RedirectionFormData,\n    },\n    payment_method_data::PaymentMethodData,\n    router_response_types::RedirectForm,\n};\npub use hyperswitch_interfaces::{\n    api::{\n        BoxedConnectorIntegration, CaptureSyncMethod, ConnectorIntegration,\n        ConnectorIntegrationAny, ConnectorRedirectResponse, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    api_client::{\n        call_connector_api, execute_connector_processing_step, handle_response,\n        store_raw_connector_response_if_required,\n    },\n    connector_integration_v2::{\n        BoxedConnectorIntegrationV2, ConnectorIntegrationAnyV2, ConnectorIntegrationV2,\n    },\n};\nuse masking::{Maskable, PeekInterface};\npub use payment_link::{PaymentLinkFormData, PaymentLinkStatusData};\nuse router_env::{instrument, tracing, RequestId, Tag};\nuse serde::Serialize;\n\nuse super::{\n    authentication::AuthenticateAndFetch,\n    connector_integration_interface::BoxedConnectorIntegrationInterface,\n};\nuse crate::{\n    configs::Settings,\n    core::\n\n... [truncated 121649 chars] ...\n\ncement.as_object().is_some_and(|obj| !obj.is_empty()) {\n        Some(enhancement)\n    } else {\n        None\n    }\n}\n\npub fn extract_field_by_dot_path(\n    value: &serde_json::Value,\n    path: &str,\n) -> Option<serde_json::Value> {\n    let parts: Vec<&str> = path.split('.').collect();\n    let mut current = value;\n\n    for part in parts {\n        match current {\n            serde_json::Value::Object(obj) => {\n                current = obj.get(part)?;\n            }\n            serde_json::Value::Array(arr) => {\n                // Try to parse part as array index\n                if let Ok(index) = part.parse::<usize>() {\n                    current = arr.get(index)?;\n                } else {\n                    return None;\n                }\n            }\n            _ => return None,\n        }\n    }\n\n    Some(current.clone())\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_mime_essence() {\n        assert_eq!(mime::APPLICATION_JSON.essence_str(), \"application/json\");\n    }\n}\n", "function_name": "crates__router__src__services__api.rs", "file": "crates__router__src__services__api.rs"}, {"query": "how to transform payments authorize data for Amazon Pay", "code": "use std::collections::HashMap;\n\nuse common_enums::{enums, CaptureMethod};\nuse common_utils::{errors::CustomResult, pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{is_refund_failure, RouterData as _},\n};\n\npub struct AmazonpayRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for AmazonpayRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmazonpayFinalizeRequest {\n    charge_amount: ChargeAmount,\n    shipping_address: AddressDetails,\n    payment_intent: PaymentIntent,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ChargeAmount {\n    amount: StringMajorUnit,\n    currency_code: common_enums::Currency,\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddressDetails {\n    name: Secret<String>,\n    address_line_1: Secret<String>,\n    address_line_2: Option<Secret<String>>,\n    address_line_3: Option<Secret<String>>,\n    city: String,\n    state_or_region: Secret<String>,\n    postal_code: Secret<String>,\n    country_code: Option<common_enums::CountryAlpha2>,\n    phone_number: Secret<String>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\npub enum PaymentIntent {\n    AuthorizeWithCapture,\n}\n\nfn get_amazonpay_capture_type(\n    item: Option<Captu\n\n... [truncated 19820 chars] ...\n\n   reason: Some(\"Amazon has declined the refund because maximum amount has been refunded or there was some other issue.\".to_owned()),\n                status_code: item.http_code,\n                attempt_status: None,\n                connector_transaction_id: Some(item.response.refund_id.clone()),\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            })\n        } else {\n            Ok(RefundsResponseData {\n                connector_refund_id: item.response.refund_id.to_string(),\n                refund_status,\n            })\n        };\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmazonpayErrorResponse {\n    pub reason_code: String,\n    pub message: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__amazonpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__amazonpay__transformers.rs"}, {"query": "AmazonpayFinalizeRequest struct", "code": "use std::collections::HashMap;\n\nuse common_enums::{enums, CaptureMethod};\nuse common_utils::{errors::CustomResult, pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{is_refund_failure, RouterData as _},\n};\n\npub struct AmazonpayRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for AmazonpayRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmazonpayFinalizeRequest {\n    charge_amount: ChargeAmount,\n    shipping_address: AddressDetails,\n    payment_intent: PaymentIntent,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ChargeAmount {\n    amount: StringMajorUnit,\n    currency_code: common_enums::Currency,\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddressDetails {\n    name: Secret<String>,\n    address_line_1: Secret<String>,\n    address_line_2: Option<Secret<String>>,\n    address_line_3: Option<Secret<String>>,\n    city: String,\n    state_or_region: Secret<String>,\n    postal_code: Secret<String>,\n    country_code: Option<common_enums::CountryAlpha2>,\n    phone_number: Secret<String>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\npub enum PaymentIntent {\n    AuthorizeWithCapture,\n}\n\nfn get_amazonpay_capture_type(\n    item: Option<Captu\n\n... [truncated 19820 chars] ...\n\n   reason: Some(\"Amazon has declined the refund because maximum amount has been refunded or there was some other issue.\".to_owned()),\n                status_code: item.http_code,\n                attempt_status: None,\n                connector_transaction_id: Some(item.response.refund_id.clone()),\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            })\n        } else {\n            Ok(RefundsResponseData {\n                connector_refund_id: item.response.refund_id.to_string(),\n                refund_status,\n            })\n        };\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmazonpayErrorResponse {\n    pub reason_code: String,\n    pub message: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__amazonpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__amazonpay__transformers.rs"}, {"query": "how to handle Amazon Pay refund responses", "code": "use std::collections::HashMap;\n\nuse common_enums::{enums, CaptureMethod};\nuse common_utils::{errors::CustomResult, pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{is_refund_failure, RouterData as _},\n};\n\npub struct AmazonpayRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for AmazonpayRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmazonpayFinalizeRequest {\n    charge_amount: ChargeAmount,\n    shipping_address: AddressDetails,\n    payment_intent: PaymentIntent,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ChargeAmount {\n    amount: StringMajorUnit,\n    currency_code: common_enums::Currency,\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddressDetails {\n    name: Secret<String>,\n    address_line_1: Secret<String>,\n    address_line_2: Option<Secret<String>>,\n    address_line_3: Option<Secret<String>>,\n    city: String,\n    state_or_region: Secret<String>,\n    postal_code: Secret<String>,\n    country_code: Option<common_enums::CountryAlpha2>,\n    phone_number: Secret<String>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\npub enum PaymentIntent {\n    AuthorizeWithCapture,\n}\n\nfn get_amazonpay_capture_type(\n    item: Option<Captu\n\n... [truncated 19820 chars] ...\n\n   reason: Some(\"Amazon has declined the refund because maximum amount has been refunded or there was some other issue.\".to_owned()),\n                status_code: item.http_code,\n                attempt_status: None,\n                connector_transaction_id: Some(item.response.refund_id.clone()),\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            })\n        } else {\n            Ok(RefundsResponseData {\n                connector_refund_id: item.response.refund_id.to_string(),\n                refund_status,\n            })\n        };\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmazonpayErrorResponse {\n    pub reason_code: String,\n    pub message: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__amazonpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__amazonpay__transformers.rs"}, {"query": "Amazon Pay connector request transformation", "code": "use std::collections::HashMap;\n\nuse common_enums::{enums, CaptureMethod};\nuse common_utils::{errors::CustomResult, pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{is_refund_failure, RouterData as _},\n};\n\npub struct AmazonpayRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for AmazonpayRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmazonpayFinalizeRequest {\n    charge_amount: ChargeAmount,\n    shipping_address: AddressDetails,\n    payment_intent: PaymentIntent,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ChargeAmount {\n    amount: StringMajorUnit,\n    currency_code: common_enums::Currency,\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddressDetails {\n    name: Secret<String>,\n    address_line_1: Secret<String>,\n    address_line_2: Option<Secret<String>>,\n    address_line_3: Option<Secret<String>>,\n    city: String,\n    state_or_region: Secret<String>,\n    postal_code: Secret<String>,\n    country_code: Option<common_enums::CountryAlpha2>,\n    phone_number: Secret<String>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\npub enum PaymentIntent {\n    AuthorizeWithCapture,\n}\n\nfn get_amazonpay_capture_type(\n    item: Option<Captu\n\n... [truncated 19820 chars] ...\n\n   reason: Some(\"Amazon has declined the refund because maximum amount has been refunded or there was some other issue.\".to_owned()),\n                status_code: item.http_code,\n                attempt_status: None,\n                connector_transaction_id: Some(item.response.refund_id.clone()),\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            })\n        } else {\n            Ok(RefundsResponseData {\n                connector_refund_id: item.response.refund_id.to_string(),\n                refund_status,\n            })\n        };\n        Ok(Self {\n            response,\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct AmazonpayErrorResponse {\n    pub reason_code: String,\n    pub message: String,\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__amazonpay__transformers.rs", "file": "crates__hyperswitch_connectors__src__connectors__amazonpay__transformers.rs"}, {"query": "how to mask phone numbers in Rust", "code": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse serde::Deserialize;\n\nuse crate::{\n    crypto::Encryptable,\n    errors::{self, ValidationError},\n    validation::{validate_email, validate_phone_number},\n};\n\n/// A string constant representing a redacted or masked value.\npub const REDACTED: &str = \"Redacted\";\n\n/// Type alias for serde_json value which has Secret Information\npub type SecretSerdeValue = Secret<serde_json::Value>;\n\n/// Strategy for masking a PhoneNumber\n#[derive(Debug)]\npub enum PhoneNumberStrategy {}\n\n/// Phone Number\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(try_from = \"String\")]\npub struct PhoneNumber(Secret<String, PhoneNumberStrategy>);\n\nimpl<T> Strategy<T> for PhoneNumberStrategy\nwhere\n    T: AsRef<str> + fmt::Debug,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    }\n}\n\nimpl FromStr for PhoneNumber {\n    type Err = error_stack::Report<ValidationError>;\n    fn from_str(phone_number: &str) -> Result<Self, Self::Err> {\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    }\n}\n\nimpl TryFrom<String> for PhoneNumber {\n    type Error = error_stack::Report<errors::ParsingError>;\n\n \n\n... [truncated 10860 chars] ...\n\n,\n            format!(\"{secret:?}\")\n        );\n    }\n\n    #[test]\n    fn test_invalid_client_secret_masking() {\n        let secret: Secret<String, IpAddress> =\n            Secret::new(\"pay_uszFB2QGe9MmLY65ojhT_secret\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_valid_phone_number_default_masking() {\n        let secret: Secret<String> = Secret::new(\"+40712345678\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_valid_upi_vpa_masking() {\n        let secret: Secret<String, UpiVpaMaskingStrategy> = Secret::new(\"my_name@upi\".to_string());\n        assert_eq!(\"*******@upi\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_invalid_upi_vpa_masking() {\n        let secret: Secret<String, UpiVpaMaskingStrategy> = Secret::new(\"my_name_upi\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n}\n", "function_name": "crates__common_utils__src__pii.rs", "file": "crates__common_utils__src__pii.rs"}, {"query": "PII protection strategy implementation", "code": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse serde::Deserialize;\n\nuse crate::{\n    crypto::Encryptable,\n    errors::{self, ValidationError},\n    validation::{validate_email, validate_phone_number},\n};\n\n/// A string constant representing a redacted or masked value.\npub const REDACTED: &str = \"Redacted\";\n\n/// Type alias for serde_json value which has Secret Information\npub type SecretSerdeValue = Secret<serde_json::Value>;\n\n/// Strategy for masking a PhoneNumber\n#[derive(Debug)]\npub enum PhoneNumberStrategy {}\n\n/// Phone Number\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(try_from = \"String\")]\npub struct PhoneNumber(Secret<String, PhoneNumberStrategy>);\n\nimpl<T> Strategy<T> for PhoneNumberStrategy\nwhere\n    T: AsRef<str> + fmt::Debug,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    }\n}\n\nimpl FromStr for PhoneNumber {\n    type Err = error_stack::Report<ValidationError>;\n    fn from_str(phone_number: &str) -> Result<Self, Self::Err> {\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    }\n}\n\nimpl TryFrom<String> for PhoneNumber {\n    type Error = error_stack::Report<errors::ParsingError>;\n\n \n\n... [truncated 10860 chars] ...\n\n,\n            format!(\"{secret:?}\")\n        );\n    }\n\n    #[test]\n    fn test_invalid_client_secret_masking() {\n        let secret: Secret<String, IpAddress> =\n            Secret::new(\"pay_uszFB2QGe9MmLY65ojhT_secret\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_valid_phone_number_default_masking() {\n        let secret: Secret<String> = Secret::new(\"+40712345678\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_valid_upi_vpa_masking() {\n        let secret: Secret<String, UpiVpaMaskingStrategy> = Secret::new(\"my_name@upi\".to_string());\n        assert_eq!(\"*******@upi\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_invalid_upi_vpa_masking() {\n        let secret: Secret<String, UpiVpaMaskingStrategy> = Secret::new(\"my_name_upi\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n}\n", "function_name": "crates__common_utils__src__pii.rs", "file": "crates__common_utils__src__pii.rs"}, {"query": "how to use Secret type for sensitive data", "code": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse serde::Deserialize;\n\nuse crate::{\n    crypto::Encryptable,\n    errors::{self, ValidationError},\n    validation::{validate_email, validate_phone_number},\n};\n\n/// A string constant representing a redacted or masked value.\npub const REDACTED: &str = \"Redacted\";\n\n/// Type alias for serde_json value which has Secret Information\npub type SecretSerdeValue = Secret<serde_json::Value>;\n\n/// Strategy for masking a PhoneNumber\n#[derive(Debug)]\npub enum PhoneNumberStrategy {}\n\n/// Phone Number\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(try_from = \"String\")]\npub struct PhoneNumber(Secret<String, PhoneNumberStrategy>);\n\nimpl<T> Strategy<T> for PhoneNumberStrategy\nwhere\n    T: AsRef<str> + fmt::Debug,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    }\n}\n\nimpl FromStr for PhoneNumber {\n    type Err = error_stack::Report<ValidationError>;\n    fn from_str(phone_number: &str) -> Result<Self, Self::Err> {\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    }\n}\n\nimpl TryFrom<String> for PhoneNumber {\n    type Error = error_stack::Report<errors::ParsingError>;\n\n \n\n... [truncated 10860 chars] ...\n\n,\n            format!(\"{secret:?}\")\n        );\n    }\n\n    #[test]\n    fn test_invalid_client_secret_masking() {\n        let secret: Secret<String, IpAddress> =\n            Secret::new(\"pay_uszFB2QGe9MmLY65ojhT_secret\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_valid_phone_number_default_masking() {\n        let secret: Secret<String> = Secret::new(\"+40712345678\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_valid_upi_vpa_masking() {\n        let secret: Secret<String, UpiVpaMaskingStrategy> = Secret::new(\"my_name@upi\".to_string());\n        assert_eq!(\"*******@upi\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_invalid_upi_vpa_masking() {\n        let secret: Secret<String, UpiVpaMaskingStrategy> = Secret::new(\"my_name_upi\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n}\n", "function_name": "crates__common_utils__src__pii.rs", "file": "crates__common_utils__src__pii.rs"}, {"query": "masking IP address and client secret", "code": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse serde::Deserialize;\n\nuse crate::{\n    crypto::Encryptable,\n    errors::{self, ValidationError},\n    validation::{validate_email, validate_phone_number},\n};\n\n/// A string constant representing a redacted or masked value.\npub const REDACTED: &str = \"Redacted\";\n\n/// Type alias for serde_json value which has Secret Information\npub type SecretSerdeValue = Secret<serde_json::Value>;\n\n/// Strategy for masking a PhoneNumber\n#[derive(Debug)]\npub enum PhoneNumberStrategy {}\n\n/// Phone Number\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(try_from = \"String\")]\npub struct PhoneNumber(Secret<String, PhoneNumberStrategy>);\n\nimpl<T> Strategy<T> for PhoneNumberStrategy\nwhere\n    T: AsRef<str> + fmt::Debug,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    }\n}\n\nimpl FromStr for PhoneNumber {\n    type Err = error_stack::Report<ValidationError>;\n    fn from_str(phone_number: &str) -> Result<Self, Self::Err> {\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    }\n}\n\nimpl TryFrom<String> for PhoneNumber {\n    type Error = error_stack::Report<errors::ParsingError>;\n\n \n\n... [truncated 10860 chars] ...\n\n,\n            format!(\"{secret:?}\")\n        );\n    }\n\n    #[test]\n    fn test_invalid_client_secret_masking() {\n        let secret: Secret<String, IpAddress> =\n            Secret::new(\"pay_uszFB2QGe9MmLY65ojhT_secret\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_valid_phone_number_default_masking() {\n        let secret: Secret<String> = Secret::new(\"+40712345678\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_valid_upi_vpa_masking() {\n        let secret: Secret<String, UpiVpaMaskingStrategy> = Secret::new(\"my_name@upi\".to_string());\n        assert_eq!(\"*******@upi\", format!(\"{secret:?}\"));\n    }\n\n    #[test]\n    fn test_invalid_upi_vpa_masking() {\n        let secret: Secret<String, UpiVpaMaskingStrategy> = Secret::new(\"my_name_upi\".to_string());\n        assert_eq!(\"*** alloc::string::String ***\", format!(\"{secret:?}\"));\n    }\n}\n", "function_name": "crates__common_utils__src__pii.rs", "file": "crates__common_utils__src__pii.rs"}, {"query": "how to implement Fiservemea payment connector", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse time::OffsetDateTime;\nuse transformers as fiservemea;\nuse uuid::Uuid;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Fiservemea {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Fiservemea {\n    pub fn new(\n\n... [truncated 28603 chars] ...\n\n   },\n        );\n\n        fiservemea_supported_payment_methods\n    });\n\nstatic FISERVEMEA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Fiservemea\",\n    description: \"Fiserv powers over 6+ million merchants and 10,000+ financial institutions enabling them to accept billions of payments a year.\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FISERVEMEA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Fiservemea {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FISERVEMEA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FISERVEMEA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FISERVEMEA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiservemea.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiservemea.rs"}, {"query": "Fiservemea HMAC signature generation", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse time::OffsetDateTime;\nuse transformers as fiservemea;\nuse uuid::Uuid;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Fiservemea {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Fiservemea {\n    pub fn new(\n\n... [truncated 28603 chars] ...\n\n   },\n        );\n\n        fiservemea_supported_payment_methods\n    });\n\nstatic FISERVEMEA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Fiservemea\",\n    description: \"Fiserv powers over 6+ million merchants and 10,000+ financial institutions enabling them to accept billions of payments a year.\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FISERVEMEA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Fiservemea {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FISERVEMEA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FISERVEMEA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FISERVEMEA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiservemea.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiservemea.rs"}, {"query": "hyperswitch Fiservemea integration", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse time::OffsetDateTime;\nuse transformers as fiservemea;\nuse uuid::Uuid;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Fiservemea {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Fiservemea {\n    pub fn new(\n\n... [truncated 28603 chars] ...\n\n   },\n        );\n\n        fiservemea_supported_payment_methods\n    });\n\nstatic FISERVEMEA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Fiservemea\",\n    description: \"Fiserv powers over 6+ million merchants and 10,000+ financial institutions enabling them to accept billions of payments a year.\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FISERVEMEA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Fiservemea {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FISERVEMEA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FISERVEMEA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FISERVEMEA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiservemea.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiservemea.rs"}, {"query": "payment authorization capture refund Fiserv", "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse time::OffsetDateTime;\nuse transformers as fiservemea;\nuse uuid::Uuid;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Fiservemea {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Fiservemea {\n    pub fn new(\n\n... [truncated 28603 chars] ...\n\n   },\n        );\n\n        fiservemea_supported_payment_methods\n    });\n\nstatic FISERVEMEA_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Fiservemea\",\n    description: \"Fiserv powers over 6+ million merchants and 10,000+ financial institutions enabling them to accept billions of payments a year.\",\n    connector_type: enums::HyperswitchConnectorCategory::BankAcquirer,\n    integration_status: enums::ConnectorIntegrationStatus::Sandbox,\n};\n\nstatic FISERVEMEA_SUPPORTED_WEBHOOK_FLOWS: [enums::EventClass; 0] = [];\n\nimpl ConnectorSpecifications for Fiservemea {\n    fn get_connector_about(&self) -> Option<&'static ConnectorInfo> {\n        Some(&FISERVEMEA_CONNECTOR_INFO)\n    }\n\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        Some(&*FISERVEMEA_SUPPORTED_PAYMENT_METHODS)\n    }\n\n    fn get_supported_webhook_flows(&self) -> Option<&'static [enums::EventClass]> {\n        Some(&FISERVEMEA_SUPPORTED_WEBHOOK_FLOWS)\n    }\n}\n", "function_name": "crates__hyperswitch_connectors__src__connectors__fiservemea.rs", "file": "crates__hyperswitch_connectors__src__connectors__fiservemea.rs"}]