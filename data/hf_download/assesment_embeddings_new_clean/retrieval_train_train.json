[{"query": "how to implement validate_psync_reference_id in Zift connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector validation stub"}, {"query": "zift connector validate_psync_reference_id function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector validation stub"}, {"query": "hyperswitch zift validate_psync_reference_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector validation stub"}, {"query": "custom result connector error zift validate_psync_reference_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector validation stub"}, {"query": "Rust function to decide between direct gateway and UCS execution path", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service\npub async fn should_call_unified_connector_service<F: Clone, T, R>(\n    state: &SessionState,\n    processor: &Processor,\n    router_data: &RouterData<F, T, R>,\n    previous_gateway: Option<GatewaySystem>,\n    call_connector_action: CallConnectorAction,\n    shadow_ucs_call_connector_action: Option<CallConnectorAction>,\n) -> RouterResult<(ExecutionPath, SessionState)>\nwhere\n    R: Send + Sync + Clone,\n{\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_name = &router_data.connector;\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {connector_name}\"))?;\n\n    let flow_name = get_flow_name::<F>()?;\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    let rollout_key = build_rollout_keys(\n        merchant_id,\n        connector_name,\n        &flow_name,\n        router_data.payment_method,\n        router_data.payment_method_type,\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // Check rollout key availability and shadow key presence (optimized to reduce DB calls)\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Single decision point using pattern matching\n    let (gateway_system, mut execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        match call_connector_action {\n            CallConnectorAction::UCSConsumeResponse(_)\n            | CallConnectorAction::UCSHandleResponse(_) => {\n                Err(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"CallConnectorAction UCSHandleResponse/UCSConsumeResponse received but UCS is disabled. These actions are only valid in UCS gateway\")?\n            }\n            CallConnectorAction::Avoid\n            | CallConnectorAction::Trigger\n            | CallConnectorAction::HandleResponse(_)\n            | CallConnectorAction::StatusUpdate { .. } => {\n                router_env::logger::debug!(\"UCS is disabled, using Direct gateway\");\n                (GatewaySystem::Direct, ExecutionPath::Direct)\n            }\n        }\n    } else {\n        match call\n\n... [truncated 1975 chars] ...\n\n                );\n                    create_updated_session_state_with_proxy(state.clone(), proxy_override)\n                }\n                None => {\n                    router_env::logger::debug!(\n                        \"No proxy override available for Shadow UCS, Using the Original State and Sending Request Directly\"\n                    );\n                    execution_path = ExecutionPath::Direct;\n                    state.clone()\n                }\n            }\n        }\n        ExecutionPath::Direct | ExecutionPath::UnifiedConnectorService => {\n            // For Direct and UCS flows, use original state\n            state.clone()\n        }\n    };\n\n    router_env::logger::info!(\n        \"Payment gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok((execution_path, session_state))\n}\n\n/// Creates a new SessionState with proxy configuration updated from the override", "function_name": "should_call_unified_connector_service", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Payment routing decision logic"}, {"query": "Hyperswitch should_call_unified_connector_service implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service\npub async fn should_call_unified_connector_service<F: Clone, T, R>(\n    state: &SessionState,\n    processor: &Processor,\n    router_data: &RouterData<F, T, R>,\n    previous_gateway: Option<GatewaySystem>,\n    call_connector_action: CallConnectorAction,\n    shadow_ucs_call_connector_action: Option<CallConnectorAction>,\n) -> RouterResult<(ExecutionPath, SessionState)>\nwhere\n    R: Send + Sync + Clone,\n{\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_name = &router_data.connector;\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {connector_name}\"))?;\n\n    let flow_name = get_flow_name::<F>()?;\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    let rollout_key = build_rollout_keys(\n        merchant_id,\n        connector_name,\n        &flow_name,\n        router_data.payment_method,\n        router_data.payment_method_type,\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // Check rollout key availability and shadow key presence (optimized to reduce DB calls)\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Single decision point using pattern matching\n    let (gateway_system, mut execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        match call_connector_action {\n            CallConnectorAction::UCSConsumeResponse(_)\n            | CallConnectorAction::UCSHandleResponse(_) => {\n                Err(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"CallConnectorAction UCSHandleResponse/UCSConsumeResponse received but UCS is disabled. These actions are only valid in UCS gateway\")?\n            }\n            CallConnectorAction::Avoid\n            | CallConnectorAction::Trigger\n            | CallConnectorAction::HandleResponse(_)\n            | CallConnectorAction::StatusUpdate { .. } => {\n                router_env::logger::debug!(\"UCS is disabled, using Direct gateway\");\n                (GatewaySystem::Direct, ExecutionPath::Direct)\n            }\n        }\n    } else {\n        match call\n\n... [truncated 1975 chars] ...\n\n                );\n                    create_updated_session_state_with_proxy(state.clone(), proxy_override)\n                }\n                None => {\n                    router_env::logger::debug!(\n                        \"No proxy override available for Shadow UCS, Using the Original State and Sending Request Directly\"\n                    );\n                    execution_path = ExecutionPath::Direct;\n                    state.clone()\n                }\n            }\n        }\n        ExecutionPath::Direct | ExecutionPath::UnifiedConnectorService => {\n            // For Direct and UCS flows, use original state\n            state.clone()\n        }\n    };\n\n    router_env::logger::info!(\n        \"Payment gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok((execution_path, session_state))\n}\n\n/// Creates a new SessionState with proxy configuration updated from the override", "function_name": "should_call_unified_connector_service", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Payment routing decision logic"}, {"query": "How to check UCS availability in Hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service\npub async fn should_call_unified_connector_service<F: Clone, T, R>(\n    state: &SessionState,\n    processor: &Processor,\n    router_data: &RouterData<F, T, R>,\n    previous_gateway: Option<GatewaySystem>,\n    call_connector_action: CallConnectorAction,\n    shadow_ucs_call_connector_action: Option<CallConnectorAction>,\n) -> RouterResult<(ExecutionPath, SessionState)>\nwhere\n    R: Send + Sync + Clone,\n{\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_name = &router_data.connector;\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {connector_name}\"))?;\n\n    let flow_name = get_flow_name::<F>()?;\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    let rollout_key = build_rollout_keys(\n        merchant_id,\n        connector_name,\n        &flow_name,\n        router_data.payment_method,\n        router_data.payment_method_type,\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // Check rollout key availability and shadow key presence (optimized to reduce DB calls)\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Single decision point using pattern matching\n    let (gateway_system, mut execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        match call_connector_action {\n            CallConnectorAction::UCSConsumeResponse(_)\n            | CallConnectorAction::UCSHandleResponse(_) => {\n                Err(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"CallConnectorAction UCSHandleResponse/UCSConsumeResponse received but UCS is disabled. These actions are only valid in UCS gateway\")?\n            }\n            CallConnectorAction::Avoid\n            | CallConnectorAction::Trigger\n            | CallConnectorAction::HandleResponse(_)\n            | CallConnectorAction::StatusUpdate { .. } => {\n                router_env::logger::debug!(\"UCS is disabled, using Direct gateway\");\n                (GatewaySystem::Direct, ExecutionPath::Direct)\n            }\n        }\n    } else {\n        match call\n\n... [truncated 1975 chars] ...\n\n                );\n                    create_updated_session_state_with_proxy(state.clone(), proxy_override)\n                }\n                None => {\n                    router_env::logger::debug!(\n                        \"No proxy override available for Shadow UCS, Using the Original State and Sending Request Directly\"\n                    );\n                    execution_path = ExecutionPath::Direct;\n                    state.clone()\n                }\n            }\n        }\n        ExecutionPath::Direct | ExecutionPath::UnifiedConnectorService => {\n            // For Direct and UCS flows, use original state\n            state.clone()\n        }\n    };\n\n    router_env::logger::info!(\n        \"Payment gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok((execution_path, session_state))\n}\n\n/// Creates a new SessionState with proxy configuration updated from the override", "function_name": "should_call_unified_connector_service", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Payment routing decision logic"}, {"query": "Rust payment gateway execution path selection logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service\npub async fn should_call_unified_connector_service<F: Clone, T, R>(\n    state: &SessionState,\n    processor: &Processor,\n    router_data: &RouterData<F, T, R>,\n    previous_gateway: Option<GatewaySystem>,\n    call_connector_action: CallConnectorAction,\n    shadow_ucs_call_connector_action: Option<CallConnectorAction>,\n) -> RouterResult<(ExecutionPath, SessionState)>\nwhere\n    R: Send + Sync + Clone,\n{\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_name = &router_data.connector;\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {connector_name}\"))?;\n\n    let flow_name = get_flow_name::<F>()?;\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    let rollout_key = build_rollout_keys(\n        merchant_id,\n        connector_name,\n        &flow_name,\n        router_data.payment_method,\n        router_data.payment_method_type,\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // Check rollout key availability and shadow key presence (optimized to reduce DB calls)\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Single decision point using pattern matching\n    let (gateway_system, mut execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        match call_connector_action {\n            CallConnectorAction::UCSConsumeResponse(_)\n            | CallConnectorAction::UCSHandleResponse(_) => {\n                Err(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"CallConnectorAction UCSHandleResponse/UCSConsumeResponse received but UCS is disabled. These actions are only valid in UCS gateway\")?\n            }\n            CallConnectorAction::Avoid\n            | CallConnectorAction::Trigger\n            | CallConnectorAction::HandleResponse(_)\n            | CallConnectorAction::StatusUpdate { .. } => {\n                router_env::logger::debug!(\"UCS is disabled, using Direct gateway\");\n                (GatewaySystem::Direct, ExecutionPath::Direct)\n            }\n        }\n    } else {\n        match call\n\n... [truncated 1975 chars] ...\n\n                );\n                    create_updated_session_state_with_proxy(state.clone(), proxy_override)\n                }\n                None => {\n                    router_env::logger::debug!(\n                        \"No proxy override available for Shadow UCS, Using the Original State and Sending Request Directly\"\n                    );\n                    execution_path = ExecutionPath::Direct;\n                    state.clone()\n                }\n            }\n        }\n        ExecutionPath::Direct | ExecutionPath::UnifiedConnectorService => {\n            // For Direct and UCS flows, use original state\n            state.clone()\n        }\n    };\n\n    router_env::logger::info!(\n        \"Payment gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok((execution_path, session_state))\n}\n\n/// Creates a new SessionState with proxy configuration updated from the override", "function_name": "should_call_unified_connector_service", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Payment routing decision logic"}, {"query": "how to revoke mandate in Wells Fargo connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo mandate revoke URL builder"}, {"query": "wellsfargo mandate revoke endpoint url construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo mandate revoke URL builder"}, {"query": "hyperswitch wells fargo mandate revoke function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo mandate revoke URL builder"}, {"query": "get_url mandate revoke router data implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo mandate revoke URL builder"}, {"query": "rust function to mask string keeping last 2 characters", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(src: String) -> Self {\n        let unmasked_char_count = 2;\n        let masked_value = if unmasked_char_count <= src.len() {\n            let len = src.len();\n            // mask every character except the last 2\n            \"*\".repeat(len - unmasked_char_count).to_string()\n                + src\n                    .get(len.saturating_sub(unmasked_char_count)..)\n                    .unwrap_or(\"\")\n        } else {\n            src\n        };\n        Self(Secret::from(masked_value))\n    }\n}", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Secret masking utility"}, {"query": "how to create Secret type from string in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(src: String) -> Self {\n        let unmasked_char_count = 2;\n        let masked_value = if unmasked_char_count <= src.len() {\n            let len = src.len();\n            // mask every character except the last 2\n            \"*\".repeat(len - unmasked_char_count).to_string()\n                + src\n                    .get(len.saturating_sub(unmasked_char_count)..)\n                    .unwrap_or(\"\")\n        } else {\n            src\n        };\n        Self(Secret::from(masked_value))\n    }\n}", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Secret masking utility"}, {"query": "rust code to hide sensitive data except last 2 chars", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(src: String) -> Self {\n        let unmasked_char_count = 2;\n        let masked_value = if unmasked_char_count <= src.len() {\n            let len = src.len();\n            // mask every character except the last 2\n            \"*\".repeat(len - unmasked_char_count).to_string()\n                + src\n                    .get(len.saturating_sub(unmasked_char_count)..)\n                    .unwrap_or(\"\")\n        } else {\n            src\n        };\n        Self(Secret::from(masked_value))\n    }\n}", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Secret masking utility"}, {"query": "hyperswitch common_utils new_type from implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(src: String) -> Self {\n        let unmasked_char_count = 2;\n        let masked_value = if unmasked_char_count <= src.len() {\n            let len = src.len();\n            // mask every character except the last 2\n            \"*\".repeat(len - unmasked_char_count).to_string()\n                + src\n                    .get(len.saturating_sub(unmasked_char_count)..)\n                    .unwrap_or(\"\")\n        } else {\n            src\n        };\n        Self(Secret::from(masked_value))\n    }\n}", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Secret masking utility"}, {"query": "rust hyperswitch amazonpay connector authorization headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay Authorization Headers"}, {"query": "how to configure amazonpay authorization request headers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay Authorization Headers"}, {"query": "hyperswitch amazonpay get_headers function source code rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay Authorization Headers"}, {"query": "amazonpay connector authorization request metadata setup hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay Authorization Headers"}, {"query": "How do I find merchant connector account from webhook authentication id in hyperswitch?", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_mca_from_authentication_id_type\npub async fn find_mca_from_authentication_id_type(\n    state: &SessionState,\n    authentication_id_type: webhooks::AuthenticationIdType,\n    platform: &domain::Platform,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let authentication = match authentication_id_type {\n        webhooks::AuthenticationIdType::AuthenticationId(authentication_id) => db\n            .find_authentication_by_merchant_id_authentication_id(\n                platform.get_processor().get_account().get_id(),\n                &authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?,\n        webhooks::AuthenticationIdType::ConnectorAuthenticationId(connector_authentication_id) => {\n            db.find_authentication_by_merchant_id_connector_authentication_id(\n                platform.get_processor().get_account().get_id().clone(),\n                connector_authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?\n        }\n    };\n    #[cfg(feature = \"v1\")]\n    {\n        // raise error if merchant_connector_id is not present since it should we be present in the current flow\n        let mca_id = authentication\n            .merchant_connector_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"merchant_connector_id not present in authentication record\")?;\n        db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n            platform.get_processor().get_account().get_id(),\n            &mca_id,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(\n            errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                id: mca_id.get_string_repr().to_string(),\n            },\n        )\n    }\n    #[cfg(feature = \"v2\")]\n    //get mca using id\n    {\n        let _ = key_store;\n        let _ = authentication;\n        todo!()\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_mca_from_authentication_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Merchant Connector Account Lookup"}, {"query": "rust hyperswitch find_mca_from_authentication_id_type implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_mca_from_authentication_id_type\npub async fn find_mca_from_authentication_id_type(\n    state: &SessionState,\n    authentication_id_type: webhooks::AuthenticationIdType,\n    platform: &domain::Platform,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let authentication = match authentication_id_type {\n        webhooks::AuthenticationIdType::AuthenticationId(authentication_id) => db\n            .find_authentication_by_merchant_id_authentication_id(\n                platform.get_processor().get_account().get_id(),\n                &authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?,\n        webhooks::AuthenticationIdType::ConnectorAuthenticationId(connector_authentication_id) => {\n            db.find_authentication_by_merchant_id_connector_authentication_id(\n                platform.get_processor().get_account().get_id().clone(),\n                connector_authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?\n        }\n    };\n    #[cfg(feature = \"v1\")]\n    {\n        // raise error if merchant_connector_id is not present since it should we be present in the current flow\n        let mca_id = authentication\n            .merchant_connector_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"merchant_connector_id not present in authentication record\")?;\n        db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n            platform.get_processor().get_account().get_id(),\n            &mca_id,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(\n            errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                id: mca_id.get_string_repr().to_string(),\n            },\n        )\n    }\n    #[cfg(feature = \"v2\")]\n    //get mca using id\n    {\n        let _ = key_store;\n        let _ = authentication;\n        todo!()\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_mca_from_authentication_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Merchant Connector Account Lookup"}, {"query": "hyperswitch router utils find_mca_from_authentication_id_type function", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_mca_from_authentication_id_type\npub async fn find_mca_from_authentication_id_type(\n    state: &SessionState,\n    authentication_id_type: webhooks::AuthenticationIdType,\n    platform: &domain::Platform,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let authentication = match authentication_id_type {\n        webhooks::AuthenticationIdType::AuthenticationId(authentication_id) => db\n            .find_authentication_by_merchant_id_authentication_id(\n                platform.get_processor().get_account().get_id(),\n                &authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?,\n        webhooks::AuthenticationIdType::ConnectorAuthenticationId(connector_authentication_id) => {\n            db.find_authentication_by_merchant_id_connector_authentication_id(\n                platform.get_processor().get_account().get_id().clone(),\n                connector_authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?\n        }\n    };\n    #[cfg(feature = \"v1\")]\n    {\n        // raise error if merchant_connector_id is not present since it should we be present in the current flow\n        let mca_id = authentication\n            .merchant_connector_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"merchant_connector_id not present in authentication record\")?;\n        db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n            platform.get_processor().get_account().get_id(),\n            &mca_id,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(\n            errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                id: mca_id.get_string_repr().to_string(),\n            },\n        )\n    }\n    #[cfg(feature = \"v2\")]\n    //get mca using id\n    {\n        let _ = key_store;\n        let _ = authentication;\n        todo!()\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_mca_from_authentication_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Merchant Connector Account Lookup"}, {"query": "merchant connector account lookup using authentication id type hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_mca_from_authentication_id_type\npub async fn find_mca_from_authentication_id_type(\n    state: &SessionState,\n    authentication_id_type: webhooks::AuthenticationIdType,\n    platform: &domain::Platform,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let authentication = match authentication_id_type {\n        webhooks::AuthenticationIdType::AuthenticationId(authentication_id) => db\n            .find_authentication_by_merchant_id_authentication_id(\n                platform.get_processor().get_account().get_id(),\n                &authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?,\n        webhooks::AuthenticationIdType::ConnectorAuthenticationId(connector_authentication_id) => {\n            db.find_authentication_by_merchant_id_connector_authentication_id(\n                platform.get_processor().get_account().get_id().clone(),\n                connector_authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?\n        }\n    };\n    #[cfg(feature = \"v1\")]\n    {\n        // raise error if merchant_connector_id is not present since it should we be present in the current flow\n        let mca_id = authentication\n            .merchant_connector_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"merchant_connector_id not present in authentication record\")?;\n        db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n            platform.get_processor().get_account().get_id(),\n            &mca_id,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(\n            errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                id: mca_id.get_string_repr().to_string(),\n            },\n        )\n    }\n    #[cfg(feature = \"v2\")]\n    //get mca using id\n    {\n        let _ = key_store;\n        let _ = authentication;\n        todo!()\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_mca_from_authentication_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Merchant Connector Account Lookup"}, {"query": "how to convert euclid graph node to string", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: viz\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.to_string(),\n            Self::MetaData(mv) => format!(\"[{} = {}]\", mv.key, mv.value),\n            Self::MandateAcceptanceType(mat) => mat.to_string(),\n            Self::MandateType(mt) => mt.to_string(),\n            Self::PaymentType(pt) => pt.to_string(),\n            Self::VoucherType(vt) => vt.to_string(),\n            Self::GiftCardType(gct) => gct.to_string(),\n            Self::BusinessLabel(bl) => bl.value.to_string(),\n            Self::SetupFutureUsage(sfu) => sfu.to_string(),\n            Self::CardRedirectType(crt) => crt.to_string(),\n            Self::RealTimePaymentType(rtpt) => rtpt.to_string(),\n            Self::OpenBankingType(ob) => ob.to_string(),\n            Self::MobilePaymentType(mpt) => mpt.to_string(),\n            Self::IssuerName(issuer_name) => issuer_name.value.clone(),\n            Self::IssuerCountry(issuer_country) => issuer_country.to_string(),\n            Self::CustomerDevicePlatform(customer_device_platform) => {\n                customer_device_platform.to_string()\n            }\n            Self::CustomerDeviceType(customer_device_type) => customer_device_type.to_string(),\n            Self::CustomerDeviceDisplaySize(customer_device_display_size) => {\n                customer_device_display_size.to_string()\n            }\n            Self::AcquirerCountry(acquirer_country) => acquirer_country.to_string(),\n            Self::AcquirerFraudRate(acquirer_fraud_rate) => acquirer_fraud_rate.number.to_string(),\n            Self::TransactionInitiator(transaction_initiator) => transaction_initiator.to_string(),\n            Self::NetworkTokenType(ntt) => ntt.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\n#[serde(tag = \"type\", content = \"details\", rename_all = \"snake_case\")]", "function_name": "viz", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Euclid graph polymorphic serialization"}, {"query": "rust euclid viz method implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: viz\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.to_string(),\n            Self::MetaData(mv) => format!(\"[{} = {}]\", mv.key, mv.value),\n            Self::MandateAcceptanceType(mat) => mat.to_string(),\n            Self::MandateType(mt) => mt.to_string(),\n            Self::PaymentType(pt) => pt.to_string(),\n            Self::VoucherType(vt) => vt.to_string(),\n            Self::GiftCardType(gct) => gct.to_string(),\n            Self::BusinessLabel(bl) => bl.value.to_string(),\n            Self::SetupFutureUsage(sfu) => sfu.to_string(),\n            Self::CardRedirectType(crt) => crt.to_string(),\n            Self::RealTimePaymentType(rtpt) => rtpt.to_string(),\n            Self::OpenBankingType(ob) => ob.to_string(),\n            Self::MobilePaymentType(mpt) => mpt.to_string(),\n            Self::IssuerName(issuer_name) => issuer_name.value.clone(),\n            Self::IssuerCountry(issuer_country) => issuer_country.to_string(),\n            Self::CustomerDevicePlatform(customer_device_platform) => {\n                customer_device_platform.to_string()\n            }\n            Self::CustomerDeviceType(customer_device_type) => customer_device_type.to_string(),\n            Self::CustomerDeviceDisplaySize(customer_device_display_size) => {\n                customer_device_display_size.to_string()\n            }\n            Self::AcquirerCountry(acquirer_country) => acquirer_country.to_string(),\n            Self::AcquirerFraudRate(acquirer_fraud_rate) => acquirer_fraud_rate.number.to_string(),\n            Self::TransactionInitiator(transaction_initiator) => transaction_initiator.to_string(),\n            Self::NetworkTokenType(ntt) => ntt.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\n#[serde(tag = \"type\", content = \"details\", rename_all = \"snake_case\")]", "function_name": "viz", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Euclid graph polymorphic serialization"}, {"query": "euclid graph serialization format", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: viz\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.to_string(),\n            Self::MetaData(mv) => format!(\"[{} = {}]\", mv.key, mv.value),\n            Self::MandateAcceptanceType(mat) => mat.to_string(),\n            Self::MandateType(mt) => mt.to_string(),\n            Self::PaymentType(pt) => pt.to_string(),\n            Self::VoucherType(vt) => vt.to_string(),\n            Self::GiftCardType(gct) => gct.to_string(),\n            Self::BusinessLabel(bl) => bl.value.to_string(),\n            Self::SetupFutureUsage(sfu) => sfu.to_string(),\n            Self::CardRedirectType(crt) => crt.to_string(),\n            Self::RealTimePaymentType(rtpt) => rtpt.to_string(),\n            Self::OpenBankingType(ob) => ob.to_string(),\n            Self::MobilePaymentType(mpt) => mpt.to_string(),\n            Self::IssuerName(issuer_name) => issuer_name.value.clone(),\n            Self::IssuerCountry(issuer_country) => issuer_country.to_string(),\n            Self::CustomerDevicePlatform(customer_device_platform) => {\n                customer_device_platform.to_string()\n            }\n            Self::CustomerDeviceType(customer_device_type) => customer_device_type.to_string(),\n            Self::CustomerDeviceDisplaySize(customer_device_display_size) => {\n                customer_device_display_size.to_string()\n            }\n            Self::AcquirerCountry(acquirer_country) => acquirer_country.to_string(),\n            Self::AcquirerFraudRate(acquirer_fraud_rate) => acquirer_fraud_rate.number.to_string(),\n            Self::TransactionInitiator(transaction_initiator) => transaction_initiator.to_string(),\n            Self::NetworkTokenType(ntt) => ntt.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\n#[serde(tag = \"type\", content = \"details\", rename_all = \"snake_case\")]", "function_name": "viz", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Euclid graph polymorphic serialization"}, {"query": "hyperswitch euclid graph to string", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: viz\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.to_string(),\n            Self::MetaData(mv) => format!(\"[{} = {}]\", mv.key, mv.value),\n            Self::MandateAcceptanceType(mat) => mat.to_string(),\n            Self::MandateType(mt) => mt.to_string(),\n            Self::PaymentType(pt) => pt.to_string(),\n            Self::VoucherType(vt) => vt.to_string(),\n            Self::GiftCardType(gct) => gct.to_string(),\n            Self::BusinessLabel(bl) => bl.value.to_string(),\n            Self::SetupFutureUsage(sfu) => sfu.to_string(),\n            Self::CardRedirectType(crt) => crt.to_string(),\n            Self::RealTimePaymentType(rtpt) => rtpt.to_string(),\n            Self::OpenBankingType(ob) => ob.to_string(),\n            Self::MobilePaymentType(mpt) => mpt.to_string(),\n            Self::IssuerName(issuer_name) => issuer_name.value.clone(),\n            Self::IssuerCountry(issuer_country) => issuer_country.to_string(),\n            Self::CustomerDevicePlatform(customer_device_platform) => {\n                customer_device_platform.to_string()\n            }\n            Self::CustomerDeviceType(customer_device_type) => customer_device_type.to_string(),\n            Self::CustomerDeviceDisplaySize(customer_device_display_size) => {\n                customer_device_display_size.to_string()\n            }\n            Self::AcquirerCountry(acquirer_country) => acquirer_country.to_string(),\n            Self::AcquirerFraudRate(acquirer_fraud_rate) => acquirer_fraud_rate.number.to_string(),\n            Self::TransactionInitiator(transaction_initiator) => transaction_initiator.to_string(),\n            Self::NetworkTokenType(ntt) => ntt.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\n#[serde(tag = \"type\", content = \"details\", rename_all = \"snake_case\")]", "function_name": "viz", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Euclid graph polymorphic serialization"}, {"query": "how to configure finix connector headers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector header retrieval"}, {"query": "rust function to get headers for create connector customer", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector header retrieval"}, {"query": "hyperswitch get_headers implementation finix", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector header retrieval"}, {"query": "finix connector authentication header setup hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector header retrieval"}, {"query": "Rust enum for payment transaction lifecycle states", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentStatus\npub enum PaymentStatus {\n    InitiationPending,\n    InitiationPendingRedirectAuth,\n    InitiationPendingRedirectAuthVerification,\n    InitiationPendingRedirectHp,\n    InitiationPendingRedemption,\n    InitiationPendingRedemptionVerification,\n    InitiationProcessing,\n    InitiationCompleted,\n    InitiationRejected,\n    InitiationRejectedInsufficientFunds,\n    InitiationFailed,\n    InitiationDeclined,\n    InitiationExpired,\n    InitiationNoFinalStatusAvailable,\n    SettlementInProgress,\n    SettlementCompleted,\n    SettlementIncomplete,\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(untagged)]", "function_name": "PaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentStatus enum definition"}, {"query": "Hyperswitch PaymentStatus variants definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentStatus\npub enum PaymentStatus {\n    InitiationPending,\n    InitiationPendingRedirectAuth,\n    InitiationPendingRedirectAuthVerification,\n    InitiationPendingRedirectHp,\n    InitiationPendingRedemption,\n    InitiationPendingRedemptionVerification,\n    InitiationProcessing,\n    InitiationCompleted,\n    InitiationRejected,\n    InitiationRejectedInsufficientFunds,\n    InitiationFailed,\n    InitiationDeclined,\n    InitiationExpired,\n    InitiationNoFinalStatusAvailable,\n    SettlementInProgress,\n    SettlementCompleted,\n    SettlementIncomplete,\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(untagged)]", "function_name": "PaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentStatus enum definition"}, {"query": "How to handle different payment status transitions in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentStatus\npub enum PaymentStatus {\n    InitiationPending,\n    InitiationPendingRedirectAuth,\n    InitiationPendingRedirectAuthVerification,\n    InitiationPendingRedirectHp,\n    InitiationPendingRedemption,\n    InitiationPendingRedemptionVerification,\n    InitiationProcessing,\n    InitiationCompleted,\n    InitiationRejected,\n    InitiationRejectedInsufficientFunds,\n    InitiationFailed,\n    InitiationDeclined,\n    InitiationExpired,\n    InitiationNoFinalStatusAvailable,\n    SettlementInProgress,\n    SettlementCompleted,\n    SettlementIncomplete,\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(untagged)]", "function_name": "PaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentStatus enum definition"}, {"query": "List of all Hyperswitch payment status enums", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentStatus\npub enum PaymentStatus {\n    InitiationPending,\n    InitiationPendingRedirectAuth,\n    InitiationPendingRedirectAuthVerification,\n    InitiationPendingRedirectHp,\n    InitiationPendingRedemption,\n    InitiationPendingRedemptionVerification,\n    InitiationProcessing,\n    InitiationCompleted,\n    InitiationRejected,\n    InitiationRejectedInsufficientFunds,\n    InitiationFailed,\n    InitiationDeclined,\n    InitiationExpired,\n    InitiationNoFinalStatusAvailable,\n    SettlementInProgress,\n    SettlementCompleted,\n    SettlementIncomplete,\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(untagged)]", "function_name": "PaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentStatus enum definition"}, {"query": "Airwallex connector implementation Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: Airwallex\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "Airwallex", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex connector integration"}, {"query": "how to implement Airwallex payment gateway integration in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: Airwallex\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "Airwallex", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex connector integration"}, {"query": "hyperswitch Airwallex connector trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: Airwallex\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "Airwallex", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex connector integration"}, {"query": "Airwallex payment orchestration Rust connector code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: Airwallex\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "Airwallex", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex connector integration"}, {"query": "how to get domain from email string in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: extract_domain\n    pub fn extract_domain(&self) -> UserResult<&str> {\n        let (_username, domain) = self\n            .peek()\n            .split_once('@')\n            .ok_or(UserErrors::InternalServerError)?;\n\n        Ok(domain)\n    }\n}\n", "function_name": "extract_domain", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "extract domain from email"}, {"query": "rust extract domain from email function", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: extract_domain\n    pub fn extract_domain(&self) -> UserResult<&str> {\n        let (_username, domain) = self\n            .peek()\n            .split_once('@')\n            .ok_or(UserErrors::InternalServerError)?;\n\n        Ok(domain)\n    }\n}\n", "function_name": "extract_domain", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "extract domain from email"}, {"query": "hyperswitch extract domain from user email", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: extract_domain\n    pub fn extract_domain(&self) -> UserResult<&str> {\n        let (_username, domain) = self\n            .peek()\n            .split_once('@')\n            .ok_or(UserErrors::InternalServerError)?;\n\n        Ok(domain)\n    }\n}\n", "function_name": "extract_domain", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "extract domain from email"}, {"query": "rust split string at @ and get domain", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: extract_domain\n    pub fn extract_domain(&self) -> UserResult<&str> {\n        let (_username, domain) = self\n            .peek()\n            .split_once('@')\n            .ok_or(UserErrors::InternalServerError)?;\n\n        Ok(domain)\n    }\n}\n", "function_name": "extract_domain", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "extract domain from email"}, {"query": "how to configure content type for globepay connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay connector header builder"}, {"query": "globepay rust connector build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay connector header builder"}, {"query": "hyperswitch globepay header configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay connector header builder"}, {"query": "rust globepay connector content type setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay connector header builder"}, {"query": "rust hyperswitch payone connector trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payone\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payone\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    #[cfg(feature = \"payouts\")]", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone connector integration trait"}, {"query": "hyperswitch payone payment method tokenization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payone\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payone\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    #[cfg(feature = \"payouts\")]", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone connector integration trait"}, {"query": "how to implement payone connector in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payone\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payone\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    #[cfg(feature = \"payouts\")]", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone connector integration trait"}, {"query": "hyperswitch payone payouts feature connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payone\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payone\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    #[cfg(feature = \"payouts\")]", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone connector integration trait"}, {"query": "thunes connector get_url rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector URL stub"}, {"query": "hyperswitch thunes payment gateway url configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector URL stub"}, {"query": "rust function get_url not implemented thunes", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector URL stub"}, {"query": "PaymentsAuthorizeRouterData thunes connector implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector URL stub"}, {"query": "nordea connector build_request rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.common_get_content_type().to_string();\n        let http_method = Method::Post;\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n\n        let request_body = self.get_request_body(req, connectors)?;\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        let sha256_digest = self.generate_digest_from_request(&request_body);\n\n        // Add Digest header\n        required_headers.push((\n            \"Digest\".to_string(),\n            sha256_digest.to_string().into_masked(),\n        ));\n\n        let signature = self.generate_signature(\n            &auth,\n            SignatureParams {\n                content_type: &content_type,\n                host: &nordea_host,\n                path,\n                payload_digest: Some(&sha256_digest),\n                date: &nordea_origin_date,\n                http_method,\n            },\n        )?;\n\n        required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n\n        let request = Some(\n            RequestBuilder::new()\n                .method(http_method)\n                .attach_default_headers()\n                .headers(required_headers)\n                .url(&AuthenticationTokenType::get_url(self, req, connectors)?)\n                .set_body(request_body)\n                .build(),\n        );\n        Ok(request)\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea connector request builder"}, {"query": "how to generate signature for nordea api request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.common_get_content_type().to_string();\n        let http_method = Method::Post;\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n\n        let request_body = self.get_request_body(req, connectors)?;\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        let sha256_digest = self.generate_digest_from_request(&request_body);\n\n        // Add Digest header\n        required_headers.push((\n            \"Digest\".to_string(),\n            sha256_digest.to_string().into_masked(),\n        ));\n\n        let signature = self.generate_signature(\n            &auth,\n            SignatureParams {\n                content_type: &content_type,\n                host: &nordea_host,\n                path,\n                payload_digest: Some(&sha256_digest),\n                date: &nordea_origin_date,\n                http_method,\n            },\n        )?;\n\n        required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n\n        let request = Some(\n            RequestBuilder::new()\n                .method(http_method)\n                .attach_default_headers()\n                .headers(required_headers)\n                .url(&AuthenticationTokenType::get_url(self, req, connectors)?)\n                .set_body(request_body)\n                .build(),\n        );\n        Ok(request)\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea connector request builder"}, {"query": "nordea authentication header generation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.common_get_content_type().to_string();\n        let http_method = Method::Post;\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n\n        let request_body = self.get_request_body(req, connectors)?;\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        let sha256_digest = self.generate_digest_from_request(&request_body);\n\n        // Add Digest header\n        required_headers.push((\n            \"Digest\".to_string(),\n            sha256_digest.to_string().into_masked(),\n        ));\n\n        let signature = self.generate_signature(\n            &auth,\n            SignatureParams {\n                content_type: &content_type,\n                host: &nordea_host,\n                path,\n                payload_digest: Some(&sha256_digest),\n                date: &nordea_origin_date,\n                http_method,\n            },\n        )?;\n\n        required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n\n        let request = Some(\n            RequestBuilder::new()\n                .method(http_method)\n                .attach_default_headers()\n                .headers(required_headers)\n                .url(&AuthenticationTokenType::get_url(self, req, connectors)?)\n                .set_body(request_body)\n                .build(),\n        );\n        Ok(request)\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea connector request builder"}, {"query": "nordea payment gateway request builder rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.common_get_content_type().to_string();\n        let http_method = Method::Post;\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n\n        let request_body = self.get_request_body(req, connectors)?;\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        let sha256_digest = self.generate_digest_from_request(&request_body);\n\n        // Add Digest header\n        required_headers.push((\n            \"Digest\".to_string(),\n            sha256_digest.to_string().into_masked(),\n        ));\n\n        let signature = self.generate_signature(\n            &auth,\n            SignatureParams {\n                content_type: &content_type,\n                host: &nordea_host,\n                path,\n                payload_digest: Some(&sha256_digest),\n                date: &nordea_origin_date,\n                http_method,\n            },\n        )?;\n\n        required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n\n        let request = Some(\n            RequestBuilder::new()\n                .method(http_method)\n                .attach_default_headers()\n                .headers(required_headers)\n                .url(&AuthenticationTokenType::get_url(self, req, connectors)?)\n                .set_body(request_body)\n                .build(),\n        );\n        Ok(request)\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea connector request builder"}, {"query": "how to handle Globepay connector errors in Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay error handler"}, {"query": "implementing get_error_response for custom payment connectors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay error handler"}, {"query": "hyperswitch globepay connector error handling pattern", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay error handler"}, {"query": "Rust function to build error response from HTTP response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay error handler"}, {"query": "Rust struct definition for initiating payments in Hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentInitiation\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "PaymentInitiation", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentInitiation struct TokenIO"}, {"query": "TokenIO connector PaymentInitiation struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentInitiation\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "PaymentInitiation", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentInitiation struct TokenIO"}, {"query": "Hyperswitch payment initiation data model Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentInitiation\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "PaymentInitiation", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentInitiation struct TokenIO"}, {"query": "How to construct PaymentInitiation struct for TokenIO", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentInitiation\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "PaymentInitiation", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentInitiation struct TokenIO"}, {"query": "Rust function to convert PayMe sale query error response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_sale_query_error_response\nfn get_sale_query_error_response(\n    (sale_query_response, http_code): (&SaleQuery, u16),\n) -> ErrorResponse {\n    ErrorResponse {\n        code: sale_query_response\n            .sale_error_code\n            .clone()\n            .unwrap_or(consts::NO_ERROR_CODE.to_string()),\n        message: sale_query_response\n            .sale_error_text\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: sale_query_response.sale_error_text.clone(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(sale_query_response.sale_payme_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "function_name": "get_sale_query_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe sale query error transformer"}, {"query": "hyperswitch PayMe connector error handling code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_sale_query_error_response\nfn get_sale_query_error_response(\n    (sale_query_response, http_code): (&SaleQuery, u16),\n) -> ErrorResponse {\n    ErrorResponse {\n        code: sale_query_response\n            .sale_error_code\n            .clone()\n            .unwrap_or(consts::NO_ERROR_CODE.to_string()),\n        message: sale_query_response\n            .sale_error_text\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: sale_query_response.sale_error_text.clone(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(sale_query_response.sale_payme_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "function_name": "get_sale_query_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe sale query error transformer"}, {"query": "how to map PayMe sale error to hyperswitch ErrorResponse", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_sale_query_error_response\nfn get_sale_query_error_response(\n    (sale_query_response, http_code): (&SaleQuery, u16),\n) -> ErrorResponse {\n    ErrorResponse {\n        code: sale_query_response\n            .sale_error_code\n            .clone()\n            .unwrap_or(consts::NO_ERROR_CODE.to_string()),\n        message: sale_query_response\n            .sale_error_text\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: sale_query_response.sale_error_text.clone(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(sale_query_response.sale_payme_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "function_name": "get_sale_query_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe sale query error transformer"}, {"query": "PayMe sale query error response transformer implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_sale_query_error_response\nfn get_sale_query_error_response(\n    (sale_query_response, http_code): (&SaleQuery, u16),\n) -> ErrorResponse {\n    ErrorResponse {\n        code: sale_query_response\n            .sale_error_code\n            .clone()\n            .unwrap_or(consts::NO_ERROR_CODE.to_string()),\n        message: sale_query_response\n            .sale_error_text\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: sale_query_response.sale_error_text.clone(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(sale_query_response.sale_payme_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "function_name": "get_sale_query_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe sale query error transformer"}, {"query": "how to format payout request body for payone connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.destination_currency,\n        )?;\n        let connector_router_data = payone::PayoneRouterData::from((amount, req));\n        let connector_req = payone::PayonePayoutFulfillRequest::try_from(connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone payout request builder"}, {"query": "convert amount for payone payout fulfillment request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.destination_currency,\n        )?;\n        let connector_router_data = payone::PayoneRouterData::from((amount, req));\n        let connector_req = payone::PayonePayoutFulfillRequest::try_from(connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone payout request builder"}, {"query": "payone connector payout request payload structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.destination_currency,\n        )?;\n        let connector_router_data = payone::PayoneRouterData::from((amount, req));\n        let connector_req = payone::PayonePayoutFulfillRequest::try_from(connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone payout request builder"}, {"query": "rust payone payout fulfillment request builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.destination_currency,\n        )?;\n        let connector_router_data = payone::PayoneRouterData::from((amount, req));\n        let connector_req = payone::PayonePayoutFulfillRequest::try_from(connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone payout request builder"}, {"query": "how to configure Klarna merchant URLs in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: MerchantURLs\npub struct MerchantURLs {\n    terms: String,\n    checkout: String,\n    confirmation: String,\n    push: String,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "function_name": "MerchantURLs", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna merchant URLs struct"}, {"query": "Klarna push notification URL configuration hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: MerchantURLs\npub struct MerchantURLs {\n    terms: String,\n    checkout: String,\n    confirmation: String,\n    push: String,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "function_name": "MerchantURLs", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna merchant URLs struct"}, {"query": "hyperswitch Klarna connector merchant urls struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: MerchantURLs\npub struct MerchantURLs {\n    terms: String,\n    checkout: String,\n    confirmation: String,\n    push: String,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "function_name": "MerchantURLs", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna merchant URLs struct"}, {"query": "Klarna checkout confirmation URL hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: MerchantURLs\npub struct MerchantURLs {\n    terms: String,\n    checkout: String,\n    confirmation: String,\n    push: String,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "function_name": "MerchantURLs", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna merchant URLs struct"}, {"query": "How do I access wallet data from PaymentMethodData?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_wallet_data\n    pub fn get_wallet_data(&self) -> Option<&WalletData> {\n        if let Self::Wallet(wallet_data) = self {\n            Some(wallet_data)\n        } else {\n            None\n        }\n    }\n", "function_name": "get_wallet_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Wallet data accessor"}, {"query": "Rust hyperswitch get_wallet_data function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_wallet_data\n    pub fn get_wallet_data(&self) -> Option<&WalletData> {\n        if let Self::Wallet(wallet_data) = self {\n            Some(wallet_data)\n        } else {\n            None\n        }\n    }\n", "function_name": "get_wallet_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Wallet data accessor"}, {"query": "Retrieve wallet configuration from PaymentMethodData enum", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_wallet_data\n    pub fn get_wallet_data(&self) -> Option<&WalletData> {\n        if let Self::Wallet(wallet_data) = self {\n            Some(wallet_data)\n        } else {\n            None\n        }\n    }\n", "function_name": "get_wallet_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Wallet data accessor"}, {"query": "hyperswitch domain models wallet data accessor", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_wallet_data\n    pub fn get_wallet_data(&self) -> Option<&WalletData> {\n        if let Self::Wallet(wallet_data) = self {\n            Some(wallet_data)\n        } else {\n            None\n        }\n    }\n", "function_name": "get_wallet_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Wallet data accessor"}, {"query": "rust hyperswitch redsys connector build_headers function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                \"application/xml\".to_string().into(),\n            ),\n            (\n                headers::SOAP_ACTION.to_string(),\n                redsys::REDSYS_SOAP_ACTION.to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys SOAP header builder"}, {"query": "how to configure SOAP headers for redsys payment gateway in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                \"application/xml\".to_string().into(),\n            ),\n            (\n                headers::SOAP_ACTION.to_string(),\n                redsys::REDSYS_SOAP_ACTION.to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys SOAP header builder"}, {"query": "hyperswitch redsys build_headers implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                \"application/xml\".to_string().into(),\n            ),\n            (\n                headers::SOAP_ACTION.to_string(),\n                redsys::REDSYS_SOAP_ACTION.to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys SOAP header builder"}, {"query": "redsys connector hyperswitch SOAP action header configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                \"application/xml\".to_string().into(),\n            ),\n            (\n                headers::SOAP_ACTION.to_string(),\n                redsys::REDSYS_SOAP_ACTION.to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys SOAP header builder"}, {"query": "rust hyperswitch QueryBuildingError enum definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: QueryBuildingError\npub enum QueryBuildingError {\n    #[allow(dead_code)]\n    #[error(\"Not Implemented: {0}\")]\n    NotImplemented(String),\n    #[error(\"Failed to Serialize to SQL\")]\n    SqlSerializeError,\n    #[error(\"Failed to build sql query: {0}\")]\n    InvalidQuery(&'static str),\n}\n\n#[derive(thiserror::Error, Debug)]", "function_name": "QueryBuildingError", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "QueryBuildingError enum definition"}, {"query": "hyperswitch analytics query builder error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: QueryBuildingError\npub enum QueryBuildingError {\n    #[allow(dead_code)]\n    #[error(\"Not Implemented: {0}\")]\n    NotImplemented(String),\n    #[error(\"Failed to Serialize to SQL\")]\n    SqlSerializeError,\n    #[error(\"Failed to build sql query: {0}\")]\n    InvalidQuery(&'static str),\n}\n\n#[derive(thiserror::Error, Debug)]", "function_name": "QueryBuildingError", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "QueryBuildingError enum definition"}, {"query": "QueryBuildingError SqlSerializeError InvalidQuery variants", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: QueryBuildingError\npub enum QueryBuildingError {\n    #[allow(dead_code)]\n    #[error(\"Not Implemented: {0}\")]\n    NotImplemented(String),\n    #[error(\"Failed to Serialize to SQL\")]\n    SqlSerializeError,\n    #[error(\"Failed to build sql query: {0}\")]\n    InvalidQuery(&'static str),\n}\n\n#[derive(thiserror::Error, Debug)]", "function_name": "QueryBuildingError", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "QueryBuildingError enum definition"}, {"query": "hyperswitch rust error types analytics module", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: QueryBuildingError\npub enum QueryBuildingError {\n    #[allow(dead_code)]\n    #[error(\"Not Implemented: {0}\")]\n    NotImplemented(String),\n    #[error(\"Failed to Serialize to SQL\")]\n    SqlSerializeError,\n    #[error(\"Failed to build sql query: {0}\")]\n    InvalidQuery(&'static str),\n}\n\n#[derive(thiserror::Error, Debug)]", "function_name": "QueryBuildingError", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "QueryBuildingError enum definition"}, {"query": "how to configure Barclaycard authentication endpoint URL in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}risk/v1/authentication-setups\",\n            ConnectorCommon::base_url(self, connectors)\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard Auth URL Builder"}, {"query": "hyperswitch barclaycard connector get_url implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}risk/v1/authentication-setups\",\n            ConnectorCommon::base_url(self, connectors)\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard Auth URL Builder"}, {"query": "barclaycard risk v1 authentication setups hyperswitch url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}risk/v1/authentication-setups\",\n            ConnectorCommon::base_url(self, connectors)\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard Auth URL Builder"}, {"query": "hyperswitch connector base_url barclaycard authentication", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}risk/v1/authentication-setups\",\n            ConnectorCommon::base_url(self, connectors)\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard Auth URL Builder"}, {"query": "rust hyperswitch find_refund_by_merchant_id_connector_transaction_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_transaction_id\n    async fn find_refund_by_merchant_id_connector_transaction_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_transaction_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v2\")]", "function_name": "find_refund_by_merchant_id_connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund lookup by connector transaction"}, {"query": "how to get refunds by connector transaction id in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_transaction_id\n    async fn find_refund_by_merchant_id_connector_transaction_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_transaction_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v2\")]", "function_name": "find_refund_by_merchant_id_connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund lookup by connector transaction"}, {"query": "hyperswitch router storage error refund lookup", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_transaction_id\n    async fn find_refund_by_merchant_id_connector_transaction_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_transaction_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v2\")]", "function_name": "find_refund_by_merchant_id_connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund lookup by connector transaction"}, {"query": "rust function to find refunds by merchant id connector id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_transaction_id\n    async fn find_refund_by_merchant_id_connector_transaction_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_transaction_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v2\")]", "function_name": "find_refund_by_merchant_id_connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund lookup by connector transaction"}, {"query": "how to implement helcim verify request in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = helcim::HelcimVerifyRequest::try_from(req)?;\n\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Verify Request Mapper"}, {"query": "helcim connector setup mandate router data transformation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = helcim::HelcimVerifyRequest::try_from(req)?;\n\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Verify Request Mapper"}, {"query": "hyperswitch helcim verify request body structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = helcim::HelcimVerifyRequest::try_from(req)?;\n\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Verify Request Mapper"}, {"query": "rust function get_request_body helcim hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = helcim::HelcimVerifyRequest::try_from(req)?;\n\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Verify Request Mapper"}, {"query": "rust hyperswitch gpayments connector authentication request builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let gpayments_auth_type = gpayments::GpaymentsAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(gpayments_auth_type.certificate))\n                .add_certificate_key(Some(gpayments_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth request builder"}, {"query": "how to configure gpayments client certificate in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let gpayments_auth_type = gpayments::GpaymentsAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(gpayments_auth_type.certificate))\n                .add_certificate_key(Some(gpayments_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth request builder"}, {"query": "hyperswitch build_request function for gpayments authentication", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let gpayments_auth_type = gpayments::GpaymentsAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(gpayments_auth_type.certificate))\n                .add_certificate_key(Some(gpayments_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth request builder"}, {"query": "rust hyperswitch connector authentication request setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let gpayments_auth_type = gpayments::GpaymentsAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(gpayments_auth_type.certificate))\n                .add_certificate_key(Some(gpayments_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth request builder"}, {"query": "Hyperswitch PaymentsPostSessionTokensData struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsPostSessionTokensData\npub struct PaymentsPostSessionTokensData {\n    // amount here would include amount, surcharge_amount and shipping_cost\n    pub amount: MinorUnit,\n    /// original amount sent by the merchant\n    pub order_amount: MinorUnit,\n    pub currency: storage_enums::Currency,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n    /// if the connector provides support to accept multiple reference ids.\n    /// In case the connector supports only one reference id, Hyperswitch's Payment ID will be sent as reference.\n    pub merchant_order_reference_id: Option<String>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub router_return_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "PaymentsPostSessionTokensData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Router request payload struct"}, {"query": "Rust struct for POST /payments/session-tokens payload", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsPostSessionTokensData\npub struct PaymentsPostSessionTokensData {\n    // amount here would include amount, surcharge_amount and shipping_cost\n    pub amount: MinorUnit,\n    /// original amount sent by the merchant\n    pub order_amount: MinorUnit,\n    pub currency: storage_enums::Currency,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n    /// if the connector provides support to accept multiple reference ids.\n    /// In case the connector supports only one reference id, Hyperswitch's Payment ID will be sent as reference.\n    pub merchant_order_reference_id: Option<String>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub router_return_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "PaymentsPostSessionTokensData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Router request payload struct"}, {"query": "Hyperswitch router request types amount shipping_cost", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsPostSessionTokensData\npub struct PaymentsPostSessionTokensData {\n    // amount here would include amount, surcharge_amount and shipping_cost\n    pub amount: MinorUnit,\n    /// original amount sent by the merchant\n    pub order_amount: MinorUnit,\n    pub currency: storage_enums::Currency,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n    /// if the connector provides support to accept multiple reference ids.\n    /// In case the connector supports only one reference id, Hyperswitch's Payment ID will be sent as reference.\n    pub merchant_order_reference_id: Option<String>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub router_return_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "PaymentsPostSessionTokensData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Router request payload struct"}, {"query": "PaymentsPostSessionTokensData merchant_order_reference_id field", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsPostSessionTokensData\npub struct PaymentsPostSessionTokensData {\n    // amount here would include amount, surcharge_amount and shipping_cost\n    pub amount: MinorUnit,\n    /// original amount sent by the merchant\n    pub order_amount: MinorUnit,\n    pub currency: storage_enums::Currency,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n    /// if the connector provides support to accept multiple reference ids.\n    /// In case the connector supports only one reference id, Hyperswitch's Payment ID will be sent as reference.\n    pub merchant_order_reference_id: Option<String>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub router_return_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "PaymentsPostSessionTokensData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Router request payload struct"}, {"query": "rust hyperswitch find_refund_by_payment_id_merchant_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_payment_id_merchant_id\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_payment_id_merchant_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Router Refund Data Access"}, {"query": "hyperswitch router storage refund query function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_payment_id_merchant_id\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_payment_id_merchant_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Router Refund Data Access"}, {"query": "how to get refunds by payment id in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_payment_id_merchant_id\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_payment_id_merchant_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Router Refund Data Access"}, {"query": "hyperswitch find_refund_by_payment_id_merchant_id storage_scheme", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_payment_id_merchant_id\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_payment_id_merchant_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Router Refund Data Access"}, {"query": "how to mask sensitive card numbers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_apply_mask_fn\n    fn test_apply_mask_fn() {\n        let value = \"12345678901\".to_string();\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}", "function_name": "test_apply_mask_fn", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Data masking utility tests"}, {"query": "rust apply_mask function test cases", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_apply_mask_fn\n    fn test_apply_mask_fn() {\n        let value = \"12345678901\".to_string();\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}", "function_name": "test_apply_mask_fn", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Data masking utility tests"}, {"query": "hyperswitch common_utils data sanitization", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_apply_mask_fn\n    fn test_apply_mask_fn() {\n        let value = \"12345678901\".to_string();\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}", "function_name": "test_apply_mask_fn", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Data masking utility tests"}, {"query": "test_apply_mask_fn implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_apply_mask_fn\n    fn test_apply_mask_fn() {\n        let value = \"12345678901\".to_string();\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}", "function_name": "test_apply_mask_fn", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Data masking utility tests"}, {"query": "How do I extract the event ID from a Worldpay webhook response URL?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_event_data\n    pub fn get_event_data(&self) -> Option<String> {\n        self.href\n            .clone()\n            .expose()\n            .rsplit_once('/')\n            .map(|h| h.1.to_string())\n    }\n}", "function_name": "get_event_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay URL segment extractor"}, {"query": "Rust function to get last part of URL string from Worldpay connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_event_data\n    pub fn get_event_data(&self) -> Option<String> {\n        self.href\n            .clone()\n            .expose()\n            .rsplit_once('/')\n            .map(|h| h.1.to_string())\n    }\n}", "function_name": "get_event_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay URL segment extractor"}, {"query": "Worldpay Modular connector get_event_data implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_event_data\n    pub fn get_event_data(&self) -> Option<String> {\n        self.href\n            .clone()\n            .expose()\n            .rsplit_once('/')\n            .map(|h| h.1.to_string())\n    }\n}", "function_name": "get_event_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay URL segment extractor"}, {"query": "Hyperswitch Worldpay response transformer URL parsing logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_event_data\n    pub fn get_event_data(&self) -> Option<String> {\n        self.href\n            .clone()\n            .expose()\n            .rsplit_once('/')\n            .map(|h| h.1.to_string())\n    }\n}", "function_name": "get_event_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay URL segment extractor"}, {"query": "how to format amount for thunes connector rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = thunes::ThunesRouterData::from((amount, req));\n        let connector_req = thunes::ThunesPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes request body builder"}, {"query": "thunes payments request body structure hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = thunes::ThunesRouterData::from((amount, req));\n        let connector_req = thunes::ThunesPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes request body builder"}, {"query": "convert minor amount to thunes format rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = thunes::ThunesRouterData::from((amount, req));\n        let connector_req = thunes::ThunesPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes request body builder"}, {"query": "hyperswitch thunes connector request payload", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = thunes::ThunesRouterData::from((amount, req));\n        let connector_req = thunes::ThunesPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes request body builder"}, {"query": "How to get the connector name from a merchant account in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name\n    pub fn get_connector_name(&self) -> common_enums::connector_enums::Connector {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name\n            }\n        }\n    }\n", "function_name": "get_connector_name", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Rust enum connector name retrieval"}, {"query": "Rust hyperswitch get_connector_name function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name\n    pub fn get_connector_name(&self) -> common_enums::connector_enums::Connector {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name\n            }\n        }\n    }\n", "function_name": "get_connector_name", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Rust enum connector name retrieval"}, {"query": "merchant_connector_account.rs get_connector_name method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name\n    pub fn get_connector_name(&self) -> common_enums::connector_enums::Connector {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name\n            }\n        }\n    }\n", "function_name": "get_connector_name", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Rust enum connector name retrieval"}, {"query": "Hyperswitch Rust enum get_connector_name pattern matching", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name\n    pub fn get_connector_name(&self) -> common_enums::connector_enums::Connector {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name\n            }\n        }\n    }\n", "function_name": "get_connector_name", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Rust enum connector name retrieval"}, {"query": "how to check if a directory value is valid in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_value_validity\n    fn check_value_validity(\n        &self,\n        val: dir::DirValue,\n        analysis_ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<bool, cgraph::GraphError<dir::DirValue>>;\n", "function_name": "check_value_validity", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSA graph validation function"}, {"query": "hyperswitch dsa graph validation function check_value_validity", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_value_validity\n    fn check_value_validity(\n        &self,\n        val: dir::DirValue,\n        analysis_ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<bool, cgraph::GraphError<dir::DirValue>>;\n", "function_name": "check_value_validity", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSA graph validation function"}, {"query": "rust function check_value_validity analysis context memoization", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_value_validity\n    fn check_value_validity(\n        &self,\n        val: dir::DirValue,\n        analysis_ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<bool, cgraph::GraphError<dir::DirValue>>;\n", "function_name": "check_value_validity", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSA graph validation function"}, {"query": "hyperswitch dsa graph error handling validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_value_validity\n    fn check_value_validity(\n        &self,\n        val: dir::DirValue,\n        analysis_ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<bool, cgraph::GraphError<dir::DirValue>>;\n", "function_name": "check_value_validity", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSA graph validation function"}, {"query": "rust hyperswitch router default sdk_url configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: default\n    fn default() -> Self {\n        Self {\n            #[allow(clippy::expect_used)]\n            sdk_url: url::Url::parse(\"http://localhost:9050/HyperLoader.js\")\n                .expect(\"Failed to parse default SDK URL\"),\n            expiry: 900,\n            ui_config: GenericLinkEnvUiConfig::default(),\n            enabled_payment_methods: HashMap::default(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Clone)]", "function_name": "default", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "router default sdk config"}, {"query": "how to configure HyperLoader SDK URL in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: default\n    fn default() -> Self {\n        Self {\n            #[allow(clippy::expect_used)]\n            sdk_url: url::Url::parse(\"http://localhost:9050/HyperLoader.js\")\n                .expect(\"Failed to parse default SDK URL\"),\n            expiry: 900,\n            ui_config: GenericLinkEnvUiConfig::default(),\n            enabled_payment_methods: HashMap::default(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Clone)]", "function_name": "default", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "router default sdk config"}, {"query": "hyperswitch router default settings function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: default\n    fn default() -> Self {\n        Self {\n            #[allow(clippy::expect_used)]\n            sdk_url: url::Url::parse(\"http://localhost:9050/HyperLoader.js\")\n                .expect(\"Failed to parse default SDK URL\"),\n            expiry: 900,\n            ui_config: GenericLinkEnvUiConfig::default(),\n            enabled_payment_methods: HashMap::default(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Clone)]", "function_name": "default", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "router default sdk config"}, {"query": "set default HyperLoader SDK URL in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: default\n    fn default() -> Self {\n        Self {\n            #[allow(clippy::expect_used)]\n            sdk_url: url::Url::parse(\"http://localhost:9050/HyperLoader.js\")\n                .expect(\"Failed to parse default SDK URL\"),\n            expiry: 900,\n            ui_config: GenericLinkEnvUiConfig::default(),\n            enabled_payment_methods: HashMap::default(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Clone)]", "function_name": "default", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "router default sdk config"}, {"query": "how to configure Netcetera webhook event type in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Ok(IncomingWebhookEvent::ExternalAuthenticationARes)\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook event type extraction"}, {"query": "hyperswitch netcetera connector get_webhook_event_type implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Ok(IncomingWebhookEvent::ExternalAuthenticationARes)\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook event type extraction"}, {"query": "rust hyperswitch netcetera webhook event parsing", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Ok(IncomingWebhookEvent::ExternalAuthenticationARes)\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook event type extraction"}, {"query": "hyperswitch incoming webhook event type extraction netcetera", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Ok(IncomingWebhookEvent::ExternalAuthenticationARes)\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook event type extraction"}, {"query": "how to handle authipay payments authorize response in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: authipay::AuthipayPaymentsResponse = res\n            .response\n            .parse_struct(\"Authipay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay Payments Authorize Response Handler"}, {"query": "authipay connector handle_response function implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: authipay::AuthipayPaymentsResponse = res\n            .response\n            .parse_struct(\"Authipay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay Payments Authorize Response Handler"}, {"query": "rust hyperswitch authipay payments authorize router data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: authipay::AuthipayPaymentsResponse = res\n            .response\n            .parse_struct(\"Authipay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay Payments Authorize Response Handler"}, {"query": "hyperswitch authipay response deserialization connector event", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: authipay::AuthipayPaymentsResponse = res\n            .response\n            .parse_struct(\"Authipay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay Payments Authorize Response Handler"}, {"query": "rust how to group directory values by key in hashmap", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_dir_values\n    pub fn from_dir_values(vals: impl IntoIterator<Item = dir::DirValue>) -> Self {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "function_name": "from_dir_values", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DirMap builder grouping"}, {"query": "hyperswitch DirMap from_dir_values implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_dir_values\n    pub fn from_dir_values(vals: impl IntoIterator<Item = dir::DirValue>) -> Self {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "function_name": "from_dir_values", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DirMap builder grouping"}, {"query": "rust FxHashMap group items by key example", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_dir_values\n    pub fn from_dir_values(vals: impl IntoIterator<Item = dir::DirValue>) -> Self {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "function_name": "from_dir_values", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DirMap builder grouping"}, {"query": "how to aggregate directory values into a map in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_dir_values\n    pub fn from_dir_values(vals: impl IntoIterator<Item = dir::DirValue>) -> Self {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "function_name": "from_dir_values", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DirMap builder grouping"}, {"query": "How to configure SEPA Instant payment methods in Hyperswitch Tokenio connector?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: LocalInstrument\npub enum LocalInstrument {\n    Sepa,\n    SepaInstant,\n    FasterPayments,\n    Elixir,\n    Bankgiro,\n    Plusgiro,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(untagged)]", "function_name": "LocalInstrument", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "LocalInstrument enum definition"}, {"query": "What are the supported LocalInstrument types for Tokenio integration?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: LocalInstrument\npub enum LocalInstrument {\n    Sepa,\n    SepaInstant,\n    FasterPayments,\n    Elixir,\n    Bankgiro,\n    Plusgiro,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(untagged)]", "function_name": "LocalInstrument", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "LocalInstrument enum definition"}, {"query": "Rust enum definition for LocalInstrument in hyperswitch tokenio transformers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: LocalInstrument\npub enum LocalInstrument {\n    Sepa,\n    SepaInstant,\n    FasterPayments,\n    Elixir,\n    Bankgiro,\n    Plusgiro,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(untagged)]", "function_name": "LocalInstrument", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "LocalInstrument enum definition"}, {"query": "Mapping Hyperswitch payment methods to Tokenio LocalInstrument types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: LocalInstrument\npub enum LocalInstrument {\n    Sepa,\n    SepaInstant,\n    FasterPayments,\n    Elixir,\n    Bankgiro,\n    Plusgiro,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(untagged)]", "function_name": "LocalInstrument", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "LocalInstrument enum definition"}, {"query": "how to extract response id from worldpay modular events", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_resource_id\n    pub fn get_resource_id(&self) -> Result<ResponseId, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id())\n    }", "function_name": "get_resource_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Response ID Extraction"}, {"query": "rust function get_resource_id worldpay connector error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_resource_id\n    pub fn get_resource_id(&self) -> Result<ResponseId, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id())\n    }", "function_name": "get_resource_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Response ID Extraction"}, {"query": "hyperswitch worldpay modular response transformer missing field", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_resource_id\n    pub fn get_resource_id(&self) -> Result<ResponseId, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id())\n    }", "function_name": "get_resource_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Response ID Extraction"}, {"query": "worldpay modular connector response id extraction logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_resource_id\n    pub fn get_resource_id(&self) -> Result<ResponseId, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id())\n    }", "function_name": "get_resource_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Response ID Extraction"}, {"query": "How to configure Wise payout bank details in Hyperswitch?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseBankDetails\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,\n    post_code: Option<String>,\n    nationality: Option<String>,\n    account_holder_name: Option<Secret<String>>,\n    email: Option<Email>,\n    account_number: Option<Secret<String>>,\n    city: Option<String>,\n    sort_code: Option<Secret<String>>,\n    iban: Option<Secret<String>>,\n    bic: Option<Secret<String>>,\n    transit_number: Option<Secret<String>>,\n    routing_number: Option<Secret<String>>,\n    abartn: Option<Secret<String>>,\n    swift_code: Option<Secret<String>>,\n    payin_reference: Option<String>,\n    psp_reference: Option<String>,\n    tax_id: Option<String>,\n    order_id: Option<String>,\n    job: Option<String>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "WiseBankDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout bank details struct"}, {"query": "WiseBankDetails struct fields for IBAN and BIC validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseBankDetails\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,\n    post_code: Option<String>,\n    nationality: Option<String>,\n    account_holder_name: Option<Secret<String>>,\n    email: Option<Email>,\n    account_number: Option<Secret<String>>,\n    city: Option<String>,\n    sort_code: Option<Secret<String>>,\n    iban: Option<Secret<String>>,\n    bic: Option<Secret<String>>,\n    transit_number: Option<Secret<String>>,\n    routing_number: Option<Secret<String>>,\n    abartn: Option<Secret<String>>,\n    swift_code: Option<Secret<String>>,\n    payin_reference: Option<String>,\n    psp_reference: Option<String>,\n    tax_id: Option<String>,\n    order_id: Option<String>,\n    job: Option<String>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "WiseBankDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout bank details struct"}, {"query": "Rust struct definition for Wise bank account payout data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseBankDetails\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,\n    post_code: Option<String>,\n    nationality: Option<String>,\n    account_holder_name: Option<Secret<String>>,\n    email: Option<Email>,\n    account_number: Option<Secret<String>>,\n    city: Option<String>,\n    sort_code: Option<Secret<String>>,\n    iban: Option<Secret<String>>,\n    bic: Option<Secret<String>>,\n    transit_number: Option<Secret<String>>,\n    routing_number: Option<Secret<String>>,\n    abartn: Option<Secret<String>>,\n    swift_code: Option<Secret<String>>,\n    payin_reference: Option<String>,\n    psp_reference: Option<String>,\n    tax_id: Option<String>,\n    order_id: Option<String>,\n    job: Option<String>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "WiseBankDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout bank details struct"}, {"query": "Secret<String> usage in WiseBankDetails account_number field", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseBankDetails\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,\n    post_code: Option<String>,\n    nationality: Option<String>,\n    account_holder_name: Option<Secret<String>>,\n    email: Option<Email>,\n    account_number: Option<Secret<String>>,\n    city: Option<String>,\n    sort_code: Option<Secret<String>>,\n    iban: Option<Secret<String>>,\n    bic: Option<Secret<String>>,\n    transit_number: Option<Secret<String>>,\n    routing_number: Option<Secret<String>>,\n    abartn: Option<Secret<String>>,\n    swift_code: Option<Secret<String>>,\n    payin_reference: Option<String>,\n    psp_reference: Option<String>,\n    tax_id: Option<String>,\n    order_id: Option<String>,\n    job: Option<String>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "WiseBankDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout bank details struct"}, {"query": "how to mask bank account numbers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_masked_types\n    fn test_masked_types() {\n        let sort_code = MaskedSortCode::from(\"110011\".to_string());\n        let routing_number = MaskedRoutingNumber::from(\"056008849\".to_string());\n        let bank_account = MaskedBankAccount::from(\"12345678901234\".to_string());\n        let iban = MaskedIban::from(\"NL02ABNA0123456789\".to_string());\n        let upi_vpa = MaskedUpiVpaId::from(\"someusername@okhdfcbank\".to_string());\n\n        // Standard masked data tests\n        assert_eq!(sort_code.0.peek().to_owned(), \"11**11\".to_string());\n        assert_eq!(routing_number.0.peek().to_owned(), \"056***849\".to_string());\n        assert_eq!(\n            bank_account.0.peek().to_owned(),\n            \"1234******1234\".to_string()\n        );\n        assert_eq!(iban.0.peek().to_owned(), \"NL02A********56789\".to_string());\n        assert_eq!(\n            upi_vpa.0.peek().to_owned(),\n            \"so**********@okhdfcbank\".to_string()\n        );\n    }\n\n    #[test]", "function_name": "test_masked_types", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "financial data masking test"}, {"query": "test for masked sort code implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_masked_types\n    fn test_masked_types() {\n        let sort_code = MaskedSortCode::from(\"110011\".to_string());\n        let routing_number = MaskedRoutingNumber::from(\"056008849\".to_string());\n        let bank_account = MaskedBankAccount::from(\"12345678901234\".to_string());\n        let iban = MaskedIban::from(\"NL02ABNA0123456789\".to_string());\n        let upi_vpa = MaskedUpiVpaId::from(\"someusername@okhdfcbank\".to_string());\n\n        // Standard masked data tests\n        assert_eq!(sort_code.0.peek().to_owned(), \"11**11\".to_string());\n        assert_eq!(routing_number.0.peek().to_owned(), \"056***849\".to_string());\n        assert_eq!(\n            bank_account.0.peek().to_owned(),\n            \"1234******1234\".to_string()\n        );\n        assert_eq!(iban.0.peek().to_owned(), \"NL02A********56789\".to_string());\n        assert_eq!(\n            upi_vpa.0.peek().to_owned(),\n            \"so**********@okhdfcbank\".to_string()\n        );\n    }\n\n    #[test]", "function_name": "test_masked_types", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "financial data masking test"}, {"query": "sanitize sensitive data in hyperswitch common utils", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_masked_types\n    fn test_masked_types() {\n        let sort_code = MaskedSortCode::from(\"110011\".to_string());\n        let routing_number = MaskedRoutingNumber::from(\"056008849\".to_string());\n        let bank_account = MaskedBankAccount::from(\"12345678901234\".to_string());\n        let iban = MaskedIban::from(\"NL02ABNA0123456789\".to_string());\n        let upi_vpa = MaskedUpiVpaId::from(\"someusername@okhdfcbank\".to_string());\n\n        // Standard masked data tests\n        assert_eq!(sort_code.0.peek().to_owned(), \"11**11\".to_string());\n        assert_eq!(routing_number.0.peek().to_owned(), \"056***849\".to_string());\n        assert_eq!(\n            bank_account.0.peek().to_owned(),\n            \"1234******1234\".to_string()\n        );\n        assert_eq!(iban.0.peek().to_owned(), \"NL02A********56789\".to_string());\n        assert_eq!(\n            upi_vpa.0.peek().to_owned(),\n            \"so**********@okhdfcbank\".to_string()\n        );\n    }\n\n    #[test]", "function_name": "test_masked_types", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "financial data masking test"}, {"query": "verify masking logic for routing numbers", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_masked_types\n    fn test_masked_types() {\n        let sort_code = MaskedSortCode::from(\"110011\".to_string());\n        let routing_number = MaskedRoutingNumber::from(\"056008849\".to_string());\n        let bank_account = MaskedBankAccount::from(\"12345678901234\".to_string());\n        let iban = MaskedIban::from(\"NL02ABNA0123456789\".to_string());\n        let upi_vpa = MaskedUpiVpaId::from(\"someusername@okhdfcbank\".to_string());\n\n        // Standard masked data tests\n        assert_eq!(sort_code.0.peek().to_owned(), \"11**11\".to_string());\n        assert_eq!(routing_number.0.peek().to_owned(), \"056***849\".to_string());\n        assert_eq!(\n            bank_account.0.peek().to_owned(),\n            \"1234******1234\".to_string()\n        );\n        assert_eq!(iban.0.peek().to_owned(), \"NL02A********56789\".to_string());\n        assert_eq!(\n            upi_vpa.0.peek().to_owned(),\n            \"so**********@okhdfcbank\".to_string()\n        );\n    }\n\n    #[test]", "function_name": "test_masked_types", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "financial data masking test"}, {"query": "elavon connector transaction type enum definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionType\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "TransactionType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon transaction type enum"}, {"query": "hyperswitch elavon cc_sale cc_auth_only mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionType\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "TransactionType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon transaction type enum"}, {"query": "rust enum for elavon payment transaction types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionType\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "TransactionType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon transaction type enum"}, {"query": "elavon api transaction type mapping hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionType\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "TransactionType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon transaction type enum"}, {"query": "how to create a json error response in actix web", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: error_response\n        fn error_response(&self) -> actix_web::HttpResponse<actix_web::body::BoxBody> {\n            use actix_web::http::header;\n\n            actix_web::HttpResponseBuilder::new(self.status_code())\n                .insert_header((header::CONTENT_TYPE, mime::APPLICATION_JSON))\n                .body(self.to_string())\n        }\n    }\n", "function_name": "error_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "actix web error response builder"}, {"query": "actix web error_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: error_response\n        fn error_response(&self) -> actix_web::HttpResponse<actix_web::body::BoxBody> {\n            use actix_web::http::header;\n\n            actix_web::HttpResponseBuilder::new(self.status_code())\n                .insert_header((header::CONTENT_TYPE, mime::APPLICATION_JSON))\n                .body(self.to_string())\n        }\n    }\n", "function_name": "error_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "actix web error response builder"}, {"query": "hyperswitch router error handling actix web", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: error_response\n        fn error_response(&self) -> actix_web::HttpResponse<actix_web::body::BoxBody> {\n            use actix_web::http::header;\n\n            actix_web::HttpResponseBuilder::new(self.status_code())\n                .insert_header((header::CONTENT_TYPE, mime::APPLICATION_JSON))\n                .body(self.to_string())\n        }\n    }\n", "function_name": "error_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "actix web error response builder"}, {"query": "actix_web HttpResponseBuilder json error body", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: error_response\n        fn error_response(&self) -> actix_web::HttpResponse<actix_web::body::BoxBody> {\n            use actix_web::http::header;\n\n            actix_web::HttpResponseBuilder::new(self.status_code())\n                .insert_header((header::CONTENT_TYPE, mime::APPLICATION_JSON))\n                .body(self.to_string())\n        }\n    }\n", "function_name": "error_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "actix web error response builder"}, {"query": "WorldpaymodularCaptureResponse struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularCaptureResponse\npub struct WorldpaymodularCaptureResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularCaptureResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Capture Response Model"}, {"query": "hyperswitch worldpay capture response fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularCaptureResponse\npub struct WorldpaymodularCaptureResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularCaptureResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Capture Response Model"}, {"query": "how to deserialize worldpay modular capture api", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularCaptureResponse\npub struct WorldpaymodularCaptureResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularCaptureResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Capture Response Model"}, {"query": "worldpaymodular payment_id field rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularCaptureResponse\npub struct WorldpaymodularCaptureResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularCaptureResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Capture Response Model"}, {"query": "how to get active payment attempt ids for total count", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_active_attempt_ids_for_total_count\n    async fn get_filtered_active_attempt_ids_for_total_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<String>, Self::Error>;\n}\n\n#[derive(Clone, Debug, PartialEq, router_derive::DebugAsDisplay, Serialize, Deserialize)]", "function_name": "get_filtered_active_attempt_ids_for_total_count", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment attempt ID retrieval"}, {"query": "hyperswitch payment intent fetch constraints active attempts", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_active_attempt_ids_for_total_count\n    async fn get_filtered_active_attempt_ids_for_total_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<String>, Self::Error>;\n}\n\n#[derive(Clone, Debug, PartialEq, router_derive::DebugAsDisplay, Serialize, Deserialize)]", "function_name": "get_filtered_active_attempt_ids_for_total_count", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment attempt ID retrieval"}, {"query": "rust function get_filtered_active_attempt_ids_for_total_count", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_active_attempt_ids_for_total_count\n    async fn get_filtered_active_attempt_ids_for_total_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<String>, Self::Error>;\n}\n\n#[derive(Clone, Debug, PartialEq, router_derive::DebugAsDisplay, Serialize, Deserialize)]", "function_name": "get_filtered_active_attempt_ids_for_total_count", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment attempt ID retrieval"}, {"query": "calculate total count of active payment attempts hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_active_attempt_ids_for_total_count\n    async fn get_filtered_active_attempt_ids_for_total_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<String>, Self::Error>;\n}\n\n#[derive(Clone, Debug, PartialEq, router_derive::DebugAsDisplay, Serialize, Deserialize)]", "function_name": "get_filtered_active_attempt_ids_for_total_count", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment attempt ID retrieval"}, {"query": "How to convert PaymentMethodData to gRPC PaymentMethod in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_unified_connector_service_payment_method\npub fn build_unified_connector_service_payment_method(\n    payment_method_data: hyperswitch_domain_models::payment_method_data::PaymentMethodData,\n    payment_method_type: Option<PaymentMethodType>,\n) -> CustomResult<payments_grpc::PaymentMethod, UnifiedConnectorServiceError> {\n    match payment_method_data {\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::Card(card) => {\n            let card_exp_month = card\n                .get_card_expiry_month_2_digit()\n                .attach_printable(\"Failed to extract 2-digit expiry month from card\")\n                .change_context(UnifiedConnectorServiceError::InvalidDataFormat {\n                    field_name: \"card_exp_month\",\n                })?\n                .peek()\n                .to_string();\n\n            let card_network = card\n                .card_network\n                .clone()\n                .map(payments_grpc::CardNetwork::foreign_from);\n\n            let card_details = CardDetails {\n                card_number: Some(\n                    CardNumber::from_str(&card.card_number.get_card_no()).change_context(\n                        UnifiedConnectorServiceError::RequestEncodingFailedWithReason(\n                            \"Failed to parse card number\".to_string(),\n                        ),\n                    )?,\n                ),\n                card_exp_month: Some(card_exp_month.into()),\n                card_exp_year: Some(card.card_exp_year.expose().into()),\n                card_cvc: Some(card.card_cvc.expose().into()),\n                card_holder_name: card.card_holder_name.map(|name| name.expose().into()),\n                card_issuer: card.card_issuer.clone(),\n                card_network: card_network.map(|card_network| card_network.into()),\n                card_type: card.card_type.clone(),\n                bank_code: card.bank_code.clone(),\n                nick_name: card.nick_name.map(|n| n.expose()),\n                card_issuing_country_alpha2: card.card_issuing_country.clone(),\n            };\n\n            Ok(payments_grpc::PaymentMethod {\n                payment_method: Some(PaymentMethod::Card(card_details)),\n            })\n        }\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::CardRedirect(\n            card_redirect_data,\n        ) => {\n            let card_redirect_type = match card_redirect_data {\n                hyperswitch_domain_models::payment_method_data::CardRedirectData::K\n\n... [truncated 30673 chars] ...\n\n        hyperswitch_domain_models::payment_method_data::BankDebitData::BacsBankDebit {\n                account_number,\n                sort_code,\n                bank_account_holder_name,\n            } => {\n                let bacs = payments_grpc::Bacs {\n                    account_number: Some(account_number.expose().into()),\n                    sort_code: Some(sort_code.expose().into()),\n                    bank_account_holder_name: bank_account_holder_name\n                        .map(|name| name.expose().into()),\n                };\n\n                Ok(payments_grpc::PaymentMethod {\n                    payment_method: Some(PaymentMethod::Bacs(bacs)),\n                })\n            }\n            _ => Err(UnifiedConnectorServiceError::NotImplemented(\n                \"Unimplemented bank debit variant\".to_string(),\n            )\n            .into()),\n        },\n        _ => Err(UnifiedConnectorServiceError::NotImplemented(format!(\n            \"Unimplemented payment method: {payment_method_data:?}\"\n        ))\n        .into()),\n    }\n}\n", "function_name": "build_unified_connector_service_payment_method", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "PaymentMethodData to gRPC conversion"}, {"query": "Rust function to map hyperswitch domain models to payments_grpc", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_unified_connector_service_payment_method\npub fn build_unified_connector_service_payment_method(\n    payment_method_data: hyperswitch_domain_models::payment_method_data::PaymentMethodData,\n    payment_method_type: Option<PaymentMethodType>,\n) -> CustomResult<payments_grpc::PaymentMethod, UnifiedConnectorServiceError> {\n    match payment_method_data {\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::Card(card) => {\n            let card_exp_month = card\n                .get_card_expiry_month_2_digit()\n                .attach_printable(\"Failed to extract 2-digit expiry month from card\")\n                .change_context(UnifiedConnectorServiceError::InvalidDataFormat {\n                    field_name: \"card_exp_month\",\n                })?\n                .peek()\n                .to_string();\n\n            let card_network = card\n                .card_network\n                .clone()\n                .map(payments_grpc::CardNetwork::foreign_from);\n\n            let card_details = CardDetails {\n                card_number: Some(\n                    CardNumber::from_str(&card.card_number.get_card_no()).change_context(\n                        UnifiedConnectorServiceError::RequestEncodingFailedWithReason(\n                            \"Failed to parse card number\".to_string(),\n                        ),\n                    )?,\n                ),\n                card_exp_month: Some(card_exp_month.into()),\n                card_exp_year: Some(card.card_exp_year.expose().into()),\n                card_cvc: Some(card.card_cvc.expose().into()),\n                card_holder_name: card.card_holder_name.map(|name| name.expose().into()),\n                card_issuer: card.card_issuer.clone(),\n                card_network: card_network.map(|card_network| card_network.into()),\n                card_type: card.card_type.clone(),\n                bank_code: card.bank_code.clone(),\n                nick_name: card.nick_name.map(|n| n.expose()),\n                card_issuing_country_alpha2: card.card_issuing_country.clone(),\n            };\n\n            Ok(payments_grpc::PaymentMethod {\n                payment_method: Some(PaymentMethod::Card(card_details)),\n            })\n        }\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::CardRedirect(\n            card_redirect_data,\n        ) => {\n            let card_redirect_type = match card_redirect_data {\n                hyperswitch_domain_models::payment_method_data::CardRedirectData::K\n\n... [truncated 30673 chars] ...\n\n        hyperswitch_domain_models::payment_method_data::BankDebitData::BacsBankDebit {\n                account_number,\n                sort_code,\n                bank_account_holder_name,\n            } => {\n                let bacs = payments_grpc::Bacs {\n                    account_number: Some(account_number.expose().into()),\n                    sort_code: Some(sort_code.expose().into()),\n                    bank_account_holder_name: bank_account_holder_name\n                        .map(|name| name.expose().into()),\n                };\n\n                Ok(payments_grpc::PaymentMethod {\n                    payment_method: Some(PaymentMethod::Bacs(bacs)),\n                })\n            }\n            _ => Err(UnifiedConnectorServiceError::NotImplemented(\n                \"Unimplemented bank debit variant\".to_string(),\n            )\n            .into()),\n        },\n        _ => Err(UnifiedConnectorServiceError::NotImplemented(format!(\n            \"Unimplemented payment method: {payment_method_data:?}\"\n        ))\n        .into()),\n    }\n}\n", "function_name": "build_unified_connector_service_payment_method", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "PaymentMethodData to gRPC conversion"}, {"query": "build_unified_connector_service_payment_method implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_unified_connector_service_payment_method\npub fn build_unified_connector_service_payment_method(\n    payment_method_data: hyperswitch_domain_models::payment_method_data::PaymentMethodData,\n    payment_method_type: Option<PaymentMethodType>,\n) -> CustomResult<payments_grpc::PaymentMethod, UnifiedConnectorServiceError> {\n    match payment_method_data {\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::Card(card) => {\n            let card_exp_month = card\n                .get_card_expiry_month_2_digit()\n                .attach_printable(\"Failed to extract 2-digit expiry month from card\")\n                .change_context(UnifiedConnectorServiceError::InvalidDataFormat {\n                    field_name: \"card_exp_month\",\n                })?\n                .peek()\n                .to_string();\n\n            let card_network = card\n                .card_network\n                .clone()\n                .map(payments_grpc::CardNetwork::foreign_from);\n\n            let card_details = CardDetails {\n                card_number: Some(\n                    CardNumber::from_str(&card.card_number.get_card_no()).change_context(\n                        UnifiedConnectorServiceError::RequestEncodingFailedWithReason(\n                            \"Failed to parse card number\".to_string(),\n                        ),\n                    )?,\n                ),\n                card_exp_month: Some(card_exp_month.into()),\n                card_exp_year: Some(card.card_exp_year.expose().into()),\n                card_cvc: Some(card.card_cvc.expose().into()),\n                card_holder_name: card.card_holder_name.map(|name| name.expose().into()),\n                card_issuer: card.card_issuer.clone(),\n                card_network: card_network.map(|card_network| card_network.into()),\n                card_type: card.card_type.clone(),\n                bank_code: card.bank_code.clone(),\n                nick_name: card.nick_name.map(|n| n.expose()),\n                card_issuing_country_alpha2: card.card_issuing_country.clone(),\n            };\n\n            Ok(payments_grpc::PaymentMethod {\n                payment_method: Some(PaymentMethod::Card(card_details)),\n            })\n        }\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::CardRedirect(\n            card_redirect_data,\n        ) => {\n            let card_redirect_type = match card_redirect_data {\n                hyperswitch_domain_models::payment_method_data::CardRedirectData::K\n\n... [truncated 30673 chars] ...\n\n        hyperswitch_domain_models::payment_method_data::BankDebitData::BacsBankDebit {\n                account_number,\n                sort_code,\n                bank_account_holder_name,\n            } => {\n                let bacs = payments_grpc::Bacs {\n                    account_number: Some(account_number.expose().into()),\n                    sort_code: Some(sort_code.expose().into()),\n                    bank_account_holder_name: bank_account_holder_name\n                        .map(|name| name.expose().into()),\n                };\n\n                Ok(payments_grpc::PaymentMethod {\n                    payment_method: Some(PaymentMethod::Bacs(bacs)),\n                })\n            }\n            _ => Err(UnifiedConnectorServiceError::NotImplemented(\n                \"Unimplemented bank debit variant\".to_string(),\n            )\n            .into()),\n        },\n        _ => Err(UnifiedConnectorServiceError::NotImplemented(format!(\n            \"Unimplemented payment method: {payment_method_data:?}\"\n        ))\n        .into()),\n    }\n}\n", "function_name": "build_unified_connector_service_payment_method", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "PaymentMethodData to gRPC conversion"}, {"query": "Error handling for card data transformation in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_unified_connector_service_payment_method\npub fn build_unified_connector_service_payment_method(\n    payment_method_data: hyperswitch_domain_models::payment_method_data::PaymentMethodData,\n    payment_method_type: Option<PaymentMethodType>,\n) -> CustomResult<payments_grpc::PaymentMethod, UnifiedConnectorServiceError> {\n    match payment_method_data {\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::Card(card) => {\n            let card_exp_month = card\n                .get_card_expiry_month_2_digit()\n                .attach_printable(\"Failed to extract 2-digit expiry month from card\")\n                .change_context(UnifiedConnectorServiceError::InvalidDataFormat {\n                    field_name: \"card_exp_month\",\n                })?\n                .peek()\n                .to_string();\n\n            let card_network = card\n                .card_network\n                .clone()\n                .map(payments_grpc::CardNetwork::foreign_from);\n\n            let card_details = CardDetails {\n                card_number: Some(\n                    CardNumber::from_str(&card.card_number.get_card_no()).change_context(\n                        UnifiedConnectorServiceError::RequestEncodingFailedWithReason(\n                            \"Failed to parse card number\".to_string(),\n                        ),\n                    )?,\n                ),\n                card_exp_month: Some(card_exp_month.into()),\n                card_exp_year: Some(card.card_exp_year.expose().into()),\n                card_cvc: Some(card.card_cvc.expose().into()),\n                card_holder_name: card.card_holder_name.map(|name| name.expose().into()),\n                card_issuer: card.card_issuer.clone(),\n                card_network: card_network.map(|card_network| card_network.into()),\n                card_type: card.card_type.clone(),\n                bank_code: card.bank_code.clone(),\n                nick_name: card.nick_name.map(|n| n.expose()),\n                card_issuing_country_alpha2: card.card_issuing_country.clone(),\n            };\n\n            Ok(payments_grpc::PaymentMethod {\n                payment_method: Some(PaymentMethod::Card(card_details)),\n            })\n        }\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::CardRedirect(\n            card_redirect_data,\n        ) => {\n            let card_redirect_type = match card_redirect_data {\n                hyperswitch_domain_models::payment_method_data::CardRedirectData::K\n\n... [truncated 30673 chars] ...\n\n        hyperswitch_domain_models::payment_method_data::BankDebitData::BacsBankDebit {\n                account_number,\n                sort_code,\n                bank_account_holder_name,\n            } => {\n                let bacs = payments_grpc::Bacs {\n                    account_number: Some(account_number.expose().into()),\n                    sort_code: Some(sort_code.expose().into()),\n                    bank_account_holder_name: bank_account_holder_name\n                        .map(|name| name.expose().into()),\n                };\n\n                Ok(payments_grpc::PaymentMethod {\n                    payment_method: Some(PaymentMethod::Bacs(bacs)),\n                })\n            }\n            _ => Err(UnifiedConnectorServiceError::NotImplemented(\n                \"Unimplemented bank debit variant\".to_string(),\n            )\n            .into()),\n        },\n        _ => Err(UnifiedConnectorServiceError::NotImplemented(format!(\n            \"Unimplemented payment method: {payment_method_data:?}\"\n        ))\n        .into()),\n    }\n}\n", "function_name": "build_unified_connector_service_payment_method", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "PaymentMethodData to gRPC conversion"}, {"query": "How to initialize RouterData for a payment flow in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: RouterData\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_method_token: Option<PaymentMethodToken>,\n    pub recurring_mandate_payment_data: Option<RecurringMandatePaymentData>,\n    pub preprocessing_id: Option<String>,\n    /// This is the balance amount for gift cards or voucher\n    pub payment_method_balance: Option<PaymentMethodBalance>,\n\n    ///for switching between two different versions of the same connector\n    pub connector_api_version: Option<String>,\n\n    /// Contains flow-specific data required to construct a request and send it to the connector.\n    pub request: Request,\n\n    /// Contains flow-specific data that the connector responds with.\n    pub response: Result<Response, ErrorResponse>,\n\n    /// Contains a reference ID that should be sent in the connector request\n    pub connector_request_reference_id: String,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout method data\n    pub payout_method_data: Option<api_models::payouts::PayoutMethodData>,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout's quote ID\n    pub quote_id: Option<String>,\n\n    pub test_mode: Option<bool>,\n    pub connector_http_status_code: Option<u16>,\n    pub external_latency: Option<u128>,\n    /// Contains apple pay flow type simplified or manual\n    pub apple_pay_flow: Option<payment_method_data::ApplePayFlow>,\n\n    \n\n... [truncated 627 chars] ...\n\nunt: Option<MinorUnit>,\n\n    pub integrity_check: Result<(), IntegrityCheckError>,\n\n    pub additional_merchant_data: Option<api_models::admin::AdditionalMerchantData>,\n\n    pub header_payload: Option<payments::HeaderPayload>,\n\n    pub connector_mandate_request_reference_id: Option<String>,\n\n    pub l2_l3_data: Option<Box<L2L3Data>>,\n\n    pub authentication_id: Option<id_type::AuthenticationId>,\n    /// Contains the type of sca exemption required for the transaction\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Contains stringified connector raw response body\n    pub raw_connector_response: Option<Secret<String>>,\n\n    /// Indicates whether the payment ID was provided by the merchant (true),\n    /// or generated internally by Hyperswitch (false)\n    pub is_payment_id_from_merchant: Option<bool>,\n\n    // Document details of the customer consisting of document number and type\n    pub customer_document_details: Option<CustomerDocumentDetails>,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]", "function_name": "RouterData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Payment flow state model"}, {"query": "What fields are required in RouterData for connector integration?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: RouterData\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_method_token: Option<PaymentMethodToken>,\n    pub recurring_mandate_payment_data: Option<RecurringMandatePaymentData>,\n    pub preprocessing_id: Option<String>,\n    /// This is the balance amount for gift cards or voucher\n    pub payment_method_balance: Option<PaymentMethodBalance>,\n\n    ///for switching between two different versions of the same connector\n    pub connector_api_version: Option<String>,\n\n    /// Contains flow-specific data required to construct a request and send it to the connector.\n    pub request: Request,\n\n    /// Contains flow-specific data that the connector responds with.\n    pub response: Result<Response, ErrorResponse>,\n\n    /// Contains a reference ID that should be sent in the connector request\n    pub connector_request_reference_id: String,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout method data\n    pub payout_method_data: Option<api_models::payouts::PayoutMethodData>,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout's quote ID\n    pub quote_id: Option<String>,\n\n    pub test_mode: Option<bool>,\n    pub connector_http_status_code: Option<u16>,\n    pub external_latency: Option<u128>,\n    /// Contains apple pay flow type simplified or manual\n    pub apple_pay_flow: Option<payment_method_data::ApplePayFlow>,\n\n    \n\n... [truncated 627 chars] ...\n\nunt: Option<MinorUnit>,\n\n    pub integrity_check: Result<(), IntegrityCheckError>,\n\n    pub additional_merchant_data: Option<api_models::admin::AdditionalMerchantData>,\n\n    pub header_payload: Option<payments::HeaderPayload>,\n\n    pub connector_mandate_request_reference_id: Option<String>,\n\n    pub l2_l3_data: Option<Box<L2L3Data>>,\n\n    pub authentication_id: Option<id_type::AuthenticationId>,\n    /// Contains the type of sca exemption required for the transaction\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Contains stringified connector raw response body\n    pub raw_connector_response: Option<Secret<String>>,\n\n    /// Indicates whether the payment ID was provided by the merchant (true),\n    /// or generated internally by Hyperswitch (false)\n    pub is_payment_id_from_merchant: Option<bool>,\n\n    // Document details of the customer consisting of document number and type\n    pub customer_document_details: Option<CustomerDocumentDetails>,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]", "function_name": "RouterData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Payment flow state model"}, {"query": "Explain the purpose of request and response fields in RouterData.", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: RouterData\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_method_token: Option<PaymentMethodToken>,\n    pub recurring_mandate_payment_data: Option<RecurringMandatePaymentData>,\n    pub preprocessing_id: Option<String>,\n    /// This is the balance amount for gift cards or voucher\n    pub payment_method_balance: Option<PaymentMethodBalance>,\n\n    ///for switching between two different versions of the same connector\n    pub connector_api_version: Option<String>,\n\n    /// Contains flow-specific data required to construct a request and send it to the connector.\n    pub request: Request,\n\n    /// Contains flow-specific data that the connector responds with.\n    pub response: Result<Response, ErrorResponse>,\n\n    /// Contains a reference ID that should be sent in the connector request\n    pub connector_request_reference_id: String,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout method data\n    pub payout_method_data: Option<api_models::payouts::PayoutMethodData>,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout's quote ID\n    pub quote_id: Option<String>,\n\n    pub test_mode: Option<bool>,\n    pub connector_http_status_code: Option<u16>,\n    pub external_latency: Option<u128>,\n    /// Contains apple pay flow type simplified or manual\n    pub apple_pay_flow: Option<payment_method_data::ApplePayFlow>,\n\n    \n\n... [truncated 627 chars] ...\n\nunt: Option<MinorUnit>,\n\n    pub integrity_check: Result<(), IntegrityCheckError>,\n\n    pub additional_merchant_data: Option<api_models::admin::AdditionalMerchantData>,\n\n    pub header_payload: Option<payments::HeaderPayload>,\n\n    pub connector_mandate_request_reference_id: Option<String>,\n\n    pub l2_l3_data: Option<Box<L2L3Data>>,\n\n    pub authentication_id: Option<id_type::AuthenticationId>,\n    /// Contains the type of sca exemption required for the transaction\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Contains stringified connector raw response body\n    pub raw_connector_response: Option<Secret<String>>,\n\n    /// Indicates whether the payment ID was provided by the merchant (true),\n    /// or generated internally by Hyperswitch (false)\n    pub is_payment_id_from_merchant: Option<bool>,\n\n    // Document details of the customer consisting of document number and type\n    pub customer_document_details: Option<CustomerDocumentDetails>,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]", "function_name": "RouterData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Payment flow state model"}, {"query": "How does RouterData handle payment method and authentication details?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: RouterData\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_method_token: Option<PaymentMethodToken>,\n    pub recurring_mandate_payment_data: Option<RecurringMandatePaymentData>,\n    pub preprocessing_id: Option<String>,\n    /// This is the balance amount for gift cards or voucher\n    pub payment_method_balance: Option<PaymentMethodBalance>,\n\n    ///for switching between two different versions of the same connector\n    pub connector_api_version: Option<String>,\n\n    /// Contains flow-specific data required to construct a request and send it to the connector.\n    pub request: Request,\n\n    /// Contains flow-specific data that the connector responds with.\n    pub response: Result<Response, ErrorResponse>,\n\n    /// Contains a reference ID that should be sent in the connector request\n    pub connector_request_reference_id: String,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout method data\n    pub payout_method_data: Option<api_models::payouts::PayoutMethodData>,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout's quote ID\n    pub quote_id: Option<String>,\n\n    pub test_mode: Option<bool>,\n    pub connector_http_status_code: Option<u16>,\n    pub external_latency: Option<u128>,\n    /// Contains apple pay flow type simplified or manual\n    pub apple_pay_flow: Option<payment_method_data::ApplePayFlow>,\n\n    \n\n... [truncated 627 chars] ...\n\nunt: Option<MinorUnit>,\n\n    pub integrity_check: Result<(), IntegrityCheckError>,\n\n    pub additional_merchant_data: Option<api_models::admin::AdditionalMerchantData>,\n\n    pub header_payload: Option<payments::HeaderPayload>,\n\n    pub connector_mandate_request_reference_id: Option<String>,\n\n    pub l2_l3_data: Option<Box<L2L3Data>>,\n\n    pub authentication_id: Option<id_type::AuthenticationId>,\n    /// Contains the type of sca exemption required for the transaction\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Contains stringified connector raw response body\n    pub raw_connector_response: Option<Secret<String>>,\n\n    /// Indicates whether the payment ID was provided by the merchant (true),\n    /// or generated internally by Hyperswitch (false)\n    pub is_payment_id_from_merchant: Option<bool>,\n\n    // Document details of the customer consisting of document number and type\n    pub customer_document_details: Option<CustomerDocumentDetails>,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]", "function_name": "RouterData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Payment flow state model"}, {"query": "Rust Customer struct constructor hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: new\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Customer struct constructor"}, {"query": "hyperswitch domain models Customer new method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: new\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Customer struct constructor"}, {"query": "how to create Customer object in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: new\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Customer struct constructor"}, {"query": "hyperswitch connector_customer_id Customer struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: new\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Customer struct constructor"}, {"query": "how to update payment method connector mandate details in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_connector_mandate_details\nasync fn update_pm_connector_mandate_details<F, Req>(\n    state: &SessionState,\n    provider: &domain::Provider,\n    payment_data: &PaymentData<F>,\n    router_data: &types::RouterData<F, Req, types::PaymentsResponseData>,\n) -> RouterResult<()>\nwhere\n    F: Clone + Send + Sync,\n{\n    let is_valid_response = matches!(\n        router_data.response.as_ref(),\n        Ok(types::PaymentsResponseData::TransactionResponse { .. })\n    );\n    let is_integrity_ok = router_data.integrity_check.is_ok();\n\n    // Check payment status from payment_data (which has the final processed status)\n    let payment_attempt = payment_data.get_payment_attempt();\n    let is_payment_successful = matches!(\n        payment_attempt.status,\n        enums::AttemptStatus::Charged\n            | enums::AttemptStatus::Authorized\n            | enums::AttemptStatus::PartiallyAuthorized\n    );\n\n    let is_eligible_for_mandate_update =\n        is_valid_response && is_integrity_ok && is_payment_successful;\n\n    if let (true, Some(payment_method), Some(mca_id)) = (\n        is_eligible_for_mandate_update,\n        payment_data.get_payment_method_info().cloned(),\n        payment_attempt.merchant_connector_id.clone(),\n    ) {\n        let payment_intent = payment_data.get_payment_intent();\n\n        let mandate_details = payment_method\n            .get_common_mandate_reference()\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to deserialize to Payment Mandate Reference\")?;\n\n        let is_active_mandate = mandate_details\n            .payments\n            .as_ref()\n            .and_then(|payments| payments.0.get(&mca_id))\n            .is_some_and(|record| {\n                record.connector_mandate_status\n                    == Some(common_enums::ConnectorMandateStatus::Active)\n            });\n\n        let is_off_session = matches!(\n            payment_intent.setup_future_usage,\n            Some(common_enums::FutureUsage::OffSession)\n        );\n\n        // Combine business logic conditions: not active mandate AND off_session\n        if !is_active_mandate && is_off_session {\n            let (connector_mandate_id, mandate_metadata, connector_mandate_request_reference_id) =\n                payment_attempt\n                    .connector_mandate_detail\n                    .clone()\n                    .map(|cmr| {\n                        (\n                            cmr.connector_mandate_id,\n        \n\n... [truncated 752 chars] ...\n\n          mandate_metadata,\n                connector_mandate_request_reference_id,\n            )?;\n\n            payment_methods::cards::update_payment_method_connector_mandate_details(\n                provider.get_key_store(),\n                &*state.store,\n                payment_method,\n                connector_mandate_details,\n                provider.get_account().storage_scheme,\n            )\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update payment method in db\")?;\n        }\n    }\n    Ok(())\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Copy, router_derive::PaymentOperation)]\n#[operation(\n    operations = \"post_update_tracker\",\n    flow = \"sync_data, cancel_data, authorize_data, capture_data, complete_authorize_data, approve_data, reject_data, setup_mandate_data, session_data,incremental_authorization_data, sdk_session_update_data, post_session_tokens_data, update_metadata_data, cancel_post_capture_data, extend_authorization_data\"\n)]", "function_name": "update_pm_connector_mandate_details", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Mandate Update Logic"}, {"query": "hyperswitch router update_pm_connector_mandate_details function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_connector_mandate_details\nasync fn update_pm_connector_mandate_details<F, Req>(\n    state: &SessionState,\n    provider: &domain::Provider,\n    payment_data: &PaymentData<F>,\n    router_data: &types::RouterData<F, Req, types::PaymentsResponseData>,\n) -> RouterResult<()>\nwhere\n    F: Clone + Send + Sync,\n{\n    let is_valid_response = matches!(\n        router_data.response.as_ref(),\n        Ok(types::PaymentsResponseData::TransactionResponse { .. })\n    );\n    let is_integrity_ok = router_data.integrity_check.is_ok();\n\n    // Check payment status from payment_data (which has the final processed status)\n    let payment_attempt = payment_data.get_payment_attempt();\n    let is_payment_successful = matches!(\n        payment_attempt.status,\n        enums::AttemptStatus::Charged\n            | enums::AttemptStatus::Authorized\n            | enums::AttemptStatus::PartiallyAuthorized\n    );\n\n    let is_eligible_for_mandate_update =\n        is_valid_response && is_integrity_ok && is_payment_successful;\n\n    if let (true, Some(payment_method), Some(mca_id)) = (\n        is_eligible_for_mandate_update,\n        payment_data.get_payment_method_info().cloned(),\n        payment_attempt.merchant_connector_id.clone(),\n    ) {\n        let payment_intent = payment_data.get_payment_intent();\n\n        let mandate_details = payment_method\n            .get_common_mandate_reference()\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to deserialize to Payment Mandate Reference\")?;\n\n        let is_active_mandate = mandate_details\n            .payments\n            .as_ref()\n            .and_then(|payments| payments.0.get(&mca_id))\n            .is_some_and(|record| {\n                record.connector_mandate_status\n                    == Some(common_enums::ConnectorMandateStatus::Active)\n            });\n\n        let is_off_session = matches!(\n            payment_intent.setup_future_usage,\n            Some(common_enums::FutureUsage::OffSession)\n        );\n\n        // Combine business logic conditions: not active mandate AND off_session\n        if !is_active_mandate && is_off_session {\n            let (connector_mandate_id, mandate_metadata, connector_mandate_request_reference_id) =\n                payment_attempt\n                    .connector_mandate_detail\n                    .clone()\n                    .map(|cmr| {\n                        (\n                            cmr.connector_mandate_id,\n        \n\n... [truncated 752 chars] ...\n\n          mandate_metadata,\n                connector_mandate_request_reference_id,\n            )?;\n\n            payment_methods::cards::update_payment_method_connector_mandate_details(\n                provider.get_key_store(),\n                &*state.store,\n                payment_method,\n                connector_mandate_details,\n                provider.get_account().storage_scheme,\n            )\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update payment method in db\")?;\n        }\n    }\n    Ok(())\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Copy, router_derive::PaymentOperation)]\n#[operation(\n    operations = \"post_update_tracker\",\n    flow = \"sync_data, cancel_data, authorize_data, capture_data, complete_authorize_data, approve_data, reject_data, setup_mandate_data, session_data,incremental_authorization_data, sdk_session_update_data, post_session_tokens_data, update_metadata_data, cancel_post_capture_data, extend_authorization_data\"\n)]", "function_name": "update_pm_connector_mandate_details", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Mandate Update Logic"}, {"query": "create mandate for off session payment hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_connector_mandate_details\nasync fn update_pm_connector_mandate_details<F, Req>(\n    state: &SessionState,\n    provider: &domain::Provider,\n    payment_data: &PaymentData<F>,\n    router_data: &types::RouterData<F, Req, types::PaymentsResponseData>,\n) -> RouterResult<()>\nwhere\n    F: Clone + Send + Sync,\n{\n    let is_valid_response = matches!(\n        router_data.response.as_ref(),\n        Ok(types::PaymentsResponseData::TransactionResponse { .. })\n    );\n    let is_integrity_ok = router_data.integrity_check.is_ok();\n\n    // Check payment status from payment_data (which has the final processed status)\n    let payment_attempt = payment_data.get_payment_attempt();\n    let is_payment_successful = matches!(\n        payment_attempt.status,\n        enums::AttemptStatus::Charged\n            | enums::AttemptStatus::Authorized\n            | enums::AttemptStatus::PartiallyAuthorized\n    );\n\n    let is_eligible_for_mandate_update =\n        is_valid_response && is_integrity_ok && is_payment_successful;\n\n    if let (true, Some(payment_method), Some(mca_id)) = (\n        is_eligible_for_mandate_update,\n        payment_data.get_payment_method_info().cloned(),\n        payment_attempt.merchant_connector_id.clone(),\n    ) {\n        let payment_intent = payment_data.get_payment_intent();\n\n        let mandate_details = payment_method\n            .get_common_mandate_reference()\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to deserialize to Payment Mandate Reference\")?;\n\n        let is_active_mandate = mandate_details\n            .payments\n            .as_ref()\n            .and_then(|payments| payments.0.get(&mca_id))\n            .is_some_and(|record| {\n                record.connector_mandate_status\n                    == Some(common_enums::ConnectorMandateStatus::Active)\n            });\n\n        let is_off_session = matches!(\n            payment_intent.setup_future_usage,\n            Some(common_enums::FutureUsage::OffSession)\n        );\n\n        // Combine business logic conditions: not active mandate AND off_session\n        if !is_active_mandate && is_off_session {\n            let (connector_mandate_id, mandate_metadata, connector_mandate_request_reference_id) =\n                payment_attempt\n                    .connector_mandate_detail\n                    .clone()\n                    .map(|cmr| {\n                        (\n                            cmr.connector_mandate_id,\n        \n\n... [truncated 752 chars] ...\n\n          mandate_metadata,\n                connector_mandate_request_reference_id,\n            )?;\n\n            payment_methods::cards::update_payment_method_connector_mandate_details(\n                provider.get_key_store(),\n                &*state.store,\n                payment_method,\n                connector_mandate_details,\n                provider.get_account().storage_scheme,\n            )\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update payment method in db\")?;\n        }\n    }\n    Ok(())\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Copy, router_derive::PaymentOperation)]\n#[operation(\n    operations = \"post_update_tracker\",\n    flow = \"sync_data, cancel_data, authorize_data, capture_data, complete_authorize_data, approve_data, reject_data, setup_mandate_data, session_data,incremental_authorization_data, sdk_session_update_data, post_session_tokens_data, update_metadata_data, cancel_post_capture_data, extend_authorization_data\"\n)]", "function_name": "update_pm_connector_mandate_details", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Mandate Update Logic"}, {"query": "hyperswitch payment orchestration mandate update logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_connector_mandate_details\nasync fn update_pm_connector_mandate_details<F, Req>(\n    state: &SessionState,\n    provider: &domain::Provider,\n    payment_data: &PaymentData<F>,\n    router_data: &types::RouterData<F, Req, types::PaymentsResponseData>,\n) -> RouterResult<()>\nwhere\n    F: Clone + Send + Sync,\n{\n    let is_valid_response = matches!(\n        router_data.response.as_ref(),\n        Ok(types::PaymentsResponseData::TransactionResponse { .. })\n    );\n    let is_integrity_ok = router_data.integrity_check.is_ok();\n\n    // Check payment status from payment_data (which has the final processed status)\n    let payment_attempt = payment_data.get_payment_attempt();\n    let is_payment_successful = matches!(\n        payment_attempt.status,\n        enums::AttemptStatus::Charged\n            | enums::AttemptStatus::Authorized\n            | enums::AttemptStatus::PartiallyAuthorized\n    );\n\n    let is_eligible_for_mandate_update =\n        is_valid_response && is_integrity_ok && is_payment_successful;\n\n    if let (true, Some(payment_method), Some(mca_id)) = (\n        is_eligible_for_mandate_update,\n        payment_data.get_payment_method_info().cloned(),\n        payment_attempt.merchant_connector_id.clone(),\n    ) {\n        let payment_intent = payment_data.get_payment_intent();\n\n        let mandate_details = payment_method\n            .get_common_mandate_reference()\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to deserialize to Payment Mandate Reference\")?;\n\n        let is_active_mandate = mandate_details\n            .payments\n            .as_ref()\n            .and_then(|payments| payments.0.get(&mca_id))\n            .is_some_and(|record| {\n                record.connector_mandate_status\n                    == Some(common_enums::ConnectorMandateStatus::Active)\n            });\n\n        let is_off_session = matches!(\n            payment_intent.setup_future_usage,\n            Some(common_enums::FutureUsage::OffSession)\n        );\n\n        // Combine business logic conditions: not active mandate AND off_session\n        if !is_active_mandate && is_off_session {\n            let (connector_mandate_id, mandate_metadata, connector_mandate_request_reference_id) =\n                payment_attempt\n                    .connector_mandate_detail\n                    .clone()\n                    .map(|cmr| {\n                        (\n                            cmr.connector_mandate_id,\n        \n\n... [truncated 752 chars] ...\n\n          mandate_metadata,\n                connector_mandate_request_reference_id,\n            )?;\n\n            payment_methods::cards::update_payment_method_connector_mandate_details(\n                provider.get_key_store(),\n                &*state.store,\n                payment_method,\n                connector_mandate_details,\n                provider.get_account().storage_scheme,\n            )\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update payment method in db\")?;\n        }\n    }\n    Ok(())\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Copy, router_derive::PaymentOperation)]\n#[operation(\n    operations = \"post_update_tracker\",\n    flow = \"sync_data, cancel_data, authorize_data, capture_data, complete_authorize_data, approve_data, reject_data, setup_mandate_data, session_data,incremental_authorization_data, sdk_session_update_data, post_session_tokens_data, update_metadata_data, cancel_post_capture_data, extend_authorization_data\"\n)]", "function_name": "update_pm_connector_mandate_details", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Mandate Update Logic"}, {"query": "rust hyperswitch PaymentsIncrementalAuthorizationData struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsIncrementalAuthorizationData\npub struct PaymentsIncrementalAuthorizationData {\n    pub total_amount: i64,\n    pub additional_amount: i64,\n    pub currency: storage_enums::Currency,\n    pub reason: Option<String>,\n    pub connector_transaction_id: String,\n    pub connector_meta: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "PaymentsIncrementalAuthorizationData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Incremental Authorization Data Struct"}, {"query": "how to handle incremental authorization data in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsIncrementalAuthorizationData\npub struct PaymentsIncrementalAuthorizationData {\n    pub total_amount: i64,\n    pub additional_amount: i64,\n    pub currency: storage_enums::Currency,\n    pub reason: Option<String>,\n    pub connector_transaction_id: String,\n    pub connector_meta: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "PaymentsIncrementalAuthorizationData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Incremental Authorization Data Struct"}, {"query": "PaymentsIncrementalAuthorizationData fields total_amount additional_amount", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsIncrementalAuthorizationData\npub struct PaymentsIncrementalAuthorizationData {\n    pub total_amount: i64,\n    pub additional_amount: i64,\n    pub currency: storage_enums::Currency,\n    pub reason: Option<String>,\n    pub connector_transaction_id: String,\n    pub connector_meta: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "PaymentsIncrementalAuthorizationData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Incremental Authorization Data Struct"}, {"query": "hyperswitch incremental authorization request types rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsIncrementalAuthorizationData\npub struct PaymentsIncrementalAuthorizationData {\n    pub total_amount: i64,\n    pub additional_amount: i64,\n    pub currency: storage_enums::Currency,\n    pub reason: Option<String>,\n    pub connector_transaction_id: String,\n    pub connector_meta: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "PaymentsIncrementalAuthorizationData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Incremental Authorization Data Struct"}, {"query": "rust hyperswitch amazonpay build_request function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Authorization Request Builder"}, {"query": "how to construct amazon pay authorization request in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Authorization Request Builder"}, {"query": "hyperswitch amazonpay connector request builder method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Authorization Request Builder"}, {"query": "rust amazonpay payments authorize request setup hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Authorization Request Builder"}, {"query": "rust hyperswitch gigadat connector error handling get_error_response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat error response handler"}, {"query": "how to implement error response builder in hyperswitch gigadat connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat error response handler"}, {"query": "hyperswitch gigadat rust function get_error_response signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat error response handler"}, {"query": "gigadat connector hyperswitch error response formatting implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat error response handler"}, {"query": "helcim setup mandate rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Helcim\".to_string())\n                .into(),\n        )\n\n        // Ok(Some(\n        //     RequestBuilder::new()\n        //         .method(Method::Post)\n        //         .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n        //         .attach_default_headers()\n        //         .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n        //         .set_body(types::SetupMandateType::get_request_body(\n        //             self, req, connectors,\n        //         )?)\n        //         .build(),\n        // ))\n    }", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Setup Mandate Request Builder"}, {"query": "hyperswitch helcim connector build_request function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Helcim\".to_string())\n                .into(),\n        )\n\n        // Ok(Some(\n        //     RequestBuilder::new()\n        //         .method(Method::Post)\n        //         .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n        //         .attach_default_headers()\n        //         .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n        //         .set_body(types::SetupMandateType::get_request_body(\n        //             self, req, connectors,\n        //         )?)\n        //         .build(),\n        // ))\n    }", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Setup Mandate Request Builder"}, {"query": "rust setup mandate router data helcim", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Helcim\".to_string())\n                .into(),\n        )\n\n        // Ok(Some(\n        //     RequestBuilder::new()\n        //         .method(Method::Post)\n        //         .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n        //         .attach_default_headers()\n        //         .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n        //         .set_body(types::SetupMandateType::get_request_body(\n        //             self, req, connectors,\n        //         )?)\n        //         .build(),\n        // ))\n    }", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Setup Mandate Request Builder"}, {"query": "helcim payment orchestration setup mandate not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Helcim\".to_string())\n                .into(),\n        )\n\n        // Ok(Some(\n        //     RequestBuilder::new()\n        //         .method(Method::Post)\n        //         .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n        //         .attach_default_headers()\n        //         .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n        //         .set_body(types::SetupMandateType::get_request_body(\n        //             self, req, connectors,\n        //         )?)\n        //         .build(),\n        // ))\n    }", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Setup Mandate Request Builder"}, {"query": "hyperswitch rust get_next_action_api implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_next_action_api\n    pub fn get_next_action_api(\n        &self,\n        base_url: String,\n        authentication_id: String,\n    ) -> CustomResult<NextAction, errors::ParsingError> {\n        let url = format!(\"{base_url}/authentication/{authentication_id}/authenticate\");\n        Ok(NextAction {\n            url: url::Url::parse(&url).change_context(errors::ParsingError::UrlParsingError)?,\n            http_method: common_utils::request::Method::Post,\n        })\n    }\n", "function_name": "get_next_action_api", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Rust authentication URL builder"}, {"query": "how to construct authentication url in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_next_action_api\n    pub fn get_next_action_api(\n        &self,\n        base_url: String,\n        authentication_id: String,\n    ) -> CustomResult<NextAction, errors::ParsingError> {\n        let url = format!(\"{base_url}/authentication/{authentication_id}/authenticate\");\n        Ok(NextAction {\n            url: url::Url::parse(&url).change_context(errors::ParsingError::UrlParsingError)?,\n            http_method: common_utils::request::Method::Post,\n        })\n    }\n", "function_name": "get_next_action_api", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Rust authentication URL builder"}, {"query": "hyperswitch authentication_id authenticate endpoint rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_next_action_api\n    pub fn get_next_action_api(\n        &self,\n        base_url: String,\n        authentication_id: String,\n    ) -> CustomResult<NextAction, errors::ParsingError> {\n        let url = format!(\"{base_url}/authentication/{authentication_id}/authenticate\");\n        Ok(NextAction {\n            url: url::Url::parse(&url).change_context(errors::ParsingError::UrlParsingError)?,\n            http_method: common_utils::request::Method::Post,\n        })\n    }\n", "function_name": "get_next_action_api", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Rust authentication URL builder"}, {"query": "rust hyperswitch NextAction struct get_next_action_api", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_next_action_api\n    pub fn get_next_action_api(\n        &self,\n        base_url: String,\n        authentication_id: String,\n    ) -> CustomResult<NextAction, errors::ParsingError> {\n        let url = format!(\"{base_url}/authentication/{authentication_id}/authenticate\");\n        Ok(NextAction {\n            url: url::Url::parse(&url).change_context(errors::ParsingError::UrlParsingError)?,\n            http_method: common_utils::request::Method::Post,\n        })\n    }\n", "function_name": "get_next_action_api", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Rust authentication URL builder"}, {"query": "how to handle 5xx server errors in Cybersource connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: cybersource::CybersourceServerErrorResponse = res\n            .response\n            .parse_struct(\"CybersourceServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "get_5xx_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource 5xx Error Parser"}, {"query": "parse CybersourceServerErrorResponse hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: cybersource::CybersourceServerErrorResponse = res\n            .response\n            .parse_struct(\"CybersourceServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "get_5xx_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource 5xx Error Parser"}, {"query": "map Cybersource reason to AttemptStatus hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: cybersource::CybersourceServerErrorResponse = res\n            .response\n            .parse_struct(\"CybersourceServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "get_5xx_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource 5xx Error Parser"}, {"query": "hyperswitch cybersource error response transformation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: cybersource::CybersourceServerErrorResponse = res\n            .response\n            .parse_struct(\"CybersourceServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "get_5xx_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource 5xx Error Parser"}, {"query": "how to implement Boku payment connector in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Boku\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Boku\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector integration"}, {"query": "hyperswitch Boku connector integration example", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Boku\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Boku\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector integration"}, {"query": "Rust trait implementation for Boku payments", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Boku\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Boku\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector integration"}, {"query": "Boku payment method tokenization hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Boku\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Boku\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector integration"}, {"query": "archipel connector try_from implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {\n                ca_certificate: Some(api_key.to_owned()),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel auth configuration"}, {"query": "how to configure HeaderKey auth type in archipel", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {\n                ca_certificate: Some(api_key.to_owned()),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel auth configuration"}, {"query": "rust try_from pattern for ConnectorAuthType", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {\n                ca_certificate: Some(api_key.to_owned()),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel auth configuration"}, {"query": "archipel hyperswitch authentication setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {\n                ca_certificate: Some(api_key.to_owned()),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel auth configuration"}, {"query": "how to configure authentication headers for juspay 3ds server in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server Header Builder"}, {"query": "rust function to build headers for juspaythreedsserver connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server Header Builder"}, {"query": "hyperswitch juspaythreedsserver build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server Header Builder"}, {"query": "how does hyperswitch handle content type and auth headers for juspay 3ds", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server Header Builder"}, {"query": "rust hyperswitch gpayments connector get_url function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let connector_metadata: GpaymentsConnectorMetaData = to_connector_meta(\n            req.request\n                .pre_authentication_data\n                .connector_metadata\n                .clone(),\n        )?;\n        Ok(connector_metadata.authentication_url)\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments connector authentication URL extraction"}, {"query": "how to extract authentication_url from connector_metadata in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let connector_metadata: GpaymentsConnectorMetaData = to_connector_meta(\n            req.request\n                .pre_authentication_data\n                .connector_metadata\n                .clone(),\n        )?;\n        Ok(connector_metadata.authentication_url)\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments connector authentication URL extraction"}, {"query": "hyperswitch gpayments authentication flow get_url method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let connector_metadata: GpaymentsConnectorMetaData = to_connector_meta(\n            req.request\n                .pre_authentication_data\n                .connector_metadata\n                .clone(),\n        )?;\n        Ok(connector_metadata.authentication_url)\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments connector authentication URL extraction"}, {"query": "rust hyperswitch connector authentication metadata parsing get_url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let connector_metadata: GpaymentsConnectorMetaData = to_connector_meta(\n            req.request\n                .pre_authentication_data\n                .connector_metadata\n                .clone(),\n        )?;\n        Ok(connector_metadata.authentication_url)\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments connector authentication URL extraction"}, {"query": "How to implement email validation and blocking in Rust for payment systems?", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: UserEmail\npub struct UserEmail(pii::Email);\n\nstatic BLOCKED_EMAIL: LazyLock<HashSet<String>> = LazyLock::new(|| {\n    let blocked_emails_content = include_str!(\"../../utils/user/blocker_emails.txt\");\n    let blocked_emails: HashSet<String> = blocked_emails_content\n        .lines()\n        .map(|s| s.trim().to_owned())\n        .collect();\n    blocked_emails\n});\n", "function_name": "UserEmail", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Rust PII Email Validation"}, {"query": "Hyperswitch UserEmail struct definition and blocked email list implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: UserEmail\npub struct UserEmail(pii::Email);\n\nstatic BLOCKED_EMAIL: LazyLock<HashSet<String>> = LazyLock::new(|| {\n    let blocked_emails_content = include_str!(\"../../utils/user/blocker_emails.txt\");\n    let blocked_emails: HashSet<String> = blocked_emails_content\n        .lines()\n        .map(|s| s.trim().to_owned())\n        .collect();\n    blocked_emails\n});\n", "function_name": "UserEmail", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Rust PII Email Validation"}, {"query": "Rust LazyLock HashSet for blocked emails in payment orchestration", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: UserEmail\npub struct UserEmail(pii::Email);\n\nstatic BLOCKED_EMAIL: LazyLock<HashSet<String>> = LazyLock::new(|| {\n    let blocked_emails_content = include_str!(\"../../utils/user/blocker_emails.txt\");\n    let blocked_emails: HashSet<String> = blocked_emails_content\n        .lines()\n        .map(|s| s.trim().to_owned())\n        .collect();\n    blocked_emails\n});\n", "function_name": "UserEmail", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Rust PII Email Validation"}, {"query": "How does Hyperswitch handle PII and blocked email addresses in the router?", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: UserEmail\npub struct UserEmail(pii::Email);\n\nstatic BLOCKED_EMAIL: LazyLock<HashSet<String>> = LazyLock::new(|| {\n    let blocked_emails_content = include_str!(\"../../utils/user/blocker_emails.txt\");\n    let blocked_emails: HashSet<String> = blocked_emails_content\n        .lines()\n        .map(|s| s.trim().to_owned())\n        .collect();\n    blocked_emails\n});\n", "function_name": "UserEmail", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Rust PII Email Validation"}, {"query": "how to configure custom headers for airwallex connector in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex connector header injection"}, {"query": "airwallex hyperswitch rust connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex connector header injection"}, {"query": "hyperswitch airwallex connector authentication header setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex connector header injection"}, {"query": "rust function get_headers airwallex hyperswitch connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex connector header injection"}, {"query": "rust hyperswitch thunes connector error response builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: thunes::ThunesErrorResponse = res\n            .response\n            .parse_struct(\"ThunesErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector error response builder"}, {"query": "how to handle thunes api error in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: thunes::ThunesErrorResponse = res\n            .response\n            .parse_struct(\"ThunesErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector error response builder"}, {"query": "hyperswitch thunes connector build_error_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: thunes::ThunesErrorResponse = res\n            .response\n            .parse_struct(\"ThunesErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector error response builder"}, {"query": "thunes connector error parsing hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: thunes::ThunesErrorResponse = res\n            .response\n            .parse_struct(\"ThunesErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector error response builder"}, {"query": "rust struct definition GenericLinkEnvConfig hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: GenericLinkEnvConfig\npub struct GenericLinkEnvConfig {\n    pub sdk_url: url::Url,\n    pub expiry: u32,\n    pub ui_config: GenericLinkEnvUiConfig,\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub enabled_payment_methods: HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n}\n", "function_name": "GenericLinkEnvConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "GenericLinkEnvConfig struct definition"}, {"query": "how to configure generic link expiry and payment methods in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: GenericLinkEnvConfig\npub struct GenericLinkEnvConfig {\n    pub sdk_url: url::Url,\n    pub expiry: u32,\n    pub ui_config: GenericLinkEnvUiConfig,\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub enabled_payment_methods: HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n}\n", "function_name": "GenericLinkEnvConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "GenericLinkEnvConfig struct definition"}, {"query": "hyperswitch GenericLinkEnvConfig deserialize_hashmap enabled_payment_methods", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: GenericLinkEnvConfig\npub struct GenericLinkEnvConfig {\n    pub sdk_url: url::Url,\n    pub expiry: u32,\n    pub ui_config: GenericLinkEnvUiConfig,\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub enabled_payment_methods: HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n}\n", "function_name": "GenericLinkEnvConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "GenericLinkEnvConfig struct definition"}, {"query": "rust url::Url GenericLinkEnvUiConfig hyperswitch configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: GenericLinkEnvConfig\npub struct GenericLinkEnvConfig {\n    pub sdk_url: url::Url,\n    pub expiry: u32,\n    pub ui_config: GenericLinkEnvUiConfig,\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub enabled_payment_methods: HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n}\n", "function_name": "GenericLinkEnvConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "GenericLinkEnvConfig struct definition"}, {"query": "rust hyperswitch find_merchant_connector_account_by_merchant_id_and_disabled_list", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_and_disabled_list\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(all(feature = \"olap\", feature = \"v2\"))]", "function_name": "find_merchant_connector_account_by_merchant_id_and_disabled_list", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "how to query merchant connector accounts by id in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_and_disabled_list\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(all(feature = \"olap\", feature = \"v2\"))]", "function_name": "find_merchant_connector_account_by_merchant_id_and_disabled_list", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "hyperswitch storage_impl merchant connector account lookup function", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_and_disabled_list\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(all(feature = \"olap\", feature = \"v2\"))]", "function_name": "find_merchant_connector_account_by_merchant_id_and_disabled_list", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "rust hyperswitch router_store find_merchant_connector_account_by_merchant_id_and_disabled_list", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_and_disabled_list\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(all(feature = \"olap\", feature = \"v2\"))]", "function_name": "find_merchant_connector_account_by_merchant_id_and_disabled_list", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "how to get auth header for Powertranz connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = powertranz::PowertranzAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                POWER_TRANZ_ID.to_string(),\n                auth.power_tranz_id.expose().into_masked(),\n            ),\n            (\n                POWER_TRANZ_PASSWORD.to_string(),\n                auth.power_tranz_password.expose().into_masked(),\n            ),\n        ])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz Auth Header Builder"}, {"query": "rust hyperswitch powertranz authentication header", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = powertranz::PowertranzAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                POWER_TRANZ_ID.to_string(),\n                auth.power_tranz_id.expose().into_masked(),\n            ),\n            (\n                POWER_TRANZ_PASSWORD.to_string(),\n                auth.power_tranz_password.expose().into_masked(),\n            ),\n        ])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz Auth Header Builder"}, {"query": "hyperswitch powertranz connector get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = powertranz::PowertranzAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                POWER_TRANZ_ID.to_string(),\n                auth.power_tranz_id.expose().into_masked(),\n            ),\n            (\n                POWER_TRANZ_PASSWORD.to_string(),\n                auth.power_tranz_password.expose().into_masked(),\n            ),\n        ])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz Auth Header Builder"}, {"query": "PowertranzAuthType hyperswitch rust connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = powertranz::PowertranzAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                POWER_TRANZ_ID.to_string(),\n                auth.power_tranz_id.expose().into_masked(),\n            ),\n            (\n                POWER_TRANZ_PASSWORD.to_string(),\n                auth.power_tranz_password.expose().into_masked(),\n            ),\n        ])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz Auth Header Builder"}, {"query": "how to format Gigadat authorization request body", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = gigadat::GigadatRouterData::from((amount, req));\n        let connector_req = gigadat::GigadatCpiRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat authorization request builder"}, {"query": "convert minor amount to Gigadat request format", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = gigadat::GigadatRouterData::from((amount, req));\n        let connector_req = gigadat::GigadatCpiRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat authorization request builder"}, {"query": "GigadatCpiRequest builder implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = gigadat::GigadatRouterData::from((amount, req));\n        let connector_req = gigadat::GigadatCpiRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat authorization request builder"}, {"query": "hyperswitch gigadat connector request payload", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = gigadat::GigadatRouterData::from((amount, req));\n        let connector_req = gigadat::GigadatCpiRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat authorization request builder"}, {"query": "rust hyperswitch list_enabled_connector_accounts_by_profile_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_enabled_connector_accounts_by_profile_id\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "list_enabled_connector_accounts_by_profile_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "List enabled connector accounts by profile"}, {"query": "how to get merchant connector accounts by profile id in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_enabled_connector_accounts_by_profile_id\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "list_enabled_connector_accounts_by_profile_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "List enabled connector accounts by profile"}, {"query": "hyperswitch storage_impl merchant connector account list function", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_enabled_connector_accounts_by_profile_id\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "list_enabled_connector_accounts_by_profile_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "List enabled connector accounts by profile"}, {"query": "rust code for listing enabled accounts by profile id hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_enabled_connector_accounts_by_profile_id\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "list_enabled_connector_accounts_by_profile_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "List enabled connector accounts by profile"}, {"query": "how to handle error responses in Thunes connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector error handler"}, {"query": "hyperswitch thunes connector error handling implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector error handler"}, {"query": "thunes connector get_error_response function rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector error handler"}, {"query": "hyperswitch connector error response builder pattern", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector error handler"}, {"query": "hyperswitch rust update_pm_and_mandate function feature flag", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_and_mandate\n    async fn update_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        provider: &domain::Provider,\n        payment_data: &PaymentData<F>,\n        router_data: &types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        feature_set: &core_utils::FeatureConfig,\n    ) -> RouterResult<()>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        if !feature_set.is_payment_method_modular_allowed {\n            update_pm_connector_mandate_details(state, provider, payment_data, router_data).await\n        } else {\n            Ok(())\n        }\n    }\n\n    #[cfg(feature = \"v1\")]", "function_name": "update_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment method mandate conditional update"}, {"query": "how to disable payment method mandate updates in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_and_mandate\n    async fn update_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        provider: &domain::Provider,\n        payment_data: &PaymentData<F>,\n        router_data: &types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        feature_set: &core_utils::FeatureConfig,\n    ) -> RouterResult<()>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        if !feature_set.is_payment_method_modular_allowed {\n            update_pm_connector_mandate_details(state, provider, payment_data, router_data).await\n        } else {\n            Ok(())\n        }\n    }\n\n    #[cfg(feature = \"v1\")]", "function_name": "update_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment method mandate conditional update"}, {"query": "hyperswitch feature_set.is_payment_method_modular_allowed conditional logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_and_mandate\n    async fn update_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        provider: &domain::Provider,\n        payment_data: &PaymentData<F>,\n        router_data: &types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        feature_set: &core_utils::FeatureConfig,\n    ) -> RouterResult<()>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        if !feature_set.is_payment_method_modular_allowed {\n            update_pm_connector_mandate_details(state, provider, payment_data, router_data).await\n        } else {\n            Ok(())\n        }\n    }\n\n    #[cfg(feature = \"v1\")]", "function_name": "update_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment method mandate conditional update"}, {"query": "rust payment orchestration router update_pm_connector_mandate_details", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_and_mandate\n    async fn update_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        provider: &domain::Provider,\n        payment_data: &PaymentData<F>,\n        router_data: &types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        feature_set: &core_utils::FeatureConfig,\n    ) -> RouterResult<()>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        if !feature_set.is_payment_method_modular_allowed {\n            update_pm_connector_mandate_details(state, provider, payment_data, router_data).await\n        } else {\n            Ok(())\n        }\n    }\n\n    #[cfg(feature = \"v1\")]", "function_name": "update_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment method mandate conditional update"}, {"query": "rust hyperswitch thunes connector get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = thunes::ThunesAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes auth header generation"}, {"query": "how to configure authorization header for thunes payment gateway in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = thunes::ThunesAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes auth header generation"}, {"query": "hyperswitch thunes auth_type to ThunesAuthType conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = thunes::ThunesAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes auth header generation"}, {"query": "rust function get_auth_header returns masked api key vector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = thunes::ThunesAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes auth header generation"}, {"query": "rust hyperswitch worldline connector setup mandate request builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Worldline\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline Setup Mandate Request Builder"}, {"query": "how to implement setup mandate flow in worldline connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Worldline\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline Setup Mandate Request Builder"}, {"query": "hyperswitch worldline.rs build_request function error NotImplemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Worldline\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline Setup Mandate Request Builder"}, {"query": "worldline mandate setup request construction rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Worldline\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline Setup Mandate Request Builder"}, {"query": "how to handle gigadat error response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: gigadat::GigadatErrorResponse = res\n            .response\n            .parse_struct(\"GigadatErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.err.clone(),\n            message: response.err.clone(),\n            reason: Some(response.err).clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Error Response Builder"}, {"query": "build_error_response gigadat connector rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: gigadat::GigadatErrorResponse = res\n            .response\n            .parse_struct(\"GigadatErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.err.clone(),\n            message: response.err.clone(),\n            reason: Some(response.err).clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Error Response Builder"}, {"query": "hyperswitch gigadat error mapping function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: gigadat::GigadatErrorResponse = res\n            .response\n            .parse_struct(\"GigadatErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.err.clone(),\n            message: response.err.clone(),\n            reason: Some(response.err).clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Error Response Builder"}, {"query": "gigadat error response deserialization hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: gigadat::GigadatErrorResponse = res\n            .response\n            .parse_struct(\"GigadatErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.err.clone(),\n            message: response.err.clone(),\n            reason: Some(response.err).clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Error Response Builder"}, {"query": "how to get current utc time in rust for worldline connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_current_date_time\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "get_current_date_time", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline UTC timestamp formatter"}, {"query": "worldline connector get_current_date_time implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_current_date_time\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "get_current_date_time", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline UTC timestamp formatter"}, {"query": "rust format current date time gmt string", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_current_date_time\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "get_current_date_time", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline UTC timestamp formatter"}, {"query": "hyperswitch worldline connector date formatting", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_current_date_time\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "get_current_date_time", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline UTC timestamp formatter"}, {"query": "rust hyperswitch get_mca_id function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_mca_id\n    pub fn get_mca_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.get_id())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_mca_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MCA ID accessor"}, {"query": "how to extract merchant connector account id from hyperswitch domain model", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_mca_id\n    pub fn get_mca_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.get_id())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_mca_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MCA ID accessor"}, {"query": "hyperswitch get_mca_id returns None for details variant", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_mca_id\n    pub fn get_mca_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.get_id())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_mca_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MCA ID accessor"}, {"query": "merchant_connector_account get_mca_id rust source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_mca_id\n    pub fn get_mca_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.get_id())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_mca_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MCA ID accessor"}, {"query": "rust hyperswitch OrderChannel enum definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: OrderChannel\npub enum OrderChannel {\n    Web,\n    Phone,\n    MobileApp,\n    Social,\n    Marketplace,\n    InStoreKiosk,\n    ScanAndGo,\n    SmartTv,\n    Mit,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "OrderChannel", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "payment channel origin enum"}, {"query": "hyperswitch payment channel types enum", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: OrderChannel\npub enum OrderChannel {\n    Web,\n    Phone,\n    MobileApp,\n    Social,\n    Marketplace,\n    InStoreKiosk,\n    ScanAndGo,\n    SmartTv,\n    Mit,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "OrderChannel", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "payment channel origin enum"}, {"query": "how to define order channel in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: OrderChannel\npub enum OrderChannel {\n    Web,\n    Phone,\n    MobileApp,\n    Social,\n    Marketplace,\n    InStoreKiosk,\n    ScanAndGo,\n    SmartTv,\n    Mit,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "OrderChannel", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "payment channel origin enum"}, {"query": "hyperswitch OrderChannel source of payment", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: OrderChannel\npub enum OrderChannel {\n    Web,\n    Phone,\n    MobileApp,\n    Social,\n    Marketplace,\n    InStoreKiosk,\n    ScanAndGo,\n    SmartTv,\n    Mit,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "OrderChannel", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "payment channel origin enum"}, {"query": "how to build headers for Authipay connector in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let timestamp = time::OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n        let auth: authipay::AuthipayAuthType =\n            authipay::AuthipayAuthType::try_from(&req.connector_auth_type)?;\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n\n        let authipay_req = self.get_request_body(req, connectors)?;\n\n        let client_request_id = uuid::Uuid::new_v4().to_string();\n        let hmac = self\n            .generate_authorization_signature(\n                auth,\n                &client_request_id,\n                authipay_req.get_inner_value().peek(),\n                timestamp,\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                types::PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\"Client-Request-Id\".to_string(), client_request_id.into()),\n            (\"Auth-Token-Type\".to_string(), \"HMAC\".to_string().into()),\n            (headers::TIMESTAMP.to_string(), timestamp.to_string().into()),\n            (\"Message-Signature\".to_string(), hmac.into_masked()),\n        ];\n        headers.append(&mut auth_header);\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector header builder"}, {"query": "Authipay HMAC signature generation implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let timestamp = time::OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n        let auth: authipay::AuthipayAuthType =\n            authipay::AuthipayAuthType::try_from(&req.connector_auth_type)?;\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n\n        let authipay_req = self.get_request_body(req, connectors)?;\n\n        let client_request_id = uuid::Uuid::new_v4().to_string();\n        let hmac = self\n            .generate_authorization_signature(\n                auth,\n                &client_request_id,\n                authipay_req.get_inner_value().peek(),\n                timestamp,\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                types::PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\"Client-Request-Id\".to_string(), client_request_id.into()),\n            (\"Auth-Token-Type\".to_string(), \"HMAC\".to_string().into()),\n            (headers::TIMESTAMP.to_string(), timestamp.to_string().into()),\n            (\"Message-Signature\".to_string(), hmac.into_masked()),\n        ];\n        headers.append(&mut auth_header);\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector header builder"}, {"query": "Hyperswitch Authipay connector authentication headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let timestamp = time::OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n        let auth: authipay::AuthipayAuthType =\n            authipay::AuthipayAuthType::try_from(&req.connector_auth_type)?;\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n\n        let authipay_req = self.get_request_body(req, connectors)?;\n\n        let client_request_id = uuid::Uuid::new_v4().to_string();\n        let hmac = self\n            .generate_authorization_signature(\n                auth,\n                &client_request_id,\n                authipay_req.get_inner_value().peek(),\n                timestamp,\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                types::PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\"Client-Request-Id\".to_string(), client_request_id.into()),\n            (\"Auth-Token-Type\".to_string(), \"HMAC\".to_string().into()),\n            (headers::TIMESTAMP.to_string(), timestamp.to_string().into()),\n            (\"Message-Signature\".to_string(), hmac.into_masked()),\n        ];\n        headers.append(&mut auth_header);\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector header builder"}, {"query": "Authipay payment gateway API header structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let timestamp = time::OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n        let auth: authipay::AuthipayAuthType =\n            authipay::AuthipayAuthType::try_from(&req.connector_auth_type)?;\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n\n        let authipay_req = self.get_request_body(req, connectors)?;\n\n        let client_request_id = uuid::Uuid::new_v4().to_string();\n        let hmac = self\n            .generate_authorization_signature(\n                auth,\n                &client_request_id,\n                authipay_req.get_inner_value().peek(),\n                timestamp,\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                types::PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\"Client-Request-Id\".to_string(), client_request_id.into()),\n            (\"Auth-Token-Type\".to_string(), \"HMAC\".to_string().into()),\n            (headers::TIMESTAMP.to_string(), timestamp.to_string().into()),\n            (\"Message-Signature\".to_string(), hmac.into_masked()),\n        ];\n        headers.append(&mut auth_header);\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector header builder"}, {"query": "how to format request body for Wells Fargo zero mandate API", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = wellsfargo::WellsfargoZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo Zero Mandate Request Builder"}, {"query": "WellsfargoZeroMandateRequest struct definition hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = wellsfargo::WellsfargoZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo Zero Mandate Request Builder"}, {"query": "get_request_body function implementation Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = wellsfargo::WellsfargoZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo Zero Mandate Request Builder"}, {"query": "hyperswitch wellsfargo connector request payload", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = wellsfargo::WellsfargoZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo Zero Mandate Request Builder"}, {"query": "how to convert ExternalVaultDetails to tuple in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: from\n    fn from(external_vault_details: ExternalVaultDetails) -> Self {\n        match external_vault_details {\n            ExternalVaultDetails::ExternalVaultEnabled(connector_details) => {\n                (Some(true), Some(connector_details))\n            }\n            ExternalVaultDetails::Skip => (Some(false), None),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ExternalVaultDetails conversion"}, {"query": "ExternalVaultDetails from function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: from\n    fn from(external_vault_details: ExternalVaultDetails) -> Self {\n        match external_vault_details {\n            ExternalVaultDetails::ExternalVaultEnabled(connector_details) => {\n                (Some(true), Some(connector_details))\n            }\n            ExternalVaultDetails::Skip => (Some(false), None),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ExternalVaultDetails conversion"}, {"query": "Rust enum to tuple conversion hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: from\n    fn from(external_vault_details: ExternalVaultDetails) -> Self {\n        match external_vault_details {\n            ExternalVaultDetails::ExternalVaultEnabled(connector_details) => {\n                (Some(true), Some(connector_details))\n            }\n            ExternalVaultDetails::Skip => (Some(false), None),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ExternalVaultDetails conversion"}, {"query": "ExternalVaultDetails::Skip handling logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: from\n    fn from(external_vault_details: ExternalVaultDetails) -> Self {\n        match external_vault_details {\n            ExternalVaultDetails::ExternalVaultEnabled(connector_details) => {\n                (Some(true), Some(connector_details))\n            }\n            ExternalVaultDetails::Skip => (Some(false), None),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ExternalVaultDetails conversion"}, {"query": "how to implement Powertranz payment tokenization in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Powertranz\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Powertranz\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector integration trait"}, {"query": "Powertranz connector integration trait implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Powertranz\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Powertranz\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector integration trait"}, {"query": "hyperswitch Powertranz payments response data handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Powertranz\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Powertranz\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector integration trait"}, {"query": "rust connector integration Powertranz payment method token", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Powertranz\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Powertranz\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector integration trait"}, {"query": "how to get payout url from payone connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}v2/{}/payouts\",\n            self.base_url(_connectors),\n            auth.merchant_account.peek()\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout URL Builder"}, {"query": "hyperswitch payone connector payout url generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}v2/{}/payouts\",\n            self.base_url(_connectors),\n            auth.merchant_account.peek()\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout URL Builder"}, {"query": "rust hyperswitch payone payout endpoint url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}v2/{}/payouts\",\n            self.base_url(_connectors),\n            auth.merchant_account.peek()\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout URL Builder"}, {"query": "PayoneAuthType hyperswitch connector payout routing", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}v2/{}/payouts\",\n            self.base_url(_connectors),\n            auth.merchant_account.peek()\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout URL Builder"}, {"query": "rust hyperswitch find merchant connector account by profile id", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_profile_id_connector_name\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_profile_id_connector_name", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account lookup"}, {"query": "how to get merchant connector account using profile id and connector name", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_profile_id_connector_name\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_profile_id_connector_name", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account lookup"}, {"query": "hyperswitch storage impl merchant connector account lookup function", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_profile_id_connector_name\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_profile_id_connector_name", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account lookup"}, {"query": "rust code find_merchant_connector_account_by_profile_id_connector_name implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_profile_id_connector_name\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_profile_id_connector_name", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account lookup"}, {"query": "how to implement setup mandate request for Powertranz connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Powertranz\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz Setup Mandate Request Builder"}, {"query": "Powertranz connector setup mandate function error NotImplemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Powertranz\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz Setup Mandate Request Builder"}, {"query": "hyperswitch powertranz build_request setup mandate", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Powertranz\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz Setup Mandate Request Builder"}, {"query": "why is setup mandate flow not implemented in powertranz connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Powertranz\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz Setup Mandate Request Builder"}, {"query": "How do I configure archipel connector to use customer specific application selection?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ApplicationSelectionIndicator\npub enum ApplicationSelectionIndicator {\n    #[default]\n    ByDefault,\n    CustomerChoice,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "ApplicationSelectionIndicator", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel connector application selection strategy"}, {"query": "Rust enum ApplicationSelectionIndicator usage in archipel connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ApplicationSelectionIndicator\npub enum ApplicationSelectionIndicator {\n    #[default]\n    ByDefault,\n    CustomerChoice,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "ApplicationSelectionIndicator", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel connector application selection strategy"}, {"query": "Hyperswitch archipel transformer customer choice routing logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ApplicationSelectionIndicator\npub enum ApplicationSelectionIndicator {\n    #[default]\n    ByDefault,\n    CustomerChoice,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "ApplicationSelectionIndicator", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel connector application selection strategy"}, {"query": "ApplicationSelectionIndicator ByDefault vs CustomerChoice behavior", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ApplicationSelectionIndicator\npub enum ApplicationSelectionIndicator {\n    #[default]\n    ByDefault,\n    CustomerChoice,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "ApplicationSelectionIndicator", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel connector application selection strategy"}, {"query": "Signifyd fraud coverage enum values", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: CoverageRequests\npub enum CoverageRequests {\n    Fraud, // use when you need a financial guarantee for Payment Fraud.\n    Inr,   // use when you need a financial guarantee for Item Not Received.\n    Snad, // use when you need a financial guarantee for fraud alleging items are Significantly Not As Described.\n    All,  // use when you need a financial guarantee on all chargebacks.\n    None, // use when you do not need a financial guarantee. Suggested actions in decision.checkpointAction are recommendations.\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "CoverageRequests", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud coverage enum"}, {"query": "how to configure Signifyd chargeback coverage in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: CoverageRequests\npub enum CoverageRequests {\n    Fraud, // use when you need a financial guarantee for Payment Fraud.\n    Inr,   // use when you need a financial guarantee for Item Not Received.\n    Snad, // use when you need a financial guarantee for fraud alleging items are Significantly Not As Described.\n    All,  // use when you need a financial guarantee on all chargebacks.\n    None, // use when you do not need a financial guarantee. Suggested actions in decision.checkpointAction are recommendations.\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "CoverageRequests", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud coverage enum"}, {"query": "Signifyd fraud types enum definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: CoverageRequests\npub enum CoverageRequests {\n    Fraud, // use when you need a financial guarantee for Payment Fraud.\n    Inr,   // use when you need a financial guarantee for Item Not Received.\n    Snad, // use when you need a financial guarantee for fraud alleging items are Significantly Not As Described.\n    All,  // use when you need a financial guarantee on all chargebacks.\n    None, // use when you do not need a financial guarantee. Suggested actions in decision.checkpointAction are recommendations.\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "CoverageRequests", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud coverage enum"}, {"query": "hyperswitch signifyd fraud guarantee options", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: CoverageRequests\npub enum CoverageRequests {\n    Fraud, // use when you need a financial guarantee for Payment Fraud.\n    Inr,   // use when you need a financial guarantee for Item Not Received.\n    Snad, // use when you need a financial guarantee for fraud alleging items are Significantly Not As Described.\n    All,  // use when you need a financial guarantee on all chargebacks.\n    None, // use when you do not need a financial guarantee. Suggested actions in decision.checkpointAction are recommendations.\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "CoverageRequests", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud coverage enum"}, {"query": "how to handle gigadat payment response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: gigadat::GigadatPaymentResponse = res\n            .response\n            .parse_struct(\"GigadatPaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Response Handler"}, {"query": "rust function parse_struct gigadat response hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: gigadat::GigadatPaymentResponse = res\n            .response\n            .parse_struct(\"GigadatPaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Response Handler"}, {"query": "gigadat connector handle_response implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: gigadat::GigadatPaymentResponse = res\n            .response\n            .parse_struct(\"GigadatPaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Response Handler"}, {"query": "hyperswitch gigadat authorization response handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: gigadat::GigadatPaymentResponse = res\n            .response\n            .parse_struct(\"GigadatPaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Response Handler"}, {"query": "how to parse netcetera webhook results response data in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        let webhook_body_value: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseDatae\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body_value))\n    }\n", "function_name": "get_webhook_resource_object", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "netcetera webhook payload deserialization"}, {"query": "hyperswitch netcetera connector webhook body deserialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        let webhook_body_value: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseDatae\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body_value))\n    }\n", "function_name": "get_webhook_resource_object", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "netcetera webhook payload deserialization"}, {"query": "rust struct parsing for netcetera results response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        let webhook_body_value: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseDatae\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body_value))\n    }\n", "function_name": "get_webhook_resource_object", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "netcetera webhook payload deserialization"}, {"query": "hyperswitch webhook resource object netcetera implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        let webhook_body_value: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseDatae\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body_value))\n    }\n", "function_name": "get_webhook_resource_object", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "netcetera webhook payload deserialization"}, {"query": "Worldpay Modular PSync response structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WroldpayModularActualPsyncResponseObj\npub struct WroldpayModularActualPsyncResponseObj {\n    pub last_event: PaymentOutcome,\n    pub value: super::PaymentValue,\n}\n\n// Sent for settlement plays totally differnt role in worldpaymodular in webhooks and psync\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "function_name": "WroldpayModularActualPsyncResponseObj", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular PSync Response"}, {"query": "WroldpayModularActualPsyncResponseObj Rust struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WroldpayModularActualPsyncResponseObj\npub struct WroldpayModularActualPsyncResponseObj {\n    pub last_event: PaymentOutcome,\n    pub value: super::PaymentValue,\n}\n\n// Sent for settlement plays totally differnt role in worldpaymodular in webhooks and psync\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "function_name": "WroldpayModularActualPsyncResponseObj", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular PSync Response"}, {"query": "Worldpay Modular payment sync payload fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WroldpayModularActualPsyncResponseObj\npub struct WroldpayModularActualPsyncResponseObj {\n    pub last_event: PaymentOutcome,\n    pub value: super::PaymentValue,\n}\n\n// Sent for settlement plays totally differnt role in worldpaymodular in webhooks and psync\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "function_name": "WroldpayModularActualPsyncResponseObj", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular PSync Response"}, {"query": "hyperswitch worldpaymodular psync response object", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WroldpayModularActualPsyncResponseObj\npub struct WroldpayModularActualPsyncResponseObj {\n    pub last_event: PaymentOutcome,\n    pub value: super::PaymentValue,\n}\n\n// Sent for settlement plays totally differnt role in worldpaymodular in webhooks and psync\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "function_name": "WroldpayModularActualPsyncResponseObj", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular PSync Response"}, {"query": "rust hyperswitch create user without password validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new_password_without_validation\n    pub fn new_password_without_validation(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n        if password.is_empty() {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "function_name": "new_password_without_validation", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User builder bypass validation"}, {"query": "hyperswitch new_password_without_validation function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new_password_without_validation\n    pub fn new_password_without_validation(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n        if password.is_empty() {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "function_name": "new_password_without_validation", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User builder bypass validation"}, {"query": "how to bypass password validation in hyperswitch user creation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new_password_without_validation\n    pub fn new_password_without_validation(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n        if password.is_empty() {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "function_name": "new_password_without_validation", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User builder bypass validation"}, {"query": "rust hyperswitch user builder without validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new_password_without_validation\n    pub fn new_password_without_validation(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n        if password.is_empty() {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "function_name": "new_password_without_validation", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User builder bypass validation"}, {"query": "how to configure gigadat connector authentication headers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector header builder"}, {"query": "rust hyperswitch gigadat build_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector header builder"}, {"query": "hyperswitch gigadat connector request header setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector header builder"}, {"query": "gigadat api authentication header hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector header builder"}, {"query": "how to format amount for globepay authorization request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = globepay::GlobepayRouterData::from((amount, req));\n        let connector_req = globepay::GlobepayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization request builder"}, {"query": "globepay connector request body structure rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = globepay::GlobepayRouterData::from((amount, req));\n        let connector_req = globepay::GlobepayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization request builder"}, {"query": "PaymentsAuthorizeRouterData to GlobepayPaymentsRequest conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = globepay::GlobepayRouterData::from((amount, req));\n        let connector_req = globepay::GlobepayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization request builder"}, {"query": "hyperswitch globepay connector get_request_body implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = globepay::GlobepayRouterData::from((amount, req));\n        let connector_req = globepay::GlobepayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization request builder"}, {"query": "hyperswitch update_payment_intent function signature rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: update_payment_intent\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n", "function_name": "update_payment_intent", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent update interface"}, {"query": "how to modify payment intent amount in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: update_payment_intent\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n", "function_name": "update_payment_intent", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent update interface"}, {"query": "rust hyperswitch payment intent update interface", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: update_payment_intent\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n", "function_name": "update_payment_intent", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent update interface"}, {"query": "hyperswitch domain models update_payment_intent implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: update_payment_intent\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n", "function_name": "update_payment_intent", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent update interface"}, {"query": "rust hyperswitch get_id merchant connector account", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_id\n    pub fn get_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.id.clone())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnectorAccount ID retrieval"}, {"query": "how to retrieve merchant connector account id in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_id\n    pub fn get_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.id.clone())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnectorAccount ID retrieval"}, {"query": "hyperswitch domain models merchant connector account identifier", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_id\n    pub fn get_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.id.clone())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnectorAccount ID retrieval"}, {"query": "rust enum get_id merchant connector account hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_id\n    pub fn get_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.id.clone())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnectorAccount ID retrieval"}, {"query": "how to handle Powertranz API error responses in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz error response handler"}, {"query": "Powertranz connector error handling implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz error response handler"}, {"query": "build_error_response function signature rust connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz error response handler"}, {"query": "hyperswitch powertranz error mapping connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz error response handler"}, {"query": "rust hyperswitch zift connector get_url function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate router URL builder"}, {"query": "how to configure zift mandate router endpoint in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate router URL builder"}, {"query": "hyperswitch zift connector setup_mandate_router_data get_url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate router URL builder"}, {"query": "rust hyperswitch zift base_url gates/xurl endpoint", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate router URL builder"}, {"query": "how to specify custom config file path for hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CmdLineConf\npub struct CmdLineConf {\n    /// Config file.\n    /// Application will look for \"config/config.toml\" if this option isn't specified.\n    #[arg(short = 'f', long, value_name = \"FILE\")]\n    pub config_path: Option<PathBuf>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "function_name": "CmdLineConf", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router CLI Config Entry"}, {"query": "hyperswitch router config_path argument default location", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CmdLineConf\npub struct CmdLineConf {\n    /// Config file.\n    /// Application will look for \"config/config.toml\" if this option isn't specified.\n    #[arg(short = 'f', long, value_name = \"FILE\")]\n    pub config_path: Option<PathBuf>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "function_name": "CmdLineConf", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router CLI Config Entry"}, {"query": "CmdLineConf struct usage in hyperswitch router binary", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CmdLineConf\npub struct CmdLineConf {\n    /// Config file.\n    /// Application will look for \"config/config.toml\" if this option isn't specified.\n    #[arg(short = 'f', long, value_name = \"FILE\")]\n    pub config_path: Option<PathBuf>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "function_name": "CmdLineConf", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router CLI Config Entry"}, {"query": "clap argument parsing for hyperswitch config file", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CmdLineConf\npub struct CmdLineConf {\n    /// Config file.\n    /// Application will look for \"config/config.toml\" if this option isn't specified.\n    #[arg(short = 'f', long, value_name = \"FILE\")]\n    pub config_path: Option<PathBuf>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "function_name": "CmdLineConf", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router CLI Config Entry"}, {"query": "How do I map Klarna shipping address fields to Hyperswitch internal structures?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaShippingAddress\npub struct KlarnaShippingAddress {\n    city: String,\n    country: enums::CountryAlpha2,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    phone: Secret<String>,\n    postal_code: Secret<String>,\n    region: Secret<String>,\n    street_address: Secret<String>,\n    street_address2: Option<Secret<String>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "function_name": "KlarnaShippingAddress", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna shipping address transformation struct"}, {"query": "Rust struct definition for Klarna shipping address transformation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaShippingAddress\npub struct KlarnaShippingAddress {\n    city: String,\n    country: enums::CountryAlpha2,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    phone: Secret<String>,\n    postal_code: Secret<String>,\n    region: Secret<String>,\n    street_address: Secret<String>,\n    street_address2: Option<Secret<String>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "function_name": "KlarnaShippingAddress", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna shipping address transformation struct"}, {"query": "hyperswitch connectors Klarna shipping address pii handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaShippingAddress\npub struct KlarnaShippingAddress {\n    city: String,\n    country: enums::CountryAlpha2,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    phone: Secret<String>,\n    postal_code: Secret<String>,\n    region: Secret<String>,\n    street_address: Secret<String>,\n    street_address2: Option<Secret<String>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "function_name": "KlarnaShippingAddress", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna shipping address transformation struct"}, {"query": "What fields are required in KlarnaShippingAddress struct?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaShippingAddress\npub struct KlarnaShippingAddress {\n    city: String,\n    country: enums::CountryAlpha2,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    phone: Secret<String>,\n    postal_code: Secret<String>,\n    region: Secret<String>,\n    street_address: Secret<String>,\n    street_address2: Option<Secret<String>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "function_name": "KlarnaShippingAddress", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna shipping address transformation struct"}, {"query": "how to get payment intent by id in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_id\n    async fn find_payment_intent_by_id(\n        &self,\n        id: &id_type::GlobalPaymentId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "find_payment_intent_by_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "payment intent retrieval"}, {"query": "hyperswitch find_payment_intent_by_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_id\n    async fn find_payment_intent_by_id(\n        &self,\n        id: &id_type::GlobalPaymentId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "find_payment_intent_by_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "payment intent retrieval"}, {"query": "rust payment intent retrieval function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_id\n    async fn find_payment_intent_by_id(\n        &self,\n        id: &id_type::GlobalPaymentId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "find_payment_intent_by_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "payment intent retrieval"}, {"query": "hyperswitch domain models payment intent lookup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_id\n    async fn find_payment_intent_by_id(\n        &self,\n        id: &id_type::GlobalPaymentId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "find_payment_intent_by_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "payment intent retrieval"}, {"query": "helcim rust connector handle_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: helcim::HelcimPaymentsResponse = res\n            .response\n            .parse_struct(\"Helcim PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Response Handler"}, {"query": "how to parse helcim payments response in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: helcim::HelcimPaymentsResponse = res\n            .response\n            .parse_struct(\"Helcim PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Response Handler"}, {"query": "helcim payments authorize response deserialization hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: helcim::HelcimPaymentsResponse = res\n            .response\n            .parse_struct(\"Helcim PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Response Handler"}, {"query": "hyperswitch helcim connector handle_response unit test", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: helcim::HelcimPaymentsResponse = res\n            .response\n            .parse_struct(\"Helcim PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Response Handler"}, {"query": "Airwallex connector get_url function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}{}\",\n            self.base_url(connectors),\n            \"api/v1/pa/customers/create\"\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex customer creation URL builder"}, {"query": "how to construct Airwallex customer creation API endpoint", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}{}\",\n            self.base_url(connectors),\n            \"api/v1/pa/customers/create\"\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex customer creation URL builder"}, {"query": "hyperswitch airwallex connector get_url method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}{}\",\n            self.base_url(connectors),\n            \"api/v1/pa/customers/create\"\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex customer creation URL builder"}, {"query": "Airwallex API URL generation in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}{}\",\n            self.base_url(connectors),\n            \"api/v1/pa/customers/create\"\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex customer creation URL builder"}, {"query": "how to configure payone payout headers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Headers"}, {"query": "hyperswitch payone connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Headers"}, {"query": "rust hyperswitch payone payout authentication headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Headers"}, {"query": "payone payout request header construction hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Headers"}, {"query": "How do I configure Archipel connector to pay on behalf of a merchant?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentInitiator\npub enum ArchipelPaymentInitiator {\n    #[default]\n    Customer,\n    Merchant,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "ArchipelPaymentInitiator", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment initiator enum"}, {"query": "ArchipelPaymentInitiator enum variants in hyperswitch connectors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentInitiator\npub enum ArchipelPaymentInitiator {\n    #[default]\n    Customer,\n    Merchant,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "ArchipelPaymentInitiator", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment initiator enum"}, {"query": "Difference between Customer and Merchant payment initiator in Archipel", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentInitiator\npub enum ArchipelPaymentInitiator {\n    #[default]\n    Customer,\n    Merchant,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "ArchipelPaymentInitiator", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment initiator enum"}, {"query": "Configure Archipel payment source type in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentInitiator\npub enum ArchipelPaymentInitiator {\n    #[default]\n    Customer,\n    Merchant,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "ArchipelPaymentInitiator", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment initiator enum"}, {"query": "rust hyperswitch powertranz connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector header configuration"}, {"query": "how to configure headers for powertranz payment gateway in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector header configuration"}, {"query": "hyperswitch powertranz authorize request headers builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector header configuration"}, {"query": "rust function get_headers powertranz hyperswitch connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector header configuration"}, {"query": "rust hyperswitch zift connector implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Zift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Zift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift Payment Gateway Connector"}, {"query": "how to implement zift payment gateway in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Zift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Zift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift Payment Gateway Connector"}, {"query": "hyperswitch zift connector integration code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Zift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Zift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift Payment Gateway Connector"}, {"query": "zift payment gateway rust hyperswitch trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Zift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Zift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift Payment Gateway Connector"}, {"query": "rust hyperswitch AuthenticationEligibilityResponse struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityResponse\npub struct AuthenticationEligibilityResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = NextAction)]\n    pub next_action: NextAction,\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n    /// The 3DS data for this authentication.\n    #[schema(value_type = Option<EligibilityResponseParams>)]\n    pub eligibility_response_params: Option<EligibilityResponseParams>,\n    /// The metadata for this authentication.\n    #[schema(value_type = serde_json::Value)]\n    pub connector_metadata: Option<serde_json::Value>,\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String)]\n    pub profile_id: id_type::ProfileId,\n    /// The error message for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_message: Option<String>,\n    /// The error code for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_code: Option<String>,\n    /// The connector used for this authentication.\n    #[schema(value_type = Option<AuthenticationConnectors>)]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n    /// Billing address\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n    /// Shipping address\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n    /// Browser information\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n    /// Email\n    #[schema(value_type = Option<String>)]\n    pub email: common_utils::crypto::OptionalEncryptableEmail,\n    /// Acquirer details information.\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Serialize, Deserialize, ToSchema)]", "function_name": "AuthenticationEligibilityResponse", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication Response Model"}, {"query": "hyperswitch router authentication response model next_action", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityResponse\npub struct AuthenticationEligibilityResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = NextAction)]\n    pub next_action: NextAction,\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n    /// The 3DS data for this authentication.\n    #[schema(value_type = Option<EligibilityResponseParams>)]\n    pub eligibility_response_params: Option<EligibilityResponseParams>,\n    /// The metadata for this authentication.\n    #[schema(value_type = serde_json::Value)]\n    pub connector_metadata: Option<serde_json::Value>,\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String)]\n    pub profile_id: id_type::ProfileId,\n    /// The error message for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_message: Option<String>,\n    /// The error code for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_code: Option<String>,\n    /// The connector used for this authentication.\n    #[schema(value_type = Option<AuthenticationConnectors>)]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n    /// Billing address\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n    /// Shipping address\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n    /// Browser information\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n    /// Email\n    #[schema(value_type = Option<String>)]\n    pub email: common_utils::crypto::OptionalEncryptableEmail,\n    /// Acquirer details information.\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Serialize, Deserialize, ToSchema)]", "function_name": "AuthenticationEligibilityResponse", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication Response Model"}, {"query": "AuthenticationEligibilityResponse authentication_id connector_metadata rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityResponse\npub struct AuthenticationEligibilityResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = NextAction)]\n    pub next_action: NextAction,\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n    /// The 3DS data for this authentication.\n    #[schema(value_type = Option<EligibilityResponseParams>)]\n    pub eligibility_response_params: Option<EligibilityResponseParams>,\n    /// The metadata for this authentication.\n    #[schema(value_type = serde_json::Value)]\n    pub connector_metadata: Option<serde_json::Value>,\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String)]\n    pub profile_id: id_type::ProfileId,\n    /// The error message for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_message: Option<String>,\n    /// The error code for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_code: Option<String>,\n    /// The connector used for this authentication.\n    #[schema(value_type = Option<AuthenticationConnectors>)]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n    /// Billing address\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n    /// Shipping address\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n    /// Browser information\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n    /// Email\n    #[schema(value_type = Option<String>)]\n    pub email: common_utils::crypto::OptionalEncryptableEmail,\n    /// Acquirer details information.\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Serialize, Deserialize, ToSchema)]", "function_name": "AuthenticationEligibilityResponse", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication Response Model"}, {"query": "hyperswitch authentication eligibility params struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityResponse\npub struct AuthenticationEligibilityResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = NextAction)]\n    pub next_action: NextAction,\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n    /// The 3DS data for this authentication.\n    #[schema(value_type = Option<EligibilityResponseParams>)]\n    pub eligibility_response_params: Option<EligibilityResponseParams>,\n    /// The metadata for this authentication.\n    #[schema(value_type = serde_json::Value)]\n    pub connector_metadata: Option<serde_json::Value>,\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String)]\n    pub profile_id: id_type::ProfileId,\n    /// The error message for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_message: Option<String>,\n    /// The error code for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_code: Option<String>,\n    /// The connector used for this authentication.\n    #[schema(value_type = Option<AuthenticationConnectors>)]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n    /// Billing address\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n    /// Shipping address\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n    /// Browser information\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n    /// Email\n    #[schema(value_type = Option<String>)]\n    pub email: common_utils::crypto::OptionalEncryptableEmail,\n    /// Acquirer details information.\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Serialize, Deserialize, ToSchema)]", "function_name": "AuthenticationEligibilityResponse", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication Response Model"}, {"query": "How to configure analytics providers for multiple tenants in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_pools_map\n    pub async fn get_pools_map(\n        &self,\n        analytics_config: &AnalyticsConfig,\n    ) -> HashMap<id_type::TenantId, AnalyticsProvider> {\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            (\n                tenant_name.clone(),\n                AnalyticsProvider::from_conf(analytics_config, tenant).await,\n            )\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n}\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "get_pools_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Tenant Analytics Provider Mapping"}, {"query": "Rust function to get analytics provider map from tenant config", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_pools_map\n    pub async fn get_pools_map(\n        &self,\n        analytics_config: &AnalyticsConfig,\n    ) -> HashMap<id_type::TenantId, AnalyticsProvider> {\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            (\n                tenant_name.clone(),\n                AnalyticsProvider::from_conf(analytics_config, tenant).await,\n            )\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n}\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "get_pools_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Tenant Analytics Provider Mapping"}, {"query": "hyperswitch router get_pools_map implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_pools_map\n    pub async fn get_pools_map(\n        &self,\n        analytics_config: &AnalyticsConfig,\n    ) -> HashMap<id_type::TenantId, AnalyticsProvider> {\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            (\n                tenant_name.clone(),\n                AnalyticsProvider::from_conf(analytics_config, tenant).await,\n            )\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n}\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "get_pools_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Tenant Analytics Provider Mapping"}, {"query": "How does router handle analytics configuration for different tenants", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_pools_map\n    pub async fn get_pools_map(\n        &self,\n        analytics_config: &AnalyticsConfig,\n    ) -> HashMap<id_type::TenantId, AnalyticsProvider> {\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            (\n                tenant_name.clone(),\n                AnalyticsProvider::from_conf(analytics_config, tenant).await,\n            )\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n}\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "get_pools_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Tenant Analytics Provider Mapping"}, {"query": "rust hyperswitch euclid get_values_by_key implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: get_values_by_key\n    fn get_values_by_key(\n        &self,\n        key: &<Self::Value as cgraph::ValueNode>::Key,\n    ) -> Option<Vec<Self::Value>> {\n        self.keywise_values\n            .get(key)\n            .map(|set| set.iter().cloned().collect())\n    }\n}\n", "function_name": "get_values_by_key", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "euclid graph key retrieval"}, {"query": "how to retrieve values by key in euclid crate", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: get_values_by_key\n    fn get_values_by_key(\n        &self,\n        key: &<Self::Value as cgraph::ValueNode>::Key,\n    ) -> Option<Vec<Self::Value>> {\n        self.keywise_values\n            .get(key)\n            .map(|set| set.iter().cloned().collect())\n    }\n}\n", "function_name": "get_values_by_key", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "euclid graph key retrieval"}, {"query": "hyperswitch euclid graph keywise_values map", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: get_values_by_key\n    fn get_values_by_key(\n        &self,\n        key: &<Self::Value as cgraph::ValueNode>::Key,\n    ) -> Option<Vec<Self::Value>> {\n        self.keywise_values\n            .get(key)\n            .map(|set| set.iter().cloned().collect())\n    }\n}\n", "function_name": "get_values_by_key", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "euclid graph key retrieval"}, {"query": "rust trait method get_values_by_key example", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: get_values_by_key\n    fn get_values_by_key(\n        &self,\n        key: &<Self::Value as cgraph::ValueNode>::Key,\n    ) -> Option<Vec<Self::Value>> {\n        self.keywise_values\n            .get(key)\n            .map(|set| set.iter().cloned().collect())\n    }\n}\n", "function_name": "get_values_by_key", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "euclid graph key retrieval"}, {"query": "rust hyperswitch get_card_data function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_card_data\n    pub fn get_card_data(&self) -> Option<&Card> {\n        if let Self::Card(card) = self {\n            Some(card)\n        } else {\n            None\n        }\n    }\n", "function_name": "get_card_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Card data extraction from enum"}, {"query": "how to extract card details from PaymentMethodData enum", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_card_data\n    pub fn get_card_data(&self) -> Option<&Card> {\n        if let Self::Card(card) = self {\n            Some(card)\n        } else {\n            None\n        }\n    }\n", "function_name": "get_card_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Card data extraction from enum"}, {"query": "hyperswitch domain models Card variant access", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_card_data\n    pub fn get_card_data(&self) -> Option<&Card> {\n        if let Self::Card(card) = self {\n            Some(card)\n        } else {\n            None\n        }\n    }\n", "function_name": "get_card_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Card data extraction from enum"}, {"query": "rust Option<&Card> pattern in hyperswitch payment methods", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_card_data\n    pub fn get_card_data(&self) -> Option<&Card> {\n        if let Self::Card(card) = self {\n            Some(card)\n        } else {\n            None\n        }\n    }\n", "function_name": "get_card_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Card data extraction from enum"}, {"query": "rust hyperswitch MaskedBankAccount constructor unwrap secret", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(secret: Secret<String>) -> Self {\n        Self::from(secret.expose())\n    }\n}\n\n#[cfg(test)]\nmod apply_mask_fn_test {\n    use masking::PeekInterface;\n\n    use crate::new_type::{\n        apply_mask, MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode,\n        MaskedUpiVpaId,\n    };\n    #[test]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Secret new_type constructor"}, {"query": "how to create MaskedBankAccount from Secret<String> in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(secret: Secret<String>) -> Self {\n        Self::from(secret.expose())\n    }\n}\n\n#[cfg(test)]\nmod apply_mask_fn_test {\n    use masking::PeekInterface;\n\n    use crate::new_type::{\n        apply_mask, MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode,\n        MaskedUpiVpaId,\n    };\n    #[test]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Secret new_type constructor"}, {"query": "hyperswitch common_utils new_type Secret expose method", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(secret: Secret<String>) -> Self {\n        Self::from(secret.expose())\n    }\n}\n\n#[cfg(test)]\nmod apply_mask_fn_test {\n    use masking::PeekInterface;\n\n    use crate::new_type::{\n        apply_mask, MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode,\n        MaskedUpiVpaId,\n    };\n    #[test]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Secret new_type constructor"}, {"query": "rust Secret new_type from implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(secret: Secret<String>) -> Self {\n        Self::from(secret.expose())\n    }\n}\n\n#[cfg(test)]\nmod apply_mask_fn_test {\n    use masking::PeekInterface;\n\n    use crate::new_type::{\n        apply_mask, MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode,\n        MaskedUpiVpaId,\n    };\n    #[test]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Secret new_type constructor"}, {"query": "rust hyperswitch gpayments connector get_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments connector header retrieval"}, {"query": "how to implement get_headers for gpayments connector in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments connector header retrieval"}, {"query": "hyperswitch gpayments authentication header generation rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments connector header retrieval"}, {"query": "rust hyperswitch gpayments connector build_headers wrapper", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments connector header retrieval"}, {"query": "how to handle Juspay 3DS error response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverErrorResponse = res\n            .response\n            .parse_struct(\"JuspaythreedsserverErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Error Response Builder"}, {"query": "build_error_response function implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverErrorResponse = res\n            .response\n            .parse_struct(\"JuspaythreedsserverErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Error Response Builder"}, {"query": "parse JuspaythreedsserverErrorResponse struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverErrorResponse = res\n            .response\n            .parse_struct(\"JuspaythreedsserverErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Error Response Builder"}, {"query": "hyperswitch connector error handling Juspay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverErrorResponse = res\n            .response\n            .parse_struct(\"JuspaythreedsserverErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Error Response Builder"}, {"query": "how to handle boku connector error responses in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response_data: Result<boku::BokuErrorResponse, Report<errors::ConnectorError>> = res\n            .response\n            .parse_struct(\"boku::BokuErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed);\n\n        match response_data {\n            Ok(response) => {\n                event_builder.map(|i| i.set_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.reason,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(_) => get_xml_deserialized(res, event_builder),\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku error response builder"}, {"query": "build_error_response function implementation hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response_data: Result<boku::BokuErrorResponse, Report<errors::ConnectorError>> = res\n            .response\n            .parse_struct(\"boku::BokuErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed);\n\n        match response_data {\n            Ok(response) => {\n                event_builder.map(|i| i.set_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.reason,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(_) => get_xml_deserialized(res, event_builder),\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku error response builder"}, {"query": "parse boku error response struct hyperswitch connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response_data: Result<boku::BokuErrorResponse, Report<errors::ConnectorError>> = res\n            .response\n            .parse_struct(\"boku::BokuErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed);\n\n        match response_data {\n            Ok(response) => {\n                event_builder.map(|i| i.set_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.reason,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(_) => get_xml_deserialized(res, event_builder),\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku error response builder"}, {"query": "hyperswitch boku integration error handling rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response_data: Result<boku::BokuErrorResponse, Report<errors::ConnectorError>> = res\n            .response\n            .parse_struct(\"boku::BokuErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed);\n\n        match response_data {\n            Ok(response) => {\n                event_builder.map(|i| i.set_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.reason,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(_) => get_xml_deserialized(res, event_builder),\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku error response builder"}, {"query": "Rust struct definition for ConnectorCustomerData hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ConnectorCustomerData\npub struct ConnectorCustomerData {\n    pub description: Option<String>,\n    pub email: Option<pii::Email>,\n    pub phone: Option<Secret<String>>,\n    pub name: Option<Secret<String>>,\n    pub preprocessing_id: Option<String>,\n    pub payment_method_data: Option<PaymentMethodData>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub billing_address: Option<AddressDetails>,\n    pub metadata: Option<Secret<serde_json::Value>>,\n    pub currency: Option<storage_enums::Currency>,\n}\n", "function_name": "ConnectorCustomerData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Customer Data Transfer Object"}, {"query": "hyperswitch router customer data struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ConnectorCustomerData\npub struct ConnectorCustomerData {\n    pub description: Option<String>,\n    pub email: Option<pii::Email>,\n    pub phone: Option<Secret<String>>,\n    pub name: Option<Secret<String>>,\n    pub preprocessing_id: Option<String>,\n    pub payment_method_data: Option<PaymentMethodData>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub billing_address: Option<AddressDetails>,\n    pub metadata: Option<Secret<serde_json::Value>>,\n    pub currency: Option<storage_enums::Currency>,\n}\n", "function_name": "ConnectorCustomerData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Customer Data Transfer Object"}, {"query": "how to define ConnectorCustomerData in hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ConnectorCustomerData\npub struct ConnectorCustomerData {\n    pub description: Option<String>,\n    pub email: Option<pii::Email>,\n    pub phone: Option<Secret<String>>,\n    pub name: Option<Secret<String>>,\n    pub preprocessing_id: Option<String>,\n    pub payment_method_data: Option<PaymentMethodData>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub billing_address: Option<AddressDetails>,\n    pub metadata: Option<Secret<serde_json::Value>>,\n    pub currency: Option<storage_enums::Currency>,\n}\n", "function_name": "ConnectorCustomerData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Customer Data Transfer Object"}, {"query": "ConnectorCustomerData hyperswitch payment orchestration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ConnectorCustomerData\npub struct ConnectorCustomerData {\n    pub description: Option<String>,\n    pub email: Option<pii::Email>,\n    pub phone: Option<Secret<String>>,\n    pub name: Option<Secret<String>>,\n    pub preprocessing_id: Option<String>,\n    pub payment_method_data: Option<PaymentMethodData>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub billing_address: Option<AddressDetails>,\n    pub metadata: Option<Secret<serde_json::Value>>,\n    pub currency: Option<storage_enums::Currency>,\n}\n", "function_name": "ConnectorCustomerData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Customer Data Transfer Object"}, {"query": "How to get the response ID string from a Worldpay event in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_response_id_str\n    pub fn get_response_id_str(\n        &self,\n    ) -> Result<ResponseIdStr, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id_str())\n    }", "function_name": "get_response_id_str", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay response ID extractor"}, {"query": "Worldpay connector error MissingRequiredField href resource id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_response_id_str\n    pub fn get_response_id_str(\n        &self,\n    ) -> Result<ResponseIdStr, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id_str())\n    }", "function_name": "get_response_id_str", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay response ID extractor"}, {"query": "Hyperswitch get_response_id_str function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_response_id_str\n    pub fn get_response_id_str(\n        &self,\n    ) -> Result<ResponseIdStr, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id_str())\n    }", "function_name": "get_response_id_str", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay response ID extractor"}, {"query": "Extract resource ID from Worldpay response transformer", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_response_id_str\n    pub fn get_response_id_str(\n        &self,\n    ) -> Result<ResponseIdStr, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id_str())\n    }", "function_name": "get_response_id_str", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay response ID extractor"}, {"query": "how to handle mandate revoke response status 204 in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &MandateRevokeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<MandateRevokeRouterData, errors::ConnectorError> {\n        if matches!(res.status_code, 204) {\n            event_builder.map(|i| i.set_response_body(&serde_json::json!({\"mandate_status\": common_enums::MandateStatus::Revoked.to_string()})));\n            Ok(MandateRevokeRouterData {\n                response: Ok(MandateRevokeResponseData {\n                    mandate_status: common_enums::MandateStatus::Revoked,\n                }),\n                ..data.clone()\n            })\n        } else {\n            // If http_code != 204 || http_code != 4xx, we dont know any other response scenario yet.\n            let response_value: serde_json::Value = serde_json::from_slice(&res.response)\n                .change_context(errors::ConnectorError::ResponseHandlingFailed)?;\n            let response_string = response_value.to_string();\n\n            event_builder.map(|i| {\n                i.set_response_body(\n                    &serde_json::json!({\"response_string\": response_string.clone()}),\n                )\n            });\n            router_env::logger::info!(connector_response=?response_string);\n\n            Ok(MandateRevokeRouterData {\n                response: Err(ErrorResponse {\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response_string.clone(),\n                    reason: Some(response_string),\n                    status_code: res.status_code,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..data.clone()\n            })\n        }\n    }", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Mandate Revoke Response Handler"}, {"query": "wellsfargo mandate revoke connector error handling rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &MandateRevokeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<MandateRevokeRouterData, errors::ConnectorError> {\n        if matches!(res.status_code, 204) {\n            event_builder.map(|i| i.set_response_body(&serde_json::json!({\"mandate_status\": common_enums::MandateStatus::Revoked.to_string()})));\n            Ok(MandateRevokeRouterData {\n                response: Ok(MandateRevokeResponseData {\n                    mandate_status: common_enums::MandateStatus::Revoked,\n                }),\n                ..data.clone()\n            })\n        } else {\n            // If http_code != 204 || http_code != 4xx, we dont know any other response scenario yet.\n            let response_value: serde_json::Value = serde_json::from_slice(&res.response)\n                .change_context(errors::ConnectorError::ResponseHandlingFailed)?;\n            let response_string = response_value.to_string();\n\n            event_builder.map(|i| {\n                i.set_response_body(\n                    &serde_json::json!({\"response_string\": response_string.clone()}),\n                )\n            });\n            router_env::logger::info!(connector_response=?response_string);\n\n            Ok(MandateRevokeRouterData {\n                response: Err(ErrorResponse {\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response_string.clone(),\n                    reason: Some(response_string),\n                    status_code: res.status_code,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..data.clone()\n            })\n        }\n    }", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Mandate Revoke Response Handler"}, {"query": "hyperswitch mandate_revoke_router_data response parsing", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &MandateRevokeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<MandateRevokeRouterData, errors::ConnectorError> {\n        if matches!(res.status_code, 204) {\n            event_builder.map(|i| i.set_response_body(&serde_json::json!({\"mandate_status\": common_enums::MandateStatus::Revoked.to_string()})));\n            Ok(MandateRevokeRouterData {\n                response: Ok(MandateRevokeResponseData {\n                    mandate_status: common_enums::MandateStatus::Revoked,\n                }),\n                ..data.clone()\n            })\n        } else {\n            // If http_code != 204 || http_code != 4xx, we dont know any other response scenario yet.\n            let response_value: serde_json::Value = serde_json::from_slice(&res.response)\n                .change_context(errors::ConnectorError::ResponseHandlingFailed)?;\n            let response_string = response_value.to_string();\n\n            event_builder.map(|i| {\n                i.set_response_body(\n                    &serde_json::json!({\"response_string\": response_string.clone()}),\n                )\n            });\n            router_env::logger::info!(connector_response=?response_string);\n\n            Ok(MandateRevokeRouterData {\n                response: Err(ErrorResponse {\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response_string.clone(),\n                    reason: Some(response_string),\n                    status_code: res.status_code,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..data.clone()\n            })\n        }\n    }", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Mandate Revoke Response Handler"}, {"query": "rust function handle_response mandate revoke 204 status", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &MandateRevokeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<MandateRevokeRouterData, errors::ConnectorError> {\n        if matches!(res.status_code, 204) {\n            event_builder.map(|i| i.set_response_body(&serde_json::json!({\"mandate_status\": common_enums::MandateStatus::Revoked.to_string()})));\n            Ok(MandateRevokeRouterData {\n                response: Ok(MandateRevokeResponseData {\n                    mandate_status: common_enums::MandateStatus::Revoked,\n                }),\n                ..data.clone()\n            })\n        } else {\n            // If http_code != 204 || http_code != 4xx, we dont know any other response scenario yet.\n            let response_value: serde_json::Value = serde_json::from_slice(&res.response)\n                .change_context(errors::ConnectorError::ResponseHandlingFailed)?;\n            let response_string = response_value.to_string();\n\n            event_builder.map(|i| {\n                i.set_response_body(\n                    &serde_json::json!({\"response_string\": response_string.clone()}),\n                )\n            });\n            router_env::logger::info!(connector_response=?response_string);\n\n            Ok(MandateRevokeRouterData {\n                response: Err(ErrorResponse {\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response_string.clone(),\n                    reason: Some(response_string),\n                    status_code: res.status_code,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..data.clone()\n            })\n        }\n    }", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Mandate Revoke Response Handler"}, {"query": "how to find payment intent from refund id type in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_refund_id_type\npub async fn find_payment_intent_from_refund_id_type(\n    state: &SessionState,\n    refund_id_type: webhooks::RefundIdType,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let refund = match refund_id_type {\n        webhooks::RefundIdType::RefundId(id) => db\n            .find_refund_by_merchant_id_refund_id(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n        webhooks::RefundIdType::ConnectorRefundId(id) => db\n            .find_refund_by_merchant_id_connector_refund_id_connector(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                connector_name,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n    };\n    let attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &refund.attempt_id,\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &attempt.payment_id,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_refund_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "PaymentIntent retrieval via Refund lookup"}, {"query": "hyperswitch find_payment_intent_from_refund_id_type implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_refund_id_type\npub async fn find_payment_intent_from_refund_id_type(\n    state: &SessionState,\n    refund_id_type: webhooks::RefundIdType,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let refund = match refund_id_type {\n        webhooks::RefundIdType::RefundId(id) => db\n            .find_refund_by_merchant_id_refund_id(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n        webhooks::RefundIdType::ConnectorRefundId(id) => db\n            .find_refund_by_merchant_id_connector_refund_id_connector(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                connector_name,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n    };\n    let attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &refund.attempt_id,\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &attempt.payment_id,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_refund_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "PaymentIntent retrieval via Refund lookup"}, {"query": "rust code for retrieving payment intent via refund lookup", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_refund_id_type\npub async fn find_payment_intent_from_refund_id_type(\n    state: &SessionState,\n    refund_id_type: webhooks::RefundIdType,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let refund = match refund_id_type {\n        webhooks::RefundIdType::RefundId(id) => db\n            .find_refund_by_merchant_id_refund_id(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n        webhooks::RefundIdType::ConnectorRefundId(id) => db\n            .find_refund_by_merchant_id_connector_refund_id_connector(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                connector_name,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n    };\n    let attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &refund.attempt_id,\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &attempt.payment_id,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_refund_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "PaymentIntent retrieval via Refund lookup"}, {"query": "hyperswitch router utils find_payment_intent_from_refund_id_type", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_refund_id_type\npub async fn find_payment_intent_from_refund_id_type(\n    state: &SessionState,\n    refund_id_type: webhooks::RefundIdType,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let refund = match refund_id_type {\n        webhooks::RefundIdType::RefundId(id) => db\n            .find_refund_by_merchant_id_refund_id(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n        webhooks::RefundIdType::ConnectorRefundId(id) => db\n            .find_refund_by_merchant_id_connector_refund_id_connector(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                connector_name,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n    };\n    let attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &refund.attempt_id,\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &attempt.payment_id,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_refund_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "PaymentIntent retrieval via Refund lookup"}, {"query": "how to convert internal payment method data structures to common enums", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_payment_method\n    pub fn get_payment_method(&self) -> Option<common_enums::PaymentMethod> {\n        match self {\n            Self::Card(_)\n            | Self::NetworkToken(_)\n            | Self::CardDetailsForNetworkTransactionId(_)\n            | Self::NetworkTokenDetailsForNetworkTransactionId(_)\n            | Self::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | Self::CardWithLimitedDetails(_) => Some(common_enums::PaymentMethod::Card),\n            Self::CardRedirect(_) => Some(common_enums::PaymentMethod::CardRedirect),\n            Self::Wallet(_) => Some(common_enums::PaymentMethod::Wallet),\n            Self::PayLater(_) => Some(common_enums::PaymentMethod::PayLater),\n            Self::BankRedirect(_) => Some(common_enums::PaymentMethod::BankRedirect),\n            Self::BankDebit(_) => Some(common_enums::PaymentMethod::BankDebit),\n            Self::BankTransfer(_) => Some(common_enums::PaymentMethod::BankTransfer),\n            Self::Crypto(_) => Some(common_enums::PaymentMethod::Crypto),\n            Self::Reward => Some(common_enums::PaymentMethod::Reward),\n            Self::RealTimePayment(_) => Some(common_enums::PaymentMethod::RealTimePayment),\n            Self::Upi(_) => Some(common_enums::PaymentMethod::Upi),\n            Self::Voucher(_) => Some(common_enums::PaymentMethod::Voucher),\n            Self::GiftCard(_) => Some(common_enums::PaymentMethod::GiftCard),\n            Self::OpenBanking(_) => Some(common_enums::PaymentMethod::OpenBanking),\n            Self::MobilePayment(_) => Some(common_enums::PaymentMethod::MobilePayment),\n            Self::CardToken(_) | Self::MandatePayment => None,\n        }\n    }\n", "function_name": "get_payment_method", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment method type mapper"}, {"query": "hyperswitch get_payment_method function implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_payment_method\n    pub fn get_payment_method(&self) -> Option<common_enums::PaymentMethod> {\n        match self {\n            Self::Card(_)\n            | Self::NetworkToken(_)\n            | Self::CardDetailsForNetworkTransactionId(_)\n            | Self::NetworkTokenDetailsForNetworkTransactionId(_)\n            | Self::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | Self::CardWithLimitedDetails(_) => Some(common_enums::PaymentMethod::Card),\n            Self::CardRedirect(_) => Some(common_enums::PaymentMethod::CardRedirect),\n            Self::Wallet(_) => Some(common_enums::PaymentMethod::Wallet),\n            Self::PayLater(_) => Some(common_enums::PaymentMethod::PayLater),\n            Self::BankRedirect(_) => Some(common_enums::PaymentMethod::BankRedirect),\n            Self::BankDebit(_) => Some(common_enums::PaymentMethod::BankDebit),\n            Self::BankTransfer(_) => Some(common_enums::PaymentMethod::BankTransfer),\n            Self::Crypto(_) => Some(common_enums::PaymentMethod::Crypto),\n            Self::Reward => Some(common_enums::PaymentMethod::Reward),\n            Self::RealTimePayment(_) => Some(common_enums::PaymentMethod::RealTimePayment),\n            Self::Upi(_) => Some(common_enums::PaymentMethod::Upi),\n            Self::Voucher(_) => Some(common_enums::PaymentMethod::Voucher),\n            Self::GiftCard(_) => Some(common_enums::PaymentMethod::GiftCard),\n            Self::OpenBanking(_) => Some(common_enums::PaymentMethod::OpenBanking),\n            Self::MobilePayment(_) => Some(common_enums::PaymentMethod::MobilePayment),\n            Self::CardToken(_) | Self::MandatePayment => None,\n        }\n    }\n", "function_name": "get_payment_method", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment method type mapper"}, {"query": "mapping internal payment method variants to common_enums", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_payment_method\n    pub fn get_payment_method(&self) -> Option<common_enums::PaymentMethod> {\n        match self {\n            Self::Card(_)\n            | Self::NetworkToken(_)\n            | Self::CardDetailsForNetworkTransactionId(_)\n            | Self::NetworkTokenDetailsForNetworkTransactionId(_)\n            | Self::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | Self::CardWithLimitedDetails(_) => Some(common_enums::PaymentMethod::Card),\n            Self::CardRedirect(_) => Some(common_enums::PaymentMethod::CardRedirect),\n            Self::Wallet(_) => Some(common_enums::PaymentMethod::Wallet),\n            Self::PayLater(_) => Some(common_enums::PaymentMethod::PayLater),\n            Self::BankRedirect(_) => Some(common_enums::PaymentMethod::BankRedirect),\n            Self::BankDebit(_) => Some(common_enums::PaymentMethod::BankDebit),\n            Self::BankTransfer(_) => Some(common_enums::PaymentMethod::BankTransfer),\n            Self::Crypto(_) => Some(common_enums::PaymentMethod::Crypto),\n            Self::Reward => Some(common_enums::PaymentMethod::Reward),\n            Self::RealTimePayment(_) => Some(common_enums::PaymentMethod::RealTimePayment),\n            Self::Upi(_) => Some(common_enums::PaymentMethod::Upi),\n            Self::Voucher(_) => Some(common_enums::PaymentMethod::Voucher),\n            Self::GiftCard(_) => Some(common_enums::PaymentMethod::GiftCard),\n            Self::OpenBanking(_) => Some(common_enums::PaymentMethod::OpenBanking),\n            Self::MobilePayment(_) => Some(common_enums::PaymentMethod::MobilePayment),\n            Self::CardToken(_) | Self::MandatePayment => None,\n        }\n    }\n", "function_name": "get_payment_method", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment method type mapper"}, {"query": "rust function to get payment method type from domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_payment_method\n    pub fn get_payment_method(&self) -> Option<common_enums::PaymentMethod> {\n        match self {\n            Self::Card(_)\n            | Self::NetworkToken(_)\n            | Self::CardDetailsForNetworkTransactionId(_)\n            | Self::NetworkTokenDetailsForNetworkTransactionId(_)\n            | Self::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | Self::CardWithLimitedDetails(_) => Some(common_enums::PaymentMethod::Card),\n            Self::CardRedirect(_) => Some(common_enums::PaymentMethod::CardRedirect),\n            Self::Wallet(_) => Some(common_enums::PaymentMethod::Wallet),\n            Self::PayLater(_) => Some(common_enums::PaymentMethod::PayLater),\n            Self::BankRedirect(_) => Some(common_enums::PaymentMethod::BankRedirect),\n            Self::BankDebit(_) => Some(common_enums::PaymentMethod::BankDebit),\n            Self::BankTransfer(_) => Some(common_enums::PaymentMethod::BankTransfer),\n            Self::Crypto(_) => Some(common_enums::PaymentMethod::Crypto),\n            Self::Reward => Some(common_enums::PaymentMethod::Reward),\n            Self::RealTimePayment(_) => Some(common_enums::PaymentMethod::RealTimePayment),\n            Self::Upi(_) => Some(common_enums::PaymentMethod::Upi),\n            Self::Voucher(_) => Some(common_enums::PaymentMethod::Voucher),\n            Self::GiftCard(_) => Some(common_enums::PaymentMethod::GiftCard),\n            Self::OpenBanking(_) => Some(common_enums::PaymentMethod::OpenBanking),\n            Self::MobilePayment(_) => Some(common_enums::PaymentMethod::MobilePayment),\n            Self::CardToken(_) | Self::MandatePayment => None,\n        }\n    }\n", "function_name": "get_payment_method", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment method type mapper"}, {"query": "rust hyperswitch authipay connector get_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector header generation"}, {"query": "how to configure authipay payment gateway headers in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector header generation"}, {"query": "hyperswitch authipay connector authentication header generation code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector header generation"}, {"query": "rust hyperswitch PaymentsAuthorizeRouterData authipay get_headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector header generation"}, {"query": "How do I handle graph analysis errors in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: negation_from_graph_error\n    fn negation_from_graph_error(\n        metadata: Vec<&Metadata>,\n        graph_error: cgraph::GraphError<V>,\n    ) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::NegationTrace {\n                trace,\n                metadata: metadata.iter().map(|m| (*m).clone()).collect(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n}\n\n#[derive(Debug)]", "function_name": "negation_from_graph_error", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Graph Error Transformation"}, {"query": "Rust function to convert GraphError to NegationTrace", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: negation_from_graph_error\n    fn negation_from_graph_error(\n        metadata: Vec<&Metadata>,\n        graph_error: cgraph::GraphError<V>,\n    ) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::NegationTrace {\n                trace,\n                metadata: metadata.iter().map(|m| (*m).clone()).collect(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n}\n\n#[derive(Debug)]", "function_name": "negation_from_graph_error", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Graph Error Transformation"}, {"query": "negation_from_graph_error implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: negation_from_graph_error\n    fn negation_from_graph_error(\n        metadata: Vec<&Metadata>,\n        graph_error: cgraph::GraphError<V>,\n    ) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::NegationTrace {\n                trace,\n                metadata: metadata.iter().map(|m| (*m).clone()).collect(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n}\n\n#[derive(Debug)]", "function_name": "negation_from_graph_error", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Graph Error Transformation"}, {"query": "Error handling pattern for cgraph::GraphError in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: negation_from_graph_error\n    fn negation_from_graph_error(\n        metadata: Vec<&Metadata>,\n        graph_error: cgraph::GraphError<V>,\n    ) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::NegationTrace {\n                trace,\n                metadata: metadata.iter().map(|m| (*m).clone()).collect(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n}\n\n#[derive(Debug)]", "function_name": "negation_from_graph_error", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Graph Error Transformation"}, {"query": "how to get bucket size for time intervals in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_bucket_size\n    fn get_bucket_size(&self) -> u8 {\n        match self {\n            Self::OneMin => 60,\n            Self::FiveMin => 5,\n            Self::FifteenMin => 15,\n            Self::ThirtyMin => 30,\n            Self::OneHour => 60,\n            Self::OneDay => 24,\n        }\n    }\n", "function_name": "get_bucket_size", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time interval bucket size mapping"}, {"query": "hyperswitch analytics query bucket size mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_bucket_size\n    fn get_bucket_size(&self) -> u8 {\n        match self {\n            Self::OneMin => 60,\n            Self::FiveMin => 5,\n            Self::FifteenMin => 15,\n            Self::ThirtyMin => 30,\n            Self::OneHour => 60,\n            Self::OneDay => 24,\n        }\n    }\n", "function_name": "get_bucket_size", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time interval bucket size mapping"}, {"query": "rust enum to minutes conversion for time windows", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_bucket_size\n    fn get_bucket_size(&self) -> u8 {\n        match self {\n            Self::OneMin => 60,\n            Self::FiveMin => 5,\n            Self::FifteenMin => 15,\n            Self::ThirtyMin => 30,\n            Self::OneHour => 60,\n            Self::OneDay => 24,\n        }\n    }\n", "function_name": "get_bucket_size", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time interval bucket size mapping"}, {"query": "get_bucket_size function implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_bucket_size\n    fn get_bucket_size(&self) -> u8 {\n        match self {\n            Self::OneMin => 60,\n            Self::FiveMin => 5,\n            Self::FifteenMin => 15,\n            Self::ThirtyMin => 30,\n            Self::OneHour => 60,\n            Self::OneDay => 24,\n        }\n    }\n", "function_name": "get_bucket_size", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time interval bucket size mapping"}, {"query": "rust try_from refresh token router data implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: try_from\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iatapay token transformer"}, {"query": "iatapay connector token generation client_credentials", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: try_from\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iatapay token transformer"}, {"query": "hyperswitch refresh token to token conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: try_from\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iatapay token transformer"}, {"query": "rust derive TryFrom refresh token data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: try_from\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iatapay token transformer"}, {"query": "how to implement insert_payment_intent in Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: insert_payment_intent\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "insert_payment_intent", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent persistence interface"}, {"query": "hyperswitch payment intent persistence interface signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: insert_payment_intent\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "insert_payment_intent", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent persistence interface"}, {"query": "Rust hyperswitch domain models insert_payment_intent merchant_key_store", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: insert_payment_intent\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "insert_payment_intent", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent persistence interface"}, {"query": "hyperswitch payment intent storage scheme implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: insert_payment_intent\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "insert_payment_intent", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent persistence interface"}, {"query": "IATAPay transaction status mapping enum", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentStatus\npub enum IatapayPaymentStatus {\n    #[default]\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n}\n", "function_name": "IatapayPaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay status enum"}, {"query": "Rust enum for IATAPay payment states", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentStatus\npub enum IatapayPaymentStatus {\n    #[default]\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n}\n", "function_name": "IatapayPaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay status enum"}, {"query": "hyperswitch IATAPay status transformer", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentStatus\npub enum IatapayPaymentStatus {\n    #[default]\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n}\n", "function_name": "IatapayPaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay status enum"}, {"query": "IATAPayUnexpectedSettled enum variant", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentStatus\npub enum IatapayPaymentStatus {\n    #[default]\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n}\n", "function_name": "IatapayPaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay status enum"}, {"query": "how to configure payone api key authorization header in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "payone connector auth header"}, {"query": "hyperswitch payone connector get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "payone connector auth header"}, {"query": "rust payone authentication header generation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "payone connector auth header"}, {"query": "hyperswitch payone.rs connector api key configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "payone connector auth header"}, {"query": "how to format error as  in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: fmt\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            f.write_str(\n                serde_json::to_string(&serde_json::json!({\n                    \"error\": {\n                        \"error_type\": \"invalid_request\",\n                        \"message\": self.err.to_string(),\n                        \"code\": \"IR_06\",\n                    }\n                }))\n                .as_deref()\n                .unwrap_or(\"Invalid Json Error\"),\n            )\n        }\n    }\n", "function_name": "fmt", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Error formatting to JSON"}, {"query": "hyperswitch error response format", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: fmt\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            f.write_str(\n                serde_json::to_string(&serde_json::json!({\n                    \"error\": {\n                        \"error_type\": \"invalid_request\",\n                        \"message\": self.err.to_string(),\n                        \"code\": \"IR_06\",\n                    }\n                }))\n                .as_deref()\n                .unwrap_or(\"Invalid Json Error\"),\n            )\n        }\n    }\n", "function_name": "fmt", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Error formatting to JSON"}, {"query": "rust fmt trait implementation for error", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: fmt\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            f.write_str(\n                serde_json::to_string(&serde_json::json!({\n                    \"error\": {\n                        \"error_type\": \"invalid_request\",\n                        \"message\": self.err.to_string(),\n                        \"code\": \"IR_06\",\n                    }\n                }))\n                .as_deref()\n                .unwrap_or(\"Invalid Json Error\"),\n            )\n        }\n    }\n", "function_name": "fmt", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Error formatting to JSON"}, {"query": "IR_06 invalid_request error format hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: fmt\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            f.write_str(\n                serde_json::to_string(&serde_json::json!({\n                    \"error\": {\n                        \"error_type\": \"invalid_request\",\n                        \"message\": self.err.to_string(),\n                        \"code\": \"IR_06\",\n                    }\n                }))\n                .as_deref()\n                .unwrap_or(\"Invalid Json Error\"),\n            )\n        }\n    }\n", "function_name": "fmt", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Error formatting to JSON"}, {"query": "How to handle Barclaycard API error responses in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardErrorResponse = res\n            .response\n            .parse_struct(\"BarclaycardErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            transformers::BarclaycardErrorResponse::StandardError(response) => {\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 739 chars] ...\n\n                  connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            transformers::BarclaycardErrorResponse::AuthenticationError(response) => {\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response.response.rmsg.clone(),\n                    reason: Some(response.response.rmsg),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard error response transformer"}, {"query": "Barclaycard connector error transformation logic hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardErrorResponse = res\n            .response\n            .parse_struct(\"BarclaycardErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            transformers::BarclaycardErrorResponse::StandardError(response) => {\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 739 chars] ...\n\n                  connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            transformers::BarclaycardErrorResponse::AuthenticationError(response) => {\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response.response.rmsg.clone(),\n                    reason: Some(response.response.rmsg),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard error response transformer"}, {"query": "Parse BarclaycardErrorResponse to ErrorResponse format", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardErrorResponse = res\n            .response\n            .parse_struct(\"BarclaycardErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            transformers::BarclaycardErrorResponse::StandardError(response) => {\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 739 chars] ...\n\n                  connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            transformers::BarclaycardErrorResponse::AuthenticationError(response) => {\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response.response.rmsg.clone(),\n                    reason: Some(response.response.rmsg),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard error response transformer"}, {"query": "Hyperswitch Barclaycard authentication error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardErrorResponse = res\n            .response\n            .parse_struct(\"BarclaycardErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            transformers::BarclaycardErrorResponse::StandardError(response) => {\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 739 chars] ...\n\n                  connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            transformers::BarclaycardErrorResponse::AuthenticationError(response) => {\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response.response.rmsg.clone(),\n                    reason: Some(response.response.rmsg),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard error response transformer"}, {"query": "Rust struct for network transaction ID and token details hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndNetworkTokenDetails\npub struct NetworkTransactionIdAndNetworkTokenDetails {\n    /// The Network Token\n    pub network_token: cards::NetworkToken,\n\n    /// The token's expiry month\n    pub token_exp_month: Secret<String>,\n\n    /// The token's expiry year\n    pub token_exp_year: Secret<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    /// The type of the card such as Credit, Debit\n    pub card_type: Option<String>,\n\n    /// The country in which the card was issued\n    pub card_issuing_country: Option<String>,\n\n    /// The bank code of the bank that issued the card\n    pub bank_code: Option<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "NetworkTransactionIdAndNetworkTokenDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Network Token Details Struct"}, {"query": "how to handle off_session payment token expiry in hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndNetworkTokenDetails\npub struct NetworkTransactionIdAndNetworkTokenDetails {\n    /// The Network Token\n    pub network_token: cards::NetworkToken,\n\n    /// The token's expiry month\n    pub token_exp_month: Secret<String>,\n\n    /// The token's expiry year\n    pub token_exp_year: Secret<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    /// The type of the card such as Credit, Debit\n    pub card_type: Option<String>,\n\n    /// The country in which the card was issued\n    pub card_issuing_country: Option<String>,\n\n    /// The bank code of the bank that issued the card\n    pub bank_code: Option<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "NetworkTransactionIdAndNetworkTokenDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Network Token Details Struct"}, {"query": "Secret<String> usage for cardholder name and network token in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndNetworkTokenDetails\npub struct NetworkTransactionIdAndNetworkTokenDetails {\n    /// The Network Token\n    pub network_token: cards::NetworkToken,\n\n    /// The token's expiry month\n    pub token_exp_month: Secret<String>,\n\n    /// The token's expiry year\n    pub token_exp_year: Secret<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    /// The type of the card such as Credit, Debit\n    pub card_type: Option<String>,\n\n    /// The country in which the card was issued\n    pub card_issuing_country: Option<String>,\n\n    /// The bank code of the bank that issued the card\n    pub bank_code: Option<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "NetworkTransactionIdAndNetworkTokenDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Network Token Details Struct"}, {"query": "hyperswitch domain models network_transaction_id off_session setup_future_usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndNetworkTokenDetails\npub struct NetworkTransactionIdAndNetworkTokenDetails {\n    /// The Network Token\n    pub network_token: cards::NetworkToken,\n\n    /// The token's expiry month\n    pub token_exp_month: Secret<String>,\n\n    /// The token's expiry year\n    pub token_exp_year: Secret<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    /// The type of the card such as Credit, Debit\n    pub card_type: Option<String>,\n\n    /// The country in which the card was issued\n    pub card_issuing_country: Option<String>,\n\n    /// The bank code of the bank that issued the card\n    pub bank_code: Option<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "NetworkTransactionIdAndNetworkTokenDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Network Token Details Struct"}, {"query": "rust hyperswitch payment response trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate\n    async fn update_modular_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsSyncData, types::PaymentsResponseData>,\n        _platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        _business_profile: &domain::Profile,\n        request_payment_method_data: Option<&domain::PaymentMethodData>,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        update_modular_pm_and_mandate_impl(state, resp, request_payment_method_data, payment_data)\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update modular payment method and mandate\")\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[async_trait]\nimpl<F: Clone> PostUpdateTracker<F, PaymentData<F>, types::PaymentsSessionData>\n    for PaymentResponse\n{", "function_name": "update_modular_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "PaymentResponse PostUpdateTracker trait"}, {"query": "hyperswitch update_modular_pm_and_mandate function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate\n    async fn update_modular_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsSyncData, types::PaymentsResponseData>,\n        _platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        _business_profile: &domain::Profile,\n        request_payment_method_data: Option<&domain::PaymentMethodData>,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        update_modular_pm_and_mandate_impl(state, resp, request_payment_method_data, payment_data)\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update modular payment method and mandate\")\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[async_trait]\nimpl<F: Clone> PostUpdateTracker<F, PaymentData<F>, types::PaymentsSessionData>\n    for PaymentResponse\n{", "function_name": "update_modular_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "PaymentResponse PostUpdateTracker trait"}, {"query": "how to implement PostUpdateTracker for payment methods in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate\n    async fn update_modular_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsSyncData, types::PaymentsResponseData>,\n        _platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        _business_profile: &domain::Profile,\n        request_payment_method_data: Option<&domain::PaymentMethodData>,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        update_modular_pm_and_mandate_impl(state, resp, request_payment_method_data, payment_data)\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update modular payment method and mandate\")\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[async_trait]\nimpl<F: Clone> PostUpdateTracker<F, PaymentData<F>, types::PaymentsSessionData>\n    for PaymentResponse\n{", "function_name": "update_modular_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "PaymentResponse PostUpdateTracker trait"}, {"query": "hyperswitch router payment response sync logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate\n    async fn update_modular_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsSyncData, types::PaymentsResponseData>,\n        _platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        _business_profile: &domain::Profile,\n        request_payment_method_data: Option<&domain::PaymentMethodData>,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        update_modular_pm_and_mandate_impl(state, resp, request_payment_method_data, payment_data)\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update modular payment method and mandate\")\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[async_trait]\nimpl<F: Clone> PostUpdateTracker<F, PaymentData<F>, types::PaymentsSessionData>\n    for PaymentResponse\n{", "function_name": "update_modular_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "PaymentResponse PostUpdateTracker trait"}, {"query": "how to handle connector response errors in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response\n    fn get_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Err(err_res) => {\n                    logger::error!(error_response=?err_res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting response, received error response: {err_res:?}\"\n                    ))\n                }\n                Ok(res) => Ok(res),\n            })\n    }\n}\n\n#[inline]", "function_name": "get_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router response error handling"}, {"query": "hyperswitch router get_response function error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response\n    fn get_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Err(err_res) => {\n                    logger::error!(error_response=?err_res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting response, received error response: {err_res:?}\"\n                    ))\n                }\n                Ok(res) => Ok(res),\n            })\n    }\n}\n\n#[inline]", "function_name": "get_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router response error handling"}, {"query": "rust router crate connector response mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response\n    fn get_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Err(err_res) => {\n                    logger::error!(error_response=?err_res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting response, received error response: {err_res:?}\"\n                    ))\n                }\n                Ok(res) => Ok(res),\n            })\n    }\n}\n\n#[inline]", "function_name": "get_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router response error handling"}, {"query": "hyperswitch utils.rs get_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response\n    fn get_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Err(err_res) => {\n                    logger::error!(error_response=?err_res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting response, received error response: {err_res:?}\"\n                    ))\n                }\n                Ok(res) => Ok(res),\n            })\n    }\n}\n\n#[inline]", "function_name": "get_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router response error handling"}, {"query": "how to build headers for Nordea API requests in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.get_content_type().to_string();\n        let http_method = self.get_http_method();\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n        let path_with_query = if let Some(query) = url_parsed.query() {\n            format!(\"{path}?{query}\")\n        } else {\n            path.to_string()\n        };\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            let nordea_request = self.get_request_body(req, connectors)?;\n\n            let sha2\n\n... [truncated 301 chars] ...\n\n              &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path,\n                    payload_digest: Some(&sha256_digest),\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        } else {\n            // Generate signature without digest for GET requests\n            let signature = self.generate_signature(\n                &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path: &path_with_query,\n                    payload_digest: None,\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        }\n\n        Ok(required_headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea header builder"}, {"query": "Nordea connector authentication header generation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.get_content_type().to_string();\n        let http_method = self.get_http_method();\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n        let path_with_query = if let Some(query) = url_parsed.query() {\n            format!(\"{path}?{query}\")\n        } else {\n            path.to_string()\n        };\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            let nordea_request = self.get_request_body(req, connectors)?;\n\n            let sha2\n\n... [truncated 301 chars] ...\n\n              &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path,\n                    payload_digest: Some(&sha256_digest),\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        } else {\n            // Generate signature without digest for GET requests\n            let signature = self.generate_signature(\n                &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path: &path_with_query,\n                    payload_digest: None,\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        }\n\n        Ok(required_headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea header builder"}, {"query": "hyperswitch nordea build_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.get_content_type().to_string();\n        let http_method = self.get_http_method();\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n        let path_with_query = if let Some(query) = url_parsed.query() {\n            format!(\"{path}?{query}\")\n        } else {\n            path.to_string()\n        };\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            let nordea_request = self.get_request_body(req, connectors)?;\n\n            let sha2\n\n... [truncated 301 chars] ...\n\n              &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path,\n                    payload_digest: Some(&sha256_digest),\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        } else {\n            // Generate signature without digest for GET requests\n            let signature = self.generate_signature(\n                &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path: &path_with_query,\n                    payload_digest: None,\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        }\n\n        Ok(required_headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea header builder"}, {"query": "Nordea API signature header generation with SHA256", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.get_content_type().to_string();\n        let http_method = self.get_http_method();\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n        let path_with_query = if let Some(query) = url_parsed.query() {\n            format!(\"{path}?{query}\")\n        } else {\n            path.to_string()\n        };\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            let nordea_request = self.get_request_body(req, connectors)?;\n\n            let sha2\n\n... [truncated 301 chars] ...\n\n              &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path,\n                    payload_digest: Some(&sha256_digest),\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        } else {\n            // Generate signature without digest for GET requests\n            let signature = self.generate_signature(\n                &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path: &path_with_query,\n                    payload_digest: None,\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        }\n\n        Ok(required_headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea header builder"}, {"query": "how to update gateway system in feature metadata rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: update_gateway_system_in_feature_metadata\npub fn update_gateway_system_in_feature_metadata<F: Clone, D>(\n    payment_data: &mut D,\n    gateway_system: GatewaySystem,\n) -> RouterResult<()>\nwhere\n    D: OperationSessionGetters<F> + OperationSessionSetters<F>,\n{\n    let mut payment_intent = payment_data.get_payment_intent().clone();\n\n    let existing_metadata = payment_intent.feature_metadata.as_ref();\n\n    let mut feature_metadata = existing_metadata\n        .and_then(|metadata| serde_json::from_value::<FeatureMetadata>(metadata.clone()).ok())\n        .unwrap_or_default();\n\n    feature_metadata.gateway_system = Some(gateway_system);\n\n    let updated_metadata = serde_json::to_value(feature_metadata)\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to serialize feature metadata\")?;\n\n    payment_intent.feature_metadata = Some(updated_metadata.clone());\n    payment_data.set_payment_intent(payment_intent);\n\n    Ok(())\n}\n", "function_name": "update_gateway_system_in_feature_metadata", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Update Gateway System in Metadata"}, {"query": "hyperswitch update_gateway_system_in_feature_metadata implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: update_gateway_system_in_feature_metadata\npub fn update_gateway_system_in_feature_metadata<F: Clone, D>(\n    payment_data: &mut D,\n    gateway_system: GatewaySystem,\n) -> RouterResult<()>\nwhere\n    D: OperationSessionGetters<F> + OperationSessionSetters<F>,\n{\n    let mut payment_intent = payment_data.get_payment_intent().clone();\n\n    let existing_metadata = payment_intent.feature_metadata.as_ref();\n\n    let mut feature_metadata = existing_metadata\n        .and_then(|metadata| serde_json::from_value::<FeatureMetadata>(metadata.clone()).ok())\n        .unwrap_or_default();\n\n    feature_metadata.gateway_system = Some(gateway_system);\n\n    let updated_metadata = serde_json::to_value(feature_metadata)\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to serialize feature metadata\")?;\n\n    payment_intent.feature_metadata = Some(updated_metadata.clone());\n    payment_data.set_payment_intent(payment_intent);\n\n    Ok(())\n}\n", "function_name": "update_gateway_system_in_feature_metadata", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Update Gateway System in Metadata"}, {"query": "rust function to modify payment intent feature metadata gateway", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: update_gateway_system_in_feature_metadata\npub fn update_gateway_system_in_feature_metadata<F: Clone, D>(\n    payment_data: &mut D,\n    gateway_system: GatewaySystem,\n) -> RouterResult<()>\nwhere\n    D: OperationSessionGetters<F> + OperationSessionSetters<F>,\n{\n    let mut payment_intent = payment_data.get_payment_intent().clone();\n\n    let existing_metadata = payment_intent.feature_metadata.as_ref();\n\n    let mut feature_metadata = existing_metadata\n        .and_then(|metadata| serde_json::from_value::<FeatureMetadata>(metadata.clone()).ok())\n        .unwrap_or_default();\n\n    feature_metadata.gateway_system = Some(gateway_system);\n\n    let updated_metadata = serde_json::to_value(feature_metadata)\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to serialize feature metadata\")?;\n\n    payment_intent.feature_metadata = Some(updated_metadata.clone());\n    payment_data.set_payment_intent(payment_intent);\n\n    Ok(())\n}\n", "function_name": "update_gateway_system_in_feature_metadata", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Update Gateway System in Metadata"}, {"query": "hyperswitch payment orchestration gateway system metadata update", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: update_gateway_system_in_feature_metadata\npub fn update_gateway_system_in_feature_metadata<F: Clone, D>(\n    payment_data: &mut D,\n    gateway_system: GatewaySystem,\n) -> RouterResult<()>\nwhere\n    D: OperationSessionGetters<F> + OperationSessionSetters<F>,\n{\n    let mut payment_intent = payment_data.get_payment_intent().clone();\n\n    let existing_metadata = payment_intent.feature_metadata.as_ref();\n\n    let mut feature_metadata = existing_metadata\n        .and_then(|metadata| serde_json::from_value::<FeatureMetadata>(metadata.clone()).ok())\n        .unwrap_or_default();\n\n    feature_metadata.gateway_system = Some(gateway_system);\n\n    let updated_metadata = serde_json::to_value(feature_metadata)\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to serialize feature metadata\")?;\n\n    payment_intent.feature_metadata = Some(updated_metadata.clone());\n    payment_data.set_payment_intent(payment_intent);\n\n    Ok(())\n}\n", "function_name": "update_gateway_system_in_feature_metadata", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Update Gateway System in Metadata"}, {"query": "how to define purchase data structure in signifyd rust connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Purchase\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "Purchase", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Purchase Data Model"}, {"query": "rust struct for signifyd purchase transaction model", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Purchase\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "Purchase", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Purchase Data Model"}, {"query": "hyperswitch signifyd purchase data fields definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Purchase\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "Purchase", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Purchase Data Model"}, {"query": "signifyd purchase object rust serde deserialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Purchase\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "Purchase", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Purchase Data Model"}, {"query": "rust hyperswitch redsys connector handle_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreProcessingRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreProcessingRouterData, errors::ConnectorError> {\n        let response: redsys::RedsysResponse = res\n            .response\n            .parse_struct(\"RedsysResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys response deserialization"}, {"query": "how does hyperswitch handle redsys response parsing in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreProcessingRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreProcessingRouterData, errors::ConnectorError> {\n        let response: redsys::RedsysResponse = res\n            .response\n            .parse_struct(\"RedsysResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys response deserialization"}, {"query": "hyperswitch redsys connector deserialization and logging logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreProcessingRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreProcessingRouterData, errors::ConnectorError> {\n        let response: redsys::RedsysResponse = res\n            .response\n            .parse_struct(\"RedsysResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys response deserialization"}, {"query": "redsys payment gateway response handling in hyperswitch rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreProcessingRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreProcessingRouterData, errors::ConnectorError> {\n        let response: redsys::RedsysResponse = res\n            .response\n            .parse_struct(\"RedsysResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys response deserialization"}, {"query": "how to implement Sift fraud detection integration in Hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift fraud connector integration"}, {"query": "Sift payment method tokenization connector rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift fraud connector integration"}, {"query": "hyperswitch sift connector integration trait not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift fraud connector integration"}, {"query": "rust connector integration for fraud detection tokenization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift fraud connector integration"}, {"query": "how to convert Hyperswitch address to Archipel billing address format", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: to_archipel_billing_address\n    fn to_archipel_billing_address(&self) -> Option<ArchipelBillingAddress> {\n        let address = self.get_combined_address_line().ok();\n        let postal_code = self.get_optional_zip();\n\n        match (address, postal_code) {\n            (None, None) => None,\n            (addr, zip) => Some(ArchipelBillingAddress {\n                address: addr,\n                postal_code: zip,\n            }),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "to_archipel_billing_address", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel billing address transformation"}, {"query": "archipel connector billing address transformation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: to_archipel_billing_address\n    fn to_archipel_billing_address(&self) -> Option<ArchipelBillingAddress> {\n        let address = self.get_combined_address_line().ok();\n        let postal_code = self.get_optional_zip();\n\n        match (address, postal_code) {\n            (None, None) => None,\n            (addr, zip) => Some(ArchipelBillingAddress {\n                address: addr,\n                postal_code: zip,\n            }),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "to_archipel_billing_address", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel billing address transformation"}, {"query": "hyperswitch archipel billing address mapping function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: to_archipel_billing_address\n    fn to_archipel_billing_address(&self) -> Option<ArchipelBillingAddress> {\n        let address = self.get_combined_address_line().ok();\n        let postal_code = self.get_optional_zip();\n\n        match (address, postal_code) {\n            (None, None) => None,\n            (addr, zip) => Some(ArchipelBillingAddress {\n                address: addr,\n                postal_code: zip,\n            }),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "to_archipel_billing_address", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel billing address transformation"}, {"query": "rust function to_archipel_billing_address implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: to_archipel_billing_address\n    fn to_archipel_billing_address(&self) -> Option<ArchipelBillingAddress> {\n        let address = self.get_combined_address_line().ok();\n        let postal_code = self.get_optional_zip();\n\n        match (address, postal_code) {\n            (None, None) => None,\n            (addr, zip) => Some(ArchipelBillingAddress {\n                address: addr,\n                postal_code: zip,\n            }),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "to_archipel_billing_address", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel billing address transformation"}, {"query": "how to configure netcetera connector authentication headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector header builder"}, {"query": "rust hyperswitch netcetera build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector header builder"}, {"query": "netcetera payment gateway hyperswitch rust connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector header builder"}, {"query": "hyperswitch netcetera connector content type header", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector header builder"}, {"query": "hyperswitch rust SyncIntegrityObject struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: SyncIntegrityObject\npub struct SyncIntegrityObject {\n    /// Sync amount\n    pub amount: Option<MinorUnit>,\n    /// Sync currency\n    pub currency: Option<storage_enums::Currency>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "SyncIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Sync Integrity Domain Model"}, {"query": "how to define sync integrity object in hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: SyncIntegrityObject\npub struct SyncIntegrityObject {\n    /// Sync amount\n    pub amount: Option<MinorUnit>,\n    /// Sync currency\n    pub currency: Option<storage_enums::Currency>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "SyncIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Sync Integrity Domain Model"}, {"query": "SyncIntegrityObject amount currency fields rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: SyncIntegrityObject\npub struct SyncIntegrityObject {\n    /// Sync amount\n    pub amount: Option<MinorUnit>,\n    /// Sync currency\n    pub currency: Option<storage_enums::Currency>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "SyncIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Sync Integrity Domain Model"}, {"query": "hyperswitch router request types sync integrity", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: SyncIntegrityObject\npub struct SyncIntegrityObject {\n    /// Sync amount\n    pub amount: Option<MinorUnit>,\n    /// Sync currency\n    pub currency: Option<storage_enums::Currency>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "SyncIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Sync Integrity Domain Model"}, {"query": "Signifyd FulfillmentMethod enum definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: FulfillmentMethod\npub enum FulfillmentMethod {\n    Delivery,\n    CounterPickup,\n    CubsidePickup,\n    LockerPickup,\n    StandardShipping,\n    ExpeditedShipping,\n    GasPickup,\n    ScheduledDelivery,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "FulfillmentMethod", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd FulfillmentMethod enum"}, {"query": "Rust FulfillmentMethod variant types Signifyd", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: FulfillmentMethod\npub enum FulfillmentMethod {\n    Delivery,\n    CounterPickup,\n    CubsidePickup,\n    LockerPickup,\n    StandardShipping,\n    ExpeditedShipping,\n    GasPickup,\n    ScheduledDelivery,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "FulfillmentMethod", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd FulfillmentMethod enum"}, {"query": "How to handle Signifyd fulfillment methods in Hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: FulfillmentMethod\npub enum FulfillmentMethod {\n    Delivery,\n    CounterPickup,\n    CubsidePickup,\n    LockerPickup,\n    StandardShipping,\n    ExpeditedShipping,\n    GasPickup,\n    ScheduledDelivery,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "FulfillmentMethod", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd FulfillmentMethod enum"}, {"query": "Signifyd API fulfillment method mapping Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: FulfillmentMethod\npub enum FulfillmentMethod {\n    Delivery,\n    CounterPickup,\n    CubsidePickup,\n    LockerPickup,\n    StandardShipping,\n    ExpeditedShipping,\n    GasPickup,\n    ScheduledDelivery,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "FulfillmentMethod", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd FulfillmentMethod enum"}, {"query": "Rust struct definition for Wise connector error response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: ErrorResponse\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "function_name": "ErrorResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector error struct"}, {"query": "hyperswitch ErrorResponse struct Wise transformers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: ErrorResponse\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "function_name": "ErrorResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector error struct"}, {"query": "Wise payment connector error handling struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: ErrorResponse\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "function_name": "ErrorResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector error struct"}, {"query": "how to handle Wise API errors in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: ErrorResponse\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "function_name": "ErrorResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector error struct"}, {"query": "how to check if external vault is enabled in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: is_external_vault_enabled\n    pub fn is_external_vault_enabled(&self) -> bool {\n        match self {\n            Self::ExternalVaultEnabled(_) => true,\n            Self::Skip => false,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl\n    TryFrom<(\n        Option<common_enums::ExternalVaultEnabled>,\n        Option<ExternalVaultConnectorDetails>,\n    )> for ExternalVaultDetails\n{\n    type Error = error_stack::Report<ValidationError>;", "function_name": "is_external_vault_enabled", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "External vault boolean check"}, {"query": "rust enum is_external_vault_enabled implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: is_external_vault_enabled\n    pub fn is_external_vault_enabled(&self) -> bool {\n        match self {\n            Self::ExternalVaultEnabled(_) => true,\n            Self::Skip => false,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl\n    TryFrom<(\n        Option<common_enums::ExternalVaultEnabled>,\n        Option<ExternalVaultConnectorDetails>,\n    )> for ExternalVaultDetails\n{\n    type Error = error_stack::Report<ValidationError>;", "function_name": "is_external_vault_enabled", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "External vault boolean check"}, {"query": "hyperswitch domain models external vault details logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: is_external_vault_enabled\n    pub fn is_external_vault_enabled(&self) -> bool {\n        match self {\n            Self::ExternalVaultEnabled(_) => true,\n            Self::Skip => false,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl\n    TryFrom<(\n        Option<common_enums::ExternalVaultEnabled>,\n        Option<ExternalVaultConnectorDetails>,\n    )> for ExternalVaultDetails\n{\n    type Error = error_stack::Report<ValidationError>;", "function_name": "is_external_vault_enabled", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "External vault boolean check"}, {"query": "is_external_vault_enabled function return type", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: is_external_vault_enabled\n    pub fn is_external_vault_enabled(&self) -> bool {\n        match self {\n            Self::ExternalVaultEnabled(_) => true,\n            Self::Skip => false,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl\n    TryFrom<(\n        Option<common_enums::ExternalVaultEnabled>,\n        Option<ExternalVaultConnectorDetails>,\n    )> for ExternalVaultDetails\n{\n    type Error = error_stack::Report<ValidationError>;", "function_name": "is_external_vault_enabled", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "External vault boolean check"}, {"query": "how to handle zift payment gateway error responses in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: zift::ZiftErrorResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.response_code,\n            message: response.response_message.clone(),\n            reason: Some(response.response_message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift error response builder"}, {"query": "zift connector error handling hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: zift::ZiftErrorResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.response_code,\n            message: response.response_message.clone(),\n            reason: Some(response.response_message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift error response builder"}, {"query": "build_error_response function implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: zift::ZiftErrorResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.response_code,\n            message: response.response_message.clone(),\n            reason: Some(response.response_message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift error response builder"}, {"query": "map zift api error to hyperswitch error model", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: zift::ZiftErrorResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.response_code,\n            message: response.response_message.clone(),\n            reason: Some(response.response_message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift error response builder"}, {"query": "How to get CtpServiceProvider from connector_name in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_ctp_service_provider\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n", "function_name": "get_ctp_service_provider", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "CTP provider enum parsing"}, {"query": "Parse connector name to CtpServiceProvider enum hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_ctp_service_provider\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n", "function_name": "get_ctp_service_provider", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "CTP provider enum parsing"}, {"query": "hyperswitch domain models get_ctp_service_provider implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_ctp_service_provider\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n", "function_name": "get_ctp_service_provider", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "CTP provider enum parsing"}, {"query": "Rust function to convert connector_name to CtpServiceProvider", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_ctp_service_provider\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n", "function_name": "get_ctp_service_provider", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "CTP provider enum parsing"}, {"query": "Rust struct definition for MandateReference in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: MandateReference\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "MandateReference", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "MandateReference domain model struct"}, {"query": "hyperswitch domain models MandateReference connector_mandate_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: MandateReference\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "MandateReference", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "MandateReference domain model struct"}, {"query": "how to handle MandateReference in payment orchestration router", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: MandateReference\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "MandateReference", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "MandateReference domain model struct"}, {"query": "MandateReference struct fields payment_method_id mandate_metadata", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: MandateReference\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "MandateReference", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "MandateReference domain model struct"}, {"query": "how to update merchant connector account configuration in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_merchant_connector_account\n    async fn update_merchant_connector_account(\n        &self,\n        this: domain::MerchantConnectorAccount,\n        merchant_connector_account: storage::MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .update_merchant_connector_account(this, merchant_connector_account, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "function_name": "update_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account update"}, {"query": "hyperswitch rust update merchant connector account key_store", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_merchant_connector_account\n    async fn update_merchant_connector_account(\n        &self,\n        this: domain::MerchantConnectorAccount,\n        merchant_connector_account: storage::MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .update_merchant_connector_account(this, merchant_connector_account, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "function_name": "update_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account update"}, {"query": "MerchantConnectorAccountUpdateInternal struct hyperswitch storage_impl", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_merchant_connector_account\n    async fn update_merchant_connector_account(\n        &self,\n        this: domain::MerchantConnectorAccount,\n        merchant_connector_account: storage::MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .update_merchant_connector_account(this, merchant_connector_account, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "function_name": "update_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account update"}, {"query": "hyperswitch router_store update_merchant_connector_account implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_merchant_connector_account\n    async fn update_merchant_connector_account(\n        &self,\n        this: domain::MerchantConnectorAccount,\n        merchant_connector_account: storage::MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .update_merchant_connector_account(this, merchant_connector_account, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "function_name": "update_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account update"}, {"query": "hyperswitch globepay connector integration implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Globepay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Globepay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay Connector Integration"}, {"query": "globepay payment method tokenization rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Globepay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Globepay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay Connector Integration"}, {"query": "hyperswitch connector not implemented globepay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Globepay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Globepay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay Connector Integration"}, {"query": "rust globepay payments response data structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Globepay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Globepay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay Connector Integration"}, {"query": "rust hyperswitch CardWithLimitedData struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: CardWithLimitedData\npub struct CardWithLimitedData {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Option<Secret<String>>,\n\n    /// The card's expiry year\n    pub card_exp_year: Option<Secret<String>>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n}\n\n// Determines if decryption should be performed\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize)]", "function_name": "CardWithLimitedData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "CardWithLimitedData struct"}, {"query": "hyperswitch domain models CardWithLimitedData eci field", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: CardWithLimitedData\npub struct CardWithLimitedData {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Option<Secret<String>>,\n\n    /// The card's expiry year\n    pub card_exp_year: Option<Secret<String>>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n}\n\n// Determines if decryption should be performed\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize)]", "function_name": "CardWithLimitedData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "CardWithLimitedData struct"}, {"query": "CardWithLimitedData hyperswitch payment method data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: CardWithLimitedData\npub struct CardWithLimitedData {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Option<Secret<String>>,\n\n    /// The card's expiry year\n    pub card_exp_year: Option<Secret<String>>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n}\n\n// Determines if decryption should be performed\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize)]", "function_name": "CardWithLimitedData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "CardWithLimitedData struct"}, {"query": "hyperswitch Secret<String> card holder name", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: CardWithLimitedData\npub struct CardWithLimitedData {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Option<Secret<String>>,\n\n    /// The card's expiry year\n    pub card_exp_year: Option<Secret<String>>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n}\n\n// Determines if decryption should be performed\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize)]", "function_name": "CardWithLimitedData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "CardWithLimitedData struct"}, {"query": "how to configure Boku connector authentication headers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector header configuration"}, {"query": "rust hyperswitch boku get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector header configuration"}, {"query": "hyperswitch boku payment gateway integration headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector header configuration"}, {"query": "PaymentsAuthorizeRouterData boku connector configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector header configuration"}, {"query": "how to retrieve payment intent by payment id and processor merchant id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_payment_id_processor_merchant_id\n    async fn find_payment_intent_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n    #[cfg(feature = \"v2\")]", "function_name": "find_payment_intent_by_payment_id_processor_merchant_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "payment intent retrieval lookup"}, {"query": "hyperswitch rust find_payment_intent_by_payment_id_processor_merchant_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_payment_id_processor_merchant_id\n    async fn find_payment_intent_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n    #[cfg(feature = \"v2\")]", "function_name": "find_payment_intent_by_payment_id_processor_merchant_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "payment intent retrieval lookup"}, {"query": "payment intent lookup function signature hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_payment_id_processor_merchant_id\n    async fn find_payment_intent_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n    #[cfg(feature = \"v2\")]", "function_name": "find_payment_intent_by_payment_id_processor_merchant_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "payment intent retrieval lookup"}, {"query": "rust code for finding payment intent using payment_id and merchant_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_payment_id_processor_merchant_id\n    async fn find_payment_intent_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n    #[cfg(feature = \"v2\")]", "function_name": "find_payment_intent_by_payment_id_processor_merchant_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "payment intent retrieval lookup"}, {"query": "How do I query a refund by internal reference ID and merchant ID in Hyperswitch?", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_internal_reference_id_merchant_id\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_internal_reference_id_merchant_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund lookup by internal ID and merchant ID"}, {"query": "Rust function to find refund using internal_reference_id and merchant_id in router crate", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_internal_reference_id_merchant_id\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_internal_reference_id_merchant_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund lookup by internal ID and merchant ID"}, {"query": "Hyperswitch storage error handling for refund lookup by merchant_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_internal_reference_id_merchant_id\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_internal_reference_id_merchant_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund lookup by internal ID and merchant ID"}, {"query": "Diesel query implementation for finding refund by internal_reference_id in router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_internal_reference_id_merchant_id\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_internal_reference_id_merchant_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund lookup by internal ID and merchant ID"}, {"query": "How do I get the connector auth type from a merchant account in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_account_details\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n", "function_name": "get_connector_account_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Connector Auth Type Retrieval"}, {"query": "Rust hyperswitch get_connector_account_details implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_account_details\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n", "function_name": "get_connector_account_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Connector Auth Type Retrieval"}, {"query": "Parse connector account details to ConnectorAuthType hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_account_details\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n", "function_name": "get_connector_account_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Connector Auth Type Retrieval"}, {"query": "hyperswitch domain models merchant connector account auth type", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_account_details\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n", "function_name": "get_connector_account_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Connector Auth Type Retrieval"}, {"query": "rust wise connector authentication body key profile_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "WiseAuth conversion trait"}, {"query": "how to convert ConnectorAuthType to WiseAuth in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "WiseAuth conversion trait"}, {"query": "hyperswitch wise transformer error handling try_from", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "WiseAuth conversion trait"}, {"query": "rust enum conversion wise profile_id api_key", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "WiseAuth conversion trait"}, {"query": "rust hyperswitch analytics clip_to_start time bucket function", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_start\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError> {\n        let clip_start = |value: u8, modulo: u8| -> u8 { value - value % modulo };\n\n        let clipped_time = match (\n            self.get_lowest_common_granularity_level(),\n            self.get_bucket_size(),\n        ) {\n            (TimeGranularityLevel::Minute, i) => time::Time::MIDNIGHT\n                .replace_second(clip_start(value.second(), i))\n                .and_then(|t| t.replace_minute(value.minute()))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Hour, i) => time::Time::MIDNIGHT\n                .replace_minute(clip_start(value.minute(), i))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Day, i) => {\n                time::Time::MIDNIGHT.replace_hour(clip_start(value.hour(), i))\n            }\n        }\n        .change_context(PostProcessingError::BucketClipping)?;\n\n        Ok(value.replace_time(clipped_time))\n    }\n", "function_name": "clip_to_start", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time Series Bucket Clipping"}, {"query": "how to clip time series to start of hour in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_start\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError> {\n        let clip_start = |value: u8, modulo: u8| -> u8 { value - value % modulo };\n\n        let clipped_time = match (\n            self.get_lowest_common_granularity_level(),\n            self.get_bucket_size(),\n        ) {\n            (TimeGranularityLevel::Minute, i) => time::Time::MIDNIGHT\n                .replace_second(clip_start(value.second(), i))\n                .and_then(|t| t.replace_minute(value.minute()))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Hour, i) => time::Time::MIDNIGHT\n                .replace_minute(clip_start(value.minute(), i))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Day, i) => {\n                time::Time::MIDNIGHT.replace_hour(clip_start(value.hour(), i))\n            }\n        }\n        .change_context(PostProcessingError::BucketClipping)?;\n\n        Ok(value.replace_time(clipped_time))\n    }\n", "function_name": "clip_to_start", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time Series Bucket Clipping"}, {"query": "hyperswitch analytics query module clip_to_start implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_start\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError> {\n        let clip_start = |value: u8, modulo: u8| -> u8 { value - value % modulo };\n\n        let clipped_time = match (\n            self.get_lowest_common_granularity_level(),\n            self.get_bucket_size(),\n        ) {\n            (TimeGranularityLevel::Minute, i) => time::Time::MIDNIGHT\n                .replace_second(clip_start(value.second(), i))\n                .and_then(|t| t.replace_minute(value.minute()))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Hour, i) => time::Time::MIDNIGHT\n                .replace_minute(clip_start(value.minute(), i))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Day, i) => {\n                time::Time::MIDNIGHT.replace_hour(clip_start(value.hour(), i))\n            }\n        }\n        .change_context(PostProcessingError::BucketClipping)?;\n\n        Ok(value.replace_time(clipped_time))\n    }\n", "function_name": "clip_to_start", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time Series Bucket Clipping"}, {"query": "rust time series bucket clipping function hyperswitch analytics", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_start\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError> {\n        let clip_start = |value: u8, modulo: u8| -> u8 { value - value % modulo };\n\n        let clipped_time = match (\n            self.get_lowest_common_granularity_level(),\n            self.get_bucket_size(),\n        ) {\n            (TimeGranularityLevel::Minute, i) => time::Time::MIDNIGHT\n                .replace_second(clip_start(value.second(), i))\n                .and_then(|t| t.replace_minute(value.minute()))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Hour, i) => time::Time::MIDNIGHT\n                .replace_minute(clip_start(value.minute(), i))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Day, i) => {\n                time::Time::MIDNIGHT.replace_hour(clip_start(value.hour(), i))\n            }\n        }\n        .change_context(PostProcessingError::BucketClipping)?;\n\n        Ok(value.replace_time(clipped_time))\n    }\n", "function_name": "clip_to_start", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time Series Bucket Clipping"}, {"query": "rust hyperswitch ProfileSetter struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileSetter\npub struct ProfileSetter {\n    pub profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "ProfileSetter", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Business Profile Domain Model"}, {"query": "hyperswitch business profile configuration struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileSetter\npub struct ProfileSetter {\n    pub profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "ProfileSetter", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Business Profile Domain Model"}, {"query": "rust domain model for payment profile settings", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileSetter\npub struct ProfileSetter {\n    pub profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "ProfileSetter", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Business Profile Domain Model"}, {"query": "hyperswitch ProfileSetter routing algorithm fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileSetter\npub struct ProfileSetter {\n    pub profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "ProfileSetter", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Business Profile Domain Model"}, {"query": "how to mask api keys in hyperswitch router data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_masked_keys\n    pub fn get_masked_keys(&self) -> Self {\n        match self {\n            Self::TemporaryAuth => Self::TemporaryAuth,\n            Self::NoKey => Self::NoKey,\n            Self::HeaderKey { api_key } => Self::HeaderKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n            },\n            Self::BodyKey { api_key, key1 } => Self::BodyKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n            },\n            Self::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Self::SignatureKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n            },\n            Self::MultiAuthKey {\n                api_key,\n                key1,\n                api_secret,\n                key2,\n            } => Self::MultiAuthKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n                key2: self.mask_key(key2.clone().expose()),\n            },\n            Self::CurrencyAuthKey { auth_key_map } => Self::CurrencyAuthKey {\n                auth_key_map: auth_key_map.clone(),\n            },\n            Self::CertificateAuth {\n                certificate,\n                private_key,\n            } => Self::CertificateAuth {\n                certificate: self.mask_key(certificate.clone().expose()),\n                private_key: self.mask_key(private_key.clone().expose()),\n            },\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]", "function_name": "get_masked_keys", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Router Data Key Masking Utility"}, {"query": "hyperswitch domain models get_masked_keys function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_masked_keys\n    pub fn get_masked_keys(&self) -> Self {\n        match self {\n            Self::TemporaryAuth => Self::TemporaryAuth,\n            Self::NoKey => Self::NoKey,\n            Self::HeaderKey { api_key } => Self::HeaderKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n            },\n            Self::BodyKey { api_key, key1 } => Self::BodyKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n            },\n            Self::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Self::SignatureKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n            },\n            Self::MultiAuthKey {\n                api_key,\n                key1,\n                api_secret,\n                key2,\n            } => Self::MultiAuthKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n                key2: self.mask_key(key2.clone().expose()),\n            },\n            Self::CurrencyAuthKey { auth_key_map } => Self::CurrencyAuthKey {\n                auth_key_map: auth_key_map.clone(),\n            },\n            Self::CertificateAuth {\n                certificate,\n                private_key,\n            } => Self::CertificateAuth {\n                certificate: self.mask_key(certificate.clone().expose()),\n                private_key: self.mask_key(private_key.clone().expose()),\n            },\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]", "function_name": "get_masked_keys", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Router Data Key Masking Utility"}, {"query": "rust enum method to hide sensitive credentials in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_masked_keys\n    pub fn get_masked_keys(&self) -> Self {\n        match self {\n            Self::TemporaryAuth => Self::TemporaryAuth,\n            Self::NoKey => Self::NoKey,\n            Self::HeaderKey { api_key } => Self::HeaderKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n            },\n            Self::BodyKey { api_key, key1 } => Self::BodyKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n            },\n            Self::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Self::SignatureKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n            },\n            Self::MultiAuthKey {\n                api_key,\n                key1,\n                api_secret,\n                key2,\n            } => Self::MultiAuthKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n                key2: self.mask_key(key2.clone().expose()),\n            },\n            Self::CurrencyAuthKey { auth_key_map } => Self::CurrencyAuthKey {\n                auth_key_map: auth_key_map.clone(),\n            },\n            Self::CertificateAuth {\n                certificate,\n                private_key,\n            } => Self::CertificateAuth {\n                certificate: self.mask_key(certificate.clone().expose()),\n                private_key: self.mask_key(private_key.clone().expose()),\n            },\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]", "function_name": "get_masked_keys", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Router Data Key Masking Utility"}, {"query": "hyperswitch router data logging security mask keys", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_masked_keys\n    pub fn get_masked_keys(&self) -> Self {\n        match self {\n            Self::TemporaryAuth => Self::TemporaryAuth,\n            Self::NoKey => Self::NoKey,\n            Self::HeaderKey { api_key } => Self::HeaderKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n            },\n            Self::BodyKey { api_key, key1 } => Self::BodyKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n            },\n            Self::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Self::SignatureKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n            },\n            Self::MultiAuthKey {\n                api_key,\n                key1,\n                api_secret,\n                key2,\n            } => Self::MultiAuthKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n                key2: self.mask_key(key2.clone().expose()),\n            },\n            Self::CurrencyAuthKey { auth_key_map } => Self::CurrencyAuthKey {\n                auth_key_map: auth_key_map.clone(),\n            },\n            Self::CertificateAuth {\n                certificate,\n                private_key,\n            } => Self::CertificateAuth {\n                certificate: self.mask_key(certificate.clone().expose()),\n                private_key: self.mask_key(private_key.clone().expose()),\n            },\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]", "function_name": "get_masked_keys", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Router Data Key Masking Utility"}, {"query": "how to create a Wise payout quote request struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WisePayoutQuoteRequest\npub struct WisePayoutQuoteRequest {\n    source_currency: String,\n    target_currency: String,\n    source_amount: Option<FloatMajorUnit>,\n    target_amount: Option<FloatMajorUnit>,\n    pay_out: WisePayOutOption,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "WisePayoutQuoteRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout quote request struct"}, {"query": "WisePayoutQuoteRequest fields and structure definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WisePayoutQuoteRequest\npub struct WisePayoutQuoteRequest {\n    source_currency: String,\n    target_currency: String,\n    source_amount: Option<FloatMajorUnit>,\n    target_amount: Option<FloatMajorUnit>,\n    pay_out: WisePayOutOption,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "WisePayoutQuoteRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout quote request struct"}, {"query": "hyperswitch wise connector payout quote request model", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WisePayoutQuoteRequest\npub struct WisePayoutQuoteRequest {\n    source_currency: String,\n    target_currency: String,\n    source_amount: Option<FloatMajorUnit>,\n    target_amount: Option<FloatMajorUnit>,\n    pay_out: WisePayOutOption,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "WisePayoutQuoteRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout quote request struct"}, {"query": "transformers.rs WisePayoutQuoteRequest implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WisePayoutQuoteRequest\npub struct WisePayoutQuoteRequest {\n    source_currency: String,\n    target_currency: String,\n    source_amount: Option<FloatMajorUnit>,\n    target_amount: Option<FloatMajorUnit>,\n    pay_out: WisePayOutOption,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "WisePayoutQuoteRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout quote request struct"}, {"query": "Rust enum definition for RedirectForm hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: RedirectForm\npub enum RedirectForm {\n    Form {\n        endpoint: String,\n        method: Method,\n        form_fields: HashMap<String, String>,\n    },\n    Html {\n        html_data: String,\n    },\n    BarclaycardAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    BarclaycardConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    BlueSnap {\n        payment_fields_token: String, // payment-field-token\n    },\n    CybersourceAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    CybersourceConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    DeutschebankThreeDSChallengeFlow {\n        acs_url: String,\n        creq: String,\n    },\n    Payme,\n    Braintree {\n        client_token: String,\n        card_token: String,\n        bin: String,\n        acs_url: String,\n    },\n    Nmi {\n        amount: String,\n        currency: common_enums::Currency,\n        public_key: masking::Secret<String>,\n        customer_vault_id: String,\n        order_id: String,\n    },\n    Mifinity {\n        initialization_token: String,\n    },\n    WorldpayDDCForm {\n        endpoint: url::Url,\n        method: Method,\n        form_fields: HashMap<String, String>,\n        collection_id: Option<String>,\n    },\n    WorldpayxmlRedirectForm {\n        jwt: String,\n    },\n}\n", "function_name": "RedirectForm", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "RedirectForm enum definition"}, {"query": "hyperswitch RedirectForm struct fields Barclaycard", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: RedirectForm\npub enum RedirectForm {\n    Form {\n        endpoint: String,\n        method: Method,\n        form_fields: HashMap<String, String>,\n    },\n    Html {\n        html_data: String,\n    },\n    BarclaycardAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    BarclaycardConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    BlueSnap {\n        payment_fields_token: String, // payment-field-token\n    },\n    CybersourceAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    CybersourceConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    DeutschebankThreeDSChallengeFlow {\n        acs_url: String,\n        creq: String,\n    },\n    Payme,\n    Braintree {\n        client_token: String,\n        card_token: String,\n        bin: String,\n        acs_url: String,\n    },\n    Nmi {\n        amount: String,\n        currency: common_enums::Currency,\n        public_key: masking::Secret<String>,\n        customer_vault_id: String,\n        order_id: String,\n    },\n    Mifinity {\n        initialization_token: String,\n    },\n    WorldpayDDCForm {\n        endpoint: url::Url,\n        method: Method,\n        form_fields: HashMap<String, String>,\n        collection_id: Option<String>,\n    },\n    WorldpayxmlRedirectForm {\n        jwt: String,\n    },\n}\n", "function_name": "RedirectForm", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "RedirectForm enum definition"}, {"query": "how to handle 3DS redirect forms in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: RedirectForm\npub enum RedirectForm {\n    Form {\n        endpoint: String,\n        method: Method,\n        form_fields: HashMap<String, String>,\n    },\n    Html {\n        html_data: String,\n    },\n    BarclaycardAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    BarclaycardConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    BlueSnap {\n        payment_fields_token: String, // payment-field-token\n    },\n    CybersourceAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    CybersourceConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    DeutschebankThreeDSChallengeFlow {\n        acs_url: String,\n        creq: String,\n    },\n    Payme,\n    Braintree {\n        client_token: String,\n        card_token: String,\n        bin: String,\n        acs_url: String,\n    },\n    Nmi {\n        amount: String,\n        currency: common_enums::Currency,\n        public_key: masking::Secret<String>,\n        customer_vault_id: String,\n        order_id: String,\n    },\n    Mifinity {\n        initialization_token: String,\n    },\n    WorldpayDDCForm {\n        endpoint: url::Url,\n        method: Method,\n        form_fields: HashMap<String, String>,\n        collection_id: Option<String>,\n    },\n    WorldpayxmlRedirectForm {\n        jwt: String,\n    },\n}\n", "function_name": "RedirectForm", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "RedirectForm enum definition"}, {"query": "hyperswitch domain models RedirectForm variant types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: RedirectForm\npub enum RedirectForm {\n    Form {\n        endpoint: String,\n        method: Method,\n        form_fields: HashMap<String, String>,\n    },\n    Html {\n        html_data: String,\n    },\n    BarclaycardAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    BarclaycardConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    BlueSnap {\n        payment_fields_token: String, // payment-field-token\n    },\n    CybersourceAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    CybersourceConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    DeutschebankThreeDSChallengeFlow {\n        acs_url: String,\n        creq: String,\n    },\n    Payme,\n    Braintree {\n        client_token: String,\n        card_token: String,\n        bin: String,\n        acs_url: String,\n    },\n    Nmi {\n        amount: String,\n        currency: common_enums::Currency,\n        public_key: masking::Secret<String>,\n        customer_vault_id: String,\n        order_id: String,\n    },\n    Mifinity {\n        initialization_token: String,\n    },\n    WorldpayDDCForm {\n        endpoint: url::Url,\n        method: Method,\n        form_fields: HashMap<String, String>,\n        collection_id: Option<String>,\n    },\n    WorldpayxmlRedirectForm {\n        jwt: String,\n    },\n}\n", "function_name": "RedirectForm", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "RedirectForm enum definition"}, {"query": "how to build airwallex customer request in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Request Builder"}, {"query": "airwallex connector customer router data request builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Request Builder"}, {"query": "rust function to construct airwallex post request headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Request Builder"}, {"query": "hyperswitch airwallex connector build_request implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Request Builder"}, {"query": "IATAPay access token refresh response structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayAuthUpdateResponse\npub struct IatapayAuthUpdateResponse {\n    pub access_token: Secret<String>,\n    pub expires_in: i64,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayAuthUpdateResponse, T, AccessToken>>\n    for RouterData<F, T, AccessToken>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "function_name": "IatapayAuthUpdateResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay auth token response"}, {"query": "Rust struct for IATAPay authentication token", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayAuthUpdateResponse\npub struct IatapayAuthUpdateResponse {\n    pub access_token: Secret<String>,\n    pub expires_in: i64,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayAuthUpdateResponse, T, AccessToken>>\n    for RouterData<F, T, AccessToken>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "function_name": "IatapayAuthUpdateResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay auth token response"}, {"query": "IatapayAuthUpdateResponse implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayAuthUpdateResponse\npub struct IatapayAuthUpdateResponse {\n    pub access_token: Secret<String>,\n    pub expires_in: i64,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayAuthUpdateResponse, T, AccessToken>>\n    for RouterData<F, T, AccessToken>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "function_name": "IatapayAuthUpdateResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay auth token response"}, {"query": "Hyperswitch IATAPay connector token handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayAuthUpdateResponse\npub struct IatapayAuthUpdateResponse {\n    pub access_token: Secret<String>,\n    pub expires_in: i64,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayAuthUpdateResponse, T, AccessToken>>\n    for RouterData<F, T, AccessToken>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "function_name": "IatapayAuthUpdateResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay auth token response"}, {"query": "how to configure Nordea OAuth authentication in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = NordeaOAuthRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea OAuth Request Serialization"}, {"query": "Nordea connector get_request_body implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = NordeaOAuthRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea OAuth Request Serialization"}, {"query": "hyperswitch nordea oauth request payload structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = NordeaOAuthRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea OAuth Request Serialization"}, {"query": "rust code for nordea oauth request transformation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = NordeaOAuthRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea OAuth Request Serialization"}, {"query": "Rust struct WiseRecipientCreateResponse definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateResponse\npub struct WiseRecipientCreateResponse {\n    id: i64,\n    business: Option<i64>,\n    profile: Option<i64>,\n    account_holder_name: Secret<String>,\n    currency: String,\n    country: String,\n    #[serde(rename = \"type\")]\n    request_type: String,\n    details: Option<WiseBankDetails>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WiseRecipientCreateResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout recipient creation response"}, {"query": "hyperswitch payouts Wise recipient creation response fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateResponse\npub struct WiseRecipientCreateResponse {\n    id: i64,\n    business: Option<i64>,\n    profile: Option<i64>,\n    account_holder_name: Secret<String>,\n    currency: String,\n    country: String,\n    #[serde(rename = \"type\")]\n    request_type: String,\n    details: Option<WiseBankDetails>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WiseRecipientCreateResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout recipient creation response"}, {"query": "WiseRecipientCreateResponse serde camelCase mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateResponse\npub struct WiseRecipientCreateResponse {\n    id: i64,\n    business: Option<i64>,\n    profile: Option<i64>,\n    account_holder_name: Secret<String>,\n    currency: String,\n    country: String,\n    #[serde(rename = \"type\")]\n    request_type: String,\n    details: Option<WiseBankDetails>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WiseRecipientCreateResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout recipient creation response"}, {"query": "how to handle Wise bank details in hyperswitch payout", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateResponse\npub struct WiseRecipientCreateResponse {\n    id: i64,\n    business: Option<i64>,\n    profile: Option<i64>,\n    account_holder_name: Secret<String>,\n    currency: String,\n    country: String,\n    #[serde(rename = \"type\")]\n    request_type: String,\n    details: Option<WiseBankDetails>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WiseRecipientCreateResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout recipient creation response"}, {"query": "how to get connector response reference id from router response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_response_reference_id\n    pub fn get_connector_response_reference_id(&self) -> Option<String> {\n        match self {\n            Self::Success {\n                connector_response_reference_id,\n                ..\n            } => connector_response_reference_id.clone(),\n            Self::Error { .. } => None,\n        }\n    }\n}", "function_name": "get_connector_response_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Router response reference ID getter"}, {"query": "rust hyperswitch get_connector_response_reference_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_response_reference_id\n    pub fn get_connector_response_reference_id(&self) -> Option<String> {\n        match self {\n            Self::Success {\n                connector_response_reference_id,\n                ..\n            } => connector_response_reference_id.clone(),\n            Self::Error { .. } => None,\n        }\n    }\n}", "function_name": "get_connector_response_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Router response reference ID getter"}, {"query": "extract reference id from router response types success", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_response_reference_id\n    pub fn get_connector_response_reference_id(&self) -> Option<String> {\n        match self {\n            Self::Success {\n                connector_response_reference_id,\n                ..\n            } => connector_response_reference_id.clone(),\n            Self::Error { .. } => None,\n        }\n    }\n}", "function_name": "get_connector_response_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Router response reference ID getter"}, {"query": "hyperswitch router response types enum success reference id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_response_reference_id\n    pub fn get_connector_response_reference_id(&self) -> Option<String> {\n        match self {\n            Self::Success {\n                connector_response_reference_id,\n                ..\n            } => connector_response_reference_id.clone(),\n            Self::Error { .. } => None,\n        }\n    }\n}", "function_name": "get_connector_response_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Router response reference ID getter"}, {"query": "how to find payment intent from mandate id in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_mandate_id_type\npub async fn find_payment_intent_from_mandate_id_type(\n    state: &SessionState,\n    mandate_id_type: webhooks::MandateIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let mandate = match mandate_id_type {\n        webhooks::MandateIdType::MandateId(mandate_id) => db\n            .find_mandate_by_merchant_id_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n        webhooks::MandateIdType::ConnectorMandateId(connector_mandate_id) => db\n            .find_mandate_by_merchant_id_connector_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                connector_mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n    };\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &mandate\n            .original_payment_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"original_payment_id not present in mandate record\")?,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_mandate_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Mandate to PaymentIntent lookup"}, {"query": "rust function find_payment_intent_from_mandate_id_type implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_mandate_id_type\npub async fn find_payment_intent_from_mandate_id_type(\n    state: &SessionState,\n    mandate_id_type: webhooks::MandateIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let mandate = match mandate_id_type {\n        webhooks::MandateIdType::MandateId(mandate_id) => db\n            .find_mandate_by_merchant_id_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n        webhooks::MandateIdType::ConnectorMandateId(connector_mandate_id) => db\n            .find_mandate_by_merchant_id_connector_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                connector_mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n    };\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &mandate\n            .original_payment_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"original_payment_id not present in mandate record\")?,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_mandate_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Mandate to PaymentIntent lookup"}, {"query": "hyperswitch webhook mandate lookup payment intent", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_mandate_id_type\npub async fn find_payment_intent_from_mandate_id_type(\n    state: &SessionState,\n    mandate_id_type: webhooks::MandateIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let mandate = match mandate_id_type {\n        webhooks::MandateIdType::MandateId(mandate_id) => db\n            .find_mandate_by_merchant_id_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n        webhooks::MandateIdType::ConnectorMandateId(connector_mandate_id) => db\n            .find_mandate_by_merchant_id_connector_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                connector_mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n    };\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &mandate\n            .original_payment_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"original_payment_id not present in mandate record\")?,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_mandate_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Mandate to PaymentIntent lookup"}, {"query": "find payment intent by mandate id type connector mandate", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_mandate_id_type\npub async fn find_payment_intent_from_mandate_id_type(\n    state: &SessionState,\n    mandate_id_type: webhooks::MandateIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let mandate = match mandate_id_type {\n        webhooks::MandateIdType::MandateId(mandate_id) => db\n            .find_mandate_by_merchant_id_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n        webhooks::MandateIdType::ConnectorMandateId(connector_mandate_id) => db\n            .find_mandate_by_merchant_id_connector_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                connector_mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n    };\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &mandate\n            .original_payment_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"original_payment_id not present in mandate record\")?,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_mandate_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Mandate to PaymentIntent lookup"}, {"query": "how to implement setup mandate for Globepay connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Globepay\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay Setup Mandate Stub"}, {"query": "globepay connector setup mandate error not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Globepay\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay Setup Mandate Stub"}, {"query": "hyperswitch globepay setup_mandate function stub", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Globepay\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay Setup Mandate Stub"}, {"query": "why is setup mandate returning not implemented error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Globepay\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay Setup Mandate Stub"}, {"query": "how to implement Netcetera payment connector integration in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Netcetera\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Netcetera\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector integration"}, {"query": "Netcetera payment method tokenization implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Netcetera\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Netcetera\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector integration"}, {"query": "hyperswitch connector integration traits Rust Netcetera", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Netcetera\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Netcetera\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector integration"}, {"query": "Rust payment gateway connector integration Netcetera", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Netcetera\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Netcetera\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector integration"}, {"query": "How to configure UCS only connectors in Hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: determine_connector_integration_type\nasync fn determine_connector_integration_type(\n    state: &SessionState,\n    connector: Connector,\n) -> RouterResult<ConnectorIntegrationType> {\n    match state.conf.grpc_client.unified_connector_service.as_ref() {\n        Some(ucs_config) => {\n            let is_ucs_only = ucs_config.ucs_only_connectors.contains(&connector);\n\n            if is_ucs_only {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    ucs_only_list = is_ucs_only,\n                    \"Using UcsConnector\"\n                );\n                Ok(ConnectorIntegrationType::UcsConnector)\n            } else {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    \"Using DirectandUCSConnector - not in ucs_only_list\"\n                );\n                Ok(ConnectorIntegrationType::DirectandUCSConnector)\n            }\n        }\n        None => {\n            router_env::logger::debug!(\n                connector = ?connector,\n                \"UCS config not present, using DirectandUCSConnector\"\n            );\n            Ok(ConnectorIntegrationType::DirectandUCSConnector)\n        }\n    }\n}\n", "function_name": "determine_connector_integration_type", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Connector integration type determination"}, {"query": "Rust function to check connector integration type in router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: determine_connector_integration_type\nasync fn determine_connector_integration_type(\n    state: &SessionState,\n    connector: Connector,\n) -> RouterResult<ConnectorIntegrationType> {\n    match state.conf.grpc_client.unified_connector_service.as_ref() {\n        Some(ucs_config) => {\n            let is_ucs_only = ucs_config.ucs_only_connectors.contains(&connector);\n\n            if is_ucs_only {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    ucs_only_list = is_ucs_only,\n                    \"Using UcsConnector\"\n                );\n                Ok(ConnectorIntegrationType::UcsConnector)\n            } else {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    \"Using DirectandUCSConnector - not in ucs_only_list\"\n                );\n                Ok(ConnectorIntegrationType::DirectandUCSConnector)\n            }\n        }\n        None => {\n            router_env::logger::debug!(\n                connector = ?connector,\n                \"UCS config not present, using DirectandUCSConnector\"\n            );\n            Ok(ConnectorIntegrationType::DirectandUCSConnector)\n        }\n    }\n}\n", "function_name": "determine_connector_integration_type", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Connector integration type determination"}, {"query": "Hyperswitch determine_connector_integration_type implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: determine_connector_integration_type\nasync fn determine_connector_integration_type(\n    state: &SessionState,\n    connector: Connector,\n) -> RouterResult<ConnectorIntegrationType> {\n    match state.conf.grpc_client.unified_connector_service.as_ref() {\n        Some(ucs_config) => {\n            let is_ucs_only = ucs_config.ucs_only_connectors.contains(&connector);\n\n            if is_ucs_only {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    ucs_only_list = is_ucs_only,\n                    \"Using UcsConnector\"\n                );\n                Ok(ConnectorIntegrationType::UcsConnector)\n            } else {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    \"Using DirectandUCSConnector - not in ucs_only_list\"\n                );\n                Ok(ConnectorIntegrationType::DirectandUCSConnector)\n            }\n        }\n        None => {\n            router_env::logger::debug!(\n                connector = ?connector,\n                \"UCS config not present, using DirectandUCSConnector\"\n            );\n            Ok(ConnectorIntegrationType::DirectandUCSConnector)\n        }\n    }\n}\n", "function_name": "determine_connector_integration_type", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Connector integration type determination"}, {"query": "How does router decide between UcsConnector and DirectandUCSConnector", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: determine_connector_integration_type\nasync fn determine_connector_integration_type(\n    state: &SessionState,\n    connector: Connector,\n) -> RouterResult<ConnectorIntegrationType> {\n    match state.conf.grpc_client.unified_connector_service.as_ref() {\n        Some(ucs_config) => {\n            let is_ucs_only = ucs_config.ucs_only_connectors.contains(&connector);\n\n            if is_ucs_only {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    ucs_only_list = is_ucs_only,\n                    \"Using UcsConnector\"\n                );\n                Ok(ConnectorIntegrationType::UcsConnector)\n            } else {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    \"Using DirectandUCSConnector - not in ucs_only_list\"\n                );\n                Ok(ConnectorIntegrationType::DirectandUCSConnector)\n            }\n        }\n        None => {\n            router_env::logger::debug!(\n                connector = ?connector,\n                \"UCS config not present, using DirectandUCSConnector\"\n            );\n            Ok(ConnectorIntegrationType::DirectandUCSConnector)\n        }\n    }\n}\n", "function_name": "determine_connector_integration_type", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Connector integration type determination"}, {"query": "How to implement RecurringDetails enum for MIT payments in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: RecurringDetails\npub enum RecurringDetails {\n    MandateId(String),\n    PaymentMethodId(String),\n    ProcessorPaymentToken(ProcessorPaymentToken),\n    /// Network transaction ID and Card Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndCardDetails(Box<NetworkTransactionIdAndCardDetails>),\n\n    /// Network transaction ID and Network Token Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndNetworkTokenDetails(Box<NetworkTransactionIdAndNetworkTokenDetails>),\n\n    /// Network transaction ID and Wallet Token details for MIT payments when payment_method_data\n    /// is not stored in the application\n    /// Applicable for wallet tokens such as Apple Pay and Google Pay.\n    NetworkTransactionIdAndDecryptedWalletTokenDetails(\n        Box<common_types::payments::NetworkTransactionIdAndDecryptedWalletTokenDetails>,\n    ),\n\n    CardWithLimitedData(Box<CardWithLimitedData>),\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "RecurringDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Recurring payment mandate enum"}, {"query": "Hyperswitch Rust RecurringDetails enum variants and usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: RecurringDetails\npub enum RecurringDetails {\n    MandateId(String),\n    PaymentMethodId(String),\n    ProcessorPaymentToken(ProcessorPaymentToken),\n    /// Network transaction ID and Card Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndCardDetails(Box<NetworkTransactionIdAndCardDetails>),\n\n    /// Network transaction ID and Network Token Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndNetworkTokenDetails(Box<NetworkTransactionIdAndNetworkTokenDetails>),\n\n    /// Network transaction ID and Wallet Token details for MIT payments when payment_method_data\n    /// is not stored in the application\n    /// Applicable for wallet tokens such as Apple Pay and Google Pay.\n    NetworkTransactionIdAndDecryptedWalletTokenDetails(\n        Box<common_types::payments::NetworkTransactionIdAndDecryptedWalletTokenDetails>,\n    ),\n\n    CardWithLimitedData(Box<CardWithLimitedData>),\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "RecurringDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Recurring payment mandate enum"}, {"query": "Rust payment orchestration RecurringDetails structure definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: RecurringDetails\npub enum RecurringDetails {\n    MandateId(String),\n    PaymentMethodId(String),\n    ProcessorPaymentToken(ProcessorPaymentToken),\n    /// Network transaction ID and Card Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndCardDetails(Box<NetworkTransactionIdAndCardDetails>),\n\n    /// Network transaction ID and Network Token Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndNetworkTokenDetails(Box<NetworkTransactionIdAndNetworkTokenDetails>),\n\n    /// Network transaction ID and Wallet Token details for MIT payments when payment_method_data\n    /// is not stored in the application\n    /// Applicable for wallet tokens such as Apple Pay and Google Pay.\n    NetworkTransactionIdAndDecryptedWalletTokenDetails(\n        Box<common_types::payments::NetworkTransactionIdAndDecryptedWalletTokenDetails>,\n    ),\n\n    CardWithLimitedData(Box<CardWithLimitedData>),\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "RecurringDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Recurring payment mandate enum"}, {"query": "ProcessorPaymentToken RecurringDetails Hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: RecurringDetails\npub enum RecurringDetails {\n    MandateId(String),\n    PaymentMethodId(String),\n    ProcessorPaymentToken(ProcessorPaymentToken),\n    /// Network transaction ID and Card Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndCardDetails(Box<NetworkTransactionIdAndCardDetails>),\n\n    /// Network transaction ID and Network Token Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndNetworkTokenDetails(Box<NetworkTransactionIdAndNetworkTokenDetails>),\n\n    /// Network transaction ID and Wallet Token details for MIT payments when payment_method_data\n    /// is not stored in the application\n    /// Applicable for wallet tokens such as Apple Pay and Google Pay.\n    NetworkTransactionIdAndDecryptedWalletTokenDetails(\n        Box<common_types::payments::NetworkTransactionIdAndDecryptedWalletTokenDetails>,\n    ),\n\n    CardWithLimitedData(Box<CardWithLimitedData>),\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "RecurringDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Recurring payment mandate enum"}, {"query": "rust hyperswitch AuthorizeSessionTokenData struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthorizeSessionTokenData\npub struct AuthorizeSessionTokenData {\n    pub amount_to_capture: Option<i64>,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub amount: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "AuthorizeSessionTokenData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "AuthorizeSessionTokenData struct"}, {"query": "how to use AuthorizeSessionTokenData in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthorizeSessionTokenData\npub struct AuthorizeSessionTokenData {\n    pub amount_to_capture: Option<i64>,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub amount: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "AuthorizeSessionTokenData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "AuthorizeSessionTokenData struct"}, {"query": "hyperswitch AuthorizeSessionTokenData amount_to_capture currency", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthorizeSessionTokenData\npub struct AuthorizeSessionTokenData {\n    pub amount_to_capture: Option<i64>,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub amount: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "AuthorizeSessionTokenData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "AuthorizeSessionTokenData struct"}, {"query": "AuthorizeSessionTokenData struct definition hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthorizeSessionTokenData\npub struct AuthorizeSessionTokenData {\n    pub amount_to_capture: Option<i64>,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub amount: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "AuthorizeSessionTokenData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "AuthorizeSessionTokenData struct"}, {"query": "rust hyperswitch helcim connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim connector header generation"}, {"query": "how to add custom headers in hyperswitch helcim integration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim connector header generation"}, {"query": "helcim connector setup mandate router data get_headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim connector header generation"}, {"query": "hyperswitch rust code get_headers function helcim", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim connector header generation"}, {"query": "how to get request body for gpayments authentication", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = gpayments::GpaymentsRouterData::from((MinorUnit::zero(), req));\n        let req_obj =\n            gpayments_types::GpaymentsAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth request builder"}, {"query": "rust function get_request_body hyperswitch gpayments", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = gpayments::GpaymentsRouterData::from((MinorUnit::zero(), req));\n        let req_obj =\n            gpayments_types::GpaymentsAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth request builder"}, {"query": "gpayments authentication request payload construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = gpayments::GpaymentsRouterData::from((MinorUnit::zero(), req));\n        let req_obj =\n            gpayments_types::GpaymentsAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth request builder"}, {"query": "hyperswitch gpayments connector request body", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = gpayments::GpaymentsRouterData::from((MinorUnit::zero(), req));\n        let req_obj =\n            gpayments_types::GpaymentsAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth request builder"}, {"query": "how to generate authorization header for payone api in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)?;\n        let http_method = self.get_http_method().to_string();\n        let content_type = Self::get_content_type(self);\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let date_header = get_formatted_date_time!(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\"\n        )?;\n        let path: String = url.replace(base_url, \"/\");\n        let authorization_header: String = self.generate_signature(\n            auth,\n            http_method,\n            path,\n            content_type.to_string(),\n            date_header.clone(),\n        )?;\n        let headers = vec![\n            (DATE.to_string(), date_header.to_string().into()),\n            (\n                AUTHORIZATION.to_string(),\n                authorization_header.to_string().into(),\n            ),\n        ];\n\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone API header generation"}, {"query": "hyperswitch payone connector signature generation logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)?;\n        let http_method = self.get_http_method().to_string();\n        let content_type = Self::get_content_type(self);\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let date_header = get_formatted_date_time!(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\"\n        )?;\n        let path: String = url.replace(base_url, \"/\");\n        let authorization_header: String = self.generate_signature(\n            auth,\n            http_method,\n            path,\n            content_type.to_string(),\n            date_header.clone(),\n        )?;\n        let headers = vec![\n            (DATE.to_string(), date_header.to_string().into()),\n            (\n                AUTHORIZATION.to_string(),\n                authorization_header.to_string().into(),\n            ),\n        ];\n\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone API header generation"}, {"query": "rust function to build payone api headers hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)?;\n        let http_method = self.get_http_method().to_string();\n        let content_type = Self::get_content_type(self);\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let date_header = get_formatted_date_time!(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\"\n        )?;\n        let path: String = url.replace(base_url, \"/\");\n        let authorization_header: String = self.generate_signature(\n            auth,\n            http_method,\n            path,\n            content_type.to_string(),\n            date_header.clone(),\n        )?;\n        let headers = vec![\n            (DATE.to_string(), date_header.to_string().into()),\n            (\n                AUTHORIZATION.to_string(),\n                authorization_header.to_string().into(),\n            ),\n        ];\n\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone API header generation"}, {"query": "hyperswitch payone build_headers implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)?;\n        let http_method = self.get_http_method().to_string();\n        let content_type = Self::get_content_type(self);\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let date_header = get_formatted_date_time!(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\"\n        )?;\n        let path: String = url.replace(base_url, \"/\");\n        let authorization_header: String = self.generate_signature(\n            auth,\n            http_method,\n            path,\n            content_type.to_string(),\n            date_header.clone(),\n        )?;\n        let headers = vec![\n            (DATE.to_string(), date_header.to_string().into()),\n            (\n                AUTHORIZATION.to_string(),\n                authorization_header.to_string().into(),\n            ),\n        ];\n\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone API header generation"}, {"query": "How to get transaction ID from Netcetera webhook in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_object_reference_id\n    fn get_webhook_object_reference_id(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ObjectReferenceId, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(ObjectReferenceId::ExternalAuthenticationID(\n            AuthenticationIdType::ConnectorAuthenticationId(webhook_body.three_ds_server_trans_id),\n        ))\n    }\n", "function_name": "get_webhook_object_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook transaction ID extraction"}, {"query": "netcetera webhook three_ds_server_trans_id parsing hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_object_reference_id\n    fn get_webhook_object_reference_id(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ObjectReferenceId, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(ObjectReferenceId::ExternalAuthenticationID(\n            AuthenticationIdType::ConnectorAuthenticationId(webhook_body.three_ds_server_trans_id),\n        ))\n    }\n", "function_name": "get_webhook_object_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook transaction ID extraction"}, {"query": "hyperswitch get_webhook_object_reference_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_object_reference_id\n    fn get_webhook_object_reference_id(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ObjectReferenceId, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(ObjectReferenceId::ExternalAuthenticationID(\n            AuthenticationIdType::ConnectorAuthenticationId(webhook_body.three_ds_server_trans_id),\n        ))\n    }\n", "function_name": "get_webhook_object_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook transaction ID extraction"}, {"query": "Rust connector extract transaction ID from webhook body", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_object_reference_id\n    fn get_webhook_object_reference_id(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ObjectReferenceId, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(ObjectReferenceId::ExternalAuthenticationID(\n            AuthenticationIdType::ConnectorAuthenticationId(webhook_body.three_ds_server_trans_id),\n        ))\n    }\n", "function_name": "get_webhook_object_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook transaction ID extraction"}, {"query": "how to handle tokenex connector errors in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex connector error handler"}, {"query": "tokenex connector error response format rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex connector error handler"}, {"query": "hyperswitch tokenex get_error_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex connector error handler"}, {"query": "custom error handling for hyperswitch tokenex integration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex connector error handler"}, {"query": "how to implement validate_mandate_payment in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \" mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate validation"}, {"query": "zift connector mandate payment validation error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \" mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate validation"}, {"query": "hyperswitch zift payment method validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \" mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate validation"}, {"query": "rust connector validate_mandate_payment implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \" mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate validation"}, {"query": "Rust enum definition for payment outcome status hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentOutcome\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]", "function_name": "PaymentOutcome", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Payment outcome enum definition"}, {"query": "Worldpay connector payment outcome enum aliases hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentOutcome\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]", "function_name": "PaymentOutcome", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Payment outcome enum definition"}, {"query": "hyperswitch PaymentOutcome enum SentForSettlement SentForRefund", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentOutcome\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]", "function_name": "PaymentOutcome", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Payment outcome enum definition"}, {"query": "payment orchestration status enum hyperswitch connectors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentOutcome\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]", "function_name": "PaymentOutcome", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Payment outcome enum definition"}, {"query": "Rust function to mask alphanumeric characters in a string keeping first and last characters visible", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: masking\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567", "function_name": "masking", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "String masking utility"}, {"query": "Hyperswitch common_utils masking function implementation for sensitive data", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: masking\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567", "function_name": "masking", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "String masking utility"}, {"query": "Rust code to obfuscate string with configurable unmasked character count", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: masking\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567", "function_name": "masking", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "String masking utility"}, {"query": "How to mask alphanumeric characters in Rust keeping start and end characters", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: masking\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567", "function_name": "masking", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "String masking utility"}, {"query": "How to handle Authipay error responses in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: authipay::AuthipayErrorResponse = res\n            .response\n            .parse_struct(\"AuthipayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n\n        let mut error_response = ErrorResponse::from(&response);\n\n        // Set status code from the response, or 400 if error code is a \"404\"\n        if let Some(error_code) = &response.error.code {\n            if error_code == \"404\" {\n                error_response.status_code = 404;\n            } else {\n                error_response.status_code = res.status_code;\n            }\n        } else {\n            error_response.status_code = res.status_code;\n        }\n\n        Ok(error_response)\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay error response builder"}, {"query": "Hyperswitch authipay connector error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: authipay::AuthipayErrorResponse = res\n            .response\n            .parse_struct(\"AuthipayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n\n        let mut error_response = ErrorResponse::from(&response);\n\n        // Set status code from the response, or 400 if error code is a \"404\"\n        if let Some(error_code) = &response.error.code {\n            if error_code == \"404\" {\n                error_response.status_code = 404;\n            } else {\n                error_response.status_code = res.status_code;\n            }\n        } else {\n            error_response.status_code = res.status_code;\n        }\n\n        Ok(error_response)\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay error response builder"}, {"query": "build_error_response function authipay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: authipay::AuthipayErrorResponse = res\n            .response\n            .parse_struct(\"AuthipayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n\n        let mut error_response = ErrorResponse::from(&response);\n\n        // Set status code from the response, or 400 if error code is a \"404\"\n        if let Some(error_code) = &response.error.code {\n            if error_code == \"404\" {\n                error_response.status_code = 404;\n            } else {\n                error_response.status_code = res.status_code;\n            }\n        } else {\n            error_response.status_code = res.status_code;\n        }\n\n        Ok(error_response)\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay error response builder"}, {"query": "Parse AuthipayErrorResponse in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: authipay::AuthipayErrorResponse = res\n            .response\n            .parse_struct(\"AuthipayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n\n        let mut error_response = ErrorResponse::from(&response);\n\n        // Set status code from the response, or 400 if error code is a \"404\"\n        if let Some(error_code) = &response.error.code {\n            if error_code == \"404\" {\n                error_response.status_code = 404;\n            } else {\n                error_response.status_code = res.status_code;\n            }\n        } else {\n            error_response.status_code = res.status_code;\n        }\n\n        Ok(error_response)\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay error response builder"}, {"query": "how to map Hyperswitch address to Klarna shipping address", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: get_address_info\nfn get_address_info(\n    address: Option<&hyperswitch_domain_models::address::Address>,\n) -> Option<Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>>> {\n    address.and_then(|add| {\n        add.address.as_ref().map(\n            |address_details| -> Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>> {\n                Ok(KlarnaShippingAddress {\n                    city: address_details.get_city()?.to_owned(),\n                    country: address_details.get_country()?.to_owned(),\n                    email: add.get_email()?.to_owned(),\n                    postal_code: address_details.get_zip()?.to_owned(),\n                    region: address_details.to_state_code()?.to_owned(),\n                    street_address: address_details.get_line1()?.to_owned(),\n                    street_address2: address_details.get_optional_line2(),\n                    given_name: address_details.get_first_name()?.to_owned(),\n                    family_name: address_details.get_last_name()?.to_owned(),\n                    phone: add.get_phone_with_country_code()?.to_owned(),\n                })\n            },\n        )\n    })\n}\n", "function_name": "get_address_info", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna address transformer"}, {"query": "rust function get_address_info Klarna connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: get_address_info\nfn get_address_info(\n    address: Option<&hyperswitch_domain_models::address::Address>,\n) -> Option<Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>>> {\n    address.and_then(|add| {\n        add.address.as_ref().map(\n            |address_details| -> Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>> {\n                Ok(KlarnaShippingAddress {\n                    city: address_details.get_city()?.to_owned(),\n                    country: address_details.get_country()?.to_owned(),\n                    email: add.get_email()?.to_owned(),\n                    postal_code: address_details.get_zip()?.to_owned(),\n                    region: address_details.to_state_code()?.to_owned(),\n                    street_address: address_details.get_line1()?.to_owned(),\n                    street_address2: address_details.get_optional_line2(),\n                    given_name: address_details.get_first_name()?.to_owned(),\n                    family_name: address_details.get_last_name()?.to_owned(),\n                    phone: add.get_phone_with_country_code()?.to_owned(),\n                })\n            },\n        )\n    })\n}\n", "function_name": "get_address_info", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna address transformer"}, {"query": "transform address details to KlarnaShippingAddress", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: get_address_info\nfn get_address_info(\n    address: Option<&hyperswitch_domain_models::address::Address>,\n) -> Option<Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>>> {\n    address.and_then(|add| {\n        add.address.as_ref().map(\n            |address_details| -> Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>> {\n                Ok(KlarnaShippingAddress {\n                    city: address_details.get_city()?.to_owned(),\n                    country: address_details.get_country()?.to_owned(),\n                    email: add.get_email()?.to_owned(),\n                    postal_code: address_details.get_zip()?.to_owned(),\n                    region: address_details.to_state_code()?.to_owned(),\n                    street_address: address_details.get_line1()?.to_owned(),\n                    street_address2: address_details.get_optional_line2(),\n                    given_name: address_details.get_first_name()?.to_owned(),\n                    family_name: address_details.get_last_name()?.to_owned(),\n                    phone: add.get_phone_with_country_code()?.to_owned(),\n                })\n            },\n        )\n    })\n}\n", "function_name": "get_address_info", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna address transformer"}, {"query": "hyperswitch klarna address mapping implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: get_address_info\nfn get_address_info(\n    address: Option<&hyperswitch_domain_models::address::Address>,\n) -> Option<Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>>> {\n    address.and_then(|add| {\n        add.address.as_ref().map(\n            |address_details| -> Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>> {\n                Ok(KlarnaShippingAddress {\n                    city: address_details.get_city()?.to_owned(),\n                    country: address_details.get_country()?.to_owned(),\n                    email: add.get_email()?.to_owned(),\n                    postal_code: address_details.get_zip()?.to_owned(),\n                    region: address_details.to_state_code()?.to_owned(),\n                    street_address: address_details.get_line1()?.to_owned(),\n                    street_address2: address_details.get_optional_line2(),\n                    given_name: address_details.get_first_name()?.to_owned(),\n                    family_name: address_details.get_last_name()?.to_owned(),\n                    phone: add.get_phone_with_country_code()?.to_owned(),\n                })\n            },\n        )\n    })\n}\n", "function_name": "get_address_info", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna address transformer"}, {"query": "rust hyperswitch authipay signature generation hmac sha256", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: generate_authorization_signature\n    pub fn generate_authorization_signature(\n        &self,\n        auth: authipay::AuthipayAuthType,\n        request_id: &str,\n        payload: &str,\n        timestamp: i128,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let authipay::AuthipayAuthType {\n            api_key,\n            api_secret,\n        } = auth;\n        let raw_signature = format!(\"{}{request_id}{timestamp}{payload}\", api_key.peek());\n\n        let key = ring::hmac::Key::new(ring::hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signature_value = common_utils::consts::BASE64_ENGINE\n            .encode(ring::hmac::sign(&key, raw_signature.as_bytes()).as_ref());\n        Ok(signature_value)\n    }\n}\n", "function_name": "generate_authorization_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay HMAC Signature Generation"}, {"query": "how to generate authorization signature for authipay connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: generate_authorization_signature\n    pub fn generate_authorization_signature(\n        &self,\n        auth: authipay::AuthipayAuthType,\n        request_id: &str,\n        payload: &str,\n        timestamp: i128,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let authipay::AuthipayAuthType {\n            api_key,\n            api_secret,\n        } = auth;\n        let raw_signature = format!(\"{}{request_id}{timestamp}{payload}\", api_key.peek());\n\n        let key = ring::hmac::Key::new(ring::hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signature_value = common_utils::consts::BASE64_ENGINE\n            .encode(ring::hmac::sign(&key, raw_signature.as_bytes()).as_ref());\n        Ok(signature_value)\n    }\n}\n", "function_name": "generate_authorization_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay HMAC Signature Generation"}, {"query": "hyperswitch authipay signature base64 encode hmac", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: generate_authorization_signature\n    pub fn generate_authorization_signature(\n        &self,\n        auth: authipay::AuthipayAuthType,\n        request_id: &str,\n        payload: &str,\n        timestamp: i128,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let authipay::AuthipayAuthType {\n            api_key,\n            api_secret,\n        } = auth;\n        let raw_signature = format!(\"{}{request_id}{timestamp}{payload}\", api_key.peek());\n\n        let key = ring::hmac::Key::new(ring::hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signature_value = common_utils::consts::BASE64_ENGINE\n            .encode(ring::hmac::sign(&key, raw_signature.as_bytes()).as_ref());\n        Ok(signature_value)\n    }\n}\n", "function_name": "generate_authorization_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay HMAC Signature Generation"}, {"query": "authipay signature generation rust implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: generate_authorization_signature\n    pub fn generate_authorization_signature(\n        &self,\n        auth: authipay::AuthipayAuthType,\n        request_id: &str,\n        payload: &str,\n        timestamp: i128,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let authipay::AuthipayAuthType {\n            api_key,\n            api_secret,\n        } = auth;\n        let raw_signature = format!(\"{}{request_id}{timestamp}{payload}\", api_key.peek());\n\n        let key = ring::hmac::Key::new(ring::hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signature_value = common_utils::consts::BASE64_ENGINE\n            .encode(ring::hmac::sign(&key, raw_signature.as_bytes()).as_ref());\n        Ok(signature_value)\n    }\n}\n", "function_name": "generate_authorization_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay HMAC Signature Generation"}, {"query": "how to generate amazon pay authorization header signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_authorization_header\n    pub fn create_authorization_header(\n        &self,\n        auth: amazonpay::AmazonpayAuthType,\n        canonical_uri: &str,\n        http_method: &Method,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> String {\n        let amazonpay::AmazonpayAuthType {\n            public_key,\n            private_key,\n        } = auth;\n\n        let mut signed_headers =\n            format!(\"{HEADER_ACCEPT};{HEADER_CONTENT_TYPE};{HEADER_DATE};{HEADER_HOST};\",);\n        if *http_method == Method::Post\n            && Self::get_last_segment(canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            signed_headers.push_str(HEADER_IDEMPOTENCY_KEY);\n            signed_headers.push(';');\n        }\n        signed_headers.push_str(HEADER_REGION);\n\n        format!(\n            \"{} PublicKeyId={}, SignedHeaders={}, Signature={}\",\n            SIGNING_ALGO,\n            public_key.expose().clone(),\n            signed_headers,\n            Self::create_signature(\n                &private_key,\n                *http_method,\n                canonical_uri,\n                &signed_headers,\n                hashed_payload,\n                header\n            )\n            .unwrap_or_else(|_| \"Invalid signature\".to_string())\n        )\n    }\n", "function_name": "create_authorization_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Signature Generation"}, {"query": "rust hyperswitch amazonpay create_authorization_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_authorization_header\n    pub fn create_authorization_header(\n        &self,\n        auth: amazonpay::AmazonpayAuthType,\n        canonical_uri: &str,\n        http_method: &Method,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> String {\n        let amazonpay::AmazonpayAuthType {\n            public_key,\n            private_key,\n        } = auth;\n\n        let mut signed_headers =\n            format!(\"{HEADER_ACCEPT};{HEADER_CONTENT_TYPE};{HEADER_DATE};{HEADER_HOST};\",);\n        if *http_method == Method::Post\n            && Self::get_last_segment(canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            signed_headers.push_str(HEADER_IDEMPOTENCY_KEY);\n            signed_headers.push(';');\n        }\n        signed_headers.push_str(HEADER_REGION);\n\n        format!(\n            \"{} PublicKeyId={}, SignedHeaders={}, Signature={}\",\n            SIGNING_ALGO,\n            public_key.expose().clone(),\n            signed_headers,\n            Self::create_signature(\n                &private_key,\n                *http_method,\n                canonical_uri,\n                &signed_headers,\n                hashed_payload,\n                header\n            )\n            .unwrap_or_else(|_| \"Invalid signature\".to_string())\n        )\n    }\n", "function_name": "create_authorization_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Signature Generation"}, {"query": "hyperswitch connector amazonpay signature generation logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_authorization_header\n    pub fn create_authorization_header(\n        &self,\n        auth: amazonpay::AmazonpayAuthType,\n        canonical_uri: &str,\n        http_method: &Method,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> String {\n        let amazonpay::AmazonpayAuthType {\n            public_key,\n            private_key,\n        } = auth;\n\n        let mut signed_headers =\n            format!(\"{HEADER_ACCEPT};{HEADER_CONTENT_TYPE};{HEADER_DATE};{HEADER_HOST};\",);\n        if *http_method == Method::Post\n            && Self::get_last_segment(canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            signed_headers.push_str(HEADER_IDEMPOTENCY_KEY);\n            signed_headers.push(';');\n        }\n        signed_headers.push_str(HEADER_REGION);\n\n        format!(\n            \"{} PublicKeyId={}, SignedHeaders={}, Signature={}\",\n            SIGNING_ALGO,\n            public_key.expose().clone(),\n            signed_headers,\n            Self::create_signature(\n                &private_key,\n                *http_method,\n                canonical_uri,\n                &signed_headers,\n                hashed_payload,\n                header\n            )\n            .unwrap_or_else(|_| \"Invalid signature\".to_string())\n        )\n    }\n", "function_name": "create_authorization_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Signature Generation"}, {"query": "aws signature v4 amazonpay header construction rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_authorization_header\n    pub fn create_authorization_header(\n        &self,\n        auth: amazonpay::AmazonpayAuthType,\n        canonical_uri: &str,\n        http_method: &Method,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> String {\n        let amazonpay::AmazonpayAuthType {\n            public_key,\n            private_key,\n        } = auth;\n\n        let mut signed_headers =\n            format!(\"{HEADER_ACCEPT};{HEADER_CONTENT_TYPE};{HEADER_DATE};{HEADER_HOST};\",);\n        if *http_method == Method::Post\n            && Self::get_last_segment(canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            signed_headers.push_str(HEADER_IDEMPOTENCY_KEY);\n            signed_headers.push(';');\n        }\n        signed_headers.push_str(HEADER_REGION);\n\n        format!(\n            \"{} PublicKeyId={}, SignedHeaders={}, Signature={}\",\n            SIGNING_ALGO,\n            public_key.expose().clone(),\n            signed_headers,\n            Self::create_signature(\n                &private_key,\n                *http_method,\n                canonical_uri,\n                &signed_headers,\n                hashed_payload,\n                header\n            )\n            .unwrap_or_else(|_| \"Invalid signature\".to_string())\n        )\n    }\n", "function_name": "create_authorization_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Signature Generation"}, {"query": "how to parse netcetera webhook response body for 3ds authentication", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_external_authentication_details\n    fn get_external_authentication_details(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ExternalAuthenticationPayload, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(ExternalAuthenticationPayload {\n            trans_status: webhook_body\n                .trans_status\n                .unwrap_or(common_enums::TransactionStatus::InformationOnly),\n            authentication_value: webhook_body.authentication_value,\n            eci: webhook_body.eci,\n            challenge_cancel,\n            challenge_code_reason,\n        })\n    }\n}\n", "function_name": "get_external_authentication_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook authentication payload parser"}, {"query": "rust hyperswitch netcetera connector extract trans_status from webhook", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_external_authentication_details\n    fn get_external_authentication_details(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ExternalAuthenticationPayload, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(ExternalAuthenticationPayload {\n            trans_status: webhook_body\n                .trans_status\n                .unwrap_or(common_enums::TransactionStatus::InformationOnly),\n            authentication_value: webhook_body.authentication_value,\n            eci: webhook_body.eci,\n            challenge_cancel,\n            challenge_code_reason,\n        })\n    }\n}\n", "function_name": "get_external_authentication_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook authentication payload parser"}, {"query": "get_external_authentication_details implementation hyperswitch netcetera", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_external_authentication_details\n    fn get_external_authentication_details(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ExternalAuthenticationPayload, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(ExternalAuthenticationPayload {\n            trans_status: webhook_body\n                .trans_status\n                .unwrap_or(common_enums::TransactionStatus::InformationOnly),\n            authentication_value: webhook_body.authentication_value,\n            eci: webhook_body.eci,\n            challenge_cancel,\n            challenge_code_reason,\n        })\n    }\n}\n", "function_name": "get_external_authentication_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook authentication payload parser"}, {"query": "netcetera webhook challenge_cancel transStatusReason parsing hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_external_authentication_details\n    fn get_external_authentication_details(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ExternalAuthenticationPayload, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(ExternalAuthenticationPayload {\n            trans_status: webhook_body\n                .trans_status\n                .unwrap_or(common_enums::TransactionStatus::InformationOnly),\n            authentication_value: webhook_body.authentication_value,\n            eci: webhook_body.eci,\n            challenge_cancel,\n            challenge_code_reason,\n        })\n    }\n}\n", "function_name": "get_external_authentication_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera webhook authentication payload parser"}, {"query": "rust struct definition for updating business profile settings", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileGeneralUpdate\npub struct ProfileGeneralUpdate {\n    pub profile_name: Option<String>,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: Option<bool>,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: Option<bool>,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: Option<bool>,\n    pub is_l2_l3_enabled: Option<bool>,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: Option<bool>,\n    pub is_auto_retries_enabled: Option<bool>,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub is_click_to_pay_enabled: Option<bool>,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: Option<bool>,\n    pub force_3ds_challenge: Option<bool>,\n    pub is_debit_routing_enabled: Option<bool>,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: Option<bool>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub is_external_vault_enabled: Option<common_enums::ExternalVaultEnabled>,\n    pub external_vault_connector_details: Option<ExternalVaultConnectorDetails>,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug)]", "function_name": "ProfileGeneralUpdate", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Business Profile Update Configuration"}, {"query": "hyperswitch ProfileGeneralUpdate fields for webhook configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileGeneralUpdate\npub struct ProfileGeneralUpdate {\n    pub profile_name: Option<String>,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: Option<bool>,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: Option<bool>,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: Option<bool>,\n    pub is_l2_l3_enabled: Option<bool>,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: Option<bool>,\n    pub is_auto_retries_enabled: Option<bool>,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub is_click_to_pay_enabled: Option<bool>,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: Option<bool>,\n    pub force_3ds_challenge: Option<bool>,\n    pub is_debit_routing_enabled: Option<bool>,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: Option<bool>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub is_external_vault_enabled: Option<common_enums::ExternalVaultEnabled>,\n    pub external_vault_connector_details: Option<ExternalVaultConnectorDetails>,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug)]", "function_name": "ProfileGeneralUpdate", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Business Profile Update Configuration"}, {"query": "how to configure routing algorithms in ProfileGeneralUpdate", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileGeneralUpdate\npub struct ProfileGeneralUpdate {\n    pub profile_name: Option<String>,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: Option<bool>,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: Option<bool>,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: Option<bool>,\n    pub is_l2_l3_enabled: Option<bool>,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: Option<bool>,\n    pub is_auto_retries_enabled: Option<bool>,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub is_click_to_pay_enabled: Option<bool>,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: Option<bool>,\n    pub force_3ds_challenge: Option<bool>,\n    pub is_debit_routing_enabled: Option<bool>,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: Option<bool>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub is_external_vault_enabled: Option<common_enums::ExternalVaultEnabled>,\n    pub external_vault_connector_details: Option<ExternalVaultConnectorDetails>,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug)]", "function_name": "ProfileGeneralUpdate", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Business Profile Update Configuration"}, {"query": "rust struct ProfileGeneralUpdate authentication connector details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileGeneralUpdate\npub struct ProfileGeneralUpdate {\n    pub profile_name: Option<String>,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: Option<bool>,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: Option<bool>,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: Option<bool>,\n    pub is_l2_l3_enabled: Option<bool>,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: Option<bool>,\n    pub is_auto_retries_enabled: Option<bool>,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub is_click_to_pay_enabled: Option<bool>,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: Option<bool>,\n    pub force_3ds_challenge: Option<bool>,\n    pub is_debit_routing_enabled: Option<bool>,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: Option<bool>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub is_external_vault_enabled: Option<common_enums::ExternalVaultEnabled>,\n    pub external_vault_connector_details: Option<ExternalVaultConnectorDetails>,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug)]", "function_name": "ProfileGeneralUpdate", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Business Profile Update Configuration"}, {"query": "how to handle Globepay API error responses in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: globepay::GlobepayErrorResponse = res\n            .response\n            .parse_struct(\"GlobepayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.return_code.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: Some(response.return_msg),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay error response builder"}, {"query": "build_error_response function implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: globepay::GlobepayErrorResponse = res\n            .response\n            .parse_struct(\"GlobepayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.return_code.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: Some(response.return_msg),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay error response builder"}, {"query": "parse GlobepayErrorResponse struct in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: globepay::GlobepayErrorResponse = res\n            .response\n            .parse_struct(\"GlobepayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.return_code.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: Some(response.return_msg),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay error response builder"}, {"query": "hyperswitch error handling connector Globepay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: globepay::GlobepayErrorResponse = res\n            .response\n            .parse_struct(\"GlobepayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.return_code.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: Some(response.return_msg),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay error response builder"}, {"query": "how to handle sift connector error responses in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift error response builder"}, {"query": "build_error_response function implementation sift rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift error response builder"}, {"query": "parse sift error response body hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift error response builder"}, {"query": "hyperswitch sift connector error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift error response builder"}, {"query": "how to build request for barclaycard pre-auth", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PaymentsPreAuthenticateType::get_url(\n                self, req, connectors,\n            )?)\n            .attach_default_headers()\n            .headers(PaymentsPreAuthenticateType::get_headers(\n                self, req, connectors,\n            )?)\n            .set_body(self.get_request_body(req, connectors)?)\n            .build();\n\n        Ok(Some(request))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth request builder"}, {"query": "barclaycard pre-auth request builder rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PaymentsPreAuthenticateType::get_url(\n                self, req, connectors,\n            )?)\n            .attach_default_headers()\n            .headers(PaymentsPreAuthenticateType::get_headers(\n                self, req, connectors,\n            )?)\n            .set_body(self.get_request_body(req, connectors)?)\n            .build();\n\n        Ok(Some(request))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth request builder"}, {"query": "PaymentsPreAuthenticateRouterData barclaycard connector implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PaymentsPreAuthenticateType::get_url(\n                self, req, connectors,\n            )?)\n            .attach_default_headers()\n            .headers(PaymentsPreAuthenticateType::get_headers(\n                self, req, connectors,\n            )?)\n            .set_body(self.get_request_body(req, connectors)?)\n            .build();\n\n        Ok(Some(request))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth request builder"}, {"query": "hyperswitch barclaycard pre-auth request construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PaymentsPreAuthenticateType::get_url(\n                self, req, connectors,\n            )?)\n            .attach_default_headers()\n            .headers(PaymentsPreAuthenticateType::get_headers(\n                self, req, connectors,\n            )?)\n            .set_body(self.get_request_body(req, connectors)?)\n            .build();\n\n        Ok(Some(request))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth request builder"}, {"query": "how to implement connector validation for nordea access token authentication", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: ConnectorValidation\nimpl ConnectorValidation for Nordea {}\n\nimpl\n    ConnectorIntegration<\n        AccessTokenAuthentication,\n        AccessTokenAuthenticationRequestData,\n        AccessTokenAuthenticationResponse,\n    > for Nordea\n{", "function_name": "ConnectorValidation", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea Access Token Validation"}, {"query": "rust connector validation trait implementation nordea hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: ConnectorValidation\nimpl ConnectorValidation for Nordea {}\n\nimpl\n    ConnectorIntegration<\n        AccessTokenAuthentication,\n        AccessTokenAuthenticationRequestData,\n        AccessTokenAuthenticationResponse,\n    > for Nordea\n{", "function_name": "ConnectorValidation", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea Access Token Validation"}, {"query": "hyperswitch nordea connector access token authentication validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: ConnectorValidation\nimpl ConnectorValidation for Nordea {}\n\nimpl\n    ConnectorIntegration<\n        AccessTokenAuthentication,\n        AccessTokenAuthenticationRequestData,\n        AccessTokenAuthenticationResponse,\n    > for Nordea\n{", "function_name": "ConnectorValidation", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea Access Token Validation"}, {"query": "nordea payment gateway connector validation implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: ConnectorValidation\nimpl ConnectorValidation for Nordea {}\n\nimpl\n    ConnectorIntegration<\n        AccessTokenAuthentication,\n        AccessTokenAuthenticationRequestData,\n        AccessTokenAuthenticationResponse,\n    > for Nordea\n{", "function_name": "ConnectorValidation", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea Access Token Validation"}, {"query": "SignifydPaymentsSaleRequest struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentsSaleRequest\npub struct SignifydPaymentsSaleRequest {\n    order_id: String,\n    purchase: Purchase,\n    decision_delivery: DecisionDelivery,\n    coverage_requests: Option<CoverageRequests>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"camelCase\", deserialize = \"snake_case\"))]", "function_name": "SignifydPaymentsSaleRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd payment sale request struct"}, {"query": "how to construct Signifyd payment sale request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentsSaleRequest\npub struct SignifydPaymentsSaleRequest {\n    order_id: String,\n    purchase: Purchase,\n    decision_delivery: DecisionDelivery,\n    coverage_requests: Option<CoverageRequests>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"camelCase\", deserialize = \"snake_case\"))]", "function_name": "SignifydPaymentsSaleRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd payment sale request struct"}, {"query": "Signifyd fraud protection payload fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentsSaleRequest\npub struct SignifydPaymentsSaleRequest {\n    order_id: String,\n    purchase: Purchase,\n    decision_delivery: DecisionDelivery,\n    coverage_requests: Option<CoverageRequests>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"camelCase\", deserialize = \"snake_case\"))]", "function_name": "SignifydPaymentsSaleRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd payment sale request struct"}, {"query": "SignifydPaymentsSaleRequest Rust struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentsSaleRequest\npub struct SignifydPaymentsSaleRequest {\n    order_id: String,\n    purchase: Purchase,\n    decision_delivery: DecisionDelivery,\n    coverage_requests: Option<CoverageRequests>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"camelCase\", deserialize = \"snake_case\"))]", "function_name": "SignifydPaymentsSaleRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd payment sale request struct"}, {"query": "how to handle wells fargo api error responses in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo error response handler"}, {"query": "wells fargo connector get_error_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo error response handler"}, {"query": "rust function to parse wells fargo http error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo error response handler"}, {"query": "hyperswitch wells fargo error handling standardization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo error response handler"}, {"query": "how to implement try_from for tuple in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: try_from\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Rust try_from tuple conversion"}, {"query": "rust try_from tuple to struct example", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: try_from\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Rust try_from tuple conversion"}, {"query": "hyperswitch rust connector try_from implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: try_from\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Rust try_from tuple conversion"}, {"query": "convert tuple to struct using try_from rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: try_from\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Rust try_from tuple conversion"}, {"query": "Rust From trait implementation for Wise connector response tuple", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector From trait"}, {"query": "how to convert Wise API response tuple to struct in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector From trait"}, {"query": "hyperswitch wise transformer from method FloatMajorUnit T", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector From trait"}, {"query": "Rust payment orchestration connector response parsing pattern", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector From trait"}, {"query": "How to configure amount conversion for Barclays connector in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.get_minor_amount();\n        let currency = req.request.get_currency()?;\n\n        let amount = convert_amount(self.amount_converter, minor_amount, currency)?;\n\n        let connector_router_data = barclaycard::BarclaycardRouterData::try_from((amount, req))?;\n        let connector_req =\n            barclaycard::BarclaycardAuthSetupRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth request builder"}, {"query": "Barclaycard hyperswitch connector pre-authentication request payload structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.get_minor_amount();\n        let currency = req.request.get_currency()?;\n\n        let amount = convert_amount(self.amount_converter, minor_amount, currency)?;\n\n        let connector_router_data = barclaycard::BarclaycardRouterData::try_from((amount, req))?;\n        let connector_req =\n            barclaycard::BarclaycardAuthSetupRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth request builder"}, {"query": "Hyperswitch barclaycard get_request_body function implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.get_minor_amount();\n        let currency = req.request.get_currency()?;\n\n        let amount = convert_amount(self.amount_converter, minor_amount, currency)?;\n\n        let connector_router_data = barclaycard::BarclaycardRouterData::try_from((amount, req))?;\n        let connector_req =\n            barclaycard::BarclaycardAuthSetupRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth request builder"}, {"query": "Rust connector error handling for Barclays payment pre-authentication", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.get_minor_amount();\n        let currency = req.request.get_currency()?;\n\n        let amount = convert_amount(self.amount_converter, minor_amount, currency)?;\n\n        let connector_router_data = barclaycard::BarclaycardRouterData::try_from((amount, req))?;\n        let connector_req =\n            barclaycard::BarclaycardAuthSetupRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth request builder"}, {"query": "rust hyperswitch apply_mask function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: apply_mask\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string();\n    }\n\n    let mask_start_index =\n    // For showing only last `unmasked_char_count` characters\n    if len < (unmasked_char_count * 2 + min_masked_char_count) {\n        0\n    // For showing first and last `unmasked_char_count` characters\n    } else {\n        unmasked_char_count\n    };\n    let mask_end_index = len - unmasked_char_count - 1;\n    let range = mask_start_index..=mask_end_index;\n\n    val.chars()\n        .enumerate()\n        .fold(String::new(), |mut acc, (index, ch)| {\n            if ch.is_alphanumeric() && range.contains(&index) {\n                acc.push('*');\n            } else {\n                acc.push(ch);\n            }\n            acc\n        })\n}\n\n/// Masked sort code\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "function_name": "apply_mask", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "String masking utility"}, {"query": "how to mask sensitive data in hyperswitch common_utils", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: apply_mask\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string();\n    }\n\n    let mask_start_index =\n    // For showing only last `unmasked_char_count` characters\n    if len < (unmasked_char_count * 2 + min_masked_char_count) {\n        0\n    // For showing first and last `unmasked_char_count` characters\n    } else {\n        unmasked_char_count\n    };\n    let mask_end_index = len - unmasked_char_count - 1;\n    let range = mask_start_index..=mask_end_index;\n\n    val.chars()\n        .enumerate()\n        .fold(String::new(), |mut acc, (index, ch)| {\n            if ch.is_alphanumeric() && range.contains(&index) {\n                acc.push('*');\n            } else {\n                acc.push(ch);\n            }\n            acc\n        })\n}\n\n/// Masked sort code\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "function_name": "apply_mask", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "String masking utility"}, {"query": "hyperswitch string masking utility preserve first and last characters", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: apply_mask\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string();\n    }\n\n    let mask_start_index =\n    // For showing only last `unmasked_char_count` characters\n    if len < (unmasked_char_count * 2 + min_masked_char_count) {\n        0\n    // For showing first and last `unmasked_char_count` characters\n    } else {\n        unmasked_char_count\n    };\n    let mask_end_index = len - unmasked_char_count - 1;\n    let range = mask_start_index..=mask_end_index;\n\n    val.chars()\n        .enumerate()\n        .fold(String::new(), |mut acc, (index, ch)| {\n            if ch.is_alphanumeric() && range.contains(&index) {\n                acc.push('*');\n            } else {\n                acc.push(ch);\n            }\n            acc\n        })\n}\n\n/// Masked sort code\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "function_name": "apply_mask", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "String masking utility"}, {"query": "rust function to mask string with asterisks unmasked_char_count", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: apply_mask\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string();\n    }\n\n    let mask_start_index =\n    // For showing only last `unmasked_char_count` characters\n    if len < (unmasked_char_count * 2 + min_masked_char_count) {\n        0\n    // For showing first and last `unmasked_char_count` characters\n    } else {\n        unmasked_char_count\n    };\n    let mask_end_index = len - unmasked_char_count - 1;\n    let range = mask_start_index..=mask_end_index;\n\n    val.chars()\n        .enumerate()\n        .fold(String::new(), |mut acc, (index, ch)| {\n            if ch.is_alphanumeric() && range.contains(&index) {\n                acc.push('*');\n            } else {\n                acc.push(ch);\n            }\n            acc\n        })\n}\n\n/// Masked sort code\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "function_name": "apply_mask", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "String masking utility"}, {"query": "how to configure TokenEx PCI Tokenize URL in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/v2/Pci/Tokenize\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "TokenEx PCI Tokenize URL generation"}, {"query": "hyperswitch TokenEx connector get_url implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/v2/Pci/Tokenize\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "TokenEx PCI Tokenize URL generation"}, {"query": "TokenEx hyperswitch v2/Pci/Tokenize endpoint configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/v2/Pci/Tokenize\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "TokenEx PCI Tokenize URL generation"}, {"query": "hyperswitch TokenEx connector base_url and get_url method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/v2/Pci/Tokenize\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "TokenEx PCI Tokenize URL generation"}, {"query": "rust hyperswitch CaptureSyncResponse enum definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: CaptureSyncResponse\npub enum CaptureSyncResponse {\n    Success {\n        resource_id: ResponseId,\n        status: common_enums::AttemptStatus,\n        connector_response_reference_id: Option<String>,\n        amount: Option<MinorUnit>,\n    },\n    Error {\n        code: String,\n        message: String,\n        reason: Option<String>,\n        status_code: u16,\n        amount: Option<MinorUnit>,\n    },\n}\n", "function_name": "CaptureSyncResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "CaptureSyncResponse enum definition"}, {"query": "how to handle CaptureSyncResponse success and error variants in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: CaptureSyncResponse\npub enum CaptureSyncResponse {\n    Success {\n        resource_id: ResponseId,\n        status: common_enums::AttemptStatus,\n        connector_response_reference_id: Option<String>,\n        amount: Option<MinorUnit>,\n    },\n    Error {\n        code: String,\n        message: String,\n        reason: Option<String>,\n        status_code: u16,\n        amount: Option<MinorUnit>,\n    },\n}\n", "function_name": "CaptureSyncResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "CaptureSyncResponse enum definition"}, {"query": "hyperswitch router synchronous capture response types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: CaptureSyncResponse\npub enum CaptureSyncResponse {\n    Success {\n        resource_id: ResponseId,\n        status: common_enums::AttemptStatus,\n        connector_response_reference_id: Option<String>,\n        amount: Option<MinorUnit>,\n    },\n    Error {\n        code: String,\n        message: String,\n        reason: Option<String>,\n        status_code: u16,\n        amount: Option<MinorUnit>,\n    },\n}\n", "function_name": "CaptureSyncResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "CaptureSyncResponse enum definition"}, {"query": "CaptureSyncResponse struct fields resource_id status_code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: CaptureSyncResponse\npub enum CaptureSyncResponse {\n    Success {\n        resource_id: ResponseId,\n        status: common_enums::AttemptStatus,\n        connector_response_reference_id: Option<String>,\n        amount: Option<MinorUnit>,\n    },\n    Error {\n        code: String,\n        message: String,\n        reason: Option<String>,\n        status_code: u16,\n        amount: Option<MinorUnit>,\n    },\n}\n", "function_name": "CaptureSyncResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "CaptureSyncResponse enum definition"}, {"query": "rust hyperswitch redsys connector get_url implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreProcessingRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/sis/rest/iniciaPeticionREST\",\n            self.base_url(connectors)\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys payment initiation URL generation"}, {"query": "how to generate redsys payment initiation url hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreProcessingRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/sis/rest/iniciaPeticionREST\",\n            self.base_url(connectors)\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys payment initiation URL generation"}, {"query": "hyperswitch redsys connector base_url sis rest iniciaPeticionREST", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreProcessingRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/sis/rest/iniciaPeticionREST\",\n            self.base_url(connectors)\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys payment initiation URL generation"}, {"query": "redsys payment gateway url generation hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreProcessingRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/sis/rest/iniciaPeticionREST\",\n            self.base_url(connectors)\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys payment initiation URL generation"}, {"query": "how to extract connector transaction id from TransactionResponse enum", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_transaction_id\n    pub fn get_connector_transaction_id(\n        &self,\n    ) -> Result<String, error_stack::Report<ApiErrorResponse>> {\n        match self {\n            Self::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(txn_id),\n                ..\n            } => Ok(txn_id.to_string()),\n            _ => Err(ApiErrorResponse::MissingRequiredField {\n                field_name: \"ConnectorTransactionId\",\n            }\n            .into()),\n        }\n    }\n", "function_name": "get_connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "TransactionResponse connector id extractor"}, {"query": "rust hyperswitch get_connector_transaction_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_transaction_id\n    pub fn get_connector_transaction_id(\n        &self,\n    ) -> Result<String, error_stack::Report<ApiErrorResponse>> {\n        match self {\n            Self::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(txn_id),\n                ..\n            } => Ok(txn_id.to_string()),\n            _ => Err(ApiErrorResponse::MissingRequiredField {\n                field_name: \"ConnectorTransactionId\",\n            }\n            .into()),\n        }\n    }\n", "function_name": "get_connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "TransactionResponse connector id extractor"}, {"query": "hyperswitch domain models router_response_types connector transaction id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_transaction_id\n    pub fn get_connector_transaction_id(\n        &self,\n    ) -> Result<String, error_stack::Report<ApiErrorResponse>> {\n        match self {\n            Self::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(txn_id),\n                ..\n            } => Ok(txn_id.to_string()),\n            _ => Err(ApiErrorResponse::MissingRequiredField {\n                field_name: \"ConnectorTransactionId\",\n            }\n            .into()),\n        }\n    }\n", "function_name": "get_connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "TransactionResponse connector id extractor"}, {"query": "TransactionResponse enum variant connector transaction id extraction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_transaction_id\n    pub fn get_connector_transaction_id(\n        &self,\n    ) -> Result<String, error_stack::Report<ApiErrorResponse>> {\n        match self {\n            Self::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(txn_id),\n                ..\n            } => Ok(txn_id.to_string()),\n            _ => Err(ApiErrorResponse::MissingRequiredField {\n                field_name: \"ConnectorTransactionId\",\n            }\n            .into()),\n        }\n    }\n", "function_name": "get_connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "TransactionResponse connector id extractor"}, {"query": "how to use Aggregate enum for sum in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Aggregate\npub enum Aggregate<R> {\n    Count {\n        field: Option<R>,\n        alias: Option<&'static str>,\n    },\n    Sum {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Min {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Max {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Percentile {\n        field: R,\n        alias: Option<&'static str>,\n        percentile: Option<&'static u8>,\n    },\n    DistinctCount {\n        field: R,\n        alias: Option<&'static str>,\n    },\n}\n\n// Window functions in query\n// ---\n// Description -\n// field: to_sql type value used as expr in aggregation\n// partition_by: partition by fields in window\n// order_by: order by fields and order (Ascending / Descending) in window\n// alias: alias of window expr in query\n// ---\n// Usage -\n// Window::Sum {\n//     field: \"count\",\n//     partition_by: Some(query_builder.transform_to_sql_values(&dimensions).switch()?),\n//     order_by: Some((\"value\", Descending)),\n//     alias: Some(\"total\"),\n// }\n#[derive(Debug)]", "function_name": "Aggregate", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Analytics Aggregate Enum"}, {"query": "hyperswitch analytics query sum aggregate example", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Aggregate\npub enum Aggregate<R> {\n    Count {\n        field: Option<R>,\n        alias: Option<&'static str>,\n    },\n    Sum {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Min {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Max {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Percentile {\n        field: R,\n        alias: Option<&'static str>,\n        percentile: Option<&'static u8>,\n    },\n    DistinctCount {\n        field: R,\n        alias: Option<&'static str>,\n    },\n}\n\n// Window functions in query\n// ---\n// Description -\n// field: to_sql type value used as expr in aggregation\n// partition_by: partition by fields in window\n// order_by: order by fields and order (Ascending / Descending) in window\n// alias: alias of window expr in query\n// ---\n// Usage -\n// Window::Sum {\n//     field: \"count\",\n//     partition_by: Some(query_builder.transform_to_sql_values(&dimensions).switch()?),\n//     order_by: Some((\"value\", Descending)),\n//     alias: Some(\"total\"),\n// }\n#[derive(Debug)]", "function_name": "Aggregate", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Analytics Aggregate Enum"}, {"query": "rust Aggregate enum Percentile distinctcount", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Aggregate\npub enum Aggregate<R> {\n    Count {\n        field: Option<R>,\n        alias: Option<&'static str>,\n    },\n    Sum {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Min {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Max {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Percentile {\n        field: R,\n        alias: Option<&'static str>,\n        percentile: Option<&'static u8>,\n    },\n    DistinctCount {\n        field: R,\n        alias: Option<&'static str>,\n    },\n}\n\n// Window functions in query\n// ---\n// Description -\n// field: to_sql type value used as expr in aggregation\n// partition_by: partition by fields in window\n// order_by: order by fields and order (Ascending / Descending) in window\n// alias: alias of window expr in query\n// ---\n// Usage -\n// Window::Sum {\n//     field: \"count\",\n//     partition_by: Some(query_builder.transform_to_sql_values(&dimensions).switch()?),\n//     order_by: Some((\"value\", Descending)),\n//     alias: Some(\"total\"),\n// }\n#[derive(Debug)]", "function_name": "Aggregate", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Analytics Aggregate Enum"}, {"query": "hyperswitch analytics crate query.rs Aggregate", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Aggregate\npub enum Aggregate<R> {\n    Count {\n        field: Option<R>,\n        alias: Option<&'static str>,\n    },\n    Sum {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Min {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Max {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Percentile {\n        field: R,\n        alias: Option<&'static str>,\n        percentile: Option<&'static u8>,\n    },\n    DistinctCount {\n        field: R,\n        alias: Option<&'static str>,\n    },\n}\n\n// Window functions in query\n// ---\n// Description -\n// field: to_sql type value used as expr in aggregation\n// partition_by: partition by fields in window\n// order_by: order by fields and order (Ascending / Descending) in window\n// alias: alias of window expr in query\n// ---\n// Usage -\n// Window::Sum {\n//     field: \"count\",\n//     partition_by: Some(query_builder.transform_to_sql_values(&dimensions).switch()?),\n//     order_by: Some((\"value\", Descending)),\n//     alias: Some(\"total\"),\n// }\n#[derive(Debug)]", "function_name": "Aggregate", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Analytics Aggregate Enum"}, {"query": "How do I access the metadata returned by the payment connector in the response object?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_metadata\n    pub fn get_connector_metadata(&self) -> Option<masking::Secret<serde_json::Value>> {\n        match self {\n            Self::TransactionResponse {\n                connector_metadata, ..\n            }\n            | Self::PreProcessingResponse {\n                connector_metadata, ..\n            } => connector_metadata.clone().map(masking::Secret::new),\n            _ => None,\n        }\n    }", "function_name": "get_connector_metadata", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "connector metadata retrieval"}, {"query": "rust hyperswitch get_connector_metadata function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_metadata\n    pub fn get_connector_metadata(&self) -> Option<masking::Secret<serde_json::Value>> {\n        match self {\n            Self::TransactionResponse {\n                connector_metadata, ..\n            }\n            | Self::PreProcessingResponse {\n                connector_metadata, ..\n            } => connector_metadata.clone().map(masking::Secret::new),\n            _ => None,\n        }\n    }", "function_name": "get_connector_metadata", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "connector metadata retrieval"}, {"query": "How to retrieve connector metadata from TransactionResponse struct in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_metadata\n    pub fn get_connector_metadata(&self) -> Option<masking::Secret<serde_json::Value>> {\n        match self {\n            Self::TransactionResponse {\n                connector_metadata, ..\n            }\n            | Self::PreProcessingResponse {\n                connector_metadata, ..\n            } => connector_metadata.clone().map(masking::Secret::new),\n            _ => None,\n        }\n    }", "function_name": "get_connector_metadata", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "connector metadata retrieval"}, {"query": "Where is the connector metadata field defined in the router response types?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_metadata\n    pub fn get_connector_metadata(&self) -> Option<masking::Secret<serde_json::Value>> {\n        match self {\n            Self::TransactionResponse {\n                connector_metadata, ..\n            }\n            | Self::PreProcessingResponse {\n                connector_metadata, ..\n            } => connector_metadata.clone().map(masking::Secret::new),\n            _ => None,\n        }\n    }", "function_name": "get_connector_metadata", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "connector metadata retrieval"}, {"query": "rust hyperswitch cybersource handle_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: cybersource::CybersourcePaymentsResponse = res\n            .response\n            .parse_struct(\"CybersourceSetupMandatesResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource Setup Mandate Response Handler"}, {"query": "how to parse cybersource setup mandate response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: cybersource::CybersourcePaymentsResponse = res\n            .response\n            .parse_struct(\"CybersourceSetupMandatesResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource Setup Mandate Response Handler"}, {"query": "hyperswitch connector cybersource handle_response deserialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: cybersource::CybersourcePaymentsResponse = res\n            .response\n            .parse_struct(\"CybersourceSetupMandatesResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource Setup Mandate Response Handler"}, {"query": "cybersource setup mandate router data hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: cybersource::CybersourcePaymentsResponse = res\n            .response\n            .parse_struct(\"CybersourceSetupMandatesResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource Setup Mandate Response Handler"}, {"query": "how to implement get_webhook_event_type in Payone connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone webhook event type extraction"}, {"query": "Payone connector webhook event type extraction error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone webhook event type extraction"}, {"query": "incoming webhook event type parsing Payone Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone webhook event type extraction"}, {"query": "hyperswitch Payone connector webhook support", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone webhook event type extraction"}, {"query": "how to decide execution path for direct connector in shadow mode", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: decide_execution_path\nfn decide_execution_path(\n    connector_type: ConnectorIntegrationType,\n    previous_gateway: Option<GatewaySystem>,\n    execution_mode: ExecutionMode,\n) -> RouterResult<(GatewaySystem, ExecutionPath)> {\n    match connector_type {\n        // UCS-only connectors always use UCS\n        ConnectorIntegrationType::UcsConnector => Ok((\n            GatewaySystem::UnifiedConnectorService,\n            ExecutionPath::UnifiedConnectorService,\n        )),\n        ConnectorIntegrationType::DirectandUCSConnector => {\n            match (previous_gateway, execution_mode) {\n                (Some(GatewaySystem::Direct), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Primary) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Shadow) => {\n                    // Previous gateway was Direct, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was UCS, continue using Direct as the config key has notapplicable execution mode\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Primary) => {\n                    // previous gateway was UCS, and config key has execution mode primary - continue using UCS\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Shadow) => {\n                    // previous gateway was UCS, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                \n\n... [truncated 2 chars] ...\n\n  ))\n                }\n                (None, ExecutionMode::Primary) => {\n                    // Fresh payment for a UCS-enabled connector - use UCS as primary\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::Shadow) => {\n                    // Fresh payment for UCS-enabled connector with shadow mode - use shadow UCS\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::NotApplicable) => {\n                    // Fresh payment request for direct connector - use direct gateway\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n            }\n        }\n    }\n}\n\n/// Build rollout keys based on flow type - include payment method for payments, skip for refunds", "function_name": "decide_execution_path", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "routing logic execution path"}, {"query": "rust function decide_execution_path gateway system", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: decide_execution_path\nfn decide_execution_path(\n    connector_type: ConnectorIntegrationType,\n    previous_gateway: Option<GatewaySystem>,\n    execution_mode: ExecutionMode,\n) -> RouterResult<(GatewaySystem, ExecutionPath)> {\n    match connector_type {\n        // UCS-only connectors always use UCS\n        ConnectorIntegrationType::UcsConnector => Ok((\n            GatewaySystem::UnifiedConnectorService,\n            ExecutionPath::UnifiedConnectorService,\n        )),\n        ConnectorIntegrationType::DirectandUCSConnector => {\n            match (previous_gateway, execution_mode) {\n                (Some(GatewaySystem::Direct), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Primary) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Shadow) => {\n                    // Previous gateway was Direct, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was UCS, continue using Direct as the config key has notapplicable execution mode\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Primary) => {\n                    // previous gateway was UCS, and config key has execution mode primary - continue using UCS\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Shadow) => {\n                    // previous gateway was UCS, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                \n\n... [truncated 2 chars] ...\n\n  ))\n                }\n                (None, ExecutionMode::Primary) => {\n                    // Fresh payment for a UCS-enabled connector - use UCS as primary\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::Shadow) => {\n                    // Fresh payment for UCS-enabled connector with shadow mode - use shadow UCS\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::NotApplicable) => {\n                    // Fresh payment request for direct connector - use direct gateway\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n            }\n        }\n    }\n}\n\n/// Build rollout keys based on flow type - include payment method for payments, skip for refunds", "function_name": "decide_execution_path", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "routing logic execution path"}, {"query": "hyperswitch routing logic direct vs ucs connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: decide_execution_path\nfn decide_execution_path(\n    connector_type: ConnectorIntegrationType,\n    previous_gateway: Option<GatewaySystem>,\n    execution_mode: ExecutionMode,\n) -> RouterResult<(GatewaySystem, ExecutionPath)> {\n    match connector_type {\n        // UCS-only connectors always use UCS\n        ConnectorIntegrationType::UcsConnector => Ok((\n            GatewaySystem::UnifiedConnectorService,\n            ExecutionPath::UnifiedConnectorService,\n        )),\n        ConnectorIntegrationType::DirectandUCSConnector => {\n            match (previous_gateway, execution_mode) {\n                (Some(GatewaySystem::Direct), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Primary) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Shadow) => {\n                    // Previous gateway was Direct, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was UCS, continue using Direct as the config key has notapplicable execution mode\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Primary) => {\n                    // previous gateway was UCS, and config key has execution mode primary - continue using UCS\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Shadow) => {\n                    // previous gateway was UCS, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                \n\n... [truncated 2 chars] ...\n\n  ))\n                }\n                (None, ExecutionMode::Primary) => {\n                    // Fresh payment for a UCS-enabled connector - use UCS as primary\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::Shadow) => {\n                    // Fresh payment for UCS-enabled connector with shadow mode - use shadow UCS\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::NotApplicable) => {\n                    // Fresh payment request for direct connector - use direct gateway\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n            }\n        }\n    }\n}\n\n/// Build rollout keys based on flow type - include payment method for payments, skip for refunds", "function_name": "decide_execution_path", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "routing logic execution path"}, {"query": "execution_mode shadow previous gateway direct", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: decide_execution_path\nfn decide_execution_path(\n    connector_type: ConnectorIntegrationType,\n    previous_gateway: Option<GatewaySystem>,\n    execution_mode: ExecutionMode,\n) -> RouterResult<(GatewaySystem, ExecutionPath)> {\n    match connector_type {\n        // UCS-only connectors always use UCS\n        ConnectorIntegrationType::UcsConnector => Ok((\n            GatewaySystem::UnifiedConnectorService,\n            ExecutionPath::UnifiedConnectorService,\n        )),\n        ConnectorIntegrationType::DirectandUCSConnector => {\n            match (previous_gateway, execution_mode) {\n                (Some(GatewaySystem::Direct), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Primary) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Shadow) => {\n                    // Previous gateway was Direct, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was UCS, continue using Direct as the config key has notapplicable execution mode\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Primary) => {\n                    // previous gateway was UCS, and config key has execution mode primary - continue using UCS\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Shadow) => {\n                    // previous gateway was UCS, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                \n\n... [truncated 2 chars] ...\n\n  ))\n                }\n                (None, ExecutionMode::Primary) => {\n                    // Fresh payment for a UCS-enabled connector - use UCS as primary\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::Shadow) => {\n                    // Fresh payment for UCS-enabled connector with shadow mode - use shadow UCS\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::NotApplicable) => {\n                    // Fresh payment request for direct connector - use direct gateway\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n            }\n        }\n    }\n}\n\n/// Build rollout keys based on flow type - include payment method for payments, skip for refunds", "function_name": "decide_execution_path", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "routing logic execution path"}, {"query": "Authipay connector integration implementation rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Authipay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Authipay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector integration stub"}, {"query": "hyperswitch Authipay payment method tokenization not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Authipay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Authipay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector integration stub"}, {"query": "Authipay connector trait definition rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Authipay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Authipay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector integration stub"}, {"query": "hyperswitch Authipay refund implementation stub", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Authipay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Authipay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector integration stub"}, {"query": "how to configure authorization header for juspay 3ds connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = juspaythreedsserver::JuspaythreedsserverAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Authorization Header"}, {"query": "rust function to get authorization header for juspaythreedsserver", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = juspaythreedsserver::JuspaythreedsserverAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Authorization Header"}, {"query": "juspaythreedsserver get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = juspaythreedsserver::JuspaythreedsserverAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Authorization Header"}, {"query": "hyperswitch juspay 3ds authentication header generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = juspaythreedsserver::JuspaythreedsserverAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Authorization Header"}, {"query": "How to configure Finix payment instrument URL in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &RouterData<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/payment_instruments\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Payment Instrument URL"}, {"query": "hyperswitch finix connector get_url implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &RouterData<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/payment_instruments\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Payment Instrument URL"}, {"query": "finix payment_instruments endpoint hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &RouterData<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/payment_instruments\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Payment Instrument URL"}, {"query": "hyperswitch finix base_url payment_instruments", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &RouterData<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/payment_instruments\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Payment Instrument URL"}, {"query": "rust hyperswitch router find refund by merchant id connector refund id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_refund_id_connector\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n", "function_name": "find_refund_by_merchant_id_connector_refund_id_connector", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "refund db lookup by connector id"}, {"query": "hyperswitch db query get refund details using connector refund id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_refund_id_connector\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n", "function_name": "find_refund_by_merchant_id_connector_refund_id_connector", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "refund db lookup by connector id"}, {"query": "how to query refund table by merchant and connector in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_refund_id_connector\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n", "function_name": "find_refund_by_merchant_id_connector_refund_id_connector", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "refund db lookup by connector id"}, {"query": "rust function find_refund_by_merchant_id_connector_refund_id_connector implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_refund_id_connector\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n", "function_name": "find_refund_by_merchant_id_connector_refund_id_connector", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "refund db lookup by connector id"}, {"query": "Worldpay Modular refund response struct Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpayModularRefundResponse\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpayModularRefundResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Refund Response Struct"}, {"query": "hyperswitch WorldpayModularRefundResponse payment_id links", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpayModularRefundResponse\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpayModularRefundResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Refund Response Struct"}, {"query": "Worldpay Modular API refund response parsing Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpayModularRefundResponse\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpayModularRefundResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Refund Response Struct"}, {"query": "WorldpayModularRefundResponse struct definition hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpayModularRefundResponse\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpayModularRefundResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular Refund Response Struct"}, {"query": "rust hyperswitch worldline connector build_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline auth header builder"}, {"query": "how to generate authorization token for worldline payment gateway in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline auth header builder"}, {"query": "hyperswitch worldline connector header generation logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline auth header builder"}, {"query": "rust function build_headers worldline hyperswitch connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline auth header builder"}, {"query": "rust hyperswitch find_merchant_connector_account_by_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_id\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account retrieval"}, {"query": "how to get merchant connector account details by id in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_id\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account retrieval"}, {"query": "hyperswitch storage layer merchant connector account lookup function", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_id\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account retrieval"}, {"query": "rust code for retrieving merchant connector account configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_id\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account retrieval"}, {"query": "how to build authorize request for thunes connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes authorize request builder"}, {"query": "rust function build_request thunes payments authorize", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes authorize request builder"}, {"query": "thunes connector request builder implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes authorize request builder"}, {"query": "PaymentsAuthorizeType get_url thunes connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes authorize request builder"}, {"query": "Helcim connector integration implementation Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim connector integration stub"}, {"query": "hyperswitch Helcim tokenize_payment_method method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim connector integration stub"}, {"query": "Helcim payments response data types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim connector integration stub"}, {"query": "Rust connector integration trait Helcim", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim connector integration stub"}, {"query": "Rust enum for connector authentication types hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: ConnectorAuthType\npub enum ConnectorAuthType {\n    TemporaryAuth,\n    HeaderKey {\n        api_key: Secret<String>,\n    },\n    BodyKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n    },\n    SignatureKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n    },\n    MultiAuthKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n        key2: Secret<String>,\n    },\n    CurrencyAuthKey {\n        auth_key_map: HashMap<common_enums::enums::Currency, common_utils::pii::SecretSerdeValue>,\n    },\n    CertificateAuth {\n        certificate: Secret<String>,\n        private_key: Secret<String>,\n    },\n    #[default]\n    NoKey,\n}\n", "function_name": "ConnectorAuthType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType definition"}, {"query": "how to implement connector auth type in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: ConnectorAuthType\npub enum ConnectorAuthType {\n    TemporaryAuth,\n    HeaderKey {\n        api_key: Secret<String>,\n    },\n    BodyKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n    },\n    SignatureKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n    },\n    MultiAuthKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n        key2: Secret<String>,\n    },\n    CurrencyAuthKey {\n        auth_key_map: HashMap<common_enums::enums::Currency, common_utils::pii::SecretSerdeValue>,\n    },\n    CertificateAuth {\n        certificate: Secret<String>,\n        private_key: Secret<String>,\n    },\n    #[default]\n    NoKey,\n}\n", "function_name": "ConnectorAuthType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType definition"}, {"query": "hyperswitch domain models connector auth type definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: ConnectorAuthType\npub enum ConnectorAuthType {\n    TemporaryAuth,\n    HeaderKey {\n        api_key: Secret<String>,\n    },\n    BodyKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n    },\n    SignatureKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n    },\n    MultiAuthKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n        key2: Secret<String>,\n    },\n    CurrencyAuthKey {\n        auth_key_map: HashMap<common_enums::enums::Currency, common_utils::pii::SecretSerdeValue>,\n    },\n    CertificateAuth {\n        certificate: Secret<String>,\n        private_key: Secret<String>,\n    },\n    #[default]\n    NoKey,\n}\n", "function_name": "ConnectorAuthType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType definition"}, {"query": "rust enum for payment gateway api key authentication hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: ConnectorAuthType\npub enum ConnectorAuthType {\n    TemporaryAuth,\n    HeaderKey {\n        api_key: Secret<String>,\n    },\n    BodyKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n    },\n    SignatureKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n    },\n    MultiAuthKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n        key2: Secret<String>,\n    },\n    CurrencyAuthKey {\n        auth_key_map: HashMap<common_enums::enums::Currency, common_utils::pii::SecretSerdeValue>,\n    },\n    CertificateAuth {\n        certificate: Secret<String>,\n        private_key: Secret<String>,\n    },\n    #[default]\n    NoKey,\n}\n", "function_name": "ConnectorAuthType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType definition"}, {"query": "how to find merchant connector account by merchant id and connector name", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_name\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "function_name": "find_merchant_connector_account_by_merchant_id_connector_name", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "rust hyperswitch find_merchant_connector_account_by_merchant_id_connector_name implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_name\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "function_name": "find_merchant_connector_account_by_merchant_id_connector_name", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "hyperswitch storage_impl merchant connector account lookup", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_name\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "function_name": "find_merchant_connector_account_by_merchant_id_connector_name", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "merchant connector account retrieval function signature rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_name\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "function_name": "find_merchant_connector_account_by_merchant_id_connector_name", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "how to handle boku connector errors in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "boku connector error handler"}, {"query": "boku connector error response format hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "boku connector error handler"}, {"query": "hyperswitch boku get_error_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "boku connector error handler"}, {"query": "custom error handling for boku payment gateway hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "boku connector error handler"}, {"query": "How to convert Signifyd payment status to Hyperswitch fraud status", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: from\n    fn from(item: SignifydPaymentStatus) -> Self {\n        match item {\n            SignifydPaymentStatus::Accept => Self::Legit,\n            SignifydPaymentStatus::Reject => Self::Fraud,\n            SignifydPaymentStatus::Hold => Self::ManualReview,\n            SignifydPaymentStatus::Challenge | SignifydPaymentStatus::Credit => Self::Pending,\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud status mapper"}, {"query": "Signifyd fraud status mapping function rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: from\n    fn from(item: SignifydPaymentStatus) -> Self {\n        match item {\n            SignifydPaymentStatus::Accept => Self::Legit,\n            SignifydPaymentStatus::Reject => Self::Fraud,\n            SignifydPaymentStatus::Hold => Self::ManualReview,\n            SignifydPaymentStatus::Challenge | SignifydPaymentStatus::Credit => Self::Pending,\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud status mapper"}, {"query": "transform Signifyd payment status to internal fraud enum", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: from\n    fn from(item: SignifydPaymentStatus) -> Self {\n        match item {\n            SignifydPaymentStatus::Accept => Self::Legit,\n            SignifydPaymentStatus::Reject => Self::Fraud,\n            SignifydPaymentStatus::Hold => Self::ManualReview,\n            SignifydPaymentStatus::Challenge | SignifydPaymentStatus::Credit => Self::Pending,\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud status mapper"}, {"query": "hyperswitch signifyd fraud status mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: from\n    fn from(item: SignifydPaymentStatus) -> Self {\n        match item {\n            SignifydPaymentStatus::Accept => Self::Legit,\n            SignifydPaymentStatus::Reject => Self::Fraud,\n            SignifydPaymentStatus::Hold => Self::ManualReview,\n            SignifydPaymentStatus::Challenge | SignifydPaymentStatus::Credit => Self::Pending,\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud status mapper"}, {"query": "rust convert Email newtype to string", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: foreign_from\n    fn foreign_from(email: Email) -> Self {\n        let email_value: String = email.expose().peek().to_owned();\n        Self::from(email_value)\n    }\n}\n\n/// Masked Phone Number\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "function_name": "foreign_from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Email newtype conversion utility"}, {"query": "how to extract value from Email type in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: foreign_from\n    fn foreign_from(email: Email) -> Self {\n        let email_value: String = email.expose().peek().to_owned();\n        Self::from(email_value)\n    }\n}\n\n/// Masked Phone Number\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "function_name": "foreign_from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Email newtype conversion utility"}, {"query": "Email expose peek rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: foreign_from\n    fn foreign_from(email: Email) -> Self {\n        let email_value: String = email.expose().peek().to_owned();\n        Self::from(email_value)\n    }\n}\n\n/// Masked Phone Number\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "function_name": "foreign_from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Email newtype conversion utility"}, {"query": "hyperswitch common_utils foreign_from function", "code": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: foreign_from\n    fn foreign_from(email: Email) -> Self {\n        let email_value: String = email.expose().peek().to_owned();\n        Self::from(email_value)\n    }\n}\n\n/// Masked Phone Number\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "function_name": "foreign_from", "file": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "unit_type": "function", "label": "Email newtype conversion utility"}, {"query": "Rust hyperswitch worldline connector get_url function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsCancelRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let auth: worldline::WorldlineAuthType =\n            worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account_id = auth.merchant_account_id.expose();\n        let payment_id = &req.request.connector_transaction_id;\n        Ok(format!(\n            \"{base_url}v1/{merchant_account_id}/payments/{payment_id}/cancel\",\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline payment cancel URL builder"}, {"query": "how to construct worldline payment cancel url hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsCancelRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let auth: worldline::WorldlineAuthType =\n            worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account_id = auth.merchant_account_id.expose();\n        let payment_id = &req.request.connector_transaction_id;\n        Ok(format!(\n            \"{base_url}v1/{merchant_account_id}/payments/{payment_id}/cancel\",\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline payment cancel URL builder"}, {"query": "hyperswitch worldline connector get_url method source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsCancelRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let auth: worldline::WorldlineAuthType =\n            worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account_id = auth.merchant_account_id.expose();\n        let payment_id = &req.request.connector_transaction_id;\n        Ok(format!(\n            \"{base_url}v1/{merchant_account_id}/payments/{payment_id}/cancel\",\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline payment cancel URL builder"}, {"query": "worldline payment cancellation url generation hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsCancelRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let auth: worldline::WorldlineAuthType =\n            worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account_id = auth.merchant_account_id.expose();\n        let payment_id = &req.request.connector_transaction_id;\n        Ok(format!(\n            \"{base_url}v1/{merchant_account_id}/payments/{payment_id}/cancel\",\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline payment cancel URL builder"}, {"query": "how to filter analytics results by date range in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_filter_clause\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()> {\n        builder.add_custom_filter_clause(\"created_at\", self.start_time, FilterTypes::Gte)?;\n        if let Some(end) = self.end_time {\n            builder.add_custom_filter_clause(\"created_at\", end, FilterTypes::Lte)?;\n        }\n        Ok(())\n    }\n}\n", "function_name": "set_filter_clause", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "analytics time range filter"}, {"query": "rust function to add created_at timestamp filter to query builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_filter_clause\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()> {\n        builder.add_custom_filter_clause(\"created_at\", self.start_time, FilterTypes::Gte)?;\n        if let Some(end) = self.end_time {\n            builder.add_custom_filter_clause(\"created_at\", end, FilterTypes::Lte)?;\n        }\n        Ok(())\n    }\n}\n", "function_name": "set_filter_clause", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "analytics time range filter"}, {"query": "hyperswitch analytics crate set_filter_clause implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_filter_clause\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()> {\n        builder.add_custom_filter_clause(\"created_at\", self.start_time, FilterTypes::Gte)?;\n        if let Some(end) = self.end_time {\n            builder.add_custom_filter_clause(\"created_at\", end, FilterTypes::Lte)?;\n        }\n        Ok(())\n    }\n}\n", "function_name": "set_filter_clause", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "analytics time range filter"}, {"query": "how does set_filter_clause work in hyperswitch analytics", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_filter_clause\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()> {\n        builder.add_custom_filter_clause(\"created_at\", self.start_time, FilterTypes::Gte)?;\n        if let Some(end) = self.end_time {\n            builder.add_custom_filter_clause(\"created_at\", end, FilterTypes::Lte)?;\n        }\n        Ok(())\n    }\n}\n", "function_name": "set_filter_clause", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "analytics time range filter"}, {"query": "how to handle redsys error response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: redsys::RedsysErrorResponse = res\n            .response\n            .parse_struct(\"RedsysErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code.clone(),\n            message: response.error_code.clone(),\n            reason: Some(response.error_code.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys error response builder"}, {"query": "build_error_response function implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: redsys::RedsysErrorResponse = res\n            .response\n            .parse_struct(\"RedsysErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code.clone(),\n            message: response.error_code.clone(),\n            reason: Some(response.error_code.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys error response builder"}, {"query": "redsys connector error handling hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: redsys::RedsysErrorResponse = res\n            .response\n            .parse_struct(\"RedsysErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code.clone(),\n            message: response.error_code.clone(),\n            reason: Some(response.error_code.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys error response builder"}, {"query": "parse redsys error response hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: redsys::RedsysErrorResponse = res\n            .response\n            .parse_struct(\"RedsysErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code.clone(),\n            message: response.error_code.clone(),\n            reason: Some(response.error_code.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys error response builder"}, {"query": "how to save payment method and mandate after authorization hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: save_pm_and_mandate\n    async fn save_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsAuthorizeData, types::PaymentsResponseData>,\n        platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        business_profile: &domain::Profile,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        todo!()\n    }\n\n    #[cfg(feature = \"v1\")]", "function_name": "save_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Method Persistence"}, {"query": "hyperswitch router save_pm_and_mandate function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: save_pm_and_mandate\n    async fn save_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsAuthorizeData, types::PaymentsResponseData>,\n        platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        business_profile: &domain::Profile,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        todo!()\n    }\n\n    #[cfg(feature = \"v1\")]", "function_name": "save_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Method Persistence"}, {"query": "rust hyperswitch payment operations save_pm_and_mandate", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: save_pm_and_mandate\n    async fn save_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsAuthorizeData, types::PaymentsResponseData>,\n        platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        business_profile: &domain::Profile,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        todo!()\n    }\n\n    #[cfg(feature = \"v1\")]", "function_name": "save_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Method Persistence"}, {"query": "hyperswitch database insert payment method mandate authorization", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: save_pm_and_mandate\n    async fn save_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsAuthorizeData, types::PaymentsResponseData>,\n        platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        business_profile: &domain::Profile,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        todo!()\n    }\n\n    #[cfg(feature = \"v1\")]", "function_name": "save_pm_and_mandate", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Method Persistence"}, {"query": "how to handle gpayments error response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: gpayments_types::TDS2ApiError = res\n            .response\n            .parse_struct(\"gpayments_types TDS2ApiError\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code,\n            message: response.error_description,\n            reason: response.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "G-Payments Error Response Builder"}, {"query": "build_error_response function implementation rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: gpayments_types::TDS2ApiError = res\n            .response\n            .parse_struct(\"gpayments_types TDS2ApiError\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code,\n            message: response.error_description,\n            reason: response.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "G-Payments Error Response Builder"}, {"query": "parse gpayments TDS2ApiError into ErrorResponse", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: gpayments_types::TDS2ApiError = res\n            .response\n            .parse_struct(\"gpayments_types TDS2ApiError\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code,\n            message: response.error_description,\n            reason: response.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "G-Payments Error Response Builder"}, {"query": "hyperswitch connector error handling gpayments", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: gpayments_types::TDS2ApiError = res\n            .response\n            .parse_struct(\"gpayments_types TDS2ApiError\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code,\n            message: response.error_description,\n            reason: response.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "G-Payments Error Response Builder"}, {"query": "Rust enum for payment transaction status in Hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionSyncStatus\npub enum TransactionSyncStatus {\n    PEN, // Pended\n    OPN, // Unpended / release / open\n    REV, // Review\n    STL, // Settled\n    PST, // Failed due to post-auth rule\n    FPR, // Failed due to fraud prevention rules\n    PRE, // Failed due to pre-auth rule\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "function_name": "TransactionSyncStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "TransactionSyncStatus enum definition"}, {"query": "Hyperswitch TransactionSyncStatus enum definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionSyncStatus\npub enum TransactionSyncStatus {\n    PEN, // Pended\n    OPN, // Unpended / release / open\n    REV, // Review\n    STL, // Settled\n    PST, // Failed due to post-auth rule\n    FPR, // Failed due to fraud prevention rules\n    PRE, // Failed due to pre-auth rule\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "function_name": "TransactionSyncStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "TransactionSyncStatus enum definition"}, {"query": "What does TransactionSyncStatus enum represent in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionSyncStatus\npub enum TransactionSyncStatus {\n    PEN, // Pended\n    OPN, // Unpended / release / open\n    REV, // Review\n    STL, // Settled\n    PST, // Failed due to post-auth rule\n    FPR, // Failed due to fraud prevention rules\n    PRE, // Failed due to pre-auth rule\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "function_name": "TransactionSyncStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "TransactionSyncStatus enum definition"}, {"query": "Hyperswitch payment orchestration transaction states", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionSyncStatus\npub enum TransactionSyncStatus {\n    PEN, // Pended\n    OPN, // Unpended / release / open\n    REV, // Review\n    STL, // Settled\n    PST, // Failed due to post-auth rule\n    FPR, // Failed due to fraud prevention rules\n    PRE, // Failed due to pre-auth rule\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "function_name": "TransactionSyncStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "TransactionSyncStatus enum definition"}, {"query": "how to transform payme payment response into hyperswitch payments response data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleResponse\npub struct GenerateSaleResponse {\n    payme_sale_id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, PaymePaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "function_name": "GenerateSaleResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe Payment Response Transformer"}, {"query": "payme connector generate sale response rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleResponse\npub struct GenerateSaleResponse {\n    payme_sale_id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, PaymePaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "function_name": "GenerateSaleResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe Payment Response Transformer"}, {"query": "hyperswitch payme payments response data mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleResponse\npub struct GenerateSaleResponse {\n    payme_sale_id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, PaymePaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "function_name": "GenerateSaleResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe Payment Response Transformer"}, {"query": "rust tryfrom implementation for payme payments response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleResponse\npub struct GenerateSaleResponse {\n    payme_sale_id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, PaymePaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "function_name": "GenerateSaleResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe Payment Response Transformer"}, {"query": "rust hyperswitch juspay three ds server connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server header builder"}, {"query": "how to configure headers for juspay three ds server in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server header builder"}, {"query": "hyperswitch juspaythreedsserver get_headers function source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server header builder"}, {"query": "juspay three ds server connector rust hyperswitch build_headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server header builder"}, {"query": "how to handle airwallex connector errors in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex error handling"}, {"query": "airwallex error response format hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex error handling"}, {"query": "hyperswitch connector error handling get_error_response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex error handling"}, {"query": "airwallex connector error webhook hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex error handling"}, {"query": "how to handle gpayments authentication response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorAuthenticationRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorAuthenticationRouterData, ConnectorError> {\n        let response: gpayments_types::GpaymentsAuthenticationSuccessResponse = res\n            .response\n            .parse_struct(\"gpayments GpaymentsAuthenticationResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth response handler"}, {"query": "rust hyperswitch gpayments connector handle_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorAuthenticationRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorAuthenticationRouterData, ConnectorError> {\n        let response: gpayments_types::GpaymentsAuthenticationSuccessResponse = res\n            .response\n            .parse_struct(\"gpayments GpaymentsAuthenticationResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth response handler"}, {"query": "gpayments authentication success response parsing hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorAuthenticationRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorAuthenticationRouterData, ConnectorError> {\n        let response: gpayments_types::GpaymentsAuthenticationSuccessResponse = res\n            .response\n            .parse_struct(\"gpayments GpaymentsAuthenticationResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth response handler"}, {"query": "hyperswitch gpayments router data deserialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorAuthenticationRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorAuthenticationRouterData, ConnectorError> {\n        let response: gpayments_types::GpaymentsAuthenticationSuccessResponse = res\n            .response\n            .parse_struct(\"gpayments GpaymentsAuthenticationResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments auth response handler"}, {"query": "how to configure Powertranz auto capture endpoint in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let mut endpoint = match req.request.is_auto_capture()? {\n            true => \"sale\",\n            false => \"auth\",\n        }\n        .to_string();\n        // 3ds payments uses different endpoints\n        if req.auth_type == AuthenticationType::ThreeDs {\n            endpoint.insert_str(0, \"spi/\")\n        };\n        Ok(format!(\"{}{endpoint}\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz URL construction"}, {"query": "hyperswitch powertranz 3ds spi endpoint url construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let mut endpoint = match req.request.is_auto_capture()? {\n            true => \"sale\",\n            false => \"auth\",\n        }\n        .to_string();\n        // 3ds payments uses different endpoints\n        if req.auth_type == AuthenticationType::ThreeDs {\n            endpoint.insert_str(0, \"spi/\")\n        };\n        Ok(format!(\"{}{endpoint}\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz URL construction"}, {"query": "rust hyperswitch powertranz connector get_url implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let mut endpoint = match req.request.is_auto_capture()? {\n            true => \"sale\",\n            false => \"auth\",\n        }\n        .to_string();\n        // 3ds payments uses different endpoints\n        if req.auth_type == AuthenticationType::ThreeDs {\n            endpoint.insert_str(0, \"spi/\")\n        };\n        Ok(format!(\"{}{endpoint}\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz URL construction"}, {"query": "hyperswitch powertranz payment method sale vs auth endpoint", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let mut endpoint = match req.request.is_auto_capture()? {\n            true => \"sale\",\n            false => \"auth\",\n        }\n        .to_string();\n        // 3ds payments uses different endpoints\n        if req.auth_type == AuthenticationType::ThreeDs {\n            endpoint.insert_str(0, \"spi/\")\n        };\n        Ok(format!(\"{}{endpoint}\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz URL construction"}, {"query": "how to configure tokenex authentication headers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                auth_headers::TOKENEX_ID.to_string(),\n                auth.tokenex_id.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_API_KEY.to_string(),\n                auth.api_key.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_SCHEME.to_string(),\n                auth_headers::TOKENEX_SCHEME_VALUE.to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "tokenex connector auth header builder"}, {"query": "rust function to build tokenex api request headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                auth_headers::TOKENEX_ID.to_string(),\n                auth.tokenex_id.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_API_KEY.to_string(),\n                auth.api_key.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_SCHEME.to_string(),\n                auth_headers::TOKENEX_SCHEME_VALUE.to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "tokenex connector auth header builder"}, {"query": "hyperswitch tokenex connector build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                auth_headers::TOKENEX_ID.to_string(),\n                auth.tokenex_id.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_API_KEY.to_string(),\n                auth.api_key.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_SCHEME.to_string(),\n                auth_headers::TOKENEX_SCHEME_VALUE.to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "tokenex connector auth header builder"}, {"query": "tokenex hyperswitch authentication header setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                auth_headers::TOKENEX_ID.to_string(),\n                auth.tokenex_id.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_API_KEY.to_string(),\n                auth.api_key.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_SCHEME.to_string(),\n                auth_headers::TOKENEX_SCHEME_VALUE.to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "tokenex connector auth header builder"}, {"query": "How to filter payment intents by status in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intent_by_constraints\n    async fn filter_payment_intent_by_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        filters: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_payment_intent_by_constraints", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment Intent Filtering"}, {"query": "Rust hyperswitch filter_payment_intent_by_constraints implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intent_by_constraints\n    async fn filter_payment_intent_by_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        filters: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_payment_intent_by_constraints", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment Intent Filtering"}, {"query": "Query payment intents by merchant ID and constraints", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intent_by_constraints\n    async fn filter_payment_intent_by_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        filters: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_payment_intent_by_constraints", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment Intent Filtering"}, {"query": "Hyperswitch domain models filter payment intents function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intent_by_constraints\n    async fn filter_payment_intent_by_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        filters: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_payment_intent_by_constraints", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment Intent Filtering"}, {"query": "how to handle graph analysis errors in rust dsa module", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: assertion_from_graph_error\n    fn assertion_from_graph_error(metadata: &Metadata, graph_error: cgraph::GraphError<V>) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::AssertionTrace {\n                trace,\n                metadata: metadata.clone(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n", "function_name": "assertion_from_graph_error", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Graph error type conversion"}, {"query": "rust assertion_from_graph_error function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: assertion_from_graph_error\n    fn assertion_from_graph_error(metadata: &Metadata, graph_error: cgraph::GraphError<V>) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::AssertionTrace {\n                trace,\n                metadata: metadata.clone(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n", "function_name": "assertion_from_graph_error", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Graph error type conversion"}, {"query": "convert cgraph GraphError to assertion trace", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: assertion_from_graph_error\n    fn assertion_from_graph_error(metadata: &Metadata, graph_error: cgraph::GraphError<V>) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::AssertionTrace {\n                trace,\n                metadata: metadata.clone(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n", "function_name": "assertion_from_graph_error", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Graph error type conversion"}, {"query": "hyperswitch dsa graph error handling metadata", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: assertion_from_graph_error\n    fn assertion_from_graph_error(metadata: &Metadata, graph_error: cgraph::GraphError<V>) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::AssertionTrace {\n                trace,\n                metadata: metadata.clone(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n", "function_name": "assertion_from_graph_error", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Graph error type conversion"}, {"query": "rust hyperswitch zift connector build_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )])\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector header builder"}, {"query": "how to set content type header in hyperswitch zift connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )])\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector header builder"}, {"query": "hyperswitch zift connector rust source code build_headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )])\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector header builder"}, {"query": "zift payment gateway connector hyperswitch rust header configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )])\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector header builder"}, {"query": "rust hyperswitch powertranz connector error response builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        // For error scenarios connector respond with 200 http status code and error response object in response\n        // For http status code other than 200 they send empty response back\n        event_builder.map(|i: &mut ConnectorEvent| i.set_error_response_body(&serde_json::json!({\"error_response\": std::str::from_utf8(&res.response).unwrap_or(\"\")})));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "PowerTranz error response builder"}, {"query": "how to handle connector error status codes in hyperswitch powertranz", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        // For error scenarios connector respond with 200 http status code and error response object in response\n        // For http status code other than 200 they send empty response back\n        event_builder.map(|i: &mut ConnectorEvent| i.set_error_response_body(&serde_json::json!({\"error_response\": std::str::from_utf8(&res.response).unwrap_or(\"\")})));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "PowerTranz error response builder"}, {"query": "hyperswitch powertranz build_error_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        // For error scenarios connector respond with 200 http status code and error response object in response\n        // For http status code other than 200 they send empty response back\n        event_builder.map(|i: &mut ConnectorEvent| i.set_error_response_body(&serde_json::json!({\"error_response\": std::str::from_utf8(&res.response).unwrap_or(\"\")})));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "PowerTranz error response builder"}, {"query": "rust hyperswitch powertranz connector 200 status error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        // For error scenarios connector respond with 200 http status code and error response object in response\n        // For http status code other than 200 they send empty response back\n        event_builder.map(|i: &mut ConnectorEvent| i.set_error_response_body(&serde_json::json!({\"error_response\": std::str::from_utf8(&res.response).unwrap_or(\"\")})));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "PowerTranz error response builder"}, {"query": "Rust struct definition for L2L3Data in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: L2L3Data\npub struct L2L3Data {\n    pub order_info: Option<OrderInfo>,\n    pub tax_info: Option<TaxInfo>,\n    pub customer_info: Option<CustomerInfo>,\n    pub shipping_details: Option<AddressDetails>,\n    pub billing_details: Option<BillingDetails>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "L2L3Data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Payment context data struct"}, {"query": "hyperswitch domain models L2L3Data struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: L2L3Data\npub struct L2L3Data {\n    pub order_info: Option<OrderInfo>,\n    pub tax_info: Option<TaxInfo>,\n    pub customer_info: Option<CustomerInfo>,\n    pub shipping_details: Option<AddressDetails>,\n    pub billing_details: Option<BillingDetails>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "L2L3Data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Payment context data struct"}, {"query": "how to define payment context data in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: L2L3Data\npub struct L2L3Data {\n    pub order_info: Option<OrderInfo>,\n    pub tax_info: Option<TaxInfo>,\n    pub customer_info: Option<CustomerInfo>,\n    pub shipping_details: Option<AddressDetails>,\n    pub billing_details: Option<BillingDetails>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "L2L3Data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Payment context data struct"}, {"query": "L2L3Data struct definition hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: L2L3Data\npub struct L2L3Data {\n    pub order_info: Option<OrderInfo>,\n    pub tax_info: Option<TaxInfo>,\n    pub customer_info: Option<CustomerInfo>,\n    pub shipping_details: Option<AddressDetails>,\n    pub billing_details: Option<BillingDetails>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "L2L3Data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Payment context data struct"}, {"query": "how to handle barclaycard connector errors in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard error handler"}, {"query": "barclaycard hyperswitch error response builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard error handler"}, {"query": "rust connector error handling hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard error handler"}, {"query": "hyperswitch barclaycard get_error_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard error handler"}, {"query": "how to convert business profile domain model to database profile", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: convert\n    async fn convert(self) -> CustomResult<Self::DstType, ValidationError> {\n        let (is_external_vault_enabled, external_vault_connector_details) =\n            self.external_vault_details.into();\n\n        Ok(diesel_models::business_profile::Profile {\n            profile_id: self.profile_id.clone(),\n            id: Some(self.profile_id),\n            merchant_id: self.merchant_id,\n            profile_name: self.profile_name,\n            created_at: self.created_at,\n            modified_at: self.modified_at,\n            return_url: self.return_url,\n            enable_payment_response_hash: self.enable_payment_response_hash,\n            payment_response_hash_key: self.payment_response_hash_key,\n            redirect_to_merchant_with_http_post: self.redirect_to_merchant_with_http_post,\n            webhook_details: self.webhook_details,\n            metadata: self.metadata,\n            routing_algorithm: self.routing_algorithm,\n            intent_fulfillment_time: self.intent_fulfillment_time,\n            frm_routing_algorithm: self.frm_routing_algorithm,\n            payout_routing_algorithm: self.payout_routing_algorithm,\n            is_recon_enabled: self.is_recon_enabled,\n            applepay_verified_domains: self.applepay_verified_domains,\n            payment_link_config: self.payment_link_config,\n            session_expiry: self.session_expiry,\n            authentication_connector_details: self.authentication_connector_details,\n            payout_link_config: self.payout_link_config,\n            is_extended_card_info_enabled: self.is_extended_card_info_enabled,\n            extended_card_info_config: self.extended_card_info_config,\n            is_connector_agnostic_mit_enabled: self.is_connector_agnostic_mit_enabled,\n            use_billing_as_payment_method_billing: self.use_billing_as_payment_method_billing,\n            collect_shipping_details_from_wallet_connector: self\n                .collect_shipping_details_from_wallet_connector,\n            collect_billing_details_from_wallet_connector: self\n                .collect_billing_details_from_wallet_connector,\n            outgoing_webhook_custom_http_headers: self\n                .outgoing_webhook_custom_http_headers\n                .map(Encryption::from),\n            always_collect_billing_details_from_wallet_connector: self\n                .always_collect_billing_details_from_wallet_connector,\n            always_collect_shipping_details_from_wallet_c\n\n... [truncated 1052 chars] ...\n\nclear_pan_retries_enabled,\n            force_3ds_challenge: Some(self.force_3ds_challenge),\n            is_debit_routing_enabled: self.is_debit_routing_enabled,\n            merchant_business_country: self.merchant_business_country,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            is_pre_network_tokenization_enabled: Some(self.is_pre_network_tokenization_enabled),\n            three_ds_decision_rule_algorithm: self.three_ds_decision_rule_algorithm,\n            acquirer_config_map: self.acquirer_config_map,\n            merchant_category_code: self.merchant_category_code,\n            merchant_country_code: self.merchant_country_code,\n            dispute_polling_interval: self.dispute_polling_interval,\n            is_manual_retry_enabled: self.is_manual_retry_enabled,\n            always_enable_overcapture: self.always_enable_overcapture,\n            is_external_vault_enabled,\n            external_vault_connector_details,\n            billing_processor_id: self.billing_processor_id,\n        })\n    }\n", "function_name": "convert", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "business profile conversion"}, {"query": "rust business profile convert method implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: convert\n    async fn convert(self) -> CustomResult<Self::DstType, ValidationError> {\n        let (is_external_vault_enabled, external_vault_connector_details) =\n            self.external_vault_details.into();\n\n        Ok(diesel_models::business_profile::Profile {\n            profile_id: self.profile_id.clone(),\n            id: Some(self.profile_id),\n            merchant_id: self.merchant_id,\n            profile_name: self.profile_name,\n            created_at: self.created_at,\n            modified_at: self.modified_at,\n            return_url: self.return_url,\n            enable_payment_response_hash: self.enable_payment_response_hash,\n            payment_response_hash_key: self.payment_response_hash_key,\n            redirect_to_merchant_with_http_post: self.redirect_to_merchant_with_http_post,\n            webhook_details: self.webhook_details,\n            metadata: self.metadata,\n            routing_algorithm: self.routing_algorithm,\n            intent_fulfillment_time: self.intent_fulfillment_time,\n            frm_routing_algorithm: self.frm_routing_algorithm,\n            payout_routing_algorithm: self.payout_routing_algorithm,\n            is_recon_enabled: self.is_recon_enabled,\n            applepay_verified_domains: self.applepay_verified_domains,\n            payment_link_config: self.payment_link_config,\n            session_expiry: self.session_expiry,\n            authentication_connector_details: self.authentication_connector_details,\n            payout_link_config: self.payout_link_config,\n            is_extended_card_info_enabled: self.is_extended_card_info_enabled,\n            extended_card_info_config: self.extended_card_info_config,\n            is_connector_agnostic_mit_enabled: self.is_connector_agnostic_mit_enabled,\n            use_billing_as_payment_method_billing: self.use_billing_as_payment_method_billing,\n            collect_shipping_details_from_wallet_connector: self\n                .collect_shipping_details_from_wallet_connector,\n            collect_billing_details_from_wallet_connector: self\n                .collect_billing_details_from_wallet_connector,\n            outgoing_webhook_custom_http_headers: self\n                .outgoing_webhook_custom_http_headers\n                .map(Encryption::from),\n            always_collect_billing_details_from_wallet_connector: self\n                .always_collect_billing_details_from_wallet_connector,\n            always_collect_shipping_details_from_wallet_c\n\n... [truncated 1052 chars] ...\n\nclear_pan_retries_enabled,\n            force_3ds_challenge: Some(self.force_3ds_challenge),\n            is_debit_routing_enabled: self.is_debit_routing_enabled,\n            merchant_business_country: self.merchant_business_country,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            is_pre_network_tokenization_enabled: Some(self.is_pre_network_tokenization_enabled),\n            three_ds_decision_rule_algorithm: self.three_ds_decision_rule_algorithm,\n            acquirer_config_map: self.acquirer_config_map,\n            merchant_category_code: self.merchant_category_code,\n            merchant_country_code: self.merchant_country_code,\n            dispute_polling_interval: self.dispute_polling_interval,\n            is_manual_retry_enabled: self.is_manual_retry_enabled,\n            always_enable_overcapture: self.always_enable_overcapture,\n            is_external_vault_enabled,\n            external_vault_connector_details,\n            billing_processor_id: self.billing_processor_id,\n        })\n    }\n", "function_name": "convert", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "business profile conversion"}, {"query": "map api business profile to diesel models profile", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: convert\n    async fn convert(self) -> CustomResult<Self::DstType, ValidationError> {\n        let (is_external_vault_enabled, external_vault_connector_details) =\n            self.external_vault_details.into();\n\n        Ok(diesel_models::business_profile::Profile {\n            profile_id: self.profile_id.clone(),\n            id: Some(self.profile_id),\n            merchant_id: self.merchant_id,\n            profile_name: self.profile_name,\n            created_at: self.created_at,\n            modified_at: self.modified_at,\n            return_url: self.return_url,\n            enable_payment_response_hash: self.enable_payment_response_hash,\n            payment_response_hash_key: self.payment_response_hash_key,\n            redirect_to_merchant_with_http_post: self.redirect_to_merchant_with_http_post,\n            webhook_details: self.webhook_details,\n            metadata: self.metadata,\n            routing_algorithm: self.routing_algorithm,\n            intent_fulfillment_time: self.intent_fulfillment_time,\n            frm_routing_algorithm: self.frm_routing_algorithm,\n            payout_routing_algorithm: self.payout_routing_algorithm,\n            is_recon_enabled: self.is_recon_enabled,\n            applepay_verified_domains: self.applepay_verified_domains,\n            payment_link_config: self.payment_link_config,\n            session_expiry: self.session_expiry,\n            authentication_connector_details: self.authentication_connector_details,\n            payout_link_config: self.payout_link_config,\n            is_extended_card_info_enabled: self.is_extended_card_info_enabled,\n            extended_card_info_config: self.extended_card_info_config,\n            is_connector_agnostic_mit_enabled: self.is_connector_agnostic_mit_enabled,\n            use_billing_as_payment_method_billing: self.use_billing_as_payment_method_billing,\n            collect_shipping_details_from_wallet_connector: self\n                .collect_shipping_details_from_wallet_connector,\n            collect_billing_details_from_wallet_connector: self\n                .collect_billing_details_from_wallet_connector,\n            outgoing_webhook_custom_http_headers: self\n                .outgoing_webhook_custom_http_headers\n                .map(Encryption::from),\n            always_collect_billing_details_from_wallet_connector: self\n                .always_collect_billing_details_from_wallet_connector,\n            always_collect_shipping_details_from_wallet_c\n\n... [truncated 1052 chars] ...\n\nclear_pan_retries_enabled,\n            force_3ds_challenge: Some(self.force_3ds_challenge),\n            is_debit_routing_enabled: self.is_debit_routing_enabled,\n            merchant_business_country: self.merchant_business_country,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            is_pre_network_tokenization_enabled: Some(self.is_pre_network_tokenization_enabled),\n            three_ds_decision_rule_algorithm: self.three_ds_decision_rule_algorithm,\n            acquirer_config_map: self.acquirer_config_map,\n            merchant_category_code: self.merchant_category_code,\n            merchant_country_code: self.merchant_country_code,\n            dispute_polling_interval: self.dispute_polling_interval,\n            is_manual_retry_enabled: self.is_manual_retry_enabled,\n            always_enable_overcapture: self.always_enable_overcapture,\n            is_external_vault_enabled,\n            external_vault_connector_details,\n            billing_processor_id: self.billing_processor_id,\n        })\n    }\n", "function_name": "convert", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "business profile conversion"}, {"query": "hyperswitch domain models business_profile convert function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: convert\n    async fn convert(self) -> CustomResult<Self::DstType, ValidationError> {\n        let (is_external_vault_enabled, external_vault_connector_details) =\n            self.external_vault_details.into();\n\n        Ok(diesel_models::business_profile::Profile {\n            profile_id: self.profile_id.clone(),\n            id: Some(self.profile_id),\n            merchant_id: self.merchant_id,\n            profile_name: self.profile_name,\n            created_at: self.created_at,\n            modified_at: self.modified_at,\n            return_url: self.return_url,\n            enable_payment_response_hash: self.enable_payment_response_hash,\n            payment_response_hash_key: self.payment_response_hash_key,\n            redirect_to_merchant_with_http_post: self.redirect_to_merchant_with_http_post,\n            webhook_details: self.webhook_details,\n            metadata: self.metadata,\n            routing_algorithm: self.routing_algorithm,\n            intent_fulfillment_time: self.intent_fulfillment_time,\n            frm_routing_algorithm: self.frm_routing_algorithm,\n            payout_routing_algorithm: self.payout_routing_algorithm,\n            is_recon_enabled: self.is_recon_enabled,\n            applepay_verified_domains: self.applepay_verified_domains,\n            payment_link_config: self.payment_link_config,\n            session_expiry: self.session_expiry,\n            authentication_connector_details: self.authentication_connector_details,\n            payout_link_config: self.payout_link_config,\n            is_extended_card_info_enabled: self.is_extended_card_info_enabled,\n            extended_card_info_config: self.extended_card_info_config,\n            is_connector_agnostic_mit_enabled: self.is_connector_agnostic_mit_enabled,\n            use_billing_as_payment_method_billing: self.use_billing_as_payment_method_billing,\n            collect_shipping_details_from_wallet_connector: self\n                .collect_shipping_details_from_wallet_connector,\n            collect_billing_details_from_wallet_connector: self\n                .collect_billing_details_from_wallet_connector,\n            outgoing_webhook_custom_http_headers: self\n                .outgoing_webhook_custom_http_headers\n                .map(Encryption::from),\n            always_collect_billing_details_from_wallet_connector: self\n                .always_collect_billing_details_from_wallet_connector,\n            always_collect_shipping_details_from_wallet_c\n\n... [truncated 1052 chars] ...\n\nclear_pan_retries_enabled,\n            force_3ds_challenge: Some(self.force_3ds_challenge),\n            is_debit_routing_enabled: self.is_debit_routing_enabled,\n            merchant_business_country: self.merchant_business_country,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            is_pre_network_tokenization_enabled: Some(self.is_pre_network_tokenization_enabled),\n            three_ds_decision_rule_algorithm: self.three_ds_decision_rule_algorithm,\n            acquirer_config_map: self.acquirer_config_map,\n            merchant_category_code: self.merchant_category_code,\n            merchant_country_code: self.merchant_country_code,\n            dispute_polling_interval: self.dispute_polling_interval,\n            is_manual_retry_enabled: self.is_manual_retry_enabled,\n            always_enable_overcapture: self.always_enable_overcapture,\n            is_external_vault_enabled,\n            external_vault_connector_details,\n            billing_processor_id: self.billing_processor_id,\n        })\n    }\n", "function_name": "convert", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "business profile conversion"}, {"query": "how to implement Gigadat tokenization in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gigadat\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gigadat\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector integration traits"}, {"query": "hyperswitch Gigadat connector integration traits", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gigadat\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gigadat\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector integration traits"}, {"query": "rust connector integration pattern hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gigadat\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gigadat\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector integration traits"}, {"query": "Gigadat payment method tokenization not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gigadat\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gigadat\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector integration traits"}, {"query": "how to configure authentication headers for Netcetera connector in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector header configuration"}, {"query": "rust hyperswitch netcetera connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector header configuration"}, {"query": "hyperswitch netcetera payment gateway header configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector header configuration"}, {"query": "netcetera connector PreAuthNRouterData header handling rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera connector header configuration"}, {"query": "hyperswitch payme connector generate sale request struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleRequest\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    sale_payment_method: SalePaymentMethod,\n    services: Option<ThreeDs>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "GenerateSaleRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe payment request struct"}, {"query": "how to construct payment request for payme gateway in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleRequest\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    sale_payment_method: SalePaymentMethod,\n    services: Option<ThreeDs>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "GenerateSaleRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe payment request struct"}, {"query": "hyperswitch payme transformer struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleRequest\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    sale_payment_method: SalePaymentMethod,\n    services: Option<ThreeDs>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "GenerateSaleRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe payment request struct"}, {"query": "payme payment initiation request fields hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleRequest\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    sale_payment_method: SalePaymentMethod,\n    services: Option<ThreeDs>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "GenerateSaleRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe payment request struct"}, {"query": "how to handle nordea error response parsing", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: responses::NordeaErrorResponse = res\n            .response\n            .parse_struct(\"NordeaErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.code.clone())\n                .unwrap_or(NO_ERROR_CODE.to_string()),\n            message: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.description.clone())\n                .unwrap_or(NO_ERROR_MESSAGE.to_string()),\n            reason: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.failure_type.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea error response builder"}, {"query": "nordea connector error response format", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: responses::NordeaErrorResponse = res\n            .response\n            .parse_struct(\"NordeaErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.code.clone())\n                .unwrap_or(NO_ERROR_CODE.to_string()),\n            message: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.description.clone())\n                .unwrap_or(NO_ERROR_MESSAGE.to_string()),\n            reason: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.failure_type.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea error response builder"}, {"query": "build_error_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: responses::NordeaErrorResponse = res\n            .response\n            .parse_struct(\"NordeaErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.code.clone())\n                .unwrap_or(NO_ERROR_CODE.to_string()),\n            message: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.description.clone())\n                .unwrap_or(NO_ERROR_MESSAGE.to_string()),\n            reason: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.failure_type.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea error response builder"}, {"query": "map nordea error to hyperswitch error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: responses::NordeaErrorResponse = res\n            .response\n            .parse_struct(\"NordeaErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.code.clone())\n                .unwrap_or(NO_ERROR_CODE.to_string()),\n            message: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.description.clone())\n                .unwrap_or(NO_ERROR_MESSAGE.to_string()),\n            reason: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.failure_type.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea error response builder"}, {"query": "Rust struct definition for KlarnaSessionRequest hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaSessionRequest\npub struct KlarnaSessionRequest {\n    intent: KlarnaSessionIntent,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    order_amount: MinorUnit,\n    order_lines: Vec<OrderLines>,\n    shipping_address: Option<KlarnaShippingAddress>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "function_name": "KlarnaSessionRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna session request struct"}, {"query": "hyperswitch Klarna connector session request fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaSessionRequest\npub struct KlarnaSessionRequest {\n    intent: KlarnaSessionIntent,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    order_amount: MinorUnit,\n    order_lines: Vec<OrderLines>,\n    shipping_address: Option<KlarnaShippingAddress>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "function_name": "KlarnaSessionRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna session request struct"}, {"query": "KlarnaSessionRequest struct definition Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaSessionRequest\npub struct KlarnaSessionRequest {\n    intent: KlarnaSessionIntent,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    order_amount: MinorUnit,\n    order_lines: Vec<OrderLines>,\n    shipping_address: Option<KlarnaShippingAddress>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "function_name": "KlarnaSessionRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna session request struct"}, {"query": "hyperswitch Klarna payment session request payload", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaSessionRequest\npub struct KlarnaSessionRequest {\n    intent: KlarnaSessionIntent,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    order_amount: MinorUnit,\n    order_lines: Vec<OrderLines>,\n    shipping_address: Option<KlarnaShippingAddress>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "function_name": "KlarnaSessionRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna session request struct"}, {"query": "how to define a window function sum in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Window\npub enum Window<R> {\n    Sum {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n    RowNumber {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n}\n\n#[derive(Debug, Clone, Copy)]", "function_name": "Window", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Window Enum Definition"}, {"query": "hyperswitch analytics crate window enum rownumber", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Window\npub enum Window<R> {\n    Sum {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n    RowNumber {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n}\n\n#[derive(Debug, Clone, Copy)]", "function_name": "Window", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Window Enum Definition"}, {"query": "rust struct window sum partition by order by", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Window\npub enum Window<R> {\n    Sum {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n    RowNumber {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n}\n\n#[derive(Debug, Clone, Copy)]", "function_name": "Window", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Window Enum Definition"}, {"query": "hyperswitch analytics query window function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Window\npub enum Window<R> {\n    Sum {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n    RowNumber {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n}\n\n#[derive(Debug, Clone, Copy)]", "function_name": "Window", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Window Enum Definition"}, {"query": "How to configure Apple Pay to decrypt tokens at the application level in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: ApplePayFlow\npub enum ApplePayFlow {\n    // Either Merchant provided certificates i.e decryption by hyperswitch or Hyperswitch certificates i.e simplified flow\n    // decryption is performed in hyperswitch\n    DecryptAtApplication(api_models::payments::PaymentProcessingDetails),\n    // decryption by connector or predecrypted token\n    SkipDecryption,\n}\n", "function_name": "ApplePayFlow", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Apple Pay token processing strategy"}, {"query": "What is the difference between DecryptAtApplication and SkipDecryption in ApplePayFlow?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: ApplePayFlow\npub enum ApplePayFlow {\n    // Either Merchant provided certificates i.e decryption by hyperswitch or Hyperswitch certificates i.e simplified flow\n    // decryption is performed in hyperswitch\n    DecryptAtApplication(api_models::payments::PaymentProcessingDetails),\n    // decryption by connector or predecrypted token\n    SkipDecryption,\n}\n", "function_name": "ApplePayFlow", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Apple Pay token processing strategy"}, {"query": "Rust enum ApplePayFlow usage for handling pre-decrypted Apple Pay tokens", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: ApplePayFlow\npub enum ApplePayFlow {\n    // Either Merchant provided certificates i.e decryption by hyperswitch or Hyperswitch certificates i.e simplified flow\n    // decryption is performed in hyperswitch\n    DecryptAtApplication(api_models::payments::PaymentProcessingDetails),\n    // decryption by connector or predecrypted token\n    SkipDecryption,\n}\n", "function_name": "ApplePayFlow", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Apple Pay token processing strategy"}, {"query": "Hyperswitch Apple Pay token decryption configuration options", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: ApplePayFlow\npub enum ApplePayFlow {\n    // Either Merchant provided certificates i.e decryption by hyperswitch or Hyperswitch certificates i.e simplified flow\n    // decryption is performed in hyperswitch\n    DecryptAtApplication(api_models::payments::PaymentProcessingDetails),\n    // decryption by connector or predecrypted token\n    SkipDecryption,\n}\n", "function_name": "ApplePayFlow", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Apple Pay token processing strategy"}, {"query": "Worldpay Modular webhook response structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularEventResponse\npub struct WorldpaymodularEventResponse {\n    pub last_event: EventType,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<EventLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularEventResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular webhook response struct"}, {"query": "hyperswitch Worldpay modular event deserialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularEventResponse\npub struct WorldpaymodularEventResponse {\n    pub last_event: EventType,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<EventLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularEventResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular webhook response struct"}, {"query": "WorldpaymodularEventResponse struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularEventResponse\npub struct WorldpaymodularEventResponse {\n    pub last_event: EventType,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<EventLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularEventResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular webhook response struct"}, {"query": "how hyperswitch handles worldpay modular webhooks", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularEventResponse\npub struct WorldpaymodularEventResponse {\n    pub last_event: EventType,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<EventLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularEventResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular webhook response struct"}, {"query": "rust hyperswitch authipay connector build_request implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "AuthiPay connector request builder"}, {"query": "how to implement build_request for authipay in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "AuthiPay connector request builder"}, {"query": "hyperswitch PaymentsAuthorizeRouterData build_request authipay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "AuthiPay connector request builder"}, {"query": "authipay connector request builder hyperswitch rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "AuthiPay connector request builder"}, {"query": "how to generate Globlepay authentication signature query params", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_globlepay_query_params\nfn get_globlepay_query_params(\n    connector_auth_type: &ConnectorAuthType,\n) -> CustomResult<String, errors::ConnectorError> {\n    let auth_type = globepay::GlobepayAuthType::try_from(connector_auth_type)?;\n    let time = (OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000).to_string();\n    let nonce_str = rand::distributions::Alphanumeric.sample_string(&mut rand::thread_rng(), 12);\n    let valid_string = format!(\n        \"{}&{time}&{nonce_str}&{}\",\n        auth_type.partner_code.expose(),\n        auth_type.credential_code.expose()\n    );\n    let digest = crypto::Sha256\n        .generate_digest(valid_string.as_bytes())\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"error encoding the query params\")?;\n    let sign = encode(digest).to_lowercase();\n    let param = format!(\"?sign={sign}&time={time}&nonce_str={nonce_str}\");\n    Ok(param)\n}\n", "function_name": "get_globlepay_query_params", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globlepay auth signature generation"}, {"query": "Rust function for Globlepay API signature generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_globlepay_query_params\nfn get_globlepay_query_params(\n    connector_auth_type: &ConnectorAuthType,\n) -> CustomResult<String, errors::ConnectorError> {\n    let auth_type = globepay::GlobepayAuthType::try_from(connector_auth_type)?;\n    let time = (OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000).to_string();\n    let nonce_str = rand::distributions::Alphanumeric.sample_string(&mut rand::thread_rng(), 12);\n    let valid_string = format!(\n        \"{}&{time}&{nonce_str}&{}\",\n        auth_type.partner_code.expose(),\n        auth_type.credential_code.expose()\n    );\n    let digest = crypto::Sha256\n        .generate_digest(valid_string.as_bytes())\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"error encoding the query params\")?;\n    let sign = encode(digest).to_lowercase();\n    let param = format!(\"?sign={sign}&time={time}&nonce_str={nonce_str}\");\n    Ok(param)\n}\n", "function_name": "get_globlepay_query_params", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globlepay auth signature generation"}, {"query": "hyperswitch Globlepay connector auth query params implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_globlepay_query_params\nfn get_globlepay_query_params(\n    connector_auth_type: &ConnectorAuthType,\n) -> CustomResult<String, errors::ConnectorError> {\n    let auth_type = globepay::GlobepayAuthType::try_from(connector_auth_type)?;\n    let time = (OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000).to_string();\n    let nonce_str = rand::distributions::Alphanumeric.sample_string(&mut rand::thread_rng(), 12);\n    let valid_string = format!(\n        \"{}&{time}&{nonce_str}&{}\",\n        auth_type.partner_code.expose(),\n        auth_type.credential_code.expose()\n    );\n    let digest = crypto::Sha256\n        .generate_digest(valid_string.as_bytes())\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"error encoding the query params\")?;\n    let sign = encode(digest).to_lowercase();\n    let param = format!(\"?sign={sign}&time={time}&nonce_str={nonce_str}\");\n    Ok(param)\n}\n", "function_name": "get_globlepay_query_params", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globlepay auth signature generation"}, {"query": "Globlepay API signature calculation using SHA256 and nonce", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_globlepay_query_params\nfn get_globlepay_query_params(\n    connector_auth_type: &ConnectorAuthType,\n) -> CustomResult<String, errors::ConnectorError> {\n    let auth_type = globepay::GlobepayAuthType::try_from(connector_auth_type)?;\n    let time = (OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000).to_string();\n    let nonce_str = rand::distributions::Alphanumeric.sample_string(&mut rand::thread_rng(), 12);\n    let valid_string = format!(\n        \"{}&{time}&{nonce_str}&{}\",\n        auth_type.partner_code.expose(),\n        auth_type.credential_code.expose()\n    );\n    let digest = crypto::Sha256\n        .generate_digest(valid_string.as_bytes())\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"error encoding the query params\")?;\n    let sign = encode(digest).to_lowercase();\n    let param = format!(\"?sign={sign}&time={time}&nonce_str={nonce_str}\");\n    Ok(param)\n}\n", "function_name": "get_globlepay_query_params", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globlepay auth signature generation"}, {"query": "How to handle Finix API response in Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<\n        RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        errors::ConnectorError,\n    > {\n        let response: finix::FinixIdentityResponse = res\n            .response\n            .parse_struct(\"Finix IdentityResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector customer response handler"}, {"query": "finix connector customer creation response parsing hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<\n        RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        errors::ConnectorError,\n    > {\n        let response: finix::FinixIdentityResponse = res\n            .response\n            .parse_struct(\"Finix IdentityResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector customer response handler"}, {"query": "Rust hyperswitch handle_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<\n        RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        errors::ConnectorError,\n    > {\n        let response: finix::FinixIdentityResponse = res\n            .response\n            .parse_struct(\"Finix IdentityResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector customer response handler"}, {"query": "FinixIdentityResponse deserialization hyperswitch connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<\n        RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        errors::ConnectorError,\n    > {\n        let response: finix::FinixIdentityResponse = res\n            .response\n            .parse_struct(\"Finix IdentityResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector customer response handler"}, {"query": "how to implement get_request_body for tokenex connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = tokenex::TokenexInsertRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex vault insert adapter"}, {"query": "hyperswitch tokenex vault insert request adapter", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = tokenex::TokenexInsertRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex vault insert adapter"}, {"query": "rust function get_request_body tokenex", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = tokenex::TokenexInsertRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex vault insert adapter"}, {"query": "ExternalVaultInsertFlow to TokenexInsertRequest conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = tokenex::TokenexInsertRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex vault insert adapter"}, {"query": "rust hyperswitch filter_refund_by_meta_constraints implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_meta_constraints\n    async fn filter_refund_by_meta_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<api_models::refunds::RefundListMetaData, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_refund_by_meta_constraints", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund metadata filtering"}, {"query": "how to get refund list metadata by merchant id and time range", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_meta_constraints\n    async fn filter_refund_by_meta_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<api_models::refunds::RefundListMetaData, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_refund_by_meta_constraints", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund metadata filtering"}, {"query": "hyperswitch router refund filtering storage scheme", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_meta_constraints\n    async fn filter_refund_by_meta_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<api_models::refunds::RefundListMetaData, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_refund_by_meta_constraints", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund metadata filtering"}, {"query": "rust function signature filter_refund_by_meta_constraints", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_meta_constraints\n    async fn filter_refund_by_meta_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<api_models::refunds::RefundListMetaData, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_refund_by_meta_constraints", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund metadata filtering"}, {"query": "How do I query a refund by merchant ID and refund ID in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_refund_id\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_merchant_id_refund_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund DB retrieval by ID"}, {"query": "Find the function to retrieve refund details from the database in Hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_refund_id\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_merchant_id_refund_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund DB retrieval by ID"}, {"query": "Rust function to get refund by merchant_id and refund_id in router crate", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_refund_id\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_merchant_id_refund_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund DB retrieval by ID"}, {"query": "Hyperswitch storage error handling for refund retrieval by ID", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_refund_id\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "function_name": "find_refund_by_merchant_id_refund_id", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund DB retrieval by ID"}, {"query": "rust hyperswitch analytics clip_to_end truncate time series", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_end\n    fn clip_to_end(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError>;\n}\n\nimpl<T> QueryFilter<T> for analytics_api::TimeRange\nwhere\n    T: AnalyticsDataSource,\n    time::PrimitiveDateTime: ToSql<T>,\n    AnalyticsCollection: ToSql<T>,\n    Granularity: GroupByClause<T>,\n{", "function_name": "clip_to_end", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time series truncation"}, {"query": "how to limit time range to current time in hyperswitch analytics", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_end\n    fn clip_to_end(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError>;\n}\n\nimpl<T> QueryFilter<T> for analytics_api::TimeRange\nwhere\n    T: AnalyticsDataSource,\n    time::PrimitiveDateTime: ToSql<T>,\n    AnalyticsCollection: ToSql<T>,\n    Granularity: GroupByClause<T>,\n{", "function_name": "clip_to_end", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time series truncation"}, {"query": "hyperswitch analytics query filter clip_to_end implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_end\n    fn clip_to_end(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError>;\n}\n\nimpl<T> QueryFilter<T> for analytics_api::TimeRange\nwhere\n    T: AnalyticsDataSource,\n    time::PrimitiveDateTime: ToSql<T>,\n    AnalyticsCollection: ToSql<T>,\n    Granularity: GroupByClause<T>,\n{", "function_name": "clip_to_end", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time series truncation"}, {"query": "rust truncate time series to end function hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_end\n    fn clip_to_end(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError>;\n}\n\nimpl<T> QueryFilter<T> for analytics_api::TimeRange\nwhere\n    T: AnalyticsDataSource,\n    time::PrimitiveDateTime: ToSql<T>,\n    AnalyticsCollection: ToSql<T>,\n    Granularity: GroupByClause<T>,\n{", "function_name": "clip_to_end", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time series truncation"}, {"query": "how to add additional card info to payment method in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: apply_additional_payment_data\n    pub fn apply_additional_payment_data(\n        &self,\n        additional_payment_data: api_models::payments::AdditionalPaymentData,\n    ) -> Self {\n        if let api_models::payments::AdditionalPaymentData::Card(additional_card_info) =\n            additional_payment_data\n        {\n            match self {\n                Self::Card(card) => {\n                    Self::Card(card.apply_additional_card_info(*additional_card_info))\n                }\n                Self::CardWithLimitedDetails(card_with_limited_details) => {\n                    Self::CardWithLimitedDetails(\n                        card_with_limited_details.apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                Self::CardDetailsForNetworkTransactionId(card_with_network_transaction_id) => {\n                    Self::CardDetailsForNetworkTransactionId(\n                        card_with_network_transaction_id\n                            .apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                _ => self.to_owned(),\n            }\n        } else {\n            self.to_owned()\n        }\n    }\n", "function_name": "apply_additional_payment_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment Method State Enrichment"}, {"query": "rust hyperswitch domain models apply_additional_payment_data implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: apply_additional_payment_data\n    pub fn apply_additional_payment_data(\n        &self,\n        additional_payment_data: api_models::payments::AdditionalPaymentData,\n    ) -> Self {\n        if let api_models::payments::AdditionalPaymentData::Card(additional_card_info) =\n            additional_payment_data\n        {\n            match self {\n                Self::Card(card) => {\n                    Self::Card(card.apply_additional_card_info(*additional_card_info))\n                }\n                Self::CardWithLimitedDetails(card_with_limited_details) => {\n                    Self::CardWithLimitedDetails(\n                        card_with_limited_details.apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                Self::CardDetailsForNetworkTransactionId(card_with_network_transaction_id) => {\n                    Self::CardDetailsForNetworkTransactionId(\n                        card_with_network_transaction_id\n                            .apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                _ => self.to_owned(),\n            }\n        } else {\n            self.to_owned()\n        }\n    }\n", "function_name": "apply_additional_payment_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment Method State Enrichment"}, {"query": "hyperswitch payment method state update additional card details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: apply_additional_payment_data\n    pub fn apply_additional_payment_data(\n        &self,\n        additional_payment_data: api_models::payments::AdditionalPaymentData,\n    ) -> Self {\n        if let api_models::payments::AdditionalPaymentData::Card(additional_card_info) =\n            additional_payment_data\n        {\n            match self {\n                Self::Card(card) => {\n                    Self::Card(card.apply_additional_card_info(*additional_card_info))\n                }\n                Self::CardWithLimitedDetails(card_with_limited_details) => {\n                    Self::CardWithLimitedDetails(\n                        card_with_limited_details.apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                Self::CardDetailsForNetworkTransactionId(card_with_network_transaction_id) => {\n                    Self::CardDetailsForNetworkTransactionId(\n                        card_with_network_transaction_id\n                            .apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                _ => self.to_owned(),\n            }\n        } else {\n            self.to_owned()\n        }\n    }\n", "function_name": "apply_additional_payment_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment Method State Enrichment"}, {"query": "extend card payment method with extra data hyperswitch domain", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: apply_additional_payment_data\n    pub fn apply_additional_payment_data(\n        &self,\n        additional_payment_data: api_models::payments::AdditionalPaymentData,\n    ) -> Self {\n        if let api_models::payments::AdditionalPaymentData::Card(additional_card_info) =\n            additional_payment_data\n        {\n            match self {\n                Self::Card(card) => {\n                    Self::Card(card.apply_additional_card_info(*additional_card_info))\n                }\n                Self::CardWithLimitedDetails(card_with_limited_details) => {\n                    Self::CardWithLimitedDetails(\n                        card_with_limited_details.apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                Self::CardDetailsForNetworkTransactionId(card_with_network_transaction_id) => {\n                    Self::CardDetailsForNetworkTransactionId(\n                        card_with_network_transaction_id\n                            .apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                _ => self.to_owned(),\n            }\n        } else {\n            self.to_owned()\n        }\n    }\n", "function_name": "apply_additional_payment_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment Method State Enrichment"}, {"query": "how to access co-badge data for a payment method in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_co_badged_card_data\n    pub fn get_co_badged_card_data(&self) -> Option<&payment_methods::CoBadgedCardData> {\n        if let Self::Card(card) = self {\n            card.co_badged_card_data.as_ref()\n        } else {\n            None\n        }\n    }\n", "function_name": "get_co_badged_card_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment Method Co-Badge Data Accessor"}, {"query": "hyperswitch get_co_badged_card_data implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_co_badged_card_data\n    pub fn get_co_badged_card_data(&self) -> Option<&payment_methods::CoBadgedCardData> {\n        if let Self::Card(card) = self {\n            card.co_badged_card_data.as_ref()\n        } else {\n            None\n        }\n    }\n", "function_name": "get_co_badged_card_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment Method Co-Badge Data Accessor"}, {"query": "rust payment method co badge data retrieval", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_co_badged_card_data\n    pub fn get_co_badged_card_data(&self) -> Option<&payment_methods::CoBadgedCardData> {\n        if let Self::Card(card) = self {\n            card.co_badged_card_data.as_ref()\n        } else {\n            None\n        }\n    }\n", "function_name": "get_co_badged_card_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment Method Co-Badge Data Accessor"}, {"query": "hyperswitch domain models card co badge", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_co_badged_card_data\n    pub fn get_co_badged_card_data(&self) -> Option<&payment_methods::CoBadgedCardData> {\n        if let Self::Card(card) = self {\n            card.co_badged_card_data.as_ref()\n        } else {\n            None\n        }\n    }\n", "function_name": "get_co_badged_card_data", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Payment Method Co-Badge Data Accessor"}, {"query": "how to convert SecretSerdeValue to Klarna metadata struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: try_from\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna metadata deserialization"}, {"query": "Klarna connector metadata deserialization error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: try_from\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna metadata deserialization"}, {"query": "try_from implementation for Klarna metadata in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: try_from\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna metadata deserialization"}, {"query": "hyperswitch Klarna connector config validation SecretSerdeValue", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: try_from\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna metadata deserialization"}, {"query": "how to dynamically generate netcetera payment gateway url with merchant prefix", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = netcetera::NetceteraMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n", "function_name": "build_endpoint", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera URL construction"}, {"query": "rust function to replace placeholder in base url using connector metadata", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = netcetera::NetceteraMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n", "function_name": "build_endpoint", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera URL construction"}, {"query": "netcetera connector build_endpoint implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = netcetera::NetceteraMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n", "function_name": "build_endpoint", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera URL construction"}, {"query": "hyperswitch netcetera metadata endpoint_prefix url construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = netcetera::NetceteraMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n", "function_name": "build_endpoint", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera URL construction"}, {"query": "Rust hyperswitch router update mandate_id from request", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_tracker\n    async fn update_tracker<'b>(\n        &'b self,\n        db: &'b SessionState,\n        processor: &domain::Processor,\n        mut payment_data: PaymentData<F>,\n        router_data: types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        locale: &Option<String>,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] routable_connector: Vec<\n            RoutableConnectorChoice,\n        >,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] business_profile: &domain::Profile,\n    ) -> RouterResult<PaymentData<F>>\n    where\n        F: 'b,\n    {\n        payment_data.mandate_id = payment_data\n            .mandate_id\n            .or_else(|| router_data.request.mandate_id.clone());\n\n        // update setup_future_usage incase it is downgraded to on-session\n        payment_data.payment_attempt.setup_future_usage_applied =\n            router_data.request.setup_future_usage;\n\n        payment_data = Box::pin(payment_response_update_tracker(\n            db,\n            payment_data,\n            router_data,\n            processor,\n            locale,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            routable_connector,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            business_profile,\n        ))\n        .await?;\n\n        Ok(payment_data)\n    }\n\n    #[cfg(feature = \"v2\")]", "function_name": "update_tracker", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Router payment response state update"}, {"query": "hyperswitch payment_response_update_tracker function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_tracker\n    async fn update_tracker<'b>(\n        &'b self,\n        db: &'b SessionState,\n        processor: &domain::Processor,\n        mut payment_data: PaymentData<F>,\n        router_data: types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        locale: &Option<String>,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] routable_connector: Vec<\n            RoutableConnectorChoice,\n        >,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] business_profile: &domain::Profile,\n    ) -> RouterResult<PaymentData<F>>\n    where\n        F: 'b,\n    {\n        payment_data.mandate_id = payment_data\n            .mandate_id\n            .or_else(|| router_data.request.mandate_id.clone());\n\n        // update setup_future_usage incase it is downgraded to on-session\n        payment_data.payment_attempt.setup_future_usage_applied =\n            router_data.request.setup_future_usage;\n\n        payment_data = Box::pin(payment_response_update_tracker(\n            db,\n            payment_data,\n            router_data,\n            processor,\n            locale,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            routable_connector,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            business_profile,\n        ))\n        .await?;\n\n        Ok(payment_data)\n    }\n\n    #[cfg(feature = \"v2\")]", "function_name": "update_tracker", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Router payment response state update"}, {"query": "how to update setup_future_usage in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_tracker\n    async fn update_tracker<'b>(\n        &'b self,\n        db: &'b SessionState,\n        processor: &domain::Processor,\n        mut payment_data: PaymentData<F>,\n        router_data: types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        locale: &Option<String>,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] routable_connector: Vec<\n            RoutableConnectorChoice,\n        >,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] business_profile: &domain::Profile,\n    ) -> RouterResult<PaymentData<F>>\n    where\n        F: 'b,\n    {\n        payment_data.mandate_id = payment_data\n            .mandate_id\n            .or_else(|| router_data.request.mandate_id.clone());\n\n        // update setup_future_usage incase it is downgraded to on-session\n        payment_data.payment_attempt.setup_future_usage_applied =\n            router_data.request.setup_future_usage;\n\n        payment_data = Box::pin(payment_response_update_tracker(\n            db,\n            payment_data,\n            router_data,\n            processor,\n            locale,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            routable_connector,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            business_profile,\n        ))\n        .await?;\n\n        Ok(payment_data)\n    }\n\n    #[cfg(feature = \"v2\")]", "function_name": "update_tracker", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Router payment response state update"}, {"query": "hyperswitch router crate payment data persistence", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_tracker\n    async fn update_tracker<'b>(\n        &'b self,\n        db: &'b SessionState,\n        processor: &domain::Processor,\n        mut payment_data: PaymentData<F>,\n        router_data: types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        locale: &Option<String>,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] routable_connector: Vec<\n            RoutableConnectorChoice,\n        >,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] business_profile: &domain::Profile,\n    ) -> RouterResult<PaymentData<F>>\n    where\n        F: 'b,\n    {\n        payment_data.mandate_id = payment_data\n            .mandate_id\n            .or_else(|| router_data.request.mandate_id.clone());\n\n        // update setup_future_usage incase it is downgraded to on-session\n        payment_data.payment_attempt.setup_future_usage_applied =\n            router_data.request.setup_future_usage;\n\n        payment_data = Box::pin(payment_response_update_tracker(\n            db,\n            payment_data,\n            router_data,\n            processor,\n            locale,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            routable_connector,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            business_profile,\n        ))\n        .await?;\n\n        Ok(payment_data)\n    }\n\n    #[cfg(feature = \"v2\")]", "function_name": "update_tracker", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Router payment response state update"}, {"query": "rust hyperswitch boku connector setup mandate error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Boku\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku Setup Mandate Not Implemented"}, {"query": "hyperswitch boku build_request function not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Boku\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku Setup Mandate Not Implemented"}, {"query": "how to implement setup mandate in boku connector rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Boku\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku Setup Mandate Not Implemented"}, {"query": "hyperswitch boku payment method mandate setup error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Boku\".to_string())\n                .into(),\n        )\n    }\n}\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku Setup Mandate Not Implemented"}, {"query": "rust hyperswitch payone connector build_request function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PayoutFulfillType::get_url(self, req, connectors)?)\n            .attach_default_headers()\n            .headers(PayoutFulfillType::get_headers(self, req, connectors)?)\n            .set_body(PayoutFulfillType::get_request_body(self, req, connectors)?)\n            .build();\n        Ok(Some(request))\n    }\n\n    #[instrument(skip_all)]", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Request Builder"}, {"query": "how does hyperswitch payone connector construct payout request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PayoutFulfillType::get_url(self, req, connectors)?)\n            .attach_default_headers()\n            .headers(PayoutFulfillType::get_headers(self, req, connectors)?)\n            .set_body(PayoutFulfillType::get_request_body(self, req, connectors)?)\n            .build();\n        Ok(Some(request))\n    }\n\n    #[instrument(skip_all)]", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Request Builder"}, {"query": "hyperswitch payone connector build_request method source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PayoutFulfillType::get_url(self, req, connectors)?)\n            .attach_default_headers()\n            .headers(PayoutFulfillType::get_headers(self, req, connectors)?)\n            .set_body(PayoutFulfillType::get_request_body(self, req, connectors)?)\n            .build();\n        Ok(Some(request))\n    }\n\n    #[instrument(skip_all)]", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Request Builder"}, {"query": "rust hyperswitch payone payout request builder implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PayoutFulfillType::get_url(self, req, connectors)?)\n            .attach_default_headers()\n            .headers(PayoutFulfillType::get_headers(self, req, connectors)?)\n            .set_body(PayoutFulfillType::get_request_body(self, req, connectors)?)\n            .build();\n        Ok(Some(request))\n    }\n\n    #[instrument(skip_all)]", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Request Builder"}, {"query": "How do I configure ArchipelWalletProvider for Apple Pay in hyperswitch?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelWalletProvider\npub enum ArchipelWalletProvider {\n    ApplePay,\n    GooglePay,\n    SamsungPay,\n}\n\n#[derive(Debug, Default, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "ArchipelWalletProvider", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel wallet provider enum definition"}, {"query": "Rust enum ArchipelWalletProvider definition for Google Pay and Samsung Pay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelWalletProvider\npub enum ArchipelWalletProvider {\n    ApplePay,\n    GooglePay,\n    SamsungPay,\n}\n\n#[derive(Debug, Default, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "ArchipelWalletProvider", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel wallet provider enum definition"}, {"query": "hyperswitch Archipel connector wallet provider configuration options", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelWalletProvider\npub enum ArchipelWalletProvider {\n    ApplePay,\n    GooglePay,\n    SamsungPay,\n}\n\n#[derive(Debug, Default, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "ArchipelWalletProvider", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel wallet provider enum definition"}, {"query": "ArchipelWalletProvider serde rename_all uppercase attribute usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelWalletProvider\npub enum ArchipelWalletProvider {\n    ApplePay,\n    GooglePay,\n    SamsungPay,\n}\n\n#[derive(Debug, Default, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "ArchipelWalletProvider", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel wallet provider enum definition"}, {"query": "hyperswitch TaxInfo struct definition rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: TaxInfo\npub struct TaxInfo {\n    pub tax_status: Option<common_enums::TaxStatus>,\n    pub customer_tax_registration_id: Option<Secret<String>>,\n    pub merchant_tax_registration_id: Option<Secret<String>>,\n    pub shipping_amount_tax: Option<MinorUnit>,\n    pub order_tax_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "TaxInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "TaxInfo struct definition"}, {"query": "how to use TaxInfo struct in hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: TaxInfo\npub struct TaxInfo {\n    pub tax_status: Option<common_enums::TaxStatus>,\n    pub customer_tax_registration_id: Option<Secret<String>>,\n    pub merchant_tax_registration_id: Option<Secret<String>>,\n    pub shipping_amount_tax: Option<MinorUnit>,\n    pub order_tax_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "TaxInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "TaxInfo struct definition"}, {"query": "TaxInfo struct fields customer_tax_registration_id rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: TaxInfo\npub struct TaxInfo {\n    pub tax_status: Option<common_enums::TaxStatus>,\n    pub customer_tax_registration_id: Option<Secret<String>>,\n    pub merchant_tax_registration_id: Option<Secret<String>>,\n    pub shipping_amount_tax: Option<MinorUnit>,\n    pub order_tax_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "TaxInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "TaxInfo struct definition"}, {"query": "hyperswitch tax registration id struct implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: TaxInfo\npub struct TaxInfo {\n    pub tax_status: Option<common_enums::TaxStatus>,\n    pub customer_tax_registration_id: Option<Secret<String>>,\n    pub merchant_tax_registration_id: Option<Secret<String>>,\n    pub shipping_amount_tax: Option<MinorUnit>,\n    pub order_tax_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "TaxInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "TaxInfo struct definition"}, {"query": "How do I handle the response from the Sift connector in hyperswitch?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: sift::SiftPaymentsResponse = res\n            .response\n            .parse_struct(\"Sift PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector response handler"}, {"query": "rust hyperswitch sift connector handle_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: sift::SiftPaymentsResponse = res\n            .response\n            .parse_struct(\"Sift PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector response handler"}, {"query": "Parse SiftPaymentsResponse in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: sift::SiftPaymentsResponse = res\n            .response\n            .parse_struct(\"Sift PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector response handler"}, {"query": "hyperswitch sift connector response deserialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: sift::SiftPaymentsResponse = res\n            .response\n            .parse_struct(\"Sift PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector response handler"}, {"query": "how to verify nordea api signature rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: SignatureParams\nstruct SignatureParams<'a> {\n    content_type: &'a str,\n    host: &'a str,\n    path: &'a str,\n    payload_digest: Option<&'a str>,\n    date: &'a str,\n    http_method: Method,\n}\n", "function_name": "SignatureParams", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea signature validation struct"}, {"query": "nordea connector signature_params struct rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: SignatureParams\nstruct SignatureParams<'a> {\n    content_type: &'a str,\n    host: &'a str,\n    path: &'a str,\n    payload_digest: Option<&'a str>,\n    date: &'a str,\n    http_method: Method,\n}\n", "function_name": "SignatureParams", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea signature validation struct"}, {"query": "rust hyperswitch nordea signature validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: SignatureParams\nstruct SignatureParams<'a> {\n    content_type: &'a str,\n    host: &'a str,\n    path: &'a str,\n    payload_digest: Option<&'a str>,\n    date: &'a str,\n    http_method: Method,\n}\n", "function_name": "SignatureParams", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea signature validation struct"}, {"query": "nordea api signature verification rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: SignatureParams\nstruct SignatureParams<'a> {\n    content_type: &'a str,\n    host: &'a str,\n    path: &'a str,\n    payload_digest: Option<&'a str>,\n    date: &'a str,\n    http_method: Method,\n}\n", "function_name": "SignatureParams", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea signature validation struct"}, {"query": "rust try_from email to user hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: try_from\n    fn try_from(value: pii::Email) -> UserResult<Self> {\n        Self::new(Secret::new(\n            value\n                .peek()\n                .split_once('@')\n                .ok_or(UserErrors::InvalidEmailError)?\n                .0\n                .to_string(),\n        ))\n    }\n}\n\n#[derive(Clone, Debug)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Email to User conversion"}, {"query": "how to convert email to user struct in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: try_from\n    fn try_from(value: pii::Email) -> UserResult<Self> {\n        Self::new(Secret::new(\n            value\n                .peek()\n                .split_once('@')\n                .ok_or(UserErrors::InvalidEmailError)?\n                .0\n                .to_string(),\n        ))\n    }\n}\n\n#[derive(Clone, Debug)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Email to User conversion"}, {"query": "hyperswitch user domain model email parsing", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: try_from\n    fn try_from(value: pii::Email) -> UserResult<Self> {\n        Self::new(Secret::new(\n            value\n                .peek()\n                .split_once('@')\n                .ok_or(UserErrors::InvalidEmailError)?\n                .0\n                .to_string(),\n        ))\n    }\n}\n\n#[derive(Clone, Debug)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Email to User conversion"}, {"query": "rust split_once email to username hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: try_from\n    fn try_from(value: pii::Email) -> UserResult<Self> {\n        Self::new(Secret::new(\n            value\n                .peek()\n                .split_once('@')\n                .ok_or(UserErrors::InvalidEmailError)?\n                .0\n                .to_string(),\n        ))\n    }\n}\n\n#[derive(Clone, Debug)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Email to User conversion"}, {"query": "how to check if a node value exists in the euclid graph context", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_presence\n    fn check_presence(\n        &self,\n        value: &cgraph::NodeValue<dir::DirValue>,\n        strength: cgraph::Strength,\n    ) -> bool {\n        match value {\n            cgraph::NodeValue::Key(k) => {\n                self.keywise_values.contains_key(k) || matches!(strength, cgraph::Strength::Weak)\n            }\n\n            cgraph::NodeValue::Value(val) => {\n                let key = val.get_key();\n                let value_set = if let Some(set) = self.keywise_values.get(&key) {\n                    set\n                } else {\n                    return matches!(strength, cgraph::Strength::Weak);\n                };\n\n                match key.kind.get_type() {\n                    DataType::EnumVariant | DataType::StrValue | DataType::MetadataValue => {\n                        value_set.contains(val)\n                    }\n                    DataType::Number => val.get_num_value().is_some_and(|num_val| {\n                        value_set.iter().any(|ctx_val| {\n                            ctx_val\n                                .get_num_value()\n                                .is_some_and(|ctx_num_val| num_val.fits(&ctx_num_val))\n                        })\n                    }),\n                }\n            }\n        }\n    }\n", "function_name": "check_presence", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "euclid graph node existence check"}, {"query": "rust euclid crate check_presence function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_presence\n    fn check_presence(\n        &self,\n        value: &cgraph::NodeValue<dir::DirValue>,\n        strength: cgraph::Strength,\n    ) -> bool {\n        match value {\n            cgraph::NodeValue::Key(k) => {\n                self.keywise_values.contains_key(k) || matches!(strength, cgraph::Strength::Weak)\n            }\n\n            cgraph::NodeValue::Value(val) => {\n                let key = val.get_key();\n                let value_set = if let Some(set) = self.keywise_values.get(&key) {\n                    set\n                } else {\n                    return matches!(strength, cgraph::Strength::Weak);\n                };\n\n                match key.kind.get_type() {\n                    DataType::EnumVariant | DataType::StrValue | DataType::MetadataValue => {\n                        value_set.contains(val)\n                    }\n                    DataType::Number => val.get_num_value().is_some_and(|num_val| {\n                        value_set.iter().any(|ctx_val| {\n                            ctx_val\n                                .get_num_value()\n                                .is_some_and(|ctx_num_val| num_val.fits(&ctx_num_val))\n                        })\n                    }),\n                }\n            }\n        }\n    }\n", "function_name": "check_presence", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "euclid graph node existence check"}, {"query": "how does check_presence handle numeric value comparisons in the graph", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_presence\n    fn check_presence(\n        &self,\n        value: &cgraph::NodeValue<dir::DirValue>,\n        strength: cgraph::Strength,\n    ) -> bool {\n        match value {\n            cgraph::NodeValue::Key(k) => {\n                self.keywise_values.contains_key(k) || matches!(strength, cgraph::Strength::Weak)\n            }\n\n            cgraph::NodeValue::Value(val) => {\n                let key = val.get_key();\n                let value_set = if let Some(set) = self.keywise_values.get(&key) {\n                    set\n                } else {\n                    return matches!(strength, cgraph::Strength::Weak);\n                };\n\n                match key.kind.get_type() {\n                    DataType::EnumVariant | DataType::StrValue | DataType::MetadataValue => {\n                        value_set.contains(val)\n                    }\n                    DataType::Number => val.get_num_value().is_some_and(|num_val| {\n                        value_set.iter().any(|ctx_val| {\n                            ctx_val\n                                .get_num_value()\n                                .is_some_and(|ctx_num_val| num_val.fits(&ctx_num_val))\n                        })\n                    }),\n                }\n            }\n        }\n    }\n", "function_name": "check_presence", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "euclid graph node existence check"}, {"query": "euclid dssa graph check node value strength and existence", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_presence\n    fn check_presence(\n        &self,\n        value: &cgraph::NodeValue<dir::DirValue>,\n        strength: cgraph::Strength,\n    ) -> bool {\n        match value {\n            cgraph::NodeValue::Key(k) => {\n                self.keywise_values.contains_key(k) || matches!(strength, cgraph::Strength::Weak)\n            }\n\n            cgraph::NodeValue::Value(val) => {\n                let key = val.get_key();\n                let value_set = if let Some(set) = self.keywise_values.get(&key) {\n                    set\n                } else {\n                    return matches!(strength, cgraph::Strength::Weak);\n                };\n\n                match key.kind.get_type() {\n                    DataType::EnumVariant | DataType::StrValue | DataType::MetadataValue => {\n                        value_set.contains(val)\n                    }\n                    DataType::Number => val.get_num_value().is_some_and(|num_val| {\n                        value_set.iter().any(|ctx_val| {\n                            ctx_val\n                                .get_num_value()\n                                .is_some_and(|ctx_num_val| num_val.fits(&ctx_num_val))\n                        })\n                    }),\n                }\n            }\n        }\n    }\n", "function_name": "check_presence", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "euclid graph node existence check"}, {"query": "rust hyperswitch wellsfargo connector build_headers function signature generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let wellsfargo_req = self.get_request_body(req, connectors)?;\n        let auth = wellsfargo::WellsfargoAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.wellsfargo.base_url.as_str();\n        let wellsfargo_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = wellsfargo_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(wellsfargo_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo connector header generation"}, {"query": "how to implement wellsfargo payment gateway authentication in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let wellsfargo_req = self.get_request_body(req, connectors)?;\n        let auth = wellsfargo::WellsfargoAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.wellsfargo.base_url.as_str();\n        let wellsfargo_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = wellsfargo_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(wellsfargo_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo connector header generation"}, {"query": "hyperswitch wellsfargo connector request header generation logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let wellsfargo_req = self.get_request_body(req, connectors)?;\n        let auth = wellsfargo::WellsfargoAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.wellsfargo.base_url.as_str();\n        let wellsfargo_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = wellsfargo_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(wellsfargo_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo connector header generation"}, {"query": "rust code for wellsfargo api signature generation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let wellsfargo_req = self.get_request_body(req, connectors)?;\n        let auth = wellsfargo::WellsfargoAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.wellsfargo.base_url.as_str();\n        let wellsfargo_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = wellsfargo_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(wellsfargo_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo connector header generation"}, {"query": "rust hyperswitch get_intent_status_with_count processor_merchant_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_intent_status_with_count\n    async fn get_intent_status_with_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        profile_id_list: Option<Vec<id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n    ) -> error_stack::Result<Vec<(common_enums::IntentStatus, i64)>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "get_intent_status_with_count", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment intent status count retrieval"}, {"query": "how to count intents by status in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_intent_status_with_count\n    async fn get_intent_status_with_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        profile_id_list: Option<Vec<id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n    ) -> error_stack::Result<Vec<(common_enums::IntentStatus, i64)>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "get_intent_status_with_count", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment intent status count retrieval"}, {"query": "hyperswitch domain models payment intent status count query", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_intent_status_with_count\n    async fn get_intent_status_with_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        profile_id_list: Option<Vec<id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n    ) -> error_stack::Result<Vec<(common_enums::IntentStatus, i64)>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "get_intent_status_with_count", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment intent status count retrieval"}, {"query": "rust hyperswitch get_intent_status_with_count profile_id_list", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_intent_status_with_count\n    async fn get_intent_status_with_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        profile_id_list: Option<Vec<id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n    ) -> error_stack::Result<Vec<(common_enums::IntentStatus, i64)>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "get_intent_status_with_count", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment intent status count retrieval"}, {"query": "how to format Powertranz payments request body in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_convertor,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = powertranz::PowertranzRouterData::try_from((amount, req))?;\n        let connector_req =\n            powertranz::PowertranzPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz request body builder"}, {"query": "convert minor amount to Powertranz format hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_convertor,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = powertranz::PowertranzRouterData::try_from((amount, req))?;\n        let connector_req =\n            powertranz::PowertranzPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz request body builder"}, {"query": "PowertranzPaymentsRequest struct definition hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_convertor,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = powertranz::PowertranzRouterData::try_from((amount, req))?;\n        let connector_req =\n            powertranz::PowertranzPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz request body builder"}, {"query": "hyperswitch powertranz connector request body builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_convertor,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = powertranz::PowertranzRouterData::try_from((amount, req))?;\n        let connector_req =\n            powertranz::PowertranzPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz request body builder"}, {"query": "how to revoke mandate in cybersource connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource mandate revoke URL builder"}, {"query": "cybersource revoke mandate url builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource mandate revoke URL builder"}, {"query": "hyperswitch cybersource mandate revoke endpoint", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource mandate revoke URL builder"}, {"query": "cybersource tms revoke mandate request url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource mandate revoke URL builder"}, {"query": "rust hyperswitch thunes connector build_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector header builder"}, {"query": "how to configure api key headers in hyperswitch thunes connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector header builder"}, {"query": "thunes payment connector hyperswitch rust get_auth_header", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector header builder"}, {"query": "hyperswitch thunes connector header construction logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector header builder"}, {"query": "how to handle scheduled capture method in Authipay connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::Scheduled | enums::CaptureMethod::ManualMultiple => Err(\n                utils::construct_not_implemented_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "function_name": "validate_connector_against_payment_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay capture method validation"}, {"query": "Authipay connector capture_method validation error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::Scheduled | enums::CaptureMethod::ManualMultiple => Err(\n                utils::construct_not_implemented_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "function_name": "validate_connector_against_payment_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay capture method validation"}, {"query": "implementing sequential automatic capture in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::Scheduled | enums::CaptureMethod::ManualMultiple => Err(\n                utils::construct_not_implemented_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "function_name": "validate_connector_against_payment_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay capture method validation"}, {"query": "hyperswitch connector capture method not supported error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::Scheduled | enums::CaptureMethod::ManualMultiple => Err(\n                utils::construct_not_implemented_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "function_name": "validate_connector_against_payment_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay capture method validation"}, {"query": "rust hyperswitch helcim connector build_headers function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim connector header generation"}, {"query": "how to generate idempotency key for helcim hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim connector header generation"}, {"query": "helcim connector hyperswitch rust build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim connector header generation"}, {"query": "hyperswitch helcim idempotency key length 25 characters", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim connector header generation"}, {"query": "how to create a new user with password validation in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n\n        let mut has_upper_case = false;\n        let mut has_lower_case = false;\n        let mut has_numeric_value = false;\n        let mut has_special_character = false;\n        let mut has_whitespace = false;\n\n        for c in password.chars() {\n            has_upper_case = has_upper_case || c.is_uppercase();\n            has_lower_case = has_lower_case || c.is_lowercase();\n            has_numeric_value = has_numeric_value || c.is_numeric();\n            has_special_character = has_special_character || !c.is_alphanumeric();\n            has_whitespace = has_whitespace || c.is_whitespace();\n        }\n\n        let is_password_format_valid = has_upper_case\n            && has_lower_case\n            && has_numeric_value\n            && has_special_character\n            && !has_whitespace;\n\n        let is_too_long = password.graphemes(true).count() > consts::user::MAX_PASSWORD_LENGTH;\n        let is_too_short = password.graphemes(true).count() < consts::user::MIN_PASSWORD_LENGTH;\n\n        if is_too_short || is_too_long || !is_password_format_valid {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User password validation constructor"}, {"query": "hyperswitch user struct password validation logic rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n\n        let mut has_upper_case = false;\n        let mut has_lower_case = false;\n        let mut has_numeric_value = false;\n        let mut has_special_character = false;\n        let mut has_whitespace = false;\n\n        for c in password.chars() {\n            has_upper_case = has_upper_case || c.is_uppercase();\n            has_lower_case = has_lower_case || c.is_lowercase();\n            has_numeric_value = has_numeric_value || c.is_numeric();\n            has_special_character = has_special_character || !c.is_alphanumeric();\n            has_whitespace = has_whitespace || c.is_whitespace();\n        }\n\n        let is_password_format_valid = has_upper_case\n            && has_lower_case\n            && has_numeric_value\n            && has_special_character\n            && !has_whitespace;\n\n        let is_too_long = password.graphemes(true).count() > consts::user::MAX_PASSWORD_LENGTH;\n        let is_too_short = password.graphemes(true).count() < consts::user::MIN_PASSWORD_LENGTH;\n\n        if is_too_short || is_too_long || !is_password_format_valid {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User password validation constructor"}, {"query": "rust password complexity check in hyperswitch user module", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n\n        let mut has_upper_case = false;\n        let mut has_lower_case = false;\n        let mut has_numeric_value = false;\n        let mut has_special_character = false;\n        let mut has_whitespace = false;\n\n        for c in password.chars() {\n            has_upper_case = has_upper_case || c.is_uppercase();\n            has_lower_case = has_lower_case || c.is_lowercase();\n            has_numeric_value = has_numeric_value || c.is_numeric();\n            has_special_character = has_special_character || !c.is_alphanumeric();\n            has_whitespace = has_whitespace || c.is_whitespace();\n        }\n\n        let is_password_format_valid = has_upper_case\n            && has_lower_case\n            && has_numeric_value\n            && has_special_character\n            && !has_whitespace;\n\n        let is_too_long = password.graphemes(true).count() > consts::user::MAX_PASSWORD_LENGTH;\n        let is_too_short = password.graphemes(true).count() < consts::user::MIN_PASSWORD_LENGTH;\n\n        if is_too_short || is_too_long || !is_password_format_valid {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User password validation constructor"}, {"query": "hyperswitch consts user max password length validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n\n        let mut has_upper_case = false;\n        let mut has_lower_case = false;\n        let mut has_numeric_value = false;\n        let mut has_special_character = false;\n        let mut has_whitespace = false;\n\n        for c in password.chars() {\n            has_upper_case = has_upper_case || c.is_uppercase();\n            has_lower_case = has_lower_case || c.is_lowercase();\n            has_numeric_value = has_numeric_value || c.is_numeric();\n            has_special_character = has_special_character || !c.is_alphanumeric();\n            has_whitespace = has_whitespace || c.is_whitespace();\n        }\n\n        let is_password_format_valid = has_upper_case\n            && has_lower_case\n            && has_numeric_value\n            && has_special_character\n            && !has_whitespace;\n\n        let is_too_long = password.graphemes(true).count() > consts::user::MAX_PASSWORD_LENGTH;\n        let is_too_short = password.graphemes(true).count() < consts::user::MIN_PASSWORD_LENGTH;\n\n        if is_too_short || is_too_long || !is_password_format_valid {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User password validation constructor"}, {"query": "rust function to sign amazon pay request with rsa pss sha256", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: sign\n    fn sign(\n        private_key_pem_str: &Secret<String>,\n        string_to_sign: &String,\n    ) -> Result<String, String> {\n        let rsa_pss_sha256_signer = RsaPssSha256;\n        let signature_bytes = rsa_pss_sha256_signer\n            .sign_message(\n                private_key_pem_str.peek().as_bytes(),\n                string_to_sign.as_bytes(),\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)\n            .map_err(|e| format!(\"Crypto operation failed: {e:?}\"))?;\n\n        Ok(STANDARD.encode(signature_bytes))\n    }\n}\n", "function_name": "sign", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay RSA-PSS Signer"}, {"query": "hyperswitch amazonpay connector sign method implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: sign\n    fn sign(\n        private_key_pem_str: &Secret<String>,\n        string_to_sign: &String,\n    ) -> Result<String, String> {\n        let rsa_pss_sha256_signer = RsaPssSha256;\n        let signature_bytes = rsa_pss_sha256_signer\n            .sign_message(\n                private_key_pem_str.peek().as_bytes(),\n                string_to_sign.as_bytes(),\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)\n            .map_err(|e| format!(\"Crypto operation failed: {e:?}\"))?;\n\n        Ok(STANDARD.encode(signature_bytes))\n    }\n}\n", "function_name": "sign", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay RSA-PSS Signer"}, {"query": "how to generate signature for amazon pay api in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: sign\n    fn sign(\n        private_key_pem_str: &Secret<String>,\n        string_to_sign: &String,\n    ) -> Result<String, String> {\n        let rsa_pss_sha256_signer = RsaPssSha256;\n        let signature_bytes = rsa_pss_sha256_signer\n            .sign_message(\n                private_key_pem_str.peek().as_bytes(),\n                string_to_sign.as_bytes(),\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)\n            .map_err(|e| format!(\"Crypto operation failed: {e:?}\"))?;\n\n        Ok(STANDARD.encode(signature_bytes))\n    }\n}\n", "function_name": "sign", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay RSA-PSS Signer"}, {"query": "rsa_pss_sha256 sign_message function amazonpay hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: sign\n    fn sign(\n        private_key_pem_str: &Secret<String>,\n        string_to_sign: &String,\n    ) -> Result<String, String> {\n        let rsa_pss_sha256_signer = RsaPssSha256;\n        let signature_bytes = rsa_pss_sha256_signer\n            .sign_message(\n                private_key_pem_str.peek().as_bytes(),\n                string_to_sign.as_bytes(),\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)\n            .map_err(|e| format!(\"Crypto operation failed: {e:?}\"))?;\n\n        Ok(STANDARD.encode(signature_bytes))\n    }\n}\n", "function_name": "sign", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay RSA-PSS Signer"}, {"query": "rust hyperswitch AuthoriseIntegrityObject struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthoriseIntegrityObject\npub struct AuthoriseIntegrityObject {\n    /// Authorise amount\n    pub amount: MinorUnit,\n    /// Authorise currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "AuthoriseIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Payment Authorization Parameters"}, {"query": "how to define authorization amount and currency in hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthoriseIntegrityObject\npub struct AuthoriseIntegrityObject {\n    /// Authorise amount\n    pub amount: MinorUnit,\n    /// Authorise currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "AuthoriseIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Payment Authorization Parameters"}, {"query": "hyperswitch router request types AuthoriseIntegrityObject fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthoriseIntegrityObject\npub struct AuthoriseIntegrityObject {\n    /// Authorise amount\n    pub amount: MinorUnit,\n    /// Authorise currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "AuthoriseIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Payment Authorization Parameters"}, {"query": "rust struct for payment authorization parameters hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthoriseIntegrityObject\npub struct AuthoriseIntegrityObject {\n    /// Authorise amount\n    pub amount: MinorUnit,\n    /// Authorise currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "AuthoriseIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "Payment Authorization Parameters"}, {"query": "how to initialize storage interfaces for multiple tenants in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_store_interface_map\n    pub async fn get_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::StorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    /// # Panics\n    ///\n    /// Panics if Failed to create event handler", "function_name": "get_store_interface_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Multi-tenant storage initialization"}, {"query": "hyperswitch router get_store_interface_map implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_store_interface_map\n    pub async fn get_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::StorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    /// # Panics\n    ///\n    /// Panics if Failed to create event handler", "function_name": "get_store_interface_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Multi-tenant storage initialization"}, {"query": "async initialization of storage adapters in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_store_interface_map\n    pub async fn get_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::StorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    /// # Panics\n    ///\n    /// Panics if Failed to create event handler", "function_name": "get_store_interface_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Multi-tenant storage initialization"}, {"query": "how does router crate handle tenant storage mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_store_interface_map\n    pub async fn get_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::StorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    /// # Panics\n    ///\n    /// Panics if Failed to create event handler", "function_name": "get_store_interface_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Multi-tenant storage initialization"}, {"query": "rust hyperswitch gpayments connector integration not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gpayments\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gpayments\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "Gpayments Connector Integration"}, {"query": "hyperswitch gpayments tokenization payments response data trait", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gpayments\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gpayments\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "Gpayments Connector Integration"}, {"query": "gpayments connector implementation status rust hyperswitch_connectors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gpayments\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gpayments\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "Gpayments Connector Integration"}, {"query": "hyperswitch gpayments payment method tokenization data flow", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gpayments\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gpayments\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "Gpayments Connector Integration"}, {"query": "how to generate authorization token for worldline connector rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: generate_authorization_token\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n", "function_name": "generate_authorization_token", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline auth token generation"}, {"query": "hyperswitch worldline connector hmac signature generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: generate_authorization_token\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n", "function_name": "generate_authorization_token", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline auth token generation"}, {"query": "rust function generate_authorization_token worldline hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: generate_authorization_token\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n", "function_name": "generate_authorization_token", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline auth token generation"}, {"query": "worldline api authentication hyperswitch rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: generate_authorization_token\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n", "function_name": "generate_authorization_token", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline auth token generation"}, {"query": "Rust struct definition for ExternalVaultProxyPaymentsData", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ExternalVaultProxyPaymentsData\npub struct ExternalVaultProxyPaymentsData {\n    pub payment_method_data: ExternalVaultPaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub statement_descriptor_suffix: Option<String>,\n    pub statement_descriptor: Option<String>,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n \n\n... [truncated 180 chars] ...\n\nference.\n    pub merchant_order_reference_id: Option<id_type::PaymentReferenceId>,\n    pub integrity_object: Option<AuthoriseIntegrityObject>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub additional_payment_method_data: Option<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n}\n\n// Note: Integrity traits for ExternalVaultProxyPaymentsData are not implemented\n// as they are not mandatory for this flow. The integrity_check field in RouterData\n// will use Ok(()) as default, similar to other flows.\n\n// Implement ConnectorCustomerData conversion for ExternalVaultProxy RouterData\nimpl\n    TryFrom<\n        &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    > for ConnectorCustomerData\n{\n    type Error = error_stack::Report<ApiErrorResponse>;\n", "function_name": "ExternalVaultProxyPaymentsData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "ExternalVaultProxyPaymentsData struct"}, {"query": "Hyperswitch router ExternalVaultProxyPaymentsData fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ExternalVaultProxyPaymentsData\npub struct ExternalVaultProxyPaymentsData {\n    pub payment_method_data: ExternalVaultPaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub statement_descriptor_suffix: Option<String>,\n    pub statement_descriptor: Option<String>,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n \n\n... [truncated 180 chars] ...\n\nference.\n    pub merchant_order_reference_id: Option<id_type::PaymentReferenceId>,\n    pub integrity_object: Option<AuthoriseIntegrityObject>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub additional_payment_method_data: Option<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n}\n\n// Note: Integrity traits for ExternalVaultProxyPaymentsData are not implemented\n// as they are not mandatory for this flow. The integrity_check field in RouterData\n// will use Ok(()) as default, similar to other flows.\n\n// Implement ConnectorCustomerData conversion for ExternalVaultProxy RouterData\nimpl\n    TryFrom<\n        &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    > for ConnectorCustomerData\n{\n    type Error = error_stack::Report<ApiErrorResponse>;\n", "function_name": "ExternalVaultProxyPaymentsData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "ExternalVaultProxyPaymentsData struct"}, {"query": "ExternalVaultProxyPaymentsData TryFrom implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ExternalVaultProxyPaymentsData\npub struct ExternalVaultProxyPaymentsData {\n    pub payment_method_data: ExternalVaultPaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub statement_descriptor_suffix: Option<String>,\n    pub statement_descriptor: Option<String>,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n \n\n... [truncated 180 chars] ...\n\nference.\n    pub merchant_order_reference_id: Option<id_type::PaymentReferenceId>,\n    pub integrity_object: Option<AuthoriseIntegrityObject>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub additional_payment_method_data: Option<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n}\n\n// Note: Integrity traits for ExternalVaultProxyPaymentsData are not implemented\n// as they are not mandatory for this flow. The integrity_check field in RouterData\n// will use Ok(()) as default, similar to other flows.\n\n// Implement ConnectorCustomerData conversion for ExternalVaultProxy RouterData\nimpl\n    TryFrom<\n        &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    > for ConnectorCustomerData\n{\n    type Error = error_stack::Report<ApiErrorResponse>;\n", "function_name": "ExternalVaultProxyPaymentsData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "ExternalVaultProxyPaymentsData struct"}, {"query": "ExternalVaultProxyPaymentsData struct fields and types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ExternalVaultProxyPaymentsData\npub struct ExternalVaultProxyPaymentsData {\n    pub payment_method_data: ExternalVaultPaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub statement_descriptor_suffix: Option<String>,\n    pub statement_descriptor: Option<String>,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n \n\n... [truncated 180 chars] ...\n\nference.\n    pub merchant_order_reference_id: Option<id_type::PaymentReferenceId>,\n    pub integrity_object: Option<AuthoriseIntegrityObject>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub additional_payment_method_data: Option<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n}\n\n// Note: Integrity traits for ExternalVaultProxyPaymentsData are not implemented\n// as they are not mandatory for this flow. The integrity_check field in RouterData\n// will use Ok(()) as default, similar to other flows.\n\n// Implement ConnectorCustomerData conversion for ExternalVaultProxy RouterData\nimpl\n    TryFrom<\n        &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    > for ConnectorCustomerData\n{\n    type Error = error_stack::Report<ApiErrorResponse>;\n", "function_name": "ExternalVaultProxyPaymentsData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "ExternalVaultProxyPaymentsData struct"}, {"query": "rust hyperswitch get_filtered_payment_intents_attempt implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_payment_intents_attempt\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<(PaymentIntent, PaymentAttempt)>, Self::Error>;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]", "function_name": "get_filtered_payment_intents_attempt", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment intent attempt retrieval filter"}, {"query": "how to fetch payment attempts by merchant id in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_payment_intents_attempt\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<(PaymentIntent, PaymentAttempt)>, Self::Error>;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]", "function_name": "get_filtered_payment_intents_attempt", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment intent attempt retrieval filter"}, {"query": "hyperswitch domain models payment intent fetch constraints", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_payment_intents_attempt\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<(PaymentIntent, PaymentAttempt)>, Self::Error>;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]", "function_name": "get_filtered_payment_intents_attempt", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment intent attempt retrieval filter"}, {"query": "rust hyperswitch payment intent attempt retrieval function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_payment_intents_attempt\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<(PaymentIntent, PaymentAttempt)>, Self::Error>;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]", "function_name": "get_filtered_payment_intents_attempt", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Payment intent attempt retrieval filter"}, {"query": "rust hyperswitch connector auth type parsing error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_option_secret_value\n    pub fn from_option_secret_value(\n        value: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n", "function_name": "from_option_secret_value", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType deserialization"}, {"query": "how to deserialize connector auth type from secret value", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_option_secret_value\n    pub fn from_option_secret_value(\n        value: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n", "function_name": "from_option_secret_value", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType deserialization"}, {"query": "hyperswitch domain models connector auth parsing", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_option_secret_value\n    pub fn from_option_secret_value(\n        value: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n", "function_name": "from_option_secret_value", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType deserialization"}, {"query": "rust change_context parsing error connector auth", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_option_secret_value\n    pub fn from_option_secret_value(\n        value: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n", "function_name": "from_option_secret_value", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType deserialization"}, {"query": "how to configure base_url for Authipay connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}payments\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector base_url configuration"}, {"query": "Authipay connector get_url function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}payments\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector base_url configuration"}, {"query": "hyperswitch Authipay payments endpoint configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}payments\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector base_url configuration"}, {"query": "Authipay connector base_url payments path", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}payments\", self.base_url(connectors)))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay connector base_url configuration"}, {"query": "rust hyperswitch connector auth type parsing error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_secret_value\n    pub fn from_secret_value(\n        value: common_utils::pii::SecretSerdeValue,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n\n    // show only first and last two digits of the key and mask others with *\n    // mask the entire key if it's length is less than or equal to 4", "function_name": "from_secret_value", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType parsing"}, {"query": "how to deserialize connector auth type from secret value", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_secret_value\n    pub fn from_secret_value(\n        value: common_utils::pii::SecretSerdeValue,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n\n    // show only first and last two digits of the key and mask others with *\n    // mask the entire key if it's length is less than or equal to 4", "function_name": "from_secret_value", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType parsing"}, {"query": "hyperswitch domain models connector auth parsing", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_secret_value\n    pub fn from_secret_value(\n        value: common_utils::pii::SecretSerdeValue,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n\n    // show only first and last two digits of the key and mask others with *\n    // mask the entire key if it's length is less than or equal to 4", "function_name": "from_secret_value", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType parsing"}, {"query": "rust hyperswitch parsing error struct parse failure connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_secret_value\n    pub fn from_secret_value(\n        value: common_utils::pii::SecretSerdeValue,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n\n    // show only first and last two digits of the key and mask others with *\n    // mask the entire key if it's length is less than or equal to 4", "function_name": "from_secret_value", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "ConnectorAuthType parsing"}, {"query": "how to get gigadat payment token url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}api/payment-token/{}\",\n            self.base_url(connectors),\n            auth.campaign_id.peek()\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat token endpoint builder"}, {"query": "gigadat connector authorization endpoint rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}api/payment-token/{}\",\n            self.base_url(connectors),\n            auth.campaign_id.peek()\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat token endpoint builder"}, {"query": "hyperswitch gigadat get_url function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}api/payment-token/{}\",\n            self.base_url(connectors),\n            auth.campaign_id.peek()\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat token endpoint builder"}, {"query": "gigadat campaign_id url construction hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}api/payment-token/{}\",\n            self.base_url(connectors),\n            auth.campaign_id.peek()\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat token endpoint builder"}, {"query": "Rust struct definition for MandateRequest in PayMe connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: MandateRequest\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "MandateRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe Mandate Request Struct"}, {"query": "hyperswitch PayMe mandate request fields currency transaction_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: MandateRequest\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "MandateRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe Mandate Request Struct"}, {"query": "how to construct MandateRequest for PayMe integration hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: MandateRequest\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "MandateRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe Mandate Request Struct"}, {"query": "PayMe connector mandate request struct hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: MandateRequest\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "MandateRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe Mandate Request Struct"}, {"query": "How to set access token for UCS in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: set_access_token_for_ucs\npub async fn set_access_token_for_ucs(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    access_token: AccessToken,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n) -> Result<(), errors::StorageError> {\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        &merchant_connector_id_or_connector_name,\n    );\n\n    let modified_access_token = AccessToken {\n        expires: access_token\n            .expires\n            .saturating_sub(consts::REDUCE_ACCESS_TOKEN_EXPIRY_TIME.into()),\n        ..access_token\n    };\n\n    logger::debug!(\n        access_token_expiry_after_modification = modified_access_token.expires,\n        merchant_id = ?merchant_id,\n        connector_name = connector_name,\n        merchant_connector_id_or_connector_name = merchant_connector_id_or_connector_name\n    );\n\n    if let Err(access_token_set_error) = state\n        .store\n        .set_access_token(key, modified_access_token)\n        .await\n    {\n        // If we are not able to set the access token in redis, the error should just be logged and proceed with the payment\n        // Payments should not fail, once the access token is successfully created\n        // The next request will create new access token, if required\n        logger::error!(access_token_set_error=?access_token_set_error, \"Failed to store UCS access token\");\n    }\n\n    Ok(())\n}\n\n// Re-export webhook transformer types for easier access\npub use transformers::{WebhookTransformData, WebhookTransformationStatus};\n\n/// Type alias for return type used by unified connector service response handlers\ntype UnifiedConnectorServiceResult = CustomResult<\n    (\n        Result<(PaymentsResponseData, AttemptStatus), ErrorResponse>,\n        u16,\n    ),\n    UnifiedConnectorServiceError,\n>;\n\n/// Type alias for return type used by unified connector service refund response handlers\ntype UnifiedConnectorServiceRefundResult =\n    CustomResult<(Result<RefundsResponseData, ErrorResponse>, u16), UnifiedConnectorServiceError>;\n\n/// Checks if the Unified Connector Service (UCS) is available for use", "function_name": "set_access_token_for_ucs", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS access token management"}, {"query": "hyperswitch router set_access_token_for_ucs function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: set_access_token_for_ucs\npub async fn set_access_token_for_ucs(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    access_token: AccessToken,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n) -> Result<(), errors::StorageError> {\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        &merchant_connector_id_or_connector_name,\n    );\n\n    let modified_access_token = AccessToken {\n        expires: access_token\n            .expires\n            .saturating_sub(consts::REDUCE_ACCESS_TOKEN_EXPIRY_TIME.into()),\n        ..access_token\n    };\n\n    logger::debug!(\n        access_token_expiry_after_modification = modified_access_token.expires,\n        merchant_id = ?merchant_id,\n        connector_name = connector_name,\n        merchant_connector_id_or_connector_name = merchant_connector_id_or_connector_name\n    );\n\n    if let Err(access_token_set_error) = state\n        .store\n        .set_access_token(key, modified_access_token)\n        .await\n    {\n        // If we are not able to set the access token in redis, the error should just be logged and proceed with the payment\n        // Payments should not fail, once the access token is successfully created\n        // The next request will create new access token, if required\n        logger::error!(access_token_set_error=?access_token_set_error, \"Failed to store UCS access token\");\n    }\n\n    Ok(())\n}\n\n// Re-export webhook transformer types for easier access\npub use transformers::{WebhookTransformData, WebhookTransformationStatus};\n\n/// Type alias for return type used by unified connector service response handlers\ntype UnifiedConnectorServiceResult = CustomResult<\n    (\n        Result<(PaymentsResponseData, AttemptStatus), ErrorResponse>,\n        u16,\n    ),\n    UnifiedConnectorServiceError,\n>;\n\n/// Type alias for return type used by unified connector service refund response handlers\ntype UnifiedConnectorServiceRefundResult =\n    CustomResult<(Result<RefundsResponseData, ErrorResponse>, u16), UnifiedConnectorServiceError>;\n\n/// Checks if the Unified Connector Service (UCS) is available for use", "function_name": "set_access_token_for_ucs", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS access token management"}, {"query": "Rust function to update UCS access token expiry time", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: set_access_token_for_ucs\npub async fn set_access_token_for_ucs(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    access_token: AccessToken,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n) -> Result<(), errors::StorageError> {\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        &merchant_connector_id_or_connector_name,\n    );\n\n    let modified_access_token = AccessToken {\n        expires: access_token\n            .expires\n            .saturating_sub(consts::REDUCE_ACCESS_TOKEN_EXPIRY_TIME.into()),\n        ..access_token\n    };\n\n    logger::debug!(\n        access_token_expiry_after_modification = modified_access_token.expires,\n        merchant_id = ?merchant_id,\n        connector_name = connector_name,\n        merchant_connector_id_or_connector_name = merchant_connector_id_or_connector_name\n    );\n\n    if let Err(access_token_set_error) = state\n        .store\n        .set_access_token(key, modified_access_token)\n        .await\n    {\n        // If we are not able to set the access token in redis, the error should just be logged and proceed with the payment\n        // Payments should not fail, once the access token is successfully created\n        // The next request will create new access token, if required\n        logger::error!(access_token_set_error=?access_token_set_error, \"Failed to store UCS access token\");\n    }\n\n    Ok(())\n}\n\n// Re-export webhook transformer types for easier access\npub use transformers::{WebhookTransformData, WebhookTransformationStatus};\n\n/// Type alias for return type used by unified connector service response handlers\ntype UnifiedConnectorServiceResult = CustomResult<\n    (\n        Result<(PaymentsResponseData, AttemptStatus), ErrorResponse>,\n        u16,\n    ),\n    UnifiedConnectorServiceError,\n>;\n\n/// Type alias for return type used by unified connector service refund response handlers\ntype UnifiedConnectorServiceRefundResult =\n    CustomResult<(Result<RefundsResponseData, ErrorResponse>, u16), UnifiedConnectorServiceError>;\n\n/// Checks if the Unified Connector Service (UCS) is available for use", "function_name": "set_access_token_for_ucs", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS access token management"}, {"query": "hyperswitch router merchant connector id access token storage", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: set_access_token_for_ucs\npub async fn set_access_token_for_ucs(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    access_token: AccessToken,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n) -> Result<(), errors::StorageError> {\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        &merchant_connector_id_or_connector_name,\n    );\n\n    let modified_access_token = AccessToken {\n        expires: access_token\n            .expires\n            .saturating_sub(consts::REDUCE_ACCESS_TOKEN_EXPIRY_TIME.into()),\n        ..access_token\n    };\n\n    logger::debug!(\n        access_token_expiry_after_modification = modified_access_token.expires,\n        merchant_id = ?merchant_id,\n        connector_name = connector_name,\n        merchant_connector_id_or_connector_name = merchant_connector_id_or_connector_name\n    );\n\n    if let Err(access_token_set_error) = state\n        .store\n        .set_access_token(key, modified_access_token)\n        .await\n    {\n        // If we are not able to set the access token in redis, the error should just be logged and proceed with the payment\n        // Payments should not fail, once the access token is successfully created\n        // The next request will create new access token, if required\n        logger::error!(access_token_set_error=?access_token_set_error, \"Failed to store UCS access token\");\n    }\n\n    Ok(())\n}\n\n// Re-export webhook transformer types for easier access\npub use transformers::{WebhookTransformData, WebhookTransformationStatus};\n\n/// Type alias for return type used by unified connector service response handlers\ntype UnifiedConnectorServiceResult = CustomResult<\n    (\n        Result<(PaymentsResponseData, AttemptStatus), ErrorResponse>,\n        u16,\n    ),\n    UnifiedConnectorServiceError,\n>;\n\n/// Type alias for return type used by unified connector service refund response handlers\ntype UnifiedConnectorServiceRefundResult =\n    CustomResult<(Result<RefundsResponseData, ErrorResponse>, u16), UnifiedConnectorServiceError>;\n\n/// Checks if the Unified Connector Service (UCS) is available for use", "function_name": "set_access_token_for_ucs", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS access token management"}, {"query": "Amazon Pay tokenization implementation hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Amazonpay\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Amazonpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay connector trait implementation"}, {"query": "hyperswitch amazonpay connector trait integration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Amazonpay\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Amazonpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay connector trait implementation"}, {"query": "rust connector integration amazonpay tokenization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Amazonpay\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Amazonpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay connector trait implementation"}, {"query": "hyperswitch payment orchestration amazonpay connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Amazonpay\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Amazonpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay connector trait implementation"}, {"query": "Archipel3DS struct definition rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: Archipel3DS\npub struct Archipel3DS {\n    #[serde(rename = \"acsTransID\")]\n    acs_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"dsTransID\")]\n    ds_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"3DSRequestorName\")]\n    three_ds_requestor_name: Option<Secret<String>>,\n    #[serde(rename = \"3DSAuthDate\")]\n    three_ds_auth_date: Option<String>,\n    #[serde(rename = \"3DSAuthAmt\")]\n    three_ds_auth_amt: Option<MinorUnit>,\n    #[serde(rename = \"3DSAuthStatus\")]\n    three_ds_auth_status: Option<String>,\n    #[serde(rename = \"3DSMaxSupportedVersion\")]\n    three_ds_max_supported_version: String,\n    #[serde(rename = \"3DSVersion\")]\n    three_ds_version: Option<common_utils::types::SemanticVersion>,\n    authentication_value: Secret<String>,\n    authentication_method: Option<Secret<String>>,\n    eci: Option<String>,\n}\n", "function_name": "Archipel3DS", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel 3DS Response Model"}, {"query": "how to parse Archipel 3DS response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: Archipel3DS\npub struct Archipel3DS {\n    #[serde(rename = \"acsTransID\")]\n    acs_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"dsTransID\")]\n    ds_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"3DSRequestorName\")]\n    three_ds_requestor_name: Option<Secret<String>>,\n    #[serde(rename = \"3DSAuthDate\")]\n    three_ds_auth_date: Option<String>,\n    #[serde(rename = \"3DSAuthAmt\")]\n    three_ds_auth_amt: Option<MinorUnit>,\n    #[serde(rename = \"3DSAuthStatus\")]\n    three_ds_auth_status: Option<String>,\n    #[serde(rename = \"3DSMaxSupportedVersion\")]\n    three_ds_max_supported_version: String,\n    #[serde(rename = \"3DSVersion\")]\n    three_ds_version: Option<common_utils::types::SemanticVersion>,\n    authentication_value: Secret<String>,\n    authentication_method: Option<Secret<String>>,\n    eci: Option<String>,\n}\n", "function_name": "Archipel3DS", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel 3DS Response Model"}, {"query": "hyperswitch archipel connector 3ds authentication fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: Archipel3DS\npub struct Archipel3DS {\n    #[serde(rename = \"acsTransID\")]\n    acs_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"dsTransID\")]\n    ds_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"3DSRequestorName\")]\n    three_ds_requestor_name: Option<Secret<String>>,\n    #[serde(rename = \"3DSAuthDate\")]\n    three_ds_auth_date: Option<String>,\n    #[serde(rename = \"3DSAuthAmt\")]\n    three_ds_auth_amt: Option<MinorUnit>,\n    #[serde(rename = \"3DSAuthStatus\")]\n    three_ds_auth_status: Option<String>,\n    #[serde(rename = \"3DSMaxSupportedVersion\")]\n    three_ds_max_supported_version: String,\n    #[serde(rename = \"3DSVersion\")]\n    three_ds_version: Option<common_utils::types::SemanticVersion>,\n    authentication_value: Secret<String>,\n    authentication_method: Option<Secret<String>>,\n    eci: Option<String>,\n}\n", "function_name": "Archipel3DS", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel 3DS Response Model"}, {"query": "rust struct Archipel3DS serde fields hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: Archipel3DS\npub struct Archipel3DS {\n    #[serde(rename = \"acsTransID\")]\n    acs_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"dsTransID\")]\n    ds_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"3DSRequestorName\")]\n    three_ds_requestor_name: Option<Secret<String>>,\n    #[serde(rename = \"3DSAuthDate\")]\n    three_ds_auth_date: Option<String>,\n    #[serde(rename = \"3DSAuthAmt\")]\n    three_ds_auth_amt: Option<MinorUnit>,\n    #[serde(rename = \"3DSAuthStatus\")]\n    three_ds_auth_status: Option<String>,\n    #[serde(rename = \"3DSMaxSupportedVersion\")]\n    three_ds_max_supported_version: String,\n    #[serde(rename = \"3DSVersion\")]\n    three_ds_version: Option<common_utils::types::SemanticVersion>,\n    authentication_value: Secret<String>,\n    authentication_method: Option<Secret<String>>,\n    eci: Option<String>,\n}\n", "function_name": "Archipel3DS", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel 3DS Response Model"}, {"query": "rust hyperswitch tokenex connector get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex auth header generation"}, {"query": "how to configure authorization header for tokenex in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex auth header generation"}, {"query": "hyperswitch tokenex connector api key masking get_auth_header", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex auth header generation"}, {"query": "rust hyperswitch tokenex connector authentication header generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex auth header generation"}, {"query": "how to filter refunds by status and amount in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_constraints\n    async fn filter_refund_by_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n        limit: i64,\n        offset: i64,\n    ) -> CustomResult<Vec<diesel_models::refund::Refund>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_refund_by_constraints", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "refund list filtering logic"}, {"query": "hyperswitch router refund list constraints implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_constraints\n    async fn filter_refund_by_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n        limit: i64,\n        offset: i64,\n    ) -> CustomResult<Vec<diesel_models::refund::Refund>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_refund_by_constraints", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "refund list filtering logic"}, {"query": "rust function to query refunds by merchant id and pagination", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_constraints\n    async fn filter_refund_by_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n        limit: i64,\n        offset: i64,\n    ) -> CustomResult<Vec<diesel_models::refund::Refund>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_refund_by_constraints", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "refund list filtering logic"}, {"query": "hyperswitch db refund filtering logic storage scheme", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_constraints\n    async fn filter_refund_by_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n        limit: i64,\n        offset: i64,\n    ) -> CustomResult<Vec<diesel_models::refund::Refund>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "filter_refund_by_constraints", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "refund list filtering logic"}, {"query": "rust hyperswitch create user entity with email validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(email: Secret<String, pii::EmailStrategy>) -> UserResult<Self> {\n        use validator::ValidateEmail;\n\n        let email_string = email.expose().to_lowercase();\n        let email =\n            pii::Email::from_str(&email_string).change_context(UserErrors::EmailParsingError)?;\n\n        if email_string.validate_email() {\n            let (_username, domain) = match email_string.as_str().split_once('@') {\n                Some((u, d)) => (u, d),\n                None => return Err(UserErrors::EmailParsingError.into()),\n            };\n\n            if BLOCKED_EMAIL.contains(domain) {\n                return Err(UserErrors::InvalidEmailError.into());\n            }\n            Ok(Self(email))\n        } else {\n            Err(UserErrors::EmailParsingError.into())\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User entity email constructor"}, {"query": "hyperswitch user constructor blocked email check", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(email: Secret<String, pii::EmailStrategy>) -> UserResult<Self> {\n        use validator::ValidateEmail;\n\n        let email_string = email.expose().to_lowercase();\n        let email =\n            pii::Email::from_str(&email_string).change_context(UserErrors::EmailParsingError)?;\n\n        if email_string.validate_email() {\n            let (_username, domain) = match email_string.as_str().split_once('@') {\n                Some((u, d)) => (u, d),\n                None => return Err(UserErrors::EmailParsingError.into()),\n            };\n\n            if BLOCKED_EMAIL.contains(domain) {\n                return Err(UserErrors::InvalidEmailError.into());\n            }\n            Ok(Self(email))\n        } else {\n            Err(UserErrors::EmailParsingError.into())\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User entity email constructor"}, {"query": "how to initialize User struct with email in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(email: Secret<String, pii::EmailStrategy>) -> UserResult<Self> {\n        use validator::ValidateEmail;\n\n        let email_string = email.expose().to_lowercase();\n        let email =\n            pii::Email::from_str(&email_string).change_context(UserErrors::EmailParsingError)?;\n\n        if email_string.validate_email() {\n            let (_username, domain) = match email_string.as_str().split_once('@') {\n                Some((u, d)) => (u, d),\n                None => return Err(UserErrors::EmailParsingError.into()),\n            };\n\n            if BLOCKED_EMAIL.contains(domain) {\n                return Err(UserErrors::InvalidEmailError.into());\n            }\n            Ok(Self(email))\n        } else {\n            Err(UserErrors::EmailParsingError.into())\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User entity email constructor"}, {"query": "rust hyperswitch pii email strategy new function", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(email: Secret<String, pii::EmailStrategy>) -> UserResult<Self> {\n        use validator::ValidateEmail;\n\n        let email_string = email.expose().to_lowercase();\n        let email =\n            pii::Email::from_str(&email_string).change_context(UserErrors::EmailParsingError)?;\n\n        if email_string.validate_email() {\n            let (_username, domain) = match email_string.as_str().split_once('@') {\n                Some((u, d)) => (u, d),\n                None => return Err(UserErrors::EmailParsingError.into()),\n            };\n\n            if BLOCKED_EMAIL.contains(domain) {\n                return Err(UserErrors::InvalidEmailError.into());\n            }\n            Ok(Self(email))\n        } else {\n            Err(UserErrors::EmailParsingError.into())\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User entity email constructor"}, {"query": "how to configure external vault connector details in business profile", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: try_from\n    fn try_from(\n        item: (\n            Option<common_enums::ExternalVaultEnabled>,\n            Option<ExternalVaultConnectorDetails>,\n        ),\n    ) -> Result<Self, Self::Error> {\n        match item {\n            (is_external_vault_enabled, external_vault_connector_details)\n                if is_external_vault_enabled\n                    .unwrap_or(common_enums::ExternalVaultEnabled::Skip)\n                    == common_enums::ExternalVaultEnabled::Enable =>\n            {\n                Ok(Self::ExternalVaultEnabled(\n                    external_vault_connector_details\n                        .get_required_value(\"ExternalVaultConnectorDetails\")?,\n                ))\n            }\n            _ => Ok(Self::Skip),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ExternalVaultEnabled conversion logic"}, {"query": "rust try_from implementation for external vault enabled enum", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: try_from\n    fn try_from(\n        item: (\n            Option<common_enums::ExternalVaultEnabled>,\n            Option<ExternalVaultConnectorDetails>,\n        ),\n    ) -> Result<Self, Self::Error> {\n        match item {\n            (is_external_vault_enabled, external_vault_connector_details)\n                if is_external_vault_enabled\n                    .unwrap_or(common_enums::ExternalVaultEnabled::Skip)\n                    == common_enums::ExternalVaultEnabled::Enable =>\n            {\n                Ok(Self::ExternalVaultEnabled(\n                    external_vault_connector_details\n                        .get_required_value(\"ExternalVaultConnectorDetails\")?,\n                ))\n            }\n            _ => Ok(Self::Skip),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ExternalVaultEnabled conversion logic"}, {"query": "hyperswitch business profile external vault configuration logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: try_from\n    fn try_from(\n        item: (\n            Option<common_enums::ExternalVaultEnabled>,\n            Option<ExternalVaultConnectorDetails>,\n        ),\n    ) -> Result<Self, Self::Error> {\n        match item {\n            (is_external_vault_enabled, external_vault_connector_details)\n                if is_external_vault_enabled\n                    .unwrap_or(common_enums::ExternalVaultEnabled::Skip)\n                    == common_enums::ExternalVaultEnabled::Enable =>\n            {\n                Ok(Self::ExternalVaultEnabled(\n                    external_vault_connector_details\n                        .get_required_value(\"ExternalVaultConnectorDetails\")?,\n                ))\n            }\n            _ => Ok(Self::Skip),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ExternalVaultEnabled conversion logic"}, {"query": "convert external vault settings to business profile skip or enable", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: try_from\n    fn try_from(\n        item: (\n            Option<common_enums::ExternalVaultEnabled>,\n            Option<ExternalVaultConnectorDetails>,\n        ),\n    ) -> Result<Self, Self::Error> {\n        match item {\n            (is_external_vault_enabled, external_vault_connector_details)\n                if is_external_vault_enabled\n                    .unwrap_or(common_enums::ExternalVaultEnabled::Skip)\n                    == common_enums::ExternalVaultEnabled::Enable =>\n            {\n                Ok(Self::ExternalVaultEnabled(\n                    external_vault_connector_details\n                        .get_required_value(\"ExternalVaultConnectorDetails\")?,\n                ))\n            }\n            _ => Ok(Self::Skip),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ExternalVaultEnabled conversion logic"}, {"query": "Elavon PaymentsCaptureRequest struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: PaymentsCaptureRequest\npub struct PaymentsCaptureRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_txn_id: String,\n}\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "function_name": "PaymentsCaptureRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon Capture Request Struct"}, {"query": "Rust struct for Elavon capture transaction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: PaymentsCaptureRequest\npub struct PaymentsCaptureRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_txn_id: String,\n}\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "function_name": "PaymentsCaptureRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon Capture Request Struct"}, {"query": "hyperswitch elavon connector capture request fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: PaymentsCaptureRequest\npub struct PaymentsCaptureRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_txn_id: String,\n}\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "function_name": "PaymentsCaptureRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon Capture Request Struct"}, {"query": "Elavon API request body mapping rust struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: PaymentsCaptureRequest\npub struct PaymentsCaptureRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_txn_id: String,\n}\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "function_name": "PaymentsCaptureRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon Capture Request Struct"}, {"query": "How to handle TransactionUnresolvedResponse in Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: PaymentsResponseData\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]", "function_name": "PaymentsResponseData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Rust PaymentsResponseData Enum"}, {"query": "Rust enum PaymentsResponseData structure hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: PaymentsResponseData\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]", "function_name": "PaymentsResponseData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Rust PaymentsResponseData Enum"}, {"query": "IncrementalAuthorizationResponse status fields hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: PaymentsResponseData\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]", "function_name": "PaymentsResponseData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Rust PaymentsResponseData Enum"}, {"query": "PaymentsResponseData SessionTokenResponse implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: PaymentsResponseData\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]", "function_name": "PaymentsResponseData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Rust PaymentsResponseData Enum"}, {"query": "how to get request body for Sift payments connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = sift::SiftRouterData::from((amount, req));\n        let connector_req = sift::SiftPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift payments request payload builder"}, {"query": "rust function to convert PaymentsAuthorizeRouterData to SiftPaymentsRequest", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = sift::SiftRouterData::from((amount, req));\n        let connector_req = sift::SiftPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift payments request payload builder"}, {"query": "hyperswitch sift connector request payload preparation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = sift::SiftRouterData::from((amount, req));\n        let connector_req = sift::SiftPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift payments request payload builder"}, {"query": "SiftPaymentsRequest try_from implementation in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = sift::SiftRouterData::from((amount, req));\n        let connector_req = sift::SiftPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift payments request payload builder"}, {"query": "how to configure webhook routing in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service_for_webhooks\npub async fn should_call_unified_connector_service_for_webhooks(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n) -> RouterResult<ExecutionPath> {\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {}\", connector_name))?;\n\n    let flow_name = \"Webhooks\";\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    // Build rollout keys - webhooks don't use payment method, so use a simplified key format\n    let rollout_key = format!(\n        \"{}_{}_{}_{}\",\n        consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // For webhooks, there is no previous gateway system to consider (webhooks are stateless)\n    let previous_gateway = None;\n\n    // Check both rollout keys to determine priority based on shadow percentage\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Use the same decision logic as payments, with no call_connector_action to consider\n    let (gateway_system, execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        router_env::logger::debug!(\"UCS is disabled for webhooks, using Direct gateway\");\n        (GatewaySystem::Direct, ExecutionPath::Direct)\n    } else {\n        // UCS is enabled, use decide function with no previous gateway for webhooks\n        decide_execution_path(\n            connector_integration_type,\n            previous_gateway,\n            rollout_result.execution_mode,\n        )?\n    };\n\n    router_env::logger::info!(\n        \"Webhook gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok(execution_path)\n}\n", "function_name": "should_call_unified_connector_service_for_webhooks", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "webhook execution path decision logic"}, {"query": "rust function for webhook execution path decision hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service_for_webhooks\npub async fn should_call_unified_connector_service_for_webhooks(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n) -> RouterResult<ExecutionPath> {\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {}\", connector_name))?;\n\n    let flow_name = \"Webhooks\";\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    // Build rollout keys - webhooks don't use payment method, so use a simplified key format\n    let rollout_key = format!(\n        \"{}_{}_{}_{}\",\n        consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // For webhooks, there is no previous gateway system to consider (webhooks are stateless)\n    let previous_gateway = None;\n\n    // Check both rollout keys to determine priority based on shadow percentage\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Use the same decision logic as payments, with no call_connector_action to consider\n    let (gateway_system, execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        router_env::logger::debug!(\"UCS is disabled for webhooks, using Direct gateway\");\n        (GatewaySystem::Direct, ExecutionPath::Direct)\n    } else {\n        // UCS is enabled, use decide function with no previous gateway for webhooks\n        decide_execution_path(\n            connector_integration_type,\n            previous_gateway,\n            rollout_result.execution_mode,\n        )?\n    };\n\n    router_env::logger::info!(\n        \"Webhook gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok(execution_path)\n}\n", "function_name": "should_call_unified_connector_service_for_webhooks", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "webhook execution path decision logic"}, {"query": "hyperswitch router should_call_unified_connector_service_for_webhooks", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service_for_webhooks\npub async fn should_call_unified_connector_service_for_webhooks(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n) -> RouterResult<ExecutionPath> {\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {}\", connector_name))?;\n\n    let flow_name = \"Webhooks\";\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    // Build rollout keys - webhooks don't use payment method, so use a simplified key format\n    let rollout_key = format!(\n        \"{}_{}_{}_{}\",\n        consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // For webhooks, there is no previous gateway system to consider (webhooks are stateless)\n    let previous_gateway = None;\n\n    // Check both rollout keys to determine priority based on shadow percentage\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Use the same decision logic as payments, with no call_connector_action to consider\n    let (gateway_system, execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        router_env::logger::debug!(\"UCS is disabled for webhooks, using Direct gateway\");\n        (GatewaySystem::Direct, ExecutionPath::Direct)\n    } else {\n        // UCS is enabled, use decide function with no previous gateway for webhooks\n        decide_execution_path(\n            connector_integration_type,\n            previous_gateway,\n            rollout_result.execution_mode,\n        )?\n    };\n\n    router_env::logger::info!(\n        \"Webhook gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok(execution_path)\n}\n", "function_name": "should_call_unified_connector_service_for_webhooks", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "webhook execution path decision logic"}, {"query": "how does hyperswitch decide between direct and unified gateway for webhooks", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service_for_webhooks\npub async fn should_call_unified_connector_service_for_webhooks(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n) -> RouterResult<ExecutionPath> {\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {}\", connector_name))?;\n\n    let flow_name = \"Webhooks\";\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    // Build rollout keys - webhooks don't use payment method, so use a simplified key format\n    let rollout_key = format!(\n        \"{}_{}_{}_{}\",\n        consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // For webhooks, there is no previous gateway system to consider (webhooks are stateless)\n    let previous_gateway = None;\n\n    // Check both rollout keys to determine priority based on shadow percentage\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Use the same decision logic as payments, with no call_connector_action to consider\n    let (gateway_system, execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        router_env::logger::debug!(\"UCS is disabled for webhooks, using Direct gateway\");\n        (GatewaySystem::Direct, ExecutionPath::Direct)\n    } else {\n        // UCS is enabled, use decide function with no previous gateway for webhooks\n        decide_execution_path(\n            connector_integration_type,\n            previous_gateway,\n            rollout_result.execution_mode,\n        )?\n    };\n\n    router_env::logger::info!(\n        \"Webhook gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok(execution_path)\n}\n", "function_name": "should_call_unified_connector_service_for_webhooks", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "webhook execution path decision logic"}, {"query": "Hyperswitch DebitRoutingConfig struct definition Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: DebitRoutingConfig\npub struct DebitRoutingConfig {\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub connector_supported_debit_networks: HashMap<enums::Connector, HashSet<enums::CardNetwork>>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_currencies: HashSet<enums::Currency>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_connectors: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "DebitRoutingConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "DebitRoutingConfig struct definition"}, {"query": "how to configure debit routing networks in Hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: DebitRoutingConfig\npub struct DebitRoutingConfig {\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub connector_supported_debit_networks: HashMap<enums::Connector, HashSet<enums::CardNetwork>>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_currencies: HashSet<enums::Currency>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_connectors: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "DebitRoutingConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "DebitRoutingConfig struct definition"}, {"query": "DebitRoutingConfig deserialize hashmap serde Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: DebitRoutingConfig\npub struct DebitRoutingConfig {\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub connector_supported_debit_networks: HashMap<enums::Connector, HashSet<enums::CardNetwork>>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_currencies: HashSet<enums::Currency>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_connectors: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "DebitRoutingConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "DebitRoutingConfig struct definition"}, {"query": "Hyperswitch router debit payment routing configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: DebitRoutingConfig\npub struct DebitRoutingConfig {\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub connector_supported_debit_networks: HashMap<enums::Connector, HashSet<enums::CardNetwork>>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_currencies: HashSet<enums::Currency>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_connectors: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "DebitRoutingConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "DebitRoutingConfig struct definition"}, {"query": "rust hyperswitch authipay get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = authipay::AuthipayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_KEY.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay API Key Header"}, {"query": "how to configure API key header for Authipay connector in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = authipay::AuthipayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_KEY.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay API Key Header"}, {"query": "hyperswitch AuthipayAuthType conversion and header generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = authipay::AuthipayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_KEY.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay API Key Header"}, {"query": "rust function get_auth_header hyperswitch authipay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = authipay::AuthipayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_KEY.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay API Key Header"}, {"query": "rust hyperswitch router user from signup request", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: from\n    fn from(_value: user_api::SignUpRequest) -> Self {\n        let new_organization =\n            api_org::OrganizationNew::new(common_enums::OrganizationType::Standard, None);\n        let db_organization = ForeignFrom::foreign_from(new_organization);\n        Self(db_organization)\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User Signup Conversion"}, {"query": "how to convert SignUpRequest to User in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: from\n    fn from(_value: user_api::SignUpRequest) -> Self {\n        let new_organization =\n            api_org::OrganizationNew::new(common_enums::OrganizationType::Standard, None);\n        let db_organization = ForeignFrom::foreign_from(new_organization);\n        Self(db_organization)\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User Signup Conversion"}, {"query": "hyperswitch router user module signup conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: from\n    fn from(_value: user_api::SignUpRequest) -> Self {\n        let new_organization =\n            api_org::OrganizationNew::new(common_enums::OrganizationType::Standard, None);\n        let db_organization = ForeignFrom::foreign_from(new_organization);\n        Self(db_organization)\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User Signup Conversion"}, {"query": "rust hyperswitch domain user from signup", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: from\n    fn from(_value: user_api::SignUpRequest) -> Self {\n        let new_organization =\n            api_org::OrganizationNew::new(common_enums::OrganizationType::Standard, None);\n        let db_organization = ForeignFrom::foreign_from(new_organization);\n        Self(db_organization)\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User Signup Conversion"}, {"query": "How to handle QR code redirection in iatapay connector response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_iatpay_response\nfn get_iatpay_response(\n    response: IatapayPaymentsResponse,\n    status_code: u16,\n) -> CustomResult<\n    (\n        enums::AttemptStatus,\n        Option<ErrorResponse>,\n        PaymentsResponseData,\n    ),\n    errors::ConnectorError,\n> {\n    let status = enums::AttemptStatus::from(response.status);\n    let error = if is_payment_failure(status) {\n        Some(ErrorResponse {\n            code: response\n                .failure_code\n                .unwrap_or_else(|| NO_ERROR_CODE.to_string()),\n            message: response\n                .failure_details\n                .clone()\n                .unwrap_or_else(|| NO_ERROR_MESSAGE.to_string()),\n            reason: response.failure_details,\n            status_code,\n            attempt_status: Some(status),\n            connector_transaction_id: response.iata_payment_id.clone(),\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    } else {\n        None\n    };\n    let form_fields = HashMap::new();\n    let id = match response.iata_payment_id.clone() {\n        Some(s) => ResponseId::ConnectorTransactionId(s),\n        None => ResponseId::NoResponseId,\n    };\n    let connector_response_reference_id = response.merchant_payment_id.or(response.iata_payment_id);\n\n    let payment_response_data = match response.checkout_methods {\n        Some(checkout_methods) => {\n            let (connector_metadata, redirection_data) =\n                match checkout_methods.redirect.redirect_url.ends_with(\"qr\") {\n                    true => {\n                        let qr_code_info = api_models::payments::FetchQrCodeInformation {\n                            qr_code_fetch_url: url::Url::parse(\n                                &checkout_methods.redirect.redirect_url,\n                            )\n                            .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                        };\n                        (\n                            Some(qr_code_info.encode_to_value())\n                                .transpose()\n                                .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                            None,\n                        )\n                    }\n                    false => (\n                        None,\n                        Some(Redire\n\n... [truncated 425 chars] ...\n\nate_reference: Box::new(None),\n                connector_metadata,\n                network_txn_id: None,\n                connector_response_reference_id: connector_response_reference_id.clone(),\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }\n        }\n        None => PaymentsResponseData::TransactionResponse {\n            resource_id: id.clone(),\n            redirection_data: Box::new(None),\n            mandate_reference: Box::new(None),\n            connector_metadata: None,\n            network_txn_id: None,\n            connector_response_reference_id: connector_response_reference_id.clone(),\n            incremental_authorization_allowed: None,\n            authentication_data: None,\n            charges: None,\n        },\n    };\n\n    Ok((status, error, payment_response_data))\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayPaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = Error;", "function_name": "get_iatpay_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iatapay response transformer"}, {"query": "Rust function to parse iatapay payment response status", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_iatpay_response\nfn get_iatpay_response(\n    response: IatapayPaymentsResponse,\n    status_code: u16,\n) -> CustomResult<\n    (\n        enums::AttemptStatus,\n        Option<ErrorResponse>,\n        PaymentsResponseData,\n    ),\n    errors::ConnectorError,\n> {\n    let status = enums::AttemptStatus::from(response.status);\n    let error = if is_payment_failure(status) {\n        Some(ErrorResponse {\n            code: response\n                .failure_code\n                .unwrap_or_else(|| NO_ERROR_CODE.to_string()),\n            message: response\n                .failure_details\n                .clone()\n                .unwrap_or_else(|| NO_ERROR_MESSAGE.to_string()),\n            reason: response.failure_details,\n            status_code,\n            attempt_status: Some(status),\n            connector_transaction_id: response.iata_payment_id.clone(),\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    } else {\n        None\n    };\n    let form_fields = HashMap::new();\n    let id = match response.iata_payment_id.clone() {\n        Some(s) => ResponseId::ConnectorTransactionId(s),\n        None => ResponseId::NoResponseId,\n    };\n    let connector_response_reference_id = response.merchant_payment_id.or(response.iata_payment_id);\n\n    let payment_response_data = match response.checkout_methods {\n        Some(checkout_methods) => {\n            let (connector_metadata, redirection_data) =\n                match checkout_methods.redirect.redirect_url.ends_with(\"qr\") {\n                    true => {\n                        let qr_code_info = api_models::payments::FetchQrCodeInformation {\n                            qr_code_fetch_url: url::Url::parse(\n                                &checkout_methods.redirect.redirect_url,\n                            )\n                            .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                        };\n                        (\n                            Some(qr_code_info.encode_to_value())\n                                .transpose()\n                                .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                            None,\n                        )\n                    }\n                    false => (\n                        None,\n                        Some(Redire\n\n... [truncated 425 chars] ...\n\nate_reference: Box::new(None),\n                connector_metadata,\n                network_txn_id: None,\n                connector_response_reference_id: connector_response_reference_id.clone(),\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }\n        }\n        None => PaymentsResponseData::TransactionResponse {\n            resource_id: id.clone(),\n            redirection_data: Box::new(None),\n            mandate_reference: Box::new(None),\n            connector_metadata: None,\n            network_txn_id: None,\n            connector_response_reference_id: connector_response_reference_id.clone(),\n            incremental_authorization_allowed: None,\n            authentication_data: None,\n            charges: None,\n        },\n    };\n\n    Ok((status, error, payment_response_data))\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayPaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = Error;", "function_name": "get_iatpay_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iatapay response transformer"}, {"query": "Hyperswitch iatapay connector error handling implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_iatpay_response\nfn get_iatpay_response(\n    response: IatapayPaymentsResponse,\n    status_code: u16,\n) -> CustomResult<\n    (\n        enums::AttemptStatus,\n        Option<ErrorResponse>,\n        PaymentsResponseData,\n    ),\n    errors::ConnectorError,\n> {\n    let status = enums::AttemptStatus::from(response.status);\n    let error = if is_payment_failure(status) {\n        Some(ErrorResponse {\n            code: response\n                .failure_code\n                .unwrap_or_else(|| NO_ERROR_CODE.to_string()),\n            message: response\n                .failure_details\n                .clone()\n                .unwrap_or_else(|| NO_ERROR_MESSAGE.to_string()),\n            reason: response.failure_details,\n            status_code,\n            attempt_status: Some(status),\n            connector_transaction_id: response.iata_payment_id.clone(),\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    } else {\n        None\n    };\n    let form_fields = HashMap::new();\n    let id = match response.iata_payment_id.clone() {\n        Some(s) => ResponseId::ConnectorTransactionId(s),\n        None => ResponseId::NoResponseId,\n    };\n    let connector_response_reference_id = response.merchant_payment_id.or(response.iata_payment_id);\n\n    let payment_response_data = match response.checkout_methods {\n        Some(checkout_methods) => {\n            let (connector_metadata, redirection_data) =\n                match checkout_methods.redirect.redirect_url.ends_with(\"qr\") {\n                    true => {\n                        let qr_code_info = api_models::payments::FetchQrCodeInformation {\n                            qr_code_fetch_url: url::Url::parse(\n                                &checkout_methods.redirect.redirect_url,\n                            )\n                            .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                        };\n                        (\n                            Some(qr_code_info.encode_to_value())\n                                .transpose()\n                                .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                            None,\n                        )\n                    }\n                    false => (\n                        None,\n                        Some(Redire\n\n... [truncated 425 chars] ...\n\nate_reference: Box::new(None),\n                connector_metadata,\n                network_txn_id: None,\n                connector_response_reference_id: connector_response_reference_id.clone(),\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }\n        }\n        None => PaymentsResponseData::TransactionResponse {\n            resource_id: id.clone(),\n            redirection_data: Box::new(None),\n            mandate_reference: Box::new(None),\n            connector_metadata: None,\n            network_txn_id: None,\n            connector_response_reference_id: connector_response_reference_id.clone(),\n            incremental_authorization_allowed: None,\n            authentication_data: None,\n            charges: None,\n        },\n    };\n\n    Ok((status, error, payment_response_data))\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayPaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = Error;", "function_name": "get_iatpay_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iatapay response transformer"}, {"query": "Map iatapay payment_id to connector transaction id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_iatpay_response\nfn get_iatpay_response(\n    response: IatapayPaymentsResponse,\n    status_code: u16,\n) -> CustomResult<\n    (\n        enums::AttemptStatus,\n        Option<ErrorResponse>,\n        PaymentsResponseData,\n    ),\n    errors::ConnectorError,\n> {\n    let status = enums::AttemptStatus::from(response.status);\n    let error = if is_payment_failure(status) {\n        Some(ErrorResponse {\n            code: response\n                .failure_code\n                .unwrap_or_else(|| NO_ERROR_CODE.to_string()),\n            message: response\n                .failure_details\n                .clone()\n                .unwrap_or_else(|| NO_ERROR_MESSAGE.to_string()),\n            reason: response.failure_details,\n            status_code,\n            attempt_status: Some(status),\n            connector_transaction_id: response.iata_payment_id.clone(),\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    } else {\n        None\n    };\n    let form_fields = HashMap::new();\n    let id = match response.iata_payment_id.clone() {\n        Some(s) => ResponseId::ConnectorTransactionId(s),\n        None => ResponseId::NoResponseId,\n    };\n    let connector_response_reference_id = response.merchant_payment_id.or(response.iata_payment_id);\n\n    let payment_response_data = match response.checkout_methods {\n        Some(checkout_methods) => {\n            let (connector_metadata, redirection_data) =\n                match checkout_methods.redirect.redirect_url.ends_with(\"qr\") {\n                    true => {\n                        let qr_code_info = api_models::payments::FetchQrCodeInformation {\n                            qr_code_fetch_url: url::Url::parse(\n                                &checkout_methods.redirect.redirect_url,\n                            )\n                            .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                        };\n                        (\n                            Some(qr_code_info.encode_to_value())\n                                .transpose()\n                                .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                            None,\n                        )\n                    }\n                    false => (\n                        None,\n                        Some(Redire\n\n... [truncated 425 chars] ...\n\nate_reference: Box::new(None),\n                connector_metadata,\n                network_txn_id: None,\n                connector_response_reference_id: connector_response_reference_id.clone(),\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }\n        }\n        None => PaymentsResponseData::TransactionResponse {\n            resource_id: id.clone(),\n            redirection_data: Box::new(None),\n            mandate_reference: Box::new(None),\n            connector_metadata: None,\n            network_txn_id: None,\n            connector_response_reference_id: connector_response_reference_id.clone(),\n            incremental_authorization_allowed: None,\n            authentication_data: None,\n            charges: None,\n        },\n    };\n\n    Ok((status, error, payment_response_data))\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayPaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = Error;", "function_name": "get_iatpay_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iatapay response transformer"}, {"query": "how to format CyberSource mandate setup request in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = cybersource::CybersourceZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "CyberSource mandate request builder"}, {"query": "CybersourceZeroMandateRequest struct definition hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = cybersource::CybersourceZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "CyberSource mandate request builder"}, {"query": "hyperswitch connector get_request_body implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = cybersource::CybersourceZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "CyberSource mandate request builder"}, {"query": "setup mandate router data cybersource hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = cybersource::CybersourceZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "CyberSource mandate request builder"}, {"query": "Rust struct definition for payment response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentResponse\npub struct PaymentResponse {\n    pub id: String,\n    pub status: PaymentStatus,\n    pub status_reason_information: Option<String>,\n    pub authentication: Option<Authentication>,\n    pub error_info: Option<ErrorInfo>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "PaymentResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentResponse struct definition"}, {"query": "hyperswitch PaymentResponse fields authentication error_info", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentResponse\npub struct PaymentResponse {\n    pub id: String,\n    pub status: PaymentStatus,\n    pub status_reason_information: Option<String>,\n    pub authentication: Option<Authentication>,\n    pub error_info: Option<ErrorInfo>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "PaymentResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentResponse struct definition"}, {"query": "how to parse hyperswitch payment response struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentResponse\npub struct PaymentResponse {\n    pub id: String,\n    pub status: PaymentStatus,\n    pub status_reason_information: Option<String>,\n    pub authentication: Option<Authentication>,\n    pub error_info: Option<ErrorInfo>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "PaymentResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentResponse struct definition"}, {"query": "hyperswitch domain models payment response rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentResponse\npub struct PaymentResponse {\n    pub id: String,\n    pub status: PaymentStatus,\n    pub status_reason_information: Option<String>,\n    pub authentication: Option<Authentication>,\n    pub error_info: Option<ErrorInfo>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "PaymentResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "PaymentResponse struct definition"}, {"query": "How to implement get_webhook_event_type in GPayments connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments webhook event type extraction"}, {"query": "GPayments webhook event type extraction Rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments webhook event type extraction"}, {"query": "hyperswitch get_webhook_event_type function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments webhook event type extraction"}, {"query": "GPayments connector webhook handling error WebhooksNotImplemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "function_name": "get_webhook_event_type", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments webhook event type extraction"}, {"query": "gigadat validate_psync_reference_id function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat PSync Reference ID Validation"}, {"query": "hyperswitch gigadat connector psync reference id validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat PSync Reference ID Validation"}, {"query": "Rust gigadat validate_psync_reference_id placeholder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat PSync Reference ID Validation"}, {"query": "hyperswitch gigadat payment sync reference id check", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat PSync Reference ID Validation"}, {"query": "how to handle payone connector error responses in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: payone::ErrorResponse = res\n            .response\n            .parse_struct(\"ErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        let errors_list = response.errors.clone().unwrap_or_default();\n        let option_error_code_message = get_error_code_error_message_based_on_priority(\n            self.clone(),\n            errors_list\n                .into_iter()\n                .map(|errors| errors.into())\n                .collect(),\n        );\n        match response.errors {\n            Some(errors) => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                message: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                reason: Some(\n                    errors\n                        .iter()\n                        .map(|error| format!(\"{} : {}\", error.code, error.message))\n                        .collect::<Vec<String>>()\n                        .join(\", \"),\n                ),\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n            None => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: NO_ERROR_CODE.to_string(),\n                message: NO_ERROR_MESSAGE.to_string(),\n                reason: None,\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n        }\n    }\n}", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone error response parser"}, {"query": "rust function to parse payone error json and return ErrorResponse", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: payone::ErrorResponse = res\n            .response\n            .parse_struct(\"ErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        let errors_list = response.errors.clone().unwrap_or_default();\n        let option_error_code_message = get_error_code_error_message_based_on_priority(\n            self.clone(),\n            errors_list\n                .into_iter()\n                .map(|errors| errors.into())\n                .collect(),\n        );\n        match response.errors {\n            Some(errors) => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                message: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                reason: Some(\n                    errors\n                        .iter()\n                        .map(|error| format!(\"{} : {}\", error.code, error.message))\n                        .collect::<Vec<String>>()\n                        .join(\", \"),\n                ),\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n            None => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: NO_ERROR_CODE.to_string(),\n                message: NO_ERROR_MESSAGE.to_string(),\n                reason: None,\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n        }\n    }\n}", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone error response parser"}, {"query": "hyperswitch payone connector error handling build_error_response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: payone::ErrorResponse = res\n            .response\n            .parse_struct(\"ErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        let errors_list = response.errors.clone().unwrap_or_default();\n        let option_error_code_message = get_error_code_error_message_based_on_priority(\n            self.clone(),\n            errors_list\n                .into_iter()\n                .map(|errors| errors.into())\n                .collect(),\n        );\n        match response.errors {\n            Some(errors) => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                message: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                reason: Some(\n                    errors\n                        .iter()\n                        .map(|error| format!(\"{} : {}\", error.code, error.message))\n                        .collect::<Vec<String>>()\n                        .join(\", \"),\n                ),\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n            None => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: NO_ERROR_CODE.to_string(),\n                message: NO_ERROR_MESSAGE.to_string(),\n                reason: None,\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n        }\n    }\n}", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone error response parser"}, {"query": "how does hyperswitch normalize payone error codes", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: payone::ErrorResponse = res\n            .response\n            .parse_struct(\"ErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        let errors_list = response.errors.clone().unwrap_or_default();\n        let option_error_code_message = get_error_code_error_message_based_on_priority(\n            self.clone(),\n            errors_list\n                .into_iter()\n                .map(|errors| errors.into())\n                .collect(),\n        );\n        match response.errors {\n            Some(errors) => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                message: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                reason: Some(\n                    errors\n                        .iter()\n                        .map(|error| format!(\"{} : {}\", error.code, error.message))\n                        .collect::<Vec<String>>()\n                        .join(\", \"),\n                ),\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n            None => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: NO_ERROR_CODE.to_string(),\n                message: NO_ERROR_MESSAGE.to_string(),\n                reason: None,\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n        }\n    }\n}", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone error response parser"}, {"query": "Barclaycard connector tokenization implementation Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Barclaycard\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Barclaycard\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard tokenization integration"}, {"query": "hyperswitch Barclaycard PaymentMethodTokenizationData", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Barclaycard\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Barclaycard\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard tokenization integration"}, {"query": "Barclaycard payment method tokenization not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Barclaycard\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Barclaycard\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard tokenization integration"}, {"query": "hyperswitch connector integration trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Barclaycard\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Barclaycard\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard tokenization integration"}, {"query": "rust hyperswitch filter payment intents by time range", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intents_by_time_range_constraints\n    async fn filter_payment_intents_by_time_range_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        time_range: &common_utils::types::TimeRange,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(feature = \"olap\")]", "function_name": "filter_payment_intents_by_time_range_constraints", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Time range filter payment intents"}, {"query": "how to get payment intents between two timestamps in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intents_by_time_range_constraints\n    async fn filter_payment_intents_by_time_range_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        time_range: &common_utils::types::TimeRange,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(feature = \"olap\")]", "function_name": "filter_payment_intents_by_time_range_constraints", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Time range filter payment intents"}, {"query": "hyperswitch domain models filter_payment_intents_by_time_range implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intents_by_time_range_constraints\n    async fn filter_payment_intents_by_time_range_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        time_range: &common_utils::types::TimeRange,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(feature = \"olap\")]", "function_name": "filter_payment_intents_by_time_range_constraints", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Time range filter payment intents"}, {"query": "rust hyperswitch retrieve payment intents by date range merchant", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intents_by_time_range_constraints\n    async fn filter_payment_intents_by_time_range_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        time_range: &common_utils::types::TimeRange,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(feature = \"olap\")]", "function_name": "filter_payment_intents_by_time_range_constraints", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "Time range filter payment intents"}, {"query": "how to handle cybersource connector error responses in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource error response handler"}, {"query": "hyperswitch cybersource connector error handling get_error_response function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource error response handler"}, {"query": "rust connector error response builder cybersource hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource error response handler"}, {"query": "cybersource connector error event builder hyperswitch rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource error response handler"}, {"query": "how to get boku url for hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let boku_url = get_country_url(\n            req.connector_meta_data.clone(),\n            self.base_url(connectors).to_string(),\n        )?;\n\n        Ok(format!(\"{boku_url}/billing/3.0/begin-single-charge\"))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku URL construction"}, {"query": "hyperswitch boku connector get_url implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let boku_url = get_country_url(\n            req.connector_meta_data.clone(),\n            self.base_url(connectors).to_string(),\n        )?;\n\n        Ok(format!(\"{boku_url}/billing/3.0/begin-single-charge\"))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku URL construction"}, {"query": "boku begin-single-charge endpoint hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let boku_url = get_country_url(\n            req.connector_meta_data.clone(),\n            self.base_url(connectors).to_string(),\n        )?;\n\n        Ok(format!(\"{boku_url}/billing/3.0/begin-single-charge\"))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku URL construction"}, {"query": "hyperswitch boku regional url configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let boku_url = get_country_url(\n            req.connector_meta_data.clone(),\n            self.base_url(connectors).to_string(),\n        )?;\n\n        Ok(format!(\"{boku_url}/billing/3.0/begin-single-charge\"))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku URL construction"}, {"query": "rust hyperswitch gpayments connector build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments header configuration"}, {"query": "how to configure content type for gpayments in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments header configuration"}, {"query": "hyperswitch gpayments connector header setup function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments header configuration"}, {"query": "gpayments hyperswitch rust build_headers method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments header configuration"}, {"query": "how to handle 5xx errors in hyperswitch wells fargo connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: wellsfargo::WellsfargoServerErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargoServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "get_5xx_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo 5xx Error Handler"}, {"query": "wellsfargo connector error response mapping to AttemptStatus", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: wellsfargo::WellsfargoServerErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargoServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "get_5xx_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo 5xx Error Handler"}, {"query": "rust hyperswitch connector error handling 5xx server error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: wellsfargo::WellsfargoServerErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargoServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "get_5xx_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo 5xx Error Handler"}, {"query": "hyperswitch wells fargo get_5xx_error_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: wellsfargo::WellsfargoServerErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargoServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "get_5xx_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo 5xx Error Handler"}, {"query": "how to get api event type from authentication id", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_api_event_type\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        self.authentication_id\n            .as_ref()\n            .map(|id| ApiEventsType::Authentication {\n                authentication_id: id.clone(),\n            })\n    }\n}\n", "function_name": "get_api_event_type", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication event type mapper"}, {"query": "rust hyperswitch authentication event type mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_api_event_type\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        self.authentication_id\n            .as_ref()\n            .map(|id| ApiEventsType::Authentication {\n                authentication_id: id.clone(),\n            })\n    }\n}\n", "function_name": "get_api_event_type", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication event type mapper"}, {"query": "get_api_event_type function implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_api_event_type\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        self.authentication_id\n            .as_ref()\n            .map(|id| ApiEventsType::Authentication {\n                authentication_id: id.clone(),\n            })\n    }\n}\n", "function_name": "get_api_event_type", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication event type mapper"}, {"query": "hyperswitch authentication webhook event type handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_api_event_type\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        self.authentication_id\n            .as_ref()\n            .map(|id| ApiEventsType::Authentication {\n                authentication_id: id.clone(),\n            })\n    }\n}\n", "function_name": "get_api_event_type", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication event type mapper"}, {"query": "ArchipelPaymentCertainty enum variants in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentCertainty\npub enum ArchipelPaymentCertainty {\n    #[default]\n    Final,\n    Estimated,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "ArchipelPaymentCertainty", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment certainty enum"}, {"query": "how to handle estimated payments in Archipel connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentCertainty\npub enum ArchipelPaymentCertainty {\n    #[default]\n    Final,\n    Estimated,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "ArchipelPaymentCertainty", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment certainty enum"}, {"query": "ArchipelPaymentCertainty Rust enum definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentCertainty\npub enum ArchipelPaymentCertainty {\n    #[default]\n    Final,\n    Estimated,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "ArchipelPaymentCertainty", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment certainty enum"}, {"query": "payment certainty states Archipel hyperswitch connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentCertainty\npub enum ArchipelPaymentCertainty {\n    #[default]\n    Final,\n    Estimated,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "ArchipelPaymentCertainty", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment certainty enum"}, {"query": "rust hypersift connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector auth headers"}, {"query": "how to configure sift api key headers in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector auth headers"}, {"query": "hyperswitch sift connector authorization header setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector auth headers"}, {"query": "rust code for sift payment connector request headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector auth headers"}, {"query": "rust hyperswitch OrderInfo struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: OrderInfo\npub struct OrderInfo {\n    pub order_date: Option<time::PrimitiveDateTime>,\n    pub order_details: Option<Vec<api_models::payments::OrderDetailsWithAmount>>,\n    pub merchant_order_reference_id: Option<String>,\n    pub discount_amount: Option<MinorUnit>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub duty_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "OrderInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "OrderInfo struct definition"}, {"query": "how to define order details in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: OrderInfo\npub struct OrderInfo {\n    pub order_date: Option<time::PrimitiveDateTime>,\n    pub order_details: Option<Vec<api_models::payments::OrderDetailsWithAmount>>,\n    pub merchant_order_reference_id: Option<String>,\n    pub discount_amount: Option<MinorUnit>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub duty_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "OrderInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "OrderInfo struct definition"}, {"query": "hyperswitch domain models OrderInfo fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: OrderInfo\npub struct OrderInfo {\n    pub order_date: Option<time::PrimitiveDateTime>,\n    pub order_details: Option<Vec<api_models::payments::OrderDetailsWithAmount>>,\n    pub merchant_order_reference_id: Option<String>,\n    pub discount_amount: Option<MinorUnit>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub duty_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "OrderInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "OrderInfo struct definition"}, {"query": "rust payment orchestration OrderInfo struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: OrderInfo\npub struct OrderInfo {\n    pub order_date: Option<time::PrimitiveDateTime>,\n    pub order_details: Option<Vec<api_models::payments::OrderDetailsWithAmount>>,\n    pub merchant_order_reference_id: Option<String>,\n    pub discount_amount: Option<MinorUnit>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub duty_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "OrderInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "OrderInfo struct definition"}, {"query": "How to handle Airwallex customer response data in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorCustomerRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorCustomerRouterData, errors::ConnectorError>\n    where\n        PaymentsResponseData: Clone,\n    {\n        let response: airwallex::AirwallexCustomerResponse = res\n            .response\n            .parse_struct(\"AirwallexCustomerResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Response Handler"}, {"query": "Rust function to parse Airwallex customer response and log it", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorCustomerRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorCustomerRouterData, errors::ConnectorError>\n    where\n        PaymentsResponseData: Clone,\n    {\n        let response: airwallex::AirwallexCustomerResponse = res\n            .response\n            .parse_struct(\"AirwallexCustomerResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Response Handler"}, {"query": "hyperswitch airwallex connector handle_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorCustomerRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorCustomerRouterData, errors::ConnectorError>\n    where\n        PaymentsResponseData: Clone,\n    {\n        let response: airwallex::AirwallexCustomerResponse = res\n            .response\n            .parse_struct(\"AirwallexCustomerResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Response Handler"}, {"query": "AirwallexCustomerResponse deserialization and RouterData conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorCustomerRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorCustomerRouterData, errors::ConnectorError>\n    where\n        PaymentsResponseData: Clone,\n    {\n        let response: airwallex::AirwallexCustomerResponse = res\n            .response\n            .parse_struct(\"AirwallexCustomerResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Response Handler"}, {"query": "KlarnaPaymentsRequest struct definition fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaPaymentsRequest\npub struct KlarnaPaymentsRequest {\n    order_lines: Vec<OrderLines>,\n    order_amount: MinorUnit,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    merchant_reference1: Option<String>,\n    merchant_reference2: Option<String>,\n    shipping_address: Option<KlarnaShippingAddress>,\n    auto_capture: Option<bool>,\n    order_tax_amount: Option<MinorUnit>,\n    #[serde(flatten)]\n    payment_method_specifics: Option<PaymentMethodSpecifics>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "function_name": "KlarnaPaymentsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna payment request model"}, {"query": "how to construct Klarna payment request payload", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaPaymentsRequest\npub struct KlarnaPaymentsRequest {\n    order_lines: Vec<OrderLines>,\n    order_amount: MinorUnit,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    merchant_reference1: Option<String>,\n    merchant_reference2: Option<String>,\n    shipping_address: Option<KlarnaShippingAddress>,\n    auto_capture: Option<bool>,\n    order_tax_amount: Option<MinorUnit>,\n    #[serde(flatten)]\n    payment_method_specifics: Option<PaymentMethodSpecifics>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "function_name": "KlarnaPaymentsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna payment request model"}, {"query": "hyperswitch Klarna connector input model", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaPaymentsRequest\npub struct KlarnaPaymentsRequest {\n    order_lines: Vec<OrderLines>,\n    order_amount: MinorUnit,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    merchant_reference1: Option<String>,\n    merchant_reference2: Option<String>,\n    shipping_address: Option<KlarnaShippingAddress>,\n    auto_capture: Option<bool>,\n    order_tax_amount: Option<MinorUnit>,\n    #[serde(flatten)]\n    payment_method_specifics: Option<PaymentMethodSpecifics>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "function_name": "KlarnaPaymentsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna payment request model"}, {"query": "KlarnaPaymentsRequest auto_capture field usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaPaymentsRequest\npub struct KlarnaPaymentsRequest {\n    order_lines: Vec<OrderLines>,\n    order_amount: MinorUnit,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    merchant_reference1: Option<String>,\n    merchant_reference2: Option<String>,\n    shipping_address: Option<KlarnaShippingAddress>,\n    auto_capture: Option<bool>,\n    order_tax_amount: Option<MinorUnit>,\n    #[serde(flatten)]\n    payment_method_specifics: Option<PaymentMethodSpecifics>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "function_name": "KlarnaPaymentsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna payment request model"}, {"query": "how to convert ConnectorCustomerRouterData to Airwallex CustomerRequest", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = airwallex::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Request Serialization"}, {"query": "Airwallex connector get_request_body implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = airwallex::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Request Serialization"}, {"query": "formatting customer data for Airwallex API in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = airwallex::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Request Serialization"}, {"query": "Airwallex customer request payload structure hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = airwallex::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex Customer Request Serialization"}, {"query": "how to access merchant connector account data in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_inner_db_merchant_connector_account\n    pub fn get_inner_db_merchant_connector_account(&self) -> Option<&MerchantConnectorAccount> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account)\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]", "function_name": "get_inner_db_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnector inner account accessor"}, {"query": "get_inner_db_merchant_connector_account function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_inner_db_merchant_connector_account\n    pub fn get_inner_db_merchant_connector_account(&self) -> Option<&MerchantConnectorAccount> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account)\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]", "function_name": "get_inner_db_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnector inner account accessor"}, {"query": "MerchantConnector enum variant access pattern hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_inner_db_merchant_connector_account\n    pub fn get_inner_db_merchant_connector_account(&self) -> Option<&MerchantConnectorAccount> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account)\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]", "function_name": "get_inner_db_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnector inner account accessor"}, {"query": "rust safe unwrap merchant connector account reference", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_inner_db_merchant_connector_account\n    pub fn get_inner_db_merchant_connector_account(&self) -> Option<&MerchantConnectorAccount> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account)\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]", "function_name": "get_inner_db_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnector inner account accessor"}, {"query": "how to check if UCS is enabled in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: check_ucs_availability\nasync fn check_ucs_availability(state: &SessionState) -> UcsAvailability {\n    let is_client_available = state.grpc_client.unified_connector_service_client.is_some();\n\n    let is_enabled = is_ucs_enabled(state, consts::UCS_ENABLED).await;\n\n    match (is_client_available, is_enabled) {\n        (true, true) => {\n            router_env::logger::debug!(\"UCS is available and enabled\");\n            UcsAvailability::Enabled\n        }\n        _ => {\n            router_env::logger::debug!(\n                \"UCS client is {} and UCS is {} in configuration\",\n                if is_client_available {\n                    \"available\"\n                } else {\n                    \"not available\"\n                },\n                if is_enabled { \"enabled\" } else { \"not enabled\" }\n            );\n            UcsAvailability::Disabled\n        }\n    }\n}\n\n/// Determines the connector integration type based on UCS configuration or on both", "function_name": "check_ucs_availability", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS availability check"}, {"query": "hyperswitch unified connector service availability check function", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: check_ucs_availability\nasync fn check_ucs_availability(state: &SessionState) -> UcsAvailability {\n    let is_client_available = state.grpc_client.unified_connector_service_client.is_some();\n\n    let is_enabled = is_ucs_enabled(state, consts::UCS_ENABLED).await;\n\n    match (is_client_available, is_enabled) {\n        (true, true) => {\n            router_env::logger::debug!(\"UCS is available and enabled\");\n            UcsAvailability::Enabled\n        }\n        _ => {\n            router_env::logger::debug!(\n                \"UCS client is {} and UCS is {} in configuration\",\n                if is_client_available {\n                    \"available\"\n                } else {\n                    \"not available\"\n                },\n                if is_enabled { \"enabled\" } else { \"not enabled\" }\n            );\n            UcsAvailability::Disabled\n        }\n    }\n}\n\n/// Determines the connector integration type based on UCS configuration or on both", "function_name": "check_ucs_availability", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS availability check"}, {"query": "rust code for checking UCS client availability", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: check_ucs_availability\nasync fn check_ucs_availability(state: &SessionState) -> UcsAvailability {\n    let is_client_available = state.grpc_client.unified_connector_service_client.is_some();\n\n    let is_enabled = is_ucs_enabled(state, consts::UCS_ENABLED).await;\n\n    match (is_client_available, is_enabled) {\n        (true, true) => {\n            router_env::logger::debug!(\"UCS is available and enabled\");\n            UcsAvailability::Enabled\n        }\n        _ => {\n            router_env::logger::debug!(\n                \"UCS client is {} and UCS is {} in configuration\",\n                if is_client_available {\n                    \"available\"\n                } else {\n                    \"not available\"\n                },\n                if is_enabled { \"enabled\" } else { \"not enabled\" }\n            );\n            UcsAvailability::Disabled\n        }\n    }\n}\n\n/// Determines the connector integration type based on UCS configuration or on both", "function_name": "check_ucs_availability", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS availability check"}, {"query": "check_ucs_availability function implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: check_ucs_availability\nasync fn check_ucs_availability(state: &SessionState) -> UcsAvailability {\n    let is_client_available = state.grpc_client.unified_connector_service_client.is_some();\n\n    let is_enabled = is_ucs_enabled(state, consts::UCS_ENABLED).await;\n\n    match (is_client_available, is_enabled) {\n        (true, true) => {\n            router_env::logger::debug!(\"UCS is available and enabled\");\n            UcsAvailability::Enabled\n        }\n        _ => {\n            router_env::logger::debug!(\n                \"UCS client is {} and UCS is {} in configuration\",\n                if is_client_available {\n                    \"available\"\n                } else {\n                    \"not available\"\n                },\n                if is_enabled { \"enabled\" } else { \"not enabled\" }\n            );\n            UcsAvailability::Disabled\n        }\n    }\n}\n\n/// Determines the connector integration type based on UCS configuration or on both", "function_name": "check_ucs_availability", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS availability check"}, {"query": "how to get saving percentage for co-badged debit card network", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: extract_debit_routing_saving_percentage\n    pub fn extract_debit_routing_saving_percentage(\n        &self,\n        network: &common_enums::CardNetwork,\n    ) -> Option<f64> {\n        self.get_co_badged_card_data()?\n            .co_badged_card_networks_info\n            .0\n            .iter()\n            .find(|info| &info.network == network)\n            .and_then(|info| info.saving_percentage)\n    }\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize, Default)]", "function_name": "extract_debit_routing_saving_percentage", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Co-badged debit routing saving percentage"}, {"query": "rust function to extract routing saving percentage from card data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: extract_debit_routing_saving_percentage\n    pub fn extract_debit_routing_saving_percentage(\n        &self,\n        network: &common_enums::CardNetwork,\n    ) -> Option<f64> {\n        self.get_co_badged_card_data()?\n            .co_badged_card_networks_info\n            .0\n            .iter()\n            .find(|info| &info.network == network)\n            .and_then(|info| info.saving_percentage)\n    }\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize, Default)]", "function_name": "extract_debit_routing_saving_percentage", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Co-badged debit routing saving percentage"}, {"query": "hyperswitch debit routing saving percentage implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: extract_debit_routing_saving_percentage\n    pub fn extract_debit_routing_saving_percentage(\n        &self,\n        network: &common_enums::CardNetwork,\n    ) -> Option<f64> {\n        self.get_co_badged_card_data()?\n            .co_badged_card_networks_info\n            .0\n            .iter()\n            .find(|info| &info.network == network)\n            .and_then(|info| info.saving_percentage)\n    }\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize, Default)]", "function_name": "extract_debit_routing_saving_percentage", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Co-badged debit routing saving percentage"}, {"query": "get_co_badged_card_data saving percentage logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: extract_debit_routing_saving_percentage\n    pub fn extract_debit_routing_saving_percentage(\n        &self,\n        network: &common_enums::CardNetwork,\n    ) -> Option<f64> {\n        self.get_co_badged_card_data()?\n            .co_badged_card_networks_info\n            .0\n            .iter()\n            .find(|info| &info.network == network)\n            .and_then(|info| info.saving_percentage)\n    }\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize, Default)]", "function_name": "extract_debit_routing_saving_percentage", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "Co-badged debit routing saving percentage"}, {"query": "hyperswitch payme connector error response transformation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_pay_sale_error_response\nfn get_pay_sale_error_response(\n    (pay_sale_response, http_code): (&PaymePaySaleResponse, u16),\n) -> ErrorResponse {\n    let code = pay_sale_response\n        .status_error_code\n        .map(|error_code| error_code.to_string())\n        .unwrap_or(consts::NO_ERROR_CODE.to_string());\n    ErrorResponse {\n        code,\n        message: pay_sale_response\n            .status_error_details\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: pay_sale_response.status_error_details.to_owned(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(pay_sale_response.payme_sale_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "function_name": "get_pay_sale_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Payme error response transformer"}, {"query": "how to handle payme payment sale errors in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_pay_sale_error_response\nfn get_pay_sale_error_response(\n    (pay_sale_response, http_code): (&PaymePaySaleResponse, u16),\n) -> ErrorResponse {\n    let code = pay_sale_response\n        .status_error_code\n        .map(|error_code| error_code.to_string())\n        .unwrap_or(consts::NO_ERROR_CODE.to_string());\n    ErrorResponse {\n        code,\n        message: pay_sale_response\n            .status_error_details\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: pay_sale_response.status_error_details.to_owned(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(pay_sale_response.payme_sale_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "function_name": "get_pay_sale_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Payme error response transformer"}, {"query": "paymePaySaleResponse to ErrorResponse mapping hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_pay_sale_error_response\nfn get_pay_sale_error_response(\n    (pay_sale_response, http_code): (&PaymePaySaleResponse, u16),\n) -> ErrorResponse {\n    let code = pay_sale_response\n        .status_error_code\n        .map(|error_code| error_code.to_string())\n        .unwrap_or(consts::NO_ERROR_CODE.to_string());\n    ErrorResponse {\n        code,\n        message: pay_sale_response\n            .status_error_details\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: pay_sale_response.status_error_details.to_owned(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(pay_sale_response.payme_sale_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "function_name": "get_pay_sale_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Payme error response transformer"}, {"query": "hyperswitch payme connector error handling code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_pay_sale_error_response\nfn get_pay_sale_error_response(\n    (pay_sale_response, http_code): (&PaymePaySaleResponse, u16),\n) -> ErrorResponse {\n    let code = pay_sale_response\n        .status_error_code\n        .map(|error_code| error_code.to_string())\n        .unwrap_or(consts::NO_ERROR_CODE.to_string());\n    ErrorResponse {\n        code,\n        message: pay_sale_response\n            .status_error_details\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: pay_sale_response.status_error_details.to_owned(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(pay_sale_response.payme_sale_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "function_name": "get_pay_sale_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Payme error response transformer"}, {"query": "hyperswitch Payme connector PayRequest struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: PayRequest\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "PayRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Payme PayRequest struct definition"}, {"query": "Payme payment gateway integration hyperswitch Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: PayRequest\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "PayRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Payme PayRequest struct definition"}, {"query": "PaymeCard struct serialization hyperswitch PayRequest", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: PayRequest\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "PayRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Payme PayRequest struct definition"}, {"query": "hyperswitch connectors payme transformer input model", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: PayRequest\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "function_name": "PayRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "Payme PayRequest struct definition"}, {"query": "rust hyperswitch zift connector get_request_body implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift Setup Mandate Request Adapter"}, {"query": "how does hyperswitch zift setup mandate request work", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift Setup Mandate Request Adapter"}, {"query": "zift connector hyperswitch rust setup_mandate_request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift Setup Mandate Request Adapter"}, {"query": "hyperswitch zift adapter request body transformation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift Setup Mandate Request Adapter"}, {"query": "Signifyd API product item struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Products\npub struct Products {\n    item_name: String,\n    item_price: i64,\n    item_quantity: i32,\n    item_id: Option<String>,\n    item_category: Option<String>,\n    item_sub_category: Option<String>,\n    item_is_digital: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Products", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Product Item Struct"}, {"query": "how to map Signifyd product data to internal models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Products\npub struct Products {\n    item_name: String,\n    item_price: i64,\n    item_quantity: i32,\n    item_id: Option<String>,\n    item_category: Option<String>,\n    item_sub_category: Option<String>,\n    item_is_digital: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Products", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Product Item Struct"}, {"query": "Signifyd connector item_name item_price fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Products\npub struct Products {\n    item_name: String,\n    item_price: i64,\n    item_quantity: i32,\n    item_id: Option<String>,\n    item_category: Option<String>,\n    item_sub_category: Option<String>,\n    item_is_digital: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Products", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Product Item Struct"}, {"query": "hyperswitch signifyd product transformation struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Products\npub struct Products {\n    item_name: String,\n    item_price: i64,\n    item_quantity: i32,\n    item_id: Option<String>,\n    item_category: Option<String>,\n    item_sub_category: Option<String>,\n    item_is_digital: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Products", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Product Item Struct"}, {"query": "IatapayPaymentsRequest struct definition rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsRequest\npub struct IatapayPaymentsRequest {\n    merchant_id: Secret<String>,\n    merchant_payment_id: Option<String>,\n    amount: FloatMajorUnit,\n    currency: common_enums::Currency,\n    country: common_enums::CountryAlpha2,\n    locale: String,\n    redirect_urls: RedirectUrls,\n    notification_url: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    payer_info: Option<PayerInfo>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    preferred_checkout_method: Option<PreferredCheckoutMethod>,\n}\n\nimpl\n    TryFrom<&IatapayRouterData<&RouterData<Authorize, PaymentsAuthorizeData, PaymentsResponseData>>>\n    for IatapayPaymentsRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n", "function_name": "IatapayPaymentsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IatapayPaymentsRequest struct"}, {"query": "how to construct IatapayPaymentsRequest object", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsRequest\npub struct IatapayPaymentsRequest {\n    merchant_id: Secret<String>,\n    merchant_payment_id: Option<String>,\n    amount: FloatMajorUnit,\n    currency: common_enums::Currency,\n    country: common_enums::CountryAlpha2,\n    locale: String,\n    redirect_urls: RedirectUrls,\n    notification_url: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    payer_info: Option<PayerInfo>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    preferred_checkout_method: Option<PreferredCheckoutMethod>,\n}\n\nimpl\n    TryFrom<&IatapayRouterData<&RouterData<Authorize, PaymentsAuthorizeData, PaymentsResponseData>>>\n    for IatapayPaymentsRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n", "function_name": "IatapayPaymentsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IatapayPaymentsRequest struct"}, {"query": "IatapayPaymentsRequest serde skip_serializing_if", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsRequest\npub struct IatapayPaymentsRequest {\n    merchant_id: Secret<String>,\n    merchant_payment_id: Option<String>,\n    amount: FloatMajorUnit,\n    currency: common_enums::Currency,\n    country: common_enums::CountryAlpha2,\n    locale: String,\n    redirect_urls: RedirectUrls,\n    notification_url: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    payer_info: Option<PayerInfo>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    preferred_checkout_method: Option<PreferredCheckoutMethod>,\n}\n\nimpl\n    TryFrom<&IatapayRouterData<&RouterData<Authorize, PaymentsAuthorizeData, PaymentsResponseData>>>\n    for IatapayPaymentsRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n", "function_name": "IatapayPaymentsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IatapayPaymentsRequest struct"}, {"query": "IatapayPaymentsRequest fields documentation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsRequest\npub struct IatapayPaymentsRequest {\n    merchant_id: Secret<String>,\n    merchant_payment_id: Option<String>,\n    amount: FloatMajorUnit,\n    currency: common_enums::Currency,\n    country: common_enums::CountryAlpha2,\n    locale: String,\n    redirect_urls: RedirectUrls,\n    notification_url: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    payer_info: Option<PayerInfo>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    preferred_checkout_method: Option<PreferredCheckoutMethod>,\n}\n\nimpl\n    TryFrom<&IatapayRouterData<&RouterData<Authorize, PaymentsAuthorizeData, PaymentsResponseData>>>\n    for IatapayPaymentsRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n", "function_name": "IatapayPaymentsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IatapayPaymentsRequest struct"}, {"query": "how to convert amount for juspay 3ds connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data =\n            juspaythreedsserver::JuspaythreedsserverRouterData::from((amount, req));\n        let connector_req = juspaythreedsserver::JuspaythreedsserverPaymentsRequest::try_from(\n            &connector_router_data,\n        )?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS request payload builder"}, {"query": "juspaythreedsserverPaymentsRequest builder implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data =\n            juspaythreedsserver::JuspaythreedsserverRouterData::from((amount, req));\n        let connector_req = juspaythreedsserver::JuspaythreedsserverPaymentsRequest::try_from(\n            &connector_router_data,\n        )?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS request payload builder"}, {"query": "PaymentsAuthorizeRouterData to juspaythreedsserver conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data =\n            juspaythreedsserver::JuspaythreedsserverRouterData::from((amount, req));\n        let connector_req = juspaythreedsserver::JuspaythreedsserverPaymentsRequest::try_from(\n            &connector_router_data,\n        )?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS request payload builder"}, {"query": "hyperswitch juspay connector request body format", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data =\n            juspaythreedsserver::JuspaythreedsserverRouterData::from((amount, req));\n        let connector_req = juspaythreedsserver::JuspaythreedsserverPaymentsRequest::try_from(\n            &connector_router_data,\n        )?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS request payload builder"}, {"query": "hyperswitch gigadat validate_mandate_payment implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat mandate validation filter"}, {"query": "how to handle card mandates in gigadat connector rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat mandate validation filter"}, {"query": "hyperswitch gigadat recurring payment validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat mandate validation filter"}, {"query": "gigadat connector validate_mandate_payment error NotImplemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat mandate validation filter"}, {"query": "rust hyperswitch authentication eligibility request struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityRequest\npub struct AuthenticationEligibilityRequest {\n    /// Payment method-specific data such as card details, wallet info, etc.\n    /// This holds the raw information required to process the payment method.\n    #[schema(value_type = PaymentMethodData)]\n    pub payment_method_data: PaymentMethodData,\n\n    /// Enum representing the type of payment method being used\n    /// (e.g., Card, Wallet, UPI, BankTransfer, etc.).\n    #[schema(value_type = PaymentMethod)]\n    pub payment_method: common_enums::PaymentMethod,\n\n    /// Can be used to specify the Payment Method Type\n    #[schema(value_type = Option<PaymentMethodType>, example = \"debit\")]\n    pub payment_method_type: Option<enums::PaymentMethodType>,\n\n    /// Optional secret value used to identify and authorize the client making the request.\n    /// This can help ensure that the payment session is secure and valid.\n    #[schema(value_type = Option<String>)]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// Optional identifier for the business profile associated with the payment.\n    /// This determines which configurations, rules, and branding are applied to the transaction.\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Optional billing address of the customer.\n    /// This can be used for fraud detection, authentication, or compliance purposes.\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n\n    /// Optional shipping address of the customer.\n    /// This can be useful for logistics, verification, or additional risk checks.\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n\n    /// Optional information about the customer's browser (user-agent, language, etc.).\n    /// This is typically used to support 3DS authentication flows and improve risk assessment.\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n\n    /// Optional email address of the customer.\n    /// Used for customer identification, communication, and possibly for 3DS or fraud checks.\n    #[schema(value_type = Option<String>)]\n    pub email: Option<common_utils::pii::Email>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "AuthenticationEligibilityRequest", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication eligibility request struct"}, {"query": "how to construct AuthenticationEligibilityRequest for 3ds flow", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityRequest\npub struct AuthenticationEligibilityRequest {\n    /// Payment method-specific data such as card details, wallet info, etc.\n    /// This holds the raw information required to process the payment method.\n    #[schema(value_type = PaymentMethodData)]\n    pub payment_method_data: PaymentMethodData,\n\n    /// Enum representing the type of payment method being used\n    /// (e.g., Card, Wallet, UPI, BankTransfer, etc.).\n    #[schema(value_type = PaymentMethod)]\n    pub payment_method: common_enums::PaymentMethod,\n\n    /// Can be used to specify the Payment Method Type\n    #[schema(value_type = Option<PaymentMethodType>, example = \"debit\")]\n    pub payment_method_type: Option<enums::PaymentMethodType>,\n\n    /// Optional secret value used to identify and authorize the client making the request.\n    /// This can help ensure that the payment session is secure and valid.\n    #[schema(value_type = Option<String>)]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// Optional identifier for the business profile associated with the payment.\n    /// This determines which configurations, rules, and branding are applied to the transaction.\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Optional billing address of the customer.\n    /// This can be used for fraud detection, authentication, or compliance purposes.\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n\n    /// Optional shipping address of the customer.\n    /// This can be useful for logistics, verification, or additional risk checks.\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n\n    /// Optional information about the customer's browser (user-agent, language, etc.).\n    /// This is typically used to support 3DS authentication flows and improve risk assessment.\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n\n    /// Optional email address of the customer.\n    /// Used for customer identification, communication, and possibly for 3DS or fraud checks.\n    #[schema(value_type = Option<String>)]\n    pub email: Option<common_utils::pii::Email>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "AuthenticationEligibilityRequest", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication eligibility request struct"}, {"query": "hyperswitch api_models AuthenticationEligibilityRequest payment_method_data", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityRequest\npub struct AuthenticationEligibilityRequest {\n    /// Payment method-specific data such as card details, wallet info, etc.\n    /// This holds the raw information required to process the payment method.\n    #[schema(value_type = PaymentMethodData)]\n    pub payment_method_data: PaymentMethodData,\n\n    /// Enum representing the type of payment method being used\n    /// (e.g., Card, Wallet, UPI, BankTransfer, etc.).\n    #[schema(value_type = PaymentMethod)]\n    pub payment_method: common_enums::PaymentMethod,\n\n    /// Can be used to specify the Payment Method Type\n    #[schema(value_type = Option<PaymentMethodType>, example = \"debit\")]\n    pub payment_method_type: Option<enums::PaymentMethodType>,\n\n    /// Optional secret value used to identify and authorize the client making the request.\n    /// This can help ensure that the payment session is secure and valid.\n    #[schema(value_type = Option<String>)]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// Optional identifier for the business profile associated with the payment.\n    /// This determines which configurations, rules, and branding are applied to the transaction.\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Optional billing address of the customer.\n    /// This can be used for fraud detection, authentication, or compliance purposes.\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n\n    /// Optional shipping address of the customer.\n    /// This can be useful for logistics, verification, or additional risk checks.\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n\n    /// Optional information about the customer's browser (user-agent, language, etc.).\n    /// This is typically used to support 3DS authentication flows and improve risk assessment.\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n\n    /// Optional email address of the customer.\n    /// Used for customer identification, communication, and possibly for 3DS or fraud checks.\n    #[schema(value_type = Option<String>)]\n    pub email: Option<common_utils::pii::Email>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "AuthenticationEligibilityRequest", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication eligibility request struct"}, {"query": "rust struct definition for payment authentication eligibility check", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityRequest\npub struct AuthenticationEligibilityRequest {\n    /// Payment method-specific data such as card details, wallet info, etc.\n    /// This holds the raw information required to process the payment method.\n    #[schema(value_type = PaymentMethodData)]\n    pub payment_method_data: PaymentMethodData,\n\n    /// Enum representing the type of payment method being used\n    /// (e.g., Card, Wallet, UPI, BankTransfer, etc.).\n    #[schema(value_type = PaymentMethod)]\n    pub payment_method: common_enums::PaymentMethod,\n\n    /// Can be used to specify the Payment Method Type\n    #[schema(value_type = Option<PaymentMethodType>, example = \"debit\")]\n    pub payment_method_type: Option<enums::PaymentMethodType>,\n\n    /// Optional secret value used to identify and authorize the client making the request.\n    /// This can help ensure that the payment session is secure and valid.\n    #[schema(value_type = Option<String>)]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// Optional identifier for the business profile associated with the payment.\n    /// This determines which configurations, rules, and branding are applied to the transaction.\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Optional billing address of the customer.\n    /// This can be used for fraud detection, authentication, or compliance purposes.\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n\n    /// Optional shipping address of the customer.\n    /// This can be useful for logistics, verification, or additional risk checks.\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n\n    /// Optional information about the customer's browser (user-agent, language, etc.).\n    /// This is typically used to support 3DS authentication flows and improve risk assessment.\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n\n    /// Optional email address of the customer.\n    /// Used for customer identification, communication, and possibly for 3DS or fraud checks.\n    #[schema(value_type = Option<String>)]\n    pub email: Option<common_utils::pii::Email>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "AuthenticationEligibilityRequest", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "Authentication eligibility request struct"}, {"query": "how to configure Sift connector authentication headers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector header builder"}, {"query": "rust hyperswitch sift connector build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector header builder"}, {"query": "hyperswitch sift payment connector header setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector header builder"}, {"query": "sift connector hyperswitch rust get_auth_header usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector header builder"}, {"query": "Rust trait implementation for Thunes payment gateway integration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Thunes\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Thunes\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector integration"}, {"query": "Hyperswitch Thunes connector tokenization logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Thunes\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Thunes\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector integration"}, {"query": "ConnectorIntegration trait definition for Thunes", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Thunes\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Thunes\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector integration"}, {"query": "Thunes payment gateway Rust SDK implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Thunes\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Thunes\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector integration"}, {"query": "how to find payment intent by connector transaction id in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_payment_id_type\npub async fn find_payment_intent_from_payment_id_type(\n    state: &SessionState,\n    payment_id_type: payments::PaymentIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    match payment_id_type {\n        payments::PaymentIdType::PaymentIntentId(payment_id) => db\n            .find_payment_intent_by_payment_id_processor_merchant_id(\n                &payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound),\n        payments::PaymentIdType::ConnectorTransactionId(connector_transaction_id) => {\n            let attempt = db\n                .find_payment_attempt_by_processor_merchant_id_connector_txn_id(\n                    platform.get_processor().get_account().get_id(),\n                    &connector_transaction_id,\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PaymentAttemptId(attempt_id) => {\n            let attempt = db\n                .find_payment_attempt_by_attempt_id_processor_merchant_id(\n                    &attempt_id,\n                    platform.get_processor().get_account().get_id(),\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PreprocessingId(_) => {\n            Err(errors::ApiErrorResponse::PaymentNotFound)?\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_payment_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "payment intent resolution utility"}, {"query": "hyperswitch router find_payment_intent_from_payment_id_type implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_payment_id_type\npub async fn find_payment_intent_from_payment_id_type(\n    state: &SessionState,\n    payment_id_type: payments::PaymentIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    match payment_id_type {\n        payments::PaymentIdType::PaymentIntentId(payment_id) => db\n            .find_payment_intent_by_payment_id_processor_merchant_id(\n                &payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound),\n        payments::PaymentIdType::ConnectorTransactionId(connector_transaction_id) => {\n            let attempt = db\n                .find_payment_attempt_by_processor_merchant_id_connector_txn_id(\n                    platform.get_processor().get_account().get_id(),\n                    &connector_transaction_id,\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PaymentAttemptId(attempt_id) => {\n            let attempt = db\n                .find_payment_attempt_by_attempt_id_processor_merchant_id(\n                    &attempt_id,\n                    platform.get_processor().get_account().get_id(),\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PreprocessingId(_) => {\n            Err(errors::ApiErrorResponse::PaymentNotFound)?\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_payment_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "payment intent resolution utility"}, {"query": "resolve payment intent from payment attempt id rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_payment_id_type\npub async fn find_payment_intent_from_payment_id_type(\n    state: &SessionState,\n    payment_id_type: payments::PaymentIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    match payment_id_type {\n        payments::PaymentIdType::PaymentIntentId(payment_id) => db\n            .find_payment_intent_by_payment_id_processor_merchant_id(\n                &payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound),\n        payments::PaymentIdType::ConnectorTransactionId(connector_transaction_id) => {\n            let attempt = db\n                .find_payment_attempt_by_processor_merchant_id_connector_txn_id(\n                    platform.get_processor().get_account().get_id(),\n                    &connector_transaction_id,\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PaymentAttemptId(attempt_id) => {\n            let attempt = db\n                .find_payment_attempt_by_attempt_id_processor_merchant_id(\n                    &attempt_id,\n                    platform.get_processor().get_account().get_id(),\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PreprocessingId(_) => {\n            Err(errors::ApiErrorResponse::PaymentNotFound)?\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_payment_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "payment intent resolution utility"}, {"query": "hyperswitch payment orchestration platform get payment intent by id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_payment_id_type\npub async fn find_payment_intent_from_payment_id_type(\n    state: &SessionState,\n    payment_id_type: payments::PaymentIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    match payment_id_type {\n        payments::PaymentIdType::PaymentIntentId(payment_id) => db\n            .find_payment_intent_by_payment_id_processor_merchant_id(\n                &payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound),\n        payments::PaymentIdType::ConnectorTransactionId(connector_transaction_id) => {\n            let attempt = db\n                .find_payment_attempt_by_processor_merchant_id_connector_txn_id(\n                    platform.get_processor().get_account().get_id(),\n                    &connector_transaction_id,\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PaymentAttemptId(attempt_id) => {\n            let attempt = db\n                .find_payment_attempt_by_attempt_id_processor_merchant_id(\n                    &attempt_id,\n                    platform.get_processor().get_account().get_id(),\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PreprocessingId(_) => {\n            Err(errors::ApiErrorResponse::PaymentNotFound)?\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "find_payment_intent_from_payment_id_type", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "payment intent resolution utility"}, {"query": "rust hyperswitch itapay connector get_redirect_url implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_redirect_url\nfn get_redirect_url(return_url: String) -> RedirectUrls {\n    RedirectUrls {\n        success_url: return_url.clone(),\n        failure_url: return_url,\n    }\n}\n\n// Auth Struct", "function_name": "get_redirect_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iTapay redirect URL builder"}, {"query": "how to configure success and failure URLs in hyperswitch itapay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_redirect_url\nfn get_redirect_url(return_url: String) -> RedirectUrls {\n    RedirectUrls {\n        success_url: return_url.clone(),\n        failure_url: return_url,\n    }\n}\n\n// Auth Struct", "function_name": "get_redirect_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iTapay redirect URL builder"}, {"query": "hyperswitch iatapay redirect_url function source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_redirect_url\nfn get_redirect_url(return_url: String) -> RedirectUrls {\n    RedirectUrls {\n        success_url: return_url.clone(),\n        failure_url: return_url,\n    }\n}\n\n// Auth Struct", "function_name": "get_redirect_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iTapay redirect URL builder"}, {"query": "rust struct RedirectUrls hyperswitch itapay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_redirect_url\nfn get_redirect_url(return_url: String) -> RedirectUrls {\n    RedirectUrls {\n        success_url: return_url.clone(),\n        failure_url: return_url,\n    }\n}\n\n// Auth Struct", "function_name": "get_redirect_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "iTapay redirect URL builder"}, {"query": "rust struct definition for IatapayPaymentsResponse", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsResponse\npub struct IatapayPaymentsResponse {\n    pub status: IatapayPaymentStatus,\n    pub iata_payment_id: Option<String>,\n    pub iata_refund_id: Option<String>,\n    pub merchant_id: Option<Secret<String>>,\n    pub merchant_payment_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n    pub checkout_methods: Option<CheckoutMethod>,\n    pub failure_code: Option<String>,\n    pub failure_details: Option<String>,\n}\n", "function_name": "IatapayPaymentsResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay payment response model"}, {"query": "IATAPay connector response model hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsResponse\npub struct IatapayPaymentsResponse {\n    pub status: IatapayPaymentStatus,\n    pub iata_payment_id: Option<String>,\n    pub iata_refund_id: Option<String>,\n    pub merchant_id: Option<Secret<String>>,\n    pub merchant_payment_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n    pub checkout_methods: Option<CheckoutMethod>,\n    pub failure_code: Option<String>,\n    pub failure_details: Option<String>,\n}\n", "function_name": "IatapayPaymentsResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay payment response model"}, {"query": "hyperswitch IATAPay payment response fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsResponse\npub struct IatapayPaymentsResponse {\n    pub status: IatapayPaymentStatus,\n    pub iata_payment_id: Option<String>,\n    pub iata_refund_id: Option<String>,\n    pub merchant_id: Option<Secret<String>>,\n    pub merchant_payment_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n    pub checkout_methods: Option<CheckoutMethod>,\n    pub failure_code: Option<String>,\n    pub failure_details: Option<String>,\n}\n", "function_name": "IatapayPaymentsResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay payment response model"}, {"query": "IatapayPaymentsResponse struct definition rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsResponse\npub struct IatapayPaymentsResponse {\n    pub status: IatapayPaymentStatus,\n    pub iata_payment_id: Option<String>,\n    pub iata_refund_id: Option<String>,\n    pub merchant_id: Option<Secret<String>>,\n    pub merchant_payment_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n    pub checkout_methods: Option<CheckoutMethod>,\n    pub failure_code: Option<String>,\n    pub failure_details: Option<String>,\n}\n", "function_name": "IatapayPaymentsResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay payment response model"}, {"query": "how to handle Juspay 3DS authorize response in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverPaymentsResponse = res\n            .response\n            .parse_struct(\"Juspaythreedsserver PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS authorize response handler"}, {"query": "JuspaythreedsserverPaymentsResponse deserialization error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverPaymentsResponse = res\n            .response\n            .parse_struct(\"Juspaythreedsserver PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS authorize response handler"}, {"query": "hyperswitch juspay connector handle_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverPaymentsResponse = res\n            .response\n            .parse_struct(\"Juspaythreedsserver PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS authorize response handler"}, {"query": "parse Juspay 3DS server response body", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverPaymentsResponse = res\n            .response\n            .parse_struct(\"Juspaythreedsserver PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS authorize response handler"}, {"query": "Elavon SSL certificate validation error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SslResult\nenum SslResult {\n    #[serde(rename = \"0\")]\n    ImportedBatchFile,\n    #[serde(other)]\n    DeclineOrUnauthorized,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "SslResult", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon SSL validation error enum"}, {"query": "SslResult enum definition Elavon connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SslResult\nenum SslResult {\n    #[serde(rename = \"0\")]\n    ImportedBatchFile,\n    #[serde(other)]\n    DeclineOrUnauthorized,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "SslResult", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon SSL validation error enum"}, {"query": "Elavon API error code 0 mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SslResult\nenum SslResult {\n    #[serde(rename = \"0\")]\n    ImportedBatchFile,\n    #[serde(other)]\n    DeclineOrUnauthorized,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "SslResult", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon SSL validation error enum"}, {"query": "Rust enum for SSL certificate validation failures", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SslResult\nenum SslResult {\n    #[serde(rename = \"0\")]\n    ImportedBatchFile,\n    #[serde(other)]\n    DeclineOrUnauthorized,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "SslResult", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon SSL validation error enum"}, {"query": "rust hyperswitch zift connector handle_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector response handler"}, {"query": "how does hyperswitch zift connector handle response deserialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector response handler"}, {"query": "hyperswitch zift setup mandate router data response handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector response handler"}, {"query": "rust connector error handling in hyperswitch zift handle_response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift connector response handler"}, {"query": "How to initialize storage interfaces for multiple tenants in parallel", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_accounts_store_interface_map\n    pub async fn get_accounts_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::AccountsStorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_accounts_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    #[cfg(feature = \"olap\")]", "function_name": "get_accounts_store_interface_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Tenant storage interface map initialization"}, {"query": "Rust code for creating accounts storage interface map", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_accounts_store_interface_map\n    pub async fn get_accounts_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::AccountsStorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_accounts_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    #[cfg(feature = \"olap\")]", "function_name": "get_accounts_store_interface_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Tenant storage interface map initialization"}, {"query": "get_accounts_store_interface_map implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_accounts_store_interface_map\n    pub async fn get_accounts_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::AccountsStorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_accounts_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    #[cfg(feature = \"olap\")]", "function_name": "get_accounts_store_interface_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Tenant storage interface map initialization"}, {"query": "hyperswitch router tenant storage interface initialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_accounts_store_interface_map\n    pub async fn get_accounts_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::AccountsStorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_accounts_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    #[cfg(feature = \"olap\")]", "function_name": "get_accounts_store_interface_map", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Tenant storage interface map initialization"}, {"query": "how to check if payment method is supported for mandate in cybersource connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n            PaymentMethodDataType::SamsungPay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Cybersource\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource mandate validation"}, {"query": "cybersource mandate supported payment methods list rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n            PaymentMethodDataType::SamsungPay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Cybersource\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource mandate validation"}, {"query": "validate_mandate_payment function cybersource connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n            PaymentMethodDataType::SamsungPay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Cybersource\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource mandate validation"}, {"query": "what payment methods support mandates in cybersource hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n            PaymentMethodDataType::SamsungPay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Cybersource\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource mandate validation"}, {"query": "how to extract mandate id from worldpay token response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_mandate_id\n    pub fn get_mandate_id(&self) -> Option<MandateReference> {\n        self.token.clone().map(|mandate_id| MandateReference {\n            connector_mandate_id: Some(mandate_id.href.expose()),\n            payment_method_id: None,\n            mandate_metadata: None,\n            connector_mandate_request_reference_id: None,\n        })\n    }\n}\n", "function_name": "get_mandate_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "WorldPay mandate ID extraction"}, {"query": "worldpay modular connector mandate reference mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_mandate_id\n    pub fn get_mandate_id(&self) -> Option<MandateReference> {\n        self.token.clone().map(|mandate_id| MandateReference {\n            connector_mandate_id: Some(mandate_id.href.expose()),\n            payment_method_id: None,\n            mandate_metadata: None,\n            connector_mandate_request_reference_id: None,\n        })\n    }\n}\n", "function_name": "get_mandate_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "WorldPay mandate ID extraction"}, {"query": "hyperswitch worldpay mandate_id extraction logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_mandate_id\n    pub fn get_mandate_id(&self) -> Option<MandateReference> {\n        self.token.clone().map(|mandate_id| MandateReference {\n            connector_mandate_id: Some(mandate_id.href.expose()),\n            payment_method_id: None,\n            mandate_metadata: None,\n            connector_mandate_request_reference_id: None,\n        })\n    }\n}\n", "function_name": "get_mandate_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "WorldPay mandate ID extraction"}, {"query": "get_mandate_id worldpay connector rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_mandate_id\n    pub fn get_mandate_id(&self) -> Option<MandateReference> {\n        self.token.clone().map(|mandate_id| MandateReference {\n            connector_mandate_id: Some(mandate_id.href.expose()),\n            payment_method_id: None,\n            mandate_metadata: None,\n            connector_mandate_request_reference_id: None,\n        })\n    }\n}\n", "function_name": "get_mandate_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "WorldPay mandate ID extraction"}, {"query": "Hyperswitch router configuration struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: Settings\npub struct Settings<S: SecretState> {\n    pub server: Server,\n    pub application_source: common_enums::ApplicationSource,\n    pub proxy: Proxy,\n    pub env: Env,\n    pub chat: SecretStateContainer<ChatSettings, S>,\n    pub master_database: SecretStateContainer<Database, S>,\n    #[cfg(feature = \"olap\")]\n    pub replica_database: SecretStateContainer<Database, S>,\n    pub redis: RedisSettings,\n    pub log: Log,\n    pub secrets: SecretStateContainer<Secrets, S>,\n    pub fallback_merchant_ids_api_key_auth: Option<FallbackMerchantIds>,\n    pub locker: Locker,\n    pub key_manager: SecretStateContainer<KeyManagerConfig, S>,\n    pub connectors: Connectors,\n    pub forex_api: SecretStateContainer<ForexApi, S>,\n    pub refund: Refund,\n    pub eph_key: EphemeralConfig,\n    pub scheduler: Option<SchedulerSettings>,\n    #[cfg(feature = \"kv_store\")]\n    pub drainer: DrainerSettings,\n    pub jwekey: SecretStateContainer<Jwekey, S>,\n    pub webhooks: WebhooksSettings,\n    pub pm_filters: ConnectorFilters,\n    pub bank_config: BankRedirectConfig,\n    pub api_keys: SecretStateContainer<ApiKeys, S>,\n    pub file_storage: FileStorageConfig,\n    pub encryption_management: EncryptionManagementConfig,\n    pub secrets_management: SecretsManagementConfig,\n    pub tokenization: TokenizationConfig,\n    pub connector_customer: ConnectorCustomer,\n    #[cfg(feature = \"dummy_connector\")]\n    pub dummy_connector: DummyConnector,\n    #[cfg(feature = \"email\")]\n    pub email: EmailSettings,\n    pub user: UserSettings,\n    pub oidc: SecretStateContainer<OidcSettings, S>,\n    pub crm: CrmManagerConfig,\n    pub cors: CorsSettings,\n    pub mandates: Mandates,\n    pub zero_mandates: ZeroMandates,\n    pub network_transaction_id_supported_connectors: NetworkTransactionIdSupportedConnectors,\n    pub card_only_mit_supported_connectors: CardOnlyMitSupportedConnectors,\n    pub list_dispute_supported_connectors: ListDiputeSupportedConnectors,\n    pub required_fields: RequiredFields,\n    pub delayed_session_response: DelayedSessionConfig,\n    pub webhook_source_verification_call: WebhookSourceVerificationCall,\n    pub billing_connectors_payment_sync: BillingConnectorPaymentsSyncCall,\n    pub billing_connectors_invoice_sync: BillingConnectorInvoiceSyncCall,\n    pub payment_method_auth: SecretStateContainer<PaymentMethodAuth, S>,\n    pub connector_request_reference_id_config: ConnectorRequestReferenceIdConfig,\n    #[cfg(feature = \"payouts\")]\n    pub payou\n\n... [truncated 2088 chars] ...\n\nure = \"v2\")]\n    pub revenue_recovery: revenue_recovery::RevenueRecoverySettings,\n    pub merchant_advice_codes: MerchantAdviceCodeLookupConfig,\n    pub clone_connector_allowlist: Option<CloneConnectorAllowlistConfig>,\n    pub merchant_id_auth: MerchantIdAuthSettings,\n    pub internal_merchant_id_profile_id_auth: InternalMerchantIdProfileIdAuthSettings,\n    #[serde(default)]\n    pub infra_values: Option<HashMap<String, String>>,\n    #[serde(default)]\n    pub enhancement: Option<HashMap<String, String>>,\n    pub superposition: SecretStateContainer<SuperpositionClientConfig, S>,\n    pub proxy_status_mapping: ProxyStatusMapping,\n    pub trace_header: TraceHeaderConfig,\n    pub internal_services: InternalServicesConfig,\n    #[serde(default)]\n    pub micro_services: MicroServicesConfig,\n    pub comparison_service: Option<ComparisonServiceConfig>,\n    pub authentication_service_enabled_connectors: AuthenticationServiceEnabledConnectors,\n    pub save_payment_method_on_session: OnSessionConfig,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "Settings", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router configuration struct"}, {"query": "how to configure PostgreSQL master and replica connections in Settings", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: Settings\npub struct Settings<S: SecretState> {\n    pub server: Server,\n    pub application_source: common_enums::ApplicationSource,\n    pub proxy: Proxy,\n    pub env: Env,\n    pub chat: SecretStateContainer<ChatSettings, S>,\n    pub master_database: SecretStateContainer<Database, S>,\n    #[cfg(feature = \"olap\")]\n    pub replica_database: SecretStateContainer<Database, S>,\n    pub redis: RedisSettings,\n    pub log: Log,\n    pub secrets: SecretStateContainer<Secrets, S>,\n    pub fallback_merchant_ids_api_key_auth: Option<FallbackMerchantIds>,\n    pub locker: Locker,\n    pub key_manager: SecretStateContainer<KeyManagerConfig, S>,\n    pub connectors: Connectors,\n    pub forex_api: SecretStateContainer<ForexApi, S>,\n    pub refund: Refund,\n    pub eph_key: EphemeralConfig,\n    pub scheduler: Option<SchedulerSettings>,\n    #[cfg(feature = \"kv_store\")]\n    pub drainer: DrainerSettings,\n    pub jwekey: SecretStateContainer<Jwekey, S>,\n    pub webhooks: WebhooksSettings,\n    pub pm_filters: ConnectorFilters,\n    pub bank_config: BankRedirectConfig,\n    pub api_keys: SecretStateContainer<ApiKeys, S>,\n    pub file_storage: FileStorageConfig,\n    pub encryption_management: EncryptionManagementConfig,\n    pub secrets_management: SecretsManagementConfig,\n    pub tokenization: TokenizationConfig,\n    pub connector_customer: ConnectorCustomer,\n    #[cfg(feature = \"dummy_connector\")]\n    pub dummy_connector: DummyConnector,\n    #[cfg(feature = \"email\")]\n    pub email: EmailSettings,\n    pub user: UserSettings,\n    pub oidc: SecretStateContainer<OidcSettings, S>,\n    pub crm: CrmManagerConfig,\n    pub cors: CorsSettings,\n    pub mandates: Mandates,\n    pub zero_mandates: ZeroMandates,\n    pub network_transaction_id_supported_connectors: NetworkTransactionIdSupportedConnectors,\n    pub card_only_mit_supported_connectors: CardOnlyMitSupportedConnectors,\n    pub list_dispute_supported_connectors: ListDiputeSupportedConnectors,\n    pub required_fields: RequiredFields,\n    pub delayed_session_response: DelayedSessionConfig,\n    pub webhook_source_verification_call: WebhookSourceVerificationCall,\n    pub billing_connectors_payment_sync: BillingConnectorPaymentsSyncCall,\n    pub billing_connectors_invoice_sync: BillingConnectorInvoiceSyncCall,\n    pub payment_method_auth: SecretStateContainer<PaymentMethodAuth, S>,\n    pub connector_request_reference_id_config: ConnectorRequestReferenceIdConfig,\n    #[cfg(feature = \"payouts\")]\n    pub payou\n\n... [truncated 2088 chars] ...\n\nure = \"v2\")]\n    pub revenue_recovery: revenue_recovery::RevenueRecoverySettings,\n    pub merchant_advice_codes: MerchantAdviceCodeLookupConfig,\n    pub clone_connector_allowlist: Option<CloneConnectorAllowlistConfig>,\n    pub merchant_id_auth: MerchantIdAuthSettings,\n    pub internal_merchant_id_profile_id_auth: InternalMerchantIdProfileIdAuthSettings,\n    #[serde(default)]\n    pub infra_values: Option<HashMap<String, String>>,\n    #[serde(default)]\n    pub enhancement: Option<HashMap<String, String>>,\n    pub superposition: SecretStateContainer<SuperpositionClientConfig, S>,\n    pub proxy_status_mapping: ProxyStatusMapping,\n    pub trace_header: TraceHeaderConfig,\n    pub internal_services: InternalServicesConfig,\n    #[serde(default)]\n    pub micro_services: MicroServicesConfig,\n    pub comparison_service: Option<ComparisonServiceConfig>,\n    pub authentication_service_enabled_connectors: AuthenticationServiceEnabledConnectors,\n    pub save_payment_method_on_session: OnSessionConfig,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "Settings", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router configuration struct"}, {"query": "Hyperswitch settings struct secret state container usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: Settings\npub struct Settings<S: SecretState> {\n    pub server: Server,\n    pub application_source: common_enums::ApplicationSource,\n    pub proxy: Proxy,\n    pub env: Env,\n    pub chat: SecretStateContainer<ChatSettings, S>,\n    pub master_database: SecretStateContainer<Database, S>,\n    #[cfg(feature = \"olap\")]\n    pub replica_database: SecretStateContainer<Database, S>,\n    pub redis: RedisSettings,\n    pub log: Log,\n    pub secrets: SecretStateContainer<Secrets, S>,\n    pub fallback_merchant_ids_api_key_auth: Option<FallbackMerchantIds>,\n    pub locker: Locker,\n    pub key_manager: SecretStateContainer<KeyManagerConfig, S>,\n    pub connectors: Connectors,\n    pub forex_api: SecretStateContainer<ForexApi, S>,\n    pub refund: Refund,\n    pub eph_key: EphemeralConfig,\n    pub scheduler: Option<SchedulerSettings>,\n    #[cfg(feature = \"kv_store\")]\n    pub drainer: DrainerSettings,\n    pub jwekey: SecretStateContainer<Jwekey, S>,\n    pub webhooks: WebhooksSettings,\n    pub pm_filters: ConnectorFilters,\n    pub bank_config: BankRedirectConfig,\n    pub api_keys: SecretStateContainer<ApiKeys, S>,\n    pub file_storage: FileStorageConfig,\n    pub encryption_management: EncryptionManagementConfig,\n    pub secrets_management: SecretsManagementConfig,\n    pub tokenization: TokenizationConfig,\n    pub connector_customer: ConnectorCustomer,\n    #[cfg(feature = \"dummy_connector\")]\n    pub dummy_connector: DummyConnector,\n    #[cfg(feature = \"email\")]\n    pub email: EmailSettings,\n    pub user: UserSettings,\n    pub oidc: SecretStateContainer<OidcSettings, S>,\n    pub crm: CrmManagerConfig,\n    pub cors: CorsSettings,\n    pub mandates: Mandates,\n    pub zero_mandates: ZeroMandates,\n    pub network_transaction_id_supported_connectors: NetworkTransactionIdSupportedConnectors,\n    pub card_only_mit_supported_connectors: CardOnlyMitSupportedConnectors,\n    pub list_dispute_supported_connectors: ListDiputeSupportedConnectors,\n    pub required_fields: RequiredFields,\n    pub delayed_session_response: DelayedSessionConfig,\n    pub webhook_source_verification_call: WebhookSourceVerificationCall,\n    pub billing_connectors_payment_sync: BillingConnectorPaymentsSyncCall,\n    pub billing_connectors_invoice_sync: BillingConnectorInvoiceSyncCall,\n    pub payment_method_auth: SecretStateContainer<PaymentMethodAuth, S>,\n    pub connector_request_reference_id_config: ConnectorRequestReferenceIdConfig,\n    #[cfg(feature = \"payouts\")]\n    pub payou\n\n... [truncated 2088 chars] ...\n\nure = \"v2\")]\n    pub revenue_recovery: revenue_recovery::RevenueRecoverySettings,\n    pub merchant_advice_codes: MerchantAdviceCodeLookupConfig,\n    pub clone_connector_allowlist: Option<CloneConnectorAllowlistConfig>,\n    pub merchant_id_auth: MerchantIdAuthSettings,\n    pub internal_merchant_id_profile_id_auth: InternalMerchantIdProfileIdAuthSettings,\n    #[serde(default)]\n    pub infra_values: Option<HashMap<String, String>>,\n    #[serde(default)]\n    pub enhancement: Option<HashMap<String, String>>,\n    pub superposition: SecretStateContainer<SuperpositionClientConfig, S>,\n    pub proxy_status_mapping: ProxyStatusMapping,\n    pub trace_header: TraceHeaderConfig,\n    pub internal_services: InternalServicesConfig,\n    #[serde(default)]\n    pub micro_services: MicroServicesConfig,\n    pub comparison_service: Option<ComparisonServiceConfig>,\n    pub authentication_service_enabled_connectors: AuthenticationServiceEnabledConnectors,\n    pub save_payment_method_on_session: OnSessionConfig,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "Settings", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router configuration struct"}, {"query": "configure webhook settings and connector filters in router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: Settings\npub struct Settings<S: SecretState> {\n    pub server: Server,\n    pub application_source: common_enums::ApplicationSource,\n    pub proxy: Proxy,\n    pub env: Env,\n    pub chat: SecretStateContainer<ChatSettings, S>,\n    pub master_database: SecretStateContainer<Database, S>,\n    #[cfg(feature = \"olap\")]\n    pub replica_database: SecretStateContainer<Database, S>,\n    pub redis: RedisSettings,\n    pub log: Log,\n    pub secrets: SecretStateContainer<Secrets, S>,\n    pub fallback_merchant_ids_api_key_auth: Option<FallbackMerchantIds>,\n    pub locker: Locker,\n    pub key_manager: SecretStateContainer<KeyManagerConfig, S>,\n    pub connectors: Connectors,\n    pub forex_api: SecretStateContainer<ForexApi, S>,\n    pub refund: Refund,\n    pub eph_key: EphemeralConfig,\n    pub scheduler: Option<SchedulerSettings>,\n    #[cfg(feature = \"kv_store\")]\n    pub drainer: DrainerSettings,\n    pub jwekey: SecretStateContainer<Jwekey, S>,\n    pub webhooks: WebhooksSettings,\n    pub pm_filters: ConnectorFilters,\n    pub bank_config: BankRedirectConfig,\n    pub api_keys: SecretStateContainer<ApiKeys, S>,\n    pub file_storage: FileStorageConfig,\n    pub encryption_management: EncryptionManagementConfig,\n    pub secrets_management: SecretsManagementConfig,\n    pub tokenization: TokenizationConfig,\n    pub connector_customer: ConnectorCustomer,\n    #[cfg(feature = \"dummy_connector\")]\n    pub dummy_connector: DummyConnector,\n    #[cfg(feature = \"email\")]\n    pub email: EmailSettings,\n    pub user: UserSettings,\n    pub oidc: SecretStateContainer<OidcSettings, S>,\n    pub crm: CrmManagerConfig,\n    pub cors: CorsSettings,\n    pub mandates: Mandates,\n    pub zero_mandates: ZeroMandates,\n    pub network_transaction_id_supported_connectors: NetworkTransactionIdSupportedConnectors,\n    pub card_only_mit_supported_connectors: CardOnlyMitSupportedConnectors,\n    pub list_dispute_supported_connectors: ListDiputeSupportedConnectors,\n    pub required_fields: RequiredFields,\n    pub delayed_session_response: DelayedSessionConfig,\n    pub webhook_source_verification_call: WebhookSourceVerificationCall,\n    pub billing_connectors_payment_sync: BillingConnectorPaymentsSyncCall,\n    pub billing_connectors_invoice_sync: BillingConnectorInvoiceSyncCall,\n    pub payment_method_auth: SecretStateContainer<PaymentMethodAuth, S>,\n    pub connector_request_reference_id_config: ConnectorRequestReferenceIdConfig,\n    #[cfg(feature = \"payouts\")]\n    pub payou\n\n... [truncated 2088 chars] ...\n\nure = \"v2\")]\n    pub revenue_recovery: revenue_recovery::RevenueRecoverySettings,\n    pub merchant_advice_codes: MerchantAdviceCodeLookupConfig,\n    pub clone_connector_allowlist: Option<CloneConnectorAllowlistConfig>,\n    pub merchant_id_auth: MerchantIdAuthSettings,\n    pub internal_merchant_id_profile_id_auth: InternalMerchantIdProfileIdAuthSettings,\n    #[serde(default)]\n    pub infra_values: Option<HashMap<String, String>>,\n    #[serde(default)]\n    pub enhancement: Option<HashMap<String, String>>,\n    pub superposition: SecretStateContainer<SuperpositionClientConfig, S>,\n    pub proxy_status_mapping: ProxyStatusMapping,\n    pub trace_header: TraceHeaderConfig,\n    pub internal_services: InternalServicesConfig,\n    #[serde(default)]\n    pub micro_services: MicroServicesConfig,\n    pub comparison_service: Option<ComparisonServiceConfig>,\n    pub authentication_service_enabled_connectors: AuthenticationServiceEnabledConnectors,\n    pub save_payment_method_on_session: OnSessionConfig,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "Settings", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router configuration struct"}, {"query": "rust struct definition for merchant profile configuration hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: Profile\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub version: common_enums::ApiVersion,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<common_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    pub acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]", "function_name": "Profile", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Merchant Profile Domain Model"}, {"query": "how to configure routing algorithms in Profile struct hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: Profile\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub version: common_enums::ApiVersion,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<common_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    pub acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]", "function_name": "Profile", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Merchant Profile Domain Model"}, {"query": "hyperswitch Profile struct webhook configuration merchant settings", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: Profile\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub version: common_enums::ApiVersion,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<common_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    pub acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]", "function_name": "Profile", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Merchant Profile Domain Model"}, {"query": "rust domain model Profile merchant_id routing_algorithm definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: Profile\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub version: common_enums::ApiVersion,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<common_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    pub acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]", "function_name": "Profile", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "Merchant Profile Domain Model"}, {"query": "rust hyperswitch user domain model company name validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(company_name: String) -> UserResult<Self> {\n        let company_name = company_name.trim();\n        let is_empty_or_whitespace = company_name.is_empty();\n        let is_too_long =\n            company_name.graphemes(true).count() > consts::user::MAX_COMPANY_NAME_LENGTH;\n\n        let is_all_valid_characters = company_name\n            .chars()\n            .all(|x| x.is_alphanumeric() || x.is_ascii_whitespace() || x == '_');\n        if is_empty_or_whitespace || is_too_long || !is_all_valid_characters {\n            Err(UserErrors::CompanyNameParsingError.into())\n        } else {\n            Ok(Self(company_name.to_string()))\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User domain model factory validation"}, {"query": "how to create a user entity with company name in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(company_name: String) -> UserResult<Self> {\n        let company_name = company_name.trim();\n        let is_empty_or_whitespace = company_name.is_empty();\n        let is_too_long =\n            company_name.graphemes(true).count() > consts::user::MAX_COMPANY_NAME_LENGTH;\n\n        let is_all_valid_characters = company_name\n            .chars()\n            .all(|x| x.is_alphanumeric() || x.is_ascii_whitespace() || x == '_');\n        if is_empty_or_whitespace || is_too_long || !is_all_valid_characters {\n            Err(UserErrors::CompanyNameParsingError.into())\n        } else {\n            Ok(Self(company_name.to_string()))\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User domain model factory validation"}, {"query": "hyperswitch domain models user struct new method validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(company_name: String) -> UserResult<Self> {\n        let company_name = company_name.trim();\n        let is_empty_or_whitespace = company_name.is_empty();\n        let is_too_long =\n            company_name.graphemes(true).count() > consts::user::MAX_COMPANY_NAME_LENGTH;\n\n        let is_all_valid_characters = company_name\n            .chars()\n            .all(|x| x.is_alphanumeric() || x.is_ascii_whitespace() || x == '_');\n        if is_empty_or_whitespace || is_too_long || !is_all_valid_characters {\n            Err(UserErrors::CompanyNameParsingError.into())\n        } else {\n            Ok(Self(company_name.to_string()))\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User domain model factory validation"}, {"query": "rust hyperswitch user errors company name parsing error", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(company_name: String) -> UserResult<Self> {\n        let company_name = company_name.trim();\n        let is_empty_or_whitespace = company_name.is_empty();\n        let is_too_long =\n            company_name.graphemes(true).count() > consts::user::MAX_COMPANY_NAME_LENGTH;\n\n        let is_all_valid_characters = company_name\n            .chars()\n            .all(|x| x.is_alphanumeric() || x.is_ascii_whitespace() || x == '_');\n        if is_empty_or_whitespace || is_too_long || !is_all_valid_characters {\n            Err(UserErrors::CompanyNameParsingError.into())\n        } else {\n            Ok(Self(company_name.to_string()))\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User domain model factory validation"}, {"query": "rust struct for payment capture data with minor units", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsCaptureData\npub struct PaymentsCaptureData {\n    pub amount_to_capture: i64,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub payment_amount: i64,\n    pub multiple_capture_data: Option<MultipleCaptureRequestData>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub browser_info: Option<BrowserInformation>,\n    pub metadata: Option<serde_json::Value>,\n    // This metadata is used to store the metadata shared during the payment intent request.\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // New amount for amount frame work\n    pub minor_payment_amount: MinorUnit,\n    pub minor_amount_to_capture: MinorUnit,\n    pub integrity_object: Option<CaptureIntegrityObject>,\n    pub webhook_url: Option<String>,\n    pub merchant_order_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "PaymentsCaptureData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsCaptureData struct definition"}, {"query": "hyperswitch payments capture payload fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsCaptureData\npub struct PaymentsCaptureData {\n    pub amount_to_capture: i64,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub payment_amount: i64,\n    pub multiple_capture_data: Option<MultipleCaptureRequestData>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub browser_info: Option<BrowserInformation>,\n    pub metadata: Option<serde_json::Value>,\n    // This metadata is used to store the metadata shared during the payment intent request.\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // New amount for amount frame work\n    pub minor_payment_amount: MinorUnit,\n    pub minor_amount_to_capture: MinorUnit,\n    pub integrity_object: Option<CaptureIntegrityObject>,\n    pub webhook_url: Option<String>,\n    pub merchant_order_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "PaymentsCaptureData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsCaptureData struct definition"}, {"query": "PaymentsCaptureData struct definition rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsCaptureData\npub struct PaymentsCaptureData {\n    pub amount_to_capture: i64,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub payment_amount: i64,\n    pub multiple_capture_data: Option<MultipleCaptureRequestData>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub browser_info: Option<BrowserInformation>,\n    pub metadata: Option<serde_json::Value>,\n    // This metadata is used to store the metadata shared during the payment intent request.\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // New amount for amount frame work\n    pub minor_payment_amount: MinorUnit,\n    pub minor_amount_to_capture: MinorUnit,\n    pub integrity_object: Option<CaptureIntegrityObject>,\n    pub webhook_url: Option<String>,\n    pub merchant_order_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "PaymentsCaptureData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsCaptureData struct definition"}, {"query": "how to construct payments capture request rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsCaptureData\npub struct PaymentsCaptureData {\n    pub amount_to_capture: i64,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub payment_amount: i64,\n    pub multiple_capture_data: Option<MultipleCaptureRequestData>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub browser_info: Option<BrowserInformation>,\n    pub metadata: Option<serde_json::Value>,\n    // This metadata is used to store the metadata shared during the payment intent request.\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // New amount for amount frame work\n    pub minor_payment_amount: MinorUnit,\n    pub minor_amount_to_capture: MinorUnit,\n    pub integrity_object: Option<CaptureIntegrityObject>,\n    pub webhook_url: Option<String>,\n    pub merchant_order_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "PaymentsCaptureData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsCaptureData struct definition"}, {"query": "how to handle globepay authorization response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: globepay::GlobepayPaymentsResponse = res\n            .response\n            .parse_struct(\"Globepay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization response handler"}, {"query": "rust function deserializing globepay response struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: globepay::GlobepayPaymentsResponse = res\n            .response\n            .parse_struct(\"Globepay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization response handler"}, {"query": "hyperswitch connector handle_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: globepay::GlobepayPaymentsResponse = res\n            .response\n            .parse_struct(\"Globepay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization response handler"}, {"query": "globepay payments authorize response parsing rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: globepay::GlobepayPaymentsResponse = res\n            .response\n            .parse_struct(\"Globepay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization response handler"}, {"query": "how to get connector token details from transaction response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_updated_connector_token_details\n    pub fn get_updated_connector_token_details(\n        &self,\n        original_connector_mandate_request_reference_id: Option<String>,\n    ) -> Option<diesel_models::ConnectorTokenDetails> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.clone().map(|mandate_ref| {\n                let connector_mandate_id = mandate_ref.connector_mandate_id;\n                let connector_mandate_request_reference_id = mandate_ref\n                    .connector_mandate_request_reference_id\n                    .or(original_connector_mandate_request_reference_id);\n\n                diesel_models::ConnectorTokenDetails {\n                    connector_mandate_id,\n                    connector_token_request_reference_id: connector_mandate_request_reference_id,\n                }\n            })\n        } else {\n            None\n        }\n    }\n", "function_name": "get_updated_connector_token_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Router mandate token details extraction"}, {"query": "rust hyperswitch get_updated_connector_token_details implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_updated_connector_token_details\n    pub fn get_updated_connector_token_details(\n        &self,\n        original_connector_mandate_request_reference_id: Option<String>,\n    ) -> Option<diesel_models::ConnectorTokenDetails> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.clone().map(|mandate_ref| {\n                let connector_mandate_id = mandate_ref.connector_mandate_id;\n                let connector_mandate_request_reference_id = mandate_ref\n                    .connector_mandate_request_reference_id\n                    .or(original_connector_mandate_request_reference_id);\n\n                diesel_models::ConnectorTokenDetails {\n                    connector_mandate_id,\n                    connector_token_request_reference_id: connector_mandate_request_reference_id,\n                }\n            })\n        } else {\n            None\n        }\n    }\n", "function_name": "get_updated_connector_token_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Router mandate token details extraction"}, {"query": "hyperswitch router mandate reference token generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_updated_connector_token_details\n    pub fn get_updated_connector_token_details(\n        &self,\n        original_connector_mandate_request_reference_id: Option<String>,\n    ) -> Option<diesel_models::ConnectorTokenDetails> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.clone().map(|mandate_ref| {\n                let connector_mandate_id = mandate_ref.connector_mandate_id;\n                let connector_mandate_request_reference_id = mandate_ref\n                    .connector_mandate_request_reference_id\n                    .or(original_connector_mandate_request_reference_id);\n\n                diesel_models::ConnectorTokenDetails {\n                    connector_mandate_id,\n                    connector_token_request_reference_id: connector_mandate_request_reference_id,\n                }\n            })\n        } else {\n            None\n        }\n    }\n", "function_name": "get_updated_connector_token_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Router mandate token details extraction"}, {"query": "function to retrieve connector mandate request id from transaction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_updated_connector_token_details\n    pub fn get_updated_connector_token_details(\n        &self,\n        original_connector_mandate_request_reference_id: Option<String>,\n    ) -> Option<diesel_models::ConnectorTokenDetails> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.clone().map(|mandate_ref| {\n                let connector_mandate_id = mandate_ref.connector_mandate_id;\n                let connector_mandate_request_reference_id = mandate_ref\n                    .connector_mandate_request_reference_id\n                    .or(original_connector_mandate_request_reference_id);\n\n                diesel_models::ConnectorTokenDetails {\n                    connector_mandate_id,\n                    connector_token_request_reference_id: connector_mandate_request_reference_id,\n                }\n            })\n        } else {\n            None\n        }\n    }\n", "function_name": "get_updated_connector_token_details", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Router mandate token details extraction"}, {"query": "How to define a FasterPayments creditor in hyperswitch?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Creditor\npub enum Creditor {\n    FasterPayments {\n        #[serde(rename = \"sortCode\")]\n        sort_code: Secret<String>,\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Sepa {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    SepaInstant {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirIban {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirAccount {\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Bankgiro {\n        #[serde(rename = \"bankgiroNumber\")]\n        bankgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Plusgiro {\n        #[serde(rename = \"plusgiroNumber\")]\n        plusgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "Creditor", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Creditor enum definition"}, {"query": "Rust enum for SEPA creditor hyperswitch tokenization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Creditor\npub enum Creditor {\n    FasterPayments {\n        #[serde(rename = \"sortCode\")]\n        sort_code: Secret<String>,\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Sepa {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    SepaInstant {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirIban {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirAccount {\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Bankgiro {\n        #[serde(rename = \"bankgiroNumber\")]\n        bankgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Plusgiro {\n        #[serde(rename = \"plusgiroNumber\")]\n        plusgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "Creditor", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Creditor enum definition"}, {"query": "Hyperswitch connector creditor structure IBAN", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Creditor\npub enum Creditor {\n    FasterPayments {\n        #[serde(rename = \"sortCode\")]\n        sort_code: Secret<String>,\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Sepa {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    SepaInstant {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirIban {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirAccount {\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Bankgiro {\n        #[serde(rename = \"bankgiroNumber\")]\n        bankgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Plusgiro {\n        #[serde(rename = \"plusgiroNumber\")]\n        plusgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "Creditor", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Creditor enum definition"}, {"query": "Bankgiro creditor definition hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Creditor\npub enum Creditor {\n    FasterPayments {\n        #[serde(rename = \"sortCode\")]\n        sort_code: Secret<String>,\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Sepa {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    SepaInstant {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirIban {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirAccount {\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Bankgiro {\n        #[serde(rename = \"bankgiroNumber\")]\n        bankgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Plusgiro {\n        #[serde(rename = \"plusgiroNumber\")]\n        plusgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "Creditor", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Creditor enum definition"}, {"query": "how to build sift authorize request rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift authorize request builder"}, {"query": "hyperswitch sift connector build_request function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift authorize request builder"}, {"query": "rust code for constructing sift payments authorize request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift authorize request builder"}, {"query": "hyperswitch sift authorization request builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift authorize request builder"}, {"query": "rust hyperswitch authipay connector error handling get_error_response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay error response handler"}, {"query": "how to implement error response builder in hyperswitch authipay connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay error response handler"}, {"query": "hyperswitch authipay rust function get_error_response signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay error response handler"}, {"query": "authipay connector hyperswitch build_error_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay error response handler"}, {"query": "Rust struct for acquirer details in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AcquirerDetails\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "function_name": "AcquirerDetails", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AcquirerDetails struct definition"}, {"query": "Hyperswitch AcquirerDetails struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AcquirerDetails\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "function_name": "AcquirerDetails", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AcquirerDetails struct definition"}, {"query": "api_models AcquirerDetails fields BIN merchant_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AcquirerDetails\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "function_name": "AcquirerDetails", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AcquirerDetails struct definition"}, {"query": "Hyperswitch payment orchestration acquirer data model", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AcquirerDetails\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "function_name": "AcquirerDetails", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AcquirerDetails struct definition"}, {"query": "how to generate digest from request content in nordea connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_digest_from_request\n    pub fn generate_digest_from_request(&self, payload: &RequestContent) -> String {\n        let payload_bytes = match payload {\n            RequestContent::RawBytes(bytes) => bytes.clone(),\n            _ => payload.get_inner_value().expose().as_bytes().to_vec(),\n        };\n\n        self.generate_digest(&payload_bytes)\n    }\n", "function_name": "generate_digest_from_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea payload digest generation"}, {"query": "rust function to hash request payload bytes hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_digest_from_request\n    pub fn generate_digest_from_request(&self, payload: &RequestContent) -> String {\n        let payload_bytes = match payload {\n            RequestContent::RawBytes(bytes) => bytes.clone(),\n            _ => payload.get_inner_value().expose().as_bytes().to_vec(),\n        };\n\n        self.generate_digest(&payload_bytes)\n    }\n", "function_name": "generate_digest_from_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea payload digest generation"}, {"query": "nordea connector digest generation implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_digest_from_request\n    pub fn generate_digest_from_request(&self, payload: &RequestContent) -> String {\n        let payload_bytes = match payload {\n            RequestContent::RawBytes(bytes) => bytes.clone(),\n            _ => payload.get_inner_value().expose().as_bytes().to_vec(),\n        };\n\n        self.generate_digest(&payload_bytes)\n    }\n", "function_name": "generate_digest_from_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea payload digest generation"}, {"query": "hyperswitch nordea request hashing logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_digest_from_request\n    pub fn generate_digest_from_request(&self, payload: &RequestContent) -> String {\n        let payload_bytes = match payload {\n            RequestContent::RawBytes(bytes) => bytes.clone(),\n            _ => payload.get_inner_value().expose().as_bytes().to_vec(),\n        };\n\n        self.generate_digest(&payload_bytes)\n    }\n", "function_name": "generate_digest_from_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea payload digest generation"}, {"query": "Rust enum for payment method data types in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: PaymentMethodData\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]", "function_name": "PaymentMethodData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "PaymentMethodData enum definition"}, {"query": "how to handle different payment methods like card and wallet in hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: PaymentMethodData\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]", "function_name": "PaymentMethodData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "PaymentMethodData enum definition"}, {"query": "hyperswitch payment method data structure definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: PaymentMethodData\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]", "function_name": "PaymentMethodData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "PaymentMethodData enum definition"}, {"query": "rust enum variants for payment methods in hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: PaymentMethodData\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]", "function_name": "PaymentMethodData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "PaymentMethodData enum definition"}, {"query": "rust hyperswitch thunes connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector auth header builder"}, {"query": "how to configure authentication headers for thunes payment gateway in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector auth header builder"}, {"query": "thunes connector source code get_headers function rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector auth header builder"}, {"query": "hyperswitch thunes authorization request header setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes connector auth header builder"}, {"query": "rust hyperswitch user name validation constructor", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_characters.contains(&g));\n\n        if is_empty_or_whitespace || is_too_long || contains_forbidden_characters {\n            Err(UserErrors::NameParsingError.into())\n        } else {\n            Ok(Self(name.into()))\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User name validation constructor"}, {"query": "hyperswitch router User type new function forbidden characters", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_characters.contains(&g));\n\n        if is_empty_or_whitespace || is_too_long || contains_forbidden_characters {\n            Err(UserErrors::NameParsingError.into())\n        } else {\n            Ok(Self(name.into()))\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User name validation constructor"}, {"query": "how to create User object in hyperswitch with validation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_characters.contains(&g));\n\n        if is_empty_or_whitespace || is_too_long || contains_forbidden_characters {\n            Err(UserErrors::NameParsingError.into())\n        } else {\n            Ok(Self(name.into()))\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User name validation constructor"}, {"query": "hyperswitch user name length limit and parsing error", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_characters.contains(&g));\n\n        if is_empty_or_whitespace || is_too_long || contains_forbidden_characters {\n            Err(UserErrors::NameParsingError.into())\n        } else {\n            Ok(Self(name.into()))\n        }\n    }\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "User name validation constructor"}, {"query": "how to find merchant connector account by id rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_by_merchant_connector_account_merchant_id_merchant_connector_id\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "function_name": "find_by_merchant_connector_account_merchant_id_merchant_connector_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup function"}, {"query": "hyperswitch merchant connector account lookup function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_by_merchant_connector_account_merchant_id_merchant_connector_id\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "function_name": "find_by_merchant_connector_account_merchant_id_merchant_connector_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup function"}, {"query": "rust code for finding merchant connector account by merchant id", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_by_merchant_connector_account_merchant_id_merchant_connector_id\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "function_name": "find_by_merchant_connector_account_merchant_id_merchant_connector_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup function"}, {"query": "hyperswitch storage layer merchant connector account retrieval", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_by_merchant_connector_account_merchant_id_merchant_connector_id\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "function_name": "find_by_merchant_connector_account_merchant_id_merchant_connector_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup function"}, {"query": "how to build a setup mandate request for Zift connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate request builder"}, {"query": "rust function to create HTTP request for Zift mandate setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate request builder"}, {"query": "hyperswitch Zift connector build_request implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate request builder"}, {"query": "setup mandate router data request builder Zift", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift mandate request builder"}, {"query": "rust hyperswitch helcim connector get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let auth = helcim::HelcimAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_TOKEN.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Auth Header Generation"}, {"query": "how to configure api token header for helcim in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let auth = helcim::HelcimAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_TOKEN.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Auth Header Generation"}, {"query": "hyperswitch helcim authentication header generation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let auth = helcim::HelcimAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_TOKEN.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Auth Header Generation"}, {"query": "helcim connector hyperswitch get_auth_header function source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let auth = helcim::HelcimAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_TOKEN.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim Auth Header Generation"}, {"query": "how to configure authorization headers for Globepay in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization header builder"}, {"query": "hyperswitch globepay connector authorization request data structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization header builder"}, {"query": "rust function to build custom headers for globepay payments", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization header builder"}, {"query": "hyperswitch globepay get_headers implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization header builder"}, {"query": "rust hyperswitch authentication create request struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationCreateRequest\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "function_name": "AuthenticationCreateRequest", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AuthenticationCreateRequest struct definition"}, {"query": "hyperswitch 3ds authentication request payload example", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationCreateRequest\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "function_name": "AuthenticationCreateRequest", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AuthenticationCreateRequest struct definition"}, {"query": "AuthenticationCreateRequest struct definition rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationCreateRequest\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "function_name": "AuthenticationCreateRequest", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AuthenticationCreateRequest struct definition"}, {"query": "how to use AuthenticationCreateRequest in hyperswitch payments", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationCreateRequest\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "function_name": "AuthenticationCreateRequest", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AuthenticationCreateRequest struct definition"}, {"query": "how to handle worldline error response parsing in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: worldline::ErrorResponse = res\n            .response\n            .parse_struct(\"Worldline ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        let error = response.errors.into_iter().next().unwrap_or_default();\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: error\n                .code\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: error\n                .message\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            ..Default::default()\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline error response builder"}, {"query": "rust function to build error response from worldline connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: worldline::ErrorResponse = res\n            .response\n            .parse_struct(\"Worldline ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        let error = response.errors.into_iter().next().unwrap_or_default();\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: error\n                .code\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: error\n                .message\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            ..Default::default()\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline error response builder"}, {"query": "hyperswitch worldline connector error handling implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: worldline::ErrorResponse = res\n            .response\n            .parse_struct(\"Worldline ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        let error = response.errors.into_iter().next().unwrap_or_default();\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: error\n                .code\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: error\n                .message\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            ..Default::default()\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline error response builder"}, {"query": "worldline error response mapping to hyperswitch error format", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: worldline::ErrorResponse = res\n            .response\n            .parse_struct(\"Worldline ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        let error = response.errors.into_iter().next().unwrap_or_default();\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: error\n                .code\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: error\n                .message\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            ..Default::default()\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline error response builder"}, {"query": "how to implement validate_psync_reference_id in sift connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector validation stub"}, {"query": "rust placeholder function validate_psync_reference_id hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector validation stub"}, {"query": "PaymentsSyncData validation logic sift connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector validation stub"}, {"query": "hyperswitch sift connector validate_psync_reference_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "function_name": "validate_psync_reference_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector validation stub"}, {"query": "how to implement get_webhook_resource_object in GPayments connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n", "function_name": "get_webhook_resource_object", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments webhook resource object handler"}, {"query": "GPayments webhook resource object masking implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n", "function_name": "get_webhook_resource_object", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments webhook resource object handler"}, {"query": "hyperswitch GPayments connector webhook handler error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n", "function_name": "get_webhook_resource_object", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments webhook resource object handler"}, {"query": "rust connector error WebhooksNotImplemented GPayments", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n", "function_name": "get_webhook_resource_object", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "GPayments webhook resource object handler"}, {"query": "How to configure LegalType for Wise payouts in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: LegalType\npub enum LegalType {\n    Business,\n    #[default]\n    Private,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "LegalType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise LegalType enum definition"}, {"query": "Rust enum LegalType definition hyperswitch connectors wise", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: LegalType\npub enum LegalType {\n    Business,\n    #[default]\n    Private,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "LegalType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise LegalType enum definition"}, {"query": "hyperswitch LegalType Business Private enum usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: LegalType\npub enum LegalType {\n    Business,\n    #[default]\n    Private,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "LegalType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise LegalType enum definition"}, {"query": "Wise connector LegalType enum default behavior", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: LegalType\npub enum LegalType {\n    Business,\n    #[default]\n    Private,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "LegalType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise LegalType enum definition"}, {"query": "rust hyperswitch gigadat connector get_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector header auth"}, {"query": "how does hyperswitch gigadat connector build authorization headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector header auth"}, {"query": "hyperswitch gigadat get_headers PaymentsAuthorizeRouterData signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector header auth"}, {"query": "rust gigadat connector header generation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat connector header auth"}, {"query": "Rust SubError struct definition hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: SubError\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "SubError", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "SubError struct definition"}, {"query": "hyperswitch payout error handling SubError", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: SubError\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "SubError", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "SubError struct definition"}, {"query": "Wise connector SubError mapping Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: SubError\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "SubError", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "SubError struct definition"}, {"query": "SubError struct fields code message path", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: SubError\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "SubError", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "SubError struct definition"}, {"query": "How do I map time intervals in the analytics module?", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_lowest_common_granularity_level\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel {\n        match self {\n            Self::OneMin => TimeGranularityLevel::Minute,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin | Self::OneHour => {\n                TimeGranularityLevel::Hour\n            }\n            Self::OneDay => TimeGranularityLevel::Day,\n        }\n    }\n", "function_name": "get_lowest_common_granularity_level", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time Granularity Mapping"}, {"query": "Rust function to convert time granularity levels in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_lowest_common_granularity_level\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel {\n        match self {\n            Self::OneMin => TimeGranularityLevel::Minute,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin | Self::OneHour => {\n                TimeGranularityLevel::Hour\n            }\n            Self::OneDay => TimeGranularityLevel::Day,\n        }\n    }\n", "function_name": "get_lowest_common_granularity_level", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time Granularity Mapping"}, {"query": "get_lowest_common_granularity_level implementation in analytics crate", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_lowest_common_granularity_level\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel {\n        match self {\n            Self::OneMin => TimeGranularityLevel::Minute,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin | Self::OneHour => {\n                TimeGranularityLevel::Hour\n            }\n            Self::OneDay => TimeGranularityLevel::Day,\n        }\n    }\n", "function_name": "get_lowest_common_granularity_level", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time Granularity Mapping"}, {"query": "hyperswitch analytics time series aggregation level mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_lowest_common_granularity_level\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel {\n        match self {\n            Self::OneMin => TimeGranularityLevel::Minute,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin | Self::OneHour => {\n                TimeGranularityLevel::Hour\n            }\n            Self::OneDay => TimeGranularityLevel::Day,\n        }\n    }\n", "function_name": "get_lowest_common_granularity_level", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Time Granularity Mapping"}, {"query": "how to implement tokenization for Juspay 3DS in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Juspaythreedsserver\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Juspaythreedsserver\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Tokenization Integration"}, {"query": "Juspaythreedsserver connector integration example hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Juspaythreedsserver\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Juspaythreedsserver\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Tokenization Integration"}, {"query": "hyperswitch rust connector trait implementation for 3ds", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Juspaythreedsserver\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Juspaythreedsserver\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Tokenization Integration"}, {"query": "PaymentMethodTokenizationData Juspaythreedsserver hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Juspaythreedsserver\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Juspaythreedsserver\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Tokenization Integration"}, {"query": "juspaythreedsserver get_url method implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Connector Stub"}, {"query": "hyperswitch juspay 3ds connector get_url stub", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Connector Stub"}, {"query": "how to implement get_url in juspaythreedsserver", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Connector Stub"}, {"query": "juspaythreedsserver connector error NotImplemented get_url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Connector Stub"}, {"query": "rust nordea connector generate_signature rsa-sha256 eidas", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_signature\n    fn generate_signature(\n        &self,\n        auth: &NordeaAuthType,\n        signature_params: SignatureParams<'_>,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        const REQUEST_WITHOUT_CONTENT_HEADERS: &str =\n            \"(request-target) x-nordea-originating-host x-nordea-originating-date\";\n        const REQUEST_WITH_CONTENT_HEADERS: &str = \"(request-target) x-nordea-originating-host x-nordea-originating-date content-type digest\";\n\n        let method_string = signature_params.http_method.to_string().to_lowercase();\n        let mut normalized_string = format!(\n            \"(request-target): {} {}\\nx-nordea-originating-host: {}\\nx-nordea-originating-date: {}\",\n            method_string, signature_params.path, signature_params.host, signature_params.date\n        );\n\n        let headers = if matches!(\n            signature_params.http_method,\n            Method::Post | Method::Put | Method::Patch\n        ) {\n            let digest = signature_params.payload_digest.unwrap_or(\"\");\n            normalized_string.push_str(&format!(\n                \"\\ncontent-type: {}\\ndigest: {}\",\n                signature_params.content_type, digest\n            ));\n            REQUEST_WITH_CONTENT_HEADERS\n        } else {\n            REQUEST_WITHOUT_CONTENT_HEADERS\n        };\n\n        let signature_base64 = {\n            let private_key_pem =\n                self.format_private_key(&auth.eidas_private_key.clone().expose())?;\n\n            let private_key_der = pem::parse(&private_key_pem).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n            let private_key_der_contents = private_key_der.contents();\n            let key_pair = RsaKeyPair::from_der(private_key_der_contents).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n\n            let mut signature = vec![0u8; key_pair.public().modulus_len()];\n            key_pair\n                .sign(\n                    &RSA_PKCS1_SHA256,\n                    &ring::rand::SystemRandom::new(),\n                    normalized_string.as_bytes(),\n                    &mut signature,\n                )\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n            consts::BASE64_ENGINE.encode(signature)\n        };\n\n        Ok(format!(\n            r#\"keyId=\"{}\",algorithm=\"rsa-sha256\",headers=\"{}\",signature=\"{}\"\"#,\n            auth.client_id.peek(),\n            headers,\n            signature_base64\n        ))\n    }\n\n    // This helper function correctly serializes a struct into the required\n    // non-percent-encoded form URL string.", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "nordea eidas signature generation"}, {"query": "how to implement nordea signature generation in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_signature\n    fn generate_signature(\n        &self,\n        auth: &NordeaAuthType,\n        signature_params: SignatureParams<'_>,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        const REQUEST_WITHOUT_CONTENT_HEADERS: &str =\n            \"(request-target) x-nordea-originating-host x-nordea-originating-date\";\n        const REQUEST_WITH_CONTENT_HEADERS: &str = \"(request-target) x-nordea-originating-host x-nordea-originating-date content-type digest\";\n\n        let method_string = signature_params.http_method.to_string().to_lowercase();\n        let mut normalized_string = format!(\n            \"(request-target): {} {}\\nx-nordea-originating-host: {}\\nx-nordea-originating-date: {}\",\n            method_string, signature_params.path, signature_params.host, signature_params.date\n        );\n\n        let headers = if matches!(\n            signature_params.http_method,\n            Method::Post | Method::Put | Method::Patch\n        ) {\n            let digest = signature_params.payload_digest.unwrap_or(\"\");\n            normalized_string.push_str(&format!(\n                \"\\ncontent-type: {}\\ndigest: {}\",\n                signature_params.content_type, digest\n            ));\n            REQUEST_WITH_CONTENT_HEADERS\n        } else {\n            REQUEST_WITHOUT_CONTENT_HEADERS\n        };\n\n        let signature_base64 = {\n            let private_key_pem =\n                self.format_private_key(&auth.eidas_private_key.clone().expose())?;\n\n            let private_key_der = pem::parse(&private_key_pem).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n            let private_key_der_contents = private_key_der.contents();\n            let key_pair = RsaKeyPair::from_der(private_key_der_contents).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n\n            let mut signature = vec![0u8; key_pair.public().modulus_len()];\n            key_pair\n                .sign(\n                    &RSA_PKCS1_SHA256,\n                    &ring::rand::SystemRandom::new(),\n                    normalized_string.as_bytes(),\n                    &mut signature,\n                )\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n            consts::BASE64_ENGINE.encode(signature)\n        };\n\n        Ok(format!(\n            r#\"keyId=\"{}\",algorithm=\"rsa-sha256\",headers=\"{}\",signature=\"{}\"\"#,\n            auth.client_id.peek(),\n            headers,\n            signature_base64\n        ))\n    }\n\n    // This helper function correctly serializes a struct into the required\n    // non-percent-encoded form URL string.", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "nordea eidas signature generation"}, {"query": "nordea eidas private key signature_params implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_signature\n    fn generate_signature(\n        &self,\n        auth: &NordeaAuthType,\n        signature_params: SignatureParams<'_>,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        const REQUEST_WITHOUT_CONTENT_HEADERS: &str =\n            \"(request-target) x-nordea-originating-host x-nordea-originating-date\";\n        const REQUEST_WITH_CONTENT_HEADERS: &str = \"(request-target) x-nordea-originating-host x-nordea-originating-date content-type digest\";\n\n        let method_string = signature_params.http_method.to_string().to_lowercase();\n        let mut normalized_string = format!(\n            \"(request-target): {} {}\\nx-nordea-originating-host: {}\\nx-nordea-originating-date: {}\",\n            method_string, signature_params.path, signature_params.host, signature_params.date\n        );\n\n        let headers = if matches!(\n            signature_params.http_method,\n            Method::Post | Method::Put | Method::Patch\n        ) {\n            let digest = signature_params.payload_digest.unwrap_or(\"\");\n            normalized_string.push_str(&format!(\n                \"\\ncontent-type: {}\\ndigest: {}\",\n                signature_params.content_type, digest\n            ));\n            REQUEST_WITH_CONTENT_HEADERS\n        } else {\n            REQUEST_WITHOUT_CONTENT_HEADERS\n        };\n\n        let signature_base64 = {\n            let private_key_pem =\n                self.format_private_key(&auth.eidas_private_key.clone().expose())?;\n\n            let private_key_der = pem::parse(&private_key_pem).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n            let private_key_der_contents = private_key_der.contents();\n            let key_pair = RsaKeyPair::from_der(private_key_der_contents).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n\n            let mut signature = vec![0u8; key_pair.public().modulus_len()];\n            key_pair\n                .sign(\n                    &RSA_PKCS1_SHA256,\n                    &ring::rand::SystemRandom::new(),\n                    normalized_string.as_bytes(),\n                    &mut signature,\n                )\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n            consts::BASE64_ENGINE.encode(signature)\n        };\n\n        Ok(format!(\n            r#\"keyId=\"{}\",algorithm=\"rsa-sha256\",headers=\"{}\",signature=\"{}\"\"#,\n            auth.client_id.peek(),\n            headers,\n            signature_base64\n        ))\n    }\n\n    // This helper function correctly serializes a struct into the required\n    // non-percent-encoded form URL string.", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "nordea eidas signature generation"}, {"query": "hyperswitch nordea connector generate_signature function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_signature\n    fn generate_signature(\n        &self,\n        auth: &NordeaAuthType,\n        signature_params: SignatureParams<'_>,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        const REQUEST_WITHOUT_CONTENT_HEADERS: &str =\n            \"(request-target) x-nordea-originating-host x-nordea-originating-date\";\n        const REQUEST_WITH_CONTENT_HEADERS: &str = \"(request-target) x-nordea-originating-host x-nordea-originating-date content-type digest\";\n\n        let method_string = signature_params.http_method.to_string().to_lowercase();\n        let mut normalized_string = format!(\n            \"(request-target): {} {}\\nx-nordea-originating-host: {}\\nx-nordea-originating-date: {}\",\n            method_string, signature_params.path, signature_params.host, signature_params.date\n        );\n\n        let headers = if matches!(\n            signature_params.http_method,\n            Method::Post | Method::Put | Method::Patch\n        ) {\n            let digest = signature_params.payload_digest.unwrap_or(\"\");\n            normalized_string.push_str(&format!(\n                \"\\ncontent-type: {}\\ndigest: {}\",\n                signature_params.content_type, digest\n            ));\n            REQUEST_WITH_CONTENT_HEADERS\n        } else {\n            REQUEST_WITHOUT_CONTENT_HEADERS\n        };\n\n        let signature_base64 = {\n            let private_key_pem =\n                self.format_private_key(&auth.eidas_private_key.clone().expose())?;\n\n            let private_key_der = pem::parse(&private_key_pem).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n            let private_key_der_contents = private_key_der.contents();\n            let key_pair = RsaKeyPair::from_der(private_key_der_contents).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n\n            let mut signature = vec![0u8; key_pair.public().modulus_len()];\n            key_pair\n                .sign(\n                    &RSA_PKCS1_SHA256,\n                    &ring::rand::SystemRandom::new(),\n                    normalized_string.as_bytes(),\n                    &mut signature,\n                )\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n            consts::BASE64_ENGINE.encode(signature)\n        };\n\n        Ok(format!(\n            r#\"keyId=\"{}\",algorithm=\"rsa-sha256\",headers=\"{}\",signature=\"{}\"\"#,\n            auth.client_id.peek(),\n            headers,\n            signature_base64\n        ))\n    }\n\n    // This helper function correctly serializes a struct into the required\n    // non-percent-encoded form URL string.", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "nordea eidas signature generation"}, {"query": "how to get access token from UCS response in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: get_access_token_from_ucs_response\npub async fn get_access_token_from_ucs_response(\n    session_state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n    ucs_state: Option<&unified_connector_service_client::payments::ConnectorState>,\n) -> Option<AccessToken> {\n    let ucs_access_token = ucs_state\n        .and_then(|state| state.access_token.as_ref())\n        .map(AccessToken::foreign_from)?;\n\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        merchant_connector_id_or_connector_name,\n    );\n\n    if let Ok(Some(cached_token)) = session_state.store.get_access_token(key).await {\n        if cached_token.token.peek() == ucs_access_token.token.peek() {\n            return None;\n        }\n    }\n\n    Some(ucs_access_token)\n}\n", "function_name": "get_access_token_from_ucs_response", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS Token Retrieval Logic"}, {"query": "hyperswitch router access token caching logic comparison", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: get_access_token_from_ucs_response\npub async fn get_access_token_from_ucs_response(\n    session_state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n    ucs_state: Option<&unified_connector_service_client::payments::ConnectorState>,\n) -> Option<AccessToken> {\n    let ucs_access_token = ucs_state\n        .and_then(|state| state.access_token.as_ref())\n        .map(AccessToken::foreign_from)?;\n\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        merchant_connector_id_or_connector_name,\n    );\n\n    if let Ok(Some(cached_token)) = session_state.store.get_access_token(key).await {\n        if cached_token.token.peek() == ucs_access_token.token.peek() {\n            return None;\n        }\n    }\n\n    Some(ucs_access_token)\n}\n", "function_name": "get_access_token_from_ucs_response", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS Token Retrieval Logic"}, {"query": "rust function get_access_token_from_ucs_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: get_access_token_from_ucs_response\npub async fn get_access_token_from_ucs_response(\n    session_state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n    ucs_state: Option<&unified_connector_service_client::payments::ConnectorState>,\n) -> Option<AccessToken> {\n    let ucs_access_token = ucs_state\n        .and_then(|state| state.access_token.as_ref())\n        .map(AccessToken::foreign_from)?;\n\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        merchant_connector_id_or_connector_name,\n    );\n\n    if let Ok(Some(cached_token)) = session_state.store.get_access_token(key).await {\n        if cached_token.token.peek() == ucs_access_token.token.peek() {\n            return None;\n        }\n    }\n\n    Some(ucs_access_token)\n}\n", "function_name": "get_access_token_from_ucs_response", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS Token Retrieval Logic"}, {"query": "hyperswitch unified connector service token retrieval session state", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: get_access_token_from_ucs_response\npub async fn get_access_token_from_ucs_response(\n    session_state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n    ucs_state: Option<&unified_connector_service_client::payments::ConnectorState>,\n) -> Option<AccessToken> {\n    let ucs_access_token = ucs_state\n        .and_then(|state| state.access_token.as_ref())\n        .map(AccessToken::foreign_from)?;\n\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        merchant_connector_id_or_connector_name,\n    );\n\n    if let Ok(Some(cached_token)) = session_state.store.get_access_token(key).await {\n        if cached_token.token.peek() == ucs_access_token.token.peek() {\n            return None;\n        }\n    }\n\n    Some(ucs_access_token)\n}\n", "function_name": "get_access_token_from_ucs_response", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS Token Retrieval Logic"}, {"query": "rust hyperswitch amazonpay get_request_body implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = amazonpay::AmazonpayRouterData::from((amount, req));\n        let connector_req = amazonpay::AmazonpayFinalizeRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay request body builder"}, {"query": "how to build amazonpay finalize request in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = amazonpay::AmazonpayRouterData::from((amount, req));\n        let connector_req = amazonpay::AmazonpayFinalizeRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay request body builder"}, {"query": "hyperswitch rust connector amazonpay request body construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = amazonpay::AmazonpayRouterData::from((amount, req));\n        let connector_req = amazonpay::AmazonpayFinalizeRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay request body builder"}, {"query": "amazonpay router data conversion rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = amazonpay::AmazonpayRouterData::from((amount, req));\n        let connector_req = amazonpay::AmazonpayFinalizeRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay request body builder"}, {"query": "how to handle zift payment gateway error responses in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift error response handler"}, {"query": "zift connector error response builder hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift error response handler"}, {"query": "rust function get_error_response zift connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift error response handler"}, {"query": "hyperswitch zift error handling connector implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "Zift error response handler"}, {"query": "how to convert RouterData to PaymentsRequest for ExternalVaultProxy", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: try_from\n    fn try_from(\n        data: &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            email: data.request.email.clone(),\n            payment_method_data: None, // External vault proxy doesn't use regular payment method data\n            description: None,\n            phone: None,\n            name: data.request.customer_name.clone(),\n            preprocessing_id: data.preprocessing_id.clone(),\n            split_payments: data.request.split_payments.clone(),\n            setup_future_usage: data.request.setup_future_usage,\n            customer_acceptance: data.request.customer_acceptance.clone(),\n            customer_id: None,\n            billing_address: None,\n            metadata: None,\n            currency: Some(data.request.currency),\n        })\n    }\n}\n#[derive(Debug, Clone, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "ExternalVaultProxy PaymentsRequest conversion"}, {"query": "ExternalVaultProxy try_from implementation in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: try_from\n    fn try_from(\n        data: &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            email: data.request.email.clone(),\n            payment_method_data: None, // External vault proxy doesn't use regular payment method data\n            description: None,\n            phone: None,\n            name: data.request.customer_name.clone(),\n            preprocessing_id: data.preprocessing_id.clone(),\n            split_payments: data.request.split_payments.clone(),\n            setup_future_usage: data.request.setup_future_usage,\n            customer_acceptance: data.request.customer_acceptance.clone(),\n            customer_id: None,\n            billing_address: None,\n            metadata: None,\n            currency: Some(data.request.currency),\n        })\n    }\n}\n#[derive(Debug, Clone, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "ExternalVaultProxy PaymentsRequest conversion"}, {"query": "hyperswitch router data to payments request conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: try_from\n    fn try_from(\n        data: &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            email: data.request.email.clone(),\n            payment_method_data: None, // External vault proxy doesn't use regular payment method data\n            description: None,\n            phone: None,\n            name: data.request.customer_name.clone(),\n            preprocessing_id: data.preprocessing_id.clone(),\n            split_payments: data.request.split_payments.clone(),\n            setup_future_usage: data.request.setup_future_usage,\n            customer_acceptance: data.request.customer_acceptance.clone(),\n            customer_id: None,\n            billing_address: None,\n            metadata: None,\n            currency: Some(data.request.currency),\n        })\n    }\n}\n#[derive(Debug, Clone, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "ExternalVaultProxy PaymentsRequest conversion"}, {"query": "ExternalVaultProxyPaymentsData try_from source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: try_from\n    fn try_from(\n        data: &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            email: data.request.email.clone(),\n            payment_method_data: None, // External vault proxy doesn't use regular payment method data\n            description: None,\n            phone: None,\n            name: data.request.customer_name.clone(),\n            preprocessing_id: data.preprocessing_id.clone(),\n            split_payments: data.request.split_payments.clone(),\n            setup_future_usage: data.request.setup_future_usage,\n            customer_acceptance: data.request.customer_acceptance.clone(),\n            customer_id: None,\n            billing_address: None,\n            metadata: None,\n            currency: Some(data.request.currency),\n        })\n    }\n}\n#[derive(Debug, Clone, Serialize)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "ExternalVaultProxy PaymentsRequest conversion"}, {"query": "how to format private key string for nordea connector rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: format_private_key\n    fn format_private_key(\n        &self,\n        private_key_str: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let key = private_key_str.to_string();\n\n        // Check if it already has PEM headers\n        let pem_data =\n            if key.contains(\"BEGIN\") && key.contains(\"END\") && key.contains(\"PRIVATE KEY\") {\n                key\n            } else {\n                // Remove whitespace and format with 64-char lines\n                let cleaned_key = key\n                    .chars()\n                    .filter(|c| !c.is_whitespace())\n                    .collect::<String>();\n\n                let formatted_key = cleaned_key\n                    .chars()\n                    .collect::<Vec<char>>()\n                    .chunks(64)\n                    .map(|chunk| chunk.iter().collect::<String>())\n                    .collect::<Vec<String>>()\n                    .join(\"\\n\");\n\n                format!(\n                \"-----BEGIN RSA PRIVATE KEY-----\\n{formatted_key}\\n-----END RSA PRIVATE KEY-----\",\n            )\n            };\n\n        Ok(pem_data)\n    }\n\n    // For non-production environments, signature generation can be skipped and instead `SKIP_SIGNATURE_VALIDATION_FOR_SANDBOX` can be passed.", "function_name": "format_private_key", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "nordea rsa key pem formatter"}, {"query": "nordea rsa private key pem formatting hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: format_private_key\n    fn format_private_key(\n        &self,\n        private_key_str: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let key = private_key_str.to_string();\n\n        // Check if it already has PEM headers\n        let pem_data =\n            if key.contains(\"BEGIN\") && key.contains(\"END\") && key.contains(\"PRIVATE KEY\") {\n                key\n            } else {\n                // Remove whitespace and format with 64-char lines\n                let cleaned_key = key\n                    .chars()\n                    .filter(|c| !c.is_whitespace())\n                    .collect::<String>();\n\n                let formatted_key = cleaned_key\n                    .chars()\n                    .collect::<Vec<char>>()\n                    .chunks(64)\n                    .map(|chunk| chunk.iter().collect::<String>())\n                    .collect::<Vec<String>>()\n                    .join(\"\\n\");\n\n                format!(\n                \"-----BEGIN RSA PRIVATE KEY-----\\n{formatted_key}\\n-----END RSA PRIVATE KEY-----\",\n            )\n            };\n\n        Ok(pem_data)\n    }\n\n    // For non-production environments, signature generation can be skipped and instead `SKIP_SIGNATURE_VALIDATION_FOR_SANDBOX` can be passed.", "function_name": "format_private_key", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "nordea rsa key pem formatter"}, {"query": "rust function to add pem headers to private key", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: format_private_key\n    fn format_private_key(\n        &self,\n        private_key_str: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let key = private_key_str.to_string();\n\n        // Check if it already has PEM headers\n        let pem_data =\n            if key.contains(\"BEGIN\") && key.contains(\"END\") && key.contains(\"PRIVATE KEY\") {\n                key\n            } else {\n                // Remove whitespace and format with 64-char lines\n                let cleaned_key = key\n                    .chars()\n                    .filter(|c| !c.is_whitespace())\n                    .collect::<String>();\n\n                let formatted_key = cleaned_key\n                    .chars()\n                    .collect::<Vec<char>>()\n                    .chunks(64)\n                    .map(|chunk| chunk.iter().collect::<String>())\n                    .collect::<Vec<String>>()\n                    .join(\"\\n\");\n\n                format!(\n                \"-----BEGIN RSA PRIVATE KEY-----\\n{formatted_key}\\n-----END RSA PRIVATE KEY-----\",\n            )\n            };\n\n        Ok(pem_data)\n    }\n\n    // For non-production environments, signature generation can be skipped and instead `SKIP_SIGNATURE_VALIDATION_FOR_SANDBOX` can be passed.", "function_name": "format_private_key", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "nordea rsa key pem formatter"}, {"query": "hyperswitch nordea connector key formatting logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: format_private_key\n    fn format_private_key(\n        &self,\n        private_key_str: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let key = private_key_str.to_string();\n\n        // Check if it already has PEM headers\n        let pem_data =\n            if key.contains(\"BEGIN\") && key.contains(\"END\") && key.contains(\"PRIVATE KEY\") {\n                key\n            } else {\n                // Remove whitespace and format with 64-char lines\n                let cleaned_key = key\n                    .chars()\n                    .filter(|c| !c.is_whitespace())\n                    .collect::<String>();\n\n                let formatted_key = cleaned_key\n                    .chars()\n                    .collect::<Vec<char>>()\n                    .chunks(64)\n                    .map(|chunk| chunk.iter().collect::<String>())\n                    .collect::<Vec<String>>()\n                    .join(\"\\n\");\n\n                format!(\n                \"-----BEGIN RSA PRIVATE KEY-----\\n{formatted_key}\\n-----END RSA PRIVATE KEY-----\",\n            )\n            };\n\n        Ok(pem_data)\n    }\n\n    // For non-production environments, signature generation can be skipped and instead `SKIP_SIGNATURE_VALIDATION_FOR_SANDBOX` can be passed.", "function_name": "format_private_key", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "nordea rsa key pem formatter"}, {"query": "how to get string representation of PreProcessingId in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_string_repr\n    pub fn get_string_repr(&self) -> &String {\n        match self {\n            Self::PreProcessingId(value) => value,\n            Self::ConnectorTransactionId(value) => value,\n        }\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Clone, Serialize, serde::Deserialize)]", "function_name": "get_string_repr", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Enum string accessor"}, {"query": "rust enum get_string_repr method implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_string_repr\n    pub fn get_string_repr(&self) -> &String {\n        match self {\n            Self::PreProcessingId(value) => value,\n            Self::ConnectorTransactionId(value) => value,\n        }\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Clone, Serialize, serde::Deserialize)]", "function_name": "get_string_repr", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Enum string accessor"}, {"query": "hyperswitch domain models router response types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_string_repr\n    pub fn get_string_repr(&self) -> &String {\n        match self {\n            Self::PreProcessingId(value) => value,\n            Self::ConnectorTransactionId(value) => value,\n        }\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Clone, Serialize, serde::Deserialize)]", "function_name": "get_string_repr", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Enum string accessor"}, {"query": "extract transaction id string from enum variant", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_string_repr\n    pub fn get_string_repr(&self) -> &String {\n        match self {\n            Self::PreProcessingId(value) => value,\n            Self::ConnectorTransactionId(value) => value,\n        }\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Clone, Serialize, serde::Deserialize)]", "function_name": "get_string_repr", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "Enum string accessor"}, {"query": "how to handle helcim payment gateway errors in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim error response handler"}, {"query": "helcim connector error response mapping hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim error response handler"}, {"query": "hyperswitch helcim get_error_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim error response handler"}, {"query": "rust connector error handling helcim hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim error response handler"}, {"query": "how to get the secret token from a payment method in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_payment_method_token\n    pub fn get_payment_method_token(&self) -> Option<Secret<String>> {\n        match self {\n            Self::Token(secret_token) => Some(secret_token.clone()),\n            _ => None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "get_payment_method_token", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "PaymentMethod token retrieval"}, {"query": "hyperswitch rust get_payment_method_token implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_payment_method_token\n    pub fn get_payment_method_token(&self) -> Option<Secret<String>> {\n        match self {\n            Self::Token(secret_token) => Some(secret_token.clone()),\n            _ => None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "get_payment_method_token", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "PaymentMethod token retrieval"}, {"query": "how to access secret token from PaymentMethod enum hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_payment_method_token\n    pub fn get_payment_method_token(&self) -> Option<Secret<String>> {\n        match self {\n            Self::Token(secret_token) => Some(secret_token.clone()),\n            _ => None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "get_payment_method_token", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "PaymentMethod token retrieval"}, {"query": "rust hyperswitch domain models get_payment_method_token example", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_payment_method_token\n    pub fn get_payment_method_token(&self) -> Option<Secret<String>> {\n        match self {\n            Self::Token(secret_token) => Some(secret_token.clone()),\n            _ => None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "get_payment_method_token", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "PaymentMethod token retrieval"}, {"query": "rust hyperswitch payone generate_signature function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: payone::PayoneAuthType,\n        http_method: String,\n        canonicalized_path: String,\n        content_type: String,\n        date_header: String,\n    ) -> CustomResult<String, ConnectorError> {\n        let payone::PayoneAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let string_to_hash: String = format!(\n            \"{}\\n{}\\n{}\\n{}\\n\",\n            http_method,\n            content_type.trim(),\n            date_header.trim(),\n            canonicalized_path.trim()\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let hash_hmac = BASE64_ENGINE.encode(hmac::sign(&key, string_to_hash.as_bytes()));\n        let signature_header = format!(\"GCS v1HMAC:{}:{}\", api_key.peek(), hash_hmac);\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "payone signature generation"}, {"query": "hyperswitch payone connector signature generation hmac sha256", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: payone::PayoneAuthType,\n        http_method: String,\n        canonicalized_path: String,\n        content_type: String,\n        date_header: String,\n    ) -> CustomResult<String, ConnectorError> {\n        let payone::PayoneAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let string_to_hash: String = format!(\n            \"{}\\n{}\\n{}\\n{}\\n\",\n            http_method,\n            content_type.trim(),\n            date_header.trim(),\n            canonicalized_path.trim()\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let hash_hmac = BASE64_ENGINE.encode(hmac::sign(&key, string_to_hash.as_bytes()));\n        let signature_header = format!(\"GCS v1HMAC:{}:{}\", api_key.peek(), hash_hmac);\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "payone signature generation"}, {"query": "how to implement payone api signature in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: payone::PayoneAuthType,\n        http_method: String,\n        canonicalized_path: String,\n        content_type: String,\n        date_header: String,\n    ) -> CustomResult<String, ConnectorError> {\n        let payone::PayoneAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let string_to_hash: String = format!(\n            \"{}\\n{}\\n{}\\n{}\\n\",\n            http_method,\n            content_type.trim(),\n            date_header.trim(),\n            canonicalized_path.trim()\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let hash_hmac = BASE64_ENGINE.encode(hmac::sign(&key, string_to_hash.as_bytes()));\n        let signature_header = format!(\"GCS v1HMAC:{}:{}\", api_key.peek(), hash_hmac);\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "payone signature generation"}, {"query": "hyperswitch payone auth signature header format", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: payone::PayoneAuthType,\n        http_method: String,\n        canonicalized_path: String,\n        content_type: String,\n        date_header: String,\n    ) -> CustomResult<String, ConnectorError> {\n        let payone::PayoneAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let string_to_hash: String = format!(\n            \"{}\\n{}\\n{}\\n{}\\n\",\n            http_method,\n            content_type.trim(),\n            date_header.trim(),\n            canonicalized_path.trim()\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let hash_hmac = BASE64_ENGINE.encode(hmac::sign(&key, string_to_hash.as_bytes()));\n        let signature_header = format!(\"GCS v1HMAC:{}:{}\", api_key.peek(), hash_hmac);\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "payone signature generation"}, {"query": "how to update routing algorithm in hyperswitch profile", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileUpdate\npub enum ProfileUpdate {\n    Update(Box<ProfileGeneralUpdate>),\n    RoutingAlgorithmUpdate {\n        routing_algorithm: Option<serde_json::Value>,\n        payout_routing_algorithm: Option<serde_json::Value>,\n        three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    },\n    DynamicRoutingAlgorithmUpdate {\n        dynamic_routing_algorithm: Option<serde_json::Value>,\n    },\n    ExtendedCardInfoUpdate {\n        is_extended_card_info_enabled: bool,\n    },\n    ConnectorAgnosticMitUpdate {\n        is_connector_agnostic_mit_enabled: bool,\n    },\n    NetworkTokenizationUpdate {\n        is_network_tokenization_enabled: bool,\n    },\n    CardTestingSecretKeyUpdate {\n        card_testing_secret_key: OptionalEncryptableName,\n    },\n    AcquirerConfigMapUpdate {\n        acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    },\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "ProfileUpdate", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ProfileUpdate enum definition"}, {"query": "rust enum ProfileUpdate hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileUpdate\npub enum ProfileUpdate {\n    Update(Box<ProfileGeneralUpdate>),\n    RoutingAlgorithmUpdate {\n        routing_algorithm: Option<serde_json::Value>,\n        payout_routing_algorithm: Option<serde_json::Value>,\n        three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    },\n    DynamicRoutingAlgorithmUpdate {\n        dynamic_routing_algorithm: Option<serde_json::Value>,\n    },\n    ExtendedCardInfoUpdate {\n        is_extended_card_info_enabled: bool,\n    },\n    ConnectorAgnosticMitUpdate {\n        is_connector_agnostic_mit_enabled: bool,\n    },\n    NetworkTokenizationUpdate {\n        is_network_tokenization_enabled: bool,\n    },\n    CardTestingSecretKeyUpdate {\n        card_testing_secret_key: OptionalEncryptableName,\n    },\n    AcquirerConfigMapUpdate {\n        acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    },\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "ProfileUpdate", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ProfileUpdate enum definition"}, {"query": "hyperswitch merchant profile update structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileUpdate\npub enum ProfileUpdate {\n    Update(Box<ProfileGeneralUpdate>),\n    RoutingAlgorithmUpdate {\n        routing_algorithm: Option<serde_json::Value>,\n        payout_routing_algorithm: Option<serde_json::Value>,\n        three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    },\n    DynamicRoutingAlgorithmUpdate {\n        dynamic_routing_algorithm: Option<serde_json::Value>,\n    },\n    ExtendedCardInfoUpdate {\n        is_extended_card_info_enabled: bool,\n    },\n    ConnectorAgnosticMitUpdate {\n        is_connector_agnostic_mit_enabled: bool,\n    },\n    NetworkTokenizationUpdate {\n        is_network_tokenization_enabled: bool,\n    },\n    CardTestingSecretKeyUpdate {\n        card_testing_secret_key: OptionalEncryptableName,\n    },\n    AcquirerConfigMapUpdate {\n        acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    },\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "ProfileUpdate", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ProfileUpdate enum definition"}, {"query": "ProfileUpdate enum definition hyperswitch domain", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileUpdate\npub enum ProfileUpdate {\n    Update(Box<ProfileGeneralUpdate>),\n    RoutingAlgorithmUpdate {\n        routing_algorithm: Option<serde_json::Value>,\n        payout_routing_algorithm: Option<serde_json::Value>,\n        three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    },\n    DynamicRoutingAlgorithmUpdate {\n        dynamic_routing_algorithm: Option<serde_json::Value>,\n    },\n    ExtendedCardInfoUpdate {\n        is_extended_card_info_enabled: bool,\n    },\n    ConnectorAgnosticMitUpdate {\n        is_connector_agnostic_mit_enabled: bool,\n    },\n    NetworkTokenizationUpdate {\n        is_network_tokenization_enabled: bool,\n    },\n    CardTestingSecretKeyUpdate {\n        card_testing_secret_key: OptionalEncryptableName,\n    },\n    AcquirerConfigMapUpdate {\n        acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    },\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "ProfileUpdate", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "unit_type": "function", "label": "ProfileUpdate enum definition"}, {"query": "rust hyperswitch sift connector get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector auth header generation"}, {"query": "how to configure sift authentication in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector auth header generation"}, {"query": "hyperswitch sift payment connector api key header generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector auth header generation"}, {"query": "rust hyperswitch sift connector auth header masking", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector auth header generation"}, {"query": "how to override proxy settings in session state", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: create_updated_session_state_with_proxy\nfn create_updated_session_state_with_proxy(\n    state: SessionState,\n    proxy_override: &ProxyOverride,\n) -> SessionState {\n    let mut updated_state = state;\n\n    // Create updated configuration with proxy overrides\n    let mut updated_conf = (*updated_state.conf).clone();\n\n    // Update proxy URLs with overrides, falling back to existing values\n    if let Some(ref http_url) = proxy_override.http_url {\n        updated_conf.proxy.http_url = Some(http_url.clone());\n    }\n    if let Some(ref https_url) = proxy_override.https_url {\n        updated_conf.proxy.https_url = Some(https_url.clone());\n    }\n\n    updated_state.conf = std::sync::Arc::new(updated_conf);\n\n    updated_state\n}\n", "function_name": "create_updated_session_state_with_proxy", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Session Proxy Override"}, {"query": "rust function update session proxy configuration hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: create_updated_session_state_with_proxy\nfn create_updated_session_state_with_proxy(\n    state: SessionState,\n    proxy_override: &ProxyOverride,\n) -> SessionState {\n    let mut updated_state = state;\n\n    // Create updated configuration with proxy overrides\n    let mut updated_conf = (*updated_state.conf).clone();\n\n    // Update proxy URLs with overrides, falling back to existing values\n    if let Some(ref http_url) = proxy_override.http_url {\n        updated_conf.proxy.http_url = Some(http_url.clone());\n    }\n    if let Some(ref https_url) = proxy_override.https_url {\n        updated_conf.proxy.https_url = Some(https_url.clone());\n    }\n\n    updated_state.conf = std::sync::Arc::new(updated_conf);\n\n    updated_state\n}\n", "function_name": "create_updated_session_state_with_proxy", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Session Proxy Override"}, {"query": "hyperswitch create_updated_session_state_with_proxy implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: create_updated_session_state_with_proxy\nfn create_updated_session_state_with_proxy(\n    state: SessionState,\n    proxy_override: &ProxyOverride,\n) -> SessionState {\n    let mut updated_state = state;\n\n    // Create updated configuration with proxy overrides\n    let mut updated_conf = (*updated_state.conf).clone();\n\n    // Update proxy URLs with overrides, falling back to existing values\n    if let Some(ref http_url) = proxy_override.http_url {\n        updated_conf.proxy.http_url = Some(http_url.clone());\n    }\n    if let Some(ref https_url) = proxy_override.https_url {\n        updated_conf.proxy.https_url = Some(https_url.clone());\n    }\n\n    updated_state.conf = std::sync::Arc::new(updated_conf);\n\n    updated_state\n}\n", "function_name": "create_updated_session_state_with_proxy", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Session Proxy Override"}, {"query": "proxy_override http_url https_url session state update", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: create_updated_session_state_with_proxy\nfn create_updated_session_state_with_proxy(\n    state: SessionState,\n    proxy_override: &ProxyOverride,\n) -> SessionState {\n    let mut updated_state = state;\n\n    // Create updated configuration with proxy overrides\n    let mut updated_conf = (*updated_state.conf).clone();\n\n    // Update proxy URLs with overrides, falling back to existing values\n    if let Some(ref http_url) = proxy_override.http_url {\n        updated_conf.proxy.http_url = Some(http_url.clone());\n    }\n    if let Some(ref https_url) = proxy_override.https_url {\n        updated_conf.proxy.https_url = Some(https_url.clone());\n    }\n\n    updated_state.conf = std::sync::Arc::new(updated_conf);\n\n    updated_state\n}\n", "function_name": "create_updated_session_state_with_proxy", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Session Proxy Override"}, {"query": "how to generate Barclays API signature in Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let barclaycard_req = self.get_request_body(req, connectors)?;\n        let http_method = self.get_http_method();\n        let auth = barclaycard::BarclaycardAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.barclaycard.base_url.as_str();\n        let barclaycard_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = barclaycard_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(barclaycard_req.get_inner_value().expose().as_bytes());\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (V_C_MERCHANT_ID.to_string(), merchant_account.into_masked()),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclays signature generation"}, {"query": "hyperswitch barclaycard connector build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let barclaycard_req = self.get_request_body(req, connectors)?;\n        let http_method = self.get_http_method();\n        let auth = barclaycard::BarclaycardAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.barclaycard.base_url.as_str();\n        let barclaycard_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = barclaycard_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(barclaycard_req.get_inner_value().expose().as_bytes());\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (V_C_MERCHANT_ID.to_string(), merchant_account.into_masked()),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclays signature generation"}, {"query": "Rust function to create Barclays payment request headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let barclaycard_req = self.get_request_body(req, connectors)?;\n        let http_method = self.get_http_method();\n        let auth = barclaycard::BarclaycardAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.barclaycard.base_url.as_str();\n        let barclaycard_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = barclaycard_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(barclaycard_req.get_inner_value().expose().as_bytes());\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (V_C_MERCHANT_ID.to_string(), merchant_account.into_masked()),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclays signature generation"}, {"query": "hyperswitch barclaycard signature generation SHA-256", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let barclaycard_req = self.get_request_body(req, connectors)?;\n        let http_method = self.get_http_method();\n        let auth = barclaycard::BarclaycardAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.barclaycard.base_url.as_str();\n        let barclaycard_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = barclaycard_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(barclaycard_req.get_inner_value().expose().as_bytes());\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (V_C_MERCHANT_ID.to_string(), merchant_account.into_masked()),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclays signature generation"}, {"query": "how to get authorization url for nordea connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/personal/v5/authorize\",\n            self.base_url(connectors)\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea authorize URL construction"}, {"query": "nordea connector get_url function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/personal/v5/authorize\",\n            self.base_url(connectors)\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea authorize URL construction"}, {"query": "hyperswitch nordea authorize endpoint url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/personal/v5/authorize\",\n            self.base_url(connectors)\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea authorize URL construction"}, {"query": "nordea personal v5 authorize url hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/personal/v5/authorize\",\n            self.base_url(connectors)\n        ))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea authorize URL construction"}, {"query": "how to handle tokenex error response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: tokenex::TokenexErrorResponse = res\n            .response\n            .parse_struct(\"TokenexErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let (code, message) = response.error.split_once(':').unwrap_or((\"\", \"\"));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: code.to_string(),\n            message: message.to_string(),\n            reason: Some(response.message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex error response builder"}, {"query": "build_error_response function tokenex connector rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: tokenex::TokenexErrorResponse = res\n            .response\n            .parse_struct(\"TokenexErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let (code, message) = response.error.split_once(':').unwrap_or((\"\", \"\"));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: code.to_string(),\n            message: message.to_string(),\n            reason: Some(response.message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex error response builder"}, {"query": "parse tokenex error message hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: tokenex::TokenexErrorResponse = res\n            .response\n            .parse_struct(\"TokenexErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let (code, message) = response.error.split_once(':').unwrap_or((\"\", \"\"));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: code.to_string(),\n            message: message.to_string(),\n            reason: Some(response.message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex error response builder"}, {"query": "tokenex connector error handling hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: tokenex::TokenexErrorResponse = res\n            .response\n            .parse_struct(\"TokenexErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let (code, message) = response.error.split_once(':').unwrap_or((\"\", \"\"));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: code.to_string(),\n            message: message.to_string(),\n            reason: Some(response.message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex error response builder"}, {"query": "rust hyperswitch PaymentsAuthorizeData struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsAuthorizeData\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub ucs_authentication_data: Option<UcsAuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // Guest customer fields\n    pub guest_customer: Option<payments::GuestCustomer>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n\n    /// Merchant's identifier for the payment/invoice. This \n\n... [truncated 417 chars] ...\n\ntion<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n    pub locale: Option<String>,\n    pub payment_channel: Option<common_enums::PaymentChannel>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub enable_overcapture: Option<common_types::primitive_wrappers::EnableOvercaptureBool>,\n    pub is_stored_credential: Option<bool>,\n    pub mit_category: Option<common_enums::MitCategory>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n    pub rrn: Option<String>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "PaymentsAuthorizeData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsAuthorizeData struct definition"}, {"query": "hyperswitch authorize request data model surcharge tax", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsAuthorizeData\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub ucs_authentication_data: Option<UcsAuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // Guest customer fields\n    pub guest_customer: Option<payments::GuestCustomer>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n\n    /// Merchant's identifier for the payment/invoice. This \n\n... [truncated 417 chars] ...\n\ntion<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n    pub locale: Option<String>,\n    pub payment_channel: Option<common_enums::PaymentChannel>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub enable_overcapture: Option<common_types::primitive_wrappers::EnableOvercaptureBool>,\n    pub is_stored_credential: Option<bool>,\n    pub mit_category: Option<common_enums::MitCategory>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n    pub rrn: Option<String>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "PaymentsAuthorizeData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsAuthorizeData struct definition"}, {"query": "PaymentsAuthorizeData incremental authorization overcapture split payments", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsAuthorizeData\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub ucs_authentication_data: Option<UcsAuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // Guest customer fields\n    pub guest_customer: Option<payments::GuestCustomer>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n\n    /// Merchant's identifier for the payment/invoice. This \n\n... [truncated 417 chars] ...\n\ntion<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n    pub locale: Option<String>,\n    pub payment_channel: Option<common_enums::PaymentChannel>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub enable_overcapture: Option<common_types::primitive_wrappers::EnableOvercaptureBool>,\n    pub is_stored_credential: Option<bool>,\n    pub mit_category: Option<common_enums::MitCategory>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n    pub rrn: Option<String>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "PaymentsAuthorizeData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsAuthorizeData struct definition"}, {"query": "hyperswitch router request types authorize data guest customer", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsAuthorizeData\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub ucs_authentication_data: Option<UcsAuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // Guest customer fields\n    pub guest_customer: Option<payments::GuestCustomer>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n\n    /// Merchant's identifier for the payment/invoice. This \n\n... [truncated 417 chars] ...\n\ntion<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n    pub locale: Option<String>,\n    pub payment_channel: Option<common_enums::PaymentChannel>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub enable_overcapture: Option<common_types::primitive_wrappers::EnableOvercaptureBool>,\n    pub is_stored_credential: Option<bool>,\n    pub mit_category: Option<common_enums::MitCategory>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n    pub rrn: Option<String>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "PaymentsAuthorizeData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsAuthorizeData struct definition"}, {"query": "how to validate payment method for mandate in wells fargo connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wellsfargo mandate payment validation"}, {"query": "wellsfargo mandate supported payment methods types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wellsfargo mandate payment validation"}, {"query": "rust function validate_mandate_payment implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wellsfargo mandate payment validation"}, {"query": "check if payment method is supported for mandate hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wellsfargo mandate payment validation"}, {"query": "rust hyperswitch amazonpay connector handle_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayFinalizeResponse = res\n            .response\n            .parse_struct(\"Amazonpay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay Response Handler"}, {"query": "how does hyperswitch handle amazonpay authorization response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayFinalizeResponse = res\n            .response\n            .parse_struct(\"Amazonpay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay Response Handler"}, {"query": "hyperswitch amazonpay connector deserialization logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayFinalizeResponse = res\n            .response\n            .parse_struct(\"Amazonpay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay Response Handler"}, {"query": "rust amazonpay finalizer response parsing hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayFinalizeResponse = res\n            .response\n            .parse_struct(\"Amazonpay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "AmazonPay Response Handler"}, {"query": "how to handle Barclaycard pre-auth response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreAuthenticateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreAuthenticateRouterData, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardAuthSetupResponse = res\n            .response\n            .parse_struct(\"Barclaycard AuthSetupResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        PaymentsPreAuthenticateRouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth response handler"}, {"query": "rust function to parse BarclaycardAuthSetupResponse", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreAuthenticateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreAuthenticateRouterData, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardAuthSetupResponse = res\n            .response\n            .parse_struct(\"Barclaycard AuthSetupResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        PaymentsPreAuthenticateRouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth response handler"}, {"query": "hyperswitch connector handle_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreAuthenticateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreAuthenticateRouterData, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardAuthSetupResponse = res\n            .response\n            .parse_struct(\"Barclaycard AuthSetupResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        PaymentsPreAuthenticateRouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth response handler"}, {"query": "Barclaycard payment provider integration hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreAuthenticateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreAuthenticateRouterData, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardAuthSetupResponse = res\n            .response\n            .parse_struct(\"Barclaycard AuthSetupResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        PaymentsPreAuthenticateRouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard pre-auth response handler"}, {"query": "boku connector rust build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let connector_auth = boku::BokuAuthType::try_from(&req.connector_auth_type)?;\n\n        let boku_url = Self::get_url(self, req, connectors)?;\n\n        let content_type = Self::common_get_content_type(self);\n\n        let connector_method = Self::get_http_method(self);\n\n        let timestamp = OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n\n        let secret_key = boku::BokuAuthType::try_from(&req.connector_auth_type)?\n            .key_id\n            .expose();\n\n        let to_sign = format!(\n            \"{} {}\\nContent-Type: {}\\n{}\",\n            connector_method, boku_url, &content_type, timestamp\n        );\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, secret_key.as_bytes());\n\n        let tag = hmac::sign(&key, to_sign.as_bytes());\n\n        let signature = hex::encode(tag);\n\n        let auth_val = format!(\"2/HMAC_SHA256(H+SHA256(E)) timestamp={timestamp}, signature={signature} signed-headers=Content-Type, key-id={}\", connector_auth.key_id.peek());\n\n        let header = vec![\n            (headers::CONTENT_TYPE.to_string(), content_type.into()),\n            (headers::AUTHORIZATION.to_string(), auth_val.into_masked()),\n        ];\n\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector authentication"}, {"query": "how to generate boku api signature rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let connector_auth = boku::BokuAuthType::try_from(&req.connector_auth_type)?;\n\n        let boku_url = Self::get_url(self, req, connectors)?;\n\n        let content_type = Self::common_get_content_type(self);\n\n        let connector_method = Self::get_http_method(self);\n\n        let timestamp = OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n\n        let secret_key = boku::BokuAuthType::try_from(&req.connector_auth_type)?\n            .key_id\n            .expose();\n\n        let to_sign = format!(\n            \"{} {}\\nContent-Type: {}\\n{}\",\n            connector_method, boku_url, &content_type, timestamp\n        );\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, secret_key.as_bytes());\n\n        let tag = hmac::sign(&key, to_sign.as_bytes());\n\n        let signature = hex::encode(tag);\n\n        let auth_val = format!(\"2/HMAC_SHA256(H+SHA256(E)) timestamp={timestamp}, signature={signature} signed-headers=Content-Type, key-id={}\", connector_auth.key_id.peek());\n\n        let header = vec![\n            (headers::CONTENT_TYPE.to_string(), content_type.into()),\n            (headers::AUTHORIZATION.to_string(), auth_val.into_masked()),\n        ];\n\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector authentication"}, {"query": "hyperswitch boku connector authentication headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let connector_auth = boku::BokuAuthType::try_from(&req.connector_auth_type)?;\n\n        let boku_url = Self::get_url(self, req, connectors)?;\n\n        let content_type = Self::common_get_content_type(self);\n\n        let connector_method = Self::get_http_method(self);\n\n        let timestamp = OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n\n        let secret_key = boku::BokuAuthType::try_from(&req.connector_auth_type)?\n            .key_id\n            .expose();\n\n        let to_sign = format!(\n            \"{} {}\\nContent-Type: {}\\n{}\",\n            connector_method, boku_url, &content_type, timestamp\n        );\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, secret_key.as_bytes());\n\n        let tag = hmac::sign(&key, to_sign.as_bytes());\n\n        let signature = hex::encode(tag);\n\n        let auth_val = format!(\"2/HMAC_SHA256(H+SHA256(E)) timestamp={timestamp}, signature={signature} signed-headers=Content-Type, key-id={}\", connector_auth.key_id.peek());\n\n        let header = vec![\n            (headers::CONTENT_TYPE.to_string(), content_type.into()),\n            (headers::AUTHORIZATION.to_string(), auth_val.into_masked()),\n        ];\n\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector authentication"}, {"query": "rust hmac sha256 signature generation boku hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let connector_auth = boku::BokuAuthType::try_from(&req.connector_auth_type)?;\n\n        let boku_url = Self::get_url(self, req, connectors)?;\n\n        let content_type = Self::common_get_content_type(self);\n\n        let connector_method = Self::get_http_method(self);\n\n        let timestamp = OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n\n        let secret_key = boku::BokuAuthType::try_from(&req.connector_auth_type)?\n            .key_id\n            .expose();\n\n        let to_sign = format!(\n            \"{} {}\\nContent-Type: {}\\n{}\",\n            connector_method, boku_url, &content_type, timestamp\n        );\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, secret_key.as_bytes());\n\n        let tag = hmac::sign(&key, to_sign.as_bytes());\n\n        let signature = hex::encode(tag);\n\n        let auth_val = format!(\"2/HMAC_SHA256(H+SHA256(E)) timestamp={timestamp}, signature={signature} signed-headers=Content-Type, key-id={}\", connector_auth.key_id.peek());\n\n        let header = vec![\n            (headers::CONTENT_TYPE.to_string(), content_type.into()),\n            (headers::AUTHORIZATION.to_string(), auth_val.into_masked()),\n        ];\n\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku connector authentication"}, {"query": "How to handle synchronous payment types in Elavon connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SyncTransactionType\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "function_name": "SyncTransactionType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon SyncTransactionType Enum"}, {"query": "Elavon connector Sale vs AuthOnly transaction types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SyncTransactionType\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "function_name": "SyncTransactionType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon SyncTransactionType Enum"}, {"query": "Rust enum SyncTransactionType Elavon implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SyncTransactionType\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "function_name": "SyncTransactionType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon SyncTransactionType Enum"}, {"query": "SyncTransactionType definition in hyperswitch connectors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SyncTransactionType\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "function_name": "SyncTransactionType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon SyncTransactionType Enum"}, {"query": "how to convert FrmSaleRouterData to Signifyd purchase object", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: try_from\n    fn try_from(item: &FrmSaleRouterData) -> Result<Self, Self::Error> {\n        let products = item\n            .request\n            .get_order_details()?\n            .iter()\n            .map(|order_detail| Products {\n                item_name: order_detail.product_name.clone(),\n                item_price: order_detail.amount.get_amount_as_i64(), // This should be changed to MinorUnit when we implement amount conversion for this connector. Additionally, the function get_amount_as_i64() should be avoided in the future.\n                item_quantity: i32::from(order_detail.quantity),\n                item_id: order_detail.product_id.clone(),\n                item_category: order_detail.category.clone(),\n                item_sub_category: order_detail.sub_category.clone(),\n                item_is_digital: order_detail\n                    .product_type\n                    .as_ref()\n                    .map(|product| product == &common_enums::ProductType::Digital),\n            })\n            .collect::<Vec<_>>();\n        let metadata: SignifydFrmMetadata = item\n            .frm_metadata\n            .clone()\n            .ok_or(ConnectorError::MissingRequiredField {\n                field_name: \"frm_metadata\",\n            })?\n            .parse_value(\"Signifyd Frm Metadata\")\n            .change_context(ConnectorError::InvalidDataFormat {\n                field_name: \"frm_metadata\",\n            })?;\n        let ship_address = item.get_shipping_address()?;\n        let billing_address = item.get_billing()?;\n        let street_addr = ship_address.get_line1()?;\n        let city_addr = ship_address.get_city()?;\n        let zip_code_addr = ship_address.get_zip()?;\n        let country_code_addr = ship_address.get_country()?;\n        let _first_name_addr = ship_address.get_first_name()?;\n        let _last_name_addr = ship_address.get_last_name()?;\n        let address: Address = Address {\n            street_address: street_addr.clone(),\n            unit: None,\n            postal_code: zip_code_addr.clone(),\n            city: city_addr.clone(),\n            province_code: zip_code_addr.clone(),\n            country_code: country_code_addr.to_owned(),\n        };\n        let destination: Destination = Destination {\n            full_name: ship_address.get_full_name().unwrap_or_default(),\n            organization: None,\n            email: None,\n            address,\n        };\n\n        let created_at = common_utils::date_time::now();\n\n\n... [truncated 322 chars] ...\n\n      products,\n            shipments,\n            currency: item.request.currency,\n            total_shipping_cost: metadata.total_shipping_cost,\n            confirmation_email: item.request.email.clone(),\n            confirmation_phone: billing_address\n                .clone()\n                .phone\n                .and_then(|phone_data| phone_data.number),\n        };\n        Ok(Self {\n            order_id: item.attempt_id.clone(),\n            purchase,\n            decision_delivery: DecisionDelivery::Sync, // Specify SYNC if you require the Response to contain a decision field. If you have registered for a webhook associated with this checkpoint, then the webhook will also be sent when SYNC is specified. If ASYNC_ONLY is specified, then the decision field in the response will be null, and you will require a Webhook integration to receive Signifyd's final decision\n            coverage_requests: metadata.coverage_request,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Purchase Transformer"}, {"query": "Signifyd integration try_from implementation Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: try_from\n    fn try_from(item: &FrmSaleRouterData) -> Result<Self, Self::Error> {\n        let products = item\n            .request\n            .get_order_details()?\n            .iter()\n            .map(|order_detail| Products {\n                item_name: order_detail.product_name.clone(),\n                item_price: order_detail.amount.get_amount_as_i64(), // This should be changed to MinorUnit when we implement amount conversion for this connector. Additionally, the function get_amount_as_i64() should be avoided in the future.\n                item_quantity: i32::from(order_detail.quantity),\n                item_id: order_detail.product_id.clone(),\n                item_category: order_detail.category.clone(),\n                item_sub_category: order_detail.sub_category.clone(),\n                item_is_digital: order_detail\n                    .product_type\n                    .as_ref()\n                    .map(|product| product == &common_enums::ProductType::Digital),\n            })\n            .collect::<Vec<_>>();\n        let metadata: SignifydFrmMetadata = item\n            .frm_metadata\n            .clone()\n            .ok_or(ConnectorError::MissingRequiredField {\n                field_name: \"frm_metadata\",\n            })?\n            .parse_value(\"Signifyd Frm Metadata\")\n            .change_context(ConnectorError::InvalidDataFormat {\n                field_name: \"frm_metadata\",\n            })?;\n        let ship_address = item.get_shipping_address()?;\n        let billing_address = item.get_billing()?;\n        let street_addr = ship_address.get_line1()?;\n        let city_addr = ship_address.get_city()?;\n        let zip_code_addr = ship_address.get_zip()?;\n        let country_code_addr = ship_address.get_country()?;\n        let _first_name_addr = ship_address.get_first_name()?;\n        let _last_name_addr = ship_address.get_last_name()?;\n        let address: Address = Address {\n            street_address: street_addr.clone(),\n            unit: None,\n            postal_code: zip_code_addr.clone(),\n            city: city_addr.clone(),\n            province_code: zip_code_addr.clone(),\n            country_code: country_code_addr.to_owned(),\n        };\n        let destination: Destination = Destination {\n            full_name: ship_address.get_full_name().unwrap_or_default(),\n            organization: None,\n            email: None,\n            address,\n        };\n\n        let created_at = common_utils::date_time::now();\n\n\n... [truncated 322 chars] ...\n\n      products,\n            shipments,\n            currency: item.request.currency,\n            total_shipping_cost: metadata.total_shipping_cost,\n            confirmation_email: item.request.email.clone(),\n            confirmation_phone: billing_address\n                .clone()\n                .phone\n                .and_then(|phone_data| phone_data.number),\n        };\n        Ok(Self {\n            order_id: item.attempt_id.clone(),\n            purchase,\n            decision_delivery: DecisionDelivery::Sync, // Specify SYNC if you require the Response to contain a decision field. If you have registered for a webhook associated with this checkpoint, then the webhook will also be sent when SYNC is specified. If ASYNC_ONLY is specified, then the decision field in the response will be null, and you will require a Webhook integration to receive Signifyd's final decision\n            coverage_requests: metadata.coverage_request,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Purchase Transformer"}, {"query": "map order details and addresses to Signifyd Purchase struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: try_from\n    fn try_from(item: &FrmSaleRouterData) -> Result<Self, Self::Error> {\n        let products = item\n            .request\n            .get_order_details()?\n            .iter()\n            .map(|order_detail| Products {\n                item_name: order_detail.product_name.clone(),\n                item_price: order_detail.amount.get_amount_as_i64(), // This should be changed to MinorUnit when we implement amount conversion for this connector. Additionally, the function get_amount_as_i64() should be avoided in the future.\n                item_quantity: i32::from(order_detail.quantity),\n                item_id: order_detail.product_id.clone(),\n                item_category: order_detail.category.clone(),\n                item_sub_category: order_detail.sub_category.clone(),\n                item_is_digital: order_detail\n                    .product_type\n                    .as_ref()\n                    .map(|product| product == &common_enums::ProductType::Digital),\n            })\n            .collect::<Vec<_>>();\n        let metadata: SignifydFrmMetadata = item\n            .frm_metadata\n            .clone()\n            .ok_or(ConnectorError::MissingRequiredField {\n                field_name: \"frm_metadata\",\n            })?\n            .parse_value(\"Signifyd Frm Metadata\")\n            .change_context(ConnectorError::InvalidDataFormat {\n                field_name: \"frm_metadata\",\n            })?;\n        let ship_address = item.get_shipping_address()?;\n        let billing_address = item.get_billing()?;\n        let street_addr = ship_address.get_line1()?;\n        let city_addr = ship_address.get_city()?;\n        let zip_code_addr = ship_address.get_zip()?;\n        let country_code_addr = ship_address.get_country()?;\n        let _first_name_addr = ship_address.get_first_name()?;\n        let _last_name_addr = ship_address.get_last_name()?;\n        let address: Address = Address {\n            street_address: street_addr.clone(),\n            unit: None,\n            postal_code: zip_code_addr.clone(),\n            city: city_addr.clone(),\n            province_code: zip_code_addr.clone(),\n            country_code: country_code_addr.to_owned(),\n        };\n        let destination: Destination = Destination {\n            full_name: ship_address.get_full_name().unwrap_or_default(),\n            organization: None,\n            email: None,\n            address,\n        };\n\n        let created_at = common_utils::date_time::now();\n\n\n... [truncated 322 chars] ...\n\n      products,\n            shipments,\n            currency: item.request.currency,\n            total_shipping_cost: metadata.total_shipping_cost,\n            confirmation_email: item.request.email.clone(),\n            confirmation_phone: billing_address\n                .clone()\n                .phone\n                .and_then(|phone_data| phone_data.number),\n        };\n        Ok(Self {\n            order_id: item.attempt_id.clone(),\n            purchase,\n            decision_delivery: DecisionDelivery::Sync, // Specify SYNC if you require the Response to contain a decision field. If you have registered for a webhook associated with this checkpoint, then the webhook will also be sent when SYNC is specified. If ASYNC_ONLY is specified, then the decision field in the response will be null, and you will require a Webhook integration to receive Signifyd's final decision\n            coverage_requests: metadata.coverage_request,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Purchase Transformer"}, {"query": "handle missing frm_metadata in Signifyd connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: try_from\n    fn try_from(item: &FrmSaleRouterData) -> Result<Self, Self::Error> {\n        let products = item\n            .request\n            .get_order_details()?\n            .iter()\n            .map(|order_detail| Products {\n                item_name: order_detail.product_name.clone(),\n                item_price: order_detail.amount.get_amount_as_i64(), // This should be changed to MinorUnit when we implement amount conversion for this connector. Additionally, the function get_amount_as_i64() should be avoided in the future.\n                item_quantity: i32::from(order_detail.quantity),\n                item_id: order_detail.product_id.clone(),\n                item_category: order_detail.category.clone(),\n                item_sub_category: order_detail.sub_category.clone(),\n                item_is_digital: order_detail\n                    .product_type\n                    .as_ref()\n                    .map(|product| product == &common_enums::ProductType::Digital),\n            })\n            .collect::<Vec<_>>();\n        let metadata: SignifydFrmMetadata = item\n            .frm_metadata\n            .clone()\n            .ok_or(ConnectorError::MissingRequiredField {\n                field_name: \"frm_metadata\",\n            })?\n            .parse_value(\"Signifyd Frm Metadata\")\n            .change_context(ConnectorError::InvalidDataFormat {\n                field_name: \"frm_metadata\",\n            })?;\n        let ship_address = item.get_shipping_address()?;\n        let billing_address = item.get_billing()?;\n        let street_addr = ship_address.get_line1()?;\n        let city_addr = ship_address.get_city()?;\n        let zip_code_addr = ship_address.get_zip()?;\n        let country_code_addr = ship_address.get_country()?;\n        let _first_name_addr = ship_address.get_first_name()?;\n        let _last_name_addr = ship_address.get_last_name()?;\n        let address: Address = Address {\n            street_address: street_addr.clone(),\n            unit: None,\n            postal_code: zip_code_addr.clone(),\n            city: city_addr.clone(),\n            province_code: zip_code_addr.clone(),\n            country_code: country_code_addr.to_owned(),\n        };\n        let destination: Destination = Destination {\n            full_name: ship_address.get_full_name().unwrap_or_default(),\n            organization: None,\n            email: None,\n            address,\n        };\n\n        let created_at = common_utils::date_time::now();\n\n\n... [truncated 322 chars] ...\n\n      products,\n            shipments,\n            currency: item.request.currency,\n            total_shipping_cost: metadata.total_shipping_cost,\n            confirmation_email: item.request.email.clone(),\n            confirmation_phone: billing_address\n                .clone()\n                .phone\n                .and_then(|phone_data| phone_data.number),\n        };\n        Ok(Self {\n            order_id: item.attempt_id.clone(),\n            purchase,\n            decision_delivery: DecisionDelivery::Sync, // Specify SYNC if you require the Response to contain a decision field. If you have registered for a webhook associated with this checkpoint, then the webhook will also be sent when SYNC is specified. If ASYNC_ONLY is specified, then the decision field in the response will be null, and you will require a Webhook integration to receive Signifyd's final decision\n            coverage_requests: metadata.coverage_request,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Purchase Transformer"}, {"query": "how to get status string from Wise connector enum", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: get_status\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]", "function_name": "get_status", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector status conversion"}, {"query": "Rust enum get_status method implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: get_status\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]", "function_name": "get_status", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector status conversion"}, {"query": "hyperswitch wise connector status conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: get_status\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]", "function_name": "get_status", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector status conversion"}, {"query": "normalize status string from Wise payment gateway", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: get_status\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]", "function_name": "get_status", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise connector status conversion"}, {"query": "how to handle worldline payment cancellation response in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsCancelRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsCancelRouterData, errors::ConnectorError> {\n        let response: worldline::PaymentResponse = res\n            .response\n            .parse_struct(\"Worldline PaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline cancellation response handler"}, {"query": "worldline connector handle_response function implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsCancelRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsCancelRouterData, errors::ConnectorError> {\n        let response: worldline::PaymentResponse = res\n            .response\n            .parse_struct(\"Worldline PaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline cancellation response handler"}, {"query": "parse worldline payment response struct in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsCancelRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsCancelRouterData, errors::ConnectorError> {\n        let response: worldline::PaymentResponse = res\n            .response\n            .parse_struct(\"Worldline PaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline cancellation response handler"}, {"query": "PaymentsCancelRouterData worldline connector error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsCancelRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsCancelRouterData, errors::ConnectorError> {\n        let response: worldline::PaymentResponse = res\n            .response\n            .parse_struct(\"Worldline PaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline cancellation response handler"}, {"query": "how to handle error responses in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_error_response\n    fn get_error_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Ok(res) => {\n                    logger::error!(response=?res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting error response, received response: {res:?}\"\n                    ))\n                }\n                Err(err_res) => Ok(err_res),\n            })\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router error response utility"}, {"query": "hyperswitch router get_error_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_error_response\n    fn get_error_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Ok(res) => {\n                    logger::error!(response=?res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting error response, received response: {res:?}\"\n                    ))\n                }\n                Err(err_res) => Ok(err_res),\n            })\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router error response utility"}, {"query": "convert async error to router result rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_error_response\n    fn get_error_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Ok(res) => {\n                    logger::error!(response=?res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting error response, received response: {res:?}\"\n                    ))\n                }\n                Err(err_res) => Ok(err_res),\n            })\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router error response utility"}, {"query": "hyperswitch router utility functions error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_error_response\n    fn get_error_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Ok(res) => {\n                    logger::error!(response=?res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting error response, received response: {res:?}\"\n                    ))\n                }\n                Err(err_res) => Ok(err_res),\n            })\n    }\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router error response utility"}]