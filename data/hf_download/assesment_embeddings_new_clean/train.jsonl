{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "The `get_error_response` method in the Airwallex connector implementation serves as a standardized error handling entry point. It accepts an HTTP `Response` object and an optional `ConnectorEvent` builder to facilitate error logging and webhook generation. By delegating to `build_error_response`, it ensures consistent error formatting and context propagation, allowing the router to handle connector failures gracefully while maintaining audit trails for failed payment or refund operations.", "queries": ["how to handle airwallex connector errors in hyperswitch", "airwallex error response format hyperswitch rust", "hyperswitch connector error handling get_error_response", "airwallex connector error webhook hyperswitch"], "label": "Airwallex error handling", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` method in the Netcetera connector implementation serves as a configuration layer for outgoing HTTP requests. It retrieves and constructs the necessary request headers, including authentication tokens and content-type specifications, by delegating to the internal `build_headers` function. This method is critical for ensuring that the connector communicates securely and correctly with the Netcetera payment gateway, handling the specific header requirements defined in the connector's configuration schema.", "queries": ["how to configure authentication headers for Netcetera connector in hyperswitch", "rust hyperswitch netcetera connector get_headers implementation", "hyperswitch netcetera payment gateway header configuration", "netcetera connector PreAuthNRouterData header handling rust"], "label": "Netcetera connector header configuration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_node_values\n    fn from_node_values<L>(vals: impl IntoIterator<Item = L>) -> Self\n    where\n        L: Into<Self::Value>,\n    {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals.into_iter().map(L::into) {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "positive": "This function constructs a `DssaGraph` instance by aggregating a collection of `dir::DirValue` items into a hierarchical map. It uses a `FxHashMap` keyed by `dir::DirKey` to group values, ensuring that duplicate values for the same key are deduplicated via `FxHashSet`. This utility is essential for building the directed acyclic graph structure used in the Dependency Subgraph Analysis (DSA) module within the `euclid` crate, facilitating efficient lookups and traversal of dependency relationships.", "queries": ["rust hyperswitch euclid dssa graph builder", "how to create DssaGraph from DirValue iterator", "euclid crate DsaGraph from_node_values implementation", "hyperswitch dependency subgraph analysis graph construction"], "label": "DsaGraph builder from DirValue", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "from_node_values", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationCreateRequest\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "positive": "The `AuthenticationCreateRequest` struct in `hyperswitch` defines the input payload for initiating an authentication flow, typically used for 3D Secure (3DS) verification. It requires mandatory fields like `amount` and `currency`, while optional fields such as `authentication_id`, `profile_id`, and `return_url` allow for flexible configuration. The struct supports specific payment orchestration needs, including `force_3ds_challenge` for mandatory verification, `psd2_sca_exemption_type` for regulatory compliance, and `authentication_connector` to specify the payment gateway. It integrates with the router's payment scopes (`/payments`) and relies on `CustomerDetails` and `AcquirerDetails` to map transaction context to the specific business profile and acquiring bank.", "queries": ["rust hyperswitch authentication create request struct fields", "hyperswitch 3ds authentication request payload example", "AuthenticationCreateRequest struct definition rust hyperswitch", "how to use AuthenticationCreateRequest in hyperswitch payments"], "label": "AuthenticationCreateRequest struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__api_models__src__authentication.rs", "path": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "symbol": "AuthenticationCreateRequest", "unit_type": "function", "num_lines": 51}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =\n            res.response.parse_struct(\"Airwallex ErrorResponse\");\n\n        match response {\n            Ok(response) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                let network_error_message = response\n                    .provider_original_response_code\n                    .clone()\n                    .and_then(airwallex::map_error_code_to_message);\n                Ok(ErrorResponse {\n                    status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.source,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: response.provider_original_response_code.clone(),\n                    network_error_message,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                connector_utils::handle_json_response_deserialization_failure(res, \"tesouro\")\n            }\n        }\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse from an Airwallex API response, handling both successful parsing and JSON deserialization failures. It maps the provider's error details (code, message, source) into Hyperswitch's internal error model, optionally populating a ConnectorEvent for downstream processing. It also handles the mapping of provider-specific error codes to user-friendly messages.", "queries": ["how to handle airwallex api error responses in hyperswitch", "airwallex connector error response builder function rust", "map airwallex error codes to hyperswitch error messages", "handle  deserialization failure in airwallex connector hyperswitch"], "label": "Airwallex error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 42}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = tokenex::TokenexInsertRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function serves as the adapter layer for the Tokenex connector within the Hyperswitch payment orchestration platform. It extracts the specific `VaultRouterData<ExternalVaultInsertFlow>` payload and transforms it into a `TokenexInsertRequest` struct, ensuring type safety and error handling via the `try_from` method. The output is wrapped in a `RequestContent::Json` box, preparing the data for transmission to the external Tokenex vault service as part of the vault insertion workflow.", "queries": ["how to implement get_request_body for tokenex connector", "hyperswitch tokenex vault insert request adapter", "rust function get_request_body tokenex", "ExternalVaultInsertFlow to TokenexInsertRequest conversion"], "label": "Tokenex vault insert adapter", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: gigadat::GigadatErrorResponse = res\n            .response\n            .parse_struct(\"GigadatErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.err.clone(),\n            message: response.err.clone(),\n            reason: Some(response.err).clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a Gigadat API response. It deserializes the raw HTTP response into a GigadatErrorResponse struct, logs the details for observability, and populates the error fields. It handles optional event builder injection to propagate the error context to downstream event processing, ensuring the router can map specific Gigadat error codes to internal system errors.", "queries": ["how to handle gigadat error response in hyperswitch", "build_error_response gigadat connector rust implementation", "hyperswitch gigadat error mapping function", "gigadat error response deserialization hyperswitch"], "label": "Gigadat Error Response Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}v2/{}/payouts\",\n            self.base_url(_connectors),\n            auth.merchant_account.peek()\n        ))\n    }\n", "positive": "This function constructs the API endpoint URL for Payone payout operations. It derives the specific merchant account identifier from the request's connector authentication type (`PayoneAuthType`) and appends it to the base Payone v2 payouts path. It is called within the `PayoutsRouterData` context to dynamically route payout requests to the correct Payone merchant endpoint.", "queries": ["how to get payout url from payone connector hyperswitch", "hyperswitch payone connector payout url generation", "rust hyperswitch payone payout endpoint url", "PayoneAuthType hyperswitch connector payout routing"], "label": "Payone Payout URL Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayAuthUpdateResponse\npub struct IatapayAuthUpdateResponse {\n    pub access_token: Secret<String>,\n    pub expires_in: i64,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayAuthUpdateResponse, T, AccessToken>>\n    for RouterData<F, T, AccessToken>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "positive": "The IatapayAuthUpdateResponse struct encapsulates the essential data returned by the IATAPay connector after successfully refreshing an authentication token. It contains the new access token (stored securely as a Secret) and the token's expiration duration in seconds. This struct is used within the TryFrom implementation to map the raw HTTP response from IATAPay into the internal RouterData model, ensuring that the authentication flow for IATAPay payments is correctly initialized for subsequent transaction processing.", "queries": ["IATAPay access token refresh response structure", "Rust struct for IATAPay authentication token", "IatapayAuthUpdateResponse implementation details", "Hyperswitch IATAPay connector token handling"], "label": "IATAPay auth token response", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "symbol": "IatapayAuthUpdateResponse", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionSyncStatus\npub enum TransactionSyncStatus {\n    PEN, // Pended\n    OPN, // Unpended / release / open\n    REV, // Review\n    STL, // Settled\n    PST, // Failed due to post-auth rule\n    FPR, // Failed due to fraud prevention rules\n    PRE, // Failed due to pre-auth rule\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "positive": "The TransactionSyncStatus enum defines the lifecycle states of a transaction within the Hyperswitch payment orchestration platform. It is used to track the current status of a payment, refund, or dispute, ranging from pending (PEN) and open (OPN) to settled (STL) or failed due to fraud (FPR) or post-auth rules (PST). This enum is crucial for the router and connector layers to manage transaction flows and ensure accurate state reporting to clients.", "queries": ["Rust enum for payment transaction status in Hyperswitch", "Hyperswitch TransactionSyncStatus enum definition", "What does TransactionSyncStatus enum represent in Rust?", "Hyperswitch payment orchestration transaction states"], "label": "TransactionSyncStatus enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "TransactionSyncStatus", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: GenericLinkEnvConfig\npub struct GenericLinkEnvConfig {\n    pub sdk_url: url::Url,\n    pub expiry: u32,\n    pub ui_config: GenericLinkEnvUiConfig,\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub enabled_payment_methods: HashMap<enums::PaymentMethod, HashSet<enums::PaymentMethodType>>,\n}\n", "positive": "The GenericLinkEnvConfig struct defines the runtime configuration for generic link generation within the Hyperswitch payment orchestration platform. It encapsulates the SDK endpoint URL, the link expiration duration in seconds, and UI-specific settings. Crucially, it manages the mapping of enabled payment methods to their specific types using a HashMap, allowing dynamic configuration of supported transaction flows. This struct is typically deserialized from environment variables or configuration files to initialize the link generation service.", "queries": ["rust struct definition GenericLinkEnvConfig hyperswitch", "how to configure generic link expiry and payment methods in hyperswitch", "hyperswitch GenericLinkEnvConfig deserialize_hashmap enabled_payment_methods", "rust url::Url GenericLinkEnvUiConfig hyperswitch configuration"], "label": "GenericLinkEnvConfig struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "GenericLinkEnvConfig", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\nimpl\n    ConnectorIntegration<\n        PostAuthentication,\n        ConnectorPostAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "positive": "This function retrieves and formats an error response from the Gpayments connector integration. It accepts a raw HTTP Response and an optional mutable reference to a ConnectorEvent builder. The method delegates to `build_error_response` to construct a standardized `ErrorResponse` object, handling the transformation of raw HTTP status codes and bodies into the platform's internal error format. It is part of the `ConnectorIntegration` trait implementation for `PostAuthentication`, ensuring consistent error handling during the authentication handshake with the Gpayments provider.", "queries": ["rust hyperswitch gpayments connector error response implementation", "how does hyperswitch handle gpayments authentication errors", "gpayments connector get_error_response function source code", "hyperswitch rust connector error handling PostAuthentication"], "label": "Gpayments error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: get_status\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]", "positive": "The `get_status` function is a method within a Rust enum implementation, designed to provide a string representation of the enum's current state. It handles two variants, `String` and `Number`, by cloning the value for the `String` variant or converting the numeric value to a string for the `Number` variant. This utility is likely used within the `hyperswitch_connectors` crate to normalize status data from various external payment gateway APIs (specifically Wise) into a consistent string format for downstream processing or logging.", "queries": ["how to get status string from Wise connector enum", "Rust enum get_status method implementation", "hyperswitch wise connector status conversion", "normalize status string from Wise payment gateway"], "label": "Wise connector status conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "get_status", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = amazonpay::AmazonpayRouterData::from((amount, req));\n        let connector_req = amazonpay::AmazonpayFinalizeRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function constructs the JSON payload for an Amazon Pay authorization request within the Hyperswitch payment orchestration platform. It leverages the `amount_converter` utility to transform the incoming `PaymentsAuthorizeRouterData` into a minor amount and currency format required by the Amazon Pay connector. The function then instantiates `AmazonpayRouterData` and attempts to convert it into a finalized `AmazonpayFinalizeRequest` struct. This ensures that the request body sent to the external Amazon Pay API is correctly typed and contains the necessary financial context derived from the orchestration layer.", "queries": ["rust hyperswitch amazonpay get_request_body implementation", "how to build amazonpay finalize request in hyperswitch", "hyperswitch rust connector amazonpay request body construction", "amazonpay router data conversion rust hyperswitch"], "label": "AmazonPay request body builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = authipay::AuthipayRouterData::from((amount, req));\n        let connector_req = authipay::AuthipayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function constructs the JSON payload for an Authipay payment authorization request. It acts as a translation layer within the `hyperswitch_connectors` crate, converting the generic `PaymentsAuthorizeRouterData` into the specific `AuthipayPaymentsRequest` format required by the Authipay API. It leverages the `amount_converter` utility to ensure precise minor_amount and currency mapping, then wraps the result in a `RequestContent::Json` struct before transmission to the connector.", "queries": ["rust function to convert authorize request to authipay json format", "how does get_request_body handle currency conversion in hyperswitch", "authipay connector request body construction rust", "PaymentsAuthorizeRouterData to AuthipayPaymentsRequest conversion"], "label": "Authipay request payload builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_payment_method_token\n    pub fn get_payment_method_token(&self) -> Option<Secret<String>> {\n        match self {\n            Self::Token(secret_token) => Some(secret_token.clone()),\n            _ => None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This function retrieves the secret token from a `PaymentMethod` enum variant. It is used to expose sensitive authentication details required for downstream API calls or connector initialization. It is part of the domain models layer, ensuring secure handling of payment method credentials within the payment orchestration platform.", "queries": ["how to get the secret token from a payment method in hyperswitch rust", "hyperswitch rust get_payment_method_token implementation", "how to access secret token from PaymentMethod enum hyperswitch", "rust hyperswitch domain models get_payment_method_token example"], "label": "PaymentMethod token retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "get_payment_method_token", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: payone::PayoneAuthType,\n        http_method: String,\n        canonicalized_path: String,\n        content_type: String,\n        date_header: String,\n    ) -> CustomResult<String, ConnectorError> {\n        let payone::PayoneAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let string_to_hash: String = format!(\n            \"{}\\n{}\\n{}\\n{}\\n\",\n            http_method,\n            content_type.trim(),\n            date_header.trim(),\n            canonicalized_path.trim()\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let hash_hmac = BASE64_ENGINE.encode(hmac::sign(&key, string_to_hash.as_bytes()));\n        let signature_header = format!(\"GCS v1HMAC:{}:{}\", api_key.peek(), hash_hmac);\n\n        Ok(signature_header)\n    }\n}\n", "positive": "This function generates a GCS v1HMAC signature for Payone API authentication. It constructs a canonical string from the HTTP method, content type, date header, and canonicalized path, then signs it using the provided API secret and HMAC-SHA256 algorithm. The resulting signature is returned in the format 'GCS v1HMAC:{api_key}:{hash}'. This is essential for securing outbound Payone API requests within the hyperswitch payment orchestration platform.", "queries": ["rust hyperswitch payone generate_signature function", "hyperswitch payone connector signature generation hmac sha256", "how to implement payone api signature in rust hyperswitch", "hyperswitch payone auth signature header format"], "label": "payone signature generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "generate_signature", "unit_type": "function", "num_lines": 28}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for the Thunes payment connector, specifically handling the 'PaymentsAuthorize' flow. It leverages the `PaymentsAuthorizeType` trait to dynamically generate the target URL, attach default headers, and serialize the request body based on the provided `PaymentsAuthorizeRouterData` and `Connectors` context. It returns a configured `Request` object ready for transmission.", "queries": ["how to build authorize request for thunes connector", "rust function build_request thunes payments authorize", "thunes connector request builder implementation hyperswitch", "PaymentsAuthorizeType get_url thunes connector"], "label": "Thunes authorize request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Netcetera\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Netcetera\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for the Netcetera payment connector within the Hyperswitch payment orchestration platform. It specifies the data flow for tokenizing payment methods (PaymentMethodToken -> PaymentMethodTokenizationData) and processing payments (PaymentsResponseData). The implementation is currently marked as 'Not Implemented (R)', indicating that the connector logic for Netcetera is not yet active in the current codebase version.", "queries": ["how to implement Netcetera payment connector integration in Rust", "Netcetera payment method tokenization implementation hyperswitch", "hyperswitch connector integration traits Rust Netcetera", "Rust payment gateway connector integration Netcetera"], "label": "Netcetera connector integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverErrorResponse = res\n            .response\n            .parse_struct(\"JuspaythreedsserverErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a raw HTTP Response received from the Juspay 3DS server. It deserializes the response body into a JuspaythreedsserverErrorResponse struct, logs the raw connector response for debugging, and populates the error fields (status_code, code, message, reason). It optionally attaches the parsed response to a ConnectorEvent builder. This ensures that error details from the third-party provider are normalized and passed up the orchestration stack for downstream handling.", "queries": ["how to handle Juspay 3DS error response in hyperswitch", "build_error_response function implementation rust", "parse JuspaythreedsserverErrorResponse struct", "hyperswitch connector error handling Juspay"], "label": "Juspay 3DS Error Response Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = gigadat::GigadatRouterData::from((amount, req));\n        let connector_req = gigadat::GigadatCpiRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function prepares the JSON payload for the Gigadat payment gateway by converting the internal minor amount to the required format and mapping the router data into the specific Gigadat CPI request structure. It acts as a serialization layer within the Gigadat connector, ensuring the payment authorization request adheres to the external provider's API contract before transmission.", "queries": ["how to format Gigadat authorization request body", "convert minor amount to Gigadat request format", "GigadatCpiRequest builder implementation", "hyperswitch gigadat connector request payload"], "label": "Gigadat authorization request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: powertranz::PowertranzBaseResponse = res\n            .response\n            .parse_struct(\"Powertranz PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "The `handle_response` function in the Powertranz connector processes the HTTP response body from a payment authorization request. It deserializes the raw response into a `PowertranzBaseResponse` struct using `serde` and `parse_struct`. The function logs the response details for debugging and updates the `ConnectorEvent` builder with the parsed data. Finally, it constructs a `RouterData` instance containing the response, original request data, and HTTP status code to proceed with the downstream routing logic.", "queries": ["rust hyperswitch powertranz connector handle_response function", "how to parse powertranz authorize response in hyperswitch", "hyperswitch powertranz connector deserialization error", "rust connector event builder set_response_body hyperswitch"], "label": "Powertranz authorize response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 21}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: Settings\npub struct Settings<S: SecretState> {\n    pub server: Server,\n    pub application_source: common_enums::ApplicationSource,\n    pub proxy: Proxy,\n    pub env: Env,\n    pub chat: SecretStateContainer<ChatSettings, S>,\n    pub master_database: SecretStateContainer<Database, S>,\n    #[cfg(feature = \"olap\")]\n    pub replica_database: SecretStateContainer<Database, S>,\n    pub redis: RedisSettings,\n    pub log: Log,\n    pub secrets: SecretStateContainer<Secrets, S>,\n    pub fallback_merchant_ids_api_key_auth: Option<FallbackMerchantIds>,\n    pub locker: Locker,\n    pub key_manager: SecretStateContainer<KeyManagerConfig, S>,\n    pub connectors: Connectors,\n    pub forex_api: SecretStateContainer<ForexApi, S>,\n    pub refund: Refund,\n    pub eph_key: EphemeralConfig,\n    pub scheduler: Option<SchedulerSettings>,\n    #[cfg(feature = \"kv_store\")]\n    pub drainer: DrainerSettings,\n    pub jwekey: SecretStateContainer<Jwekey, S>,\n    pub webhooks: WebhooksSettings,\n    pub pm_filters: ConnectorFilters,\n    pub bank_config: BankRedirectConfig,\n    pub api_keys: SecretStateContainer<ApiKeys, S>,\n    pub file_storage: FileStorageConfig,\n    pub encryption_management: EncryptionManagementConfig,\n    pub secrets_management: SecretsManagementConfig,\n    pub tokenization: TokenizationConfig,\n    pub connector_customer: ConnectorCustomer,\n    #[cfg(feature = \"dummy_connector\")]\n    pub dummy_connector: DummyConnector,\n    #[cfg(feature = \"email\")]\n    pub email: EmailSettings,\n    pub user: UserSettings,\n    pub oidc: SecretStateContainer<OidcSettings, S>,\n    pub crm: CrmManagerConfig,\n    pub cors: CorsSettings,\n    pub mandates: Mandates,\n    pub zero_mandates: ZeroMandates,\n    pub network_transaction_id_supported_connectors: NetworkTransactionIdSupportedConnectors,\n    pub card_only_mit_supported_connectors: CardOnlyMitSupportedConnectors,\n    pub list_dispute_supported_connectors: ListDiputeSupportedConnectors,\n    pub required_fields: RequiredFields,\n    pub delayed_session_response: DelayedSessionConfig,\n    pub webhook_source_verification_call: WebhookSourceVerificationCall,\n    pub billing_connectors_payment_sync: BillingConnectorPaymentsSyncCall,\n    pub billing_connectors_invoice_sync: BillingConnectorInvoiceSyncCall,\n    pub payment_method_auth: SecretStateContainer<PaymentMethodAuth, S>,\n    pub connector_request_reference_id_config: ConnectorRequestReferenceIdConfig,\n    #[cfg(feature = \"payouts\")]\n    pub payou\n\n... [truncated 2088 chars] ...\n\nure = \"v2\")]\n    pub revenue_recovery: revenue_recovery::RevenueRecoverySettings,\n    pub merchant_advice_codes: MerchantAdviceCodeLookupConfig,\n    pub clone_connector_allowlist: Option<CloneConnectorAllowlistConfig>,\n    pub merchant_id_auth: MerchantIdAuthSettings,\n    pub internal_merchant_id_profile_id_auth: InternalMerchantIdProfileIdAuthSettings,\n    #[serde(default)]\n    pub infra_values: Option<HashMap<String, String>>,\n    #[serde(default)]\n    pub enhancement: Option<HashMap<String, String>>,\n    pub superposition: SecretStateContainer<SuperpositionClientConfig, S>,\n    pub proxy_status_mapping: ProxyStatusMapping,\n    pub trace_header: TraceHeaderConfig,\n    pub internal_services: InternalServicesConfig,\n    #[serde(default)]\n    pub micro_services: MicroServicesConfig,\n    pub comparison_service: Option<ComparisonServiceConfig>,\n    pub authentication_service_enabled_connectors: AuthenticationServiceEnabledConnectors,\n    pub save_payment_method_on_session: OnSessionConfig,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "positive": "The Settings struct serves as the central configuration container for the Hyperswitch router, aggregating runtime parameters for server, database (PostgreSQL master/replica), Redis, and connectors. It manages secret states for sensitive components like API keys, JWE keys, and OIDC, while defining routing scopes, webhook handling, and feature flags (e.g., OLAP, KV_STORE). This struct is injected into the router's dependency injection container to drive application behavior and tenant isolation.", "queries": ["Hyperswitch router configuration struct definition", "how to configure PostgreSQL master and replica connections in Settings", "Hyperswitch settings struct secret state container usage", "configure webhook settings and connector filters in router"], "label": "Router configuration struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "Settings", "unit_type": "function", "num_lines": 117}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Products\npub struct Products {\n    item_name: String,\n    item_price: i64,\n    item_quantity: i32,\n    item_id: Option<String>,\n    item_category: Option<String>,\n    item_sub_category: Option<String>,\n    item_is_digital: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This struct defines the data model for a product item within the Signifyd connector's API transformation layer. It encapsulates core attributes like item name, price, quantity, and category, while also supporting digital product identification. The struct is marked with `#[serde(rename_all = camelCase)]` to ensure proper serialization/deserialization compatibility with external Signifyd API responses, facilitating the mapping of raw API data into the internal domain models used by the Hyperswitch payment orchestration platform.", "queries": ["Signifyd API product item struct definition", "how to map Signifyd product data to internal models", "Signifyd connector item_name item_price fields", "hyperswitch signifyd product transformation struct"], "label": "Signifyd Product Item Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "Products", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: TaxInfo\npub struct TaxInfo {\n    pub tax_status: Option<common_enums::TaxStatus>,\n    pub customer_tax_registration_id: Option<Secret<String>>,\n    pub merchant_tax_registration_id: Option<Secret<String>>,\n    pub shipping_amount_tax: Option<MinorUnit>,\n    pub order_tax_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "positive": "The TaxInfo struct in hyperswitch_domain_models is a core domain model representing tax-related data for a payment transaction. It encapsulates tax status, customer and merchant tax registration IDs (stored securely), and tax amounts for the order and shipping. This struct is essential for compliance, accurate tax calculation, and reporting within the payment orchestration platform, serving as a key data transfer object between the router, connectors, and storage layers.", "queries": ["hyperswitch TaxInfo struct definition rust", "how to use TaxInfo struct in hyperswitch domain models", "TaxInfo struct fields customer_tax_registration_id rust", "hyperswitch tax registration id struct implementation"], "label": "TaxInfo struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "TaxInfo", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndNetworkTokenDetails\npub struct NetworkTransactionIdAndNetworkTokenDetails {\n    /// The Network Token\n    pub network_token: cards::NetworkToken,\n\n    /// The token's expiry month\n    pub token_exp_month: Secret<String>,\n\n    /// The token's expiry year\n    pub token_exp_year: Secret<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    /// The type of the card such as Credit, Debit\n    pub card_type: Option<String>,\n\n    /// The country in which the card was issued\n    pub card_issuing_country: Option<String>,\n\n    /// The bank code of the bank that issued the card\n    pub bank_code: Option<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n\n    /// The network transaction ID provided by the card network during a Customer Initiated Transaction (CIT)\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "positive": "This struct encapsulates sensitive details for a card network token, including the token itself, expiry (month/year), and card metadata like network type, issuing country, and bank code. It is critical for off-session payments where `setup_future_usage` is enabled, storing the `network_transaction_id` returned by the network during the Customer Initiated Transaction (CIT). The data is typed as `Secret<String>` to ensure sensitive fields like cardholder name and expiry are handled securely within the `hyperswitch_domain_models` crate.", "queries": ["Rust struct for network transaction ID and token details hyperswitch", "how to handle off_session payment token expiry in hyperswitch domain models", "Secret<String> usage for cardholder name and network token in Rust", "hyperswitch domain models network_transaction_id off_session setup_future_usage"], "label": "Network Token Details Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "NetworkTransactionIdAndNetworkTokenDetails", "unit_type": "function", "num_lines": 40}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseBankDetails\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,\n    post_code: Option<String>,\n    nationality: Option<String>,\n    account_holder_name: Option<Secret<String>>,\n    email: Option<Email>,\n    account_number: Option<Secret<String>>,\n    city: Option<String>,\n    sort_code: Option<Secret<String>>,\n    iban: Option<Secret<String>>,\n    bic: Option<Secret<String>>,\n    transit_number: Option<Secret<String>>,\n    routing_number: Option<Secret<String>>,\n    abartn: Option<Secret<String>>,\n    swift_code: Option<Secret<String>>,\n    payin_reference: Option<String>,\n    psp_reference: Option<String>,\n    tax_id: Option<String>,\n    order_id: Option<String>,\n    job: Option<String>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "positive": "The `WiseBankDetails` struct in the `hyperswitch_connectors` crate defines the core data model for capturing and validating bank account details during payouts. It is a critical component for the Wise connector, mapping the specific fields required by Wise's API (such as IBAN, BIC, sort code, and account holder name) to internal representations. The struct uses `Secret` wrappers for sensitive fields like account numbers and sort codes to ensure secure handling. It is heavily utilized within the `transformers.rs` file to transform incoming payout requests into the format expected by Wise, handling both validation and serialization for the `payouts` feature.", "queries": ["How to configure Wise payout bank details in Hyperswitch?", "WiseBankDetails struct fields for IBAN and BIC validation", "Rust struct definition for Wise bank account payout data", "Secret<String> usage in WiseBankDetails account_number field"], "label": "Wise payout bank details struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "WiseBankDetails", "unit_type": "function", "num_lines": 27}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentStatus\npub enum IatapayPaymentStatus {\n    #[default]\n    Created,\n    Initiated,\n    Authorized,\n    Settled,\n    Cleared,\n    Failed,\n    #[serde(rename = \"UNEXPECTED SETTLED\")]\n    UnexpectedSettled,\n}\n", "positive": "Defines the state machine for IATAPay transaction lifecycle within the hyperswitch_connectors crate. This enum maps IATAPay's specific API status codes to internal Rust representations, handling standard states like Created, Initiated, Authorized, Settled, and Failed, alongside the legacy 'UNEXPECTED SETTLED' edge case. It is used by the IatapayPaymentStatus transformer to normalize responses from the IATAPay HTTP API before dispatching events to the router or storage layer.", "queries": ["IATAPay transaction status mapping enum", "Rust enum for IATAPay payment states", "hyperswitch IATAPay status transformer", "IATAPayUnexpectedSettled enum variant"], "label": "IATAPay status enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "symbol": "IatapayPaymentStatus", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: try_from\n    fn try_from(\n        item: (\n            Option<common_enums::ExternalVaultEnabled>,\n            Option<ExternalVaultConnectorDetails>,\n        ),\n    ) -> Result<Self, Self::Error> {\n        match item {\n            (is_external_vault_enabled, external_vault_connector_details)\n                if is_external_vault_enabled\n                    .unwrap_or(common_enums::ExternalVaultEnabled::Skip)\n                    == common_enums::ExternalVaultEnabled::Enable =>\n            {\n                Ok(Self::ExternalVaultEnabled(\n                    external_vault_connector_details\n                        .get_required_value(\"ExternalVaultConnectorDetails\")?,\n                ))\n            }\n            _ => Ok(Self::Skip),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "positive": "This function implements a conversion logic for the BusinessProfile enum, specifically handling the 'ExternalVaultEnabled' configuration state. It accepts a tuple containing an optional boolean flag and optional connector details. If the flag is set to 'Enable', it extracts and validates the required 'ExternalVaultConnectorDetails' from the input, returning a variant containing the details. Otherwise, it defaults to the 'Skip' state. This logic is critical for determining whether the payment orchestration platform should route transactions through a specific external vault connector or bypass it, directly influencing the payment flow configuration within the domain models.", "queries": ["how to configure external vault connector details in business profile", "rust try_from implementation for external vault enabled enum", "hyperswitch business profile external vault configuration logic", "convert external vault settings to business profile skip or enable"], "label": "ExternalVaultEnabled conversion logic", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__business_profile.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 23}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsCancelRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let auth: worldline::WorldlineAuthType =\n            worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account_id = auth.merchant_account_id.expose();\n        let payment_id = &req.request.connector_transaction_id;\n        Ok(format!(\n            \"{base_url}v1/{merchant_account_id}/payments/{payment_id}/cancel\",\n        ))\n    }\n", "positive": "The `get_url` function constructs the specific API endpoint URL for cancelling a payment transaction within the Worldline connector. It leverages the base URL and authentication details from the request context, extracting the merchant account ID and the connector's transaction ID to format a precise cancellation URL string. This function is a critical component of the connector's request routing logic, ensuring the correct endpoint is targeted for the payment cancellation operation.", "queries": ["Rust hyperswitch worldline connector get_url function implementation", "how to construct worldline payment cancel url hyperswitch", "hyperswitch worldline connector get_url method source code", "worldline payment cancellation url generation hyperswitch rust"], "label": "Worldline payment cancel URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: authipay::AuthipayErrorResponse = res\n            .response\n            .parse_struct(\"AuthipayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n\n        let mut error_response = ErrorResponse::from(&response);\n\n        // Set status code from the response, or 400 if error code is a \"404\"\n        if let Some(error_code) = &response.error.code {\n            if error_code == \"404\" {\n                error_response.status_code = 404;\n            } else {\n                error_response.status_code = res.status_code;\n            }\n        } else {\n            error_response.status_code = res.status_code;\n        }\n\n        Ok(error_response)\n    }\n}\n", "positive": "The `build_error_response` function in the `authipay` connector is responsible for transforming an HTTP response from the Authipay payment gateway into a standardized `ErrorResponse` object used by the Hyperswitch platform. It parses the raw JSON body into a specific `AuthipayErrorResponse` struct, sets the appropriate HTTP status code (defaulting to the response's status or 400 if the error code is '404'), and optionally populates a `ConnectorEvent` with the error details for downstream processing. This function is a critical component of the connector's error handling pipeline, ensuring that failures from the external provider are normalized and logged correctly.", "queries": ["How to handle Authipay error responses in Rust", "Hyperswitch authipay connector error handling", "build_error_response function authipay", "Parse AuthipayErrorResponse in Rust"], "label": "Authipay error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Helcim\".to_string())\n                .into(),\n        )\n\n        // Ok(Some(\n        //     RequestBuilder::new()\n        //         .method(Method::Post)\n        //         .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n        //         .attach_default_headers()\n        //         .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n        //         .set_body(types::SetupMandateType::get_request_body(\n        //             self, req, connectors,\n        //         )?)\n        //         .build(),\n        // ))\n    }", "positive": "The `build_request` function in the Helcim connector is responsible for constructing the HTTP request for the Setup Mandate flow. Currently, it returns a `NotImplemented` error, indicating that this specific payment orchestration flow is not yet supported for the Helcim integration. The function signature suggests it would eventually accept setup mandate router data and a connectors context to build a `Request` object, utilizing helper methods like `get_url`, `get_headers`, and `get_request_body` from the `SetupMandateType` trait. This function is a critical part of the connector's request lifecycle, sitting between the router's orchestration logic and the external Helcim API.", "queries": ["helcim setup mandate rust implementation", "hyperswitch helcim connector build_request function", "rust setup mandate router data helcim", "helcim payment orchestration setup mandate not implemented"], "label": "Helcim Setup Mandate Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = netcetera::NetceteraMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n", "positive": "This function constructs the final API endpoint URL for Netcetera payment processing by replacing a placeholder string in the base URL with the specific merchant endpoint prefix derived from connector metadata. It acts as a dynamic URL resolver, ensuring the request is routed to the correct merchant-specific gateway URL defined in the Netcetera configuration. The function handles secret serialization via `SecretSerdeValue` and returns a `CustomResult` to signal success or configuration errors.", "queries": ["how to dynamically generate netcetera payment gateway url with merchant prefix", "rust function to replace placeholder in base url using connector metadata", "netcetera connector build_endpoint implementation hyperswitch", "hyperswitch netcetera metadata endpoint_prefix url construction"], "label": "Netcetera URL construction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "build_endpoint", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: set_access_token_for_ucs\npub async fn set_access_token_for_ucs(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    access_token: AccessToken,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n) -> Result<(), errors::StorageError> {\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        &merchant_connector_id_or_connector_name,\n    );\n\n    let modified_access_token = AccessToken {\n        expires: access_token\n            .expires\n            .saturating_sub(consts::REDUCE_ACCESS_TOKEN_EXPIRY_TIME.into()),\n        ..access_token\n    };\n\n    logger::debug!(\n        access_token_expiry_after_modification = modified_access_token.expires,\n        merchant_id = ?merchant_id,\n        connector_name = connector_name,\n        merchant_connector_id_or_connector_name = merchant_connector_id_or_connector_name\n    );\n\n    if let Err(access_token_set_error) = state\n        .store\n        .set_access_token(key, modified_access_token)\n        .await\n    {\n        // If we are not able to set the access token in redis, the error should just be logged and proceed with the payment\n        // Payments should not fail, once the access token is successfully created\n        // The next request will create new access token, if required\n        logger::error!(access_token_set_error=?access_token_set_error, \"Failed to store UCS access token\");\n    }\n\n    Ok(())\n}\n\n// Re-export webhook transformer types for easier access\npub use transformers::{WebhookTransformData, WebhookTransformationStatus};\n\n/// Type alias for return type used by unified connector service response handlers\ntype UnifiedConnectorServiceResult = CustomResult<\n    (\n        Result<(PaymentsResponseData, AttemptStatus), ErrorResponse>,\n        u16,\n    ),\n    UnifiedConnectorServiceError,\n>;\n\n/// Type alias for return type used by unified connector service refund response handlers\ntype UnifiedConnectorServiceRefundResult =\n    CustomResult<(Result<RefundsResponseData, ErrorResponse>, u16), UnifiedConnectorServiceError>;\n\n/// Checks if the Unified Connector Service (UCS) is available for use", "positive": "This function, `set_access_token_for_ucs`, manages the lifecycle of access tokens for the Unified Connector Service (UCS) within the Hyperswitch payment orchestration platform. It accepts an access token and merchant context, calculates a modified expiry time by subtracting a constant buffer (`REDUCE_ACCESS_TOKEN_EXPIRY_TIME`), and stores the result in Redis via the session state. Crucially, it handles storage failures gracefully by logging errors without failing the payment flow, ensuring high availability. The function determines the storage key using the merchant ID and either a specific `MerchantConnectorAccountId` or a generic `creds_identifier`, falling back to the connector name if neither is provided.", "queries": ["How to set access token for UCS in hyperswitch router", "hyperswitch router set_access_token_for_ucs function implementation", "Rust function to update UCS access token expiry time", "hyperswitch router merchant connector id access token storage"], "label": "UCS access token management", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "set_access_token_for_ucs", "unit_type": "function", "num_lines": 65}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "positive": "The `build_headers` function within the `Globepay` connector implementation generates the HTTP headers required for outbound requests to the Globepay API. It specifically constructs a vector of key-value pairs, defaulting to `Content-Type` based on the connector's configuration. This method is called by the generic HTTP client wrapper to ensure the request payload is correctly formatted before transmission, handling the specific header requirements of the Globepay payment gateway.", "queries": ["how to configure content type for globepay connector", "globepay rust connector build_headers implementation", "hyperswitch globepay header configuration", "rust globepay connector content type setup"], "label": "Globepay connector header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsRequest\npub struct IatapayPaymentsRequest {\n    merchant_id: Secret<String>,\n    merchant_payment_id: Option<String>,\n    amount: FloatMajorUnit,\n    currency: common_enums::Currency,\n    country: common_enums::CountryAlpha2,\n    locale: String,\n    redirect_urls: RedirectUrls,\n    notification_url: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    payer_info: Option<PayerInfo>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    preferred_checkout_method: Option<PreferredCheckoutMethod>,\n}\n\nimpl\n    TryFrom<&IatapayRouterData<&RouterData<Authorize, PaymentsAuthorizeData, PaymentsResponseData>>>\n    for IatapayPaymentsRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n", "positive": "The `IatapayPaymentsRequest` struct is a core data transfer object within the IATAPay connector implementation. It encapsulates the necessary parameters for constructing a payment request, including merchant identification (`merchant_id`), financial details (`amount`, `currency`, `country`), and user interaction settings (`locale`, `redirect_urls`, `notification_url`). It also supports optional fields for payer information and preferred checkout methods. This struct is designed to be deserialized from JSON payloads and is central to the transformation logic within the connector's request handling pipeline.", "queries": ["IatapayPaymentsRequest struct definition rust", "how to construct IatapayPaymentsRequest object", "IatapayPaymentsRequest serde skip_serializing_if", "IatapayPaymentsRequest fields documentation"], "label": "IatapayPaymentsRequest struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "symbol": "IatapayPaymentsRequest", "unit_type": "function", "num_lines": 21}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Barclaycard\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Barclaycard\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This function implements the core integration logic for the Barclaycard payment connector within the Hyperswitch platform. It defines the trait implementation for `ConnectorIntegration`, specifically handling the tokenization of payment methods using `PaymentMethodToken` and `PaymentMethodTokenizationData`. The implementation is currently marked as 'Not Implemented (R)', indicating that the specific business logic for processing Barclaycard tokenization requests is pending or reserved for future development. This unit serves as the architectural anchor for the connector, defining the interface contract for payment processing flows.", "queries": ["Barclaycard connector tokenization implementation Rust", "hyperswitch Barclaycard PaymentMethodTokenizationData", "Barclaycard payment method tokenization not implemented", "hyperswitch connector integration trait implementation"], "label": "Barclaycard tokenization integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Decision\npub struct Decision {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    checkpoint_action: SignifydPaymentStatus,\n    checkpoint_action_reason: Option<String>,\n    checkpoint_action_policy: Option<String>,\n    score: Option<f64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "positive": "The `Decision` struct defines the response payload for the Signifyd fraud detection connector, encapsulating the risk assessment outcome. It includes a timestamp (`created_at`), the final fraud status (`checkpoint_action`), the reason for the decision (`checkpoint_action_reason`), the policy applied (`checkpoint_action_policy`), and a risk score (`score`). This data is deserialized from the Signifyd API response and used by the `transformers::api` module to determine whether to authorize or block a payment transaction within the Hyperswitch orchestration flow.", "queries": ["Signifyd fraud decision response struct fields", "how to parse signifyd checkpoint action in rust", "hyperswitch signifyd connector decision struct", "signifyd fraud score and checkpoint action types"], "label": "Signifyd Decision Response Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "Decision", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: default\n    fn default() -> Self {\n        Self {\n            #[allow(clippy::expect_used)]\n            sdk_url: url::Url::parse(\"http://localhost:9050/HyperLoader.js\")\n                .expect(\"Failed to parse default SDK URL\"),\n            expiry: 900,\n            ui_config: GenericLinkEnvUiConfig::default(),\n            enabled_payment_methods: HashMap::default(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Clone)]", "positive": "This function initializes the default configuration for the Router crate, specifically setting up the HyperLoader SDK connection. It parses a hardcoded localhost URL ('http://localhost:9050/HyperLoader.js') for the SDK endpoint and sets a default session expiry of 900 seconds. It also initializes an empty HashMap for enabled payment methods and applies default UI configuration settings. This serves as the fallback configuration when no custom settings are provided during system startup.", "queries": ["rust hyperswitch router default sdk_url configuration", "how to configure HyperLoader SDK URL in hyperswitch router", "hyperswitch router default settings function implementation", "set default HyperLoader SDK URL in hyperswitch router"], "label": "router default sdk config", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "default", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: gigadat::GigadatPaymentResponse = res\n            .response\n            .parse_struct(\"GigadatPaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the Gigadat payment gateway after an authorization request. It deserializes the raw response body into a `GigadatPaymentResponse` struct, logs the details for observability, and constructs a `RouterData` object containing the parsed response, original request data, and HTTP status code. It is a critical step in the payment orchestration flow, bridging the external connector's output with the internal router's state management.", "queries": ["how to handle gigadat payment response in hyperswitch", "rust function parse_struct gigadat response hyperswitch", "gigadat connector handle_response implementation hyperswitch", "hyperswitch gigadat authorization response handling"], "label": "Gigadat Response Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 21}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: juspaythreedsserver::JuspaythreedsserverPaymentsResponse = res\n            .response\n            .parse_struct(\"Juspaythreedsserver PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the Juspay 3DS server for an authorize transaction. It deserializes the raw response into a structured JuspaythreedsserverPaymentsResponse, logs the details for debugging, and attempts to construct a RouterData object containing the parsed response and original request context. It is a critical component in the Juspay connector's flow, bridging the external payment gateway's API output with the internal router's data model.", "queries": ["how to handle Juspay 3DS authorize response in Rust", "JuspaythreedsserverPaymentsResponse deserialization error", "hyperswitch juspay connector handle_response implementation", "parse Juspay 3DS server response body"], "label": "Juspay 3DS authorize response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: viz\n    fn viz(&self) -> String {\n        match self {\n            Self::PaymentMethod(pm) => pm.to_string(),\n            Self::CardBin(bin) => bin.value.clone(),\n            Self::ExtendedCardBin(ebin) => ebin.value.clone(),\n            Self::CardType(ct) => ct.to_string(),\n            Self::CardNetwork(cn) => cn.to_string(),\n            Self::PayLaterType(plt) => plt.to_string(),\n            Self::WalletType(wt) => wt.to_string(),\n            Self::UpiType(ut) => ut.to_string(),\n            Self::BankTransferType(btt) => btt.to_string(),\n            Self::BankRedirectType(brt) => brt.to_string(),\n            Self::BankDebitType(bdt) => bdt.to_string(),\n            Self::CryptoType(ct) => ct.to_string(),\n            Self::RewardType(rt) => rt.to_string(),\n            Self::PaymentAmount(amt) => amt.number.to_string(),\n            Self::PaymentCurrency(curr) => curr.to_string(),\n            Self::AuthenticationType(at) => at.to_string(),\n            Self::CaptureMethod(cm) => cm.to_string(),\n            Self::BusinessCountry(bc) => bc.to_string(),\n            Self::BillingCountry(bc) => bc.to_string(),\n            Self::Connector(conn) => conn.connector.to_string(),\n            Self::MetaData(mv) => format!(\"[{} = {}]\", mv.key, mv.value),\n            Self::MandateAcceptanceType(mat) => mat.to_string(),\n            Self::MandateType(mt) => mt.to_string(),\n            Self::PaymentType(pt) => pt.to_string(),\n            Self::VoucherType(vt) => vt.to_string(),\n            Self::GiftCardType(gct) => gct.to_string(),\n            Self::BusinessLabel(bl) => bl.value.to_string(),\n            Self::SetupFutureUsage(sfu) => sfu.to_string(),\n            Self::CardRedirectType(crt) => crt.to_string(),\n            Self::RealTimePaymentType(rtpt) => rtpt.to_string(),\n            Self::OpenBankingType(ob) => ob.to_string(),\n            Self::MobilePaymentType(mpt) => mpt.to_string(),\n            Self::IssuerName(issuer_name) => issuer_name.value.clone(),\n            Self::IssuerCountry(issuer_country) => issuer_country.to_string(),\n            Self::CustomerDevicePlatform(customer_device_platform) => {\n                customer_device_platform.to_string()\n            }\n            Self::CustomerDeviceType(customer_device_type) => customer_device_type.to_string(),\n            Self::CustomerDeviceDisplaySize(customer_device_display_size) => {\n                customer_device_display_size.to_string()\n            }\n            Self::AcquirerCountry(acquirer_country) => acquirer_country.to_string(),\n            Self::AcquirerFraudRate(acquirer_fraud_rate) => acquirer_fraud_rate.number.to_string(),\n            Self::TransactionInitiator(transaction_initiator) => transaction_initiator.to_string(),\n            Self::NetworkTokenType(ntt) => ntt.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\n#[serde(tag = \"type\", content = \"details\", rename_all = \"snake_case\")]", "positive": "This method implements a polymorphic string conversion strategy for the Euclid graph data structure. It acts as a serialization layer, mapping specific enum variantssuch as PaymentMethod, CardBin, or Connectorto their human-readable string representations. This is critical for generating consistent, human-readable payloads for API responses and logging within the Hyperswitch payment orchestration platform.", "queries": ["how to convert euclid graph node to string", "rust euclid viz method implementation", "euclid graph serialization format", "hyperswitch euclid graph to string"], "label": "Euclid graph polymorphic serialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "viz", "unit_type": "function", "num_lines": 53}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_metadata\n    pub fn get_connector_metadata(&self) -> Option<masking::Secret<serde_json::Value>> {\n        match self {\n            Self::TransactionResponse {\n                connector_metadata, ..\n            }\n            | Self::PreProcessingResponse {\n                connector_metadata, ..\n            } => connector_metadata.clone().map(masking::Secret::new),\n            _ => None,\n        }\n    }", "positive": "This function retrieves the connector metadata payload associated with a transaction or preprocessing response object. It is designed to expose the specific configuration or response data returned by the external payment connector (e.g., Stripe, Razorpay) during the payment flow. The implementation uses pattern matching to safely extract the metadata field from variants like TransactionResponse and PreProcessingResponse, applying masking to ensure sensitive data is handled securely before returning it to the caller.", "queries": ["How do I access the metadata returned by the payment connector in the response object?", "rust hyperswitch get_connector_metadata function implementation", "How to retrieve connector metadata from TransactionResponse struct in hyperswitch", "Where is the connector metadata field defined in the router response types?"], "label": "connector metadata retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "get_connector_metadata", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "The `get_error_response` method in the `boku` connector implementation serves as a specialized error handling entry point. It accepts a raw HTTP `Response` and an optional `ConnectorEvent` builder, then delegates the construction of a standardized `ErrorResponse` to the internal `build_error_response` function. This pattern ensures consistent error formatting across the payment orchestration platform, allowing the router to parse and present errors uniformly regardless of the specific upstream provider's response format.", "queries": ["how to handle boku connector errors in hyperswitch", "boku connector error response format hyperswitch rust", "hyperswitch boku get_error_response implementation", "custom error handling for boku payment gateway hyperswitch"], "label": "boku connector error handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: create_updated_session_state_with_proxy\nfn create_updated_session_state_with_proxy(\n    state: SessionState,\n    proxy_override: &ProxyOverride,\n) -> SessionState {\n    let mut updated_state = state;\n\n    // Create updated configuration with proxy overrides\n    let mut updated_conf = (*updated_state.conf).clone();\n\n    // Update proxy URLs with overrides, falling back to existing values\n    if let Some(ref http_url) = proxy_override.http_url {\n        updated_conf.proxy.http_url = Some(http_url.clone());\n    }\n    if let Some(ref https_url) = proxy_override.https_url {\n        updated_conf.proxy.https_url = Some(https_url.clone());\n    }\n\n    updated_state.conf = std::sync::Arc::new(updated_conf);\n\n    updated_state\n}\n", "positive": "This function updates a payment session state by applying proxy configuration overrides. It clones the existing configuration, updates the HTTP and HTTPS proxy URLs with values from the provided ProxyOverride struct, and returns a new SessionState with the modified Arc-wrapped configuration. This mechanism allows dynamic routing adjustments for specific payment flows without altering the global default settings.", "queries": ["how to override proxy settings in session state", "rust function update session proxy configuration hyperswitch", "hyperswitch create_updated_session_state_with_proxy implementation", "proxy_override http_url https_url session state update"], "label": "Session Proxy Override", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "create_updated_session_state_with_proxy", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: extract_domain\n    pub fn extract_domain(&self) -> UserResult<&str> {\n        let (_username, domain) = self\n            .peek()\n            .split_once('@')\n            .ok_or(UserErrors::InternalServerError)?;\n\n        Ok(domain)\n    }\n}\n", "positive": "The `extract_domain` method retrieves the domain portion of a user identifier string. It splits the string at the '@' delimiter, discarding the username, and returns the domain. This utility is essential for validating user email formats and for routing user requests to the correct tenant or organization context within the payment orchestration platform.", "queries": ["how to get domain from email string in rust", "rust extract domain from email function", "hyperswitch extract domain from user email", "rust split string at @ and get domain"], "label": "extract domain from email", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "extract_domain", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: sift::SiftPaymentsResponse = res\n            .response\n            .parse_struct(\"Sift PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the raw HTTP response from the Sift payment connector, deserializing it into a typed `SiftPaymentsResponse` struct. It logs the response details for debugging and updates the connector event builder if one exists. Finally, it constructs a `ResponseRouterData` object to be passed to the router's data handling logic, ensuring the response is routed correctly based on the HTTP status code and parsed body.", "queries": ["How do I handle the response from the Sift connector in hyperswitch?", "rust hyperswitch sift connector handle_response implementation", "Parse SiftPaymentsResponse in hyperswitch router", "hyperswitch sift connector response deserialization"], "label": "Sift connector response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "The `get_error_response` function in the `helcim` connector implementation is a specialized error handling method designed to convert an HTTP response into a standardized `ErrorResponse` object. It serves as a critical integration point, ensuring that errors received from the Helcim payment gateway are normalized and mapped to the platform's internal error types (`errors::ConnectorError`). The function accepts the raw HTTP response and an optional `ConnectorEvent` builder, allowing for the creation of audit trails or event notifications when specific error conditions occur during the payment processing lifecycle.", "queries": ["how to handle helcim payment gateway errors in rust hyperswitch", "helcim connector error response mapping hyperswitch rust", "hyperswitch helcim get_error_response function implementation", "rust connector error handling helcim hyperswitch"], "label": "helcim error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: is_external_vault_enabled\n    pub fn is_external_vault_enabled(&self) -> bool {\n        match self {\n            Self::ExternalVaultEnabled(_) => true,\n            Self::Skip => false,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl\n    TryFrom<(\n        Option<common_enums::ExternalVaultEnabled>,\n        Option<ExternalVaultConnectorDetails>,\n    )> for ExternalVaultDetails\n{\n    type Error = error_stack::Report<ValidationError>;", "positive": "This method determines whether an external vault is active for a specific payment method configuration. It acts as a boolean gate within the `ExternalVaultDetails` enum, returning `true` for `ExternalVaultEnabled` variants and `false` for `Skip`. This logic is critical in the `hyperswitch_domain_models` crate to route payment flows correctly, ensuring that sensitive card data is handled by a third-party vault connector rather than the local system when configured.", "queries": ["how to check if external vault is enabled in hyperswitch", "rust enum is_external_vault_enabled implementation", "hyperswitch domain models external vault details logic", "is_external_vault_enabled function return type"], "label": "External vault boolean check", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__business_profile.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "symbol": "is_external_vault_enabled", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_updated_connector_token_details\n    pub fn get_updated_connector_token_details(\n        &self,\n        original_connector_mandate_request_reference_id: Option<String>,\n    ) -> Option<diesel_models::ConnectorTokenDetails> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.clone().map(|mandate_ref| {\n                let connector_mandate_id = mandate_ref.connector_mandate_id;\n                let connector_mandate_request_reference_id = mandate_ref\n                    .connector_mandate_request_reference_id\n                    .or(original_connector_mandate_request_reference_id);\n\n                diesel_models::ConnectorTokenDetails {\n                    connector_mandate_id,\n                    connector_token_request_reference_id: connector_mandate_request_reference_id,\n                }\n            })\n        } else {\n            None\n        }\n    }\n", "positive": "This function, defined within the Router Response Types module, extracts and constructs `ConnectorTokenDetails` specifically for transaction mandates. It checks if the current response context is a `TransactionResponse` and, if so, retrieves the `mandate_reference`. It prioritizes the `connector_mandate_request_reference_id` from the mandate object but falls back to the `original_connector_mandate_request_reference_id` passed as an argument, ensuring robust token generation for payment flows that require dynamic mandate linking.", "queries": ["how to get connector token details from transaction response", "rust hyperswitch get_updated_connector_token_details implementation", "hyperswitch router mandate reference token generation", "function to retrieve connector mandate request id from transaction"], "label": "Router mandate token details extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "get_updated_connector_token_details", "unit_type": "function", "num_lines": 24}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: authipay::AuthipayPaymentsResponse = res\n            .response\n            .parse_struct(\"Authipay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "The `handle_response` function processes the HTTP response from the Authipay payment gateway. It deserializes the raw response into a structured `AuthipayPaymentsResponse` object, handling potential deserialization failures. It then populates the optional `ConnectorEvent` builder with the response data for analytics. Finally, it constructs a `ResponseRouterData` struct, which is used to create a `RouterData` instance, effectively bridging the raw HTTP response and the application's internal state for the payment authorization flow.", "queries": ["how to handle authipay payments authorize response in rust hyperswitch", "authipay connector handle_response function implementation hyperswitch", "rust hyperswitch authipay payments authorize router data", "hyperswitch authipay response deserialization connector event"], "label": "Authipay Payments Authorize Response Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_inner_db_merchant_connector_account\n    pub fn get_inner_db_merchant_connector_account(&self) -> Option<&MerchantConnectorAccount> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account)\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]", "positive": "This function retrieves the inner `MerchantConnectorAccount` reference from a variant of the `MerchantConnector` enum. It is a utility method used to safely access the underlying account data when the current context is an account, returning `None` if the variant is `MerchantConnectorDetails`. This pattern is essential for type-safe navigation within the domain models, ensuring that downstream logic can confidently access account-specific fields like credentials or configuration without risking a runtime panic on a details variant.", "queries": ["how to access merchant connector account data in Rust", "get_inner_db_merchant_connector_account function implementation", "MerchantConnector enum variant access pattern hyperswitch", "rust safe unwrap merchant connector account reference"], "label": "MerchantConnector inner account accessor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "get_inner_db_merchant_connector_account", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsAuthorizeData\npub struct PaymentsAuthorizeData {\n    pub payment_method_data: PaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub ucs_authentication_data: Option<UcsAuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // Guest customer fields\n    pub guest_customer: Option<payments::GuestCustomer>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n\n    /// Merchant's identifier for the payment/invoice. This \n\n... [truncated 417 chars] ...\n\ntion<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n    pub locale: Option<String>,\n    pub payment_channel: Option<common_enums::PaymentChannel>,\n    pub enable_partial_authorization:\n        Option<common_types::primitive_wrappers::EnablePartialAuthorizationBool>,\n    pub enable_overcapture: Option<common_types::primitive_wrappers::EnableOvercaptureBool>,\n    pub is_stored_credential: Option<bool>,\n    pub mit_category: Option<common_enums::MitCategory>,\n    pub billing_descriptor: Option<common_types::payments::BillingDescriptor>,\n    pub tokenization: Option<common_enums::Tokenization>,\n    pub partner_merchant_identifier_details:\n        Option<common_types::payments::PartnerMerchantIdentifierDetails>,\n    pub rrn: Option<String>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "positive": "PaymentsAuthorizeData is a core domain model struct in the router request pipeline, representing the input payload for payment authorization operations. It aggregates complex payment metadata including payment method details, financial amounts (original, surcharge, tax, total), customer information (PII, guest customer), and authorization flags (confirm, capture_method, off_session). The struct supports advanced features like incremental authorization, overcapture, split payments, and mandate management. It also includes authentication data (UCS/3DS) and feature metadata for routing logic, serving as the primary data contract between the API layer and the authorization engine.", "queries": ["rust hyperswitch PaymentsAuthorizeData struct fields", "hyperswitch authorize request data model surcharge tax", "PaymentsAuthorizeData incremental authorization overcapture split payments", "hyperswitch router request types authorize data guest customer"], "label": "PaymentsAuthorizeData struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "PaymentsAuthorizeData", "unit_type": "function", "num_lines": 77}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: RouterData\npub struct RouterData<Flow, Request, Response> {\n    pub flow: PhantomData<Flow>,\n    pub merchant_id: id_type::MerchantId,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub connector_customer: Option<String>,\n    pub connector: String,\n    // TODO: This should be a PaymentId type.\n    // Make this change after all the connector dependency has been removed from connectors\n    pub payment_id: String,\n    pub attempt_id: String,\n    pub tenant_id: id_type::TenantId,\n    pub status: common_enums::enums::AttemptStatus,\n    pub payment_method: common_enums::enums::PaymentMethod,\n    pub payment_method_type: Option<common_enums::enums::PaymentMethodType>,\n    pub connector_auth_type: ConnectorAuthType,\n    pub description: Option<String>,\n    pub address: PaymentAddress,\n    pub auth_type: common_enums::enums::AuthenticationType,\n    pub connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    pub connector_wallets_details: Option<common_utils::pii::SecretSerdeValue>,\n    pub amount_captured: Option<i64>,\n    pub access_token: Option<AccessToken>,\n    pub session_token: Option<String>,\n    pub reference_id: Option<String>,\n    pub payment_method_token: Option<PaymentMethodToken>,\n    pub recurring_mandate_payment_data: Option<RecurringMandatePaymentData>,\n    pub preprocessing_id: Option<String>,\n    /// This is the balance amount for gift cards or voucher\n    pub payment_method_balance: Option<PaymentMethodBalance>,\n\n    ///for switching between two different versions of the same connector\n    pub connector_api_version: Option<String>,\n\n    /// Contains flow-specific data required to construct a request and send it to the connector.\n    pub request: Request,\n\n    /// Contains flow-specific data that the connector responds with.\n    pub response: Result<Response, ErrorResponse>,\n\n    /// Contains a reference ID that should be sent in the connector request\n    pub connector_request_reference_id: String,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout method data\n    pub payout_method_data: Option<api_models::payouts::PayoutMethodData>,\n\n    #[cfg(feature = \"payouts\")]\n    /// Contains payout's quote ID\n    pub quote_id: Option<String>,\n\n    pub test_mode: Option<bool>,\n    pub connector_http_status_code: Option<u16>,\n    pub external_latency: Option<u128>,\n    /// Contains apple pay flow type simplified or manual\n    pub apple_pay_flow: Option<payment_method_data::ApplePayFlow>,\n\n    \n\n... [truncated 627 chars] ...\n\nunt: Option<MinorUnit>,\n\n    pub integrity_check: Result<(), IntegrityCheckError>,\n\n    pub additional_merchant_data: Option<api_models::admin::AdditionalMerchantData>,\n\n    pub header_payload: Option<payments::HeaderPayload>,\n\n    pub connector_mandate_request_reference_id: Option<String>,\n\n    pub l2_l3_data: Option<Box<L2L3Data>>,\n\n    pub authentication_id: Option<id_type::AuthenticationId>,\n    /// Contains the type of sca exemption required for the transaction\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Contains stringified connector raw response body\n    pub raw_connector_response: Option<Secret<String>>,\n\n    /// Indicates whether the payment ID was provided by the merchant (true),\n    /// or generated internally by Hyperswitch (false)\n    pub is_payment_id_from_merchant: Option<bool>,\n\n    // Document details of the customer consisting of document number and type\n    pub customer_document_details: Option<CustomerDocumentDetails>,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]", "positive": "RouterData is a core domain model in the Hyperswitch payment orchestration platform, encapsulating the complete state of a payment transaction flow. It serves as the central data carrier for routing logic, holding critical identifiers like merchant_id, tenant_id, and payment_id, alongside flow-specific request and response payloads. The struct integrates connector details, authentication states, and metadata (e.g., connector_auth_type, connector_meta_data), enabling the router to orchestrate complex payment flows across multiple connectors while maintaining transaction integrity and context for debugging or reconciliation.", "queries": ["How to initialize RouterData for a payment flow in Rust?", "What fields are required in RouterData for connector integration?", "Explain the purpose of request and response fields in RouterData.", "How does RouterData handle payment method and authentication details?"], "label": "Payment flow state model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "RouterData", "unit_type": "function", "num_lines": 99}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        // For error scenarios connector respond with 200 http status code and error response object in response\n        // For http status code other than 200 they send empty response back\n        event_builder.map(|i: &mut ConnectorEvent| i.set_error_response_body(&serde_json::json!({\"error_response\": std::str::from_utf8(&res.response).unwrap_or(\"\")})));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: None,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object for the PowerTranz connector, handling the specific requirement that HTTP errors from the connector must be reported with a 200 OK status code. It accepts a raw Response struct and an optional ConnectorEvent builder. If the event builder exists, it populates the event body with a JSON object containing the error message extracted from the response bytes. The function then returns a populated ErrorResponse struct containing the original HTTP status code, empty strings for standard error fields, and None values for optional metadata fields like network advice or transaction IDs, ensuring a consistent error contract across the hyperswitch payment orchestration platform.", "queries": ["rust hyperswitch powertranz connector error response builder", "how to handle connector error status codes in hyperswitch powertranz", "hyperswitch powertranz build_error_response function implementation", "rust hyperswitch powertranz connector 200 status error handling"], "label": "PowerTranz error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 25}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for the Juspay 3DS server connector, specifically handling the authorization flow. It utilizes the PaymentsAuthorizeRouterData to map internal Hyperswitch fields to Juspay's API requirements. The method dynamically generates the target URL and headers via associated functions in PaymentsAuthorizeType, ensuring proper authentication and routing context before serializing the final request body.", "queries": ["how to build request for juspay 3ds authorization", "PaymentsAuthorizeRouterData build_request implementation", "hyperswitch juspay connector request builder", "juspaythreedsserver build_request function rust"], "label": "Juspay 3DS Authorization Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelWalletProvider\npub enum ArchipelWalletProvider {\n    ApplePay,\n    GooglePay,\n    SamsungPay,\n}\n\n#[derive(Debug, Default, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"UPPERCASE\")]", "positive": "This enum defines the supported digital wallet providers for the Archipel connector, specifically ApplePay, GooglePay, and SamsungPay. It is used within the `ArchipelWalletProvider` struct to map external provider IDs to internal enum variants, ensuring type safety and consistent handling of different wallet ecosystems during payment orchestration. The `#[serde(rename_all = \"UPPERCASE\")]` attribute ensures that incoming JSON payloads are deserialized correctly regardless of casing, facilitating robust integration with the Archipel API.", "queries": ["How do I configure ArchipelWalletProvider for Apple Pay in hyperswitch?", "Rust enum ArchipelWalletProvider definition for Google Pay and Samsung Pay", "hyperswitch Archipel connector wallet provider configuration options", "ArchipelWalletProvider serde rename_all uppercase attribute usage"], "label": "Archipel wallet provider enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "ArchipelWalletProvider", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsCancelRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsCancelRouterData, errors::ConnectorError> {\n        let response: worldline::PaymentResponse = res\n            .response\n            .parse_struct(\"Worldline PaymentResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "positive": "This function processes the HTTP response from the Worldline payment gateway after a cancellation request. It deserializes the raw response body into a Worldline::PaymentResponse struct and logs the details for observability. It updates the optional ConnectorEvent builder with the response payload and attempts to construct a RouterData object containing the parsed response, original request data, and HTTP status code, handling potential deserialization or context conversion failures.", "queries": ["how to handle worldline payment cancellation response in rust", "worldline connector handle_response function implementation hyperswitch", "parse worldline payment response struct in hyperswitch", "PaymentsCancelRouterData worldline connector error handling"], "label": "Worldline cancellation response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<\n        RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        errors::ConnectorError,\n    > {\n        let response: finix::FinixIdentityResponse = res\n            .response\n            .parse_struct(\"Finix IdentityResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function handles the response from a Finix API call for creating a connector customer. It deserializes the raw HTTP response into a FinixIdentityResponse struct, logs the details for observability, and constructs a RouterData object containing the parsed response, original input data, and HTTP status code for downstream processing.", "queries": ["How to handle Finix API response in Rust hyperswitch", "finix connector customer creation response parsing hyperswitch", "Rust hyperswitch handle_response function implementation", "FinixIdentityResponse deserialization hyperswitch connector"], "label": "Finix connector customer response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__finix.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "positive": "The `get_url` method within the Sift connector implementation serves as a placeholder for URL generation logic required by the Sift payment orchestration platform. In the context of Hyperswitch's architecture, this function is part of the `Connectors` trait implementation for the Sift integration. It is designed to accept router authorization data and a collection of active connectors, returning a URL string. Currently, this method is not implemented and returns a `NotImplemented` error, indicating that the specific Sift endpoint configuration or redirection logic has not yet been defined in this version of the codebase.", "queries": ["rust hyperswitch sift connector get_url method implementation", "hyperswitch sift connector get_url function returns NotImplemented", "how to implement get_url in hyperswitch sift connector rust", "hyperswitch sift connector get_url trait implementation"], "label": "Sift connector get_url placeholder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_masked_keys\n    pub fn get_masked_keys(&self) -> Self {\n        match self {\n            Self::TemporaryAuth => Self::TemporaryAuth,\n            Self::NoKey => Self::NoKey,\n            Self::HeaderKey { api_key } => Self::HeaderKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n            },\n            Self::BodyKey { api_key, key1 } => Self::BodyKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n            },\n            Self::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Self::SignatureKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n            },\n            Self::MultiAuthKey {\n                api_key,\n                key1,\n                api_secret,\n                key2,\n            } => Self::MultiAuthKey {\n                api_key: self.mask_key(api_key.clone().expose()),\n                key1: self.mask_key(key1.clone().expose()),\n                api_secret: self.mask_key(api_secret.clone().expose()),\n                key2: self.mask_key(key2.clone().expose()),\n            },\n            Self::CurrencyAuthKey { auth_key_map } => Self::CurrencyAuthKey {\n                auth_key_map: auth_key_map.clone(),\n            },\n            Self::CertificateAuth {\n                certificate,\n                private_key,\n            } => Self::CertificateAuth {\n                certificate: self.mask_key(certificate.clone().expose()),\n                private_key: self.mask_key(private_key.clone().expose()),\n            },\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]", "positive": "The `get_masked_keys` function is a utility method within the `RouterData` enum in the `hyperswitch_domain_models` crate. Its primary purpose is to create a new instance of the enum where all sensitive authentication keys (api_key, key1, api_secret, key2, certificate, private_key) are masked. This is crucial for logging and debugging, ensuring that sensitive credentials are not exposed in plain text. The function handles all variants of the enum, including `TemporaryAuth`, `NoKey`, `HeaderKey`, `BodyKey`, `SignatureKey`, `MultiAuthKey`, `CurrencyAuthKey`, and `CertificateAuth`, applying the `mask_key` method to the relevant fields in each case. This function is likely called before logging router data or before sending it to external monitoring systems to maintain security.", "queries": ["how to mask api keys in hyperswitch router data", "hyperswitch domain models get_masked_keys function implementation", "rust enum method to hide sensitive credentials in hyperswitch", "hyperswitch router data logging security mask keys"], "label": "Router Data Key Masking Utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "get_masked_keys", "unit_type": "function", "num_lines": 46}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = thunes::ThunesAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "positive": "This function generates the HTTP Authorization header for Thunes payment connector requests. It accepts a `ConnectorAuthType` enum, converts it to the specific `ThunesAuthType`, and returns a vector of header-value tuples. The implementation ensures the API key is masked for security before exposure, handling the authentication handshake required for outbound payment processing within the `hyperswitch_connectors` crate.", "queries": ["rust hyperswitch thunes connector get_auth_header implementation", "how to configure authorization header for thunes payment gateway in hyperswitch", "hyperswitch thunes auth_type to ThunesAuthType conversion", "rust function get_auth_header returns masked api key vector"], "label": "Thunes auth header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: MandateReference\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "positive": "The MandateReference struct in hyperswitch_domain_models serves as a domain model for storing and validating mandate-specific data returned by payment connectors. It encapsulates the `connector_mandate_id` (the unique identifier from the provider), the `payment_method_id` linking the mandate to a specific payment method, and `mandate_metadata` (PII data). It also tracks the `connector_mandate_request_reference_id` to map the mandate response back to the original request. This struct is used within the router's response types to pass mandate details from the connector layer to the API layer, ensuring data integrity and traceability in the payment orchestration flow.", "queries": ["Rust struct definition for MandateReference in hyperswitch", "hyperswitch domain models MandateReference connector_mandate_id", "how to handle MandateReference in payment orchestration router", "MandateReference struct fields payment_method_id mandate_metadata"], "label": "MandateReference domain model struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "MandateReference", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response payload from the Zift payment gateway connector. It deserializes the raw bytes into a `ZiftAuthPaymentsResponse` struct using `serde_urlencoded`. The function logs the response details for debugging and updates the `ConnectorEvent` builder with the parsed data. Finally, it constructs a `RouterData` object containing the response, the original setup mandate context, and the HTTP status code, returning it as a successful result.", "queries": ["rust hyperswitch zift connector handle_response function implementation", "how does hyperswitch zift connector handle response deserialization", "hyperswitch zift setup mandate router data response handling", "rust connector error handling in hyperswitch zift handle_response"], "label": "Zift connector response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 18}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_and_mandate\n    async fn update_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        provider: &domain::Provider,\n        payment_data: &PaymentData<F>,\n        router_data: &types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        feature_set: &core_utils::FeatureConfig,\n    ) -> RouterResult<()>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        if !feature_set.is_payment_method_modular_allowed {\n            update_pm_connector_mandate_details(state, provider, payment_data, router_data).await\n        } else {\n            Ok(())\n        }\n    }\n\n    #[cfg(feature = \"v1\")]", "positive": "This function, `update_pm_and_mandate`, manages the lifecycle of payment methods and mandates within the Hyperswitch payment orchestration router. It acts as a conditional gatekeeper that checks the `feature_set.is_payment_method_modular_allowed` configuration flag. If the feature is disabled, it delegates to `update_pm_connector_mandate_details` to synchronize provider-specific mandates. If enabled, it short-circuits and returns `Ok(())`, effectively bypassing the mandate update logic to support modular payment method architectures. It operates within the `PaymentOperations` trait context, handling `SessionState` and `RouterData` structures.", "queries": ["hyperswitch rust update_pm_and_mandate function feature flag", "how to disable payment method mandate updates in hyperswitch router", "hyperswitch feature_set.is_payment_method_modular_allowed conditional logic", "rust payment orchestration router update_pm_connector_mandate_details"], "label": "Payment method mandate conditional update", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__payments__operations__payment_response.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "symbol": "update_pm_and_mandate", "unit_type": "function", "num_lines": 23}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_and_disabled_list\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(all(feature = \"olap\", feature = \"v2\"))]", "positive": "This function retrieves a MerchantConnectorAccount entity from the storage layer based on a specific merchant ID and a boolean flag indicating whether to include disabled accounts. It acts as a critical lookup mechanism within the storage_impl crate, bridging the router's request handling with the underlying PostgreSQL database via the router_store abstraction. The function accepts a MerchantKeyStore reference to handle cryptographic keys and returns a CustomResult, ensuring robust error handling for scenarios where the account configuration might be missing or inaccessible.", "queries": ["rust hyperswitch find_merchant_connector_account_by_merchant_id_and_disabled_list", "how to query merchant connector accounts by id in hyperswitch rust", "hyperswitch storage_impl merchant connector account lookup function", "rust hyperswitch router_store find_merchant_connector_account_by_merchant_id_and_disabled_list"], "label": "merchant connector account lookup", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "find_merchant_connector_account_by_merchant_id_and_disabled_list", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: error_response\n        fn error_response(&self) -> actix_web::HttpResponse<actix_web::body::BoxBody> {\n            use actix_web::http::header;\n\n            actix_web::HttpResponseBuilder::new(self.status_code())\n                .insert_header((header::CONTENT_TYPE, mime::APPLICATION_JSON))\n                .body(self.to_string())\n        }\n    }\n", "positive": "This function generates a standardized HTTP error response within the router crate. It constructs an `HttpResponse` using the current status code, sets the Content-Type header to `application/json`, and serializes the error details into the response body. It is utilized by the `Error` struct to ensure consistent API error formatting for clients.", "queries": ["how to create a json error response in actix web", "actix web error_response function implementation", "hyperswitch router error handling actix web", "actix_web HttpResponseBuilder json error body"], "label": "actix web error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Aggregate\npub enum Aggregate<R> {\n    Count {\n        field: Option<R>,\n        alias: Option<&'static str>,\n    },\n    Sum {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Min {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Max {\n        field: R,\n        alias: Option<&'static str>,\n    },\n    Percentile {\n        field: R,\n        alias: Option<&'static str>,\n        percentile: Option<&'static u8>,\n    },\n    DistinctCount {\n        field: R,\n        alias: Option<&'static str>,\n    },\n}\n\n// Window functions in query\n// ---\n// Description -\n// field: to_sql type value used as expr in aggregation\n// partition_by: partition by fields in window\n// order_by: order by fields and order (Ascending / Descending) in window\n// alias: alias of window expr in query\n// ---\n// Usage -\n// Window::Sum {\n//     field: \"count\",\n//     partition_by: Some(query_builder.transform_to_sql_values(&dimensions).switch()?),\n//     order_by: Some((\"value\", Descending)),\n//     alias: Some(\"total\"),\n// }\n#[derive(Debug)]", "positive": "The `Aggregate` enum in `crates/analytics/src/query.rs` defines a polymorphic structure for SQL aggregation operations within the Hyperswitch payment orchestration platform. It supports standard aggregations like Count, Sum, Min, and Max, alongside advanced metrics such as Percentile and DistinctCount. This type is used to construct analytical queries, likely for generating real-time dashboards or debugging transaction flows, by mapping Rust enums to specific SQL aggregate functions.", "queries": ["how to use Aggregate enum for sum in rust hyperswitch", "hyperswitch analytics query sum aggregate example", "rust Aggregate enum Percentile distinctcount", "hyperswitch analytics crate query.rs Aggregate"], "label": "Analytics Aggregate Enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "Aggregate", "unit_type": "function", "num_lines": 44}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = helcim::HelcimVerifyRequest::try_from(req)?;\n\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "positive": "The `get_request_body` function in the `helcim.rs` connector is responsible for transforming the internal `SetupMandateRouterData` into the specific `HelcimVerifyRequest` format required by the Helcim payment gateway. It acts as a serialization layer, ensuring the router's data structure is correctly mapped to the external API's expectations. This function is a critical step in the payment mandate setup flow, handling the data marshaling before the request is dispatched to the Helcim service via the `Connectors` infrastructure.", "queries": ["how to implement helcim verify request in rust hyperswitch", "helcim connector setup mandate router data transformation", "hyperswitch helcim verify request body structure", "rust function get_request_body helcim hyperswitch"], "label": "Helcim Verify Request Mapper", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = wellsfargo::WellsfargoZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function prepares the request payload for Wells Fargo's Zero Mandate API integration. It takes a generic router data structure, validates and converts it into a specific `WellsfargoZeroMandateRequest` struct, and wraps it in a `RequestContent::Json` container. This ensures the correct JSON format is sent to the Wells Fargo connector endpoint.", "queries": ["how to format request body for Wells Fargo zero mandate API", "WellsfargoZeroMandateRequest struct definition hyperswitch", "get_request_body function implementation Rust hyperswitch", "hyperswitch wellsfargo connector request payload"], "label": "Wells Fargo Zero Mandate Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_presence\n    fn check_presence(\n        &self,\n        value: &cgraph::NodeValue<dir::DirValue>,\n        strength: cgraph::Strength,\n    ) -> bool {\n        match value {\n            cgraph::NodeValue::Key(k) => {\n                self.keywise_values.contains_key(k) || matches!(strength, cgraph::Strength::Weak)\n            }\n\n            cgraph::NodeValue::Value(val) => {\n                let key = val.get_key();\n                let value_set = if let Some(set) = self.keywise_values.get(&key) {\n                    set\n                } else {\n                    return matches!(strength, cgraph::Strength::Weak);\n                };\n\n                match key.kind.get_type() {\n                    DataType::EnumVariant | DataType::StrValue | DataType::MetadataValue => {\n                        value_set.contains(val)\n                    }\n                    DataType::Number => val.get_num_value().is_some_and(|num_val| {\n                        value_set.iter().any(|ctx_val| {\n                            ctx_val\n                                .get_num_value()\n                                .is_some_and(|ctx_num_val| num_val.fits(&ctx_num_val))\n                        })\n                    }),\n                }\n            }\n        }\n    }\n", "positive": "This function, defined within the euclid crate's dssa graph module, determines whether a specific node value exists within the graph's context. It handles two primary value types: 'Key' values, which are checked against a direct lookup map, and 'Value' objects, which are validated against their associated key's type. For numeric values, it performs a range check using the 'fits' method to determine if the context value encompasses the target value. The function is critical for the Data Structure and Algorithm Analysis (DSA) graph engine, enabling the system to verify node existence and evaluate value strength during the construction and traversal of dependency graphs.", "queries": ["how to check if a node value exists in the euclid graph context", "rust euclid crate check_presence function implementation", "how does check_presence handle numeric value comparisons in the graph", "euclid dssa graph check node value strength and existence"], "label": "euclid graph node existence check", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "check_presence", "unit_type": "function", "num_lines": 34}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayFinalizeResponse = res\n            .response\n            .parse_struct(\"Amazonpay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "The `handle_response` function in the Amazon Pay connector processes the HTTP response from the Amazon Pay PaymentsAuthorize API. It deserializes the raw response into a strongly-typed `AmazonpayFinalizeResponse` struct, logs the details for debugging, and maps the data into a `ResponseRouterData` object. This object is then converted into a `RouterData` to be used by the router for further processing, such as updating the payment status or triggering downstream events. It is a critical integration point ensuring the router correctly interprets Amazon Pay's authorization outcome.", "queries": ["rust hyperswitch amazonpay connector handle_response function implementation", "how does hyperswitch handle amazonpay authorization response", "hyperswitch amazonpay connector deserialization logic", "rust amazonpay finalizer response parsing hyperswitch"], "label": "AmazonPay Response Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_next_action_api\n    pub fn get_next_action_api(\n        &self,\n        base_url: String,\n        authentication_id: String,\n    ) -> CustomResult<NextAction, errors::ParsingError> {\n        let url = format!(\"{base_url}/authentication/{authentication_id}/authenticate\");\n        Ok(NextAction {\n            url: url::Url::parse(&url).change_context(errors::ParsingError::UrlParsingError)?,\n            http_method: common_utils::request::Method::Post,\n        })\n    }\n", "positive": "This function constructs a URL for the Hyperswitch authentication API, specifically targeting the 'authenticate' endpoint for a given authentication ID. It takes a base URL and an authentication ID as inputs, formats the URL string, and returns a `NextAction` struct containing the parsed URL and the HTTP POST method. This is a critical utility for orchestrating the authentication flow within the payment orchestration platform, enabling the retrieval of the next step in the authentication process.", "queries": ["hyperswitch rust get_next_action_api implementation", "how to construct authentication url in hyperswitch rust", "hyperswitch authentication_id authenticate endpoint rust", "rust hyperswitch NextAction struct get_next_action_api"], "label": "Rust authentication URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__api_models__src__authentication.rs", "path": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "symbol": "get_next_action_api", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: generate_authorization_token\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n", "positive": "This function generates a GCS v1HMAC authorization token for the Worldline connector in the Hyperswitch payment orchestration platform. It constructs a signature string from the HTTP method, content type, date, and endpoint, then signs it using the provided API secret with HMAC-SHA256. The resulting signature is base64-encoded and combined with the API key to create a valid authorization header for Worldline API requests. This is a critical utility for authenticating outgoing requests to the Worldline payment gateway within the connector's integration layer.", "queries": ["how to generate authorization token for worldline connector rust hyperswitch", "hyperswitch worldline connector hmac signature generation", "rust function generate_authorization_token worldline hyperswitch", "worldline api authentication hyperswitch rust implementation"], "label": "Worldline auth token generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "generate_authorization_token", "unit_type": "function", "num_lines": 26}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Powertranz\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Powertranz\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the core integration contract for the Powertranz payment connector within the Hyperswitch payment orchestration platform. It establishes the standard interface for tokenizing payment methods (`PaymentMethodTokenizationData`) and processing payment transactions (`PaymentsResponseData`). The implementation handles the specific HTTP communication requirements of the Powertranz gateway, ensuring that the router can dispatch payment flows to this specific connector while abstracting the underlying network logic. It serves as the primary entry point for all Powertranz-specific payment operations.", "queries": ["how to implement Powertranz payment tokenization in Rust", "Powertranz connector integration trait implementation hyperswitch", "hyperswitch Powertranz payments response data handling", "rust connector integration Powertranz payment method token"], "label": "Powertranz connector integration trait", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ApplicationSelectionIndicator\npub enum ApplicationSelectionIndicator {\n    #[default]\n    ByDefault,\n    CustomerChoice,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This enum defines the strategy for selecting the application context during payment processing within the Hyperswitch payment orchestration platform. It is primarily used in the `archipel` connector transformer to determine whether to route a transaction based on the default system configuration or the specific customer's pre-defined preferences. The `ByDefault` variant applies the standard routing logic, while `CustomerChoice` enforces the customer's specific application selection rules, ensuring compliance with tenant-specific business requirements.", "queries": ["How do I configure archipel connector to use customer specific application selection?", "Rust enum ApplicationSelectionIndicator usage in archipel connector", "Hyperswitch archipel transformer customer choice routing logic", "ApplicationSelectionIndicator ByDefault vs CustomerChoice behavior"], "label": "Archipel connector application selection strategy", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "ApplicationSelectionIndicator", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: UserEmail\npub struct UserEmail(pii::Email);\n\nstatic BLOCKED_EMAIL: LazyLock<HashSet<String>> = LazyLock::new(|| {\n    let blocked_emails_content = include_str!(\"../../utils/user/blocker_emails.txt\");\n    let blocked_emails: HashSet<String> = blocked_emails_content\n        .lines()\n        .map(|s| s.trim().to_owned())\n        .collect();\n    blocked_emails\n});\n", "positive": "The `UserEmail` struct is a wrapper around a `pii::Email` type, designed to enforce strict privacy protection for email addresses within the Hyperswitch payment orchestration platform. It leverages the `LazyLock` pattern to efficiently load and cache a static `HashSet` of blocked email addresses from a text file (`blocker_emails.txt`). This mechanism is used to validate and filter user emails, ensuring that specific email domains or addresses are rejected during the user onboarding or payment initiation process. The struct is a core component of the domain model, integrating directly with the router's type system to handle sensitive PII data securely.", "queries": ["How to implement email validation and blocking in Rust for payment systems?", "Hyperswitch UserEmail struct definition and blocked email list implementation", "Rust LazyLock HashSet for blocked emails in payment orchestration", "How does Hyperswitch handle PII and blocked email addresses in the router?"], "label": "Rust PII Email Validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "UserEmail", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_apply_mask_fn\n    fn test_apply_mask_fn() {\n        let value = \"12345678901\".to_string();\n\n        // Generic masked tests\n        assert_eq!(apply_mask(&value, 2, 2), \"12*******01\".to_string());\n        assert_eq!(apply_mask(&value, 3, 2), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 3, 3), \"123*****901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 3), \"1234***8901\".to_string());\n        assert_eq!(apply_mask(&value, 4, 4), \"*******8901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 4), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 5, 5), \"******78901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 5), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 6, 6), \"*****678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 6), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 7, 7), \"****5678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 7), \"***45678901\".to_string());\n        assert_eq!(apply_mask(&value, 8, 8), \"***45678901\".to_string());\n    }\n}", "positive": "This unit tests the `apply_mask` utility function within the `common_utils` crate, which is a foundational library for data sanitization across the Hyperswitch payment orchestration platform. The test suite validates the function's ability to mask sensitive identifiers (like PANs or IDs) by preserving a configurable prefix and suffix while obscuring the middle characters. It ensures the function handles edge cases where the prefix or suffix length equals the total string length, correctly returning the original string or a fully masked version. This utility is critical for logging, debugging, and API response masking to prevent accidental exposure of sensitive payment data.", "queries": ["how to mask sensitive card numbers in hyperswitch", "rust apply_mask function test cases", "hyperswitch common_utils data sanitization", "test_apply_mask_fn implementation details"], "label": "Data masking utility tests", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__common_utils__src__new_type.rs", "path": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "symbol": "test_apply_mask_fn", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PayoutFulfillType::get_url(self, req, connectors)?)\n            .attach_default_headers()\n            .headers(PayoutFulfillType::get_headers(self, req, connectors)?)\n            .set_body(PayoutFulfillType::get_request_body(self, req, connectors)?)\n            .build();\n        Ok(Some(request))\n    }\n\n    #[instrument(skip_all)]", "positive": "This function constructs the HTTP POST request payload for a Payone payout fulfillment operation. It leverages the `PayoutFulfillType` trait to dynamically assemble the target URL and headers based on the provided `PayoutsRouterData` and `Connectors` context. The method ensures standard HTTP verb usage and attaches the necessary request body before finalizing the request object, serving as a critical abstraction layer for the Payone connector's payout flow.", "queries": ["rust hyperswitch payone connector build_request function implementation", "how does hyperswitch payone connector construct payout request", "hyperswitch payone connector build_request method source code", "rust hyperswitch payone payout request builder implementation"], "label": "Payone Payout Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: PaymentMethodData\npub enum PaymentMethodData {\n    Card(Card),\n    CardDetailsForNetworkTransactionId(CardDetailsForNetworkTransactionId),\n    CardWithLimitedDetails(CardWithLimitedDetails),\n    NetworkTokenDetailsForNetworkTransactionId(NetworkTokenDetailsForNetworkTransactionId),\n    DecryptedWalletTokenDetailsForNetworkTransactionId(\n        DecryptedWalletTokenDetailsForNetworkTransactionId,\n    ),\n    CardRedirect(CardRedirectData),\n    Wallet(WalletData),\n    PayLater(PayLaterData),\n    BankRedirect(BankRedirectData),\n    BankDebit(BankDebitData),\n    BankTransfer(Box<BankTransferData>),\n    Crypto(CryptoData),\n    MandatePayment,\n    Reward,\n    RealTimePayment(Box<RealTimePaymentData>),\n    Upi(UpiData),\n    Voucher(VoucherData),\n    GiftCard(Box<GiftCardData>),\n    CardToken(CardToken),\n    OpenBanking(OpenBankingData),\n    NetworkToken(NetworkTokenData),\n    MobilePayment(MobilePaymentData),\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]", "positive": "The PaymentMethodData enum defines the polymorphic structure for all supported payment methods within the Hyperswitch domain models. It serves as the core data container for payment initiation, refund processing, and dispute management, distinguishing between raw card details, network tokens, wallet integrations, and real-time payment schemes like UPI. This structure is utilized by the router to deserialize incoming API payloads and by the storage layer to persist transaction metadata, ensuring type-safe handling of diverse payment flows across the orchestration platform.", "queries": ["Rust enum for payment method data types in hyperswitch", "how to handle different payment methods like card and wallet in hyperswitch domain models", "hyperswitch payment method data structure definition", "rust enum variants for payment methods in hyperswitch domain models"], "label": "PaymentMethodData enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "PaymentMethodData", "unit_type": "function", "num_lines": 28}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: responses::NordeaErrorResponse = res\n            .response\n            .parse_struct(\"NordeaErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.code.clone())\n                .unwrap_or(NO_ERROR_CODE.to_string()),\n            message: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.description.clone())\n                .unwrap_or(NO_ERROR_MESSAGE.to_string()),\n            reason: get_error_data(response.error.as_ref())\n                .and_then(|failure| failure.failure_type.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a raw HTTP Response received from the Nordea connector. It parses the response body into a NordeaErrorResponse struct, logs the details for observability, and maps the raw error data (code, description, failure_type) to the connector's internal error schema. It also supports optional event building for webhook processing.", "queries": ["how to handle nordea error response parsing", "nordea connector error response format", "build_error_response function implementation", "map nordea error to hyperswitch error"], "label": "Nordea error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 34}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let auth = helcim::HelcimAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_TOKEN.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "positive": "This function generates the HTTP Authorization header for Helcim connector requests. It takes a generic ConnectorAuthType and converts it into a specific HelcimAuthType, then extracts the API key to construct a masked header tuple. It is used within the Helcim connector implementation to ensure secure communication with the Helcim payment gateway.", "queries": ["rust hyperswitch helcim connector get_auth_header implementation", "how to configure api token header for helcim in hyperswitch", "hyperswitch helcim authentication header generation rust", "helcim connector hyperswitch get_auth_header function source code"], "label": "Helcim Auth Header Generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorAuthenticationRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorAuthenticationRouterData, ConnectorError> {\n        let response: gpayments_types::GpaymentsAuthenticationSuccessResponse = res\n            .response\n            .parse_struct(\"gpayments GpaymentsAuthenticationResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the GPayments connector during authentication flows. It deserializes the raw response into a typed struct, logs the payload for debugging, and constructs a `RouterData` object containing the parsed success details and original request context. It is a critical deserialization and validation step ensuring the downstream router receives structured authentication data.", "queries": ["how to handle gpayments authentication response in hyperswitch", "rust hyperswitch gpayments connector handle_response implementation", "gpayments authentication success response parsing hyperswitch", "hyperswitch gpayments router data deserialization"], "label": "gpayments auth response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentCertainty\npub enum ArchipelPaymentCertainty {\n    #[default]\n    Final,\n    Estimated,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This enum defines the three possible states of payment certainty for the Archipel connector, mapping to the `ArchipelPaymentCertainty` field in the connector's request/response models. It is used to distinguish between a finalized payment transaction and an estimated or provisional state, allowing the orchestration layer to handle partial or pre-authorization scenarios correctly within the payment flow.", "queries": ["ArchipelPaymentCertainty enum variants in hyperswitch", "how to handle estimated payments in Archipel connector", "ArchipelPaymentCertainty Rust enum definition", "payment certainty states Archipel hyperswitch connector"], "label": "Archipel payment certainty enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "ArchipelPaymentCertainty", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for Airwallex customer operations. It leverages the `ConnectorCustomerType` trait to dynamically generate the target URL and headers based on the provided `ConnectorCustomerRouterData` and `Connectors` context. The method ensures standard HTTP verb (POST) and body attachment, abstracting the specific HTTP client configuration for Airwallex integration within the Hyperswitch payment orchestration platform.", "queries": ["how to build airwallex customer request in hyperswitch rust", "airwallex connector customer router data request builder", "rust function to construct airwallex post request headers", "hyperswitch airwallex connector build_request implementation"], "label": "Airwallex Customer Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 18}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_dir_values\n    pub fn from_dir_values(vals: impl IntoIterator<Item = dir::DirValue>) -> Self {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "positive": "This function constructs a `DirMap` by aggregating `DirValue` items from an iterator into a `FxHashMap` keyed by `DirKey`. It ensures uniqueness within each key's set of values, effectively grouping directory metadata (such as file paths, permissions, or attributes) for efficient lookup and storage within the Hyperswitch configuration or routing context.", "queries": ["rust how to group directory values by key in hashmap", "hyperswitch DirMap from_dir_values implementation", "rust FxHashMap group items by key example", "how to aggregate directory values into a map in rust"], "label": "DirMap builder grouping", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "from_dir_values", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function serves as the standard error handling interface for the Tokenex connector within the Hyperswitch payment orchestration platform. It accepts an HTTP Response object and an optional mutable reference to a ConnectorEvent builder. Its primary behavior is to delegate error construction to the internal `build_error_response` method, ensuring consistent error formatting and state management. This method is crucial for transforming raw HTTP failures into standardized `ErrorResponse` types or `ConnectorError` variants, facilitating downstream processing and logging in the router's payment flow.", "queries": ["how to handle tokenex connector errors in hyperswitch", "tokenex connector error response format rust hyperswitch", "hyperswitch tokenex get_error_response implementation", "custom error handling for hyperswitch tokenex integration"], "label": "Tokenex connector error handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "positive": "This function defines the interface for extracting the event type from an incoming webhook request within the GPayments connector. It serves as a placeholder implementation, returning a 'WebhooksNotImplemented' error, indicating that the specific GPayments connector has not yet implemented the logic to parse and validate the incoming webhook payload's event type. This method is part of the broader webhook handling infrastructure in Hyperswitch, which manages incoming events from payment gateways and dispatches them to the appropriate internal handlers.", "queries": ["How to implement get_webhook_event_type in GPayments connector", "GPayments webhook event type extraction Rust implementation", "hyperswitch get_webhook_event_type function signature", "GPayments connector webhook handling error WebhooksNotImplemented"], "label": "GPayments webhook event type extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "get_webhook_event_type", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_payment_id_merchant_id\n    async fn find_refund_by_payment_id_merchant_id(\n        &self,\n        payment_id: &common_utils::id_type::PaymentId,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "positive": "This function retrieves a list of refunds associated with a specific payment and merchant, filtering by the provided storage scheme. It is a core data access method used within the router's refund handling logic to fetch historical refund records from the PostgreSQL database, ensuring data isolation based on tenant storage configurations.", "queries": ["rust hyperswitch find_refund_by_payment_id_merchant_id", "hyperswitch router storage refund query function signature", "how to get refunds by payment id in hyperswitch rust", "hyperswitch find_refund_by_payment_id_merchant_id storage_scheme"], "label": "Router Refund Data Access", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "find_refund_by_payment_id_merchant_id", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: Pay3dsRequest\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "positive": "The `Pay3dsRequest` struct within the PayMe connector transformer module defines the data model for 3D Secure (3DS) authentication requests. It encapsulates sensitive buyer credentials (name, email, key) and transaction identifiers (sale ID, JWT metadata) required to initiate the 3DS flow. This struct is likely deserialized from incoming webhook payloads or API requests to prepare the necessary parameters for the PayMe gateway's 3DS verification endpoint, ensuring secure authentication of the transaction.", "queries": ["PayMe 3DS request struct fields buyer_name buyer_email", "hyperswitch payme connector 3ds request structure", "PayMe payment gateway 3D Secure request payload rust", "hyperswitch payme transformer 3ds data model"], "label": "PayMe 3DS Request Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "symbol": "Pay3dsRequest", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: to_archipel_billing_address\n    fn to_archipel_billing_address(&self) -> Option<ArchipelBillingAddress> {\n        let address = self.get_combined_address_line().ok();\n        let postal_code = self.get_optional_zip();\n\n        match (address, postal_code) {\n            (None, None) => None,\n            (addr, zip) => Some(ArchipelBillingAddress {\n                address: addr,\n                postal_code: zip,\n            }),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]", "positive": "The `to_archipel_billing_address` function in the `archipel` connector transforms a Hyperswitch internal address structure into the Archipel billing address format. It retrieves the combined address line and optional ZIP code, returning a `Some(ArchipelBillingAddress)` if either is present, or `None` if both are missing. This function is crucial for mapping internal payment data to the Archipel API's specific address schema during the checkout process.", "queries": ["how to convert Hyperswitch address to Archipel billing address format", "archipel connector billing address transformation rust", "hyperswitch archipel billing address mapping function", "rust function to_archipel_billing_address implementation"], "label": "Archipel billing address transformation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "to_archipel_billing_address", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function is a specialized error handler within the Barclaycard connector implementation. It accepts a raw HTTP response and an optional event builder to construct a standardized ErrorResponse. It serves as a critical integration point for error handling, ensuring that connector-specific failures are transformed into a unified domain model, allowing the router to process and report payment failures consistently across the hyperswitch platform.", "queries": ["how to handle barclaycard connector errors in rust", "barclaycard hyperswitch error response builder", "rust connector error handling hyperswitch", "hyperswitch barclaycard get_error_response implementation"], "label": "Barclaycard error handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.common_get_content_type().to_string();\n        let http_method = Method::Post;\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n\n        let request_body = self.get_request_body(req, connectors)?;\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        let sha256_digest = self.generate_digest_from_request(&request_body);\n\n        // Add Digest header\n        required_headers.push((\n            \"Digest\".to_string(),\n            sha256_digest.to_string().into_masked(),\n        ));\n\n        let signature = self.generate_signature(\n            &auth,\n            SignatureParams {\n                content_type: &content_type,\n                host: &nordea_host,\n                path,\n                payload_digest: Some(&sha256_digest),\n                date: &nordea_origin_date,\n                http_method,\n            },\n        )?;\n\n        required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n\n        let request = Some(\n            RequestBuilder::new()\n                .method(http_method)\n                .attach_default_headers()\n                .headers(required_headers)\n                .url(&AuthenticationTokenType::get_url(self, req, connectors)?)\n                .set_body(request_body)\n                .build(),\n        );\n        Ok(request)\n    }\n", "positive": "The `build_request` function constructs a secure HTTP request for the Nordea payment connector. It authenticates using client credentials, generates a SHA-256 digest of the request body, and creates a cryptographic signature based on the HTTP method, path, host, and date. This ensures data integrity and secure communication with the Nordea API endpoint.", "queries": ["nordea connector build_request rust implementation", "how to generate signature for nordea api request", "nordea authentication header generation rust", "nordea payment gateway request builder rust"], "label": "Nordea connector request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 83}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                \"application/xml\".to_string().into(),\n            ),\n            (\n                headers::SOAP_ACTION.to_string(),\n                redsys::REDSYS_SOAP_ACTION.to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n", "positive": "The `build_headers` function within the Redsys connector implementation generates the mandatory HTTP headers required for SOAP-based communication with the Redsys payment gateway. It constructs a vector of tuples containing header names and values, specifically setting the Content-Type to 'application/xml' and the SOAP Action to the constant `REDSYS_SOAP_ACTION`. This function is called during the request preparation phase to ensure the outgoing HTTP request adheres to the Redsys API specification before the payload is serialized and sent.", "queries": ["rust hyperswitch redsys connector build_headers function", "how to configure SOAP headers for redsys payment gateway in hyperswitch", "hyperswitch redsys build_headers implementation details", "redsys connector hyperswitch SOAP action header configuration"], "label": "Redsys SOAP header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: from\n    fn from(external_vault_details: ExternalVaultDetails) -> Self {\n        match external_vault_details {\n            ExternalVaultDetails::ExternalVaultEnabled(connector_details) => {\n                (Some(true), Some(connector_details))\n            }\n            ExternalVaultDetails::Skip => (Some(false), None),\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "positive": "This function converts an `ExternalVaultDetails` enum variant into a tuple of (bool, Option<ConnectorDetails>). It handles the 'ExternalVaultEnabled' case by returning a tuple with `Some(true)` and the connector details, and the 'Skip' case by returning `Some(false)` and `None`. This is a domain model utility used to initialize the internal vault state from external configuration, ensuring the correct boolean flag and optional connector reference are set for downstream processing.", "queries": ["how to convert ExternalVaultDetails to tuple in Rust", "ExternalVaultDetails from function implementation", "Rust enum to tuple conversion hyperswitch", "ExternalVaultDetails::Skip handling logic"], "label": "ExternalVaultDetails conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__business_profile.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "symbol": "from", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_external_authentication_details\n    fn get_external_authentication_details(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ExternalAuthenticationPayload, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n\n        let challenge_cancel = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"challengeCancel\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        let challenge_code_reason = webhook_body\n            .results_request\n            .as_ref()\n            .and_then(|v| v.get(\"transStatusReason\").and_then(|v| v.as_str()))\n            .map(|s| s.to_string());\n\n        Ok(ExternalAuthenticationPayload {\n            trans_status: webhook_body\n                .trans_status\n                .unwrap_or(common_enums::TransactionStatus::InformationOnly),\n            authentication_value: webhook_body.authentication_value,\n            eci: webhook_body.eci,\n            challenge_cancel,\n            challenge_code_reason,\n        })\n    }\n}\n", "positive": "This function processes the raw body of a Netcetera webhook request to extract authentication details for a 3D Secure (3DS) challenge. It parses the incoming JSON payload into a `ResultsResponseData` struct, specifically targeting fields like `transStatus`, `authenticationValue`, `eci`, and reason codes (`challengeCancel`, `transStatusReason`). The extracted data is wrapped into an `ExternalAuthenticationPayload` and returned, enabling the router to validate the transaction status and authentication result received from the Netcetera gateway.", "queries": ["how to parse netcetera webhook response body for 3ds authentication", "rust hyperswitch netcetera connector extract trans_status from webhook", "get_external_authentication_details implementation hyperswitch netcetera", "netcetera webhook challenge_cancel transStatusReason parsing hyperswitch"], "label": "Netcetera webhook authentication payload parser", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "get_external_authentication_details", "unit_type": "function", "num_lines": 33}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_active_attempt_ids_for_total_count\n    async fn get_filtered_active_attempt_ids_for_total_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<String>, Self::Error>;\n}\n\n#[derive(Clone, Debug, PartialEq, router_derive::DebugAsDisplay, Serialize, Deserialize)]", "positive": "This function retrieves a list of active payment attempt IDs filtered by specific constraints, such as processor merchant ID and storage scheme, to calculate the total count of active attempts. It is a critical component within the domain models layer, designed to interface with storage implementations to fetch data efficiently. The function signature indicates it is an async method returning a Result containing a vector of Strings (IDs) or a custom error type, ensuring robust error handling during the retrieval process.", "queries": ["how to get active payment attempt ids for total count", "hyperswitch payment intent fetch constraints active attempts", "rust function get_filtered_active_attempt_ids_for_total_count", "calculate total count of active payment attempts hyperswitch"], "label": "Payment attempt ID retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "get_filtered_active_attempt_ids_for_total_count", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "The `get_error_response` method in the Powertranz connector implementation serves as a standardized error handling entry point. It accepts an HTTP response object and an optional mutable reference to a `ConnectorEvent` builder. Its primary purpose is to construct a `CustomResult<ErrorResponse, errors::ConnectorError>` by delegating to `build_error_response`. This ensures that all HTTP-level failures from the Powertranz gateway are normalized into the platform's internal error schema, allowing the router to handle payment failures, network timeouts, or authentication errors consistently across the orchestration flow.", "queries": ["how to handle Powertranz API error responses in Rust", "Powertranz connector error handling implementation hyperswitch", "build_error_response function signature rust connector", "hyperswitch powertranz error mapping connector"], "label": "Powertranz error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "positive": "This function implements the `validate_mandate_payment` interface for the Gigadat connector within the Hyperswitch payment orchestration platform. It serves as a validation gate for recurring payment mandates, specifically filtering out Card payment methods. When invoked with Card data, it returns a `NotImplemented` error, while all other payment method types (e.g., ACH, SEPA) are implicitly accepted. This ensures that only non-card-based mandates are processed by this specific connector implementation.", "queries": ["hyperswitch gigadat validate_mandate_payment implementation", "how to handle card mandates in gigadat connector rust", "hyperswitch gigadat recurring payment validation", "gigadat connector validate_mandate_payment error NotImplemented"], "label": "Gigadat mandate validation filter", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "validate_mandate_payment", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: update_payment_intent\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n", "positive": "This function defines the interface for updating an existing PaymentIntent within the Hyperswitch domain models. It accepts the current PaymentIntent state, the desired updates (e.g., amount, currency, metadata), and a merchant-specific storage configuration. The implementation is responsible for validating the update against business rules and ensuring data integrity before persisting changes to the underlying storage layer, effectively bridging the API request layer with the domain logic.", "queries": ["hyperswitch update_payment_intent function signature rust", "how to modify payment intent amount in hyperswitch", "rust hyperswitch payment intent update interface", "hyperswitch domain models update_payment_intent implementation"], "label": "PaymentIntent update interface", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "update_payment_intent", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "This function retrieves the HTTP headers required for a specific payment request. It acts as a configuration layer, dynamically assembling headers based on the incoming request context and the available connectors. This ensures that every outgoing transaction carries the necessary authentication tokens, API keys, and custom metadata required by the underlying payment gateway (e.g., Finix), facilitating secure and compliant communication within the payment orchestration platform.", "queries": ["how to configure finix connector headers in hyperswitch", "rust function to get headers for create connector customer", "hyperswitch get_headers implementation finix", "finix connector authentication header setup hyperswitch"], "label": "Finix connector header retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__finix.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_signature\n    fn generate_signature(\n        &self,\n        auth: &NordeaAuthType,\n        signature_params: SignatureParams<'_>,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        const REQUEST_WITHOUT_CONTENT_HEADERS: &str =\n            \"(request-target) x-nordea-originating-host x-nordea-originating-date\";\n        const REQUEST_WITH_CONTENT_HEADERS: &str = \"(request-target) x-nordea-originating-host x-nordea-originating-date content-type digest\";\n\n        let method_string = signature_params.http_method.to_string().to_lowercase();\n        let mut normalized_string = format!(\n            \"(request-target): {} {}\\nx-nordea-originating-host: {}\\nx-nordea-originating-date: {}\",\n            method_string, signature_params.path, signature_params.host, signature_params.date\n        );\n\n        let headers = if matches!(\n            signature_params.http_method,\n            Method::Post | Method::Put | Method::Patch\n        ) {\n            let digest = signature_params.payload_digest.unwrap_or(\"\");\n            normalized_string.push_str(&format!(\n                \"\\ncontent-type: {}\\ndigest: {}\",\n                signature_params.content_type, digest\n            ));\n            REQUEST_WITH_CONTENT_HEADERS\n        } else {\n            REQUEST_WITHOUT_CONTENT_HEADERS\n        };\n\n        let signature_base64 = {\n            let private_key_pem =\n                self.format_private_key(&auth.eidas_private_key.clone().expose())?;\n\n            let private_key_der = pem::parse(&private_key_pem).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n            let private_key_der_contents = private_key_der.contents();\n            let key_pair = RsaKeyPair::from_der(private_key_der_contents).change_context(\n                errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"eIDAS Private Key\",\n                },\n            )?;\n\n            let mut signature = vec![0u8; key_pair.public().modulus_len()];\n            key_pair\n                .sign(\n                    &RSA_PKCS1_SHA256,\n                    &ring::rand::SystemRandom::new(),\n                    normalized_string.as_bytes(),\n                    &mut signature,\n                )\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n            consts::BASE64_ENGINE.encode(signature)\n        };\n\n        Ok(format!(\n            r#\"keyId=\"{}\",algorithm=\"rsa-sha256\",headers=\"{}\",signature=\"{}\"\"#,\n            auth.client_id.peek(),\n            headers,\n            signature_base64\n        ))\n    }\n\n    // This helper function correctly serializes a struct into the required\n    // non-percent-encoded form URL string.", "positive": "This function generates a cryptographic signature for HTTP requests using the RSA-SHA256 algorithm, adhering to the eIDAS security standard required by Nordea. It constructs a normalized string from the HTTP method, path, host, date, and specific headers (content-type and digest for body-bearing methods). It then signs this string using a private key loaded from the configuration, returning a standard Authorization header string formatted with keyId, algorithm, headers, and the base64-encoded signature.", "queries": ["rust nordea connector generate_signature rsa-sha256 eidas", "how to implement nordea signature generation in rust hyperswitch", "nordea eidas private key signature_params implementation", "hyperswitch nordea connector generate_signature function"], "label": "nordea eidas signature generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "generate_signature", "unit_type": "function", "num_lines": 68}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a raw HTTP Response received from the Sift payment connector. It parses the response body into a SiftErrorResponse struct, logs the connector's raw response for debugging, and populates the error details (status code, code, message, reason) into the unified error model. It also supports optional event builder injection to attach the raw response payload to the connector event stream.", "queries": ["how to handle sift connector error responses in hyperswitch", "build_error_response function implementation sift rust", "parse sift error response body hyperswitch", "hyperswitch sift connector error handling"], "label": "Sift error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: fmt\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            f.write_str(\n                serde_json::to_string(&serde_json::json!({\n                    \"error\": {\n                        \"error_type\": \"invalid_request\",\n                        \"message\": self.err.to_string(),\n                        \"code\": \"IR_06\",\n                    }\n                }))\n                .as_deref()\n                .unwrap_or(\"Invalid Json Error\"),\n            )\n        }\n    }\n", "positive": "This `fmt` method implements the `std::fmt::Display` trait for a custom error type. It serializes the internal error into a JSON object with a standardized structure, including a fixed error type 'invalid_request', a specific code 'IR_06', and the error message. This is used to format error responses for the API, ensuring consistent JSON error payloads for clients.", "queries": ["how to format error as  in rust hyperswitch", "hyperswitch error response format", "rust fmt trait implementation for error", "IR_06 invalid_request error format hyperswitch"], "label": "Error formatting to JSON", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "fmt", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: zift::ZiftErrorResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.response_code,\n            message: response.response_message.clone(),\n            reason: Some(response.response_message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a Zift payment gateway response. It deserializes the raw HTTP body into a ZiftErrorResponse struct, logs the connector's specific response details, and populates the error fields. It handles optional event builder injection for downstream webhook processing and ensures all network-level error codes are mapped to the internal error model.", "queries": ["how to handle zift payment gateway error responses in rust", "zift connector error handling hyperswitch rust", "build_error_response function implementation hyperswitch", "map zift api error to hyperswitch error model"], "label": "Zift error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 27}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreProcessingRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreProcessingRouterData, errors::ConnectorError> {\n        let response: redsys::RedsysResponse = res\n            .response\n            .parse_struct(\"RedsysResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the Redsys payment gateway connector. It deserializes the raw response body into a `RedsysResponse` struct, logs the connector output for observability, and constructs a `RouterData` object containing the parsed response, original request context, and HTTP status code. It is a critical deserialization and validation step in the payment flow before routing decisions are made.", "queries": ["rust hyperswitch redsys connector handle_response function implementation", "how does hyperswitch handle redsys response parsing in rust", "hyperswitch redsys connector deserialization and logging logic", "redsys payment gateway response handling in hyperswitch rust code"], "label": "Redsys response deserialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentInitiation\npub struct PaymentInitiation {\n    pub ref_id: String,\n    pub remittance_information_primary: MerchantId,\n    pub amount: Amount,\n    pub local_instrument: LocalInstrument,\n    pub creditor: Creditor,\n    pub callback_url: Option<String>,\n    pub flow_type: FlowType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]", "positive": "The PaymentInitiation struct defines the core data model for initiating a payment transaction within the Hyperswitch payment orchestration platform. It encapsulates essential transaction details such as the unique reference ID, total amount, and local instrument type. The struct includes specific fields for the creditor (beneficiary) and remittance information, along with an optional callback URL for asynchronous notifications. It also specifies the flow type (e.g., one-time or recurring) and integrates with the TokenIO connector for secure token-based processing. This struct serves as the primary input for the payment initiation flow, mapping directly to the TokenIO API's request payload structure.", "queries": ["Rust struct definition for initiating payments in Hyperswitch", "TokenIO connector PaymentInitiation struct fields", "Hyperswitch payment initiation data model Rust", "How to construct PaymentInitiation struct for TokenIO"], "label": "PaymentInitiation struct TokenIO", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "PaymentInitiation", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n", "positive": "This function constructs the HTTP headers for requests sent to the GPayments connector. It specifically sets the Content-Type header based on the connector's configuration, ensuring the upstream payment gateway receives data in the correct format. It is a standard boilerplate method within the connector trait implementation, abstracting header management from the specific HTTP client logic.", "queries": ["rust hyperswitch gpayments connector build_headers implementation", "how to configure content type for gpayments in hyperswitch", "hyperswitch gpayments connector header setup function", "gpayments hyperswitch rust build_headers method"], "label": "GPayments header configuration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: MandateRequest\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "positive": "The MandateRequest struct defines the input parameters required to initiate a payment mandate via the PayMe connector. It encapsulates financial details like currency, sale price, and transaction ID, alongside sensitive credentials such as seller and buyer keys. This struct is used within the PayMe transformer layer to map the internal Hyperswitch mandate model to the specific API requirements of the PayMe payment gateway, ensuring secure and compliant mandate creation.", "queries": ["Rust struct definition for MandateRequest in PayMe connector", "hyperswitch PayMe mandate request fields currency transaction_id", "how to construct MandateRequest for PayMe integration hyperswitch", "PayMe connector mandate request struct hyperswitch rust"], "label": "PayMe Mandate Request Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "symbol": "MandateRequest", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function, `get_error_response`, serves as a standardized error handling wrapper within the Thunes connector implementation. It accepts an HTTP `Response` object and an optional `ConnectorEvent` builder, then delegates to `build_error_response` to construct a standardized `ErrorResponse`. This ensures that errors returned by the Thunes API are normalized into Hyperswitch's internal error model, allowing the router to handle failures consistently regardless of the underlying payment provider's specific error codes. It is a critical component of the connector's error propagation layer, ensuring that network failures or API rejection errors are surfaced correctly to the calling application.", "queries": ["how to handle error responses in Thunes connector hyperswitch", "hyperswitch thunes connector error handling implementation", "thunes connector get_error_response function rust", "hyperswitch connector error response builder pattern"], "label": "Thunes connector error handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: generate_digest_from_request\n    pub fn generate_digest_from_request(&self, payload: &RequestContent) -> String {\n        let payload_bytes = match payload {\n            RequestContent::RawBytes(bytes) => bytes.clone(),\n            _ => payload.get_inner_value().expose().as_bytes().to_vec(),\n        };\n\n        self.generate_digest(&payload_bytes)\n    }\n", "positive": "This function prepares a raw payload for cryptographic hashing by normalizing the input. It handles two distinct input types: raw byte slices and structured request content. If the input is a struct, it extracts the inner value and converts it to bytes. The function then delegates the actual hashing logic to the internal `generate_digest` method, ensuring consistent payload representation for signature verification or logging purposes within the Nordea connector.", "queries": ["how to generate digest from request content in nordea connector", "rust function to hash request payload bytes hyperswitch", "nordea connector digest generation implementation", "hyperswitch nordea request hashing logic"], "label": "Nordea payload digest generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "generate_digest_from_request", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_string_repr\n    pub fn get_string_repr(&self) -> &String {\n        match self {\n            Self::PreProcessingId(value) => value,\n            Self::ConnectorTransactionId(value) => value,\n        }\n    }\n}\n\n#[derive(Debug, Eq, PartialEq, Clone, Serialize, serde::Deserialize)]", "positive": "This function, `get_string_repr`, is a utility method within the `RouterResponseTypes` enum in the `hyperswitch_domain_models` crate. It provides a consistent way to extract the underlying string identifier from two specific enum variants: `PreProcessingId` and `ConnectorTransactionId`. This is critical for serialization and logging within the payment orchestration router, ensuring that transaction tracking data is accessible as a standard string reference regardless of the specific processing stage.", "queries": ["how to get string representation of PreProcessingId in hyperswitch", "rust enum get_string_repr method implementation", "hyperswitch domain models router response types", "extract transaction id string from enum variant"], "label": "Enum string accessor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "get_string_repr", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: LegalType\npub enum LegalType {\n    Business,\n    #[default]\n    Private,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "The `LegalType` enum in `hyperswitch_connectors` defines the classification of a legal entity, specifically for payout operations. It supports two primary states: `Business` and `Private`. The `Private` variant is designated as the default value, indicating that a payout is typically directed to an individual unless explicitly specified as a business entity. This enum is used within the Wise connector's transformer logic to map incoming payout requests to the appropriate legal structure, ensuring compliance with Wise's payout requirements and handling the serialization/deserialization of the payout data.", "queries": ["How to configure LegalType for Wise payouts in hyperswitch", "Rust enum LegalType definition hyperswitch connectors wise", "hyperswitch LegalType Business Private enum usage", "Wise connector LegalType enum default behavior"], "label": "Wise LegalType enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "LegalType", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "This function retrieves authentication headers for the GPayments connector. It acts as a wrapper around the `build_headers` method, taking a `ConnectorAuthenticationRouterData` struct and a `Connectors` registry as inputs. It returns a vector of tuples containing header names and masked values, ensuring secure transmission of credentials and configuration details required for the GPayments API interaction within the Hyperswitch payment orchestration platform.", "queries": ["rust hyperswitch gpayments connector get_headers function implementation", "how to implement get_headers for gpayments connector in hyperswitch rust", "hyperswitch gpayments authentication header generation rust code", "rust hyperswitch gpayments connector build_headers wrapper"], "label": "gpayments connector header retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsPreAuthenticateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsPreAuthenticateRouterData, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardAuthSetupResponse = res\n            .response\n            .parse_struct(\"Barclaycard AuthSetupResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        PaymentsPreAuthenticateRouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "The handle_response function processes the HTTP response from the Barclaycard payment provider's pre-authentication setup endpoint. It deserializes the raw response into a structured BarclaycardAuthSetupResponse, logs the details for observability, and constructs a PaymentsPreAuthenticateRouterData object. This data is then passed to the router for further processing, ensuring the payment orchestration flow can proceed with the correct authentication context.", "queries": ["how to handle Barclaycard pre-auth response in hyperswitch", "rust function to parse BarclaycardAuthSetupResponse", "hyperswitch connector handle_response implementation", "Barclaycard payment provider integration hyperswitch rust"], "label": "Barclaycard pre-auth response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: get_address_info\nfn get_address_info(\n    address: Option<&hyperswitch_domain_models::address::Address>,\n) -> Option<Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>>> {\n    address.and_then(|add| {\n        add.address.as_ref().map(\n            |address_details| -> Result<KlarnaShippingAddress, error_stack::Report<errors::ConnectorError>> {\n                Ok(KlarnaShippingAddress {\n                    city: address_details.get_city()?.to_owned(),\n                    country: address_details.get_country()?.to_owned(),\n                    email: add.get_email()?.to_owned(),\n                    postal_code: address_details.get_zip()?.to_owned(),\n                    region: address_details.to_state_code()?.to_owned(),\n                    street_address: address_details.get_line1()?.to_owned(),\n                    street_address2: address_details.get_optional_line2(),\n                    given_name: address_details.get_first_name()?.to_owned(),\n                    family_name: address_details.get_last_name()?.to_owned(),\n                    phone: add.get_phone_with_country_code()?.to_owned(),\n                })\n            },\n        )\n    })\n}\n", "positive": "This function transforms a domain-level Address object into a Klarna-specific shipping address format. It handles optional address fields safely, extracting city, country, postal code, and region from address details, while pulling contact information like email and phone with country codes from the parent address object. It is used within the Klarna connector's transformer layer to map Hyperswitch's internal address models to Klarna's API requirements before payment or checkout requests.", "queries": ["how to map Hyperswitch address to Klarna shipping address", "rust function get_address_info Klarna connector", "transform address details to KlarnaShippingAddress", "hyperswitch klarna address mapping implementation"], "label": "Klarna address transformer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "symbol": "get_address_info", "unit_type": "function", "num_lines": 23}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: PayRequest\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "positive": "The `PayRequest` struct defines the input payload for Payme payment processing within the hyperswitch_connectors crate. It encapsulates sensitive buyer details (name, email) and transaction identifiers (sale_id), utilizing Serde flattening to integrate `PaymeCard` configuration seamlessly. This struct serves as the primary data transfer object (DTO) passed to the Payme transformer logic, mapping the orchestration platform's generic payment request model to the specific API requirements of the Payme payment gateway.", "queries": ["hyperswitch Payme connector PayRequest struct definition", "Payme payment gateway integration hyperswitch Rust", "PaymeCard struct serialization hyperswitch PayRequest", "hyperswitch connectors payme transformer input model"], "label": "Payme PayRequest struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "symbol": "PayRequest", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(email: Secret<String, pii::EmailStrategy>) -> UserResult<Self> {\n        use validator::ValidateEmail;\n\n        let email_string = email.expose().to_lowercase();\n        let email =\n            pii::Email::from_str(&email_string).change_context(UserErrors::EmailParsingError)?;\n\n        if email_string.validate_email() {\n            let (_username, domain) = match email_string.as_str().split_once('@') {\n                Some((u, d)) => (u, d),\n                None => return Err(UserErrors::EmailParsingError.into()),\n            };\n\n            if BLOCKED_EMAIL.contains(domain) {\n                return Err(UserErrors::InvalidEmailError.into());\n            }\n            Ok(Self(email))\n        } else {\n            Err(UserErrors::EmailParsingError.into())\n        }\n    }\n", "positive": "This constructor initializes a User entity by validating and normalizing an email address. It enforces lowercase conversion, checks for blocked domains via the BLOCKED_EMAIL set, and ensures strict RFC-compliant email format using the `validator` crate. The function returns a `UserResult` containing the sanitized `pii::Email` or a `UserErrors` variant, ensuring data integrity before storage in the `hyperswitch_domain_models` crate.", "queries": ["rust hyperswitch create user entity with email validation", "hyperswitch user constructor blocked email check", "how to initialize User struct with email in hyperswitch", "rust hyperswitch pii email strategy new function"], "label": "User entity email constructor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "new", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ConnectorCustomerData\npub struct ConnectorCustomerData {\n    pub description: Option<String>,\n    pub email: Option<pii::Email>,\n    pub phone: Option<Secret<String>>,\n    pub name: Option<Secret<String>>,\n    pub preprocessing_id: Option<String>,\n    pub payment_method_data: Option<PaymentMethodData>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub billing_address: Option<AddressDetails>,\n    pub metadata: Option<Secret<serde_json::Value>>,\n    pub currency: Option<storage_enums::Currency>,\n}\n", "positive": "The `ConnectorCustomerData` struct serves as the primary data transfer object (DTO) for customer information passed between the router and external payment connectors. It encapsulates sensitive PII (email, phone, name) and non-sensitive metadata, alongside payment configuration like split payments and future usage mandates. This struct is crucial for the 'Connect' phase of the payment flow, ensuring that the connector has the necessary context to create or update a customer record on the provider's side before processing transactions.", "queries": ["Rust struct definition for ConnectorCustomerData hyperswitch", "hyperswitch router customer data struct fields", "how to define ConnectorCustomerData in hyperswitch domain models", "ConnectorCustomerData hyperswitch payment orchestration"], "label": "Customer Data Transfer Object", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "ConnectorCustomerData", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: format_private_key\n    fn format_private_key(\n        &self,\n        private_key_str: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let key = private_key_str.to_string();\n\n        // Check if it already has PEM headers\n        let pem_data =\n            if key.contains(\"BEGIN\") && key.contains(\"END\") && key.contains(\"PRIVATE KEY\") {\n                key\n            } else {\n                // Remove whitespace and format with 64-char lines\n                let cleaned_key = key\n                    .chars()\n                    .filter(|c| !c.is_whitespace())\n                    .collect::<String>();\n\n                let formatted_key = cleaned_key\n                    .chars()\n                    .collect::<Vec<char>>()\n                    .chunks(64)\n                    .map(|chunk| chunk.iter().collect::<String>())\n                    .collect::<Vec<String>>()\n                    .join(\"\\n\");\n\n                format!(\n                \"-----BEGIN RSA PRIVATE KEY-----\\n{formatted_key}\\n-----END RSA PRIVATE KEY-----\",\n            )\n            };\n\n        Ok(pem_data)\n    }\n\n    // For non-production environments, signature generation can be skipped and instead `SKIP_SIGNATURE_VALIDATION_FOR_SANDBOX` can be passed.", "positive": "This function within the Nordea connector implementation normalizes raw private key strings into standard PEM format. It detects if the input already contains PEM headers; if not, it strips whitespace and formats the key into 64-character lines, wrapping them with '-----BEGIN RSA PRIVATE KEY-----' and '-----END RSA PRIVATE KEY-----' headers. This normalization is critical for cryptographic operations in the payment orchestration flow.", "queries": ["how to format private key string for nordea connector rust", "nordea rsa private key pem formatting hyperswitch", "rust function to add pem headers to private key", "hyperswitch nordea connector key formatting logic"], "label": "nordea rsa key pem formatter", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "format_private_key", "unit_type": "function", "num_lines": 34}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_current_date_time\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This utility function retrieves the current UTC timestamp formatted as a specific human-readable string (e.g., 'Mon, 01 Jan 2024 12:00:00 GMT'). It is used by the Worldline connector implementation to generate compliant request headers or payload fields requiring precise date-time representation. The function relies on the `format_description` crate to define the output pattern and `OffsetDateTime::now_utc()` to ensure timezone accuracy.", "queries": ["how to get current utc time in rust for worldline connector", "worldline connector get_current_date_time implementation", "rust format current date time gmt string", "hyperswitch worldline connector date formatting"], "label": "Worldline UTC timestamp formatter", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "get_current_date_time", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: decide_execution_path\nfn decide_execution_path(\n    connector_type: ConnectorIntegrationType,\n    previous_gateway: Option<GatewaySystem>,\n    execution_mode: ExecutionMode,\n) -> RouterResult<(GatewaySystem, ExecutionPath)> {\n    match connector_type {\n        // UCS-only connectors always use UCS\n        ConnectorIntegrationType::UcsConnector => Ok((\n            GatewaySystem::UnifiedConnectorService,\n            ExecutionPath::UnifiedConnectorService,\n        )),\n        ConnectorIntegrationType::DirectandUCSConnector => {\n            match (previous_gateway, execution_mode) {\n                (Some(GatewaySystem::Direct), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Primary) => {\n                    // Previous gateway was Direct, continue using Direct\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::Direct), ExecutionMode::Shadow) => {\n                    // Previous gateway was Direct, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::NotApplicable) => {\n                    // Previous gateway was UCS, continue using Direct as the config key has notapplicable execution mode\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Primary) => {\n                    // previous gateway was UCS, and config key has execution mode primary - continue using UCS\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (Some(GatewaySystem::UnifiedConnectorService), ExecutionMode::Shadow) => {\n                    // previous gateway was UCS, but now UCS is in shadow mode for comparison\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                \n\n... [truncated 2 chars] ...\n\n  ))\n                }\n                (None, ExecutionMode::Primary) => {\n                    // Fresh payment for a UCS-enabled connector - use UCS as primary\n                    Ok((\n                        GatewaySystem::UnifiedConnectorService,\n                        ExecutionPath::UnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::Shadow) => {\n                    // Fresh payment for UCS-enabled connector with shadow mode - use shadow UCS\n                    Ok((\n                        GatewaySystem::Direct,\n                        ExecutionPath::ShadowUnifiedConnectorService,\n                    ))\n                }\n                (None, ExecutionMode::NotApplicable) => {\n                    // Fresh payment request for direct connector - use direct gateway\n                    Ok((GatewaySystem::Direct, ExecutionPath::Direct))\n                }\n            }\n        }\n    }\n}\n\n/// Build rollout keys based on flow type - include payment method for payments, skip for refunds", "positive": "This function determines the routing strategy for payment transactions based on the connector type, previous gateway state, and execution mode. It handles logic for UCS-only connectors, Direct connectors, and mixed scenarios where a Direct gateway might shadow a UCS service. It returns the appropriate GatewaySystem and ExecutionPath to ensure the correct service handles the request, supporting primary, shadow, and not-applicable modes.", "queries": ["how to decide execution path for direct connector in shadow mode", "rust function decide_execution_path gateway system", "hyperswitch routing logic direct vs ucs connector", "execution_mode shadow previous gateway direct"], "label": "routing logic execution path", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "decide_execution_path", "unit_type": "function", "num_lines": 70}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_filter_clause\n    fn set_filter_clause(&self, builder: &mut QueryBuilder<T>) -> QueryResult<()> {\n        builder.add_custom_filter_clause(\"created_at\", self.start_time, FilterTypes::Gte)?;\n        if let Some(end) = self.end_time {\n            builder.add_custom_filter_clause(\"created_at\", end, FilterTypes::Lte)?;\n        }\n        Ok(())\n    }\n}\n", "positive": "This function configures time-based filtering for analytics queries within the Hyperswitch payment orchestration platform. It utilizes the `QueryBuilder` to append SQL-like custom clauses, specifically setting a 'created_at' timestamp range. It enforces a 'Greater Than or Equal to' (Gte) constraint using `start_time` and, if provided, an 'Less Than or Equal to' (Lte) constraint using `end_time`. This mechanism is critical for isolating transaction data for specific time windows in the analytics crate.", "queries": ["how to filter analytics results by date range in hyperswitch", "rust function to add created_at timestamp filter to query builder", "hyperswitch analytics crate set_filter_clause implementation", "how does set_filter_clause work in hyperswitch analytics"], "label": "analytics time range filter", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "set_filter_clause", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: foreign_from\n    fn foreign_from(email: Email) -> Self {\n        let email_value: String = email.expose().peek().to_owned();\n        Self::from(email_value)\n    }\n}\n\n/// Masked Phone Number\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "positive": "The `foreign_from` function in `common_utils` serves as a type conversion utility for the `Email` newtype wrapper. It extracts the underlying string value from the `Email` struct using `expose().peek()`, clones it into a `String`, and then delegates the construction to the standard `From<String>` implementation. This pattern is used throughout the codebase to handle serialization/deserialization boundaries where the internal representation differs from the external API model, specifically within the `api_models` crate.", "queries": ["rust convert Email newtype to string", "how to extract value from Email type in hyperswitch", "Email expose peek rust implementation", "hyperswitch common_utils foreign_from function"], "label": "Email newtype conversion utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__common_utils__src__new_type.rs", "path": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "symbol": "foreign_from", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: ConnectorAuthType\npub enum ConnectorAuthType {\n    TemporaryAuth,\n    HeaderKey {\n        api_key: Secret<String>,\n    },\n    BodyKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n    },\n    SignatureKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n    },\n    MultiAuthKey {\n        api_key: Secret<String>,\n        key1: Secret<String>,\n        api_secret: Secret<String>,\n        key2: Secret<String>,\n    },\n    CurrencyAuthKey {\n        auth_key_map: HashMap<common_enums::enums::Currency, common_utils::pii::SecretSerdeValue>,\n    },\n    CertificateAuth {\n        certificate: Secret<String>,\n        private_key: Secret<String>,\n    },\n    #[default]\n    NoKey,\n}\n", "positive": "This enum defines the authentication strategy required to communicate with a specific payment connector. It supports various methods including temporary tokens, API keys in headers or bodies, signature-based authentication with secrets, multi-key configurations, currency-specific keys, and certificate-based auth. The `NoKey` variant serves as a default for connectors that do not require authentication. This type is central to the `hyperswitch_domain_models` crate, which provides the core data structures for the payment orchestration platform.", "queries": ["Rust enum for connector authentication types hyperswitch", "how to implement connector auth type in hyperswitch rust", "hyperswitch domain models connector auth type definition", "rust enum for payment gateway api key authentication hyperswitch"], "label": "ConnectorAuthType definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "ConnectorAuthType", "unit_type": "function", "num_lines": 31}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let connector_auth = boku::BokuAuthType::try_from(&req.connector_auth_type)?;\n\n        let boku_url = Self::get_url(self, req, connectors)?;\n\n        let content_type = Self::common_get_content_type(self);\n\n        let connector_method = Self::get_http_method(self);\n\n        let timestamp = OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n\n        let secret_key = boku::BokuAuthType::try_from(&req.connector_auth_type)?\n            .key_id\n            .expose();\n\n        let to_sign = format!(\n            \"{} {}\\nContent-Type: {}\\n{}\",\n            connector_method, boku_url, &content_type, timestamp\n        );\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, secret_key.as_bytes());\n\n        let tag = hmac::sign(&key, to_sign.as_bytes());\n\n        let signature = hex::encode(tag);\n\n        let auth_val = format!(\"2/HMAC_SHA256(H+SHA256(E)) timestamp={timestamp}, signature={signature} signed-headers=Content-Type, key-id={}\", connector_auth.key_id.peek());\n\n        let header = vec![\n            (headers::CONTENT_TYPE.to_string(), content_type.into()),\n            (headers::AUTHORIZATION.to_string(), auth_val.into_masked()),\n        ];\n\n        Ok(header)\n    }\n}\n", "positive": "The `build_headers` function in the `boku` connector generates the HTTP headers required for authenticating and signing requests to the Boku payment gateway. It constructs a request signature using HMAC-SHA256 with a secret key, a timestamp, and the request method and URL. The function also sets the Content-Type header. The resulting headers are returned as a vector of tuples, ready to be added to the outgoing HTTP request.", "queries": ["boku connector rust build_headers implementation", "how to generate boku api signature rust hyperswitch", "hyperswitch boku connector authentication headers", "rust hmac sha256 signature generation boku hyperswitch"], "label": "Boku connector authentication", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 41}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthoriseIntegrityObject\npub struct AuthoriseIntegrityObject {\n    /// Authorise amount\n    pub amount: MinorUnit,\n    /// Authorise currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "positive": "The `AuthoriseIntegrityObject` struct in `hyperswitch_domain_models` defines the immutable financial parameters for a payment authorization request. It encapsulates the specific `amount` (in minor units) and `currency` to be authorized, ensuring strict adherence to the merchant's requested transaction value. This object is passed through the router layer to the connector implementations, serving as the core validation payload that determines if the transaction meets the bank's risk and fraud thresholds before funds are reserved.", "queries": ["rust hyperswitch AuthoriseIntegrityObject struct definition", "how to define authorization amount and currency in hyperswitch domain models", "hyperswitch router request types AuthoriseIntegrityObject fields", "rust struct for payment authorization parameters hyperswitch"], "label": "Payment Authorization Parameters", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "AuthoriseIntegrityObject", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let gpayments_auth_type = gpayments::GpaymentsAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(gpayments_auth_type.certificate))\n                .add_certificate_key(Some(gpayments_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for GPayments authentication flows within the Hyperswitch payment orchestration platform. It leverages the `gpayments` module to parse the authentication type, retrieves the specific API endpoint and headers using the `ConnectorAuthenticationType` trait, and attaches the necessary X.509 client certificates and private keys. The result is a fully configured `Request` object ready for transmission to the GPayments gateway, ensuring secure and compliant credential exchange during the connection handshake.", "queries": ["rust hyperswitch gpayments connector authentication request builder", "how to configure gpayments client certificate in hyperswitch", "hyperswitch build_request function for gpayments authentication", "rust hyperswitch connector authentication request setup"], "label": "gpayments auth request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 25}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_refund_id\n    async fn find_refund_by_merchant_id_refund_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "positive": "This function serves as a critical data access layer component within the Hyperswitch Router crate, specifically designed to retrieve a specific refund record from the PostgreSQL database based on unique merchant identifiers. It accepts a MerchantId, a string refund_id, and a storage scheme enum to determine the tenant schema, ensuring multi-tenancy isolation. The function returns a `CustomResult<diesel_refund::Refund, errors::StorageError>`, handling potential database interaction failures gracefully. It is a core dependency for the refund lifecycle, invoked by the `refund` scope routes defined in `crates/router/src/routes/app.rs` to fetch state for processing, auditing, or webhook notifications.", "queries": ["How do I query a refund by merchant ID and refund ID in Rust?", "Find the function to retrieve refund details from the database in Hyperswitch", "Rust function to get refund by merchant_id and refund_id in router crate", "Hyperswitch storage error handling for refund retrieval by ID"], "label": "Refund DB retrieval by ID", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "find_refund_by_merchant_id_refund_id", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentStatus\npub enum PaymentStatus {\n    InitiationPending,\n    InitiationPendingRedirectAuth,\n    InitiationPendingRedirectAuthVerification,\n    InitiationPendingRedirectHp,\n    InitiationPendingRedemption,\n    InitiationPendingRedemptionVerification,\n    InitiationProcessing,\n    InitiationCompleted,\n    InitiationRejected,\n    InitiationRejectedInsufficientFunds,\n    InitiationFailed,\n    InitiationDeclined,\n    InitiationExpired,\n    InitiationNoFinalStatusAvailable,\n    SettlementInProgress,\n    SettlementCompleted,\n    SettlementIncomplete,\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(untagged)]", "positive": "The PaymentStatus enum defines the lifecycle states for a payment transaction within the Hyperswitch orchestration platform. It covers the entire flow from initiation (InitiationPending, InitiationProcessing) through various redirect and redemption scenarios (InitiationPendingRedirectAuth, InitiationPendingRedemption) to final settlement (SettlementCompleted, SettlementIncomplete). This type is central to the `hyperswitch_domain_models` crate and is used across the system to track and validate the current state of a payment, ensuring correct routing and webhook triggering based on the transaction's progress.", "queries": ["Rust enum for payment transaction lifecycle states", "Hyperswitch PaymentStatus variants definition", "How to handle different payment status transitions in Rust", "List of all Hyperswitch payment status enums"], "label": "PaymentStatus enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "PaymentStatus", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let timestamp = time::OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000;\n        let auth: authipay::AuthipayAuthType =\n            authipay::AuthipayAuthType::try_from(&req.connector_auth_type)?;\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n\n        let authipay_req = self.get_request_body(req, connectors)?;\n\n        let client_request_id = uuid::Uuid::new_v4().to_string();\n        let hmac = self\n            .generate_authorization_signature(\n                auth,\n                &client_request_id,\n                authipay_req.get_inner_value().peek(),\n                timestamp,\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                types::PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\"Client-Request-Id\".to_string(), client_request_id.into()),\n            (\"Auth-Token-Type\".to_string(), \"HMAC\".to_string().into()),\n            (headers::TIMESTAMP.to_string(), timestamp.to_string().into()),\n            (\"Message-Signature\".to_string(), hmac.into_masked()),\n        ];\n        headers.append(&mut auth_header);\n        Ok(headers)\n    }\n}\n", "positive": "The `build_headers` function constructs the HTTP headers required for authenticating and communicating with the Authipay payment gateway. It generates a unique Client-Request-Id, a timestamp, and an HMAC-based Message-Signature using the request body and authentication credentials. These headers are essential for the connector to securely transmit payment authorization requests within the Hyperswitch payment orchestration platform.", "queries": ["how to build headers for Authipay connector in Rust", "Authipay HMAC signature generation implementation", "Hyperswitch Authipay connector authentication headers", "Authipay payment gateway API header structure"], "label": "Authipay connector header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 38}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WisePayoutQuoteRequest\npub struct WisePayoutQuoteRequest {\n    source_currency: String,\n    target_currency: String,\n    source_amount: Option<FloatMajorUnit>,\n    target_amount: Option<FloatMajorUnit>,\n    pay_out: WisePayOutOption,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "positive": "This struct, `WisePayoutQuoteRequest`, defines the input parameters for generating a payout quote within the Wise connector. It encapsulates the financial details of the transaction, including source and target currencies, amounts, and the specific payout method. It is a core data transfer object used by the `transformers.rs` module to map internal domain models to Wise API requirements, facilitating the retrieval of exchange rates and payout fees.", "queries": ["how to create a Wise payout quote request struct", "WisePayoutQuoteRequest fields and structure definition", "hyperswitch wise connector payout quote request model", "transformers.rs WisePayoutQuoteRequest implementation details"], "label": "Wise payout quote request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "WisePayoutQuoteRequest", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: generate_authorization_signature\n    pub fn generate_authorization_signature(\n        &self,\n        auth: authipay::AuthipayAuthType,\n        request_id: &str,\n        payload: &str,\n        timestamp: i128,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let authipay::AuthipayAuthType {\n            api_key,\n            api_secret,\n        } = auth;\n        let raw_signature = format!(\"{}{request_id}{timestamp}{payload}\", api_key.peek());\n\n        let key = ring::hmac::Key::new(ring::hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signature_value = common_utils::consts::BASE64_ENGINE\n            .encode(ring::hmac::sign(&key, raw_signature.as_bytes()).as_ref());\n        Ok(signature_value)\n    }\n}\n", "positive": "This function generates a SHA-256 HMAC signature for the Authipay payment connector to secure API requests. It constructs a raw signature string by concatenating the API key, request ID, timestamp, and payload, then signs this data using the provided API secret. The resulting binary hash is Base64 encoded and returned as a string. This mechanism ensures data integrity and authenticity for requests sent to the Authipay gateway.", "queries": ["rust hyperswitch authipay signature generation hmac sha256", "how to generate authorization signature for authipay connector hyperswitch", "hyperswitch authipay signature base64 encode hmac", "authipay signature generation rust implementation hyperswitch"], "label": "Authipay HMAC Signature Generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "generate_authorization_signature", "unit_type": "function", "num_lines": 20}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for the CyberSource 'Setup Mandate' API integration within the Hyperswitch payment orchestration platform. It acts as a request builder for the `SetupMandateRouterData` flow, utilizing the `SetupMandateType` trait to dynamically determine the target URL, required headers, and request body structure based on the provided configuration and connector context. The method returns a `CustomResult` containing an `Option<Request>`, ensuring safe handling of scenarios where request generation might fail or be skipped.", "queries": ["rust hyperswitch cybersource setup mandate request builder", "how to build cybersource setup mandate api request in hyperswitch", "hyperswitch cybersource connector setup mandate request implementation", "rust function build_request setup mandate router data hyperswitch"], "label": "CyberSource Setup Mandate Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n", "positive": "The `build_headers` function in the Helcim connector prepares the HTTP request headers required for API authentication and idempotency. It constructs a vector of tuples containing header names and values, specifically setting the Content-Type and generating a unique API key based on the request's connector authentication type. A critical integration detail is the Helcim requirement for an Idempotency Key of exactly 25 characters; this function prefixes generated IDs with 'HS_' to ensure compliance with this length constraint.", "queries": ["rust hyperswitch helcim connector build_headers function", "how to generate idempotency key for helcim hyperswitch", "helcim connector hyperswitch rust build_headers implementation", "hyperswitch helcim idempotency key length 25 characters"], "label": "helcim connector header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 25}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: Profile\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub version: common_enums::ApiVersion,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<common_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    pub acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]", "positive": "The `Profile` struct in `hyperswitch_domain_models` serves as the core domain entity representing a merchant's business configuration within the orchestration platform. It encapsulates critical settings such as routing algorithms (for payments, refunds, and payouts), webhook configurations, and authentication connector details. This struct is central to the router's logic for determining how to process transactions based on the specific merchant's rules, including features like 3DS decision rules, network tokenization, and tax connector integration. It is used extensively in the `router` crate to validate and route requests, and is persisted via Diesel models in `diesel_models`.", "queries": ["rust struct definition for merchant profile configuration hyperswitch", "how to configure routing algorithms in Profile struct hyperswitch", "hyperswitch Profile struct webhook configuration merchant settings", "rust domain model Profile merchant_id routing_algorithm definition"], "label": "Merchant Profile Domain Model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__business_profile.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "symbol": "Profile", "unit_type": "function", "num_lines": 65}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "positive": "The `get_error_response` method in the `Cybersource` connector implementation serves as a standardized error handling interface. It accepts an HTTP `Response` object and an optional mutable reference to a `ConnectorEvent` builder. Its primary purpose is to transform raw HTTP error payloads into structured `ErrorResponse` objects while simultaneously populating the event context for downstream processing or webhook notifications. This method delegates the actual parsing logic to `build_error_response`, ensuring consistent error formatting across the payment orchestration flow.", "queries": ["how to handle cybersource connector error responses in rust hyperswitch", "hyperswitch cybersource connector error handling get_error_response function", "rust connector error response builder cybersource hyperswitch", "cybersource connector error event builder hyperswitch rust implementation"], "label": "Cybersource error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Amazonpay\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Amazonpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for the Amazon Pay connector within the Hyperswitch payment orchestration platform. It establishes the interface for tokenizing payment methods and processing payment flows, utilizing the `PaymentMethodToken` and `PaymentMethodTokenizationData` types. The implementation ensures that the Amazon Pay connector adheres to the core `ConnectorIntegration` trait, allowing the router to abstract specific provider logic while handling the tokenization and payment response data structures required for the orchestration flow.", "queries": ["Amazon Pay tokenization implementation hyperswitch rust", "hyperswitch amazonpay connector trait integration", "rust connector integration amazonpay tokenization", "hyperswitch payment orchestration amazonpay connector"], "label": "AmazonPay connector trait implementation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: DebitRoutingConfig\npub struct DebitRoutingConfig {\n    #[serde(deserialize_with = \"deserialize_hashmap\")]\n    pub connector_supported_debit_networks: HashMap<enums::Connector, HashSet<enums::CardNetwork>>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_currencies: HashSet<enums::Currency>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub supported_connectors: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "positive": "DebitRoutingConfig is a configuration struct in the Hyperswitch payment orchestration platform (Rust) that defines routing rules for debit transactions. It specifies which connectors support specific debit networks (e.g., Visa, Mastercard), supported currencies, and eligible connectors. This struct is likely deserialized from a configuration file and used by the router to dynamically route debit payments based on network and currency constraints. Integration context: part of the router's configuration module (crates/router/src/configs/settings.rs), enabling flexible, multi-connector debit routing logic.", "queries": ["Hyperswitch DebitRoutingConfig struct definition Rust", "how to configure debit routing networks in Hyperswitch", "DebitRoutingConfig deserialize hashmap serde Rust", "Hyperswitch router debit payment routing configuration"], "label": "DebitRoutingConfig struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "DebitRoutingConfig", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: cybersource::CybersourceServerErrorResponse = res\n            .response\n            .parse_struct(\"CybersourceServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function handles the parsing and transformation of 5xx server error responses from the Cybersource connector. It deserializes the raw HTTP response into a structured `CybersourceServerErrorResponse`, logs the error details, and maps the specific `Reason` (e.g., SystemError, ServiceTimeout) to the appropriate `AttemptStatus`. It constructs a standardized `ErrorResponse` object, populating fields like status code, reason, and message while handling optional fields and defaulting to 'NO_ERROR_CODE' or 'NO_ERROR_MESSAGE' if the upstream payload is incomplete. This ensures consistent error reporting for downstream consumers.", "queries": ["how to handle 5xx server errors in Cybersource connector hyperswitch", "parse CybersourceServerErrorResponse hyperswitch rust", "map Cybersource reason to AttemptStatus hyperswitch", "hyperswitch cybersource error response transformation"], "label": "Cybersource 5xx Error Parser", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "get_5xx_error_response", "unit_type": "function", "num_lines": 40}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SyncTransactionType\npub enum SyncTransactionType {\n    Sale,\n    AuthOnly,\n    Return,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "positive": "This enum defines the standard transaction types for synchronous payment processing within the Elavon connector. It supports 'Sale' for immediate capture, 'AuthOnly' for pre-authorization, and 'Return' for processing refunds. The 'SyncTransactionType' variant is utilized by the transformer logic to map incoming payment requests to the specific Elavon API command required for the transaction flow, ensuring compatibility with the orchestration platform's synchronous payment handling.", "queries": ["How to handle synchronous payment types in Elavon connector", "Elavon connector Sale vs AuthOnly transaction types", "Rust enum SyncTransactionType Elavon implementation", "SyncTransactionType definition in hyperswitch connectors"], "label": "Elavon SyncTransactionType Enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "SyncTransactionType", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = gpayments::GpaymentsRouterData::from((MinorUnit::zero(), req));\n        let req_obj =\n            gpayments_types::GpaymentsAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }", "positive": "This function constructs the JSON payload for Gpayments authentication requests. It extracts the `ConnectorAuthenticationRouterData` and transforms it into `GpaymentsAuthenticationRequest` using the `GpaymentsRouterData` struct, ensuring the request body is formatted correctly for the Gpayments connector integration within the Hyperswitch payment orchestration platform.", "queries": ["how to get request body for gpayments authentication", "rust function get_request_body hyperswitch gpayments", "gpayments authentication request payload construction", "hyperswitch gpayments connector request body"], "label": "gpayments auth request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: worldline::ErrorResponse = res\n            .response\n            .parse_struct(\"Worldline ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        logger::info!(connector_response=?response);\n\n        let error = response.errors.into_iter().next().unwrap_or_default();\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: error\n                .code\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: error\n                .message\n                .unwrap_or_else(|| hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            ..Default::default()\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a Worldline API response, handling deserialization and error mapping. It parses the raw HTTP response body into a Worldline::ErrorResponse struct, logs the details for debugging, and maps the first error found to the internal ErrorResponse format. It supports optional event building for webhook tracking and uses default constants for missing error codes or messages.", "queries": ["how to handle worldline error response parsing in hyperswitch", "rust function to build error response from worldline connector", "hyperswitch worldline connector error handling implementation", "worldline error response mapping to hyperswitch error format"], "label": "Worldline error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 27}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        let webhook_body_value: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseDatae\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(Box::new(webhook_body_value))\n    }\n", "positive": "This function, `get_webhook_resource_object`, serves as the deserialization entry point for Netcetera webhook payloads within the Hyperswitch payment orchestration platform. It extracts the raw JSON body from an incoming webhook request and parses it into a strongly-typed Rust struct (`netcetera::ResultsResponseData`). This step is critical for validating the webhook signature and extracting transaction details before dispatching the event to the internal event bus. It handles the specific 'ResultsResponseDatae' struct format required by the Netcetera connector integration.", "queries": ["how to parse netcetera webhook results response data in rust", "hyperswitch netcetera connector webhook body deserialization", "rust struct parsing for netcetera results response", "hyperswitch webhook resource object netcetera implementation"], "label": "netcetera webhook payload deserialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "get_webhook_resource_object", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for Amazon Pay authorization flows within the Hyperswitch payment orchestration platform. It leverages the `PaymentsAuthorizeType` trait to dynamically generate the target URL, headers, and request body based on the provided `PaymentsAuthorizeRouterData` and connector configuration. The method ensures standard HTTP verb (POST) and default headers are applied before finalizing the request object, serving as a critical abstraction for routing authorization intents to the Amazon Pay gateway.", "queries": ["rust hyperswitch amazonpay build_request function implementation", "how to construct amazon pay authorization request in hyperswitch rust", "hyperswitch amazonpay connector request builder method", "rust amazonpay payments authorize request setup hyperswitch"], "label": "Amazon Pay Authorization Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n", "positive": "This function constructs the API endpoint URL for the Zift connector by appending '/gates/xurl' to the base URL. It is a setup method used to initialize the specific routing gate for Zift transactions within the Hyperswitch payment orchestration framework. The function relies on the base URL configuration and the provided connectors context to generate the final endpoint string, ensuring the router knows where to direct Zift-specific mandate requests.", "queries": ["rust hyperswitch zift connector get_url function implementation", "how to configure zift mandate router endpoint in hyperswitch", "hyperswitch zift connector setup_mandate_router_data get_url", "rust hyperswitch zift base_url gates/xurl endpoint"], "label": "Zift mandate router URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: CardWithLimitedData\npub struct CardWithLimitedData {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Option<Secret<String>>,\n\n    /// The card's expiry year\n    pub card_exp_year: Option<Secret<String>>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The ECI(Electronic Commerce Indicator) value for this authentication.\n    pub eci: Option<String>,\n}\n\n// Determines if decryption should be performed\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize)]", "positive": "The `CardWithLimitedData` struct in `hyperswitch_domain_models` is a specialized domain model representing a credit card with sensitive fields redacted for security. It contains the masked `card_number`, optional `card_exp_month`, `card_exp_year`, and `card_holder_name` wrapped in `Secret` types to prevent accidental logging. It also includes the `eci` (Electronic Commerce Indicator) for 3D Secure authentication context. This struct is used in payment flows to pass card details to connectors while ensuring PII is handled securely, typically appearing in the `PaymentMethod` domain model hierarchy.", "queries": ["rust hyperswitch CardWithLimitedData struct definition", "hyperswitch domain models CardWithLimitedData eci field", "CardWithLimitedData hyperswitch payment method data", "hyperswitch Secret<String> card holder name"], "label": "CardWithLimitedData struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "CardWithLimitedData", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Globepay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Globepay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This function defines the integration trait implementation for the Globepay connector within the Hyperswitch payment orchestration platform. It establishes the contract for processing payment flows, specifically handling the tokenization of payment methods and the execution of payment requests. The implementation is currently marked as 'Not Implemented' (R), indicating that the core business logic for interacting with the Globepay API to process these specific operations is pending development or is a placeholder within the Rust codebase.", "queries": ["hyperswitch globepay connector integration implementation", "globepay payment method tokenization rust code", "hyperswitch connector not implemented globepay", "rust globepay payments response data structure"], "label": "Globepay Connector Integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_pay_sale_error_response\nfn get_pay_sale_error_response(\n    (pay_sale_response, http_code): (&PaymePaySaleResponse, u16),\n) -> ErrorResponse {\n    let code = pay_sale_response\n        .status_error_code\n        .map(|error_code| error_code.to_string())\n        .unwrap_or(consts::NO_ERROR_CODE.to_string());\n    ErrorResponse {\n        code,\n        message: pay_sale_response\n            .status_error_details\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: pay_sale_response.status_error_details.to_owned(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(pay_sale_response.payme_sale_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "positive": "This function transforms a PaymePaySaleResponse object into a standardized ErrorResponse for the hyperswitch payment orchestration platform. It maps the Payme-specific error status code and details into the connector's internal error model, ensuring consistent error reporting across different payment providers. It is a critical component in the connector's error handling pipeline, specifically invoked when processing payment sale requests that fail, allowing the system to propagate precise failure reasons to the client.", "queries": ["hyperswitch payme connector error response transformation", "how to handle payme payment sale errors in hyperswitch rust", "paymePaySaleResponse to ErrorResponse mapping hyperswitch", "hyperswitch payme connector error handling code"], "label": "Payme error response transformer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "symbol": "get_pay_sale_error_response", "unit_type": "function", "num_lines": 25}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(src: String) -> Self {\n        let unmasked_char_count = 2;\n        let masked_value = if unmasked_char_count <= src.len() {\n            let len = src.len();\n            // mask every character except the last 2\n            \"*\".repeat(len - unmasked_char_count).to_string()\n                + src\n                    .get(len.saturating_sub(unmasked_char_count)..)\n                    .unwrap_or(\"\")\n        } else {\n            src\n        };\n        Self(Secret::from(masked_value))\n    }\n}", "positive": "This function implements a secure string-to-Secret conversion utility within the common_utils crate. It accepts a raw string input and returns a new_type::Secret instance by masking the value. The masking logic preserves the last two characters of the input string while replacing all preceding characters with asterisks ('*'). This ensures sensitive data (like API keys or tokens) is logged or displayed without exposing the full payload, adhering to security best practices for the payment orchestration platform.", "queries": ["rust function to mask string keeping last 2 characters", "how to create Secret type from string in hyperswitch", "rust code to hide sensitive data except last 2 chars", "hyperswitch common_utils new_type from implementation"], "label": "Secret masking utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__common_utils__src__new_type.rs", "path": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "symbol": "from", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_redirect_url\nfn get_redirect_url(return_url: String) -> RedirectUrls {\n    RedirectUrls {\n        success_url: return_url.clone(),\n        failure_url: return_url,\n    }\n}\n\n// Auth Struct", "positive": "This function generates a `RedirectUrls` struct containing success and failure URLs derived from a single input string. It is used by the iTapay connector to construct the redirect payload required for the payment initiation flow, ensuring the user is returned to the specified endpoint regardless of the transaction outcome.", "queries": ["rust hyperswitch itapay connector get_redirect_url implementation", "how to configure success and failure URLs in hyperswitch itapay", "hyperswitch iatapay redirect_url function source code", "rust struct RedirectUrls hyperswitch itapay"], "label": "iTapay redirect URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "symbol": "get_redirect_url", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: fmt\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Ascending => write!(f, \"asc\"),\n            Self::Descending => write!(f, \"desc\"),\n        }\n    }\n}\n\n// Select TopN values for a group based on a metric\n// ---\n// Description -\n// columns: Columns in group to select TopN values for\n// count: N in TopN\n// order_column: metric used to sort and limit TopN\n// order: sort order of metric (Ascending / Descending)\n// ---\n// Usage -\n// Use via add_top_n_clause fn of query_builder\n// add_top_n_clause(\n//     &dimensions,\n//     distribution.distribution_cardinality.into(),\n//     \"count\",\n//     Order::Descending,\n// )\n#[allow(dead_code)]\n#[derive(Debug)]", "positive": "This `fmt` method implements the `Display` trait for the `Order` enum, which is used within the analytics module to define sorting directions for query results. It maps the enum variants `Ascending` and `Descending` to their corresponding string representations 'asc' and 'desc'. This function is crucial for generating readable output for sorting metrics, such as when selecting the top N values for a group based on a specific metric. It is integrated into the query builder's logic, specifically via the `add_top_n_clause` function, to dynamically construct SQL-like clauses for analytics queries.", "queries": ["how to format Order enum for display in hyperswitch analytics", "hyperswitch query builder add_top_n_clause Order enum usage", "rust fmt method implementation for Order enum hyperswitch", "hyperswitch analytics sorting directions Ascending Descending fmt"], "label": "Order enum Display trait implementation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "fmt", "unit_type": "function", "num_lines": 26}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )])\n    }\n}\n", "positive": "This function constructs the HTTP headers for outgoing requests within the Zift connector. It specifically sets the Content-Type header based on the connector's configuration, ensuring the upstream payment provider receives data in the correct format. It is a standard initialization step in the connector's request pipeline, abstracting header management from the main request logic.", "queries": ["rust hyperswitch zift connector build_headers function implementation", "how to set content type header in hyperswitch zift connector", "hyperswitch zift connector rust source code build_headers", "zift payment gateway connector hyperswitch rust header configuration"], "label": "Zift connector header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}risk/v1/authentication-setups\",\n            ConnectorCommon::base_url(self, connectors)\n        ))\n    }", "positive": "This function constructs the authentication endpoint URL for the Barclaycard connector. It retrieves the base URL via `ConnectorCommon::base_url` and appends the specific Barclaycard risk API path (`risk/v1/authentication-setups`). It is invoked during the pre-authentication phase of the payment flow to prepare the request payload for the external provider.", "queries": ["how to configure Barclaycard authentication endpoint URL in hyperswitch", "hyperswitch barclaycard connector get_url implementation", "barclaycard risk v1 authentication setups hyperswitch url", "hyperswitch connector base_url barclaycard authentication"], "label": "Barclaycard Auth URL Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: Airwallex\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "The Airwallex connector implements the `ConnectorIntegration` trait for the Airwallex payment gateway. It provides the core logic for processing payment flows, including payment creation, refunds, and webhook handling, by translating Hyperswitch domain models into Airwallex-specific API requests. The implementation leverages `StringMajorUnitForConnector` and `StringMinorUnitForConnector` for precise currency conversion and formatting, ensuring data integrity between the orchestration platform and the payment provider. It is registered within the `hyperswitch_connectors` crate, serving as a critical integration point for merchants using Airwallex as a payment method.", "queries": ["Airwallex connector implementation Rust hyperswitch", "how to implement Airwallex payment gateway integration in Rust", "hyperswitch Airwallex connector trait implementation", "Airwallex payment orchestration Rust connector code"], "label": "Airwallex connector integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "Airwallex", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: CaptureSyncResponse\npub enum CaptureSyncResponse {\n    Success {\n        resource_id: ResponseId,\n        status: common_enums::AttemptStatus,\n        connector_response_reference_id: Option<String>,\n        amount: Option<MinorUnit>,\n    },\n    Error {\n        code: String,\n        message: String,\n        reason: Option<String>,\n        status_code: u16,\n        amount: Option<MinorUnit>,\n    },\n}\n", "positive": "The CaptureSyncResponse enum defines the standardized return structure for synchronous capture operations within the Hyperswitch payment orchestration platform. It encapsulates the result of a payment capture attempt, distinguishing between a successful transaction and a failure scenario. The Success variant includes the generated resource identifier, the final attempt status, a reference to the connector's response, and the captured amount. The Error variant provides granular failure details, such as an error code, a descriptive message, an HTTP status code, and the amount attempted. This structure is utilized by the router to communicate capture outcomes back to the client and to update the internal state of payment records.", "queries": ["rust hyperswitch CaptureSyncResponse enum definition", "how to handle CaptureSyncResponse success and error variants in hyperswitch", "hyperswitch router synchronous capture response types", "CaptureSyncResponse struct fields resource_id status_code"], "label": "CaptureSyncResponse enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "CaptureSyncResponse", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: TransactionType\npub enum TransactionType {\n    CcSale,\n    CcAuthOnly,\n    CcComplete,\n    CcReturn,\n    TxnQuery,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"UPPERCASE\")]", "positive": "Defines the transaction type enum for Elavon connector integration within the hyperswitch_connectors crate. This enum maps specific payment operations (CcSale, CcAuthOnly, CcReturn, etc.) to Elavon's API requirements, ensuring the correct transaction flow is initiated based on the payment intent. It is serialized/deserialized with uppercase keys to align with Elavon's API response format.", "queries": ["elavon connector transaction type enum definition", "hyperswitch elavon cc_sale cc_auth_only mapping", "rust enum for elavon payment transaction types", "elavon api transaction type mapping hyperswitch"], "label": "Elavon transaction type enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "TransactionType", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: redsys::RedsysErrorResponse = res\n            .response\n            .parse_struct(\"RedsysErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code.clone(),\n            message: response.error_code.clone(),\n            reason: Some(response.error_code.clone()),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a Redsys API response, handling error parsing and logging. It takes a raw Response struct and an optional ConnectorEvent builder, deserializing the body into a RedsysErrorResponse. It logs the response details and returns a standardized error object containing the status code, error code, and message, ensuring consistent error reporting across the payment orchestration platform.", "queries": ["how to handle redsys error response in hyperswitch", "build_error_response function implementation rust", "redsys connector error handling hyperswitch", "parse redsys error response hyperswitch"], "label": "Redsys error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let auth = barclaycard::BarclaycardAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "positive": "This function generates the HTTP Authorization header for Barclaycard API requests. It takes a ConnectorAuthType enum, converts it to the specific BarclaycardAuthType, and returns a vector of header-value pairs. The value is masked for security, exposing only the API key when needed for the actual HTTP call. It is a core utility in the Barclaycard connector module, ensuring proper authentication for all payment operations.", "queries": ["how to get authorization header for barclaycard connector rust", "rust hyperswitch barclaycard get_auth_header implementation", "barclaycard connector authentication header generation hyperswitch", "hyperswitch barclaycard auth_type to header conversion"], "label": "Barclaycard auth header generator", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WroldpayModularActualPsyncResponseObj\npub struct WroldpayModularActualPsyncResponseObj {\n    pub last_event: PaymentOutcome,\n    pub value: super::PaymentValue,\n}\n\n// Sent for settlement plays totally differnt role in worldpaymodular in webhooks and psync\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "positive": "This struct represents the actual payload returned by Worldpay Modular during a PaymentSync (PSync) operation. It encapsulates the final transaction outcome and the monetary value details. Crucially, the `value` field plays a distinct role in PSync compared to webhooks, where settlement logic is handled differently. The struct is serialized using a `#[serde(untagged)]` variant, implying it can deserialize from multiple potential response formats without explicit tag fields, facilitating flexible integration with Worldpay's API responses.", "queries": ["Worldpay Modular PSync response structure", "WroldpayModularActualPsyncResponseObj Rust struct", "Worldpay Modular payment sync payload fields", "hyperswitch worldpaymodular psync response object"], "label": "Worldpay Modular PSync Response", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "WroldpayModularActualPsyncResponseObj", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "positive": "This function constructs the API endpoint URL for revoking a mandate within the Wells Fargo connector. It utilizes the base URL from the connector configuration and appends the specific Wells Fargo mandate identifier, derived from the request payload via `RevokeMandateRequestData::get_connector_mandate_id`. This ensures the correct endpoint is targeted for mandate cancellation operations.", "queries": ["how to revoke mandate in Wells Fargo connector", "wellsfargo mandate revoke endpoint url construction", "hyperswitch wells fargo mandate revoke function", "get_url mandate revoke router data implementation"], "label": "Wells Fargo mandate revoke URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "positive": "This function generates the HTTP Authorization header for Tokenex payment gateway integrations. It accepts a generic ConnectorAuthType, converts it to the specific TokenexAuthType, and returns a masked API key within the Authorization header vector. It is a core utility for the Tokenex connector crate, ensuring secure credential injection during payment processing flows.", "queries": ["rust hyperswitch tokenex connector get_auth_header implementation", "how to configure authorization header for tokenex in hyperswitch", "hyperswitch tokenex connector api key masking get_auth_header", "rust hyperswitch tokenex connector authentication header generation"], "label": "Tokenex auth header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_billing_city\n    pub fn get_billing_city(&self) -> Option<String> {\n        self.billing_details\n            .as_ref()\n            .and_then(|billing| billing.address_city.clone())\n    }\n}\n// Different patterns of authentication.\n#[derive(Default, Debug, Clone, Deserialize, Serialize)]\n#[serde(tag = \"auth_type\")]", "positive": "This function retrieves the city associated with the billing address from the payment entity. It is a domain model accessor that safely returns an Option<String>, allowing the router and payment orchestration layers to display or validate billing information without panicking on null values. It is typically used in checkout flows to display the customer's billing location.", "queries": ["how to get billing city from payment object rust hyperswitch", "hyperswitch get_billing_city function implementation", "rust Option<String> billing address city retrieval", "hyperswitch domain models router_data billing details"], "label": "billing city retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "get_billing_city", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: CoverageRequests\npub enum CoverageRequests {\n    Fraud, // use when you need a financial guarantee for Payment Fraud.\n    Inr,   // use when you need a financial guarantee for Item Not Received.\n    Snad, // use when you need a financial guarantee for fraud alleging items are Significantly Not As Described.\n    All,  // use when you need a financial guarantee on all chargebacks.\n    None, // use when you do not need a financial guarantee. Suggested actions in decision.checkpointAction are recommendations.\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This enum defines the scope of fraud coverage for Signifyd chargebacks within the payment orchestration flow. It allows merchants to specify the type of financial guarantee required, such as Fraud, Inr (Item Not Received), Snad (Significantly Not As Described), or All. The enum is used to configure the decision logic in the Signifyd connector transformer, determining which specific chargeback scenarios are covered by the fraud guarantee before triggering the appropriate webhook or refund action.", "queries": ["Signifyd fraud coverage enum values", "how to configure Signifyd chargeback coverage in hyperswitch", "Signifyd fraud types enum definition", "hyperswitch signifyd fraud guarantee options"], "label": "Signifyd fraud coverage enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "CoverageRequests", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: CustomerInfo\npub struct CustomerInfo {\n    pub customer_id: Option<id_type::CustomerId>,\n    pub customer_email: Option<common_utils::pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub customer_phone_number: Option<Secret<String>>,\n    pub customer_phone_country_code: Option<String>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "positive": "The CustomerInfo struct in hyperswitch_domain_models defines the core identity and contact details for a payer. It encapsulates optional fields for customer_id, email, name, and phone number (including country code), utilizing Secret types for sensitive data. This domain model serves as the primary input for payment flows, ensuring that the orchestrator has the necessary payer context to route transactions, validate KYC requirements, and trigger subsequent actions like webhooks or refunds. It is a fundamental component of the router's request payload structure.", "queries": ["hyperswitch CustomerInfo struct definition", "how to define customer details in hyperswitch rust domain models", "CustomerInfo struct fields hyperswitch payment orchestration", "hyperswitch domain models CustomerInfo source code"], "label": "CustomerInfo struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "CustomerInfo", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` method in the JuspayThreeDSServer connector serves as the primary interface for constructing the HTTP headers required to communicate with the Juspay 3DS Server API. It accepts a `PaymentsAuthorizeRouterData` struct containing the authorization request context and a `Connectors` registry, then delegates to `build_headers` to assemble the payload. This function is critical for ensuring the request is authenticated and properly routed by the upstream provider, handling the specific header requirements for the Juspay 3DS protocol within the Hyperswitch payment orchestration framework.", "queries": ["rust hyperswitch juspay three ds server connector get_headers implementation", "how to configure headers for juspay three ds server in hyperswitch rust", "hyperswitch juspaythreedsserver get_headers function source code", "juspay three ds server connector rust hyperswitch build_headers"], "label": "Juspay 3DS Server header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: PaymentsCaptureRequest\npub struct PaymentsCaptureRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_txn_id: String,\n}\n#[derive(Debug, Serialize)]\n#[serde(rename = \"txn\")]", "positive": "This struct defines the input parameters for capturing a payment transaction within the Elavon connector. It encapsulates sensitive credentials (SSL Account ID, User ID, PIN) and transactional data (Type, Amount, Transaction ID) required to process the capture request. It is mapped to the 'txn' field in the Elavon API payload, serving as the primary data transfer object for the PaymentsCaptureRequest function.", "queries": ["Elavon PaymentsCaptureRequest struct definition", "Rust struct for Elavon capture transaction", "hyperswitch elavon connector capture request fields", "Elavon API request body mapping rust struct"], "label": "Elavon Capture Request Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "PaymentsCaptureRequest", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response\n    fn get_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Err(err_res) => {\n                    logger::error!(error_response=?err_res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting response, received error response: {err_res:?}\"\n                    ))\n                }\n                Ok(res) => Ok(res),\n            })\n    }\n}\n\n#[inline]", "positive": "The `get_response` method is a utility function within the Router crate, designed to handle the finalization of HTTP responses returned by downstream payment connectors. It performs error context propagation by mapping any internal `RouterResult` errors into a standardized `ApiErrorResponse::InternalServerError`. The function specifically checks the inner result of the connector response: if an error response is received, it logs the error details and returns an internal server error with a descriptive printable message. If a successful response is received, it passes it through unmodified, ensuring the orchestration layer cleanly surfaces connector failures or successes to the client.", "queries": ["how to handle connector response errors in hyperswitch router", "hyperswitch router get_response function error handling", "rust router crate connector response mapping", "hyperswitch utils.rs get_response implementation"], "label": "Router response error handling", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "get_response", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Authipay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Authipay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for the Authipay connector within the Hyperswitch payment orchestration platform. It specifies the data flow for tokenizing payment methods, handling payment requests, and processing refunds. The implementation is currently marked as 'Not Implemented' (R), indicating it serves as a placeholder or stub for future development. It relies on the `ConnectorIntegration` trait for core logic and `ConnectorCommonExt` for shared utility functions.", "queries": ["Authipay connector integration implementation rust hyperswitch", "hyperswitch Authipay payment method tokenization not implemented", "Authipay connector trait definition rust code", "hyperswitch Authipay refund implementation stub"], "label": "Authipay connector integration stub", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CmdLineConf\npub struct CmdLineConf {\n    /// Config file.\n    /// Application will look for \"config/config.toml\" if this option isn't specified.\n    #[arg(short = 'f', long, value_name = \"FILE\")]\n    pub config_path: Option<PathBuf>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "positive": "The `CmdLineConf` struct in `hyperswitch` serves as the configuration entry point for the router binary, specifically designed to handle command-line argument parsing. It utilizes the `clap` crate to define the `-f` or `--config-path` flag, which allows operators to override the default runtime configuration file location. By default, if no path is specified, the application automatically loads settings from the standard `config/config.toml` directory. This struct is a foundational component of the router's startup sequence, ensuring that the orchestration platform can adapt its configuration based on deployment environment or specific runtime requirements without modifying the binary itself.", "queries": ["how to specify custom config file path for hyperswitch router", "hyperswitch router config_path argument default location", "CmdLineConf struct usage in hyperswitch router binary", "clap argument parsing for hyperswitch config file"], "label": "Router CLI Config Entry", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "CmdLineConf", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_card_data\n    pub fn get_card_data(&self) -> Option<&Card> {\n        if let Self::Card(card) = self {\n            Some(card)\n        } else {\n            None\n        }\n    }\n", "positive": "This function retrieves the specific Card entity from a generic PaymentMethodData enum variant. It is used within the domain models layer to safely access card-specific attributes (like PAN, expiry, CVV) when the payment method type is known to be a card. It returns a reference to the Card struct if the variant matches, or None otherwise, ensuring type safety during payment orchestration flows.", "queries": ["rust hyperswitch get_card_data function implementation", "how to extract card details from PaymentMethodData enum", "hyperswitch domain models Card variant access", "rust Option<&Card> pattern in hyperswitch payment methods"], "label": "Card data extraction from enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "get_card_data", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: globepay::GlobepayErrorResponse = res\n            .response\n            .parse_struct(\"GlobepayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.return_code.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: Some(response.return_msg),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse from a Globepay API response. It deserializes the raw HTTP response into a GlobepayErrorResponse struct, logs the details, and maps the specific return code and message into the platform's unified error format. It also optionally populates a ConnectorEvent with the error details for downstream processing or auditing.", "queries": ["how to handle Globepay API error responses in Rust", "build_error_response function implementation hyperswitch", "parse GlobepayErrorResponse struct in Rust", "hyperswitch error handling connector Globepay"], "label": "Globepay error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AcquirerDetails\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]", "positive": "The `AcquirerDetails` struct in the `api_models` crate defines the core data model for capturing essential details about the payment acquirer (e.g., bank or processor) associated with a transaction. It encapsulates the acquirer's BIN (Bank Identification Number), Merchant ID, and the country code of the merchant. This struct is a fundamental component of the API models, used to serialize and deserialize acquirer information in payment requests and responses, ensuring that downstream systems like the router and connectors have the necessary context to process and route transactions correctly.", "queries": ["Rust struct for acquirer details in hyperswitch", "Hyperswitch AcquirerDetails struct definition", "api_models AcquirerDetails fields BIN merchant_id", "Hyperswitch payment orchestration acquirer data model"], "label": "AcquirerDetails struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__api_models__src__authentication.rs", "path": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "symbol": "AcquirerDetails", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "positive": "This function constructs the HTTP headers required for authenticating and formatting requests sent to the Juspay 3DS Server connector. It dynamically retrieves the Content-Type based on the connector's configuration and generates an Authorization header using the specific authentication type defined in the request context. The resulting vector of tuples is used to populate the outgoing HTTP request, ensuring secure and compliant communication with the external payment gateway.", "queries": ["how to configure authentication headers for juspay 3ds server in hyperswitch", "rust function to build headers for juspaythreedsserver connector hyperswitch", "hyperswitch juspaythreedsserver build_headers implementation", "how does hyperswitch handle content type and auth headers for juspay 3ds"], "label": "Juspay 3DS Server Header Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_characters.contains(&g));\n\n        if is_empty_or_whitespace || is_too_long || contains_forbidden_characters {\n            Err(UserErrors::NameParsingError.into())\n        } else {\n            Ok(Self(name.into()))\n        }\n    }\n", "positive": "This `new` constructor in `crates/router/src/types/domain/user.rs` validates user name inputs for the Hyperswitch payment orchestration platform. It enforces strict sanitization rules by rejecting empty, whitespace-only, or excessively long names (exceeding `consts::user::MAX_NAME_LENGTH`). It also blocks specific forbidden characters like `/`, `(`, `)`, and `{` to prevent injection or parsing issues within the router's domain models. The function returns a `UserResult<Self>`, ensuring that invalid names result in a `UserErrors::NameParsingError` rather than a panic, which is critical for maintaining data integrity in the router's PostgreSQL tenant schemas.", "queries": ["rust hyperswitch user name validation constructor", "hyperswitch router User type new function forbidden characters", "how to create User object in hyperswitch with validation", "hyperswitch user name length limit and parsing error"], "label": "User name validation constructor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "new", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            cybersource::CybersourceErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Cybersource ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::CybersourceErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.message.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                         \n\n... [truncated 2707 chars] ...\n\n& \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"cybersource\")\n            }\n        }\n    }\n}\n", "positive": "The `build_error_response` function in the `cybersource` connector handles parsing and standardizing error responses from the Cybersource API. It extracts error codes, messages, and detailed reasons from the API's JSON payload, transforming them into a consistent `ErrorResponse` format. This function is critical for error handling, logging, and propagating accurate failure information to the router, ensuring downstream systems understand the specific nature of a transaction failure. It also optionally populates an event builder for audit trails.", "queries": ["How to parse Cybersource API error response in Rust", "Rust hyperswitch cybersource connector error handling", "Standardize Cybersource error response format hyperswitch", "Implement error parsing logic for Cybersource connector"], "label": "Cybersource error response parser", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 134}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsCaptureData\npub struct PaymentsCaptureData {\n    pub amount_to_capture: i64,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub payment_amount: i64,\n    pub multiple_capture_data: Option<MultipleCaptureRequestData>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub browser_info: Option<BrowserInformation>,\n    pub metadata: Option<serde_json::Value>,\n    // This metadata is used to store the metadata shared during the payment intent request.\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n    // New amount for amount frame work\n    pub minor_payment_amount: MinorUnit,\n    pub minor_amount_to_capture: MinorUnit,\n    pub integrity_object: Option<CaptureIntegrityObject>,\n    pub webhook_url: Option<String>,\n    pub merchant_order_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "positive": "The PaymentsCaptureData struct defines the input payload for capturing funds from a payment intent. It includes core financial fields like amount_to_capture, currency, and connector_transaction_id, alongside metadata fields such as browser_info and split_payments. Crucially, it supports the 'amount framework' via minor_payment_amount and minor_amount_to_capture, and includes an integrity_object for security verification. This struct is used by the router and drainer to orchestrate the capture flow, ensuring funds are released to connectors while maintaining strict validation and metadata tracking.", "queries": ["rust struct for payment capture data with minor units", "hyperswitch payments capture payload fields", "PaymentsCaptureData struct definition rust hyperswitch", "how to construct payments capture request rust"], "label": "PaymentsCaptureData struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "PaymentsCaptureData", "unit_type": "function", "num_lines": 21}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_refund_id_type\npub async fn find_payment_intent_from_refund_id_type(\n    state: &SessionState,\n    refund_id_type: webhooks::RefundIdType,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let refund = match refund_id_type {\n        webhooks::RefundIdType::RefundId(id) => db\n            .find_refund_by_merchant_id_refund_id(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n        webhooks::RefundIdType::ConnectorRefundId(id) => db\n            .find_refund_by_merchant_id_connector_refund_id_connector(\n                platform.get_processor().get_account().get_id(),\n                &id,\n                connector_name,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::RefundNotFound)?,\n    };\n    let attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &refund.attempt_id,\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &attempt.payment_id,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "positive": "This function retrieves a PaymentIntent by traversing a Refund record. It accepts a RefundIdType (either internal merchant ID or external connector ID) and a connector name. It first queries the database to locate the Refund using the provided ID and storage scheme, then locates the associated PaymentAttempt, and finally retrieves the PaymentIntent linked to that attempt. It returns a CustomResult<PaymentIntent> and handles not-found scenarios by converting them into ApiErrorResponse::RefundNotFound or ApiErrorResponse::PaymentNotFound.", "queries": ["how to find payment intent from refund id type in hyperswitch", "hyperswitch find_payment_intent_from_refund_id_type implementation", "rust code for retrieving payment intent via refund lookup", "hyperswitch router utils find_payment_intent_from_refund_id_type"], "label": "PaymentIntent retrieval via Refund lookup", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "find_payment_intent_from_refund_id_type", "unit_type": "function", "num_lines": 46}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: RecipientType\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "positive": "The `RecipientType` enum in `hyperswitch_connectors/src/connectors/wise/transformers.rs` defines the supported types for payment recipients within the Wise connector integration. It includes `Aba`, `Iban`, `SortCode`, and `SwiftCode`, which are mapped to the Wise API's recipient types. This enum is crucial for transforming Hyperswitch's generic recipient models into Wise-specific formats, ensuring accurate payout routing and compliance with Wise's banking standards. It is primarily used in the Wise payout transformer to handle international and domestic transfers, leveraging the `#[serde(rename_all = \"UPPERCASE\")]` attribute for serialization compatibility.", "queries": ["How to configure recipient type for Wise payouts in Hyperswitch", "Rust enum RecipientType Wise connector implementation", "Hyperswitch Wise transformer recipient types Aba Iban SortCode", "Wise API recipient type mapping Hyperswitch Rust"], "label": "Wise recipient type enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "RecipientType", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n", "positive": "This function constructs the HTTP headers required for authenticating requests to the Airwallex connector. It specifically generates a Bearer token header using the access token retrieved from the incoming `RouterData` flow context. It also ensures the Content-Type header is set according to the connector's configuration. The function is critical for establishing a secure connection with the Airwallex API, handling authentication errors by returning a `FailedToObtainAuthType` error if the token is missing.", "queries": ["how to configure bearer token authentication in Airwallex connector", "rust function to generate authorization header for Airwallex API", "hyperswitch Airwallex connector build_headers implementation", "how does hyperswitch handle access tokens in Airwallex integration"], "label": "Airwallex auth header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 24}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: MerchantURLs\npub struct MerchantURLs {\n    terms: String,\n    checkout: String,\n    confirmation: String,\n    push: String,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "positive": "This struct encapsulates the merchant-specific URLs required for the Klarna payment flow, specifically handling the redirect lifecycle. It manages the URLs for the merchant's Terms of Service, the Checkout page, the Confirmation page, and the Push notification endpoint. These fields are critical for the Klarna connector to correctly route the user after payment authorization and to receive real-time status updates via the Push API. The struct is serialized and deserialized to facilitate data transfer between the Hyperswitch orchestration layer and the Klarna API response.", "queries": ["how to configure Klarna merchant URLs in hyperswitch", "Klarna push notification URL configuration hyperswitch", "hyperswitch Klarna connector merchant urls struct", "Klarna checkout confirmation URL hyperswitch"], "label": "Klarna merchant URLs struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "symbol": "MerchantURLs", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_5xx_error_response\n    fn get_5xx_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: wellsfargo::WellsfargoServerErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargoServerErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|event| event.set_response_body(&response));\n        router_env::logger::info!(error_response=?response);\n\n        let attempt_status = match response.reason {\n            Some(reason) => match reason {\n                transformers::Reason::SystemError => Some(enums::AttemptStatus::Failure),\n                transformers::Reason::ServerTimeout | transformers::Reason::ServiceTimeout => None,\n            },\n            None => None,\n        };\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            reason: response.status.clone(),\n            code: response\n                .status\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string()),\n            message: response\n                .message\n                .unwrap_or(hyperswitch_interfaces::consts::NO_ERROR_MESSAGE.to_string()),\n            attempt_status,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function handles 5xx server errors from the Wells Fargo connector by deserializing the server response into a structured error object. It logs the error details and determines the `AttemptStatus` based on the response reason, specifically mapping `SystemError` to `Failure` while treating timeouts as retryable. The function populates an `ErrorResponse` struct with status codes, messages, and metadata, and optionally updates the connector event builder with the raw response body before returning the error.", "queries": ["how to handle 5xx errors in hyperswitch wells fargo connector", "wellsfargo connector error response mapping to AttemptStatus", "rust hyperswitch connector error handling 5xx server error", "hyperswitch wells fargo get_5xx_error_response function implementation"], "label": "Wells Fargo 5xx Error Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "get_5xx_error_response", "unit_type": "function", "num_lines": 40}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: ConnectorValidation\nimpl ConnectorValidation for Nordea {}\n\nimpl\n    ConnectorIntegration<\n        AccessTokenAuthentication,\n        AccessTokenAuthenticationRequestData,\n        AccessTokenAuthenticationResponse,\n    > for Nordea\n{", "positive": "This function implements the `ConnectorValidation` trait for the Nordea connector within the Hyperswitch payment orchestration platform. It serves as the validation entry point for the `AccessTokenAuthentication` integration strategy, ensuring that the API credentials provided by the merchant are structurally correct and valid before attempting to establish a connection. It acts as a specific implementation hook within the `hyperswitch_connectors` crate, handling the pre-flight checks required by the Nordea payment gateway integration.", "queries": ["how to implement connector validation for nordea access token authentication", "rust connector validation trait implementation nordea hyperswitch", "hyperswitch nordea connector access token authentication validation", "nordea payment gateway connector validation implementation rust"], "label": "Nordea Access Token Validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "ConnectorValidation", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: globepay::GlobepayPaymentsResponse = res\n            .response\n            .parse_struct(\"Globepay PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the Globepay payment gateway following an authorization request. It deserializes the raw response body into a `GlobepayPaymentsResponse` struct using `parse_struct`. It updates the optional `ConnectorEvent` builder with the response details and logs the payload for observability. Finally, it constructs a `RouterData` instance containing the parsed response, the original request data, and the HTTP status code to facilitate downstream routing and processing within the Hyperswitch orchestrator.", "queries": ["how to handle globepay authorization response in hyperswitch", "rust function deserializing globepay response struct", "hyperswitch connector handle_response implementation", "globepay payments authorize response parsing rust"], "label": "Globepay authorization response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 21}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` function in the `Payone` connector is responsible for constructing and returning the HTTP headers required for outgoing payout requests. It acts as a specific implementation of the generic `build_headers` method, tailored to the Payone API's authentication and metadata requirements. This function is a critical integration point, ensuring that every payout request sent to Payone includes the necessary authorization tokens, content types, and custom identifiers for tracking and security. It is called by the payout orchestration logic within the `PayoutsRouterData` context, bridging the domain's payout intent with the external Payone gateway's specific communication protocol.", "queries": ["how to configure payone payout headers in hyperswitch", "hyperswitch payone connector get_headers implementation", "rust hyperswitch payone payout authentication headers", "payone payout request header construction hyperswitch"], "label": "Payone Payout Headers", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "positive": "This function constructs the HTTP headers required for outbound API requests within the Sift connector. It dynamically generates the Content-Type header based on the connector's configuration and retrieves authentication credentials (API key) from the request context using the specified auth type. The resulting headers are returned as a vector of tuples, ensuring proper authorization and data format specification for the external Sift service integration.", "queries": ["how to configure Sift connector authentication headers in hyperswitch", "rust hyperswitch sift connector build_headers implementation", "hyperswitch sift payment connector header setup", "sift connector hyperswitch rust get_auth_header usage"], "label": "Sift connector header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` method within the Sift connector implementation serves as the primary interface for constructing the HTTP request headers required to authenticate and authorize transactions with the Sift payment processor. It leverages the `build_headers` helper to dynamically assemble credentials, including the Sift API Key and specific request identifiers, ensuring secure communication with the external service. This function is invoked by the router's `PaymentsAuthorizeRouterData` flow to prepare the authorization request payload before transmission.", "queries": ["rust hypersift connector get_headers implementation", "how to configure sift api key headers in hyperswitch rust", "hyperswitch sift connector authorization header setup", "rust code for sift payment connector request headers"], "label": "Sift connector auth headers", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_name\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "positive": "This function retrieves a list of MerchantConnectorAccount records associated with a specific merchant ID and connector name. It acts as a critical lookup layer within the storage_impl crate, bridging the domain layer's request for account configurations with the underlying router_store implementation. The function accepts a MerchantKeyStore reference to handle cryptographic keys securely and returns a vector of domain objects, ensuring that the orchestration platform can dynamically select the correct payment gateway credentials and settings for a given transaction flow.", "queries": ["how to find merchant connector account by merchant id and connector name", "rust hyperswitch find_merchant_connector_account_by_merchant_id_connector_name implementation", "hyperswitch storage_impl merchant connector account lookup", "merchant connector account retrieval function signature rust"], "label": "merchant connector account lookup", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "find_merchant_connector_account_by_merchant_id_connector_name", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: thunes::ThunesErrorResponse = res\n            .response\n            .parse_struct(\"ThunesErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,\n            message: response.message,\n            reason: response.reason,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a raw HTTP Response received from the Thunes connector. It parses the response body into a ThunesErrorResponse struct and logs the details for observability. It then populates a new ErrorResponse with the status code, error code, message, and reason, while initializing optional fields like network advice codes and metadata to None. This ensures the router can handle connector failures uniformly regardless of the specific provider's error format.", "queries": ["rust hyperswitch thunes connector error response builder", "how to handle thunes api error in hyperswitch", "hyperswitch thunes connector build_error_response implementation", "thunes connector error parsing hyperswitch rust"], "label": "Thunes connector error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: get_api_event_type\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        self.authentication_id\n            .as_ref()\n            .map(|id| ApiEventsType::Authentication {\n                authentication_id: id.clone(),\n            })\n    }\n}\n", "positive": "This method retrieves the specific API event type associated with an authentication record. It checks the internal `authentication_id` field and returns a `Some(ApiEventsType::Authentication)` containing the cloned ID if present, or `None` if the ID is absent. This function is critical for the webhook dispatcher, specifically within `incoming_webhooks_wrapper`, to correctly categorize incoming authentication events and trigger the appropriate downstream flows.", "queries": ["how to get api event type from authentication id", "rust hyperswitch authentication event type mapping", "get_api_event_type function implementation hyperswitch", "hyperswitch authentication webhook event type handling"], "label": "Authentication event type mapper", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__api_models__src__authentication.rs", "path": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "symbol": "get_api_event_type", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.access_token.peek(),\n            auth.security_token.peek()\n        );\n        let auth_header = format!(\"Basic {}\", consts::BASE64_ENGINE.encode(auth_key));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_header.into_masked(),\n        )])\n    }\n", "positive": "This function constructs the HTTP Basic Authentication header required for Gigadat API requests. It accepts a `ConnectorAuthType` enum, converts it to a `GigadatAuthType`, and combines the access token and security token into a base64-encoded string. The resulting header is returned as a masked tuple within a vector, ensuring sensitive credentials are handled securely before being sent to the Gigadat connector.", "queries": ["how to generate basic auth header for gigadat connector hyperswitch", "rust hyperswitch gigadat connector authentication implementation", "hyperswitch gigadat get_auth_header function source code", "gigadat connector hyperswitch basic auth token generation"], "label": "Gigadat Basic Auth Header", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 18}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let mut endpoint = match req.request.is_auto_capture()? {\n            true => \"sale\",\n            false => \"auth\",\n        }\n        .to_string();\n        // 3ds payments uses different endpoints\n        if req.auth_type == AuthenticationType::ThreeDs {\n            endpoint.insert_str(0, \"spi/\")\n        };\n        Ok(format!(\"{}{endpoint}\", self.base_url(connectors)))\n    }\n", "positive": "This function constructs the specific API endpoint URL for Powertranz payment transactions based on the authorization request context. It dynamically appends 'sale' or 'auth' suffixes depending on the `is_auto_capture` flag and prepends 'spi/' for ThreeDs authentication types, ensuring the router sends the correct HTTP verb to the connector's base URL.", "queries": ["how to configure Powertranz auto capture endpoint in hyperswitch", "hyperswitch powertranz 3ds spi endpoint url construction", "rust hyperswitch powertranz connector get_url implementation", "hyperswitch powertranz payment method sale vs auth endpoint"], "label": "Powertranz URL construction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_pools_map\n    pub async fn get_pools_map(\n        &self,\n        analytics_config: &AnalyticsConfig,\n    ) -> HashMap<id_type::TenantId, AnalyticsProvider> {\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            (\n                tenant_name.clone(),\n                AnalyticsProvider::from_conf(analytics_config, tenant).await,\n            )\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n}\n#[derive(Debug, Deserialize, Clone, Default)]", "positive": "This function retrieves a mapping of Tenant IDs to their specific AnalyticsProvider configurations. It iterates over the internal tenant registry, concurrently initializing each provider using the provided global AnalyticsConfig and the tenant-specific settings. The result is a HashMap where keys are Tenant IDs and values are fully initialized provider instances, facilitating dynamic analytics routing per tenant.", "queries": ["How to configure analytics providers for multiple tenants in hyperswitch router", "Rust function to get analytics provider map from tenant config", "hyperswitch router get_pools_map implementation", "How does router handle analytics configuration for different tenants"], "label": "Tenant Analytics Provider Mapping", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "get_pools_map", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: SslResult\nenum SslResult {\n    #[serde(rename = \"0\")]\n    ImportedBatchFile,\n    #[serde(other)]\n    DeclineOrUnauthorized,\n}\n\n#[derive(Debug, Clone, Serialize)]", "positive": "This `SslResult` enum defines the response status for SSL/TLS certificate validation failures within the Elavon connector. It maps the specific error code '0' to `ImportedBatchFile` and any other status to `DeclineOrUnauthorized`. This structure is used to deserialize the raw error payload from Elavon's API, ensuring that certificate-related batch import failures are correctly categorized before being transformed into a standard payment decline response.", "queries": ["Elavon SSL certificate validation error handling", "SslResult enum definition Elavon connector", "Elavon API error code 0 mapping", "Rust enum for SSL certificate validation failures"], "label": "Elavon SSL validation error enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "SslResult", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Creditor\npub enum Creditor {\n    FasterPayments {\n        #[serde(rename = \"sortCode\")]\n        sort_code: Secret<String>,\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Sepa {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    SepaInstant {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirIban {\n        iban: Secret<String>,\n        name: Secret<String>,\n    },\n    ElixirAccount {\n        #[serde(rename = \"accountNumber\")]\n        account_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Bankgiro {\n        #[serde(rename = \"bankgiroNumber\")]\n        bankgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n    Plusgiro {\n        #[serde(rename = \"plusgiroNumber\")]\n        plusgiro_number: Secret<String>,\n        name: Secret<String>,\n    },\n}\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "positive": "The `Creditor` enum in the `hyperswitch_connectors` crate defines the structure for creditor information across various payment schemes. It supports multiple formats like FasterPayments (with sort code and account number), SEPA (IBAN), and local schemes such as Bankgiro and Plusgiro. This enum is used within the tokenization and transformer logic to map incoming payment instructions into a standardized internal representation, ensuring compatibility with the router's orchestration engine.", "queries": ["How to define a FasterPayments creditor in hyperswitch?", "Rust enum for SEPA creditor hyperswitch tokenization", "Hyperswitch connector creditor structure IBAN", "Bankgiro creditor definition hyperswitch rust"], "label": "Creditor enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "Creditor", "unit_type": "function", "num_lines": 39}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_co_badged_card_data\n    pub fn get_co_badged_card_data(&self) -> Option<&payment_methods::CoBadgedCardData> {\n        if let Self::Card(card) = self {\n            card.co_badged_card_data.as_ref()\n        } else {\n            None\n        }\n    }\n", "positive": "This method retrieves the `CoBadgedCardData` struct associated with a payment method instance. It is a safe accessor pattern used within the `payment_methods` module to check if a card is branded with a co-badge (e.g., Visa/Mastercard with a local bank logo) and retrieve the specific metadata for that badge. It returns `None` if the instance is not a Card type or if no co-badge data exists. This function is critical for displaying localized payment options and handling specific card network rules in the domain models layer.", "queries": ["how to access co-badge data for a payment method in Rust", "hyperswitch get_co_badged_card_data implementation", "rust payment method co badge data retrieval", "hyperswitch domain models card co badge"], "label": "Payment Method Co-Badge Data Accessor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "get_co_badged_card_data", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_refund_id_connector\n    async fn find_refund_by_merchant_id_connector_refund_id_connector(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_refund_id: &str,\n        connector: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n", "positive": "This function retrieves a refund record from the database using a composite key consisting of the merchant ID, connector name, and the specific refund ID assigned by the external payment processor. It is a core data access method used within the router's refund handling logic to locate transaction details for reconciliation, status updates, or retrieval of refund metadata associated with a specific connector implementation. The method accepts the storage scheme to ensure correct schema isolation for multi-tenant environments.", "queries": ["rust hyperswitch router find refund by merchant id connector refund id", "hyperswitch db query get refund details using connector refund id", "how to query refund table by merchant and connector in hyperswitch", "rust function find_refund_by_merchant_id_connector_refund_id_connector implementation"], "label": "refund db lookup by connector id", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "find_refund_by_merchant_id_connector_refund_id_connector", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: try_from\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]", "positive": "This function implements the TryFrom trait for the Klarna connector metadata structure, converting a raw SecretSerdeValue into a validated connector metadata object. It utilizes a utility function, `to_connector_meta_from_secret`, to deserialize the sensitive data into the specific struct type. The function includes error handling via `change_context` to wrap deserialization failures into a `ConnectorError::InvalidConnectorConfig` with the 'metadata' key, ensuring that malformed or invalid secret configurations are caught and reported during the connector initialization phase.", "queries": ["how to convert SecretSerdeValue to Klarna metadata struct", "Klarna connector metadata deserialization error handling", "try_from implementation for Klarna metadata in hyperswitch", "hyperswitch Klarna connector config validation SecretSerdeValue"], "label": "Klarna metadata deserialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payout_attempt\npub async fn get_mca_from_payout_attempt(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payout_id_type: webhooks::PayoutIdType,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let payout = match payout_id_type {\n        webhooks::PayoutIdType::PayoutAttemptId(payout_attempt_id) => db\n            .find_payout_attempt_by_merchant_id_payout_attempt_id(\n                platform.get_processor().get_account().get_id(),\n                &payout_attempt_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n        webhooks::PayoutIdType::ConnectorPayoutId(connector_payout_id) => db\n            .find_payout_attempt_by_merchant_id_connector_payout_id(\n                platform.get_processor().get_account().get_id(),\n                &connector_payout_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n    };\n    match payout.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = platform.get_processor().get_key_store();\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &payout.profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {}\",\n                            payout.profile_id.get_string_repr(),\n                            connector_name\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                todo!()\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "positive": "This utility function resolves a MerchantConnectorAccount (MCA) from a PayoutAttempt using either a PayoutAttemptId or a ConnectorPayoutId. It handles the 'v1' feature flag by querying the database for the MCA via merchant_connector_id or by falling back to a profile_id and connector_name lookup. The 'v2' feature flag path is currently stubbed with 'todo!' implementations, indicating pending logic for the newer architecture. It is called within webhook handlers to ensure the correct account context exists before processing payout-related events.", "queries": ["rust hyperswitch get_mca_from_payout_attempt implementation", "how to resolve merchant connector account from payout attempt id hyperswitch", "hyperswitch router utils get_mca_from_payout_attempt v1 v2 feature flag", "find merchant connector account by payout attempt hyperswitch rust"], "label": "Payout MCA Resolution Utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "get_mca_from_payout_attempt", "unit_type": "function", "num_lines": 78}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function, `get_error_response`, acts as a specialized error handler within the `Globepay` connector implementation. It accepts an HTTP `Response` object and an optional `ConnectorEvent` builder to construct a standardized `ErrorResponse`. Crucially, it delegates the actual construction logic to `build_error_response`, ensuring that error details are normalized and mapped to the platform's internal error types before being returned to the router. This method is vital for maintaining consistency across the Hyperswitch payment orchestration platform, allowing the router to handle connector failures uniformly regardless of the underlying provider's specific error format.", "queries": ["how to handle Globepay connector errors in Rust hyperswitch", "implementing get_error_response for custom payment connectors", "hyperswitch globepay connector error handling pattern", "Rust function to build error response from HTTP response"], "label": "Globepay error handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_unified_connector_service_payment_method\npub fn build_unified_connector_service_payment_method(\n    payment_method_data: hyperswitch_domain_models::payment_method_data::PaymentMethodData,\n    payment_method_type: Option<PaymentMethodType>,\n) -> CustomResult<payments_grpc::PaymentMethod, UnifiedConnectorServiceError> {\n    match payment_method_data {\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::Card(card) => {\n            let card_exp_month = card\n                .get_card_expiry_month_2_digit()\n                .attach_printable(\"Failed to extract 2-digit expiry month from card\")\n                .change_context(UnifiedConnectorServiceError::InvalidDataFormat {\n                    field_name: \"card_exp_month\",\n                })?\n                .peek()\n                .to_string();\n\n            let card_network = card\n                .card_network\n                .clone()\n                .map(payments_grpc::CardNetwork::foreign_from);\n\n            let card_details = CardDetails {\n                card_number: Some(\n                    CardNumber::from_str(&card.card_number.get_card_no()).change_context(\n                        UnifiedConnectorServiceError::RequestEncodingFailedWithReason(\n                            \"Failed to parse card number\".to_string(),\n                        ),\n                    )?,\n                ),\n                card_exp_month: Some(card_exp_month.into()),\n                card_exp_year: Some(card.card_exp_year.expose().into()),\n                card_cvc: Some(card.card_cvc.expose().into()),\n                card_holder_name: card.card_holder_name.map(|name| name.expose().into()),\n                card_issuer: card.card_issuer.clone(),\n                card_network: card_network.map(|card_network| card_network.into()),\n                card_type: card.card_type.clone(),\n                bank_code: card.bank_code.clone(),\n                nick_name: card.nick_name.map(|n| n.expose()),\n                card_issuing_country_alpha2: card.card_issuing_country.clone(),\n            };\n\n            Ok(payments_grpc::PaymentMethod {\n                payment_method: Some(PaymentMethod::Card(card_details)),\n            })\n        }\n        hyperswitch_domain_models::payment_method_data::PaymentMethodData::CardRedirect(\n            card_redirect_data,\n        ) => {\n            let card_redirect_type = match card_redirect_data {\n                hyperswitch_domain_models::payment_method_data::CardRedirectData::K\n\n... [truncated 30673 chars] ...\n\n        hyperswitch_domain_models::payment_method_data::BankDebitData::BacsBankDebit {\n                account_number,\n                sort_code,\n                bank_account_holder_name,\n            } => {\n                let bacs = payments_grpc::Bacs {\n                    account_number: Some(account_number.expose().into()),\n                    sort_code: Some(sort_code.expose().into()),\n                    bank_account_holder_name: bank_account_holder_name\n                        .map(|name| name.expose().into()),\n                };\n\n                Ok(payments_grpc::PaymentMethod {\n                    payment_method: Some(PaymentMethod::Bacs(bacs)),\n                })\n            }\n            _ => Err(UnifiedConnectorServiceError::NotImplemented(\n                \"Unimplemented bank debit variant\".to_string(),\n            )\n            .into()),\n        },\n        _ => Err(UnifiedConnectorServiceError::NotImplemented(format!(\n            \"Unimplemented payment method: {payment_method_data:?}\"\n        ))\n        .into()),\n    }\n}\n", "positive": "This function transforms domain-specific `PaymentMethodData` structures into the gRPC `PaymentMethod` protobuf format required by the Unified Connector Service. It handles complex type mapping for various payment instruments, including Cards (processing expiry months, networks, and CVCs), Redirects, Wallets, and Bank Debits (BACS). It utilizes `change_context` for error propagation and ensures strict validation of sensitive fields like card numbers and expiry dates before serialization.", "queries": ["How to convert PaymentMethodData to gRPC PaymentMethod in Rust", "Rust function to map hyperswitch domain models to payments_grpc", "build_unified_connector_service_payment_method implementation details", "Error handling for card data transformation in hyperswitch"], "label": "PaymentMethodData to gRPC conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "build_unified_connector_service_payment_method", "unit_type": "function", "num_lines": 671}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` function in the Airwallex connector implementation serves as a dynamic header injection layer for API requests. It accepts a `ConnectorCustomerRouterData` struct containing customer-specific configurations and a `Connectors` registry, then delegates to `build_headers` to assemble authentication and metadata. This ensures that every outgoing request to the Airwallex API is properly authenticated and context-aware, handling the specific masking requirements of sensitive data like API keys or customer identifiers.", "queries": ["how to configure custom headers for airwallex connector in hyperswitch", "airwallex hyperswitch rust connector get_headers implementation", "hyperswitch airwallex connector authentication header setup", "rust function get_headers airwallex hyperswitch connector"], "label": "Airwallex connector header injection", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_filtered_payment_intents_attempt\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<(PaymentIntent, PaymentAttempt)>, Self::Error>;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]", "positive": "This function retrieves a list of PaymentIntents and their corresponding PaymentAttempts based on specific merchant and constraint criteria. It acts as a critical filtering mechanism within the domain models layer, allowing the router to fetch transaction history or specific states (like failed attempts) for a given processor merchant ID. The function accepts a `PaymentIntentFetchConstraints` struct to define the scope of the search and utilizes a `MerchantKeyStore` for cryptographic operations, returning a vector of tuples containing the intent and its associated attempt details.", "queries": ["rust hyperswitch get_filtered_payment_intents_attempt implementation", "how to fetch payment attempts by merchant id in hyperswitch", "hyperswitch domain models payment intent fetch constraints", "rust hyperswitch payment intent attempt retrieval function"], "label": "Payment intent attempt retrieval filter", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "get_filtered_payment_intents_attempt", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: check_value_validity\n    fn check_value_validity(\n        &self,\n        val: dir::DirValue,\n        analysis_ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<bool, cgraph::GraphError<dir::DirValue>>;\n", "positive": "This method validates the structural integrity of a directory value within the DSA graph, ensuring it adheres to domain constraints before processing. It integrates with the AnalysisContext to enforce business rules and uses Memoization to prevent redundant cycle checks. The function is critical for maintaining data consistency during the graph traversal phase, specifically handling optional domain restrictions to filter valid nodes.", "queries": ["how to check if a directory value is valid in rust hyperswitch", "hyperswitch dsa graph validation function check_value_validity", "rust function check_value_validity analysis context memoization", "hyperswitch dsa graph error handling validation"], "label": "DSA graph validation function", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "check_value_validity", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_convertor,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = powertranz::PowertranzRouterData::try_from((amount, req))?;\n        let connector_req =\n            powertranz::PowertranzPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function constructs the JSON payload for Powertranz payment authorization requests. It leverages the `amount_convertor` to transform the incoming `minor_amount` and `currency` into the specific format required by the Powertranz API. The function then orchestrates the data transformation pipeline by converting the router data into a `PowertranzRouterData` struct, and subsequently into a `PowertranzPaymentsRequest` struct. This ensures that the request body sent to the Powertranz connector is structurally correct and contains the necessary financial details for processing the transaction.", "queries": ["how to format Powertranz payments request body in Rust", "convert minor amount to Powertranz format hyperswitch", "PowertranzPaymentsRequest struct definition hyperswitch", "hyperswitch powertranz connector request body builder"], "label": "Powertranz request body builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: Archipel3DS\npub struct Archipel3DS {\n    #[serde(rename = \"acsTransID\")]\n    acs_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"dsTransID\")]\n    ds_trans_id: Option<Secret<String>>,\n    #[serde(rename = \"3DSRequestorName\")]\n    three_ds_requestor_name: Option<Secret<String>>,\n    #[serde(rename = \"3DSAuthDate\")]\n    three_ds_auth_date: Option<String>,\n    #[serde(rename = \"3DSAuthAmt\")]\n    three_ds_auth_amt: Option<MinorUnit>,\n    #[serde(rename = \"3DSAuthStatus\")]\n    three_ds_auth_status: Option<String>,\n    #[serde(rename = \"3DSMaxSupportedVersion\")]\n    three_ds_max_supported_version: String,\n    #[serde(rename = \"3DSVersion\")]\n    three_ds_version: Option<common_utils::types::SemanticVersion>,\n    authentication_value: Secret<String>,\n    authentication_method: Option<Secret<String>>,\n    eci: Option<String>,\n}\n", "positive": "The `Archipel3DS` struct defines the data model for 3D Secure (3DS) authentication responses specific to the Archipel payment gateway connector. It encapsulates transaction identifiers (ACS and DS Trans IDs), authentication values, and metadata such as the 3DS version, ECI flag, and authorization status. This struct is utilized within the Archipel transformer layer to map the raw JSON response from the gateway into a standardized internal format, facilitating downstream processing and validation of secure payment flows.", "queries": ["Archipel3DS struct definition rust hyperswitch", "how to parse Archipel 3DS response in hyperswitch", "hyperswitch archipel connector 3ds authentication fields", "rust struct Archipel3DS serde fields hyperswitch"], "label": "Archipel 3DS Response Model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "Archipel3DS", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: CardPaymentRequest\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_card_number: CardNumber,\n    pub ssl_exp_date: Secret<String>,\n    pub ssl_cvv2cvc2: Secret<String>,\n    pub ssl_email: Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_add_token: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_get_token: Option<String>,\n    pub ssl_transaction_currency: Currency,\n}\n#[derive(Debug, Serialize)]", "positive": "This struct, CardPaymentRequest, is a core data transfer object for the Elavon connector in the Hyperswitch payment orchestration platform. It encapsulates the specific fields required to construct a payment request for the Elavon gateway, including transaction type, account/user identifiers, sensitive card details (number, CVV), and financial metadata like amount and currency. It is designed to be serialized for API communication with Elavon, handling sensitive data securely via the Secret wrapper type and optional tokenization fields.", "queries": ["Elavon CardPaymentRequest struct definition", "Hyperswitch Elavon connector payment request fields", "Rust struct for Elavon API payment payload", "ssl_account_id ssl_user_id Elavon hyperswitch"], "label": "Elavon payment request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "CardPaymentRequest", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: RedirectForm\npub enum RedirectForm {\n    Form {\n        endpoint: String,\n        method: Method,\n        form_fields: HashMap<String, String>,\n    },\n    Html {\n        html_data: String,\n    },\n    BarclaycardAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    BarclaycardConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    BlueSnap {\n        payment_fields_token: String, // payment-field-token\n    },\n    CybersourceAuthSetup {\n        access_token: String,\n        ddc_url: String,\n        reference_id: String,\n    },\n    CybersourceConsumerAuth {\n        access_token: String,\n        step_up_url: String,\n    },\n    DeutschebankThreeDSChallengeFlow {\n        acs_url: String,\n        creq: String,\n    },\n    Payme,\n    Braintree {\n        client_token: String,\n        card_token: String,\n        bin: String,\n        acs_url: String,\n    },\n    Nmi {\n        amount: String,\n        currency: common_enums::Currency,\n        public_key: masking::Secret<String>,\n        customer_vault_id: String,\n        order_id: String,\n    },\n    Mifinity {\n        initialization_token: String,\n    },\n    WorldpayDDCForm {\n        endpoint: url::Url,\n        method: Method,\n        form_fields: HashMap<String, String>,\n        collection_id: Option<String>,\n    },\n    WorldpayxmlRedirectForm {\n        jwt: String,\n    },\n}\n", "positive": "The `RedirectForm` enum in `hyperswitch_domain_models` defines the standardized response structure for payment flows requiring a redirect to a third-party authentication or form submission page. It supports various connector-specific implementations, including standard HTML data, specific 3D Secure (3DS) flows for providers like Barclaycard and Cybersource, and token-based redirects for BlueSnap. This type is used by the router to serialize the final redirect payload returned to the client after a payment authorization or step-up authentication process.", "queries": ["Rust enum definition for RedirectForm hyperswitch", "hyperswitch RedirectForm struct fields Barclaycard", "how to handle 3DS redirect forms in hyperswitch", "hyperswitch domain models RedirectForm variant types"], "label": "RedirectForm enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "RedirectForm", "unit_type": "function", "num_lines": 62}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the core integration contract for the Helcim payment connector within the Hyperswitch payment orchestration platform. It specifies the required methods for tokenizing payment methods (`tokenize_payment_method`) and processing payments (`process_payment`), ensuring type safety with `PaymentMethodToken`, `PaymentMethodTokenizationData`, and `PaymentsResponseData`. The implementation is currently marked as 'Not Implemented (R)', indicating it is a stub or placeholder awaiting the Rust implementation logic to handle Helcim-specific API interactions, such as creating tokens and executing authorization requests.", "queries": ["Helcim connector integration implementation Rust", "hyperswitch Helcim tokenize_payment_method method", "Helcim payments response data types", "Rust connector integration trait Helcim"], "label": "Helcim connector integration stub", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PayoutsRouterData<PoFulfill>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.destination_currency,\n        )?;\n        let connector_router_data = payone::PayoneRouterData::from((amount, req));\n        let connector_req = payone::PayonePayoutFulfillRequest::try_from(connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function constructs the JSON payload for a Payone payout fulfillment request. It converts the internal minor amount to the connector's required format using the provided amount converter, then wraps the request data into a `RequestContent` struct. It is a critical step in the payout orchestration flow, translating the generic `PayoutsRouterData` into the specific `PayonePayoutFulfillRequest` expected by the Payone connector.", "queries": ["how to format payout request body for payone connector", "convert amount for payone payout fulfillment request", "payone connector payout request payload structure", "rust payone payout fulfillment request builder"], "label": "Payone payout request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsPostSessionTokensData\npub struct PaymentsPostSessionTokensData {\n    // amount here would include amount, surcharge_amount and shipping_cost\n    pub amount: MinorUnit,\n    /// original amount sent by the merchant\n    pub order_amount: MinorUnit,\n    pub currency: storage_enums::Currency,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n    /// if the connector provides support to accept multiple reference ids.\n    /// In case the connector supports only one reference id, Hyperswitch's Payment ID will be sent as reference.\n    pub merchant_order_reference_id: Option<String>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub router_return_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "positive": "This struct defines the input payload for the POST /payments/session-tokens endpoint within the Hyperswitch router. It encapsulates financial details (amount, currency, order_amount), shipping logistics (shipping_cost), and merchant configuration (merchant_order_reference_id, setup_future_usage, router_return_url). It serves as the domain model for initiating a session token request, mapping client-side payment data to internal storage enums and preparing context for connector interaction.", "queries": ["Hyperswitch PaymentsPostSessionTokensData struct definition", "Rust struct for POST /payments/session-tokens payload", "Hyperswitch router request types amount shipping_cost", "PaymentsPostSessionTokensData merchant_order_reference_id field"], "label": "Router request payload struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "PaymentsPostSessionTokensData", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateResponse\npub struct WiseRecipientCreateResponse {\n    id: i64,\n    business: Option<i64>,\n    profile: Option<i64>,\n    account_holder_name: Secret<String>,\n    currency: String,\n    country: String,\n    #[serde(rename = \"type\")]\n    request_type: String,\n    details: Option<WiseBankDetails>,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This struct defines the response payload for creating a Wise recipient during payout flows. It encapsulates the generated recipient ID, associated business and profile identifiers, and sensitive account details like the account holder name. The `request_type` field distinguishes the specific recipient configuration, while the `details` field holds the parsed Wise bank account information. This data is typically returned by the `WiseRecipientCreate` transformer in `hyperswitch_connectors` and consumed by the payout orchestration logic to finalize the transfer instruction.", "queries": ["Rust struct WiseRecipientCreateResponse definition", "hyperswitch payouts Wise recipient creation response fields", "WiseRecipientCreateResponse serde camelCase mapping", "how to handle Wise bank details in hyperswitch payout"], "label": "Wise payout recipient creation response", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "WiseRecipientCreateResponse", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateRequest\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]", "positive": "This struct defines the request payload for creating a new Wise recipient, a prerequisite for processing payouts. It encapsulates essential financial details like currency, recipient type (individual or company), and sensitive profile/account holder information. The `Secret` wrapper indicates sensitive data requiring secure handling. This struct is used within the Wise connector's transformer layer to map internal API models to Wise's specific recipient creation schema, facilitating the integration of Wise's payout infrastructure into the Hyperswitch orchestration platform.", "queries": ["How to create a Wise recipient in Rust hyperswitch", "WiseRecipientCreateRequest struct definition hyperswitch", "Hyperswitch Wise connector payout recipient creation", "Rust struct WiseRecipientCreateRequest fields"], "label": "Wise recipient creation request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "WiseRecipientCreateRequest", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: AuthorizeSessionTokenData\npub struct AuthorizeSessionTokenData {\n    pub amount_to_capture: Option<i64>,\n    pub currency: storage_enums::Currency,\n    pub connector_transaction_id: String,\n    pub amount: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize)]", "positive": "This struct, defined in the router request types, encapsulates the data payload required to authorize a session token. It includes the specific amount to capture, the transaction currency, and the unique connector transaction ID. It also holds the original authorized amount. This data is crucial for the router to validate and process subsequent capture operations within the payment orchestration flow.", "queries": ["rust hyperswitch AuthorizeSessionTokenData struct fields", "how to use AuthorizeSessionTokenData in hyperswitch router", "hyperswitch AuthorizeSessionTokenData amount_to_capture currency", "AuthorizeSessionTokenData struct definition hyperswitch rust"], "label": "AuthorizeSessionTokenData struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "AuthorizeSessionTokenData", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` function within the Gigadat connector implementation serves as the primary interface for constructing the HTTP request headers required to authenticate and authorize outgoing payment transactions. It accepts a `PaymentsAuthorizeRouterData` struct containing the transaction context and a `Connectors` registry, then delegates the header generation logic to the internal `build_headers` method. This function is critical for ensuring that the Gigadat gateway receives the correct API keys and signature parameters derived from the Hyperswitch configuration, effectively bridging the internal domain models with the external payment provider's API requirements.", "queries": ["rust hyperswitch gigadat connector get_headers function implementation", "how does hyperswitch gigadat connector build authorization headers", "hyperswitch gigadat get_headers PaymentsAuthorizeRouterData signature", "rust gigadat connector header generation hyperswitch"], "label": "Gigadat connector header auth", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "positive": "The `get_auth_header` function in the `payone.rs` connector implementation generates the HTTP Authorization header for Payone API requests. It accepts a `ConnectorAuthType` enum, converts it to a specific `PayoneAuthType`, and returns a vector containing the key 'AUTHORIZATION' paired with the API key. This ensures secure, masked transmission of credentials during payment orchestration flows.", "queries": ["how to configure payone api key authorization header in hyperswitch", "hyperswitch payone connector get_auth_header implementation", "rust payone authentication header generation hyperswitch", "hyperswitch payone.rs connector api key configuration"], "label": "payone connector auth header", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileUpdate\npub enum ProfileUpdate {\n    Update(Box<ProfileGeneralUpdate>),\n    RoutingAlgorithmUpdate {\n        routing_algorithm: Option<serde_json::Value>,\n        payout_routing_algorithm: Option<serde_json::Value>,\n        three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    },\n    DynamicRoutingAlgorithmUpdate {\n        dynamic_routing_algorithm: Option<serde_json::Value>,\n    },\n    ExtendedCardInfoUpdate {\n        is_extended_card_info_enabled: bool,\n    },\n    ConnectorAgnosticMitUpdate {\n        is_connector_agnostic_mit_enabled: bool,\n    },\n    NetworkTokenizationUpdate {\n        is_network_tokenization_enabled: bool,\n    },\n    CardTestingSecretKeyUpdate {\n        card_testing_secret_key: OptionalEncryptableName,\n    },\n    AcquirerConfigMapUpdate {\n        acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    },\n}\n\n#[cfg(feature = \"v1\")]", "positive": "The ProfileUpdate enum in Rust defines the structure for updating a merchant's profile within the Hyperswitch payment orchestration platform. It supports granular updates across various profile dimensions, including general settings, routing algorithms (both static and dynamic), card information extensions, network tokenization, and specific integrations like MIT and card testing. This enum is central to the domain model, allowing the router and domain layers to construct and validate profile modification requests before persistence, ensuring the orchestration engine's configuration remains accurate and up-to-date.", "queries": ["how to update routing algorithm in hyperswitch profile", "rust enum ProfileUpdate hyperswitch domain models", "hyperswitch merchant profile update structure", "ProfileUpdate enum definition hyperswitch domain"], "label": "ProfileUpdate enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__business_profile.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "symbol": "ProfileUpdate", "unit_type": "function", "num_lines": 28}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: from\n    fn from(item: IatapayPaymentStatus) -> Self {\n        match item {\n            IatapayPaymentStatus::Authorized\n            | IatapayPaymentStatus::Settled\n            | IatapayPaymentStatus::Cleared => Self::Charged,\n            IatapayPaymentStatus::Failed | IatapayPaymentStatus::UnexpectedSettled => Self::Failure,\n            IatapayPaymentStatus::Created => Self::AuthenticationPending,\n            IatapayPaymentStatus::Initiated => Self::Pending,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This function serves as a mapping layer within the IATAPay connector implementation, converting the external IATAPay payment status enum into the internal Hyperswitch payment status model. It handles state transitions such as mapping 'Authorized', 'Settled', and 'Cleared' to 'Charged', 'Failed' to 'Failure', and 'Created' to 'AuthenticationPending'. This logic is critical for ensuring the router correctly interprets the upstream provider's response during the payment lifecycle.", "queries": ["rust iatapay payment status mapping function", "how to convert IatapayPaymentStatus to internal status", "hyperswitch connector iatapay status transformation", "IatapayPaymentStatus enum mapping logic rust"], "label": "IATAPay status mapping", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "symbol": "from", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: insert_payment_intent\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]", "positive": "This function defines the interface for persisting a new PaymentIntent entity within the domain models layer. It abstracts the storage interaction, requiring a fully constructed `PaymentIntent` object, a `MerchantKeyStore` for cryptographic verification, and the specific `MerchantStorageScheme` (e.g., tenant isolation strategy) to ensure data is routed to the correct database schema. The function returns the persisted entity or a typed error result, serving as the primary entry point for the 'Create Payment Intent' flow before routing to the storage implementation layer.", "queries": ["how to implement insert_payment_intent in Rust hyperswitch", "hyperswitch payment intent persistence interface signature", "Rust hyperswitch domain models insert_payment_intent merchant_key_store", "hyperswitch payment intent storage scheme implementation"], "label": "PaymentIntent persistence interface", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "insert_payment_intent", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "positive": "This function constructs the HTTP request headers for the Thunes payment connector. It dynamically generates a Content-Type header based on the connector's configuration and retrieves authentication credentials (API key) using the `get_auth_header` method. The resulting headers are returned as a vector of tuples, ensuring the outgoing request to the Thunes API is properly authenticated and formatted.", "queries": ["rust hyperswitch thunes connector build_headers function implementation", "how to configure api key headers in hyperswitch thunes connector", "thunes payment connector hyperswitch rust get_auth_header", "hyperswitch thunes connector header construction logic"], "label": "Thunes connector header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function retrieves and formats an ErrorResponse from an HTTP Response object within the Gigadat connector implementation. It serves as a standardized error handling wrapper that accepts a raw Response and an optional ConnectorEvent builder. The method delegates the actual parsing and construction logic to `build_error_response`, ensuring consistent error reporting and event generation for failed payment operations. It is a core utility in the connector's error handling pipeline, mapping HTTP status codes and bodies into the platform's internal error model.", "queries": ["rust hyperswitch gigadat connector error handling get_error_response", "how to implement error response builder in hyperswitch gigadat connector", "hyperswitch gigadat rust function get_error_response signature", "gigadat connector hyperswitch error response formatting implementation"], "label": "Gigadat error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: key_analysis\n    fn key_analysis(\n        &self,\n        key: dir::DirKey,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "positive": "The `key_analysis` function is a core component within the DSA (Directed Acyclic Graph) graph construction logic, specifically located in the `euclid` crate. Its primary purpose is to analyze a specific directory key (`dir::DirKey`) within the broader project context, utilizing an `AnalysisContext` to determine its properties and relationships. It performs critical graph validation by checking for cycles using `cycle_map` and memoizing results to prevent redundant processing. The function is designed to handle domain filtering, accepting an optional list of `domains` to constrain the analysis scope. It returns a `Result` indicating success or a `GraphError`, ensuring robust error handling during the complex graph traversal and dependency resolution phases of the Hyperswitch payment orchestration engine.", "queries": ["rust euclid crate key_analysis function signature", "hyperswitch dsa graph key_analysis implementation", "how does key_analysis work in euclid crate", "rust AnalysisContext key_analysis function"], "label": "DSA graph key analysis", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "key_analysis", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaSessionRequest\npub struct KlarnaSessionRequest {\n    intent: KlarnaSessionIntent,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    order_amount: MinorUnit,\n    order_lines: Vec<OrderLines>,\n    shipping_address: Option<KlarnaShippingAddress>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "positive": "This struct defines the input payload for initiating a Klarna session within the Hyperswitch payment orchestration platform. It encapsulates core transaction details such as the intent (authorization or capture), purchase context (country, currency), and financial specifics (order amount in minor units, line items). The structure also supports optional shipping address data, ensuring the connector can map the merchant's request to Klarna's session requirements for seamless checkout integration.", "queries": ["Rust struct definition for KlarnaSessionRequest hyperswitch", "hyperswitch Klarna connector session request fields", "KlarnaSessionRequest struct definition Rust hyperswitch", "hyperswitch Klarna payment session request payload"], "label": "Klarna session request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "symbol": "KlarnaSessionRequest", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsPreProcessingRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/sis/rest/iniciaPeticionREST\",\n            self.base_url(connectors)\n        ))\n    }", "positive": "The `get_url` function within the Redsys connector implementation generates the specific REST API endpoint URL for initiating payment requests. It constructs the path by appending the fixed string '/sis/rest/iniciaPeticionREST' to the dynamically resolved base URL, which is fetched from the configured connectors. This method is critical for routing the initial payment request to the Redsys payment gateway, ensuring the correct endpoint is called during the payment processing flow.", "queries": ["rust hyperswitch redsys connector get_url implementation", "how to generate redsys payment initiation url hyperswitch", "hyperswitch redsys connector base_url sis rest iniciaPeticionREST", "redsys payment gateway url generation hyperswitch rust"], "label": "Redsys payment initiation URL generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Powertranz\".to_string())\n                .into(),\n        )\n    }\n}\n", "positive": "This function defines the request construction logic for the Powertranz connector within the Hyperswitch payment orchestration platform. It is responsible for translating the internal `SetupMandate` request data into a format compatible with the Powertranz API. Currently, the implementation explicitly returns a `NotImplemented` error, indicating that the specific mandate setup workflow has not been integrated into this connector module yet. It interacts with the global `Connectors` context to manage external service dependencies.", "queries": ["how to implement setup mandate request for Powertranz connector", "Powertranz connector setup mandate function error NotImplemented", "hyperswitch powertranz build_request setup mandate", "why is setup mandate flow not implemented in powertranz connector"], "label": "Powertranz Setup Mandate Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_start\n    fn clip_to_start(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError> {\n        let clip_start = |value: u8, modulo: u8| -> u8 { value - value % modulo };\n\n        let clipped_time = match (\n            self.get_lowest_common_granularity_level(),\n            self.get_bucket_size(),\n        ) {\n            (TimeGranularityLevel::Minute, i) => time::Time::MIDNIGHT\n                .replace_second(clip_start(value.second(), i))\n                .and_then(|t| t.replace_minute(value.minute()))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Hour, i) => time::Time::MIDNIGHT\n                .replace_minute(clip_start(value.minute(), i))\n                .and_then(|t| t.replace_hour(value.hour())),\n            (TimeGranularityLevel::Day, i) => {\n                time::Time::MIDNIGHT.replace_hour(clip_start(value.hour(), i))\n            }\n        }\n        .change_context(PostProcessingError::BucketClipping)?;\n\n        Ok(value.replace_time(clipped_time))\n    }\n", "positive": "The `clip_to_start` function in the `analytics` crate's query module adjusts a time series value to the start of a specific time bucket. It calculates the start of the bucket based on the current time granularity (Minute, Hour, or Day) and the configured bucket size. This is essential for data aggregation and grouping time-series analytics data into consistent, non-overlapping intervals, ensuring accurate reporting and trend analysis within the payment orchestration platform.", "queries": ["rust hyperswitch analytics clip_to_start time bucket function", "how to clip time series to start of hour in rust hyperswitch", "hyperswitch analytics query module clip_to_start implementation", "rust time series bucket clipping function hyperswitch analytics"], "label": "Time Series Bucket Clipping", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "clip_to_start", "unit_type": "function", "num_lines": 26}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaShippingAddress\npub struct KlarnaShippingAddress {\n    city: String,\n    country: enums::CountryAlpha2,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    phone: Secret<String>,\n    postal_code: Secret<String>,\n    region: Secret<String>,\n    street_address: Secret<String>,\n    street_address2: Option<Secret<String>>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]", "positive": "The `KlarnaShippingAddress` struct in `hyperswitch_connectors` defines the data model for transforming raw Klarna shipping details into Hyperswitch's internal `api_models::ShippingAddress`. It handles sensitive fields like phone numbers and emails using `Secret` wrappers to prevent logging, while mapping standard fields like city, country, and street address. This transformation is critical for the payment orchestration flow, ensuring that customer delivery information is correctly passed from the Klarna connector to the router and downstream services.", "queries": ["How do I map Klarna shipping address fields to Hyperswitch internal structures?", "Rust struct definition for Klarna shipping address transformation", "hyperswitch connectors Klarna shipping address pii handling", "What fields are required in KlarnaShippingAddress struct?"], "label": "Klarna shipping address transformation struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "symbol": "KlarnaShippingAddress", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_pm_connector_mandate_details\nasync fn update_pm_connector_mandate_details<F, Req>(\n    state: &SessionState,\n    provider: &domain::Provider,\n    payment_data: &PaymentData<F>,\n    router_data: &types::RouterData<F, Req, types::PaymentsResponseData>,\n) -> RouterResult<()>\nwhere\n    F: Clone + Send + Sync,\n{\n    let is_valid_response = matches!(\n        router_data.response.as_ref(),\n        Ok(types::PaymentsResponseData::TransactionResponse { .. })\n    );\n    let is_integrity_ok = router_data.integrity_check.is_ok();\n\n    // Check payment status from payment_data (which has the final processed status)\n    let payment_attempt = payment_data.get_payment_attempt();\n    let is_payment_successful = matches!(\n        payment_attempt.status,\n        enums::AttemptStatus::Charged\n            | enums::AttemptStatus::Authorized\n            | enums::AttemptStatus::PartiallyAuthorized\n    );\n\n    let is_eligible_for_mandate_update =\n        is_valid_response && is_integrity_ok && is_payment_successful;\n\n    if let (true, Some(payment_method), Some(mca_id)) = (\n        is_eligible_for_mandate_update,\n        payment_data.get_payment_method_info().cloned(),\n        payment_attempt.merchant_connector_id.clone(),\n    ) {\n        let payment_intent = payment_data.get_payment_intent();\n\n        let mandate_details = payment_method\n            .get_common_mandate_reference()\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to deserialize to Payment Mandate Reference\")?;\n\n        let is_active_mandate = mandate_details\n            .payments\n            .as_ref()\n            .and_then(|payments| payments.0.get(&mca_id))\n            .is_some_and(|record| {\n                record.connector_mandate_status\n                    == Some(common_enums::ConnectorMandateStatus::Active)\n            });\n\n        let is_off_session = matches!(\n            payment_intent.setup_future_usage,\n            Some(common_enums::FutureUsage::OffSession)\n        );\n\n        // Combine business logic conditions: not active mandate AND off_session\n        if !is_active_mandate && is_off_session {\n            let (connector_mandate_id, mandate_metadata, connector_mandate_request_reference_id) =\n                payment_attempt\n                    .connector_mandate_detail\n                    .clone()\n                    .map(|cmr| {\n                        (\n                            cmr.connector_mandate_id,\n        \n\n... [truncated 752 chars] ...\n\n          mandate_metadata,\n                connector_mandate_request_reference_id,\n            )?;\n\n            payment_methods::cards::update_payment_method_connector_mandate_details(\n                provider.get_key_store(),\n                &*state.store,\n                payment_method,\n                connector_mandate_details,\n                provider.get_account().storage_scheme,\n            )\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update payment method in db\")?;\n        }\n    }\n    Ok(())\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Clone, Copy, router_derive::PaymentOperation)]\n#[operation(\n    operations = \"post_update_tracker\",\n    flow = \"sync_data, cancel_data, authorize_data, capture_data, complete_authorize_data, approve_data, reject_data, setup_mandate_data, session_data,incremental_authorization_data, sdk_session_update_data, post_session_tokens_data, update_metadata_data, cancel_post_capture_data, extend_authorization_data\"\n)]", "positive": "This function handles the synchronization of payment method (PM) connector mandates after a successful payment transaction. It validates the response integrity and payment status, then checks if an off-session payment requires a new mandate to be created or updated in the database. It integrates with the router's payment flow to ensure merchant connector mandates are active for future off-session transactions.", "queries": ["how to update payment method connector mandate details in hyperswitch", "hyperswitch router update_pm_connector_mandate_details function implementation", "create mandate for off session payment hyperswitch", "hyperswitch payment orchestration mandate update logic"], "label": "Payment Mandate Update Logic", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__payments__operations__payment_response.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "symbol": "update_pm_connector_mandate_details", "unit_type": "function", "num_lines": 105}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: FulfillmentMethod\npub enum FulfillmentMethod {\n    Delivery,\n    CounterPickup,\n    CubsidePickup,\n    LockerPickup,\n    StandardShipping,\n    ExpeditedShipping,\n    GasPickup,\n    ScheduledDelivery,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "positive": "The FulfillmentMethod enum in the Signifyd API transformer defines the specific delivery or pickup options available for an order. It is used to map the Signifyd response's fulfillment method to the internal system's representation, ensuring accurate order tracking and logistics processing. This enum is critical for the Signifyd connector to correctly interpret fraud and chargeback data, as it categorizes the physical handling of goods, distinguishing between standard shipping, expedited options, and various pickup methods like locker or gas station pickup.", "queries": ["Signifyd FulfillmentMethod enum definition", "Rust FulfillmentMethod variant types Signifyd", "How to handle Signifyd fulfillment methods in Hyperswitch", "Signifyd API fulfillment method mapping Rust"], "label": "Signifyd FulfillmentMethod enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "FulfillmentMethod", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_webhook_resource_object\n    fn get_webhook_resource_object(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<Box<dyn masking::ErasedMaskSerialize>, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n}\n", "positive": "This function defines the interface for retrieving a masked resource object from a webhook payload within the GPayments connector. It is part of the `GPayments` struct implementation, which handles the specific integration logic for Google Pay. The method accepts an `IncomingWebhookRequestDetails` reference and is expected to return a `Box<dyn masking::ErasedMaskSerialize>` containing the sanitized data. Currently, this implementation returns a `ConnectorError::WebhooksNotImplemented` error, indicating that the specific resource extraction logic for GPayments webhooks has not yet been implemented in this version of the codebase.", "queries": ["how to implement get_webhook_resource_object in GPayments connector", "GPayments webhook resource object masking implementation", "hyperswitch GPayments connector webhook handler error", "rust connector error WebhooksNotImplemented GPayments"], "label": "GPayments webhook resource object handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "get_webhook_resource_object", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &ConnectorAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let connector_metadata: GpaymentsConnectorMetaData = to_connector_meta(\n            req.request\n                .pre_authentication_data\n                .connector_metadata\n                .clone(),\n        )?;\n        Ok(connector_metadata.authentication_url)\n    }\n", "positive": "The `get_url` function in `gpayments.rs` is a critical component of the GPayments connector's authentication flow. It extracts the specific authentication URL from the request's pre-authentication data, which is deserialized into `GpaymentsConnectorMetaData`. This URL is then returned as a `CustomResult<String, ConnectorError>`, enabling the connector to proceed with the authentication handshake. The function is designed to handle the metadata parsing and URL extraction in a single, isolated step, ensuring that the authentication process is robust and error-handled. It is a key part of the connector's integration with the Hyperswitch router, facilitating secure and standardized payment gateway connections.", "queries": ["rust hyperswitch gpayments connector get_url function implementation", "how to extract authentication_url from connector_metadata in hyperswitch", "hyperswitch gpayments authentication flow get_url method", "rust hyperswitch connector authentication metadata parsing get_url"], "label": "GPayments connector authentication URL extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service\npub async fn should_call_unified_connector_service<F: Clone, T, R>(\n    state: &SessionState,\n    processor: &Processor,\n    router_data: &RouterData<F, T, R>,\n    previous_gateway: Option<GatewaySystem>,\n    call_connector_action: CallConnectorAction,\n    shadow_ucs_call_connector_action: Option<CallConnectorAction>,\n) -> RouterResult<(ExecutionPath, SessionState)>\nwhere\n    R: Send + Sync + Clone,\n{\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_name = &router_data.connector;\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {connector_name}\"))?;\n\n    let flow_name = get_flow_name::<F>()?;\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    let rollout_key = build_rollout_keys(\n        merchant_id,\n        connector_name,\n        &flow_name,\n        router_data.payment_method,\n        router_data.payment_method_type,\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // Check rollout key availability and shadow key presence (optimized to reduce DB calls)\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Single decision point using pattern matching\n    let (gateway_system, mut execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        match call_connector_action {\n            CallConnectorAction::UCSConsumeResponse(_)\n            | CallConnectorAction::UCSHandleResponse(_) => {\n                Err(errors::ApiErrorResponse::InternalServerError)\n                    .attach_printable(\"CallConnectorAction UCSHandleResponse/UCSConsumeResponse received but UCS is disabled. These actions are only valid in UCS gateway\")?\n            }\n            CallConnectorAction::Avoid\n            | CallConnectorAction::Trigger\n            | CallConnectorAction::HandleResponse(_)\n            | CallConnectorAction::StatusUpdate { .. } => {\n                router_env::logger::debug!(\"UCS is disabled, using Direct gateway\");\n                (GatewaySystem::Direct, ExecutionPath::Direct)\n            }\n        }\n    } else {\n        match call\n\n... [truncated 1975 chars] ...\n\n                );\n                    create_updated_session_state_with_proxy(state.clone(), proxy_override)\n                }\n                None => {\n                    router_env::logger::debug!(\n                        \"No proxy override available for Shadow UCS, Using the Original State and Sending Request Directly\"\n                    );\n                    execution_path = ExecutionPath::Direct;\n                    state.clone()\n                }\n            }\n        }\n        ExecutionPath::Direct | ExecutionPath::UnifiedConnectorService => {\n            // For Direct and UCS flows, use original state\n            state.clone()\n        }\n    };\n\n    router_env::logger::info!(\n        \"Payment gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok((execution_path, session_state))\n}\n\n/// Creates a new SessionState with proxy configuration updated from the override", "positive": "This function determines the execution path (Direct vs. Unified Connector Service) for a payment request based on UCS availability, rollout keys, and specific action types. It handles gateway system selection, shadow UCS logic, and proxy overrides, ensuring correct routing decisions in the Hyperswitch payment orchestration platform.", "queries": ["Rust function to decide between direct gateway and UCS execution path", "Hyperswitch should_call_unified_connector_service implementation", "How to check UCS availability in Hyperswitch router", "Rust payment gateway execution path selection logic"], "label": "Payment routing decision logic", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "should_call_unified_connector_service", "unit_type": "function", "num_lines": 131}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &ConnectorCustomerRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<ConnectorCustomerRouterData, errors::ConnectorError>\n    where\n        PaymentsResponseData: Clone,\n    {\n        let response: airwallex::AirwallexCustomerResponse = res\n            .response\n            .parse_struct(\"AirwallexCustomerResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n        .change_context(errors::ConnectorError::ResponseHandlingFailed)\n    }\n", "positive": "This function handles the response payload from the Airwallex connector integration. It deserializes the raw HTTP response into an AirwallexCustomerResponse struct, logs the data for observability, and attempts to transform the raw response into a RouterData object using the ResponseRouterData wrapper. It supports optional event building for webhook contexts.", "queries": ["How to handle Airwallex customer response data in hyperswitch", "Rust function to parse Airwallex customer response and log it", "hyperswitch airwallex connector handle_response implementation", "AirwallexCustomerResponse deserialization and RouterData conversion"], "label": "Airwallex Customer Response Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 25}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_internal_reference_id_merchant_id\n    async fn find_refund_by_internal_reference_id_merchant_id(\n        &self,\n        internal_reference_id: &str,\n        merchant_id: &common_utils::id_type::MerchantId,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<diesel_refund::Refund, errors::StorageError>;\n\n    #[cfg(feature = \"v1\")]", "positive": "This function serves as a critical data access layer method within the Router crate, specifically designed to retrieve a refund entity from the PostgreSQL database. It acts as a specialized lookup mechanism that filters records based on a unique composite key: the `internal_reference_id` (often a transaction ID) and the `merchant_id`. The method accepts a `MerchantStorageScheme` enum to handle multi-tenant isolation, ensuring that queries are scoped correctly to the specific merchant's schema or configuration. It is typically invoked during the refund processing flow or when reconciling transaction states, bridging the gap between the Actix-web request handlers and the underlying Diesel ORM models defined in `diesel_refund`.", "queries": ["How do I query a refund by internal reference ID and merchant ID in Hyperswitch?", "Rust function to find refund using internal_reference_id and merchant_id in router crate", "Hyperswitch storage error handling for refund lookup by merchant_id", "Diesel query implementation for finding refund by internal_reference_id in router"], "label": "Refund lookup by internal ID and merchant ID", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "find_refund_by_internal_reference_id_merchant_id", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: ExternalVaultProxyPaymentsData\npub struct ExternalVaultProxyPaymentsData {\n    pub payment_method_data: ExternalVaultPaymentMethodData,\n    /// total amount (original_amount + surcharge_amount + tax_on_surcharge_amount)\n    /// If connector supports separate field for surcharge amount, consider using below functions defined on `PaymentsAuthorizeData` to fetch original amount and surcharge amount separately\n    /// ```text\n    /// get_original_amount()\n    /// get_surcharge_amount()\n    /// get_tax_on_surcharge_amount()\n    /// get_total_surcharge_amount() // returns surcharge_amount + tax_on_surcharge_amount\n    /// ```\n    pub amount: i64,\n    pub order_tax_amount: Option<MinorUnit>,\n    pub email: Option<pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub currency: storage_enums::Currency,\n    pub confirm: bool,\n    pub statement_descriptor_suffix: Option<String>,\n    pub statement_descriptor: Option<String>,\n    pub capture_method: Option<storage_enums::CaptureMethod>,\n    pub router_return_url: Option<String>,\n    pub webhook_url: Option<String>,\n    pub complete_authorize_url: Option<String>,\n    // Mandates\n    pub setup_future_usage: Option<storage_enums::FutureUsage>,\n    pub mandate_id: Option<api_models::payments::MandateIds>,\n    pub off_session: Option<bool>,\n    pub customer_acceptance: Option<common_payments_types::CustomerAcceptance>,\n    pub setup_mandate_details: Option<mandates::MandateData>,\n    pub browser_info: Option<BrowserInformation>,\n    pub order_details: Option<Vec<OrderDetailsWithAmount>>,\n    pub order_category: Option<String>,\n    pub session_token: Option<String>,\n    pub enrolled_for_3ds: bool,\n    pub related_transaction_id: Option<String>,\n    pub payment_experience: Option<storage_enums::PaymentExperience>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub surcharge_details: Option<SurchargeDetails>,\n    pub customer_id: Option<id_type::CustomerId>,\n    pub request_incremental_authorization: bool,\n    pub metadata: Option<serde_json::Value>,\n    pub authentication_data: Option<AuthenticationData>,\n    pub request_extended_authorization:\n        Option<common_types::primitive_wrappers::RequestExtendedAuthorizationBool>,\n    pub split_payments: Option<common_types::payments::SplitPaymentsRequest>,\n\n    // New amount for amount frame work\n    pub minor_amount: MinorUnit,\n    /// Merchant's identifier for the payment/invoice. This will be sent to the connector\n \n\n... [truncated 180 chars] ...\n\nference.\n    pub merchant_order_reference_id: Option<id_type::PaymentReferenceId>,\n    pub integrity_object: Option<AuthoriseIntegrityObject>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub additional_payment_method_data: Option<AdditionalPaymentData>,\n    pub merchant_account_id: Option<Secret<String>>,\n    pub merchant_config_currency: Option<storage_enums::Currency>,\n    pub connector_testing_data: Option<pii::SecretSerdeValue>,\n    pub order_id: Option<String>,\n}\n\n// Note: Integrity traits for ExternalVaultProxyPaymentsData are not implemented\n// as they are not mandatory for this flow. The integrity_check field in RouterData\n// will use Ok(()) as default, similar to other flows.\n\n// Implement ConnectorCustomerData conversion for ExternalVaultProxy RouterData\nimpl\n    TryFrom<\n        &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    > for ConnectorCustomerData\n{\n    type Error = error_stack::Report<ApiErrorResponse>;\n", "positive": "The `ExternalVaultProxyPaymentsData` struct defines the input payload for the ExternalVaultProxy payment flow within the Hyperswitch router. It encapsulates payment details, vault-specific metadata, and mandate information required to authorize transactions via external vault connectors. This struct is used to convert `RouterData` into `ConnectorCustomerData` for downstream processing, supporting complex flows like incremental authorization, split payments, and 3DS authentication.", "queries": ["Rust struct definition for ExternalVaultProxyPaymentsData", "Hyperswitch router ExternalVaultProxyPaymentsData fields", "ExternalVaultProxyPaymentsData TryFrom implementation", "ExternalVaultProxyPaymentsData struct fields and types"], "label": "ExternalVaultProxyPaymentsData struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "ExternalVaultProxyPaymentsData", "unit_type": "function", "num_lines": 76}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n            PaymentMethodDataType::SamsungPay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Cybersource\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This function validates whether a specific payment method is supported for mandate processing within the Cybersource connector. It checks the input payment method type and data against a predefined set of supported mandates (Card, ApplePay, GooglePay, SamsungPay) and delegates the validation logic to a shared utility function. It is a critical gatekeeper ensuring that mandate flows are only initiated for compliant payment methods.", "queries": ["how to check if payment method is supported for mandate in cybersource connector", "cybersource mandate supported payment methods list rust implementation", "validate_mandate_payment function cybersource connector hyperswitch", "what payment methods support mandates in cybersource hyperswitch"], "label": "Cybersource mandate validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "validate_mandate_payment", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: from\n    fn from(_value: user_api::SignUpRequest) -> Self {\n        let new_organization =\n            api_org::OrganizationNew::new(common_enums::OrganizationType::Standard, None);\n        let db_organization = ForeignFrom::foreign_from(new_organization);\n        Self(db_organization)\n    }\n}\n", "positive": "This function implements a conversion from a `user_api::SignUpRequest` into a domain-specific `user::User` type. It initializes a new organization using the standard `OrganizationType` and delegates the persistence logic to `ForeignFrom::foreign_from`, ensuring the user entity is correctly constructed with its associated organizational context within the router's domain layer.", "queries": ["rust hyperswitch router user from signup request", "how to convert SignUpRequest to User in hyperswitch", "hyperswitch router user module signup conversion", "rust hyperswitch domain user from signup"], "label": "User Signup Conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "from", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: OrderChannel\npub enum OrderChannel {\n    Web,\n    Phone,\n    MobileApp,\n    Social,\n    Marketplace,\n    InStoreKiosk,\n    ScanAndGo,\n    SmartTv,\n    Mit,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "positive": "The `OrderChannel` enum defines the origin or context of a payment transaction, mapping to specific business logic flows within the Hyperswitch payment orchestration platform. It supports diverse entry points including Web, MobileApp, Phone, and InStoreKiosk, as well as newer channels like ScanAndGo and SmartTv. This data is critical for routing, analytics, and fraud detection, ensuring that the `router` correctly interprets the source of the payment request before dispatching it to the appropriate `hyperswitch_connectors` implementation.", "queries": ["rust hyperswitch OrderChannel enum definition", "hyperswitch payment channel types enum", "how to define order channel in hyperswitch rust", "hyperswitch OrderChannel source of payment"], "label": "payment channel origin enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "OrderChannel", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: get_sale_query_error_response\nfn get_sale_query_error_response(\n    (sale_query_response, http_code): (&SaleQuery, u16),\n) -> ErrorResponse {\n    ErrorResponse {\n        code: sale_query_response\n            .sale_error_code\n            .clone()\n            .unwrap_or(consts::NO_ERROR_CODE.to_string()),\n        message: sale_query_response\n            .sale_error_text\n            .clone()\n            .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n        reason: sale_query_response.sale_error_text.clone(),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(sale_query_response.sale_payme_id.clone()),\n        connector_response_reference_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n        connector_metadata: None,\n    }\n}\n", "positive": "This function transforms a raw PayMe API sale query response into a standardized ErrorResponse object. It handles error scenarios by mapping the connector's specific error codes and messages into the hyperswitch domain model. It is critical for the payment orchestration flow, specifically within the PayMe connector's transformer layer, to ensure that network-level errors from the payment gateway are correctly propagated to the router and downstream systems for logging, retry logic, and user notification.", "queries": ["Rust function to convert PayMe sale query error response", "hyperswitch PayMe connector error handling code", "how to map PayMe sale error to hyperswitch ErrorResponse", "PayMe sale query error response transformer implementation"], "label": "PayMe sale query error transformer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "symbol": "get_sale_query_error_response", "unit_type": "function", "num_lines": 24}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: apply_additional_payment_data\n    pub fn apply_additional_payment_data(\n        &self,\n        additional_payment_data: api_models::payments::AdditionalPaymentData,\n    ) -> Self {\n        if let api_models::payments::AdditionalPaymentData::Card(additional_card_info) =\n            additional_payment_data\n        {\n            match self {\n                Self::Card(card) => {\n                    Self::Card(card.apply_additional_card_info(*additional_card_info))\n                }\n                Self::CardWithLimitedDetails(card_with_limited_details) => {\n                    Self::CardWithLimitedDetails(\n                        card_with_limited_details.apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                Self::CardDetailsForNetworkTransactionId(card_with_network_transaction_id) => {\n                    Self::CardDetailsForNetworkTransactionId(\n                        card_with_network_transaction_id\n                            .apply_additional_card_info(*additional_card_info),\n                    )\n                }\n                _ => self.to_owned(),\n            }\n        } else {\n            self.to_owned()\n        }\n    }\n", "positive": "This method extends the payment method state by incorporating additional transactional details, specifically handling `AdditionalPaymentData` for card transactions. It acts as a polymorphic accessor that checks the current variant (Card, CardWithLimitedDetails, or CardDetailsForNetworkTransactionId) and delegates the enrichment to the specific `apply_additional_card_info` implementation. If the data is not card-related or the variant does not match, it returns a cloned copy of the current state, ensuring immutability and state consistency within the domain model.", "queries": ["how to add additional card info to payment method in hyperswitch", "rust hyperswitch domain models apply_additional_payment_data implementation", "hyperswitch payment method state update additional card details", "extend card payment method with extra data hyperswitch domain"], "label": "Payment Method State Enrichment", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "apply_additional_payment_data", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelPaymentInitiator\npub enum ArchipelPaymentInitiator {\n    #[default]\n    Customer,\n    Merchant,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "positive": "The ArchipelPaymentInitiator enum defines the payment source type for the Archipel connector, distinguishing between 'Customer' and 'Merchant' flows. This selector determines how the connector handles the payer identity and authorization logic within the payment initiation request. It is a core configuration parameter used in the Archipel transformer to map Hyperswitch payment requests to Archipel's specific API expectations, ensuring correct routing of funds based on the intended payer context.", "queries": ["How do I configure Archipel connector to pay on behalf of a merchant?", "ArchipelPaymentInitiator enum variants in hyperswitch connectors", "Difference between Customer and Merchant payment initiator in Archipel", "Configure Archipel payment source type in hyperswitch"], "label": "Archipel payment initiator enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "ArchipelPaymentInitiator", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: from\n    fn from(secret: Secret<String>) -> Self {\n        Self::from(secret.expose())\n    }\n}\n\n#[cfg(test)]\nmod apply_mask_fn_test {\n    use masking::PeekInterface;\n\n    use crate::new_type::{\n        apply_mask, MaskedBankAccount, MaskedIban, MaskedRoutingNumber, MaskedSortCode,\n        MaskedUpiVpaId,\n    };\n    #[test]", "positive": "The `from` method on `Secret` new types (e.g., `MaskedBankAccount`) is a constructor that accepts a `Secret<String>` and unwraps the inner string value using `expose()`. It is used to initialize the new type from a pre-existing secret wrapper, ensuring the new instance inherits the masking configuration of the source type. This pattern is central to the `common_utils` crate, providing a consistent interface for handling sensitive data across the payment orchestration platform.", "queries": ["rust hyperswitch MaskedBankAccount constructor unwrap secret", "how to create MaskedBankAccount from Secret<String> in hyperswitch", "hyperswitch common_utils new_type Secret expose method", "rust Secret new_type from implementation hyperswitch"], "label": "Secret new_type constructor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__common_utils__src__new_type.rs", "path": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "symbol": "from", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Err(report!(ConnectorError::WebhooksNotImplemented))\n    }\n", "positive": "This function defines the interface for extracting the event type from an incoming webhook payload. It is a placeholder implementation in the Payone connector that returns a 'WebhooksNotImplemented' error, indicating that this specific connector does not support handling incoming webhook events. Developers must override this method in concrete connector implementations to parse the payload and return the correct event type for downstream processing.", "queries": ["how to implement get_webhook_event_type in Payone connector", "Payone connector webhook event type extraction error", "incoming webhook event type parsing Payone Rust", "hyperswitch Payone connector webhook support"], "label": "Payone webhook event type extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "get_webhook_event_type", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_merchant_connector_account\n    async fn update_merchant_connector_account(\n        &self,\n        this: domain::MerchantConnectorAccount,\n        merchant_connector_account: storage::MerchantConnectorAccountUpdateInternal,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .update_merchant_connector_account(this, merchant_connector_account, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "positive": "This function updates a specific merchant's configuration for a payment connector within the Hyperswitch orchestration platform. It accepts a domain-level `MerchantConnectorAccount` object and a `MerchantConnectorAccountUpdateInternal` struct containing the new configuration details. The function interacts with the `router_store` to persist changes and utilizes a `MerchantKeyStore` to manage cryptographic keys associated with the connector. It is a critical component for dynamic configuration management, allowing merchants to switch providers or update credentials without service disruption.", "queries": ["how to update merchant connector account configuration in hyperswitch", "hyperswitch rust update merchant connector account key_store", "MerchantConnectorAccountUpdateInternal struct hyperswitch storage_impl", "hyperswitch router_store update_merchant_connector_account implementation"], "label": "merchant connector account update", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "update_merchant_connector_account", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: SyncIntegrityObject\npub struct SyncIntegrityObject {\n    /// Sync amount\n    pub amount: Option<MinorUnit>,\n    /// Sync currency\n    pub currency: Option<storage_enums::Currency>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "positive": "The `SyncIntegrityObject` struct in `hyperswitch_domain_models` defines the data model for tracking financial synchronization amounts. It encapsulates the `amount` (as a `MinorUnit`) and the `currency` (using `storage_enums::Currency`), serving as a critical domain model for reconciling payment records between the router and storage layers. It is used within the `router` crate's request handling and `storage_impl` to ensure data consistency during payment flows.", "queries": ["hyperswitch rust SyncIntegrityObject struct definition", "how to define sync integrity object in hyperswitch domain models", "SyncIntegrityObject amount currency fields rust", "hyperswitch router request types sync integrity"], "label": "Sync Integrity Domain Model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "SyncIntegrityObject", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: wellsfargo::WellsfargoAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let wellsfargo::WellsfargoAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "positive": "This function generates a custom HMAC-SHA256 signature for Wells Fargo API requests, adhering to their specific authorization header format. It constructs a canonical string from the HTTP method, resource path, host, date, and payload digest, then signs it using the provided API secret. It handles different HTTP verbs (GET, POST, PATCH, DELETE) by dynamically adjusting the request-target and digest inclusion. The resulting signature is formatted into a specific header string containing the API key, algorithm, signed headers list, and the base64-encoded signature value.", "queries": ["how to generate wells fargo signature header rust", "wellsfargo connector signature generation hmac sha256", "rust function create wells fargo authorization header", "hyperswitch wells fargo signature implementation"], "label": "Wells Fargo Signature Generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "generate_signature", "unit_type": "function", "num_lines": 53}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = juspaythreedsserver::JuspaythreedsserverAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "positive": "This function generates the HTTP Authorization header for Juspay 3DS server connections. It accepts a generic ConnectorAuthType and converts it into the specific JuspaythreedsserverAuthType required by the connector. It returns a vector of header-value tuples, specifically mapping the API key to the 'Authorization' header field using a masked type for security.", "queries": ["how to configure authorization header for juspay 3ds connector", "rust function to get authorization header for juspaythreedsserver", "juspaythreedsserver get_auth_header implementation", "hyperswitch juspay 3ds authentication header generation"], "label": "Juspay 3DS Authorization Header", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_response_id_str\n    pub fn get_response_id_str(\n        &self,\n    ) -> Result<ResponseIdStr, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id_str())\n    }", "positive": "This function retrieves the response identifier string from a cloned event collection, handling the absence of events by returning a 'MissingRequiredField' error. It is a critical utility within the Worldpay Modular connector's response transformation layer, ensuring the correct resource ID is extracted for downstream processing and logging.", "queries": ["How to get the response ID string from a Worldpay event in Rust?", "Worldpay connector error MissingRequiredField href resource id", "Hyperswitch get_response_id_str function implementation", "Extract resource ID from Worldpay response transformer"], "label": "Worldpay response ID extractor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "get_response_id_str", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "This function retrieves the HTTP headers required for the Amazon Pay authorization request. It acts as a wrapper around the internal `build_headers` method, utilizing the `PaymentsAuthorizeRouterData` context and the `Connectors` registry to assemble the necessary authentication and payload metadata. It returns a vector of tuples containing header names and masked values, ensuring secure transmission of credentials and request identifiers to the Amazon Pay gateway.", "queries": ["rust hyperswitch amazonpay connector authorization headers implementation", "how to configure amazonpay authorization request headers in hyperswitch", "hyperswitch amazonpay get_headers function source code rust", "amazonpay connector authorization request metadata setup hyperswitch"], "label": "AmazonPay Authorization Headers", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}{}\",\n            self.base_url(connectors),\n            \"api/v1/pa/customers/create\"\n        ))\n    }\n", "positive": "This function constructs the API endpoint URL for creating a customer within the Airwallex payment orchestration connector. It retrieves the base URL dynamically using the connector configuration and appends the specific Airwallex API path '/api/v1/pa/customers/create'. This is a critical integration step for the Airwallex connector, ensuring the correct endpoint is called during the customer creation flow.", "queries": ["Airwallex connector get_url function implementation", "how to construct Airwallex customer creation API endpoint", "hyperswitch airwallex connector get_url method", "Airwallex API URL generation in hyperswitch"], "label": "Airwallex customer creation URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleResponse\npub struct GenerateSaleResponse {\n    payme_sale_id: String,\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, PaymePaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = error_stack::Report<errors::ConnectorError>;", "positive": "This function, defined within the PayMe connector's transformer module, is responsible for mapping the raw HTTP response from the PayMe payment gateway into the standardized internal `PaymentsResponseData` format expected by the Hyperswitch router. It handles the transformation of the specific `PaymePaymentsResponse` DTO into a generic `PaymentsResponseData` struct, ensuring that fields like transaction status, identifiers, and monetary amounts are correctly aligned with the orchestration platform's domain models. This transformation is a critical step in the payment flow, bridging the gap between the external payment provider's API contract and the internal system architecture.", "queries": ["how to transform payme payment response into hyperswitch payments response data", "payme connector generate sale response rust implementation", "hyperswitch payme payments response data mapping", "rust tryfrom implementation for payme payments response"], "label": "PayMe Payment Response Transformer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "symbol": "GenerateSaleResponse", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &AccessTokenAuthenticationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = NordeaOAuthRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function, defined within the Nordea connector implementation, extracts and prepares the OAuth request payload for the Nordea payment gateway. It acts as a serialization layer, transforming the generic `AccessTokenAuthenticationRouterData` struct into a specific `NordeaOAuthRequest` type. The function is critical for the authentication handshake, ensuring the connector sends the correct JSON-formatted credentials required by the Nordea API to establish a secure session before processing payment transactions.", "queries": ["how to configure Nordea OAuth authentication in hyperswitch", "Nordea connector get_request_body implementation details", "hyperswitch nordea oauth request payload structure", "rust code for nordea oauth request transformation"], "label": "Nordea OAuth Request Serialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: SignatureParams\nstruct SignatureParams<'a> {\n    content_type: &'a str,\n    host: &'a str,\n    path: &'a str,\n    payload_digest: Option<&'a str>,\n    date: &'a str,\n    http_method: Method,\n}\n", "positive": "SignatureParams is a struct in the Nordea connector that encapsulates the cryptographic and routing metadata required to validate and process incoming HTTP requests. It holds the content type, host, path, and HTTP method to construct the canonical request string. Crucially, it includes the payload digest (SHA-256 hash) and the request date, which are essential for verifying the request's integrity and freshness against the Nordea API's security policies. This struct is used by the signature verification logic to ensure that the request originates from a trusted source and has not been tampered with.", "queries": ["how to verify nordea api signature rust", "nordea connector signature_params struct rust", "rust hyperswitch nordea signature validation", "nordea api signature verification rust implementation"], "label": "Nordea signature validation struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "SignatureParams", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]", "positive": "This function implements a conversion trait for the Wise connector, transforming a generic `ConnectorAuthType` enum variant into a specific `WiseAuth` struct. It handles the 'BodyKey' authentication mode by extracting the `api_key` and `profile_id` fields, ensuring type safety and ownership transfer. If the input does not match the expected authentication type, it returns a `ConnectorError::FailedToObtainAuthType`, acting as a strict validation gate for the Wise payment integration within the hyperswitch_connectors crate.", "queries": ["rust wise connector authentication body key profile_id", "how to convert ConnectorAuthType to WiseAuth in hyperswitch", "hyperswitch wise transformer error handling try_from", "rust enum conversion wise profile_id api_key"], "label": "WiseAuth conversion trait", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_ctp_service_provider\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n", "positive": "This function retrieves the `CtpServiceProvider` enum variant corresponding to the merchant's configured connector name. It performs runtime parsing of the string identifier, attaching a descriptive error if the connector name is not a valid enum member. This mapping is critical for the orchestration layer to route payment flows to the correct Transaction Processing Provider (CTP) implementation within the `hyperswitch_connectors` crate.", "queries": ["How to get CtpServiceProvider from connector_name in Rust", "Parse connector name to CtpServiceProvider enum hyperswitch", "hyperswitch domain models get_ctp_service_provider implementation", "Rust function to convert connector_name to CtpServiceProvider"], "label": "CTP provider enum parsing", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "get_ctp_service_provider", "unit_type": "function", "num_lines": 20}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_option_secret_value\n    pub fn from_option_secret_value(\n        value: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n", "positive": "This function, located in the domain models crate, acts as a deserialization constructor for `ConnectorAuthType`. It accepts an optional `SecretSerdeValue` (likely parsed from JSON) and attempts to parse it into the specific enum variant. It utilizes the `change_context` utility to wrap any parsing failures into a `ParsingError::StructParseFailure`, ensuring that authentication type mismatches or malformed data are surfaced clearly during the connector initialization phase.", "queries": ["rust hyperswitch connector auth type parsing error", "how to deserialize connector auth type from secret value", "hyperswitch domain models connector auth parsing", "rust change_context parsing error connector auth"], "label": "ConnectorAuthType deserialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "from_option_secret_value", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: convert\n    async fn convert(self) -> CustomResult<Self::DstType, ValidationError> {\n        let (is_external_vault_enabled, external_vault_connector_details) =\n            self.external_vault_details.into();\n\n        Ok(diesel_models::business_profile::Profile {\n            profile_id: self.profile_id.clone(),\n            id: Some(self.profile_id),\n            merchant_id: self.merchant_id,\n            profile_name: self.profile_name,\n            created_at: self.created_at,\n            modified_at: self.modified_at,\n            return_url: self.return_url,\n            enable_payment_response_hash: self.enable_payment_response_hash,\n            payment_response_hash_key: self.payment_response_hash_key,\n            redirect_to_merchant_with_http_post: self.redirect_to_merchant_with_http_post,\n            webhook_details: self.webhook_details,\n            metadata: self.metadata,\n            routing_algorithm: self.routing_algorithm,\n            intent_fulfillment_time: self.intent_fulfillment_time,\n            frm_routing_algorithm: self.frm_routing_algorithm,\n            payout_routing_algorithm: self.payout_routing_algorithm,\n            is_recon_enabled: self.is_recon_enabled,\n            applepay_verified_domains: self.applepay_verified_domains,\n            payment_link_config: self.payment_link_config,\n            session_expiry: self.session_expiry,\n            authentication_connector_details: self.authentication_connector_details,\n            payout_link_config: self.payout_link_config,\n            is_extended_card_info_enabled: self.is_extended_card_info_enabled,\n            extended_card_info_config: self.extended_card_info_config,\n            is_connector_agnostic_mit_enabled: self.is_connector_agnostic_mit_enabled,\n            use_billing_as_payment_method_billing: self.use_billing_as_payment_method_billing,\n            collect_shipping_details_from_wallet_connector: self\n                .collect_shipping_details_from_wallet_connector,\n            collect_billing_details_from_wallet_connector: self\n                .collect_billing_details_from_wallet_connector,\n            outgoing_webhook_custom_http_headers: self\n                .outgoing_webhook_custom_http_headers\n                .map(Encryption::from),\n            always_collect_billing_details_from_wallet_connector: self\n                .always_collect_billing_details_from_wallet_connector,\n            always_collect_shipping_details_from_wallet_c\n\n... [truncated 1052 chars] ...\n\nclear_pan_retries_enabled,\n            force_3ds_challenge: Some(self.force_3ds_challenge),\n            is_debit_routing_enabled: self.is_debit_routing_enabled,\n            merchant_business_country: self.merchant_business_country,\n            is_iframe_redirection_enabled: self.is_iframe_redirection_enabled,\n            is_pre_network_tokenization_enabled: Some(self.is_pre_network_tokenization_enabled),\n            three_ds_decision_rule_algorithm: self.three_ds_decision_rule_algorithm,\n            acquirer_config_map: self.acquirer_config_map,\n            merchant_category_code: self.merchant_category_code,\n            merchant_country_code: self.merchant_country_code,\n            dispute_polling_interval: self.dispute_polling_interval,\n            is_manual_retry_enabled: self.is_manual_retry_enabled,\n            always_enable_overcapture: self.always_enable_overcapture,\n            is_external_vault_enabled,\n            external_vault_connector_details,\n            billing_processor_id: self.billing_processor_id,\n        })\n    }\n", "positive": "This `convert` method transforms a domain model struct into a `diesel_models::business_profile::Profile` entity for database persistence. It handles the mapping of API request fields to the underlying storage schema, including complex configurations like webhook headers, routing algorithms, and external vault settings. The method is critical for the 'business_profile' module within the `hyperswitch_domain_models` crate, ensuring data integrity when saving merchant configuration to PostgreSQL.", "queries": ["how to convert business profile domain model to database profile", "rust business profile convert method implementation hyperswitch", "map api business profile to diesel models profile", "hyperswitch domain models business_profile convert function"], "label": "business profile conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__business_profile.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "symbol": "convert", "unit_type": "function", "num_lines": 74}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: helcim::HelcimPaymentsResponse = res\n            .response\n            .parse_struct(\"Helcim PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }", "positive": "The `handle_response` function in the `helcim.rs` connector processes the HTTP response from the Helcim payment gateway. It deserializes the raw response into a `HelcimPaymentsResponse` struct, logs the details for debugging, and attempts to convert it into a `ResponseRouterData` object. This data is then used to update the state of the payment flow, specifically for a Setup Mandate Router, and is optionally attached to a `ConnectorEvent` for downstream processing or auditing.", "queries": ["helcim rust connector handle_response function implementation", "how to parse helcim payments response in rust hyperswitch", "helcim payments authorize response deserialization hyperswitch", "hyperswitch helcim connector handle_response unit test"], "label": "Helcim Response Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 18}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: try_from\n    fn try_from(\n        data: &RouterData<\n            flows::ExternalVaultProxy,\n            ExternalVaultProxyPaymentsData,\n            response_types::PaymentsResponseData,\n        >,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            email: data.request.email.clone(),\n            payment_method_data: None, // External vault proxy doesn't use regular payment method data\n            description: None,\n            phone: None,\n            name: data.request.customer_name.clone(),\n            preprocessing_id: data.preprocessing_id.clone(),\n            split_payments: data.request.split_payments.clone(),\n            setup_future_usage: data.request.setup_future_usage,\n            customer_acceptance: data.request.customer_acceptance.clone(),\n            customer_id: None,\n            billing_address: None,\n            metadata: None,\n            currency: Some(data.request.currency),\n        })\n    }\n}\n#[derive(Debug, Clone, Serialize)]", "positive": "This `try_from` implementation converts `RouterData` containing `ExternalVaultProxy` flows into a domain-specific payment request object. It extracts core fields like customer name, email, and currency from the request payload while explicitly setting `payment_method_data` to `None` to reflect the unique architecture of External Vault Proxy flows. It handles cloning of request data and configuration flags such as `split_payments` and `setup_future_usage`, ensuring the downstream domain model is populated correctly for processing external vault transactions.", "queries": ["how to convert RouterData to PaymentsRequest for ExternalVaultProxy", "ExternalVaultProxy try_from implementation in hyperswitch", "hyperswitch router data to payments request conversion", "ExternalVaultProxyPaymentsData try_from source code"], "label": "ExternalVaultProxy PaymentsRequest conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 25}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: L2L3Data\npub struct L2L3Data {\n    pub order_info: Option<OrderInfo>,\n    pub tax_info: Option<TaxInfo>,\n    pub customer_info: Option<CustomerInfo>,\n    pub shipping_details: Option<AddressDetails>,\n    pub billing_details: Option<BillingDetails>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "positive": "The L2L3Data struct serves as a comprehensive container for the second and third levels of payment orchestration data. It aggregates granular transaction details including OrderInfo, TaxInfo, CustomerInfo, and specific shipping/billing addresses. This structure is essential for the router to validate and route payment flows, ensuring that all contextual metadata required for processing is available in a single, typed object before dispatching to the appropriate connector or payment method.", "queries": ["Rust struct definition for L2L3Data in hyperswitch router", "hyperswitch domain models L2L3Data struct fields", "how to define payment context data in hyperswitch router", "L2L3Data struct definition hyperswitch domain models"], "label": "Payment context data struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "L2L3Data", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: try_from\n    fn try_from(value: pii::Email) -> UserResult<Self> {\n        Self::new(Secret::new(\n            value\n                .peek()\n                .split_once('@')\n                .ok_or(UserErrors::InvalidEmailError)?\n                .0\n                .to_string(),\n        ))\n    }\n}\n\n#[derive(Clone, Debug)]", "positive": "The `try_from` function in `user.rs` implements the `TryFrom` trait for `pii::Email`, converting it into a `User` domain model. It extracts the local part of the email address (the substring before '@') using `split_once`, which is a standard identifier for user accounts in the Hyperswitch payment orchestration platform. This conversion is critical for the domain layer, ensuring that user identities are consistently represented as `User` objects with a `Secret`-wrapped username, facilitating secure and normalized data handling across the router and storage layers.", "queries": ["rust try_from email to user hyperswitch", "how to convert email to user struct in hyperswitch", "hyperswitch user domain model email parsing", "rust split_once email to username hyperswitch"], "label": "Email to User conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` method within the Boku connector implementation serves as the configuration layer for outgoing HTTP requests. It retrieves the necessary authentication headers and metadata required to communicate with the Boku payment gateway. This function is invoked during the authorization process, specifically within the `PaymentsAuthorizeRouterData` flow, to ensure the request is properly authenticated and compliant with Boku's API specifications. It relies on the `Connectors` context to access specific configuration parameters, such as API keys or secret identifiers, which are masked for security before transmission.", "queries": ["how to configure Boku connector authentication headers in hyperswitch", "rust hyperswitch boku get_headers implementation", "hyperswitch boku payment gateway integration headers", "PaymentsAuthorizeRouterData boku connector configuration"], "label": "Boku connector header configuration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentOutcome\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]", "positive": "The `PaymentOutcome` enum in `hyperswitch_connectors` defines the final status of a transaction after processing by a connector like Worldpay. It includes states such as `Authorized`, `Refused`, `SentForSettlement`, `SentForRefund`, and `SentForCancellation`. Crucially, it supports multiple aliases (e.g., 'authorized', 'Sent for Settlement') to normalize inconsistent responses from external payment gateways into a unified internal domain model, ensuring robust error handling and status tracking within the payment orchestration flow.", "queries": ["Rust enum definition for payment outcome status hyperswitch", "Worldpay connector payment outcome enum aliases hyperswitch", "hyperswitch PaymentOutcome enum SentForSettlement SentForRefund", "payment orchestration status enum hyperswitch connectors"], "label": "Payment outcome enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "PaymentOutcome", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = thunes::ThunesRouterData::from((amount, req));\n        let connector_req = thunes::ThunesPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function constructs the JSON payload for a Thunes payment authorization request. It leverages the `amount_converter` utility to transform the incoming `minor_amount` and `currency` into a standardized format required by the Thunes API. The resulting data is wrapped into a `ThunesPaymentsRequest` struct and returned as a `RequestContent::Json` object, serving as the specific body for the outgoing HTTP call to the Thunes connector.", "queries": ["how to format amount for thunes connector rust", "thunes payments request body structure hyperswitch", "convert minor amount to thunes format rust", "hyperswitch thunes connector request payload"], "label": "Thunes request body builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_id\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "positive": "This function retrieves a specific MerchantConnectorAccount entity by its unique ID, acting as a critical lookup layer within the storage abstraction. It bridges the domain layer with the underlying router store implementation, handling the retrieval of payment provider credentials and configuration. The function is designed to be async and returns a CustomResult, ensuring robust error handling for scenarios where the account ID does not exist or key store access fails. It is a core component of the storage module, facilitating the retrieval of connector-specific settings required for processing transactions.", "queries": ["rust hyperswitch find_merchant_connector_account_by_id implementation", "how to get merchant connector account details by id in hyperswitch", "hyperswitch storage layer merchant connector account lookup function", "rust code for retrieving merchant connector account configuration"], "label": "Merchant connector account retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "find_merchant_connector_account_by_id", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate\n    async fn update_modular_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsSyncData, types::PaymentsResponseData>,\n        _platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        _business_profile: &domain::Profile,\n        request_payment_method_data: Option<&domain::PaymentMethodData>,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        update_modular_pm_and_mandate_impl(state, resp, request_payment_method_data, payment_data)\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to update modular payment method and mandate\")\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[async_trait]\nimpl<F: Clone> PostUpdateTracker<F, PaymentData<F>, types::PaymentsSessionData>\n    for PaymentResponse\n{", "positive": "This function serves as a trait implementation for `PaymentResponse`, acting as a PostUpdateTracker. It orchestrates the synchronization of modular payment methods and mandates during a payment lifecycle. It accepts a `SessionState`, `RouterData`, and mutable `PaymentData`, delegating the core logic to `update_modular_pm_and_mandate_impl`. It handles the context conversion to an `ApiErrorResponse` if the underlying implementation fails, ensuring the router can gracefully report internal synchronization errors.", "queries": ["rust hyperswitch payment response trait implementation", "hyperswitch update_modular_pm_and_mandate function signature", "how to implement PostUpdateTracker for payment methods in hyperswitch", "hyperswitch router payment response sync logic"], "label": "PaymentResponse PostUpdateTracker trait", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__payments__operations__payment_response.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "symbol": "update_modular_pm_and_mandate", "unit_type": "function", "num_lines": 24}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_id\n    pub fn get_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.id.clone())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "positive": "This function retrieves the unique identifier for a Merchant Connector Account entity. It is part of the `MerchantConnectorAccount` enum variant within the domain models, handling the polymorphic structure of connector configurations. It returns a `MerchantConnectorAccountId` type, returning `None` for the `MerchantConnectorDetails` variant. This method is essential for routing payment requests to the correct external provider configuration and is used by the router and scheduler to associate operations with specific connector settings.", "queries": ["rust hyperswitch get_id merchant connector account", "how to retrieve merchant connector account id in hyperswitch", "hyperswitch domain models merchant connector account identifier", "rust enum get_id merchant connector account hyperswitch"], "label": "MerchantConnectorAccount ID retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "get_id", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_mandate_reference\n    pub fn get_mandate_reference(&self) -> Option<MandateReference> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.as_ref().clone()\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "positive": "The `get_mandate_reference` method retrieves the mandate reference associated with a payment transaction response. It is a utility function designed to extract and return the mandate identifier from the `TransactionResponse` variant of the enum. If the current instance is not a `TransactionResponse` or the mandate reference is absent, it returns `None`. This function is essential for downstream processing where the specific mandate linked to a transaction must be identified, facilitating actions like mandate verification or linking subsequent payment attempts to the correct mandate.", "queries": ["how to get mandate reference from transaction response", "hyperswitch get_mandate_reference function", "rust get_mandate_reference example", "mandate reference extraction hyperswitch"], "label": "get_mandate_reference function", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "get_mandate_reference", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: test_masked_types\n    fn test_masked_types() {\n        let sort_code = MaskedSortCode::from(\"110011\".to_string());\n        let routing_number = MaskedRoutingNumber::from(\"056008849\".to_string());\n        let bank_account = MaskedBankAccount::from(\"12345678901234\".to_string());\n        let iban = MaskedIban::from(\"NL02ABNA0123456789\".to_string());\n        let upi_vpa = MaskedUpiVpaId::from(\"someusername@okhdfcbank\".to_string());\n\n        // Standard masked data tests\n        assert_eq!(sort_code.0.peek().to_owned(), \"11**11\".to_string());\n        assert_eq!(routing_number.0.peek().to_owned(), \"056***849\".to_string());\n        assert_eq!(\n            bank_account.0.peek().to_owned(),\n            \"1234******1234\".to_string()\n        );\n        assert_eq!(iban.0.peek().to_owned(), \"NL02A********56789\".to_string());\n        assert_eq!(\n            upi_vpa.0.peek().to_owned(),\n            \"so**********@okhdfcbank\".to_string()\n        );\n    }\n\n    #[test]", "positive": "This unit test validates the masking logic for sensitive financial identifiers within the `common_utils` crate. It instantiates `MaskedSortCode`, `MaskedRoutingNumber`, `MaskedBankAccount`, `MaskedIban`, and `MaskedUpiVpaId` types, asserting that their internal string representations are correctly obfuscated (e.g., '11**11', '056***849'). This ensures data sanitization compliance for logging and debugging in the payment orchestration platform.", "queries": ["how to mask bank account numbers in hyperswitch", "test for masked sort code implementation", "sanitize sensitive data in hyperswitch common utils", "verify masking logic for routing numbers"], "label": "financial data masking test", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__common_utils__src__new_type.rs", "path": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "symbol": "test_masked_types", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.common_get_content_type().to_string().into(),\n        )];\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth_header);\n        Ok(header)\n    }\n}\n", "positive": "This function constructs the HTTP request headers for Powertranz connector operations. It initializes the payload with a Content-Type header derived from the connector's configuration and appends authentication credentials retrieved via `get_auth_header`. The method ensures the request is properly formatted and authorized before transmission to the Powertranz gateway.", "queries": ["how to configure Powertranz connector authentication headers", "rust hyperswitch powertranz build_headers implementation", "Powertranz connector HTTP header setup hyperswitch", "hyperswitch powertranz get_auth_header usage"], "label": "Powertranz connector header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: clip_to_end\n    fn clip_to_end(\n        &self,\n        value: Self::SeriesType,\n    ) -> error_stack::Result<Self::SeriesType, PostProcessingError>;\n}\n\nimpl<T> QueryFilter<T> for analytics_api::TimeRange\nwhere\n    T: AnalyticsDataSource,\n    time::PrimitiveDateTime: ToSql<T>,\n    AnalyticsCollection: ToSql<T>,\n    Granularity: GroupByClause<T>,\n{", "positive": "The `clip_to_end` method truncates a time series or data stream to its final timestamp, effectively discarding all historical data points prior to the current moment. This function is critical for generating real-time analytics reports where only the most recent state is relevant, ensuring memory efficiency and reducing processing overhead on the `analytics` crate's query engine.", "queries": ["rust hyperswitch analytics clip_to_end truncate time series", "how to limit time range to current time in hyperswitch analytics", "hyperswitch analytics query filter clip_to_end implementation", "rust truncate time series to end function hyperswitch"], "label": "Time series truncation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "clip_to_end", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "positive": "This function implements a constructor for a struct, likely a request or response wrapper, accepting a tuple of a monetary amount (in minor units) and router-specific data. It is a core transformation step in the connector's flow, converting raw input data into a structured object ready for processing or transmission to the router. It appears to be part of the Klarna connector's data transformation layer within the hyperswitch_connectors crate.", "queries": ["Klarna connector amount and router data transformation Rust", "hyperswitch Klarna from function minor unit router_data", "Rust struct constructor from tuple amount router_data hyperswitch", "Klarna payment orchestration connector data transformation Rust"], "label": "Klarna connector data transformation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "symbol": "from", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_resource_id\n    pub fn get_resource_id(&self) -> Result<ResponseId, error_stack::Report<ConnectorError>> {\n        self.events\n            .clone()\n            .ok_or(\n                ConnectorError::MissingRequiredField {\n                    field_name: \"href resource id\",\n                }\n                .into(),\n            )\n            .and_then(|event| event.get_response_id())\n    }", "positive": "This function retrieves the unique `ResponseId` from a cloned events object, handling the absence of events by returning a `ConnectorError::MissingRequiredField` with the specific message 'href resource id'. It is a critical utility in the Worldpay Modular connector's response transformer, ensuring the orchestration platform can correctly map third-party payment gateway responses to internal transaction identifiers for downstream processing and reconciliation.", "queries": ["how to extract response id from worldpay modular events", "rust function get_resource_id worldpay connector error handling", "hyperswitch worldpay modular response transformer missing field", "worldpay modular connector response id extraction logic"], "label": "Worldpay Modular Response ID Extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "get_resource_id", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: PaymentResponse\npub struct PaymentResponse {\n    pub id: String,\n    pub status: PaymentStatus,\n    pub status_reason_information: Option<String>,\n    pub authentication: Option<Authentication>,\n    pub error_info: Option<ErrorInfo>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "positive": "The PaymentResponse struct defines the standard output format for successful payment transactions within the Hyperswitch payment orchestration platform. It encapsulates core transaction details such as the unique payment ID, current status, and optional status reasons. Crucially, it includes an Authentication object for 3D Secure verification outcomes and an ErrorInfo object for handling failures. This structure is used by the router to serialize responses for clients and is central to the API's domain models, ensuring consistent data representation across the system.", "queries": ["Rust struct definition for payment response in hyperswitch", "hyperswitch PaymentResponse fields authentication error_info", "how to parse hyperswitch payment response struct", "hyperswitch domain models payment response rust"], "label": "PaymentResponse struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "PaymentResponse", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_accounts_store_interface_map\n    pub async fn get_accounts_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::AccountsStorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_accounts_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    #[cfg(feature = \"olap\")]", "positive": "This function constructs a runtime mapping of Tenant IDs to their specific AccountsStorageInterface implementations. It iterates through the application's tenant configuration, initializing a unique storage backend for each tenant using the provided StorageImpl, event handler, and cache store. It utilizes `futures::future::join_all` to parallelize the initialization of these interfaces, ensuring efficient startup and handling of multi-tenant storage contexts within the router.", "queries": ["How to initialize storage interfaces for multiple tenants in parallel", "Rust code for creating accounts storage interface map", "get_accounts_store_interface_map implementation hyperswitch", "hyperswitch router tenant storage interface initialization"], "label": "Tenant storage interface map initialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "get_accounts_store_interface_map", "unit_type": "function", "num_lines": 31}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n\n        let mut has_upper_case = false;\n        let mut has_lower_case = false;\n        let mut has_numeric_value = false;\n        let mut has_special_character = false;\n        let mut has_whitespace = false;\n\n        for c in password.chars() {\n            has_upper_case = has_upper_case || c.is_uppercase();\n            has_lower_case = has_lower_case || c.is_lowercase();\n            has_numeric_value = has_numeric_value || c.is_numeric();\n            has_special_character = has_special_character || !c.is_alphanumeric();\n            has_whitespace = has_whitespace || c.is_whitespace();\n        }\n\n        let is_password_format_valid = has_upper_case\n            && has_lower_case\n            && has_numeric_value\n            && has_special_character\n            && !has_whitespace;\n\n        let is_too_long = password.graphemes(true).count() > consts::user::MAX_PASSWORD_LENGTH;\n        let is_too_short = password.graphemes(true).count() < consts::user::MIN_PASSWORD_LENGTH;\n\n        if is_too_short || is_too_long || !is_password_format_valid {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "positive": "The `new` function in `user.rs` constructs a `User` struct by validating a provided password against strict complexity rules. It checks for the presence of uppercase, lowercase, numeric, and special characters while ensuring no whitespace is present. Additionally, it enforces minimum and maximum length constraints defined in `consts::user`. If validation fails, it returns a `PasswordParsingError`. This function is critical for enforcing security policies within the Hyperswitch payment orchestration platform, ensuring user accounts adhere to robust password standards.", "queries": ["how to create a new user with password validation in hyperswitch rust", "hyperswitch user struct password validation logic rust", "rust password complexity check in hyperswitch user module", "hyperswitch consts user max password length validation"], "label": "User password validation constructor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "new", "unit_type": "function", "num_lines": 32}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_mca_id\n    pub fn get_mca_id(&self) -> Option<id_type::MerchantConnectorAccountId> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                Some(merchant_connector_account.get_id())\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "positive": "The `get_mca_id` method retrieves the unique identifier for a Merchant Connector Account (MCA) from a domain model variant. It is a public accessor used to distinguish between the MCA and its details, returning the internal ID for the MCA variant or None for the details variant. This is essential for downstream routing and storage operations that require the specific MCA identifier.", "queries": ["rust hyperswitch get_mca_id function implementation", "how to extract merchant connector account id from hyperswitch domain model", "hyperswitch get_mca_id returns None for details variant", "merchant_connector_account get_mca_id rust source code"], "label": "MCA ID accessor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "get_mca_id", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_enabled_connector_accounts_by_profile_id\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]", "positive": "This function retrieves a list of active merchant connector accounts associated with a specific profile ID, filtered by connector type. It acts as a critical abstraction layer within the storage_impl crate, delegating the actual database query to the router_store. The function accepts a MerchantKeyStore reference for cryptographic verification and returns a vector of domain::MerchantConnectorAccount objects, ensuring only enabled accounts are returned for the specified profile.", "queries": ["rust hyperswitch list_enabled_connector_accounts_by_profile_id implementation", "how to get merchant connector accounts by profile id in hyperswitch", "hyperswitch storage_impl merchant connector account list function", "rust code for listing enabled accounts by profile id hyperswitch"], "label": "List enabled connector accounts by profile", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "list_enabled_connector_accounts_by_profile_id", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: determine_connector_integration_type\nasync fn determine_connector_integration_type(\n    state: &SessionState,\n    connector: Connector,\n) -> RouterResult<ConnectorIntegrationType> {\n    match state.conf.grpc_client.unified_connector_service.as_ref() {\n        Some(ucs_config) => {\n            let is_ucs_only = ucs_config.ucs_only_connectors.contains(&connector);\n\n            if is_ucs_only {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    ucs_only_list = is_ucs_only,\n                    \"Using UcsConnector\"\n                );\n                Ok(ConnectorIntegrationType::UcsConnector)\n            } else {\n                router_env::logger::debug!(\n                    connector = ?connector,\n                    \"Using DirectandUCSConnector - not in ucs_only_list\"\n                );\n                Ok(ConnectorIntegrationType::DirectandUCSConnector)\n            }\n        }\n        None => {\n            router_env::logger::debug!(\n                connector = ?connector,\n                \"UCS config not present, using DirectandUCSConnector\"\n            );\n            Ok(ConnectorIntegrationType::DirectandUCSConnector)\n        }\n    }\n}\n", "positive": "This function determines the integration type for a specific connector within the Hyperswitch payment orchestration platform. It checks the Unified Connector Service (UCS) configuration to see if the connector is designated as 'ucs_only'. If present in the list, it returns UcsConnector; otherwise, it defaults to DirectandUCSConnector. This logic is crucial for routing payment requests to the appropriate connector implementation, ensuring correct handling of both direct and UCS-based integrations based on the runtime configuration.", "queries": ["How to configure UCS only connectors in Hyperswitch router", "Rust function to check connector integration type in router", "Hyperswitch determine_connector_integration_type implementation", "How does router decide between UcsConnector and DirectandUCSConnector"], "label": "Connector integration type determination", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "determine_connector_integration_type", "unit_type": "function", "num_lines": 33}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let barclaycard_req = self.get_request_body(req, connectors)?;\n        let http_method = self.get_http_method();\n        let auth = barclaycard::BarclaycardAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.barclaycard.base_url.as_str();\n        let barclaycard_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = barclaycard_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(barclaycard_req.get_inner_value().expose().as_bytes());\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (V_C_MERCHANT_ID.to_string(), merchant_account.into_masked()),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "positive": "This function constructs the HTTP request headers for the Barclays connector integration within the Hyperswitch payment orchestration platform. It dynamically generates a cryptographic signature using the merchant account, request path, HTTP method, current UTC timestamp, and the SHA-256 digest of the request body. It sets standard headers like Content-Type, Accept, Host, and Date, and conditionally appends the Digest header for POST/PUT requests. The function relies on the `RouterData` context to retrieve authentication details and URL paths, ensuring secure and compliant communication with the Barclays API.", "queries": ["how to generate Barclays API signature in Rust hyperswitch", "hyperswitch barclaycard connector build_headers implementation", "Rust function to create Barclays payment request headers", "hyperswitch barclaycard signature generation SHA-256"], "label": "Barclays signature generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 55}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Destination\npub struct Destination {\n    full_name: Secret<String>,\n    organization: Option<String>,\n    email: Option<Email>,\n    address: Address,\n}\n\n#[derive(Debug, Serialize, Deserialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "positive": "The `Destination` struct defines the target entity for a payment transaction, encapsulating sensitive credentials like the full name (stored as a Secret) and contact details (email, address). It is used within the `signifyd` connector transformer to map the final recipient of funds, ensuring secure handling of sensitive data while maintaining standard address formatting for the Signifyd fraud detection API integration.", "queries": ["Rust struct Destination hyperswitch signifyd connector", "how to define destination entity in signifyd transformer", "hyperswitch signifyd destination struct fields organization email", "signifyd fraud detection connector destination address rust"], "label": "Signifyd Destination Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "Destination", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Redsys\".to_string())\n                .into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Redsys\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "The `build_request` method in the Redsys connector implementation handles the initial request construction phase for payment flows. It accepts a `RouterData` struct containing `SetupMandate` context and `PaymentsResponseData`, along with a `Connectors` reference. Currently, this method is explicitly implemented to return a `NotImplemented` error, indicating that the Redsys connector does not support the 'Setup Mandate' flow variant within the Hyperswitch payment orchestration platform.", "queries": ["Redsys connector setup mandate build_request rust", "hyperswitch redsys build_request function not implemented", "how to implement setup mandate in redsys connector rust", "redsys setup mandate flow hyperswitch error handling"], "label": "Redsys Setup Mandate build_request", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: IatapayPaymentsResponse\npub struct IatapayPaymentsResponse {\n    pub status: IatapayPaymentStatus,\n    pub iata_payment_id: Option<String>,\n    pub iata_refund_id: Option<String>,\n    pub merchant_id: Option<Secret<String>>,\n    pub merchant_payment_id: Option<String>,\n    pub amount: FloatMajorUnit,\n    pub currency: String,\n    pub checkout_methods: Option<CheckoutMethod>,\n    pub failure_code: Option<String>,\n    pub failure_details: Option<String>,\n}\n", "positive": "This struct defines the response payload returned by the IATAPay connector after processing a payment transaction. It encapsulates the transaction status, unique identifiers (IATA payment/refund IDs), and financial details (amount, currency). It also includes merchant-specific IDs for reconciliation and optional failure codes or checkout method metadata, serving as the data model for the `IatapayPaymentsResponse` transformer in the `hyperswitch_connectors` crate.", "queries": ["rust struct definition for IatapayPaymentsResponse", "IATAPay connector response model hyperswitch", "hyperswitch IATAPay payment response fields", "IatapayPaymentsResponse struct definition rust"], "label": "IATAPay payment response model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "symbol": "IatapayPaymentsResponse", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_meta_constraints\n    async fn filter_refund_by_meta_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<api_models::refunds::RefundListMetaData, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "positive": "This function retrieves a paginated list of refund metadata filtered by specific merchant constraints. It accepts a MerchantId, a TimeRange for the refund window, and the storage scheme (e.g., tenant schema) to ensure data isolation. The result is wrapped in a RefundListMetaData struct, handling potential storage errors during the query execution. It is a core component of the router's refund retrieval logic, ensuring that only relevant, authorized refund records are exposed to the API layer.", "queries": ["rust hyperswitch filter_refund_by_meta_constraints implementation", "how to get refund list metadata by merchant id and time range", "hyperswitch router refund filtering storage scheme", "rust function signature filter_refund_by_meta_constraints"], "label": "Refund metadata filtering", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "filter_refund_by_meta_constraints", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentLinks\npub struct PaymentLinks {\n    #[serde(\n        rename = \"cardPayments:events\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub events: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:settle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialSettle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:refund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialRefund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:reverse\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub reverse_event: Option<PaymentLink>,\n    #[serde(rename = \"tokens:token\", skip_serializing_if = \"Option::is_none\")]\n    pub token: Option<SecretPaymentLink>,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "positive": "The `PaymentLinks` struct defines the configuration for webhook event triggers associated with a payment link. It serializes specific event typessuch as `settle`, `refund`, `partial_refund`, `reverse`, and `partial_settle`into a nested `PaymentLink` object, mapping them to the WorldPay Modular API's `cardPayments:*` keys. It also handles token generation via the `tokens:token` key, returning a `SecretPaymentLink`. This struct is used within the WorldPay Modular response transformer to map incoming webhook configurations to Hyperswitch's internal domain models, ensuring that payment link lifecycle events are correctly routed and processed by the router.", "queries": ["WorldPay Modular webhook configuration struct", "how to configure payment link events in WorldPay Modular", "WorldPay Modular response transformer PaymentLinks struct", "hyperswitch worldpay modular webhook event mapping"], "label": "WorldPay Modular webhook config struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "PaymentLinks", "unit_type": "function", "num_lines": 36}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = sift::SiftRouterData::from((amount, req));\n        let connector_req = sift::SiftPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function prepares the request payload for the Sift payment connector by converting the internal minor amount to the connector's expected format. It constructs a `SiftRouterData` object from the incoming `PaymentsAuthorizeRouterData` and attempts to deserialize it into a `SiftPaymentsRequest`. The resulting JSON content is then wrapped in a `RequestContent` struct before being returned, serving as the specific input for the Sift integration within the Hyperswitch payment orchestration flow.", "queries": ["how to get request body for Sift payments connector", "rust function to convert PaymentsAuthorizeRouterData to SiftPaymentsRequest", "hyperswitch sift connector request payload preparation", "SiftPaymentsRequest try_from implementation in hyperswitch"], "label": "Sift payments request payload builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: assertion_from_graph_error\n    fn assertion_from_graph_error(metadata: &Metadata, graph_error: cgraph::GraphError<V>) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::AssertionTrace {\n                trace,\n                metadata: metadata.clone(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n", "positive": "This function handles the conversion of graph analysis errors into typed assertion objects within the DSA (Data Structure Analysis) graph module. It acts as a type-safe error mapper, taking raw `GraphError` variantsspecifically `AnalysisError` containing a traceand wrapping them into `AssertionTrace` instances. It preserves the original `Metadata` context and falls back to a generic `Graph` wrapper for any unhandled error types, ensuring robust error propagation in the graph traversal logic.", "queries": ["how to handle graph analysis errors in rust dsa module", "rust assertion_from_graph_error function implementation", "convert cgraph GraphError to assertion trace", "hyperswitch dsa graph error handling metadata"], "label": "Graph error type conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "assertion_from_graph_error", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: get_access_token_from_ucs_response\npub async fn get_access_token_from_ucs_response(\n    session_state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n    merchant_connector_id: Option<&id_type::MerchantConnectorAccountId>,\n    creds_identifier: Option<String>,\n    ucs_state: Option<&unified_connector_service_client::payments::ConnectorState>,\n) -> Option<AccessToken> {\n    let ucs_access_token = ucs_state\n        .and_then(|state| state.access_token.as_ref())\n        .map(AccessToken::foreign_from)?;\n\n    let merchant_id = processor.get_account().get_id();\n\n    let merchant_connector_id_or_connector_name = merchant_connector_id\n        .map(|mca_id| mca_id.get_string_repr().to_string())\n        .or(creds_identifier.map(|id| id.to_string()))\n        .unwrap_or(connector_name.to_string());\n\n    let key = common_utils::access_token::get_default_access_token_key(\n        merchant_id,\n        merchant_connector_id_or_connector_name,\n    );\n\n    if let Ok(Some(cached_token)) = session_state.store.get_access_token(key).await {\n        if cached_token.token.peek() == ucs_access_token.token.peek() {\n            return None;\n        }\n    }\n\n    Some(ucs_access_token)\n}\n", "positive": "This function retrieves an access token from a Unified Connector Service (UCS) response, specifically handling the logic to determine if a new token is needed. It compares the UCS-provided token against a cached token stored in the session state. If the tokens match, it returns None to prevent unnecessary updates; otherwise, it returns the UCS token. The function constructs a cache key using the merchant ID and the connector identifier (either a specific merchant connector ID or the connector name). This ensures the router uses the correct credentials for the specific payment processor context defined in the UCS state.", "queries": ["how to get access token from UCS response in hyperswitch router", "hyperswitch router access token caching logic comparison", "rust function get_access_token_from_ucs_response implementation", "hyperswitch unified connector service token retrieval session state"], "label": "UCS Token Retrieval Logic", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "get_access_token_from_ucs_response", "unit_type": "function", "num_lines": 33}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_object_reference_id\n    fn get_webhook_object_reference_id(\n        &self,\n        request: &IncomingWebhookRequestDetails<'_>,\n    ) -> CustomResult<ObjectReferenceId, ConnectorError> {\n        let webhook_body: netcetera::ResultsResponseData = request\n            .body\n            .parse_struct(\"netcetera ResultsResponseData\")\n            .change_context(ConnectorError::WebhookBodyDecodingFailed)?;\n        Ok(ObjectReferenceId::ExternalAuthenticationID(\n            AuthenticationIdType::ConnectorAuthenticationId(webhook_body.three_ds_server_trans_id),\n        ))\n    }\n", "positive": "This function extracts the unique transaction identifier from a Netcetera webhook payload. It parses the incoming webhook body into a ResultsResponseData struct and maps the 'three_ds_server_trans_id' field to an ObjectReferenceId, specifically using the ExternalAuthenticationID type. This is a critical integration step for verifying and reconciling 3D Secure authentication events received from the Netcetera connector.", "queries": ["How to get transaction ID from Netcetera webhook in Rust?", "netcetera webhook three_ds_server_trans_id parsing hyperswitch", "hyperswitch get_webhook_object_reference_id implementation", "Rust connector extract transaction ID from webhook body"], "label": "Netcetera webhook transaction ID extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "get_webhook_object_reference_id", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: gpayments_types::TDS2ApiError = res\n            .response\n            .parse_struct(\"gpayments_types TDS2ApiError\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_code,\n            message: response.error_description,\n            reason: response.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a G-Payments API response. It deserializes the raw HTTP body into a TDS2ApiError struct, logs the error details for observability, and populates the error fields including status code, error code, description, and reason. It optionally attaches the parsed error body to a ConnectorEvent for downstream processing, ensuring the router receives a consistent error format regardless of the specific connector failure.", "queries": ["how to handle gpayments error response in hyperswitch", "build_error_response function implementation rust hyperswitch", "parse gpayments TDS2ApiError into ErrorResponse", "hyperswitch connector error handling gpayments"], "label": "G-Payments Error Response Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(format!(\n            \"{}api/payment-token/{}\",\n            self.base_url(connectors),\n            auth.campaign_id.peek()\n        ))\n    }\n", "positive": "This function constructs the API endpoint URL for the Gigadat payment token service. It retrieves the authentication type (GigadatAuthType) from the request context, validates it, and appends the campaign ID to the base URL. It is a critical helper for the Gigadat connector's authorization flow, ensuring the correct token endpoint is called based on the specific campaign configuration.", "queries": ["how to get gigadat payment token url", "gigadat connector authorization endpoint rust hyperswitch", "hyperswitch gigadat get_url function implementation", "gigadat campaign_id url construction hyperswitch"], "label": "Gigadat token endpoint builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: LocalInstrument\npub enum LocalInstrument {\n    Sepa,\n    SepaInstant,\n    FasterPayments,\n    Elixir,\n    Bankgiro,\n    Plusgiro,\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(untagged)]", "positive": "The `LocalInstrument` enum in `tokenio/transformers.rs` defines the specific payment instrument types supported by the Tokenio connector, including SEPA, SEPA Instant, Faster Payments, Elixir, Bankgiro, and Plusgiro. It serves as a critical data model for mapping generic payment method identifiers to Tokenio-specific instrument types, ensuring accurate transaction routing and validation within the Hyperswitch payment orchestration platform.", "queries": ["How to configure SEPA Instant payment methods in Hyperswitch Tokenio connector?", "What are the supported LocalInstrument types for Tokenio integration?", "Rust enum definition for LocalInstrument in hyperswitch tokenio transformers", "Mapping Hyperswitch payment methods to Tokenio LocalInstrument types"], "label": "LocalInstrument enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "LocalInstrument", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = globepay::GlobepayRouterData::from((amount, req));\n        let connector_req = globepay::GlobepayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function constructs the JSON payload for a Globepay payment authorization request. It leverages the `amount_converter` to transform the incoming `PaymentsAuthorizeRouterData` into the specific minor amount and currency format required by the Globepay API. It then instantiates `GlobepayRouterData` and attempts to convert this into a `GlobepayPaymentsRequest` struct, returning the result as a boxed JSON `RequestContent` for the connector to execute.", "queries": ["how to format amount for globepay authorization request", "globepay connector request body structure rust hyperswitch", "PaymentsAuthorizeRouterData to GlobepayPaymentsRequest conversion", "hyperswitch globepay connector get_request_body implementation"], "label": "Globepay authorization request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response_data: Result<boku::BokuErrorResponse, Report<errors::ConnectorError>> = res\n            .response\n            .parse_struct(\"boku::BokuErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed);\n\n        match response_data {\n            Ok(response) => {\n                event_builder.map(|i| i.set_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.reason,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(_) => get_xml_deserialized(res, event_builder),\n        }\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse from a Boku connector's HTTP response. It attempts to deserialize the response body into a BokuErrorResponse struct; if successful, it populates the error details and logs the response. If deserialization fails, it delegates to a fallback XML deserialization method. This ensures consistent error handling across the payment orchestration platform, mapping raw connector errors into a unified internal format for downstream processing and logging.", "queries": ["how to handle boku connector error responses in hyperswitch", "build_error_response function implementation hyperswitch rust", "parse boku error response struct hyperswitch connector", "hyperswitch boku integration error handling rust code"], "label": "Boku error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 33}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` function within the Powertranz connector implementation serves as the configuration layer for HTTP request metadata. It is invoked by the router's `PaymentsAuthorizeRouterData` flow to dynamically assemble headers required for secure communication with the Powertranz gateway. By utilizing the `build_headers` method, it integrates with the `Connectors` context to inject tenant-specific configurations, API keys, and signature generation parameters. This ensures that authorization requests are authenticated and compliant with Powertranz's API specifications before transmission.", "queries": ["rust hyperswitch powertranz connector get_headers implementation", "how to configure headers for powertranz payment gateway in hyperswitch rust", "hyperswitch powertranz authorize request headers builder", "rust function get_headers powertranz hyperswitch connector"], "label": "Powertranz connector header configuration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityRequest\npub struct AuthenticationEligibilityRequest {\n    /// Payment method-specific data such as card details, wallet info, etc.\n    /// This holds the raw information required to process the payment method.\n    #[schema(value_type = PaymentMethodData)]\n    pub payment_method_data: PaymentMethodData,\n\n    /// Enum representing the type of payment method being used\n    /// (e.g., Card, Wallet, UPI, BankTransfer, etc.).\n    #[schema(value_type = PaymentMethod)]\n    pub payment_method: common_enums::PaymentMethod,\n\n    /// Can be used to specify the Payment Method Type\n    #[schema(value_type = Option<PaymentMethodType>, example = \"debit\")]\n    pub payment_method_type: Option<enums::PaymentMethodType>,\n\n    /// Optional secret value used to identify and authorize the client making the request.\n    /// This can help ensure that the payment session is secure and valid.\n    #[schema(value_type = Option<String>)]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// Optional identifier for the business profile associated with the payment.\n    /// This determines which configurations, rules, and branding are applied to the transaction.\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Optional billing address of the customer.\n    /// This can be used for fraud detection, authentication, or compliance purposes.\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n\n    /// Optional shipping address of the customer.\n    /// This can be useful for logistics, verification, or additional risk checks.\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n\n    /// Optional information about the customer's browser (user-agent, language, etc.).\n    /// This is typically used to support 3DS authentication flows and improve risk assessment.\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n\n    /// Optional email address of the customer.\n    /// Used for customer identification, communication, and possibly for 3DS or fraud checks.\n    #[schema(value_type = Option<String>)]\n    pub email: Option<common_utils::pii::Email>,\n}\n\n#[cfg(feature = \"v1\")]", "positive": "The AuthenticationEligibilityRequest struct serves as the input payload for the authentication eligibility check flow within the Hyperswitch payment orchestration engine. It aggregates raw payment method data (like card details) with contextual metadata required to determine if a transaction is eligible for processing. Key fields include the specific payment method type, optional business profile ID for rule application, and customer details like billing/shipping addresses and browser information, which are critical for fraud detection and 3DS (Three-Domain Secure) authentication flows. This struct is defined in the api_models crate and is typically deserialized from incoming HTTP requests to the router before being passed to domain logic.", "queries": ["rust hyperswitch authentication eligibility request struct fields", "how to construct AuthenticationEligibilityRequest for 3ds flow", "hyperswitch api_models AuthenticationEligibilityRequest payment_method_data", "rust struct definition for payment authentication eligibility check"], "label": "Authentication eligibility request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__api_models__src__authentication.rs", "path": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "symbol": "AuthenticationEligibilityRequest", "unit_type": "function", "num_lines": 47}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_webhook_event_type\n    fn get_webhook_event_type(\n        &self,\n        _request: &IncomingWebhookRequestDetails<'_>,\n        _context: Option<&WebhookContext>,\n    ) -> CustomResult<IncomingWebhookEvent, ConnectorError> {\n        Ok(IncomingWebhookEvent::ExternalAuthenticationARes)\n    }\n", "positive": "This function implements the event type extraction logic for the Netcetera connector within the Hyperswitch payment orchestration platform. It is responsible for parsing the incoming webhook request to identify the specific event type, which determines the subsequent processing flow. In this specific implementation, the function is hardcoded to return 'ExternalAuthenticationARes', indicating that the connector is configured to handle a specific type of external authentication event. This logic is critical for the webhook wrapper to correctly route the event to the appropriate handler for verification and downstream processing.", "queries": ["how to configure Netcetera webhook event type in hyperswitch", "hyperswitch netcetera connector get_webhook_event_type implementation", "rust hyperswitch netcetera webhook event parsing", "hyperswitch incoming webhook event type extraction netcetera"], "label": "Netcetera webhook event type extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "get_webhook_event_type", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: QueryBuildingError\npub enum QueryBuildingError {\n    #[allow(dead_code)]\n    #[error(\"Not Implemented: {0}\")]\n    NotImplemented(String),\n    #[error(\"Failed to Serialize to SQL\")]\n    SqlSerializeError,\n    #[error(\"Failed to build sql query: {0}\")]\n    InvalidQuery(&'static str),\n}\n\n#[derive(thiserror::Error, Debug)]", "positive": "The `QueryBuildingError` enum in `crates/analytics/src/query.rs` defines specific error variants for the analytics query builder. It handles serialization failures (`SqlSerializeError`), unsupported operations (`NotImplemented`), and malformed SQL construction (`InvalidQuery`). This error handling is critical for the analytics module's integration with the storage layer, ensuring that data retrieval failures are distinct and actionable for debugging the payment orchestration platform's reporting pipelines.", "queries": ["rust hyperswitch QueryBuildingError enum definition", "hyperswitch analytics query builder error handling", "QueryBuildingError SqlSerializeError InvalidQuery variants", "hyperswitch rust error types analytics module"], "label": "QueryBuildingError enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "QueryBuildingError", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &MandateRevokeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}tms/v1/paymentinstruments/{}\",\n            self.base_url(connectors),\n            utils::RevokeMandateRequestData::get_connector_mandate_id(&req.request)?\n        ))\n    }", "positive": "This function constructs the API endpoint URL for revoking a mandate via the CyberSource connector. It appends the base URL and the specific mandate identifier extracted from the request payload using `RevokeMandateRequestData::get_connector_mandate_id`. It is part of the `Cybersource` connector implementation, handling the specific HTTP request path required by the CyberSource TMS (Transaction Management Service) to cancel a stored payment instrument mandate.", "queries": ["how to revoke mandate in cybersource connector", "cybersource revoke mandate url builder", "hyperswitch cybersource mandate revoke endpoint", "cybersource tms revoke mandate request url"], "label": "Cybersource mandate revoke URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::Scheduled | enums::CaptureMethod::ManualMultiple => Err(\n                utils::construct_not_implemented_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "positive": "This function validates the compatibility of the Authipay connector with the specified payment request configuration. It specifically checks the `capture_method` parameter to ensure the connector supports the requested transaction flow. It returns an error for unsupported methods like 'Scheduled' or 'ManualMultiple', while allowing 'Automatic', 'Manual', and 'SequentialAutomatic'. This validation occurs within the `hyperswitch_connectors` crate to enforce architectural constraints before payment processing.", "queries": ["how to handle scheduled capture method in Authipay connector", "Authipay connector capture_method validation error", "implementing sequential automatic capture in hyperswitch", "hyperswitch connector capture method not supported error"], "label": "Authipay capture method validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "validate_connector_against_payment_request", "unit_type": "function", "num_lines": 18}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: ErrorResponse\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "positive": "The `ErrorResponse` struct in `hyperswitch_connectors/src/connectors/wise/transformers.rs` defines the standardized response envelope for Wise connector interactions. It encapsulates error details such as HTTP status codes (`WiseHttpStatus`), descriptive messages, and a list of specific sub-errors. This structure ensures consistent error handling and logging across the payment orchestration platform's Wise integration, allowing the router to parse and relay precise failure reasons to clients.", "queries": ["Rust struct definition for Wise connector error response", "hyperswitch ErrorResponse struct Wise transformers", "Wise payment connector error handling struct", "how to handle Wise API errors in hyperswitch"], "label": "Wise connector error struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "ErrorResponse", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "positive": "This function serves as a placeholder stub within the Sift payment connector implementation. It is designed to validate a PaymentsSyncData reference ID during the synchronization process. Currently, it performs no validation logic (returns Ok(())) and accepts parameters for future implementation, specifically handling the `PaymentsSyncData` context, a ThreeDS flag, the attempt status, and optional connector metadata containing sensitive PII.", "queries": ["how to implement validate_psync_reference_id in sift connector", "rust placeholder function validate_psync_reference_id hyperswitch", "PaymentsSyncData validation logic sift connector hyperswitch", "hyperswitch sift connector validate_psync_reference_id implementation"], "label": "Sift connector validation stub", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "validate_psync_reference_id", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "positive": "This function retrieves authentication headers for the Sift payment connector. It accepts a generic `ConnectorAuthType` and converts it into a specific `SiftAuthType` using `try_from`. The function constructs a single header entry containing the `AUTHORIZATION` key and the Sift API key, which is masked using `masking::Maskable`. This is a standard connector interface implementation within the `hyperswitch_connectors` crate, ensuring secure credential injection for Sift-specific payment flows.", "queries": ["rust hyperswitch sift connector get_auth_header implementation", "how to configure sift authentication in hyperswitch rust", "hyperswitch sift payment connector api key header generation", "rust hyperswitch sift connector auth header masking"], "label": "Sift connector auth header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: helcim::HelcimErrorResponse = res\n            .response\n            .parse_struct(\"HelcimErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_string = match response {\n            transformers::HelcimErrorResponse::Payment(response) => match response.errors {\n                transformers::HelcimErrorTypes::StringType(error) => error,\n                transformers::HelcimErrorTypes::JsonType(error) => error.to_string(),\n            },\n            transformers::HelcimErrorResponse::General(error_string) => error_string,\n        };\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: NO_ERROR_CODE.to_owned(),\n            message: error_string.clone(),\n            reason: Some(error_string),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a Helcim API response, handling both payment-specific and general error structures. It deserializes the raw HTTP response into a HelcimErrorResponse, logs the details, and maps the Helcim-specific error types (StringType or JsonType) into a unified error message. The resulting ErrorResponse is returned with the original HTTP status code, while metadata fields like connector_transaction_id and network_advice_code are set to None, indicating this is a non-success response.", "queries": ["how to handle helcim error response in hyperswitch", "rust function build_error_response helcim connector", "hyperswitch helcim error parsing implementation", "helcim error types string json mapping hyperswitch"], "label": "Helcim error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 37}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                account_id: api_key.to_owned(),\n                user_id: key1.to_owned(),\n                pin: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]", "positive": "This `try_from` function implements a type conversion from `ConnectorAuthType` to a specific authentication struct (likely `ElavonAuth`). It handles the `SignatureKey` variant by extracting `api_key`, `key1`, and `api_secret` fields, mapping them to `account_id`, `user_id`, and `pin` respectively. This is a critical transformation step within the Elavon connector's data pipeline, ensuring raw authentication parameters are correctly formatted for downstream API calls or internal processing logic.", "queries": ["rust elavon connector signature key authentication conversion", "how does hyperswitch elavon transform auth type to signature key", "elavon connector try_from signature key implementation rust", "hyperswitch elavon auth pin account_id user_id mapping"], "label": "Elavon Auth Signature Key Conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_authorization_header\n    pub fn create_authorization_header(\n        &self,\n        auth: amazonpay::AmazonpayAuthType,\n        canonical_uri: &str,\n        http_method: &Method,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> String {\n        let amazonpay::AmazonpayAuthType {\n            public_key,\n            private_key,\n        } = auth;\n\n        let mut signed_headers =\n            format!(\"{HEADER_ACCEPT};{HEADER_CONTENT_TYPE};{HEADER_DATE};{HEADER_HOST};\",);\n        if *http_method == Method::Post\n            && Self::get_last_segment(canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            signed_headers.push_str(HEADER_IDEMPOTENCY_KEY);\n            signed_headers.push(';');\n        }\n        signed_headers.push_str(HEADER_REGION);\n\n        format!(\n            \"{} PublicKeyId={}, SignedHeaders={}, Signature={}\",\n            SIGNING_ALGO,\n            public_key.expose().clone(),\n            signed_headers,\n            Self::create_signature(\n                &private_key,\n                *http_method,\n                canonical_uri,\n                &signed_headers,\n                hashed_payload,\n                header\n            )\n            .unwrap_or_else(|_| \"Invalid signature\".to_string())\n        )\n    }\n", "positive": "This function constructs the authorization header for Amazon Pay API requests using AWS Signature Version 4. It dynamically builds the 'SignedHeaders' string by including standard headers (Accept, Content-Type, Date, Host) and conditionally adding 'Idempotency-Key' for POST requests that are not finalize operations. It then generates the final signature using the private key and returns the formatted string containing the PublicKeyId, SignedHeaders, and Signature.", "queries": ["how to generate amazon pay authorization header signature", "rust hyperswitch amazonpay create_authorization_header implementation", "hyperswitch connector amazonpay signature generation logic", "aws signature v4 amazonpay header construction rust"], "label": "Amazon Pay Signature Generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "create_authorization_header", "unit_type": "function", "num_lines": 40}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: save_pm_and_mandate\n    async fn save_pm_and_mandate<'b>(\n        &self,\n        state: &SessionState,\n        resp: &types::RouterData<F, types::PaymentsAuthorizeData, types::PaymentsResponseData>,\n        platform: &domain::Platform,\n        payment_data: &mut PaymentData<F>,\n        business_profile: &domain::Profile,\n    ) -> CustomResult<(), errors::ApiErrorResponse>\n    where\n        F: 'b + Clone + Send + Sync,\n    {\n        todo!()\n    }\n\n    #[cfg(feature = \"v1\")]", "positive": "This function, located in the Router crate's payment operations module, is responsible for persisting Payment Methods (PM) and Mandates to the database after a successful authorization response. It takes the authorization response data, the current session state, and the platform/business profile context to construct and execute the necessary database insertions. It is a critical step in the payment flow, ensuring that the PM and Mandate are stored for future transactions. The function signature indicates it is generic over a Future type, allowing for asynchronous operations. It returns a CustomResult to handle potential database errors or API response errors.", "queries": ["how to save payment method and mandate after authorization hyperswitch", "hyperswitch router save_pm_and_mandate function implementation", "rust hyperswitch payment operations save_pm_and_mandate", "hyperswitch database insert payment method mandate authorization"], "label": "Payment Method Persistence", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__payments__operations__payment_response.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "symbol": "save_pm_and_mandate", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: barclaycard::BarclaycardErrorResponse = res\n            .response\n            .parse_struct(\"BarclaycardErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            transformers::BarclaycardErrorResponse::StandardError(response) => {\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 739 chars] ...\n\n                  connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            transformers::BarclaycardErrorResponse::AuthenticationError(response) => {\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response.response.rmsg.clone(),\n                    reason: Some(response.response.rmsg),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n        }\n    }\n}\n", "positive": "This function handles the transformation of Barclaycard API error responses into the standardized ErrorResponse format used by Hyperswitch. It parses the raw HTTP response into a structured error object, extracting specific error codes, messages, and detailed reasons. It supports both standard error structures and authentication-specific errors, logging the response for debugging. The function is critical for mapping third-party payment gateway failures to internal error states, ensuring accurate error reporting to clients and proper handling of network advice codes.", "queries": ["How to handle Barclaycard API error responses in Rust", "Barclaycard connector error transformation logic hyperswitch", "Parse BarclaycardErrorResponse to ErrorResponse format", "Hyperswitch Barclaycard authentication error handling"], "label": "Barclaycard error response transformer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 97}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "The `get_error_response` method within the Zift connector implementation serves as a specialized error handling wrapper. It accepts a raw HTTP `Response` object and an optional mutable reference to a `ConnectorEvent` builder. Its primary purpose is to transform standard HTTP error states into the platform's standardized `ErrorResponse` format while simultaneously populating the event context for downstream webhook or audit logging. This function is critical for maintaining consistency across the payment orchestration platform, ensuring that errors from the Zift payment gateway are normalized and tracked correctly within the `hyperswitch_connectors` crate.", "queries": ["how to handle zift payment gateway error responses in rust", "zift connector error response builder hyperswitch", "rust function get_error_response zift connector", "hyperswitch zift error handling connector implementation"], "label": "Zift error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new\n    pub fn new(company_name: String) -> UserResult<Self> {\n        let company_name = company_name.trim();\n        let is_empty_or_whitespace = company_name.is_empty();\n        let is_too_long =\n            company_name.graphemes(true).count() > consts::user::MAX_COMPANY_NAME_LENGTH;\n\n        let is_all_valid_characters = company_name\n            .chars()\n            .all(|x| x.is_alphanumeric() || x.is_ascii_whitespace() || x == '_');\n        if is_empty_or_whitespace || is_too_long || !is_all_valid_characters {\n            Err(UserErrors::CompanyNameParsingError.into())\n        } else {\n            Ok(Self(company_name.to_string()))\n        }\n    }\n", "positive": "This function constructs a new `User` domain entity, validating the provided `company_name` string against strict constraints. It ensures the input is not empty, exceeds the maximum allowed length defined in `consts::user::MAX_COMPANY_NAME_LENGTH`, and contains only alphanumeric characters, whitespace, or underscores. If validation fails, it returns a `UserErrors::CompanyNameParsingError`; otherwise, it returns a successfully constructed `User` instance. This logic resides within the `hyperswitch_domain_models` crate, serving as a core data integrity layer for the router's user management module.", "queries": ["rust hyperswitch user domain model company name validation", "how to create a user entity with company name in hyperswitch rust", "hyperswitch domain models user struct new method validation", "rust hyperswitch user errors company name parsing error"], "label": "User domain model factory validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "new", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: RecurringDetails\npub enum RecurringDetails {\n    MandateId(String),\n    PaymentMethodId(String),\n    ProcessorPaymentToken(ProcessorPaymentToken),\n    /// Network transaction ID and Card Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndCardDetails(Box<NetworkTransactionIdAndCardDetails>),\n\n    /// Network transaction ID and Network Token Details for MIT payments when payment_method_data\n    /// is not stored in the application\n    NetworkTransactionIdAndNetworkTokenDetails(Box<NetworkTransactionIdAndNetworkTokenDetails>),\n\n    /// Network transaction ID and Wallet Token details for MIT payments when payment_method_data\n    /// is not stored in the application\n    /// Applicable for wallet tokens such as Apple Pay and Google Pay.\n    NetworkTransactionIdAndDecryptedWalletTokenDetails(\n        Box<common_types::payments::NetworkTransactionIdAndDecryptedWalletTokenDetails>,\n    ),\n\n    CardWithLimitedData(Box<CardWithLimitedData>),\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "positive": "The RecurringDetails enum in Rust defines the specific data structure required to represent a recurring payment mandate or token within the Hyperswitch payment orchestration platform. It is a variant type that encapsulates different states of a recurring transaction, such as a MandateId, a PaymentMethodId, or a ProcessorPaymentToken. Crucially, it also handles 'MIT' (Merchant Initiated Transaction) scenarios where the application does not store the full payment method data, using specialized variants like NetworkTransactionIdAndCardDetails or NetworkTransactionIdAndNetworkTokenDetails. This structure is essential for the domain models crate to support complex recurring billing flows, ensuring that the system can correctly identify and process scheduled or authorized transactions across various payment networks and wallet providers.", "queries": ["How to implement RecurringDetails enum for MIT payments in Rust", "Hyperswitch Rust RecurringDetails enum variants and usage", "Rust payment orchestration RecurringDetails structure definition", "ProcessorPaymentToken RecurringDetails Hyperswitch domain models"], "label": "Recurring payment mandate enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "RecurringDetails", "unit_type": "function", "num_lines": 23}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: payone::ErrorResponse = res\n            .response\n            .parse_struct(\"ErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        let errors_list = response.errors.clone().unwrap_or_default();\n        let option_error_code_message = get_error_code_error_message_based_on_priority(\n            self.clone(),\n            errors_list\n                .into_iter()\n                .map(|errors| errors.into())\n                .collect(),\n        );\n        match response.errors {\n            Some(errors) => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                message: option_error_code_message\n                    .clone()\n                    .map(|error_code_message| error_code_message.error_code)\n                    .unwrap_or(NO_ERROR_CODE.to_string()),\n                reason: Some(\n                    errors\n                        .iter()\n                        .map(|error| format!(\"{} : {}\", error.code, error.message))\n                        .collect::<Vec<String>>()\n                        .join(\", \"),\n                ),\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n            None => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: NO_ERROR_CODE.to_string(),\n                message: NO_ERROR_MESSAGE.to_string(),\n                reason: None,\n                attempt_status: None,\n                connector_transaction_id: None,\n                connector_response_reference_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n        }\n    }\n}", "positive": "This function constructs a standardized ErrorResponse object from a raw HTTP Response received from the Payone connector. It parses the JSON body into a specific ErrorResponse struct, logs the raw response for debugging, and normalizes error codes using a priority-based lookup. The function handles both cases where the response contains an error list and cases where it does not, populating the resulting object with the HTTP status code, normalized error codes, and a concatenated reason string of all error messages. It is a critical utility for the Payone connector implementation within the hyperswitch_connectors crate, ensuring consistent error reporting across the payment orchestration platform.", "queries": ["how to handle payone connector error responses in hyperswitch", "rust function to parse payone error json and return ErrorResponse", "hyperswitch payone connector error handling build_error_response", "how does hyperswitch normalize payone error codes"], "label": "Payone error response parser", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 62}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payone\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payone\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    #[cfg(feature = \"payouts\")]", "positive": "This trait implementation defines the integration contract for the Payone connector within the Hyperswitch payment orchestration platform. It establishes the interface for tokenizing payment methods and processing payment flows, ensuring type safety with `PaymentMethodToken`, `PaymentMethodTokenizationData`, and `PaymentsResponseData`. The implementation leverages the `ConnectorCommonExt` trait to provide shared functionality, specifically enabling payout features when the 'payouts' feature flag is active, facilitating seamless interaction with the Payone payment gateway.", "queries": ["rust hyperswitch payone connector trait implementation", "hyperswitch payone payment method tokenization", "how to implement payone connector in hyperswitch rust", "hyperswitch payone payouts feature connector"], "label": "Payone connector integration trait", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` function in the Helcim connector implementation serves as the primary interface for constructing the HTTP request headers required to authenticate and authorize outgoing payment requests to the Helcim API. It accepts a `SetupMandateRouterData` object containing the mandate context and a `Connectors` registry, then delegates the header generation logic to the internal `build_headers` method. This function is critical for ensuring that every transaction initiated through the Helcim integration includes the necessary security tokens and API identifiers, handling the specific masking requirements for sensitive data before transmission.", "queries": ["rust hyperswitch helcim connector get_headers implementation", "how to add custom headers in hyperswitch helcim integration", "helcim connector setup mandate router data get_headers", "hyperswitch rust code get_headers function helcim"], "label": "helcim connector header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: find_refund_by_merchant_id_connector_transaction_id\n    async fn find_refund_by_merchant_id_connector_transaction_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_transaction_id: &str,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<diesel_refund::Refund>, errors::StorageError>;\n\n    #[cfg(feature = \"v2\")]", "positive": "This function retrieves a list of refunds associated with a specific merchant and a given connector transaction ID. It is designed to handle multi-refund scenarios where a single upstream transaction (e.g., a payment) might have triggered multiple downstream refund attempts. The function accepts a storage scheme to ensure data is queried from the correct tenant schema, returning a vector of diesel_refund::Refund models. It is a core lookup utility used by the router's refund handling logic to reconcile transaction states and retrieve audit trails.", "queries": ["rust hyperswitch find_refund_by_merchant_id_connector_transaction_id", "how to get refunds by connector transaction id in hyperswitch", "hyperswitch router storage error refund lookup", "rust function to find refunds by merchant id connector id"], "label": "Refund lookup by connector transaction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "find_refund_by_merchant_id_connector_transaction_id", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileSetter\npub struct ProfileSetter {\n    pub profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]", "positive": "The ProfileSetter struct in hyperswitch_domain_models serves as the primary domain model for configuring business payment profiles. It encapsulates complex orchestration settings including routing algorithms (dynamic, L2/L3, debit), connector configurations (authentication, tax, external vault), and security parameters like payment response hashing and 3DS enforcement. This struct is central to the 'business_profile' module, mapping directly to the database schema managed by diesel_models and used by the router to enforce tenant-specific payment flows and webhook integrations.", "queries": ["rust hyperswitch ProfileSetter struct definition", "hyperswitch business profile configuration struct fields", "rust domain model for payment profile settings", "hyperswitch ProfileSetter routing algorithm fields"], "label": "Business Profile Domain Model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__business_profile.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "symbol": "ProfileSetter", "unit_type": "function", "num_lines": 61}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Thunes\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Thunes\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for the Thunes connector within the Hyperswitch payment orchestration platform. It establishes the interface for tokenizing payment methods and processing payment flows, abstracting the specific HTTP/gRPC interactions required to communicate with the Thunes payment gateway. The implementation is currently marked as 'Not Implemented (R)', indicating a placeholder for future development or a specific architectural decision to defer the logic.", "queries": ["Rust trait implementation for Thunes payment gateway integration", "Hyperswitch Thunes connector tokenization logic", "ConnectorIntegration trait definition for Thunes", "Thunes payment gateway Rust SDK implementation"], "label": "Thunes connector integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: new_password_without_validation\n    pub fn new_password_without_validation(password: Secret<String>) -> UserResult<Self> {\n        let password = password.expose();\n        if password.is_empty() {\n            return Err(UserErrors::PasswordParsingError.into());\n        }\n        Ok(Self(password.into()))\n    }\n", "positive": "This function constructs a new User instance from a password string while explicitly bypassing standard validation checks. It accepts a `Secret<String>` to handle sensitive data securely, extracts the inner string, and validates that it is not empty. If the password is empty, it returns a `PasswordParsingError`. Otherwise, it wraps the password in a `Secret` and returns the constructed User. This is typically used in internal migration scripts, administrative tools, or specific initialization flows where the system trusts the input source and does not require standard password complexity or length enforcement.", "queries": ["rust hyperswitch create user without password validation", "hyperswitch new_password_without_validation function signature", "how to bypass password validation in hyperswitch user creation", "rust hyperswitch user builder without validation"], "label": "User builder bypass validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "new_password_without_validation", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_account_details\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n", "positive": "This function retrieves and parses the inner details of a merchant connector account, specifically casting it to a `ConnectorAuthType`. It is a core utility in the `hyperswitch_domain_models` crate, used to validate and configure authentication parameters for specific payment connectors within the orchestration platform. The function relies on the `connector_account_details` field, which holds the raw configuration data, and returns a parsed `Result` type that can be handled by the router or other domain services.", "queries": ["How do I get the connector auth type from a merchant account in Rust?", "Rust hyperswitch get_connector_account_details implementation", "Parse connector account details to ConnectorAuthType hyperswitch", "hyperswitch domain models merchant connector account auth type"], "label": "Connector Auth Type Retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "get_connector_account_details", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: AnalysisError\npub enum AnalysisError<V: cgraph::ValueNode> {\n    Graph(cgraph::GraphError<V>),\n    AssertionTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Metadata,\n    },\n    NegationTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Vec<Metadata>,\n    },\n}\n\nimpl<V: cgraph::ValueNode> AnalysisError<V> {", "positive": "The AnalysisError enum in euclid defines error variants for the graph analysis engine, specifically handling graph structural issues and assertion trace failures. It integrates with the cgraph module to provide context-aware error reporting, distinguishing between single assertion failures and complex negation trace scenarios. This type is central to the DSSA (Data Structure and State Analysis) workflow within the hyperswitch codebase, ensuring precise error propagation during the verification of payment orchestration logic and state transitions.", "queries": ["rust AnalysisError enum definition euclid crate", "hyperswitch euclid dssa graph error handling", "AnalysisError Graph AssertionTrace NegationTrace rust", "euclid crate AnalysisError trait implementation cgraph"], "label": "AnalysisError enum definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "AnalysisError", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Authentication\npub enum Authentication {\n    RedirectUrl {\n        #[serde(rename = \"redirectUrl\")]\n        redirect_url: String,\n    },\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This Rust enum, `Authentication`, defines the structure for handling redirect-based authentication flows within the Hyperswitch payment orchestration platform. It encapsulates the `redirectUrl` parameter, which is essential for initiating a redirect-based authentication process, likely for payment methods like cards or wallets that require a user to be redirected to an external authentication page. The enum is annotated with `#[serde(rename_all = \"camelCase\")]`, ensuring that the field name `redirectUrl` in the JSON payload is correctly deserialized into the Rust field `redirect_url`. This component is part of the `hyperswitch_connectors` crate, which provides the interface and logic for integrating with various external payment service providers.", "queries": ["rust enum Authentication redirectUrl hyperswitch", "hyperswitch tokenio Authentication RedirectUrl struct", "how to handle redirectUrl in hyperswitch rust", "Authentication enum definition hyperswitch tokenio"], "label": "Authentication RedirectUrl Enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "Authentication", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_payment_id_type\npub async fn find_payment_intent_from_payment_id_type(\n    state: &SessionState,\n    payment_id_type: payments::PaymentIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    match payment_id_type {\n        payments::PaymentIdType::PaymentIntentId(payment_id) => db\n            .find_payment_intent_by_payment_id_processor_merchant_id(\n                &payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound),\n        payments::PaymentIdType::ConnectorTransactionId(connector_transaction_id) => {\n            let attempt = db\n                .find_payment_attempt_by_processor_merchant_id_connector_txn_id(\n                    platform.get_processor().get_account().get_id(),\n                    &connector_transaction_id,\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PaymentAttemptId(attempt_id) => {\n            let attempt = db\n                .find_payment_attempt_by_attempt_id_processor_merchant_id(\n                    &attempt_id,\n                    platform.get_processor().get_account().get_id(),\n                    platform.get_processor().get_account().storage_scheme,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n            db.find_payment_intent_by_payment_id_processor_merchant_id(\n                &attempt.payment_id,\n                platform.get_processor().get_account().get_id(),\n                platform.get_processor().get_key_store(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n        }\n        payments::PaymentIdType::PreprocessingId(_) => {\n            Err(errors::ApiErrorResponse::PaymentNotFound)?\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "positive": "This utility function resolves a PaymentIntent from various input identifiers (PaymentIntentId, ConnectorTransactionId, PaymentAttemptId) within the Hyperswitch router. It handles the lookup logic by first fetching the associated PaymentAttempt if the input is a transaction or attempt ID, then retrieving the final PaymentIntent. It integrates with the database layer using the provided SessionState and Platform context, ensuring the correct processor account and storage scheme are used. The function returns a CustomResult, mapping database failures to a generic PaymentNotFound error.", "queries": ["how to find payment intent by connector transaction id in hyperswitch", "hyperswitch router find_payment_intent_from_payment_id_type implementation", "resolve payment intent from payment attempt id rust hyperswitch", "hyperswitch payment orchestration platform get payment intent by id"], "label": "payment intent resolution utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "find_payment_intent_from_payment_id_type", "unit_type": "function", "num_lines": 61}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_payment_intent_from_mandate_id_type\npub async fn find_payment_intent_from_mandate_id_type(\n    state: &SessionState,\n    mandate_id_type: webhooks::MandateIdType,\n    platform: &domain::Platform,\n) -> CustomResult<PaymentIntent, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let mandate = match mandate_id_type {\n        webhooks::MandateIdType::MandateId(mandate_id) => db\n            .find_mandate_by_merchant_id_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n        webhooks::MandateIdType::ConnectorMandateId(connector_mandate_id) => db\n            .find_mandate_by_merchant_id_connector_mandate_id(\n                platform.get_processor().get_account().get_id(),\n                connector_mandate_id.as_str(),\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::MandateNotFound)?,\n    };\n    db.find_payment_intent_by_payment_id_processor_merchant_id(\n        &mandate\n            .original_payment_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"original_payment_id not present in mandate record\")?,\n        platform.get_processor().get_account().get_id(),\n        platform.get_processor().get_key_store(),\n        platform.get_processor().get_account().storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)\n}\n\n#[cfg(feature = \"v1\")]", "positive": "This utility function retrieves a PaymentIntent based on a Mandate ID, handling two distinct ID types: the internal Mandate ID and the external Connector Mandate ID. It first queries the database for the mandate record using the platform's processor account and storage scheme, then derives the original PaymentIntent ID from the mandate's metadata. Finally, it performs a lookup to retrieve the specific PaymentIntent object, returning a 404 error if either the mandate or the intent cannot be located. This function is critical for webhook handlers that need to correlate mandate events back to the original payment transaction.", "queries": ["how to find payment intent from mandate id in hyperswitch", "rust function find_payment_intent_from_mandate_id_type implementation", "hyperswitch webhook mandate lookup payment intent", "find payment intent by mandate id type connector mandate"], "label": "Mandate to PaymentIntent lookup", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "find_payment_intent_from_mandate_id_type", "unit_type": "function", "num_lines": 38}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: insert_merchant_connector_account\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n", "positive": "This function serves as a critical abstraction layer within the storage implementation, specifically designed to persist merchant connector account configurations. It acts as a direct pass-through to the underlying router store, ensuring that tenant-specific payment gateway integrations are securely stored and managed. The function accepts a domain model of the account and a secure key store, handling the necessary cryptographic material for authentication, and returns the persisted entity, facilitating the initialization of payment flows for specific merchants.", "queries": ["how to add a new merchant connector account in hyperswitch rust storage", "rust hyperswitch insert_merchant_connector_account implementation details", "hyperswitch storage layer merchant connector account persistence", "rust hyperswitch key_store parameter for account insertion"], "label": "Merchant account persistence abstraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "insert_merchant_connector_account", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}payments\", self.base_url(connectors)))\n    }\n", "positive": "This function constructs the base URL for the Authipay payment gateway by prepending 'payments' to the dynamically resolved base URL. It is a core utility within the Authipay connector implementation, responsible for defining the endpoint path for payment authorization requests. The function accepts a router data context and a shared connectors registry to resolve the base configuration, ensuring the connector communicates with the correct gateway host. It is called during the authorization flow to establish the target endpoint for the HTTP request.", "queries": ["how to configure base_url for Authipay connector", "Authipay connector get_url function implementation", "hyperswitch Authipay payments endpoint configuration", "Authipay connector base_url payments path"], "label": "Authipay connector base_url configuration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: OrderInfo\npub struct OrderInfo {\n    pub order_date: Option<time::PrimitiveDateTime>,\n    pub order_details: Option<Vec<api_models::payments::OrderDetailsWithAmount>>,\n    pub merchant_order_reference_id: Option<String>,\n    pub discount_amount: Option<MinorUnit>,\n    pub shipping_cost: Option<MinorUnit>,\n    pub duty_amount: Option<MinorUnit>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]", "positive": "The `OrderInfo` struct in `hyperswitch_domain_models` defines the core data model for a payment order. It encapsulates essential transaction details such as the `order_date`, `merchant_order_reference_id`, and a list of `order_details`. The struct also supports financial calculations for the transaction, including `discount_amount`, `shipping_cost`, and `duty_amount`, all stored as `MinorUnit` values. This struct is a fundamental component of the domain models, used to serialize and deserialize order data for API responses and internal processing within the payment orchestration platform.", "queries": ["rust hyperswitch OrderInfo struct definition", "how to define order details in hyperswitch rust", "hyperswitch domain models OrderInfo fields", "rust payment orchestration OrderInfo struct"], "label": "OrderInfo struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "OrderInfo", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: negation_from_graph_error\n    fn negation_from_graph_error(\n        metadata: Vec<&Metadata>,\n        graph_error: cgraph::GraphError<V>,\n    ) -> Self {\n        match graph_error {\n            cgraph::GraphError::AnalysisError(trace) => Self::NegationTrace {\n                trace,\n                metadata: metadata.iter().map(|m| (*m).clone()).collect(),\n            },\n\n            other => Self::Graph(other),\n        }\n    }\n}\n\n#[derive(Debug)]", "positive": "This function, `negation_from_graph_error`, serves as a robust error transformation utility within the DSA (Data Structure Analysis) graph module. It takes a vector of metadata and a generic `GraphError` from the `cgraph` crate, then maps it to a specific `NegationTrace` variant if the error is an `AnalysisError`. This allows the calling code to handle graph analysis failures by preserving the original error trace and attaching relevant metadata, while any other graph errors are simply wrapped in the `Graph` variant. It is a critical component for error propagation in the graph traversal logic.", "queries": ["How do I handle graph analysis errors in Rust?", "Rust function to convert GraphError to NegationTrace", "negation_from_graph_error implementation hyperswitch", "Error handling pattern for cgraph::GraphError in Rust"], "label": "Graph Error Transformation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "negation_from_graph_error", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_error_response\n    fn get_error_response(self) -> RouterResult<types::Response> {\n        self.map_err(|error| error.change_context(errors::ApiErrorResponse::InternalServerError))\n            .attach_printable(\"Error while receiving response\")\n            .and_then(|inner| match inner {\n                Ok(res) => {\n                    logger::error!(response=?res);\n                    Err(errors::ApiErrorResponse::InternalServerError).attach_printable(format!(\n                        \"Expecting error response, received response: {res:?}\"\n                    ))\n                }\n                Err(err_res) => Ok(err_res),\n            })\n    }\n", "positive": "The `get_error_response` method in the Router crate is a utility function designed to handle and transform errors from an internal asynchronous operation into a standardized `RouterResult<types::Response>`. It maps any error into an `ApiErrorResponse::InternalServerError` and attaches a descriptive printable message. Crucially, it inspects the inner result: if the operation unexpectedly succeeds (returns `Ok`), it logs the response as an error and returns an internal server error. If the operation fails (returns `Err`), it passes that error through. This ensures that the router consistently returns a valid HTTP error response, preventing unhandled success states from leaking through to the client.", "queries": ["how to handle error responses in hyperswitch router", "hyperswitch router get_error_response function implementation", "convert async error to router result rust hyperswitch", "hyperswitch router utility functions error handling"], "label": "Router error response utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: from_secret_value\n    pub fn from_secret_value(\n        value: common_utils::pii::SecretSerdeValue,\n    ) -> common_utils::errors::CustomResult<Self, common_utils::errors::ParsingError> {\n        value\n            .parse_value::<Self>(\"ConnectorAuthType\")\n            .change_context(common_utils::errors::ParsingError::StructParseFailure(\n                \"ConnectorAuthType\",\n            ))\n    }\n\n    // show only first and last two digits of the key and mask others with *\n    // mask the entire key if it's length is less than or equal to 4", "positive": "This function, located in the domain models crate, parses a serialized secret value into a ConnectorAuthType struct. It utilizes the `common_utils::pii::SecretSerdeValue` type to handle sensitive data securely. The function attempts to deserialize the input into the specific struct type 'ConnectorAuthType', raising a `ParsingError::StructParseFailure` if the deserialization fails. This utility is critical for initializing authentication configurations within the payment orchestration platform, ensuring that connector credentials are correctly mapped from their serialized storage format to runtime domain objects.", "queries": ["rust hyperswitch connector auth type parsing error", "how to deserialize connector auth type from secret value", "hyperswitch domain models connector auth parsing", "rust hyperswitch parsing error struct parse failure connector"], "label": "ConnectorAuthType parsing", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "from_secret_value", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \" mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n", "positive": "This function validates the payment mandate for a specific payment method within the Zift connector. It acts as a gatekeeper, checking if the provided payment method data (specifically Card types) supports the mandate payment flow. If the method is unsupported, it returns a `NotSupported` error with the connector's ID and a descriptive message, ensuring the router only proceeds with valid payment methods for this specific integration.", "queries": ["how to implement validate_mandate_payment in rust", "zift connector mandate payment validation error", "hyperswitch zift payment method validation", "rust connector validate_mandate_payment implementation"], "label": "Zift mandate validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "validate_mandate_payment", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = powertranz::PowertranzAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                POWER_TRANZ_ID.to_string(),\n                auth.power_tranz_id.expose().into_masked(),\n            ),\n            (\n                POWER_TRANZ_PASSWORD.to_string(),\n                auth.power_tranz_password.expose().into_masked(),\n            ),\n        ])\n    }\n", "positive": "This function constructs the HTTP Basic Authentication header payload for Powertranz connector integrations. It accepts a generic `ConnectorAuthType` and converts it into a specific `PowertranzAuthType` to ensure type safety. The function returns a vector of key-value tuples containing the Powertranz ID and Password, masking sensitive credential values using the `masking` utility before returning them. This is a critical utility for the `hyperswitch_connectors` crate, ensuring secure credential handling during the authentication handshake with the Powertranz payment gateway.", "queries": ["how to get auth header for Powertranz connector", "rust hyperswitch powertranz authentication header", "hyperswitch powertranz connector get_auth_header implementation", "PowertranzAuthType hyperswitch rust connector"], "label": "Powertranz Auth Header Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__powertranz.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 18}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intents_by_time_range_constraints\n    async fn filter_payment_intents_by_time_range_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        time_range: &common_utils::types::TimeRange,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(feature = \"olap\")]", "positive": "This function retrieves a list of PaymentIntents filtered by a specific time range and merchant constraints. It acts as a critical data accessor within the domain models layer, ensuring that queries respect tenant isolation and storage scheme variations (e.g., legacy vs. v2). The function signature includes a MerchantKeyStore and storage scheme parameter, indicating it handles cryptographic verification and database routing logic internally before returning the result vector.", "queries": ["rust hyperswitch filter payment intents by time range", "how to get payment intents between two timestamps in hyperswitch", "hyperswitch domain models filter_payment_intents_by_time_range implementation", "rust hyperswitch retrieve payment intents by date range merchant"], "label": "Time range filter payment intents", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "filter_payment_intents_by_time_range_constraints", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Juspaythreedsserver\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Juspaythreedsserver\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for the Juspay 3DS Server connector within the Hyperswitch payment orchestration platform. It establishes the interface for tokenizing payment methods using Juspay's 3D Secure protocol. The implementation handles the specific request/response data structures (`PaymentMethodToken`, `PaymentMethodTokenizationData`, `PaymentsResponseData`) required for the Juspaythreedsserver connector, ensuring that the orchestration router can dispatch tokenization requests to the external Juspay gateway and process the resulting secure tokens for subsequent payment flows.", "queries": ["how to implement tokenization for Juspay 3DS in Rust", "Juspaythreedsserver connector integration example hyperswitch", "hyperswitch rust connector trait implementation for 3ds", "PaymentMethodTokenizationData Juspaythreedsserver hyperswitch"], "label": "Juspay 3DS Tokenization Integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let wellsfargo_req = self.get_request_body(req, connectors)?;\n        let auth = wellsfargo::WellsfargoAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.wellsfargo.base_url.as_str();\n        let wellsfargo_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = wellsfargo_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(wellsfargo_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "positive": "The `build_headers` function constructs the HTTP headers required for authenticating and communicating with the Wells Fargo payment connector. It dynamically generates a signature based on the request body, HTTP method, timestamp, and merchant credentials, ensuring secure and compliant API interactions. This function is a critical component of the connector's request pipeline, handling the cryptographic details necessary for the Wells Fargo API to process transactions.", "queries": ["rust hyperswitch wellsfargo connector build_headers function signature generation", "how to implement wellsfargo payment gateway authentication in rust hyperswitch", "hyperswitch wellsfargo connector request header generation logic", "rust code for wellsfargo api signature generation hyperswitch"], "label": "Wells Fargo connector header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 58}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpayModularRefundResponse\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "The WorldpayModularRefundResponse struct in Rust defines the data model for parsing the JSON response from a Worldpay Modular refund transaction. It encapsulates the refund's unique identifier (payment_id) and a collection of navigation links (links) for subsequent API interactions, such as retrieving the refund status or retrieving the payment details. This struct is essential for the connector's transformer layer to map the raw HTTP response into a structured, domain-agnostic format for the router.", "queries": ["Worldpay Modular refund response struct Rust", "hyperswitch WorldpayModularRefundResponse payment_id links", "Worldpay Modular API refund response parsing Rust", "WorldpayModularRefundResponse struct definition hyperswitch"], "label": "Worldpay Modular Refund Response Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "WorldpayModularRefundResponse", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name_as_string\n    pub fn get_connector_name_as_string(&self) -> String {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name.to_string()\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name.to_string()\n            }\n        }\n    }\n", "positive": "This function retrieves the connector name as a string representation from a Rust enum variant. It handles two specific enum arms: `MerchantConnectorAccount` and `MerchantConnectorDetails`. By extracting the `connector_name` field from the respective struct, it provides a unified string output, facilitating display or logging of the active payment gateway integration. This utility is essential for routing logic and error reporting within the domain models layer.", "queries": ["rust enum get connector name string", "how to convert merchant connector account to string", "hyperswitch domain models get_connector_name_as_string", "extract connector name from merchant connector details rust"], "label": "Enum field extraction utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "get_connector_name_as_string", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.get_minor_amount();\n        let currency = req.request.get_currency()?;\n\n        let amount = convert_amount(self.amount_converter, minor_amount, currency)?;\n\n        let connector_router_data = barclaycard::BarclaycardRouterData::try_from((amount, req))?;\n        let connector_req =\n            barclaycard::BarclaycardAuthSetupRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "positive": "The `get_request_body` function in the `barclaycard.rs` connector prepares the authentication request payload for the Barclays payment gateway. It converts the incoming payment amount from minor units to the connector's expected format using the configured amount converter. It then constructs a `BarclaycardAuthSetupRequest` from the router data and wraps it in a `RequestContent::Json` for transmission. This function is a critical step in the pre-authentication flow, ensuring the correct financial data is sent to the external processor.", "queries": ["How to configure amount conversion for Barclays connector in hyperswitch", "Barclaycard hyperswitch connector pre-authentication request payload structure", "Hyperswitch barclaycard get_request_body function implementation details", "Rust connector error handling for Barclays payment pre-authentication"], "label": "Barclaycard pre-auth request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n", "positive": "This function constructs the HTTP headers required for authenticating and communicating with the Worldline payment gateway. It dynamically generates a signed authorization token based on the HTTP method, content type, timestamp, and endpoint path, ensuring secure, time-sensitive requests. It integrates with the router's request context to extract necessary authentication types and routing data, returning a vector of masked header tuples for the outgoing HTTP client.", "queries": ["rust hyperswitch worldline connector build_headers function implementation", "how to generate authorization token for worldline payment gateway in hyperswitch", "hyperswitch worldline connector header generation logic", "rust function build_headers worldline hyperswitch connector"], "label": "Worldline auth header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n", "positive": "This function, `get_request_body`, is a critical adapter within the Zift connector implementation that transforms the internal `SetupMandateRouterData` into a format consumable by the Zift payment gateway. It leverages the `zift::ZiftSetupMandateRequest` struct to deserialize the router payload, ensuring type safety and data integrity before transmission. The function returns a `RequestContent::FormUrlEncoded` wrapper, indicating that the mandate setup payload is structured as URL-encoded form data. This specific transformation is essential for the 'setup_mandate' flow, allowing Hyperswitch to securely configure payment mandates with Zift's API requirements.", "queries": ["rust hyperswitch zift connector get_request_body implementation", "how does hyperswitch zift setup mandate request work", "zift connector hyperswitch rust setup_mandate_request", "hyperswitch zift adapter request body transformation"], "label": "Zift Setup Mandate Request Adapter", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name\n    pub fn get_connector_name(&self) -> common_enums::connector_enums::Connector {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name\n            }\n        }\n    }\n", "positive": "The `get_connector_name` function in `merchant_connector_account.rs` is a core method for the `MerchantConnectorAccount` enum. It abstracts the retrieval of the connector's name, handling two variants: `MerchantConnectorAccount` and `MerchantConnectorDetails`. This ensures a consistent interface for the router and scheduler to identify the specific payment provider (e.g., Stripe, Razorpay) associated with a transaction or account configuration, facilitating downstream routing and integration logic.", "queries": ["How to get the connector name from a merchant account in Rust?", "Rust hyperswitch get_connector_name function implementation", "merchant_connector_account.rs get_connector_name method", "Hyperswitch Rust enum get_connector_name pattern matching"], "label": "Rust enum connector name retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "get_connector_name", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Worldline\".to_string())\n                .into(),\n        )\n    }\n}\n", "positive": "This function defines the request construction logic for the Worldline payment connector within the Hyperswitch payment orchestration platform. It is responsible for transforming the internal `SetupMandateRequestData` into a specific HTTP request format required by the Worldline API. Currently, this implementation explicitly raises a `NotImplemented` error, indicating that the specific 'Setup Mandate' payment flow has not been integrated for this connector yet. It interacts with the router's `RouterData` and the global `Connectors` context to prepare the payload before transmission.", "queries": ["rust hyperswitch worldline connector setup mandate request builder", "how to implement setup mandate flow in worldline connector hyperswitch", "hyperswitch worldline.rs build_request function error NotImplemented", "worldline mandate setup request construction rust hyperswitch"], "label": "Worldline Setup Mandate Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: apply_mask\nfn apply_mask(val: &str, unmasked_char_count: usize, min_masked_char_count: usize) -> String {\n    let len = val.len();\n    if len <= unmasked_char_count {\n        return val.to_string();\n    }\n\n    let mask_start_index =\n    // For showing only last `unmasked_char_count` characters\n    if len < (unmasked_char_count * 2 + min_masked_char_count) {\n        0\n    // For showing first and last `unmasked_char_count` characters\n    } else {\n        unmasked_char_count\n    };\n    let mask_end_index = len - unmasked_char_count - 1;\n    let range = mask_start_index..=mask_end_index;\n\n    val.chars()\n        .enumerate()\n        .fold(String::new(), |mut acc, (index, ch)| {\n            if ch.is_alphanumeric() && range.contains(&index) {\n                acc.push('*');\n            } else {\n                acc.push(ch);\n            }\n            acc\n        })\n}\n\n/// Masked sort code\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]", "positive": "This utility function applies a security-sensitive mask to string values, typically used for logging or displaying sensitive data like card numbers or bank account details. It intelligently preserves the first and last N alphanumeric characters while replacing the middle segment with asterisks ('*'). The logic handles edge cases where the input length is shorter than the required unmasked count or where the total length is insufficient to display both start and end segments alongside the minimum required masked characters. It is a core utility within the `common_utils` crate, ensuring consistent data obfuscation across the Hyperswitch payment orchestration platform.", "queries": ["rust hyperswitch apply_mask function implementation", "how to mask sensitive data in hyperswitch common_utils", "hyperswitch string masking utility preserve first and last characters", "rust function to mask string with asterisks unmasked_char_count"], "label": "String masking utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__common_utils__src__new_type.rs", "path": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "symbol": "apply_mask", "unit_type": "function", "num_lines": 31}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: find_mca_from_authentication_id_type\npub async fn find_mca_from_authentication_id_type(\n    state: &SessionState,\n    authentication_id_type: webhooks::AuthenticationIdType,\n    platform: &domain::Platform,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let authentication = match authentication_id_type {\n        webhooks::AuthenticationIdType::AuthenticationId(authentication_id) => db\n            .find_authentication_by_merchant_id_authentication_id(\n                platform.get_processor().get_account().get_id(),\n                &authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?,\n        webhooks::AuthenticationIdType::ConnectorAuthenticationId(connector_authentication_id) => {\n            db.find_authentication_by_merchant_id_connector_authentication_id(\n                platform.get_processor().get_account().get_id().clone(),\n                connector_authentication_id,\n                platform.get_processor().get_key_store(),\n                &state.into(),\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::InternalServerError)?\n        }\n    };\n    #[cfg(feature = \"v1\")]\n    {\n        // raise error if merchant_connector_id is not present since it should we be present in the current flow\n        let mca_id = authentication\n            .merchant_connector_id\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"merchant_connector_id not present in authentication record\")?;\n        db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n            platform.get_processor().get_account().get_id(),\n            &mca_id,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(\n            errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                id: mca_id.get_string_repr().to_string(),\n            },\n        )\n    }\n    #[cfg(feature = \"v2\")]\n    //get mca using id\n    {\n        let _ = key_store;\n        let _ = authentication;\n        todo!()\n    }\n}\n\n#[cfg(feature = \"v1\")]", "positive": "This function retrieves a Merchant Connector Account (MCA) based on an authentication ID provided via webhooks. It handles two input types: a standard Authentication ID and a Connector-specific Authentication ID. It queries the database using the platform's processor context and key store. In the v1 feature branch, it performs a secondary lookup to validate the presence of a merchant_connector_id and fetch the specific MCA record, raising an error if the ID is missing. The v2 branch is currently a stub marked with a TODO.", "queries": ["How do I find merchant connector account from webhook authentication id in hyperswitch?", "rust hyperswitch find_mca_from_authentication_id_type implementation", "hyperswitch router utils find_mca_from_authentication_id_type function", "merchant connector account lookup using authentication id type hyperswitch"], "label": "Merchant Connector Account Lookup", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "find_mca_from_authentication_id_type", "unit_type": "function", "num_lines": 56}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let boku_url = get_country_url(\n            req.connector_meta_data.clone(),\n            self.base_url(connectors).to_string(),\n        )?;\n\n        Ok(format!(\"{boku_url}/billing/3.0/begin-single-charge\"))\n    }\n", "positive": "This function constructs the specific API endpoint URL for initiating a Boku payment transaction. It leverages the `get_country_url` helper to dynamically select the correct regional base URL based on the request's connector metadata, then appends the specific Boku billing path '/billing/3.0/begin-single-charge'. This ensures the router directs the payment request to the correct regional Boku gateway instance.", "queries": ["how to get boku url for hyperswitch", "hyperswitch boku connector get_url implementation", "boku begin-single-charge endpoint hyperswitch", "hyperswitch boku regional url configuration"], "label": "Boku URL construction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 13}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gigadat\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gigadat\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for Gigadat, a payment connector within the hyperswitch_connectors crate. It implements `ConnectorCommonExt` to provide shared utility methods (like logging and request validation) required for all connector operations. The specific implementation for `PaymentMethodTokenizationData` is marked as 'Not Implemented' (R), indicating that tokenization flows are currently unsupported by this connector. This structure allows the router to dynamically dispatch payment requests to Gigadat while abstracting away the underlying HTTP/gRPC communication details.", "queries": ["how to implement Gigadat tokenization in hyperswitch rust", "hyperswitch Gigadat connector integration traits", "rust connector integration pattern hyperswitch", "Gigadat payment method tokenization not implemented"], "label": "Gigadat connector integration traits", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_metadata\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.metadata.to_owned()\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "positive": "This function retrieves the metadata associated with a MerchantConnectorAccount. It is part of the `MerchantConnectorAccount` enum variant within the domain models, likely used to expose configuration or custom attributes defined during the connector setup. The function returns a `Secret<Value>` to ensure sensitive metadata is handled securely, returning `None` for other enum variants like `MerchantConnectorDetails`.", "queries": ["how to retrieve metadata from merchant connector account", "rust hyperswitch get_metadata function implementation", "MerchantConnectorAccount enum metadata field access", "hyperswitch domain models merchant connector account metadata"], "label": "MerchantConnectorAccount metadata retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "get_metadata", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: tokenex::TokenexErrorResponse = res\n            .response\n            .parse_struct(\"TokenexErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let (code, message) = response.error.split_once(':').unwrap_or((\"\", \"\"));\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: code.to_string(),\n            message: message.to_string(),\n            reason: Some(response.message),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a Tokenex API response, handling error parsing and logging. It extracts the HTTP status code and splits the error message into a code and description. It is responsible for mapping the raw TokenexErrorResponse struct into the platform's internal error format, ensuring consistent error reporting for failed payment transactions. It is called by the Tokenex connector implementation to process failed authorization or capture attempts.", "queries": ["how to handle tokenex error response in hyperswitch", "build_error_response function tokenex connector rust", "parse tokenex error message hyperswitch", "tokenex connector error handling hyperswitch rust"], "label": "Tokenex error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 31}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for the AuthiPay payment gateway authorization flow. It leverages the `PaymentsAuthorizeRouterData` struct to map internal Hyperswitch payment objects to the specific API schema required by the AuthiPay connector. The method dynamically generates the target URL and headers using the `PaymentsAuthorizeType` trait implementation, ensuring proper authentication and routing before sending the request to the external payment provider.", "queries": ["rust hyperswitch authipay connector build_request implementation", "how to implement build_request for authipay in hyperswitch rust", "hyperswitch PaymentsAuthorizeRouterData build_request authipay", "authipay connector request builder hyperswitch rust code"], "label": "AuthiPay connector request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_payment_id_processor_merchant_id\n    async fn find_payment_intent_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n    #[cfg(feature = \"v2\")]", "positive": "This method retrieves a PaymentIntent entity by its unique payment_id, processor_merchant_id, and the specific storage scheme (e.g., tenant isolation). It serves as the core lookup mechanism for the router and scheduler to reconstruct payment state, validate processor configurations, and handle webhook processing. The function signature requires a MerchantKeyStore for cryptographic verification and returns a Result type, ensuring robust error handling for missing or invalid payment records within the hyperswitch_domain_models crate.", "queries": ["how to retrieve payment intent by payment id and processor merchant id", "hyperswitch rust find_payment_intent_by_payment_id_processor_merchant_id implementation", "payment intent lookup function signature hyperswitch domain models", "rust code for finding payment intent using payment_id and merchant_id"], "label": "payment intent retrieval lookup", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "find_payment_intent_by_payment_id_processor_merchant_id", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: new\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "positive": "This function constructs a new `Customer` instance within the `hyperswitch_domain_models` crate. It initializes the core identifier `connector_customer_id` and accepts optional fields for `name`, `email`, and `billing_address`. This is a standard domain model constructor used to encapsulate customer data retrieved from or destined for external payment connectors within the orchestration platform.", "queries": ["Rust Customer struct constructor hyperswitch", "hyperswitch domain models Customer new method", "how to create Customer object in hyperswitch", "hyperswitch connector_customer_id Customer struct definition"], "label": "Customer struct constructor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "new", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Globepay\".to_string())\n                .into(),\n        )\n    }\n}\n", "positive": "This function is a stub implementation within the Globepay connector module, designed to handle the 'Setup Mandate' payment flow. It currently returns a 'NotImplemented' error, indicating that the specific mandate creation logic required by the Globepay API has not yet been integrated into the hyperswitch_connectors crate. It accepts RouterData and Connectors context but does not generate a valid HTTP request payload.", "queries": ["how to implement setup mandate for Globepay connector", "globepay connector setup mandate error not implemented", "hyperswitch globepay setup_mandate function stub", "why is setup mandate returning not implemented error"], "label": "Globepay Setup Mandate Stub", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularPaymentsResponse\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "The `WorldpaymodularPaymentsResponse` struct serves as the primary data model for deserializing the JSON payload returned by the Worldpay Modular API following a payment authorization request. It encapsulates the transaction outcome, associated risk factors, issuer details, and payment instrument information. Crucially, it includes a `_links` field for retrieving transaction status and a `description` field for human-readable explanations, facilitating robust error handling and status tracking within the Hyperswitch payment orchestration engine.", "queries": ["Worldpay Modular API response structure Rust struct", "hyperswitch WorldpaymodularPaymentsResponse deserialize", "Worldpay Modular payment response fields outcome risk_factors", "Rust struct WorldpaymodularPaymentsResponse _links description"], "label": "Worldpay Modular API Response Model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "WorldpaymodularPaymentsResponse", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: get_iatpay_response\nfn get_iatpay_response(\n    response: IatapayPaymentsResponse,\n    status_code: u16,\n) -> CustomResult<\n    (\n        enums::AttemptStatus,\n        Option<ErrorResponse>,\n        PaymentsResponseData,\n    ),\n    errors::ConnectorError,\n> {\n    let status = enums::AttemptStatus::from(response.status);\n    let error = if is_payment_failure(status) {\n        Some(ErrorResponse {\n            code: response\n                .failure_code\n                .unwrap_or_else(|| NO_ERROR_CODE.to_string()),\n            message: response\n                .failure_details\n                .clone()\n                .unwrap_or_else(|| NO_ERROR_MESSAGE.to_string()),\n            reason: response.failure_details,\n            status_code,\n            attempt_status: Some(status),\n            connector_transaction_id: response.iata_payment_id.clone(),\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    } else {\n        None\n    };\n    let form_fields = HashMap::new();\n    let id = match response.iata_payment_id.clone() {\n        Some(s) => ResponseId::ConnectorTransactionId(s),\n        None => ResponseId::NoResponseId,\n    };\n    let connector_response_reference_id = response.merchant_payment_id.or(response.iata_payment_id);\n\n    let payment_response_data = match response.checkout_methods {\n        Some(checkout_methods) => {\n            let (connector_metadata, redirection_data) =\n                match checkout_methods.redirect.redirect_url.ends_with(\"qr\") {\n                    true => {\n                        let qr_code_info = api_models::payments::FetchQrCodeInformation {\n                            qr_code_fetch_url: url::Url::parse(\n                                &checkout_methods.redirect.redirect_url,\n                            )\n                            .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                        };\n                        (\n                            Some(qr_code_info.encode_to_value())\n                                .transpose()\n                                .change_context(errors::ConnectorError::ResponseHandlingFailed)?,\n                            None,\n                        )\n                    }\n                    false => (\n                        None,\n                        Some(Redire\n\n... [truncated 425 chars] ...\n\nate_reference: Box::new(None),\n                connector_metadata,\n                network_txn_id: None,\n                connector_response_reference_id: connector_response_reference_id.clone(),\n                incremental_authorization_allowed: None,\n                authentication_data: None,\n                charges: None,\n            }\n        }\n        None => PaymentsResponseData::TransactionResponse {\n            resource_id: id.clone(),\n            redirection_data: Box::new(None),\n            mandate_reference: Box::new(None),\n            connector_metadata: None,\n            network_txn_id: None,\n            connector_response_reference_id: connector_response_reference_id.clone(),\n            incremental_authorization_allowed: None,\n            authentication_data: None,\n            charges: None,\n        },\n    };\n\n    Ok((status, error, payment_response_data))\n}\n\nimpl<F, T> TryFrom<ResponseRouterData<F, IatapayPaymentsResponse, T, PaymentsResponseData>>\n    for RouterData<F, T, PaymentsResponseData>\n{\n    type Error = Error;", "positive": "This function transforms the raw HTTP response from the iatapay connector into the standardized Hyperswitch `PaymentsResponseData` format. It handles mapping the connector's status to `AttemptStatus`, constructing `ErrorResponse` objects for failures, and extracting metadata. Crucially, it detects QR code redirection URLs to fetch QR code information, ensuring the frontend can render the correct payment interface. It also manages transaction ID mapping using `iata_payment_id` or `merchant_payment_id`.", "queries": ["How to handle QR code redirection in iatapay connector response", "Rust function to parse iatapay payment response status", "Hyperswitch iatapay connector error handling implementation", "Map iatapay payment_id to connector transaction id"], "label": "iatapay response transformer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "symbol": "get_iatpay_response", "unit_type": "function", "num_lines": 101}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: try_from\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]", "positive": "This `try_from` function implements the conversion from a tuple `(MinorUnit, T)` to the struct `Self`. It takes the first element as the `amount` and the second element as `router_data`, returning a `Result` to handle potential conversion errors. This is a standard Rust pattern for safe type conversion, likely used within the `hyperswitch_connectors` crate to transform raw data or configuration into a structured object for payment processing logic.", "queries": ["how to implement try_from for tuple in rust", "rust try_from tuple to struct example", "hyperswitch rust connector try_from implementation", "convert tuple to struct using try_from rust"], "label": "Rust try_from tuple conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "positive": "The `validate_psync_reference_id` function is a placeholder within the Gigadat connector implementation, designed to validate PaymentSyncData reference IDs. As a stub, it currently performs no validation logic and returns a success result. Its primary purpose is to define the interface contract for future implementation, ensuring the connector can handle the specific validation requirements of the Gigadat payment gateway during the payment synchronization process.", "queries": ["gigadat validate_psync_reference_id function implementation", "hyperswitch gigadat connector psync reference id validation", "Rust gigadat validate_psync_reference_id placeholder", "hyperswitch gigadat payment sync reference id check"], "label": "Gigadat PSync Reference ID Validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "validate_psync_reference_id", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: GenerateSaleRequest\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    sale_payment_method: SalePaymentMethod,\n    services: Option<ThreeDs>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]", "positive": "This struct defines the payload for initiating a payment transaction within the PayMe connector. It encapsulates core transaction details such as the currency, sale type, and price, alongside the unique transaction ID and product name. Crucially, it handles security and routing by storing the seller's PayMe ID and the specific payment method to be used. The struct also manages user experience flows by defining the return and callback URLs, and supports multi-language interfaces. This data structure is utilized by the `transformers` module to map internal Hyperswitch payment models to the specific API requirements of the PayMe payment gateway.", "queries": ["hyperswitch payme connector generate sale request struct", "how to construct payment request for payme gateway in rust", "hyperswitch payme transformer struct definition", "payme payment initiation request fields hyperswitch"], "label": "PayMe payment request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "symbol": "GenerateSaleRequest", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_profile_id_connector_name\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "positive": "This function retrieves a `MerchantConnectorAccount` entity by matching a specific `ProfileId` against a `connector_name`. It acts as a critical lookup layer within the `storage_impl` crate, bridging the domain logic in `hyperswitch_domain_models` with the underlying persistence layer. The function accepts a `MerchantKeyStore` reference to handle cryptographic keys associated with the account. It delegates the actual database query to `self.router_store`, ensuring that the retrieved account is fully hydrated and ready for payment orchestration flows. This is essential for ensuring that the correct payment gateway configuration is active for a specific merchant.", "queries": ["rust hyperswitch find merchant connector account by profile id", "how to get merchant connector account using profile id and connector name", "hyperswitch storage impl merchant connector account lookup function", "rust code find_merchant_connector_account_by_profile_id_connector_name implementation"], "label": "Merchant connector account lookup", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "find_merchant_connector_account_by_profile_id_connector_name", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for the Zift payment orchestration connector. It utilizes the `SetupMandateRouterData` context to dynamically generate the target URL and headers via `SetupMandateType` utility methods. The request body is populated using the same type utilities, ensuring consistent data mapping for mandate setup operations. The function returns a configured `Request` object wrapped in a `CustomResult`, handling potential configuration errors gracefully before transmission to the Zift API.", "queries": ["how to build a setup mandate request for Zift connector", "rust function to create HTTP request for Zift mandate setup", "hyperswitch Zift connector build_request implementation", "setup mandate router data request builder Zift"], "label": "Zift mandate request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 18}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentsSaleRequest\npub struct SignifydPaymentsSaleRequest {\n    order_id: String,\n    purchase: Purchase,\n    decision_delivery: DecisionDelivery,\n    coverage_requests: Option<CoverageRequests>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"camelCase\", deserialize = \"snake_case\"))]", "positive": "This struct defines the core data payload for initiating a payment sale transaction within the Signifyd fraud protection integration. It encapsulates the order identifier, the specific purchase details, and the decision delivery mechanism used to communicate the fraud assessment back to the payment processor. The struct also supports optional coverage requests, allowing the caller to specify risk coverage parameters for the transaction. It is serialized using camelCase keys to align with Signifyd's API contract.", "queries": ["SignifydPaymentsSaleRequest struct definition", "how to construct Signifyd payment sale request", "Signifyd fraud protection payload fields", "SignifydPaymentsSaleRequest Rust struct fields"], "label": "Signifyd payment sale request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "SignifydPaymentsSaleRequest", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_lowest_common_granularity_level\n    fn get_lowest_common_granularity_level(&self) -> Self::GranularityLevel {\n        match self {\n            Self::OneMin => TimeGranularityLevel::Minute,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin | Self::OneHour => {\n                TimeGranularityLevel::Hour\n            }\n            Self::OneDay => TimeGranularityLevel::Day,\n        }\n    }\n", "positive": "This function determines the aggregation level for time-series analytics queries. It maps specific input granularities (OneMin, FiveMin, etc.) to the next coarser level (Minute, Hour, Day) required for efficient data retrieval and storage in the analytics crate. It is used by the query builder to ensure data consistency when fetching metrics.", "queries": ["How do I map time intervals in the analytics module?", "Rust function to convert time granularity levels in hyperswitch", "get_lowest_common_granularity_level implementation in analytics crate", "hyperswitch analytics time series aggregation level mapping"], "label": "Time Granularity Mapping", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "get_lowest_common_granularity_level", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data =\n            juspaythreedsserver::JuspaythreedsserverRouterData::from((amount, req));\n        let connector_req = juspaythreedsserver::JuspaythreedsserverPaymentsRequest::try_from(\n            &connector_router_data,\n        )?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function prepares the JSON payload for the Juspay 3DS server connector by converting the internal payment amount to the connector's required format. It constructs a `JuspaythreedsserverRouterData` object from the incoming `PaymentsAuthorizeRouterData` and attempts to transform it into a `JuspaythreedsserverPaymentsRequest`. The final output is wrapped in a `RequestContent::Json` struct, which is the standard input format expected by the connector's HTTP client. This step is critical for ensuring the correct monetary values and request structure are sent to the external Juspay gateway during the authorization flow.", "queries": ["how to convert amount for juspay 3ds connector", "juspaythreedsserverPaymentsRequest builder implementation", "PaymentsAuthorizeRouterData to juspaythreedsserver conversion", "hyperswitch juspay connector request body format"], "label": "Juspay 3DS request payload builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = boku::BokuRouterData::from((amount, req));\n        let connector_req = boku::BokuPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Xml(Box::new(connector_req)))\n    }\n", "positive": "This function constructs the XML request payload for the Boku payment gateway. It converts the incoming authorization amount using a configured currency converter, wraps the data into a Boku-specific router structure, and serializes it into a RequestContent::Xml object. It serves as the data transformation layer between the generic PaymentsAuthorizeRouterData and Boku's specific API contract.", "queries": ["how to format boku xml request body hyperswitch", "hyperswitch boku connector get_request_body implementation", "convert amount to boku xml format hyperswitch", "boku payments request builder hyperswitch rust"], "label": "Boku XML request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "positive": "This function constructs the HTTP headers required for authenticating and formatting requests sent to the Gigadat payment gateway. It dynamically retrieves the Content-Type based on the connector's configuration and generates an Authorization header using the specific authentication type defined in the request context. The resulting headers are returned as a vector of key-value pairs, ensuring the outgoing request meets Gigadat's API security and communication standards.", "queries": ["how to configure gigadat connector authentication headers in hyperswitch", "rust hyperswitch gigadat build_headers function implementation", "hyperswitch gigadat connector request header setup", "gigadat api authentication header hyperswitch rust"], "label": "Gigadat connector header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: merge_transaction_responses\n    pub fn merge_transaction_responses(\n        auth_response: &Self,\n        capture_response: &Self,\n    ) -> Result<Self, error_stack::Report<ApiErrorResponse>> {\n        match (auth_response, capture_response) {\n            (\n                Self::TransactionResponse {\n                    resource_id: _,\n                    redirection_data: auth_redirection_data,\n                    mandate_reference: auth_mandate_reference,\n                    connector_metadata: auth_connector_metadata,\n                    network_txn_id: auth_network_txn_id,\n                    connector_response_reference_id: auth_connector_response_reference_id,\n                    incremental_authorization_allowed: auth_incremental_auth_allowed,\n                    authentication_data: auth_authentication_data,\n                    charges: auth_charges,\n                },\n                Self::TransactionResponse {\n                    resource_id: capture_resource_id,\n                    redirection_data: capture_redirection_data,\n                    mandate_reference: capture_mandate_reference,\n                    connector_metadata: capture_connector_metadata,\n                    network_txn_id: capture_network_txn_id,\n                    connector_response_reference_id: capture_connector_response_reference_id,\n                    incremental_authorization_allowed: capture_incremental_auth_allowed,\n                    authentication_data: capture_authentication_data,\n                    charges: capture_charges,\n                },\n            ) => Ok(Self::TransactionResponse {\n                resource_id: capture_resource_id.clone(),\n                redirection_data: Box::new(\n                    capture_redirection_data\n                        .clone()\n                        .or_else(|| *auth_redirection_data.clone()),\n                ),\n                mandate_reference: Box::new(\n                    auth_mandate_reference\n                        .clone()\n                        .or_else(|| *capture_mandate_reference.clone()),\n                ),\n                connector_metadata: capture_connector_metadata\n                    .clone()\n                    .or(auth_connector_metadata.clone()),\n                network_txn_id: capture_network_txn_id\n                    .clone()\n                    .or(auth_network_txn_id.clone()),\n                connector_response_reference_id: capture_connector_response_reference_id\n                    .clone()\n                    .or(auth_connector_response_reference_id.clone()),\n                incremental_authorization_allowed: (*capture_incremental_auth_allowed)\n                    .or(*auth_incremental_auth_allowed),\n                authentication_data: capture_authentication_data\n                    .clone()\n                    .or(auth_authentication_data.clone()),\n                charges: auth_charges.clone().or(capture_charges.clone()),\n            }),\n            _ => Err(ApiErrorResponse::NotSupported {\n                message: \"Invalid Flow \".to_owned(),\n            }\n            .into()),\n        }\n    }\n\n    #[cfg(feature = \"v2\")]", "positive": "The `merge_transaction_responses` function in the `router_response_types.rs` file is a utility designed to combine two `TransactionResponse` objects into a single, coherent result. It is primarily used during payment flows where an authorization (`auth_response`) and a capture (`capture_response`) are processed sequentially. The function intelligently merges fields, prioritizing the capture response's data while preserving critical authorization data (like `mandate_reference` and `authentication_data`) if the capture lacks it. This ensures that the final response object contains a complete history of the transaction lifecycle. It is a core component of the domain model, facilitating the aggregation of partial transaction data into a unified representation for downstream consumers.", "queries": ["how to merge authorization and capture transaction responses in Rust", "hyperswitch router_response_types merge_transaction_responses function", "combine auth and capture response objects in payment orchestration", "rust function to merge TransactionResponse structs hyperswitch"], "label": "merge transaction responses function", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "merge_transaction_responses", "unit_type": "function", "num_lines": 64}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Zift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Zift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "The `ConnectorIntegration` trait implementation for `Zift` defines the core interface for processing payment flows within the Hyperswitch payment orchestration platform. It is responsible for handling the specific business logic required to tokenize payment methods and process payments, refunds, and disputes via the Zift payment gateway. This implementation is part of the `hyperswitch_connectors` crate, which manages the integration logic for various external payment service providers. The trait is generic over the flow type, request data, and response data, allowing it to adapt to different transaction types. The specific implementation for Zift is currently marked as 'Not Implemented' (R), indicating that the connector logic has not yet been fully developed or integrated into the main codebase.", "queries": ["rust hyperswitch zift connector implementation", "how to implement zift payment gateway in hyperswitch rust", "hyperswitch zift connector integration code", "zift payment gateway rust hyperswitch trait implementation"], "label": "Zift Payment Gateway Connector", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_payment_method\n    pub fn get_payment_method(&self) -> Option<common_enums::PaymentMethod> {\n        match self {\n            Self::Card(_)\n            | Self::NetworkToken(_)\n            | Self::CardDetailsForNetworkTransactionId(_)\n            | Self::NetworkTokenDetailsForNetworkTransactionId(_)\n            | Self::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | Self::CardWithLimitedDetails(_) => Some(common_enums::PaymentMethod::Card),\n            Self::CardRedirect(_) => Some(common_enums::PaymentMethod::CardRedirect),\n            Self::Wallet(_) => Some(common_enums::PaymentMethod::Wallet),\n            Self::PayLater(_) => Some(common_enums::PaymentMethod::PayLater),\n            Self::BankRedirect(_) => Some(common_enums::PaymentMethod::BankRedirect),\n            Self::BankDebit(_) => Some(common_enums::PaymentMethod::BankDebit),\n            Self::BankTransfer(_) => Some(common_enums::PaymentMethod::BankTransfer),\n            Self::Crypto(_) => Some(common_enums::PaymentMethod::Crypto),\n            Self::Reward => Some(common_enums::PaymentMethod::Reward),\n            Self::RealTimePayment(_) => Some(common_enums::PaymentMethod::RealTimePayment),\n            Self::Upi(_) => Some(common_enums::PaymentMethod::Upi),\n            Self::Voucher(_) => Some(common_enums::PaymentMethod::Voucher),\n            Self::GiftCard(_) => Some(common_enums::PaymentMethod::GiftCard),\n            Self::OpenBanking(_) => Some(common_enums::PaymentMethod::OpenBanking),\n            Self::MobilePayment(_) => Some(common_enums::PaymentMethod::MobilePayment),\n            Self::CardToken(_) | Self::MandatePayment => None,\n        }\n    }\n", "positive": "This function, located in the domain models crate, acts as a type-safe mapper that extracts the high-level `PaymentMethod` enum variant from complex, granular internal data structures. It handles a wide array of specific payment typesincluding `Card`, `Wallet`, `PayLater`, `BankTransfer`, `Crypto`, and `Upi`by matching against variants like `Card`, `NetworkToken`, and `Wallet`. Crucially, it filters out sensitive or non-payment types such as `CardToken` and `MandatePayment`, returning `None` for these cases. This logic is essential for the router and analytics layers to categorize transactions and route them to the correct payment processors without exposing raw token details.", "queries": ["how to convert internal payment method data structures to common enums", "hyperswitch get_payment_method function implementation rust", "mapping internal payment method variants to common_enums", "rust function to get payment method type from domain models"], "label": "Payment method type mapper", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "get_payment_method", "unit_type": "function", "num_lines": 26}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "positive": "The `get_url` method within the `juspaythreedsserver` connector implementation serves as a placeholder for URL generation logic specific to the Juspay 3DS server integration. As a stub method, it currently returns a `NotImplemented` error, indicating that the specific URL endpoint configuration for initiating 3D Secure authentication flows has not yet been implemented in this connector crate. This function is part of the `PaymentsAuthorizeRouterData` flow, where it would typically be called to retrieve the specific API endpoint required to forward authorization requests to the Juspay gateway.", "queries": ["juspaythreedsserver get_url method implementation", "hyperswitch juspay 3ds connector get_url stub", "how to implement get_url in juspaythreedsserver", "juspaythreedsserver connector error NotImplemented get_url"], "label": "Juspay 3DS Connector Stub", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularCaptureResponse\npub struct WorldpaymodularCaptureResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This struct represents the deserialized response payload from the Worldpay Modular API following a successful payment capture transaction. It encapsulates the unique identifier for the payment (`payment_id`) and a collection of navigation links (`_links`) typically used to retrieve the payment status, details, or perform subsequent actions. It is utilized within the `WorldpaymodularCaptureResponse` transformer to map the raw HTTP JSON response into the internal domain model required by the Hyperswitch payment orchestration engine.", "queries": ["WorldpaymodularCaptureResponse struct definition", "hyperswitch worldpay capture response fields", "how to deserialize worldpay modular capture api", "worldpaymodular payment_id field rust"], "label": "Worldpay Modular Capture Response Model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "WorldpaymodularCaptureResponse", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &RouterData<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/payment_instruments\", self.base_url(connectors)))\n    }\n", "positive": "This function constructs the base API endpoint URL for interacting with the Finix payment gateway. It retrieves the configured base URL from the connector's configuration and appends the specific resource path '/payment_instruments'. This endpoint is used to manage payment instruments (cards, bank accounts) within the Finix system, serving as a prerequisite for creating payment methods or processing transactions in the Hyperswitch orchestration platform.", "queries": ["How to configure Finix payment instrument URL in hyperswitch", "hyperswitch finix connector get_url implementation", "finix payment_instruments endpoint hyperswitch rust", "hyperswitch finix base_url payment_instruments"], "label": "Finix Payment Instrument URL", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__finix.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: get_intent_status_with_count\n    async fn get_intent_status_with_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        profile_id_list: Option<Vec<id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n    ) -> error_stack::Result<Vec<(common_enums::IntentStatus, i64)>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "positive": "This function retrieves a list of distinct payment intent statuses along with their respective counts for a specific processor merchant. It accepts optional profile filters and a time range constraint to scope the aggregation. The return type is a vector of tuples containing the status enum and the count, designed to support analytics and reporting workflows within the domain models layer.", "queries": ["rust hyperswitch get_intent_status_with_count processor_merchant_id", "how to count intents by status in hyperswitch rust", "hyperswitch domain models payment intent status count query", "rust hyperswitch get_intent_status_with_count profile_id_list"], "label": "Payment intent status count retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "get_intent_status_with_count", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_transaction_id\n    pub fn get_connector_transaction_id(\n        &self,\n    ) -> Result<String, error_stack::Report<ApiErrorResponse>> {\n        match self {\n            Self::TransactionResponse {\n                resource_id: ResponseId::ConnectorTransactionId(txn_id),\n                ..\n            } => Ok(txn_id.to_string()),\n            _ => Err(ApiErrorResponse::MissingRequiredField {\n                field_name: \"ConnectorTransactionId\",\n            }\n            .into()),\n        }\n    }\n", "positive": "This function retrieves the `ConnectorTransactionId` from a `TransactionResponse` enum variant. It is a critical utility in the `hyperswitch_domain_models` crate, specifically within the `router_response_types` module. It handles the mapping of internal response structures to the specific transaction identifier required by the payment orchestration router, ensuring that the correct ID is passed downstream to connectors or logging systems. It returns a `Result<String>` and handles missing fields by returning an `ApiErrorResponse::MissingRequiredField` error.", "queries": ["how to extract connector transaction id from TransactionResponse enum", "rust hyperswitch get_connector_transaction_id implementation", "hyperswitch domain models router_response_types connector transaction id", "TransactionResponse enum variant connector transaction id extraction"], "label": "TransactionResponse connector id extractor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "get_connector_transaction_id", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/v2/Pci/Tokenize\", self.base_url(connectors)))\n    }\n", "positive": "This function generates the API endpoint URL for the PCI Tokenization service within the TokenEx connector. It constructs the path '/v2/Pci/Tokenize' relative to the connector's base URL, which is dynamically resolved via the base_url helper. This endpoint is used during the ExternalVaultInsertFlow to securely tokenize sensitive card data before storage.", "queries": ["how to configure TokenEx PCI Tokenize URL in hyperswitch", "hyperswitch TokenEx connector get_url implementation", "TokenEx hyperswitch v2/Pci/Tokenize endpoint configuration", "hyperswitch TokenEx connector base_url and get_url method"], "label": "TokenEx PCI Tokenize URL generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: Window\npub enum Window<R> {\n    Sum {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n    RowNumber {\n        field: R,\n        partition_by: Option<String>,\n        order_by: Option<(String, Order)>,\n        alias: Option<&'static str>,\n    },\n}\n\n#[derive(Debug, Clone, Copy)]", "positive": "The `Window` enum in `hyperswitch` defines SQL window function constructs for analytics queries, specifically supporting `Sum` and `RowNumber` aggregations. It accepts a generic field `R`, optional partitioning keys, ordering criteria, and an alias. This abstraction is utilized within the analytics crate to generate dynamic SQL queries that perform complex time-series or group-based aggregations over payment events, facilitating metrics calculation and reporting.", "queries": ["how to define a window function sum in rust hyperswitch", "hyperswitch analytics crate window enum rownumber", "rust struct window sum partition by order by", "hyperswitch analytics query window function implementation"], "label": "Window Enum Definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "Window", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_mandate_id\n    pub fn get_mandate_id(&self) -> Option<MandateReference> {\n        self.token.clone().map(|mandate_id| MandateReference {\n            connector_mandate_id: Some(mandate_id.href.expose()),\n            payment_method_id: None,\n            mandate_metadata: None,\n            connector_mandate_request_reference_id: None,\n        })\n    }\n}\n", "positive": "This function extracts a mandate identifier from a token object, transforming it into a `MandateReference` struct. It maps the token's `href` field to `connector_mandate_id` within the connector-specific response wrapper, which is used by the WorldPay Modular connector to link payment actions to specific mandates. It is a critical transformation step in the response processing pipeline for mandate retrieval operations.", "queries": ["how to extract mandate id from worldpay token response", "worldpay modular connector mandate reference mapping", "hyperswitch worldpay mandate_id extraction logic", "get_mandate_id worldpay connector rust implementation"], "label": "WorldPay mandate ID extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "get_mandate_id", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: extract_debit_routing_saving_percentage\n    pub fn extract_debit_routing_saving_percentage(\n        &self,\n        network: &common_enums::CardNetwork,\n    ) -> Option<f64> {\n        self.get_co_badged_card_data()?\n            .co_badged_card_networks_info\n            .0\n            .iter()\n            .find(|info| &info.network == network)\n            .and_then(|info| info.saving_percentage)\n    }\n}\n\n#[derive(PartialEq, Clone, Debug, Serialize, Deserialize, Default)]", "positive": "This function retrieves the specific saving percentage associated with a Co-badged card network for a debit transaction. It takes a `CardNetwork` enum as input and queries the internal `co_badged_card_networks_info` tuple. The method returns `None` if the network is not found or if the card data is missing, ensuring safe handling of routing configuration data within the `hyperswitch_domain_models` crate.", "queries": ["how to get saving percentage for co-badged debit card network", "rust function to extract routing saving percentage from card data", "hyperswitch debit routing saving percentage implementation", "get_co_badged_card_data saving percentage logic"], "label": "Co-badged debit routing saving percentage", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "extract_debit_routing_saving_percentage", "unit_type": "function", "num_lines": 14}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n", "positive": "This function implements the From trait for converting a tuple of (FloatMajorUnit, T) into the connector's internal struct. It extracts the monetary amount and router-specific data, serving as a constructor for the Wise connector's response model. This pattern is used within the Wise transformer module to parse raw API responses into typed domain objects before routing the payment flow.", "queries": ["Rust From trait implementation for Wise connector response tuple", "how to convert Wise API response tuple to struct in hyperswitch", "hyperswitch wise transformer from method FloatMajorUnit T", "Rust payment orchestration connector response parsing pattern"], "label": "Wise connector From trait", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "from", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs\n// MODULE: data::code_corpus_hyperswitch::crates__common_utils__src__new_type.rs\n// SYMBOL: masking\nimpl masking::SerializableSecret for MerchantName {}\n\n/// Function for masking alphanumeric characters in a string.\n///\n/// # Arguments\n///     `val`\n///         - holds reference to the string to be masked.\n///     `unmasked_char_count`\n///         - minimum character count to remain unmasked for identification\n///         - this number is for keeping the characters unmasked from\n///             both beginning (if feasible) and ending of the string.\n///     `min_masked_char_count`\n///         - this ensures the minimum number of characters to be masked\n///\n/// # Behaviour\n///     - Returns the original string if its length is less than or equal to `unmasked_char_count`.\n///     - If the string length allows, keeps `unmasked_char_count` characters unmasked at both start and end.\n///     - Otherwise, keeps `unmasked_char_count` characters unmasked only at the end.\n///     - Only alphanumeric characters are masked; other characters remain unchanged.\n///\n/// # Examples\n///     Sort Code\n///         (12-34-56, 2, 2) -> 12-**-56\n///     Routing number\n///         (026009593, 3, 3) -> 026***593\n///     CNPJ\n///         (12345678901, 4, 4) -> *******8901\n///     CNPJ\n///         (12345678901, 4, 3) -> 1234***8901\n///     Pix key\n///         (123e-a452-1243-1244-000, 4, 4) -> 123e-****-****-****-000\n///     IBAN\n///         (AL35202111090000000001234567, 5, 5) -> AL352******************34567", "positive": "The `masking` function in `common_utils` implements a flexible alphanumeric string obfuscation strategy used to sanitize sensitive data like Merchant Names, Routing Numbers, and IBANs. It accepts a reference to the string, a target unmasked count, and a minimum masked count. The logic prioritizes preserving the first and last characters for identification, splitting the unmasked characters evenly between the start and end if the string length permits. If the string is too short, it masks the middle portion. This utility is critical for logging, debugging, and API response masking within the Hyperswitch payment orchestration platform to ensure PII protection while maintaining data traceability.", "queries": ["Rust function to mask alphanumeric characters in a string keeping first and last characters visible", "Hyperswitch common_utils masking function implementation for sensitive data", "Rust code to obfuscate string with configurable unmasked character count", "How to mask alphanumeric characters in Rust keeping start and end characters"], "label": "String masking utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__common_utils__src__new_type.rs", "path": "data/code_corpus_hyperswitch/crates__common_utils__src__new_type.rs", "symbol": "masking", "unit_type": "function", "num_lines": 33}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::ApplePay,\n            PaymentMethodDataType::GooglePay,\n        ]);\n        utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This function, `validate_mandate_payment`, is a core validation step within the Wellsfargo connector implementation. It determines if the provided payment method (PM) is supported for a mandate-based payment flow. It checks the PM type against a whitelist of supported mandates (Card, ApplePay, GooglePay) and delegates the detailed validation logic to a utility function, `is_mandate_supported`. This ensures that only specific payment methods are processed for mandates within the Wellsfargo integration.", "queries": ["how to validate payment method for mandate in wells fargo connector", "wellsfargo mandate supported payment methods types", "rust function validate_mandate_payment implementation", "check if payment method is supported for mandate hyperswitch"], "label": "Wellsfargo mandate payment validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "validate_mandate_payment", "unit_type": "function", "num_lines": 18}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for the Sift payment fraud detection connector within the Hyperswitch payment orchestration platform. It specifies how the system handles payment method tokenization requests by forwarding them to Sift's API to generate risk scores or tokens. The implementation is currently marked as 'Not Implemented' (R), indicating it is a placeholder for future development. It leverages the `ConnectorIntegration` trait to manage the specific data types `PaymentMethodToken`, `PaymentMethodTokenizationData`, and `PaymentsResponseData` required for the tokenization workflow.", "queries": ["how to implement Sift fraud detection integration in Hyperswitch", "Sift payment method tokenization connector rust implementation", "hyperswitch sift connector integration trait not implemented", "rust connector integration for fraud detection tokenization"], "label": "Sift fraud connector integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: try_from\n    fn try_from(item: &FrmSaleRouterData) -> Result<Self, Self::Error> {\n        let products = item\n            .request\n            .get_order_details()?\n            .iter()\n            .map(|order_detail| Products {\n                item_name: order_detail.product_name.clone(),\n                item_price: order_detail.amount.get_amount_as_i64(), // This should be changed to MinorUnit when we implement amount conversion for this connector. Additionally, the function get_amount_as_i64() should be avoided in the future.\n                item_quantity: i32::from(order_detail.quantity),\n                item_id: order_detail.product_id.clone(),\n                item_category: order_detail.category.clone(),\n                item_sub_category: order_detail.sub_category.clone(),\n                item_is_digital: order_detail\n                    .product_type\n                    .as_ref()\n                    .map(|product| product == &common_enums::ProductType::Digital),\n            })\n            .collect::<Vec<_>>();\n        let metadata: SignifydFrmMetadata = item\n            .frm_metadata\n            .clone()\n            .ok_or(ConnectorError::MissingRequiredField {\n                field_name: \"frm_metadata\",\n            })?\n            .parse_value(\"Signifyd Frm Metadata\")\n            .change_context(ConnectorError::InvalidDataFormat {\n                field_name: \"frm_metadata\",\n            })?;\n        let ship_address = item.get_shipping_address()?;\n        let billing_address = item.get_billing()?;\n        let street_addr = ship_address.get_line1()?;\n        let city_addr = ship_address.get_city()?;\n        let zip_code_addr = ship_address.get_zip()?;\n        let country_code_addr = ship_address.get_country()?;\n        let _first_name_addr = ship_address.get_first_name()?;\n        let _last_name_addr = ship_address.get_last_name()?;\n        let address: Address = Address {\n            street_address: street_addr.clone(),\n            unit: None,\n            postal_code: zip_code_addr.clone(),\n            city: city_addr.clone(),\n            province_code: zip_code_addr.clone(),\n            country_code: country_code_addr.to_owned(),\n        };\n        let destination: Destination = Destination {\n            full_name: ship_address.get_full_name().unwrap_or_default(),\n            organization: None,\n            email: None,\n            address,\n        };\n\n        let created_at = common_utils::date_time::now();\n\n\n... [truncated 322 chars] ...\n\n      products,\n            shipments,\n            currency: item.request.currency,\n            total_shipping_cost: metadata.total_shipping_cost,\n            confirmation_email: item.request.email.clone(),\n            confirmation_phone: billing_address\n                .clone()\n                .phone\n                .and_then(|phone_data| phone_data.number),\n        };\n        Ok(Self {\n            order_id: item.attempt_id.clone(),\n            purchase,\n            decision_delivery: DecisionDelivery::Sync, // Specify SYNC if you require the Response to contain a decision field. If you have registered for a webhook associated with this checkpoint, then the webhook will also be sent when SYNC is specified. If ASYNC_ONLY is specified, then the decision field in the response will be null, and you will require a Webhook integration to receive Signifyd's final decision\n            coverage_requests: metadata.coverage_request,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This `try_from` implementation transforms `FrmSaleRouterData` into a Signifyd purchase object. It extracts order details, shipping/billing addresses, and metadata from the router data, handling potential errors like missing fields. It specifically maps product quantities and amounts, noting a future requirement to use `MinorUnit` instead of `get_amount_as_i64()`. The function constructs a `Purchase` struct with a synchronous delivery decision and prepares coverage requests for the Signifyd fraud detection integration.", "queries": ["how to convert FrmSaleRouterData to Signifyd purchase object", "Signifyd integration try_from implementation Rust", "map order details and addresses to Signifyd Purchase struct", "handle missing frm_metadata in Signifyd connector"], "label": "Signifyd Purchase Transformer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 82}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: insert_org_in_db\n    pub async fn insert_org_in_db(self, state: SessionState) -> UserResult<Organization> {\n        state\n            .accounts_store\n            .insert_organization(self.0)\n            .await\n            .map_err(|e| {\n                if e.current_context().is_db_unique_violation() {\n                    e.change_context(UserErrors::DuplicateOrganizationId)\n                } else {\n                    e.change_context(UserErrors::InternalServerError)\n                }\n            })\n            .attach_printable(\"Error while inserting organization\")\n    }\n", "positive": "This function inserts a new organization record into the persistent storage layer. It acts as a critical data persistence step during the onboarding or creation of a new tenant within the Hyperswitch payment orchestration platform. The function interacts with the `accounts_store` to handle the database transaction. It specifically handles database integrity constraints by checking for unique violations (e.g., duplicate organization IDs) and maps them to a specific `UserErrors::DuplicateOrganizationId` error, while other errors are generalized to an internal server error. This ensures robust error handling for tenant creation workflows.", "queries": ["how to insert a new organization into the hyperswitch database", "rust function to create organization in accounts_store", "hyperswitch insert_organization_in_db error handling duplicate id", "code for creating a new organization tenant in hyperswitch"], "label": "Organization creation persistence", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__types__domain__user.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "symbol": "insert_org_in_db", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Gpayments\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gpayments\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for Gpayments, a connector within the hyperswitch_connectors crate. It establishes the interface for tokenizing payment methods and processing payment flows. The implementation is currently marked as 'Not Implemented (R)', indicating the connector logic for Gpayments is a placeholder or under development. It relies on the `ConnectorIntegration` trait for core payment operations and `ConnectorCommonExt` for shared utility extensions.", "queries": ["rust hyperswitch gpayments connector integration not implemented", "hyperswitch gpayments tokenization payments response data trait", "gpayments connector implementation status rust hyperswitch_connectors", "hyperswitch gpayments payment method tokenization data flow"], "label": "Gpayments Connector Integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {\n                ca_certificate: Some(api_key.to_owned()),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, Eq, PartialEq)]", "positive": "This function implements a 'try_from' conversion for a connector's authentication type, specifically handling the 'HeaderKey' variant by extracting the API key. It constructs a new instance of the connector's auth struct, setting the 'ca_certificate' field with the provided key. If the input is not a 'HeaderKey', it returns a 'ConnectorError::FailedToObtainAuthType'. This is a core utility for the archipel connector, ensuring proper authentication configuration during the payment orchestration flow.", "queries": ["archipel connector try_from implementation", "how to configure HeaderKey auth type in archipel", "rust try_from pattern for ConnectorAuthType", "archipel hyperswitch authentication setup"], "label": "Archipel auth configuration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n", "positive": "This function `get_error_response` is a specialized handler within the Wells Fargo connector implementation that standardizes HTTP responses into a unified `ErrorResponse` format. It acts as a critical abstraction layer, converting raw `Response` objects from external payment gateways into the internal `hyperswitch` error model. The function accepts an optional `ConnectorEvent` builder, allowing it to enrich error logs or audit trails with contextual metadata before returning the standardized error. This ensures consistent error handling across the payment orchestration platform, decoupling the connector's specific HTTP implementation from the core router's error processing logic.", "queries": ["how to handle wells fargo api error responses in rust", "wells fargo connector get_error_response implementation", "rust function to parse wells fargo http error", "hyperswitch wells fargo error handling standardization"], "label": "Wells Fargo error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: get_bucket_size\n    fn get_bucket_size(&self) -> u8 {\n        match self {\n            Self::OneMin => 60,\n            Self::FiveMin => 5,\n            Self::FifteenMin => 15,\n            Self::ThirtyMin => 30,\n            Self::OneHour => 60,\n            Self::OneDay => 24,\n        }\n    }\n", "positive": "This function, `get_bucket_size`, is part of the `analytics` crate within the Hyperswitch payment orchestration platform. It serves as a mapping utility that translates specific time interval enumssuch as `OneMin`, `FiveMin`, or `OneDay`into their corresponding integer bucket durations in minutes. This logic is critical for configuring time-windowed aggregation queries, specifically within the `query.rs` module, to ensure that data is bucketed correctly for performance monitoring and analytics reporting.", "queries": ["how to get bucket size for time intervals in rust", "hyperswitch analytics query bucket size mapping", "rust enum to minutes conversion for time windows", "get_bucket_size function implementation rust"], "label": "Time interval bucket size mapping", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "get_bucket_size", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: try_from\n    fn try_from(_item: &types::RefreshTokenRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            grant_type: \"client_credentials\".to_string(),\n            scope: \"payment\".to_string(),\n        })\n    }\n}\n#[derive(Debug, Serialize)]", "positive": "This function implements the `TryFrom` trait for a token struct, specifically transforming `RefreshTokenRouterData` into a token object. It hardcodes the grant type to 'client_credentials' and sets the scope to 'payment', effectively creating a static authentication token payload for the IATAPay connector. This is a critical transformation step within the connector's request handling pipeline, ensuring the external payment gateway receives the correct authorization parameters derived from the internal router data structure.", "queries": ["rust try_from refresh token router data implementation", "iatapay connector token generation client_credentials", "hyperswitch refresh token to token conversion", "rust derive TryFrom refresh token data"], "label": "iatapay token transformer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = airwallex::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function, defined within the Airwallex connector implementation, transforms the internal `ConnectorCustomerRouterData` struct into the specific `CustomerRequest` format required by the Airwallex API. It acts as a serialization adapter, ensuring that the router's generic customer data is correctly mapped to Airwallex's expected JSON payload before the HTTP request is dispatched. The function returns the payload wrapped in a `RequestContent::Json` variant, handling potential conversion errors via the `try_from` method.", "queries": ["how to convert ConnectorCustomerRouterData to Airwallex CustomerRequest", "Airwallex connector get_request_body implementation", "formatting customer data for Airwallex API in hyperswitch", "Airwallex customer request payload structure hyperswitch"], "label": "Airwallex Customer Request Serialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: validate_psync_reference_id\n    fn validate_psync_reference_id(\n        &self,\n        _data: &PaymentsSyncData,\n        _is_three_ds: bool,\n        _status: enums::AttemptStatus,\n        _connector_meta_data: Option<common_utils::pii::SecretSerdeValue>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        Ok(())\n    }\n}\n", "positive": "This function serves as a validation stub within the Zift connector implementation. It is designed to handle the validation of a PSync (Payment Sync) reference ID during payment processing flows. The function currently returns a successful result (Ok(())), indicating that no validation logic is enforced at this stage. It accepts standard context parameters such as PaymentsSyncData, a boolean flag for 3DS status, the current AttemptStatus, and optional connector metadata, allowing for future extensibility or integration with specific Zift API requirements.", "queries": ["how to implement validate_psync_reference_id in Zift connector", "zift connector validate_psync_reference_id function signature", "hyperswitch zift validate_psync_reference_id implementation", "custom result connector error zift validate_psync_reference_id"], "label": "Zift connector validation stub", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "validate_psync_reference_id", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "This function retrieves and formats the HTTP headers required for authorizing a payment transaction with the Globepay connector. It acts as a wrapper for the internal `build_headers` method, taking the router's authorization request data and the active connector registry as inputs. The output is a vector of key-value pairs, where values are masked for security, ensuring sensitive data like API keys and signatures are handled correctly before transmission to the external payment gateway.", "queries": ["how to configure authorization headers for Globepay in hyperswitch", "hyperswitch globepay connector authorization request data structure", "rust function to build custom headers for globepay payments", "hyperswitch globepay get_headers implementation details"], "label": "Globepay authorization header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth = NordeaAuthType::try_from(&req.connector_auth_type)?;\n        let content_type = self.get_content_type().to_string();\n        let http_method = self.get_http_method();\n\n        // Extract host from base URL\n        let nordea_host = Url::parse(self.base_url(connectors))\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .to_string();\n\n        let nordea_origin_date = date_time::now_rfc7231_http_date()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let full_url = self.get_url(req, connectors)?;\n        let url_parsed =\n            Url::parse(&full_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let path = url_parsed.path();\n        let path_with_query = if let Some(query) = url_parsed.query() {\n            format!(\"{path}?{query}\")\n        } else {\n            path.to_string()\n        };\n\n        let mut required_headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.clone().into(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n            ),\n            (\n                \"X-IBM-Client-ID\".to_string(),\n                auth.client_id.clone().expose().into_masked(),\n            ),\n            (\n                \"X-IBM-Client-Secret\".to_string(),\n                auth.client_secret.clone().expose().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Date\".to_string(),\n                nordea_origin_date.clone().into_masked(),\n            ),\n            (\n                \"X-Nordea-Originating-Host\".to_string(),\n                nordea_host.clone().into_masked(),\n            ),\n        ];\n\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            let nordea_request = self.get_request_body(req, connectors)?;\n\n            let sha2\n\n... [truncated 301 chars] ...\n\n              &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path,\n                    payload_digest: Some(&sha256_digest),\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        } else {\n            // Generate signature without digest for GET requests\n            let signature = self.generate_signature(\n                &auth,\n                SignatureParams {\n                    content_type: &content_type,\n                    host: &nordea_host,\n                    path: &path_with_query,\n                    payload_digest: None,\n                    date: &nordea_origin_date,\n                    http_method,\n                },\n            )?;\n\n            required_headers.push((\"Signature\".to_string(), signature.into_masked()));\n        }\n\n        Ok(required_headers)\n    }\n}\n", "positive": "The `build_headers` function constructs the HTTP headers required for a Nordea payment request. It dynamically generates an Authorization header with a Bearer token, sets the Content-Type, and includes the Nordea-specific X-IBM-Client-ID and X-IBM-Client-Secret. It also calculates and adds a signature header, which includes the request path, host, and a SHA-256 digest of the request body for POST/PUT/PATCH methods, or just the path and host for GET requests. This ensures the request is authenticated and signed according to Nordea's API specifications.", "queries": ["how to build headers for Nordea API requests in Rust", "Nordea connector authentication header generation hyperswitch", "hyperswitch nordea build_headers function implementation", "Nordea API signature header generation with SHA256"], "label": "Nordea header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 105}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n", "positive": "This function constructs the HTTP headers required for authenticating and formatting requests sent to the Netcetera payment gateway. It initializes a vector with a mandatory Content-Type header derived from the connector's configuration and appends authentication headers based on the specific auth type provided in the request context. The function ensures the request is properly formatted and authorized before transmission.", "queries": ["how to configure netcetera connector authentication headers", "rust hyperswitch netcetera build_headers implementation", "netcetera payment gateway hyperswitch rust connector", "hyperswitch netcetera connector content type header"], "label": "Netcetera connector header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsPreAuthenticateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        let request = RequestBuilder::new()\n            .method(Method::Post)\n            .url(&PaymentsPreAuthenticateType::get_url(\n                self, req, connectors,\n            )?)\n            .attach_default_headers()\n            .headers(PaymentsPreAuthenticateType::get_headers(\n                self, req, connectors,\n            )?)\n            .set_body(self.get_request_body(req, connectors)?)\n            .build();\n\n        Ok(Some(request))\n    }\n", "positive": "This function constructs the HTTP POST request for the Barclaycard pre-authentication flow. It utilizes the `RequestBuilder` to set the HTTP method, dynamically generates the URL and headers using `PaymentsPreAuthenticateType` utilities, and attaches the specific request body derived from the input data. It returns an `Option<Request>` to handle scenarios where request generation might fail or be skipped.", "queries": ["how to build request for barclaycard pre-auth", "barclaycard pre-auth request builder rust hyperswitch", "PaymentsPreAuthenticateRouterData barclaycard connector implementation", "hyperswitch barclaycard pre-auth request construction"], "label": "Barclaycard pre-auth request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 20}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: KlarnaPaymentsRequest\npub struct KlarnaPaymentsRequest {\n    order_lines: Vec<OrderLines>,\n    order_amount: MinorUnit,\n    purchase_country: enums::CountryAlpha2,\n    purchase_currency: enums::Currency,\n    merchant_reference1: Option<String>,\n    merchant_reference2: Option<String>,\n    shipping_address: Option<KlarnaShippingAddress>,\n    auto_capture: Option<bool>,\n    order_tax_amount: Option<MinorUnit>,\n    #[serde(flatten)]\n    payment_method_specifics: Option<PaymentMethodSpecifics>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]", "positive": "This struct defines the input payload for initiating a Klarna payment transaction within the Hyperswitch payment orchestration platform. It encapsulates core transaction details such as the total order amount, purchase currency and country, and a list of individual order line items. The struct supports optional merchant references and shipping addresses, alongside a boolean flag for auto-capture. It utilizes Serde flattening to dynamically inject Klarna-specific payment method configurations via the PaymentMethodSpecifics field, ensuring flexibility for different Klarna payment flows like account pay or pay later.", "queries": ["KlarnaPaymentsRequest struct definition fields", "how to construct Klarna payment request payload", "hyperswitch Klarna connector input model", "KlarnaPaymentsRequest auto_capture field usage"], "label": "Klarna payment request model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "symbol": "KlarnaPaymentsRequest", "unit_type": "function", "num_lines": 16}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularEventResponse\npub struct WorldpaymodularEventResponse {\n    pub last_event: EventType,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<EventLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This struct represents the top-level envelope for Worldpay Modular API webhooks. It encapsulates the specific event type (e.g., payment, refund) and optional metadata links. It is deserialized from incoming webhook payloads in the `hyperswitch_connectors` crate, serving as the primary data model for processing asynchronous payment events triggered by the Worldpay gateway.", "queries": ["Worldpay Modular webhook response structure", "hyperswitch Worldpay modular event deserialization", "WorldpaymodularEventResponse struct definition", "how hyperswitch handles worldpay modular webhooks"], "label": "Worldpay Modular webhook response struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "WorldpaymodularEventResponse", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_tracker\n    async fn update_tracker<'b>(\n        &'b self,\n        db: &'b SessionState,\n        processor: &domain::Processor,\n        mut payment_data: PaymentData<F>,\n        router_data: types::RouterData<\n            F,\n            types::PaymentsAuthorizeData,\n            types::PaymentsResponseData,\n        >,\n        locale: &Option<String>,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] routable_connector: Vec<\n            RoutableConnectorChoice,\n        >,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] business_profile: &domain::Profile,\n    ) -> RouterResult<PaymentData<F>>\n    where\n        F: 'b,\n    {\n        payment_data.mandate_id = payment_data\n            .mandate_id\n            .or_else(|| router_data.request.mandate_id.clone());\n\n        // update setup_future_usage incase it is downgraded to on-session\n        payment_data.payment_attempt.setup_future_usage_applied =\n            router_data.request.setup_future_usage;\n\n        payment_data = Box::pin(payment_response_update_tracker(\n            db,\n            payment_data,\n            router_data,\n            processor,\n            locale,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            routable_connector,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            business_profile,\n        ))\n        .await?;\n\n        Ok(payment_data)\n    }\n\n    #[cfg(feature = \"v2\")]", "positive": "This function orchestrates the final state update for a payment response within the Router crate. It acts as a bridge between the incoming HTTP request context and the database persistence layer. It specifically handles the synchronization of the `mandate_id` from the request payload to the payment data object and applies the `setup_future_usage` configuration. The core logic delegates to `payment_response_update_tracker` to persist the final state, ensuring the payment record reflects the exact outcome of the authorization or capture operation.", "queries": ["Rust hyperswitch router update mandate_id from request", "hyperswitch payment_response_update_tracker function signature", "how to update setup_future_usage in hyperswitch router", "hyperswitch router crate payment data persistence"], "label": "Router payment response state update", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__payments__operations__payment_response.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "symbol": "update_tracker", "unit_type": "function", "num_lines": 44}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = authipay::AuthipayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::API_KEY.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n", "positive": "This function constructs the HTTP Authorization header for the Authipay payment connector. It accepts a generic `ConnectorAuthType` and converts it into the specific `AuthipayAuthType` enum. It then returns a vector of key-value pairs, specifically mapping the API key to the standard `API_KEY` header name, ensuring the key is masked for security before transmission.", "queries": ["rust hyperswitch authipay get_auth_header implementation", "how to configure API key header for Authipay connector in hyperswitch", "hyperswitch AuthipayAuthType conversion and header generation", "rust function get_auth_header hyperswitch authipay"], "label": "Authipay API Key Header", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "get_auth_header", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Boku\".to_string())\n                .into(),\n        )\n    }\n}\n", "positive": "This function defines the request construction logic for the Boku payment connector within the Hyperswitch payment orchestration platform. It is designed to handle the 'Setup Mandate' flow, which is a specific payment method lifecycle event. The implementation currently returns a 'NotImplemented' error, indicating that the Boku connector integration for this specific mandate setup flow has not been fully developed or is currently disabled in the Rust codebase.", "queries": ["rust hyperswitch boku connector setup mandate error", "hyperswitch boku build_request function not implemented", "how to implement setup mandate in boku connector rust", "hyperswitch boku payment method mandate setup error"], "label": "Boku Setup Mandate Not Implemented", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 12}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: value_analysis\n    fn value_analysis(\n        &self,\n        val: dir::DirValue,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "positive": "This function performs a directed graph traversal to analyze the value dependencies of a specific directory value within the Euclid crate. It constructs a dependency graph, utilizing memoization to prevent redundant computations and cycle detection to identify circular references. The method accepts optional domain filters to restrict analysis scope and returns a Result indicating success or a GraphError if the traversal encounters invalid graph structures.", "queries": ["how to analyze value dependencies in euclid graph", "euclid dssa graph value_analysis function signature", "rust euclid graph cycle detection memoization", "how to filter domain analysis in euclid graph traversal"], "label": "Euclid graph value dependency analysis", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "value_analysis", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationEligibilityResponse\npub struct AuthenticationEligibilityResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = NextAction)]\n    pub next_action: NextAction,\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n    /// The 3DS data for this authentication.\n    #[schema(value_type = Option<EligibilityResponseParams>)]\n    pub eligibility_response_params: Option<EligibilityResponseParams>,\n    /// The metadata for this authentication.\n    #[schema(value_type = serde_json::Value)]\n    pub connector_metadata: Option<serde_json::Value>,\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String)]\n    pub profile_id: id_type::ProfileId,\n    /// The error message for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_message: Option<String>,\n    /// The error code for this authentication.\n    #[schema(value_type = Option<String>)]\n    pub error_code: Option<String>,\n    /// The connector used for this authentication.\n    #[schema(value_type = Option<AuthenticationConnectors>)]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n    /// Billing address\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<Address>,\n    /// Shipping address\n    #[schema(value_type = Option<Address>)]\n    pub shipping: Option<Address>,\n    /// Browser information\n    #[schema(value_type = Option<BrowserInformation>)]\n    pub browser_information: Option<BrowserInformation>,\n    /// Email\n    #[schema(value_type = Option<String>)]\n    pub email: common_utils::crypto::OptionalEncryptableEmail,\n    /// Acquirer details information.\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, Serialize, Deserialize, ToSchema)]", "positive": "The AuthenticationEligibilityResponse struct defines the data model returned by the router when initiating or querying an authentication flow (e.g., 3DS). It encapsulates the authentication lifecycle, including the unique authentication_id, current status (e.g., Started), and the next_action required to proceed. Crucially, it carries connector-specific details like eligibility_response_params, connector_metadata, and acquirer_details, alongside user context such as billing/shipping addresses and browser information. This struct is central to the router's orchestration logic, mapping the result of a connector's eligibility check back to the client.", "queries": ["rust hyperswitch AuthenticationEligibilityResponse struct fields", "hyperswitch router authentication response model next_action", "AuthenticationEligibilityResponse authentication_id connector_metadata rust", "hyperswitch authentication eligibility params struct definition"], "label": "Authentication Response Model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__api_models__src__authentication.rs", "path": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "symbol": "AuthenticationEligibilityResponse", "unit_type": "function", "num_lines": 47}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` method in the Thunes connector implementation serves as the primary interface for constructing the HTTP request headers required to authenticate and authorize transactions with the Thunes payment gateway. It acts as a wrapper around the internal `build_headers` logic, specifically tailored for the `PaymentsAuthorizeRouterData` context. This function is critical for ensuring that sensitive credentials and dynamic routing information are correctly injected into the outgoing request, facilitating secure communication with the external payment provider within the Hyperswitch orchestration framework.", "queries": ["rust hyperswitch thunes connector get_headers implementation", "how to configure authentication headers for thunes payment gateway in hyperswitch", "thunes connector source code get_headers function rust", "hyperswitch thunes authorization request header setup"], "label": "Thunes connector auth header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &MandateRevokeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<MandateRevokeRouterData, errors::ConnectorError> {\n        if matches!(res.status_code, 204) {\n            event_builder.map(|i| i.set_response_body(&serde_json::json!({\"mandate_status\": common_enums::MandateStatus::Revoked.to_string()})));\n            Ok(MandateRevokeRouterData {\n                response: Ok(MandateRevokeResponseData {\n                    mandate_status: common_enums::MandateStatus::Revoked,\n                }),\n                ..data.clone()\n            })\n        } else {\n            // If http_code != 204 || http_code != 4xx, we dont know any other response scenario yet.\n            let response_value: serde_json::Value = serde_json::from_slice(&res.response)\n                .change_context(errors::ConnectorError::ResponseHandlingFailed)?;\n            let response_string = response_value.to_string();\n\n            event_builder.map(|i| {\n                i.set_response_body(\n                    &serde_json::json!({\"response_string\": response_string.clone()}),\n                )\n            });\n            router_env::logger::info!(connector_response=?response_string);\n\n            Ok(MandateRevokeRouterData {\n                response: Err(ErrorResponse {\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: response_string.clone(),\n                    reason: Some(response_string),\n                    status_code: res.status_code,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                }),\n                ..data.clone()\n            })\n        }\n    }", "positive": "This function handles the response logic for the Wells Fargo mandate revoke operation within the Hyperswitch payment orchestration platform. It processes the HTTP response from the connector, distinguishing between a successful 204 No Content status (which triggers a specific 'Revoked' event payload) and error scenarios. For non-204 responses, it attempts to deserialize the body into a JSON value to capture the raw response string, logs it, and constructs a detailed ErrorResponse object containing the status code, message, and reason. This ensures the router accurately reflects the connector's state and facilitates downstream webhook or logging processing.", "queries": ["how to handle mandate revoke response status 204 in hyperswitch", "wellsfargo mandate revoke connector error handling rust", "hyperswitch mandate_revoke_router_data response parsing", "rust function handle_response mandate revoke 204 status"], "label": "Mandate Revoke Response Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 45}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Boku\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Boku\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This function defines the integration interface for the Boku payment connector within the Hyperswitch payment orchestration platform. It implements the `ConnectorIntegration` trait, specifying how the Boku connector handles payment flows, tokenization requests, and response data structures. The implementation is currently marked as 'Not Implemented' (R), indicating that the specific business logic for processing Boku transactions, including token creation and payment execution, has not yet been coded. This placeholder ensures type safety and contract compliance with the connector architecture.", "queries": ["how to implement Boku payment connector in Rust", "hyperswitch Boku connector integration example", "Rust trait implementation for Boku payments", "Boku payment method tokenization hyperswitch"], "label": "Boku connector integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: PaymentsResponseData\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]", "positive": "PaymentsResponseData is a Rust enum in the hyperswitch payment orchestration platform used to represent the diverse outcomes of payment processing. It encapsulates various response types, including successful transactions (TransactionResponse), session management (SessionResponse, SessionTokenResponse), tokenization (TokenizationResponse), and complex states like unresolved transactions (TransactionUnresolvedResponse) or incremental authorizations (IncrementalAuthorizationResponse). This structure allows the router to handle a wide array of connector responses uniformly, providing a standardized interface for downstream consumers and ensuring consistent error handling across different payment flows.", "queries": ["How to handle TransactionUnresolvedResponse in Rust hyperswitch", "Rust enum PaymentsResponseData structure hyperswitch", "IncrementalAuthorizationResponse status fields hyperswitch", "PaymentsResponseData SessionTokenResponse implementation"], "label": "Rust PaymentsResponseData Enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "PaymentsResponseData", "unit_type": "function", "num_lines": 62}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsIncrementalAuthorizationData\npub struct PaymentsIncrementalAuthorizationData {\n    pub total_amount: i64,\n    pub additional_amount: i64,\n    pub currency: storage_enums::Currency,\n    pub reason: Option<String>,\n    pub connector_transaction_id: String,\n    pub connector_meta: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "positive": "This struct, defined in the router request types, encapsulates the data payload for incremental authorization flows. It aggregates the original total amount, the new incremental amount, and the currency, alongside a specific reason for the authorization. It includes the connector transaction ID for tracking and optional connector metadata, serving as the input contract between the router and the specific payment connector during partial capture or incremental charge operations.", "queries": ["rust hyperswitch PaymentsIncrementalAuthorizationData struct definition", "how to handle incremental authorization data in hyperswitch router", "PaymentsIncrementalAuthorizationData fields total_amount additional_amount", "hyperswitch incremental authorization request types rust"], "label": "Incremental Authorization Data Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "PaymentsIncrementalAuthorizationData", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_id\n    async fn find_payment_intent_by_id(\n        &self,\n        id: &id_type::GlobalPaymentId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "positive": "This function retrieves a PaymentIntent entity from the storage layer based on its unique GlobalPaymentId. It is a core domain model operation used by the router to fetch payment state for processing, validation, or webhook dispatching. The function signature indicates it accepts a merchant key store and a storage scheme, implying it handles tenant-specific data isolation and potentially verifies cryptographic keys for the retrieved intent. It is a critical lookup primitive for the payment orchestration flow.", "queries": ["how to get payment intent by id in hyperswitch rust", "hyperswitch find_payment_intent_by_id implementation", "rust payment intent retrieval function signature", "hyperswitch domain models payment intent lookup"], "label": "payment intent retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "find_payment_intent_by_id", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Purchase\npub struct Purchase {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    order_channel: OrderChannel,\n    total_price: i64,\n    products: Vec<Products>,\n    shipments: Shipments,\n    currency: Option<Currency>,\n    total_shipping_cost: Option<i64>,\n    confirmation_email: Option<Email>,\n    confirmation_phone: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "positive": "The `Purchase` struct defines the data model for a purchase transaction within the Signifyd connector. It encapsulates financial details like total price and currency, logistical information including products and shipments, and contact verification data such as confirmation emails and phone numbers. This structure is likely used to normalize and validate incoming purchase data from the Signifyd API before processing or storing it in the Hyperswitch system, ensuring all necessary context for fraud detection and order fulfillment is captured.", "queries": ["how to define purchase data structure in signifyd rust connector", "rust struct for signifyd purchase transaction model", "hyperswitch signifyd purchase data fields definition", "signifyd purchase object rust serde deserialization"], "label": "Signifyd Purchase Data Model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "Purchase", "unit_type": "function", "num_lines": 15}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__business_profile.rs\n// SYMBOL: ProfileGeneralUpdate\npub struct ProfileGeneralUpdate {\n    pub profile_name: Option<String>,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: Option<bool>,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: Option<bool>,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: Option<bool>,\n    pub is_l2_l3_enabled: Option<bool>,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: Option<bool>,\n    pub is_auto_retries_enabled: Option<bool>,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub is_click_to_pay_enabled: Option<bool>,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: Option<bool>,\n    pub force_3ds_challenge: Option<bool>,\n    pub is_debit_routing_enabled: Option<bool>,\n    pub merchant_business_country: Option<api_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: Option<bool>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub is_external_vault_enabled: Option<common_enums::ExternalVaultEnabled>,\n    pub external_vault_connector_details: Option<ExternalVaultConnectorDetails>,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug)]", "positive": "The ProfileGeneralUpdate struct in hyperswitch_domain_models defines the mutable configuration state for a business profile. It encompasses a wide array of optional fields including payment response hashing, webhook details, routing algorithms (dynamic, debit, and payout), and connector configurations (authentication, tax, and external vault). This struct is used to update business settings, manage payment method preferences, and configure security parameters like 3DS challenge enforcement and network tokenization. It serves as the input payload for the business profile update endpoint, allowing merchants to customize the orchestration behavior of their payment flows.", "queries": ["rust struct definition for updating business profile settings", "hyperswitch ProfileGeneralUpdate fields for webhook configuration", "how to configure routing algorithms in ProfileGeneralUpdate", "rust struct ProfileGeneralUpdate authentication connector details"], "label": "Business Profile Update Configuration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__business_profile.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__business_profile.rs", "symbol": "ProfileGeneralUpdate", "unit_type": "function", "num_lines": 57}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: from\n    fn from(item: SignifydPaymentStatus) -> Self {\n        match item {\n            SignifydPaymentStatus::Accept => Self::Legit,\n            SignifydPaymentStatus::Reject => Self::Fraud,\n            SignifydPaymentStatus::Hold => Self::ManualReview,\n            SignifydPaymentStatus::Challenge | SignifydPaymentStatus::Credit => Self::Pending,\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This function maps a Signifyd payment status to the Hyperswitch internal fraud status. It handles mapping from 'Accept' to 'Legit', 'Reject' to 'Fraud', 'Hold' to 'ManualReview', and 'Challenge'/'Credit' to 'Pending'. This transformation is critical for the Signifyd connector to translate external fraud signals into the platform's internal domain model, ensuring accurate risk handling during payment orchestration.", "queries": ["How to convert Signifyd payment status to Hyperswitch fraud status", "Signifyd fraud status mapping function rust", "transform Signifyd payment status to internal fraud enum", "hyperswitch signifyd fraud status mapping"], "label": "Signifyd fraud status mapper", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "from", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: filter_payment_intent_by_constraints\n    async fn filter_payment_intent_by_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        filters: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "positive": "This function retrieves a list of PaymentIntent records from the database that match specific filtering criteria. It is a core domain operation used by the router and scheduler to query the state of payment flows, ensuring that only intents matching the provided processor_merchant_id and constraints (like status or amount) are returned. It integrates with the storage layer to handle different merchant storage schemes, providing a critical abstraction for querying the payment orchestration state.", "queries": ["How to filter payment intents by status in Rust?", "Rust hyperswitch filter_payment_intent_by_constraints implementation", "Query payment intents by merchant ID and constraints", "Hyperswitch domain models filter payment intents function"], "label": "Payment Intent Filtering", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "filter_payment_intent_by_constraints", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: sign\n    fn sign(\n        private_key_pem_str: &Secret<String>,\n        string_to_sign: &String,\n    ) -> Result<String, String> {\n        let rsa_pss_sha256_signer = RsaPssSha256;\n        let signature_bytes = rsa_pss_sha256_signer\n            .sign_message(\n                private_key_pem_str.peek().as_bytes(),\n                string_to_sign.as_bytes(),\n            )\n            .change_context(errors::ConnectorError::RequestEncodingFailed)\n            .map_err(|e| format!(\"Crypto operation failed: {e:?}\"))?;\n\n        Ok(STANDARD.encode(signature_bytes))\n    }\n}\n", "positive": "This function performs RSA-PSS SHA-256 signing for Amazon Pay requests. It accepts a PEM-formatted private key and a string to sign, generates a cryptographic signature using the RsaPssSha256 algorithm, and returns a Base64-encoded string. This is a core utility within the Amazon Pay connector implementation, ensuring request integrity and compliance with Amazon's cryptographic standards during payment processing.", "queries": ["rust function to sign amazon pay request with rsa pss sha256", "hyperswitch amazonpay connector sign method implementation", "how to generate signature for amazon pay api in rust", "rsa_pss_sha256 sign_message function amazonpay hyperswitch"], "label": "Amazon Pay RSA-PSS Signer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "sign", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: update_gateway_system_in_feature_metadata\npub fn update_gateway_system_in_feature_metadata<F: Clone, D>(\n    payment_data: &mut D,\n    gateway_system: GatewaySystem,\n) -> RouterResult<()>\nwhere\n    D: OperationSessionGetters<F> + OperationSessionSetters<F>,\n{\n    let mut payment_intent = payment_data.get_payment_intent().clone();\n\n    let existing_metadata = payment_intent.feature_metadata.as_ref();\n\n    let mut feature_metadata = existing_metadata\n        .and_then(|metadata| serde_json::from_value::<FeatureMetadata>(metadata.clone()).ok())\n        .unwrap_or_default();\n\n    feature_metadata.gateway_system = Some(gateway_system);\n\n    let updated_metadata = serde_json::to_value(feature_metadata)\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to serialize feature metadata\")?;\n\n    payment_intent.feature_metadata = Some(updated_metadata.clone());\n    payment_data.set_payment_intent(payment_intent);\n\n    Ok(())\n}\n", "positive": "This function updates the gateway system identifier within the feature metadata of a payment intent. It retrieves the existing metadata, deserializes it into a FeatureMetadata struct, updates the gateway_system field, and then serializes the updated metadata back into the payment intent. This ensures the orchestration layer correctly tracks which gateway system is handling a specific payment operation, which is critical for routing, debugging, and analytics within the Hyperswitch payment orchestration platform.", "queries": ["how to update gateway system in feature metadata rust", "hyperswitch update_gateway_system_in_feature_metadata implementation", "rust function to modify payment intent feature metadata gateway", "hyperswitch payment orchestration gateway system metadata update"], "label": "Update Gateway System in Metadata", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "update_gateway_system_in_feature_metadata", "unit_type": "function", "num_lines": 27}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = tokenex::TokenexAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                auth_headers::TOKENEX_ID.to_string(),\n                auth.tokenex_id.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_API_KEY.to_string(),\n                auth.api_key.expose().into_masked(),\n            ),\n            (\n                auth_headers::TOKENEX_SCHEME.to_string(),\n                auth_headers::TOKENEX_SCHEME_VALUE.to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n", "positive": "The `build_headers` function constructs the HTTP request headers required for authenticating and communicating with the Tokenex payment gateway. It dynamically retrieves the authentication type from the request context, specifically extracting the Tokenex ID and API Key from the `auth` object. The function ensures these sensitive credentials are masked before inclusion and adds a standard Content-Type header. This method is called by the Tokenex connector implementation to prepare the request payload for downstream API calls.", "queries": ["how to configure tokenex authentication headers in hyperswitch", "rust function to build tokenex api request headers", "hyperswitch tokenex connector build_headers implementation", "tokenex hyperswitch authentication header setup"], "label": "tokenex connector auth header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 29}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let http_method = self.get_http_method();\n\n        let canonical_uri: String =\n            self.get_url(req, connectors)?\n                .replacen(AMAZON_PAY_API_BASE_URL, \"\", 1);\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/json\".to_string().into(),\n            ),\n            (\n                HEADER_DATE.to_string(),\n                Utc::now()\n                    .format(\"%Y-%m-%dT%H:%M:%SZ\")\n                    .to_string()\n                    .into_masked(),\n            ),\n            (\n                HEADER_HOST.to_string(),\n                AMAZON_PAY_HOST.to_string().into_masked(),\n            ),\n            (HEADER_REGION.to_string(), \"na\".to_string().into_masked()),\n        ];\n\n        if http_method == Method::Post\n            && Self::get_last_segment(&canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            header.push((\n                HEADER_IDEMPOTENCY_KEY.to_string(),\n                req.connector_request_reference_id.clone().into_masked(),\n            ));\n        }\n\n        let hashed_payload = if http_method == Method::Get {\n            hex::encode(Sha256::digest(\"\".as_bytes()))\n        } else {\n            hex::encode(Sha256::digest(\n                self.get_request_body(req, connectors)?\n                    .get_inner_value()\n                    .expose()\n                    .as_bytes(),\n            ))\n        };\n\n        let authorization = self.create_authorization_header(\n            amazonpay::AmazonpayAuthType::try_from(&req.connector_auth_type)?,\n            &canonical_uri,\n            &http_method,\n            &hashed_payload,\n            &header,\n        );\n\n        header.push((\n            headers::AUTHORIZATION.to_string(),\n            authorization.clone().into_masked(),\n        ));\n\n        Ok(header)\n    }\n}\n", "positive": "This function constructs the HTTP request headers for Amazon Pay API interactions within the Hyperswitch payment orchestration platform. It dynamically generates a vector of tuples containing header names and values, handling critical security and idempotency requirements. It sets standard headers like Content-Type, Date, and Host, and conditionally injects an Idempotency Key for non-finalize POST requests. It calculates a SHA256 hash of the request body for signature generation and creates an Authorization header using the specific Amazon Pay authentication logic, ensuring secure and idempotent communication with the Amazon Pay connector.", "queries": ["how to generate amazon pay authorization header in rust hyperswitch", "hyperswitch amazonpay connector build_headers implementation", "rust function to create amazonpay api headers with idempotency", "hyperswitch amazonpay signature generation build_headers"], "label": "Amazon Pay header builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 71}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: check_ucs_availability\nasync fn check_ucs_availability(state: &SessionState) -> UcsAvailability {\n    let is_client_available = state.grpc_client.unified_connector_service_client.is_some();\n\n    let is_enabled = is_ucs_enabled(state, consts::UCS_ENABLED).await;\n\n    match (is_client_available, is_enabled) {\n        (true, true) => {\n            router_env::logger::debug!(\"UCS is available and enabled\");\n            UcsAvailability::Enabled\n        }\n        _ => {\n            router_env::logger::debug!(\n                \"UCS client is {} and UCS is {} in configuration\",\n                if is_client_available {\n                    \"available\"\n                } else {\n                    \"not available\"\n                },\n                if is_enabled { \"enabled\" } else { \"not enabled\" }\n            );\n            UcsAvailability::Disabled\n        }\n    }\n}\n\n/// Determines the connector integration type based on UCS configuration or on both", "positive": "This function checks the availability and enabled status of the Unified Connector Service (UCS) within the router's runtime state. It determines if the gRPC client is instantiated and if UCS is enabled via configuration. The result, `UcsAvailability::Enabled` or `Disabled`, is used to route payment flows to the appropriate backend service, ensuring the system only attempts to communicate with UCS when both the client connection and configuration are valid.", "queries": ["how to check if UCS is enabled in hyperswitch router", "hyperswitch unified connector service availability check function", "rust code for checking UCS client availability", "check_ucs_availability function implementation hyperswitch"], "label": "UCS availability check", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "check_ucs_availability", "unit_type": "function", "num_lines": 26}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let base_url = build_endpoint(self.base_url(connectors), &req.connector_meta_data)?;\n        Ok(format!(\"{base_url}/3ds/versioning\"))\n    }\n", "positive": "This function constructs the specific 3DS versioning endpoint URL for the Netcetera payment connector. It retrieves the base URL dynamically using the connector's metadata and appends the '/3ds/versioning' path segment. This is a critical step in the Pre-Authentication (PreAuthN) flow, ensuring the correct URL is used to interact with the Netcetera gateway for 3D Secure protocol configuration.", "queries": ["how to configure 3ds versioning url for netcetera connector", "netcetera connector get_url implementation hyperswitch", "hyperswitch netcetera 3ds endpoint configuration", "PreAuthNRouterData netcetera get_url function"], "label": "Netcetera 3DS URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "The `build_request` function constructs the HTTP request payload for a Sift payment authorization. It uses the `PaymentsAuthorizeType` trait to dynamically generate the URL, headers, and request body based on the provided router data and connector configuration. This method is central to the Sift connector's integration, ensuring the correct API call is made with all necessary context for fraud detection.", "queries": ["how to build sift authorize request rust hyperswitch", "hyperswitch sift connector build_request function implementation", "rust code for constructing sift payments authorize request", "hyperswitch sift authorization request builder"], "label": "Sift authorize request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_connector_response_reference_id\n    pub fn get_connector_response_reference_id(&self) -> Option<String> {\n        match self {\n            Self::Success {\n                connector_response_reference_id,\n                ..\n            } => connector_response_reference_id.clone(),\n            Self::Error { .. } => None,\n        }\n    }\n}", "positive": "This method retrieves the unique reference identifier associated with a successful payment connector response. It is part of the `RouterResponseTypes` enum, which models the outcome of a payment orchestration request. The function performs a pattern match on the enum variant: if the response is a `Success` variant, it returns the `connector_response_reference_id` string; otherwise, for `Error` variants, it returns `None`. This is critical for downstream reconciliation and tracking the specific transaction reference returned by the external payment gateway.", "queries": ["how to get connector response reference id from router response", "rust hyperswitch get_connector_response_reference_id", "extract reference id from router response types success", "hyperswitch router response types enum success reference id"], "label": "Router response reference ID getter", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_response_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "symbol": "get_connector_response_reference_id", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: filter_refund_by_constraints\n    async fn filter_refund_by_constraints(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n        limit: i64,\n        offset: i64,\n    ) -> CustomResult<Vec<diesel_models::refund::Refund>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "positive": "This function retrieves a paginated list of refunds from the database based on merchant-specific constraints. It filters results using the provided `RefundListConstraints` struct, applies the appropriate storage scheme (e.g., tenant isolation), and returns a vector of `Refund` diesel models. It is a core component of the router's refund retrieval logic, handling the mapping between API request parameters and database queries for the `/refunds` and `/v2/refunds` endpoints.", "queries": ["how to filter refunds by status and amount in hyperswitch router", "hyperswitch router refund list constraints implementation", "rust function to query refunds by merchant id and pagination", "hyperswitch db refund filtering logic storage scheme"], "label": "refund list filtering logic", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "filter_refund_by_constraints", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_by_merchant_connector_account_merchant_id_merchant_connector_id\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]", "positive": "This function retrieves a specific MerchantConnectorAccount entity by its unique identifiers: merchant_id and merchant_connector_id. It acts as a data access layer method, delegating the actual database query to the internal router_store. It accepts a MerchantKeyStore for cryptographic operations and returns a domain::MerchantConnectorAccount, handling errors via CustomResult. This is a core lookup method for resolving account configurations during payment processing.", "queries": ["how to find merchant connector account by id rust hyperswitch", "hyperswitch merchant connector account lookup function implementation", "rust code for finding merchant connector account by merchant id", "hyperswitch storage layer merchant connector account retrieval"], "label": "merchant connector account lookup function", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "find_by_merchant_connector_account_merchant_id_merchant_connector_id", "unit_type": "function", "num_lines": 17}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: get_event_data\n    pub fn get_event_data(&self) -> Option<String> {\n        self.href\n            .clone()\n            .expose()\n            .rsplit_once('/')\n            .map(|h| h.1.to_string())\n    }\n}", "positive": "The `get_event_data` function in the Worldpay Modular connector's response transformer extracts the final segment of a URL string. It is designed to parse the `href` field, which typically contains a full API response path, and isolate the specific event identifier or resource ID. This utility is crucial for downstream processing, such as mapping raw webhook payloads to internal Hyperswitch event models or generating unique identifiers for logging and tracking.", "queries": ["How do I extract the event ID from a Worldpay webhook response URL?", "Rust function to get last part of URL string from Worldpay connector", "Worldpay Modular connector get_event_data implementation details", "Hyperswitch Worldpay response transformer URL parsing logic"], "label": "Worldpay URL segment extractor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "get_event_data", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: get_wallet_data\n    pub fn get_wallet_data(&self) -> Option<&WalletData> {\n        if let Self::Wallet(wallet_data) = self {\n            Some(wallet_data)\n        } else {\n            None\n        }\n    }\n", "positive": "This function retrieves the wallet-specific data payload from the PaymentMethodData enum variant. It is a critical accessor for the 'Wallet' variant, allowing downstream logic to extract sensitive financial details or configuration parameters required for processing specific wallet-based transactions. It is typically invoked within the router or domain models to validate wallet eligibility or retrieve specific wallet parameters before dispatching a payment request to a connector.", "queries": ["How do I access wallet data from PaymentMethodData?", "Rust hyperswitch get_wallet_data function implementation", "Retrieve wallet configuration from PaymentMethodData enum", "hyperswitch domain models wallet data accessor"], "label": "Wallet data accessor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "get_wallet_data", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: SubError\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "The `SubError` struct defines a granular error representation used within the payment orchestration platform, specifically for payouts. It encapsulates a machine-readable error code, a human-readable message, and optional context fields like `path` and `field` to pinpoint the exact location of validation or processing failures. This structure is utilized by the Wise connector transformer to map specific API error responses into the internal domain model, ensuring precise error tracking and debugging during payout transactions.", "queries": ["Rust SubError struct definition hyperswitch", "hyperswitch payout error handling SubError", "Wise connector SubError mapping Rust", "SubError struct fields code message path"], "label": "SubError struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "SubError", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = payone::PayoneAuthType::try_from(&req.connector_auth_type)?;\n        let http_method = self.get_http_method().to_string();\n        let content_type = Self::get_content_type(self);\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let date_header = get_formatted_date_time!(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\"\n        )?;\n        let path: String = url.replace(base_url, \"/\");\n        let authorization_header: String = self.generate_signature(\n            auth,\n            http_method,\n            path,\n            content_type.to_string(),\n            date_header.clone(),\n        )?;\n        let headers = vec![\n            (DATE.to_string(), date_header.to_string().into()),\n            (\n                AUTHORIZATION.to_string(),\n                authorization_header.to_string().into(),\n            ),\n        ];\n\n        Ok(headers)\n    }\n}\n", "positive": "This function constructs the HTTP headers required for Payone API authentication and communication. It dynamically generates a signature based on the HTTP method, request path, content type, and a GMT-formatted timestamp. The resulting headers, including Date and Authorization, are returned to be applied to the outgoing request payload.", "queries": ["how to generate authorization header for payone api in rust hyperswitch", "hyperswitch payone connector signature generation logic", "rust function to build payone api headers hyperswitch", "hyperswitch payone build_headers implementation details"], "label": "Payone API header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 33}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "positive": "This function defines the URL retrieval mechanism for the Thunes payment connector within the Hyperswitch payment orchestration platform. It is part of the `PaymentsAuthorizeRouterData` flow, responsible for dynamically constructing the API endpoint URL required to communicate with the Thunes gateway during the authorization process. Currently, this method is a stub that returns a `NotImplemented` error, indicating that the specific URL logic for Thunes integration has not yet been implemented in the Rust source code.", "queries": ["thunes connector get_url rust hyperswitch", "hyperswitch thunes payment gateway url configuration", "rust function get_url not implemented thunes", "PaymentsAuthorizeRouterData thunes connector implementation"], "label": "Thunes connector URL stub", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function, `get_error_response`, serves as a standardized error handling method within the Authipay connector implementation. It accepts an HTTP `Response` object and an optional `ConnectorEvent` builder to construct a consistent `ErrorResponse`. Crucially, it delegates the actual logic to `build_error_response`, allowing the connector to map raw HTTP status codes and error bodies into a unified internal error format. This ensures that failures during payment processing or authentication are captured and propagated correctly to the router, maintaining the integrity of the payment orchestration flow.", "queries": ["rust hyperswitch authipay connector error handling get_error_response", "how to implement error response builder in hyperswitch authipay connector", "hyperswitch authipay rust function get_error_response signature", "authipay connector hyperswitch build_error_response implementation"], "label": "Authipay error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_globlepay_query_params\nfn get_globlepay_query_params(\n    connector_auth_type: &ConnectorAuthType,\n) -> CustomResult<String, errors::ConnectorError> {\n    let auth_type = globepay::GlobepayAuthType::try_from(connector_auth_type)?;\n    let time = (OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000).to_string();\n    let nonce_str = rand::distributions::Alphanumeric.sample_string(&mut rand::thread_rng(), 12);\n    let valid_string = format!(\n        \"{}&{time}&{nonce_str}&{}\",\n        auth_type.partner_code.expose(),\n        auth_type.credential_code.expose()\n    );\n    let digest = crypto::Sha256\n        .generate_digest(valid_string.as_bytes())\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"error encoding the query params\")?;\n    let sign = encode(digest).to_lowercase();\n    let param = format!(\"?sign={sign}&time={time}&nonce_str={nonce_str}\");\n    Ok(param)\n}\n", "positive": "This function generates the authentication query parameters required for Globlepay API requests. It constructs a valid string by combining the partner code, current UTC timestamp (milliseconds), a random 12-character alphanumeric nonce, and the credential code. It then computes a SHA-256 digest of this string, encodes it to Base64, and converts it to lowercase to create the final 'sign' parameter. This logic is critical for securing Globlepay connector integrations within the Hyperswitch payment orchestration platform.", "queries": ["how to generate Globlepay authentication signature query params", "Rust function for Globlepay API signature generation", "hyperswitch Globlepay connector auth query params implementation", "Globlepay API signature calculation using SHA256 and nonce"], "label": "Globlepay auth signature generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "get_globlepay_query_params", "unit_type": "function", "num_lines": 20}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: get_store_interface_map\n    pub async fn get_store_interface_map(\n        &self,\n        storage_impl: &app::StorageImpl,\n        conf: &configs::Settings,\n        cache_store: Arc<storage_impl::redis::RedisStore>,\n        testable: bool,\n    ) -> HashMap<id_type::TenantId, Box<dyn app::StorageInterface>> {\n        #[allow(clippy::expect_used)]\n        let event_handler = conf\n            .events\n            .get_event_handler()\n            .await\n            .expect(\"Failed to create event handler\");\n        futures::future::join_all(self.0.iter().map(|(tenant_name, tenant)| async {\n            let store = Box::pin(AppState::get_store_interface(\n                storage_impl,\n                &event_handler,\n                conf,\n                tenant,\n                cache_store.clone(),\n                testable,\n            ))\n            .await\n            .get_storage_interface();\n            (tenant_name.clone(), store)\n        }))\n        .await\n        .into_iter()\n        .collect()\n    }\n    /// # Panics\n    ///\n    /// Panics if Failed to create event handler", "positive": "This function initializes a multi-tenant storage interface map by asynchronously instantiating storage adapters for each configured tenant. It utilizes `futures::future::join_all` to parallelize the creation of `Box<dyn app::StorageInterface>` instances, ensuring high throughput during system startup. The function relies on a shared `event_handler` derived from the configuration and a `RedisStore` for caching. It is a critical entry point for the Router crate, responsible for mapping tenant identifiers to their specific storage implementations before request routing.", "queries": ["how to initialize storage interfaces for multiple tenants in hyperswitch router", "hyperswitch router get_store_interface_map implementation details", "async initialization of storage adapters in hyperswitch router", "how does router crate handle tenant storage mapping"], "label": "Multi-tenant storage initialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "get_store_interface_map", "unit_type": "function", "num_lines": 33}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` function in the Authipay connector implementation serves as the primary interface for constructing the HTTP request headers required to authenticate outgoing payment authorization requests to the Authipay gateway. It acts as a wrapper around the internal `build_headers` method, ensuring that sensitive data is properly masked before transmission. This function is critical for the connector's integration, as it dynamically populates headers based on the incoming `PaymentsAuthorizeRouterData` context and the available connector configurations, handling potential errors during the header generation process.", "queries": ["rust hyperswitch authipay connector get_headers function implementation", "how to configure authipay payment gateway headers in hyperswitch rust", "hyperswitch authipay connector authentication header generation code", "rust hyperswitch PaymentsAuthorizeRouterData authipay get_headers"], "label": "Authipay connector header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__authipay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = cybersource::CybersourceZeroMandateRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function constructs the JSON payload for a CyberSource Zero Mandate request by deserializing the incoming `SetupMandateRouterData` into a `CybersourceZeroMandateRequest`. It is a critical transformation step within the CyberSource connector's request pipeline, ensuring the orchestration platform correctly formats mandate setup instructions for the payment gateway. The function returns a `RequestContent::Json` wrapper, enabling the router to transmit the mandate payload securely to the external payment provider.", "queries": ["how to format CyberSource mandate setup request in hyperswitch", "CybersourceZeroMandateRequest struct definition hyperswitch", "hyperswitch connector get_request_body implementation", "setup mandate router data cybersource hyperswitch"], "label": "CyberSource mandate request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 9}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: cybersource::CybersourcePaymentsResponse = res\n            .response\n            .parse_struct(\"CybersourceSetupMandatesResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the Cybersource connector for Setup Mandate routing. It deserializes the raw response into a `CybersourcePaymentsResponse` struct, logs the payload for debugging, and constructs a `RouterData` object containing the parsed response, original request data, and HTTP status code. It is a critical deserialization and validation step within the `handle_response` lifecycle of the `CybersourcePayments` connector implementation.", "queries": ["rust hyperswitch cybersource handle_response function implementation", "how to parse cybersource setup mandate response in hyperswitch", "hyperswitch connector cybersource handle_response deserialization", "cybersource setup mandate router data hyperswitch rust"], "label": "Cybersource Setup Mandate Response Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &AccessTokenAuthenticationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}/personal/v5/authorize\",\n            self.base_url(connectors)\n        ))\n    }\n", "positive": "This function constructs the authorization endpoint URL for the Nordea payment connector. It retrieves the base URL dynamically via `self.base_url(connectors)` and appends the specific Nordea API path `/personal/v5/authorize`. It is a critical helper method used within the Nordea connector's request handling logic to ensure the correct API endpoint is targeted for initiating payment authorization flows.", "queries": ["how to get authorization url for nordea connector", "nordea connector get_url function implementation", "hyperswitch nordea authorize endpoint url", "nordea personal v5 authorize url hyperswitch"], "label": "Nordea authorize URL construction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 11}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: get_values_by_key\n    fn get_values_by_key(\n        &self,\n        key: &<Self::Value as cgraph::ValueNode>::Key,\n    ) -> Option<Vec<Self::Value>> {\n        self.keywise_values\n            .get(key)\n            .map(|set| set.iter().cloned().collect())\n    }\n}\n", "positive": "This function retrieves a collection of values associated with a specific key from the internal `keywise_values` map. It is a generic method defined within a trait context, likely used to fetch related entities (e.g., payment methods, customers, or routing rules) by a unique identifier. The implementation returns an Option of a Vec, ensuring safe handling of missing keys by returning None instead of panicking, and allows for cloning the retrieved values into a new vector.", "queries": ["rust hyperswitch euclid get_values_by_key implementation", "how to retrieve values by key in euclid crate", "hyperswitch euclid graph keywise_values map", "rust trait method get_values_by_key example"], "label": "euclid graph key retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "get_values_by_key", "unit_type": "function", "num_lines": 10}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: ApplePayFlow\npub enum ApplePayFlow {\n    // Either Merchant provided certificates i.e decryption by hyperswitch or Hyperswitch certificates i.e simplified flow\n    // decryption is performed in hyperswitch\n    DecryptAtApplication(api_models::payments::PaymentProcessingDetails),\n    // decryption by connector or predecrypted token\n    SkipDecryption,\n}\n", "positive": "The ApplePayFlow enum defines the two distinct processing strategies for Apple Pay transactions within the Hyperswitch payment orchestration platform. The DecryptAtApplication variant initiates a secure flow where the merchant-provided certificate is used to decrypt payment details directly by Hyperswitch, ensuring data privacy. The SkipDecryption variant represents a simplified, pre-processed flow where the token is already decrypted or handled by the connector, bypassing Hyperswitch's decryption step. This enum is central to the payment method data handling logic, determining how sensitive transaction information is processed before routing to the payment processor.", "queries": ["How to configure Apple Pay to decrypt tokens at the application level in Rust?", "What is the difference between DecryptAtApplication and SkipDecryption in ApplePayFlow?", "Rust enum ApplePayFlow usage for handling pre-decrypted Apple Pay tokens", "Hyperswitch Apple Pay token decryption configuration options"], "label": "Apple Pay token processing strategy", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "ApplePayFlow", "unit_type": "function", "num_lines": 8}
{"split": "train", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: should_call_unified_connector_service_for_webhooks\npub async fn should_call_unified_connector_service_for_webhooks(\n    state: &SessionState,\n    processor: &Processor,\n    connector_name: &str,\n) -> RouterResult<ExecutionPath> {\n    // Extract context information\n    let merchant_id = processor.get_account().get_id().get_string_repr();\n\n    let connector_enum = Connector::from_str(connector_name)\n        .change_context(errors::ApiErrorResponse::IncorrectConnectorNameGiven)\n        .attach_printable_lazy(|| format!(\"Failed to parse connector name: {}\", connector_name))?;\n\n    let flow_name = \"Webhooks\";\n\n    // Check UCS availability using idiomatic helper\n    let ucs_availability = check_ucs_availability(state).await;\n\n    // Build rollout keys - webhooks don't use payment method, so use a simplified key format\n    let rollout_key = format!(\n        \"{}_{}_{}_{}\",\n        consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    // Determine connector integration type\n    let connector_integration_type =\n        determine_connector_integration_type(state, connector_enum).await?;\n\n    // For webhooks, there is no previous gateway system to consider (webhooks are stateless)\n    let previous_gateway = None;\n\n    // Check both rollout keys to determine priority based on shadow percentage\n    let rollout_result = should_execute_based_on_rollout(state, &rollout_key).await?;\n\n    // Use the same decision logic as payments, with no call_connector_action to consider\n    let (gateway_system, execution_path) = if ucs_availability == UcsAvailability::Disabled {\n        router_env::logger::debug!(\"UCS is disabled for webhooks, using Direct gateway\");\n        (GatewaySystem::Direct, ExecutionPath::Direct)\n    } else {\n        // UCS is enabled, use decide function with no previous gateway for webhooks\n        decide_execution_path(\n            connector_integration_type,\n            previous_gateway,\n            rollout_result.execution_mode,\n        )?\n    };\n\n    router_env::logger::info!(\n        \"Webhook gateway decision: gateway={:?}, execution_path={:?} - merchant_id={}, connector={}, flow={}\",\n        gateway_system,\n        execution_path,\n        merchant_id,\n        connector_name,\n        flow_name\n    );\n\n    Ok(execution_path)\n}\n", "positive": "This function determines the execution path for webhook events within the Unified Connector Service (UCS) architecture. It evaluates UCS availability, merchant-specific rollout configurations, and connector integration types to decide whether to route webhooks through the Unified Gateway or directly to the connector. Crucially, it handles the stateless nature of webhooks by omitting previous gateway checks and uses a simplified rollout key format that excludes payment method details. The result dictates the `ExecutionPath` returned to the router, ensuring correct event handling based on current feature flags and system state.", "queries": ["how to configure webhook routing in hyperswitch router", "rust function for webhook execution path decision hyperswitch", "hyperswitch router should_call_unified_connector_service_for_webhooks", "how does hyperswitch decide between direct and unified gateway for webhooks"], "label": "webhook execution path decision logic", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "should_call_unified_connector_service_for_webhooks", "unit_type": "function", "num_lines": 61}
