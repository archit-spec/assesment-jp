[{"query": "rust hyperswitch find payment intent by merchant reference id and profile id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_merchant_reference_id_profile_id\n    async fn find_payment_intent_by_merchant_reference_id_profile_id(\n        &self,\n        merchant_reference_id: &id_type::PaymentReferenceId,\n        profile_id: &id_type::ProfileId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: &common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v2\")]", "function_name": "find_payment_intent_by_merchant_reference_id_profile_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent lookup by reference"}, {"query": "hyperswitch domain models how to get payment intent by merchant reference", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_merchant_reference_id_profile_id\n    async fn find_payment_intent_by_merchant_reference_id_profile_id(\n        &self,\n        merchant_reference_id: &id_type::PaymentReferenceId,\n        profile_id: &id_type::ProfileId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: &common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v2\")]", "function_name": "find_payment_intent_by_merchant_reference_id_profile_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent lookup by reference"}, {"query": "rust hyperswitch payment intent lookup function signature merchant reference", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_merchant_reference_id_profile_id\n    async fn find_payment_intent_by_merchant_reference_id_profile_id(\n        &self,\n        merchant_reference_id: &id_type::PaymentReferenceId,\n        profile_id: &id_type::ProfileId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: &common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v2\")]", "function_name": "find_payment_intent_by_merchant_reference_id_profile_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent lookup by reference"}, {"query": "hyperswitch domain models retrieve payment intent by profile id reference", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_merchant_reference_id_profile_id\n    async fn find_payment_intent_by_merchant_reference_id_profile_id(\n        &self,\n        merchant_reference_id: &id_type::PaymentReferenceId,\n        profile_id: &id_type::ProfileId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: &common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v2\")]", "function_name": "find_payment_intent_by_merchant_reference_id_profile_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "unit_type": "function", "label": "PaymentIntent lookup by reference"}, {"query": "how to configure tokenex connector authentication headers in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "tokenex connector header generation"}, {"query": "tokenex get_headers function implementation rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "tokenex connector header generation"}, {"query": "hyperswitch tokenex connector header generation build_headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "tokenex connector header generation"}, {"query": "configure tokenex api keys hyperswitch tokenex connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "tokenex connector header generation"}, {"query": "how to get refund status counts for a specific merchant", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_refund_status_with_count\n    async fn get_refund_status_with_count(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        profile_id_list: Option<Vec<common_utils::id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<(common_enums::RefundStatus, i64)>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "get_refund_status_with_count", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund status count retrieval"}, {"query": "rust function to count refunds by status hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_refund_status_with_count\n    async fn get_refund_status_with_count(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        profile_id_list: Option<Vec<common_utils::id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<(common_enums::RefundStatus, i64)>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "get_refund_status_with_count", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund status count retrieval"}, {"query": "get_refund_status_with_count implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_refund_status_with_count\n    async fn get_refund_status_with_count(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        profile_id_list: Option<Vec<common_utils::id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<(common_enums::RefundStatus, i64)>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "get_refund_status_with_count", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund status count retrieval"}, {"query": "hyperswitch router refund status aggregation query", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_refund_status_with_count\n    async fn get_refund_status_with_count(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        profile_id_list: Option<Vec<common_utils::id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<(common_enums::RefundStatus, i64)>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "function_name": "get_refund_status_with_count", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund status count retrieval"}, {"query": "how to generate signature for cybersource api request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let cybersource_req = self.get_request_body(req, connectors)?;\n        let auth = cybersource::CybersourceAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.cybersource.base_url.as_str();\n        let cybersource_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = cybersource_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(cybersource_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource signature generation"}, {"query": "rust hyperswitch cybersource build_headers function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let cybersource_req = self.get_request_body(req, connectors)?;\n        let auth = cybersource::CybersourceAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.cybersource.base_url.as_str();\n        let cybersource_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = cybersource_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(cybersource_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource signature generation"}, {"query": "cybersource authentication header generation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let cybersource_req = self.get_request_body(req, connectors)?;\n        let auth = cybersource::CybersourceAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.cybersource.base_url.as_str();\n        let cybersource_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = cybersource_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(cybersource_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource signature generation"}, {"query": "hyperswitch connector cybersource signature calculation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let cybersource_req = self.get_request_body(req, connectors)?;\n        let auth = cybersource::CybersourceAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.cybersource.base_url.as_str();\n        let cybersource_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = cybersource_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(cybersource_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource signature generation"}, {"query": "how to build gpayments endpoint url rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = gpayments::GpaymentsMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl\n    ConnectorIntegration<\n        Authentication,\n        ConnectorAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "function_name": "build_endpoint", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments endpoint builder"}, {"query": "gpayments connector metadata endpoint_prefix hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = gpayments::GpaymentsMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl\n    ConnectorIntegration<\n        Authentication,\n        ConnectorAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "function_name": "build_endpoint", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments endpoint builder"}, {"query": "hyperswitch gpayments build_endpoint function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = gpayments::GpaymentsMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl\n    ConnectorIntegration<\n        Authentication,\n        ConnectorAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "function_name": "build_endpoint", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments endpoint builder"}, {"query": "rust hyperswitch gpayments connector url construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = gpayments::GpaymentsMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl\n    ConnectorIntegration<\n        Authentication,\n        ConnectorAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "function_name": "build_endpoint", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "gpayments endpoint builder"}, {"query": "how to handle finix connector errors in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix error response handler"}, {"query": "implement custom error response builder for hyperswitch connectors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix error response handler"}, {"query": "rust hyperswitch finix error handling get_error_response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix error response handler"}, {"query": "hyperswitch connector error response standardization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix error response handler"}, {"query": "how to implement validate_connector_against_payment_request in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::ManualMultiple | enums::CaptureMethod::Scheduled => Err(\n                crate::utils::construct_not_supported_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "function_name": "validate_connector_against_payment_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "connector capture method validation"}, {"query": "hyperswitch connector capture method validation error ManualMultiple", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::ManualMultiple | enums::CaptureMethod::Scheduled => Err(\n                crate::utils::construct_not_supported_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "function_name": "validate_connector_against_payment_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "connector capture method validation"}, {"query": "rust enum match validate_connector_against_payment_request hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::ManualMultiple | enums::CaptureMethod::Scheduled => Err(\n                crate::utils::construct_not_supported_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "function_name": "validate_connector_against_payment_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "connector capture method validation"}, {"query": "hyperswitch connector not supported error capture method Scheduled", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::ManualMultiple | enums::CaptureMethod::Scheduled => Err(\n                crate::utils::construct_not_supported_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "function_name": "validate_connector_against_payment_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "connector capture method validation"}, {"query": "how to build gigadat authorize request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "gigadat authorize request builder"}, {"query": "gigadat connector build_request rust implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "gigadat authorize request builder"}, {"query": "rust gigadat payments authorize request builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "gigadat authorize request builder"}, {"query": "hyperswitch gigadat connector request construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "gigadat authorize request builder"}, {"query": "Rust struct definition for Wise payout address details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseAddressDetails\npub struct WiseAddressDetails {\n    country: Option<CountryAlpha2>,\n    country_code: Option<CountryAlpha2>,\n    first_line: Option<Secret<String>>,\n    post_code: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n}\n\n#[allow(dead_code)]\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WiseAddressDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout address model"}, {"query": "hyperswitch Wise connector address transformation model", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseAddressDetails\npub struct WiseAddressDetails {\n    country: Option<CountryAlpha2>,\n    country_code: Option<CountryAlpha2>,\n    first_line: Option<Secret<String>>,\n    post_code: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n}\n\n#[allow(dead_code)]\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WiseAddressDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout address model"}, {"query": "how to handle sensitive address fields in Wise payouts", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseAddressDetails\npub struct WiseAddressDetails {\n    country: Option<CountryAlpha2>,\n    country_code: Option<CountryAlpha2>,\n    first_line: Option<Secret<String>>,\n    post_code: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n}\n\n#[allow(dead_code)]\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WiseAddressDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout address model"}, {"query": "WiseAddressDetails struct implementation in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseAddressDetails\npub struct WiseAddressDetails {\n    country: Option<CountryAlpha2>,\n    country_code: Option<CountryAlpha2>,\n    first_line: Option<Secret<String>>,\n    post_code: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n}\n\n#[allow(dead_code)]\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WiseAddressDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise payout address model"}, {"query": "how to find merchant connector account by merchant id and label", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_label\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_merchant_id_connector_label", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "rust hyperswitch find_merchant_connector_account implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_label\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_merchant_id_connector_label", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "merchant connector account lookup function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_label\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_merchant_id_connector_label", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "hyperswitch router store merchant connector account fetch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_label\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "function_name": "find_merchant_connector_account_by_merchant_id_connector_label", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account lookup"}, {"query": "how to handle mandate validation in Sift connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift mandate validation logic"}, {"query": "implement validate_mandate_payment for Sift", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift mandate validation logic"}, {"query": "Sift connector mandate payment method support", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift mandate validation logic"}, {"query": "error handling for unsupported payment types in Sift", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift mandate validation logic"}, {"query": "rust hypersift connector error response builder trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector error response builder"}, {"query": "how to handle sift payment gateway errors in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector error response builder"}, {"query": "hyperswitch sift connector get_error_response method signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector error response builder"}, {"query": "rust connector trait error handling hypersift integration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector error response builder"}, {"query": "SignifydPaymentStatus Rust enum usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentStatus\npub enum SignifydPaymentStatus {\n    Accept,\n    Challenge,\n    Credit,\n    Hold,\n    Reject,\n}\n", "function_name": "SignifydPaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud status enum"}, {"query": "hyperswitch signifyd fraud status codes", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentStatus\npub enum SignifydPaymentStatus {\n    Accept,\n    Challenge,\n    Credit,\n    Hold,\n    Reject,\n}\n", "function_name": "SignifydPaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud status enum"}, {"query": "Signifyd API response mapping Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentStatus\npub enum SignifydPaymentStatus {\n    Accept,\n    Challenge,\n    Credit,\n    Hold,\n    Reject,\n}\n", "function_name": "SignifydPaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud status enum"}, {"query": "SignifydPaymentStatus accept challenge hold reject", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentStatus\npub enum SignifydPaymentStatus {\n    Accept,\n    Challenge,\n    Credit,\n    Hold,\n    Reject,\n}\n", "function_name": "SignifydPaymentStatus", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd fraud status enum"}, {"query": "how to configure merchant connector account details in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: MerchantConnectorAccount\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "MerchantConnectorAccount", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account configuration struct"}, {"query": "rust struct definition merchant connector account hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: MerchantConnectorAccount\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "MerchantConnectorAccount", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account configuration struct"}, {"query": "hyperswitch merchant connector account webhook configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: MerchantConnectorAccount\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "MerchantConnectorAccount", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account configuration struct"}, {"query": "merchant connector account encryption hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: MerchantConnectorAccount\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "MerchantConnectorAccount", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant connector account configuration struct"}, {"query": "how to build request for Wells Fargo mandate setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo mandate setup request builder"}, {"query": "rust function to create HTTP request for Wells Fargo SetupMandateType", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo mandate setup request builder"}, {"query": "hyperswitch Wells Fargo connector build_request implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo mandate setup request builder"}, {"query": "SetupMandateRouterData request builder Wells Fargo", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo mandate setup request builder"}, {"query": "How to get merchant connector account from payment intent id in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_object_reference_id\npub async fn get_mca_from_object_reference_id(\n    state: &SessionState,\n    object_reference_id: webhooks::ObjectReferenceId,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let default_profile_id = platform\n        .get_processor()\n        .get_account()\n        .default_profile\n        .as_ref();\n\n    #[cfg(feature = \"v2\")]\n    let default_profile_id = Option::<&String>::None;\n\n    match default_profile_id {\n        Some(profile_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                let _db = db;\n                let _profile_id = profile_id;\n                todo!()\n            }\n        }\n        _ => match object_reference_id {\n            webhooks::ObjectReferenceId::PaymentId(payment_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_payment_id_type(state, payment_id_type, platform)\n                        .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::RefundId(refund_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_refund_id_type(\n                        state,\n                        refund_id_type,\n                        platform,\n                        connector_name,\n                    )\n                    .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::Manda\n\n... [truncated 544 chars] ...\n\n           }\n            webhooks::ObjectReferenceId::SubscriptionId(subscription_id_type) => {\n                #[cfg(feature = \"v1\")]\n                {\n                    let subscription_state = state.clone().into();\n                    let subscription_handler =\n                        SubscriptionHandler::new(&subscription_state, platform);\n                    let mut subscription_with_handler = subscription_handler\n                        .find_subscription(subscription_id_type)\n                        .await?;\n\n                    subscription_with_handler.get_mca(connector_name).await\n                }\n                #[cfg(feature = \"v2\")]\n                {\n                    let _db = db;\n                    todo!()\n                }\n            }\n            #[cfg(feature = \"payouts\")]\n            webhooks::ObjectReferenceId::PayoutId(payout_id_type) => {\n                get_mca_from_payout_attempt(state, platform, payout_id_type, connector_name).await\n            }\n        },\n    }\n}\n\n// validate json format for the error", "function_name": "get_mca_from_object_reference_id", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router MCA resolution from object ID"}, {"query": "hyperswitch router find_mca_from_object_reference_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_object_reference_id\npub async fn get_mca_from_object_reference_id(\n    state: &SessionState,\n    object_reference_id: webhooks::ObjectReferenceId,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let default_profile_id = platform\n        .get_processor()\n        .get_account()\n        .default_profile\n        .as_ref();\n\n    #[cfg(feature = \"v2\")]\n    let default_profile_id = Option::<&String>::None;\n\n    match default_profile_id {\n        Some(profile_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                let _db = db;\n                let _profile_id = profile_id;\n                todo!()\n            }\n        }\n        _ => match object_reference_id {\n            webhooks::ObjectReferenceId::PaymentId(payment_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_payment_id_type(state, payment_id_type, platform)\n                        .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::RefundId(refund_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_refund_id_type(\n                        state,\n                        refund_id_type,\n                        platform,\n                        connector_name,\n                    )\n                    .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::Manda\n\n... [truncated 544 chars] ...\n\n           }\n            webhooks::ObjectReferenceId::SubscriptionId(subscription_id_type) => {\n                #[cfg(feature = \"v1\")]\n                {\n                    let subscription_state = state.clone().into();\n                    let subscription_handler =\n                        SubscriptionHandler::new(&subscription_state, platform);\n                    let mut subscription_with_handler = subscription_handler\n                        .find_subscription(subscription_id_type)\n                        .await?;\n\n                    subscription_with_handler.get_mca(connector_name).await\n                }\n                #[cfg(feature = \"v2\")]\n                {\n                    let _db = db;\n                    todo!()\n                }\n            }\n            #[cfg(feature = \"payouts\")]\n            webhooks::ObjectReferenceId::PayoutId(payout_id_type) => {\n                get_mca_from_payout_attempt(state, platform, payout_id_type, connector_name).await\n            }\n        },\n    }\n}\n\n// validate json format for the error", "function_name": "get_mca_from_object_reference_id", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router MCA resolution from object ID"}, {"query": "rust function to resolve merchant account from webhook object reference id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_object_reference_id\npub async fn get_mca_from_object_reference_id(\n    state: &SessionState,\n    object_reference_id: webhooks::ObjectReferenceId,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let default_profile_id = platform\n        .get_processor()\n        .get_account()\n        .default_profile\n        .as_ref();\n\n    #[cfg(feature = \"v2\")]\n    let default_profile_id = Option::<&String>::None;\n\n    match default_profile_id {\n        Some(profile_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                let _db = db;\n                let _profile_id = profile_id;\n                todo!()\n            }\n        }\n        _ => match object_reference_id {\n            webhooks::ObjectReferenceId::PaymentId(payment_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_payment_id_type(state, payment_id_type, platform)\n                        .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::RefundId(refund_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_refund_id_type(\n                        state,\n                        refund_id_type,\n                        platform,\n                        connector_name,\n                    )\n                    .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::Manda\n\n... [truncated 544 chars] ...\n\n           }\n            webhooks::ObjectReferenceId::SubscriptionId(subscription_id_type) => {\n                #[cfg(feature = \"v1\")]\n                {\n                    let subscription_state = state.clone().into();\n                    let subscription_handler =\n                        SubscriptionHandler::new(&subscription_state, platform);\n                    let mut subscription_with_handler = subscription_handler\n                        .find_subscription(subscription_id_type)\n                        .await?;\n\n                    subscription_with_handler.get_mca(connector_name).await\n                }\n                #[cfg(feature = \"v2\")]\n                {\n                    let _db = db;\n                    todo!()\n                }\n            }\n            #[cfg(feature = \"payouts\")]\n            webhooks::ObjectReferenceId::PayoutId(payout_id_type) => {\n                get_mca_from_payout_attempt(state, platform, payout_id_type, connector_name).await\n            }\n        },\n    }\n}\n\n// validate json format for the error", "function_name": "get_mca_from_object_reference_id", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router MCA resolution from object ID"}, {"query": "hyperswitch get_mca_from_payment_intent usage in router utils", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_object_reference_id\npub async fn get_mca_from_object_reference_id(\n    state: &SessionState,\n    object_reference_id: webhooks::ObjectReferenceId,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let default_profile_id = platform\n        .get_processor()\n        .get_account()\n        .default_profile\n        .as_ref();\n\n    #[cfg(feature = \"v2\")]\n    let default_profile_id = Option::<&String>::None;\n\n    match default_profile_id {\n        Some(profile_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                let _db = db;\n                let _profile_id = profile_id;\n                todo!()\n            }\n        }\n        _ => match object_reference_id {\n            webhooks::ObjectReferenceId::PaymentId(payment_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_payment_id_type(state, payment_id_type, platform)\n                        .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::RefundId(refund_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_refund_id_type(\n                        state,\n                        refund_id_type,\n                        platform,\n                        connector_name,\n                    )\n                    .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::Manda\n\n... [truncated 544 chars] ...\n\n           }\n            webhooks::ObjectReferenceId::SubscriptionId(subscription_id_type) => {\n                #[cfg(feature = \"v1\")]\n                {\n                    let subscription_state = state.clone().into();\n                    let subscription_handler =\n                        SubscriptionHandler::new(&subscription_state, platform);\n                    let mut subscription_with_handler = subscription_handler\n                        .find_subscription(subscription_id_type)\n                        .await?;\n\n                    subscription_with_handler.get_mca(connector_name).await\n                }\n                #[cfg(feature = \"v2\")]\n                {\n                    let _db = db;\n                    todo!()\n                }\n            }\n            #[cfg(feature = \"payouts\")]\n            webhooks::ObjectReferenceId::PayoutId(payout_id_type) => {\n                get_mca_from_payout_attempt(state, platform, payout_id_type, connector_name).await\n            }\n        },\n    }\n}\n\n// validate json format for the error", "function_name": "get_mca_from_object_reference_id", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Router MCA resolution from object ID"}, {"query": "rust hyperswitch payone connector error handling get_error_response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\n#[async_trait::async_trait]", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Connector Error Handler"}, {"query": "how to implement custom error response in hyperswitch payone connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\n#[async_trait::async_trait]", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Connector Error Handler"}, {"query": "hyperswitch payone connector error builder pattern rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\n#[async_trait::async_trait]", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Connector Error Handler"}, {"query": "rust hyperswitch payone error response unit test", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\n#[async_trait::async_trait]", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Connector Error Handler"}, {"query": "How to convert minor amount to currency for Redsys in hyperswitch?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreProcessingRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.minor_amount;\n        let currency =\n            req.request\n                .currency\n                .ok_or(errors::ConnectorError::MissingRequiredField {\n                    field_name: \"currency\",\n                })?;\n\n        let amount =\n            connector_utils::convert_amount(self.amount_converter, minor_amount, currency)?;\n        let connector_router_data = redsys::RedsysRouterData::from((amount, req, currency));\n        let connector_req = redsys::RedsysTransaction::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys request body builder"}, {"query": "Implement get_request_body for Redsys connector in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreProcessingRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.minor_amount;\n        let currency =\n            req.request\n                .currency\n                .ok_or(errors::ConnectorError::MissingRequiredField {\n                    field_name: \"currency\",\n                })?;\n\n        let amount =\n            connector_utils::convert_amount(self.amount_converter, minor_amount, currency)?;\n        let connector_router_data = redsys::RedsysRouterData::from((amount, req, currency));\n        let connector_req = redsys::RedsysTransaction::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys request body builder"}, {"query": "Hyperswitch Redsys transaction request body conversion logic", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreProcessingRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.minor_amount;\n        let currency =\n            req.request\n                .currency\n                .ok_or(errors::ConnectorError::MissingRequiredField {\n                    field_name: \"currency\",\n                })?;\n\n        let amount =\n            connector_utils::convert_amount(self.amount_converter, minor_amount, currency)?;\n        let connector_router_data = redsys::RedsysRouterData::from((amount, req, currency));\n        let connector_req = redsys::RedsysTransaction::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys request body builder"}, {"query": "Rust function to build Redsys payment request payload", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreProcessingRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.minor_amount;\n        let currency =\n            req.request\n                .currency\n                .ok_or(errors::ConnectorError::MissingRequiredField {\n                    field_name: \"currency\",\n                })?;\n\n        let amount =\n            connector_utils::convert_amount(self.amount_converter, minor_amount, currency)?;\n        let connector_router_data = redsys::RedsysRouterData::from((amount, req, currency));\n        let connector_req = redsys::RedsysTransaction::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys request body builder"}, {"query": "how to handle Amazon Pay error responses in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayErrorResponse = res\n            .response\n            .parse_struct(\"AmazonpayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.reason_code.clone(),\n            message: response.message.clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            reason: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay error response builder"}, {"query": "build_error_response function implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayErrorResponse = res\n            .response\n            .parse_struct(\"AmazonpayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.reason_code.clone(),\n            message: response.message.clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            reason: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay error response builder"}, {"query": "parse amazonpay error response struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayErrorResponse = res\n            .response\n            .parse_struct(\"AmazonpayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.reason_code.clone(),\n            message: response.message.clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            reason: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay error response builder"}, {"query": "hyperswitch connector error handling pattern", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayErrorResponse = res\n            .response\n            .parse_struct(\"AmazonpayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.reason_code.clone(),\n            message: response.message.clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            reason: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay error response builder"}, {"query": "how to remove a DirValue from keywise_values map in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: remove\n    pub fn remove(&mut self, value: dir::DirValue) {\n        let set = self.keywise_values.entry(value.get_key()).or_default();\n\n        set.remove(&value);\n\n        if set.is_empty() {\n            self.keywise_values.remove(&value.get_key());\n        }\n    }\n}\n", "function_name": "remove", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSSA Graph Value Removal"}, {"query": "hyperswitch dssa graph remove function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: remove\n    pub fn remove(&mut self, value: dir::DirValue) {\n        let set = self.keywise_values.entry(value.get_key()).or_default();\n\n        set.remove(&value);\n\n        if set.is_empty() {\n            self.keywise_values.remove(&value.get_key());\n        }\n    }\n}\n", "function_name": "remove", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSSA Graph Value Removal"}, {"query": "rust remove entry from hashmap if empty after removal", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: remove\n    pub fn remove(&mut self, value: dir::DirValue) {\n        let set = self.keywise_values.entry(value.get_key()).or_default();\n\n        set.remove(&value);\n\n        if set.is_empty() {\n            self.keywise_values.remove(&value.get_key());\n        }\n    }\n}\n", "function_name": "remove", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSSA Graph Value Removal"}, {"query": "dssa graph keywise_values remove method source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: remove\n    pub fn remove(&mut self, value: dir::DirValue) {\n        let set = self.keywise_values.entry(value.get_key()).or_default();\n\n        set.remove(&value);\n\n        if set.is_empty() {\n            self.keywise_values.remove(&value.get_key());\n        }\n    }\n}\n", "function_name": "remove", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSSA Graph Value Removal"}, {"query": "How to handle Wells Fargo connector error responses in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            wellsfargo::WellsfargoErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Wellsfargo ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::WellsfargoErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 2663 chars] ...\n\n & \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"wellsfargo\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo error response builder"}, {"query": "Build ErrorResponse from Wells Fargo API response status 401", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            wellsfargo::WellsfargoErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Wellsfargo ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::WellsfargoErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 2663 chars] ...\n\n & \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"wellsfargo\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo error response builder"}, {"query": "Parse Wells Fargo error details and reason codes", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            wellsfargo::WellsfargoErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Wellsfargo ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::WellsfargoErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 2663 chars] ...\n\n & \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"wellsfargo\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo error response builder"}, {"query": "Handle JSON deserialization failure for Wells Fargo connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            wellsfargo::WellsfargoErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Wellsfargo ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::WellsfargoErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 2663 chars] ...\n\n & \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"wellsfargo\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo error response builder"}, {"query": "how to update multiple merchant connector accounts in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_multiple_merchant_connector_accounts\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        merchant_connector_accounts: Vec<(\n            domain::MerchantConnectorAccount,\n            storage::MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error> {\n        self.router_store\n            .update_multiple_merchant_connector_accounts(merchant_connector_accounts)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "function_name": "update_multiple_merchant_connector_accounts", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Batch update merchant connector accounts"}, {"query": "hyperswitch update_multiple_merchant_connector_accounts implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_multiple_merchant_connector_accounts\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        merchant_connector_accounts: Vec<(\n            domain::MerchantConnectorAccount,\n            storage::MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error> {\n        self.router_store\n            .update_multiple_merchant_connector_accounts(merchant_connector_accounts)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "function_name": "update_multiple_merchant_connector_accounts", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Batch update merchant connector accounts"}, {"query": "batch update merchant connector accounts hyperswitch storage_impl", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_multiple_merchant_connector_accounts\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        merchant_connector_accounts: Vec<(\n            domain::MerchantConnectorAccount,\n            storage::MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error> {\n        self.router_store\n            .update_multiple_merchant_connector_accounts(merchant_connector_accounts)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "function_name": "update_multiple_merchant_connector_accounts", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Batch update merchant connector accounts"}, {"query": "hyperswitch router store update multiple accounts function", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_multiple_merchant_connector_accounts\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        merchant_connector_accounts: Vec<(\n            domain::MerchantConnectorAccount,\n            storage::MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error> {\n        self.router_store\n            .update_multiple_merchant_connector_accounts(merchant_connector_accounts)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "function_name": "update_multiple_merchant_connector_accounts", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Batch update merchant connector accounts"}, {"query": "how to configure netcetera connector authentication in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let netcetera_auth_type = netcetera::NetceteraAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorPreAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorPreAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorPreAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(netcetera_auth_type.certificate))\n                .add_certificate_key(Some(netcetera_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera pre-auth request builder"}, {"query": "rust function build_request netcetera connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let netcetera_auth_type = netcetera::NetceteraAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorPreAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorPreAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorPreAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(netcetera_auth_type.certificate))\n                .add_certificate_key(Some(netcetera_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera pre-auth request builder"}, {"query": "netcetera pre-authentication request builder hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let netcetera_auth_type = netcetera::NetceteraAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorPreAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorPreAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorPreAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(netcetera_auth_type.certificate))\n                .add_certificate_key(Some(netcetera_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera pre-auth request builder"}, {"query": "hyperswitch netcetera connector ssl certificate configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let netcetera_auth_type = netcetera::NetceteraAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorPreAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorPreAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorPreAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(netcetera_auth_type.certificate))\n                .add_certificate_key(Some(netcetera_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera pre-auth request builder"}, {"query": "how to configure tokenex vault request builder in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ExternalVaultInsertType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ExternalVaultInsertType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ExternalVaultInsertType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "TokenEx connector request builder"}, {"query": "rust hyperswitch tokenex connector build_request implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ExternalVaultInsertType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ExternalVaultInsertType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ExternalVaultInsertType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "TokenEx connector request builder"}, {"query": "hyperswitch tokenex external vault insert flow request setup", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ExternalVaultInsertType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ExternalVaultInsertType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ExternalVaultInsertType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "TokenEx connector request builder"}, {"query": "tokenex hyperswitch connector request builder method post", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ExternalVaultInsertType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ExternalVaultInsertType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ExternalVaultInsertType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "TokenEx connector request builder"}, {"query": "rust elavon connector from function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon payment transformer constructor"}, {"query": "how to convert elavon response to router data struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon payment transformer constructor"}, {"query": "elavon payment transformer constructor amount router_data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon payment transformer constructor"}, {"query": "hyperswitch elavon connector from method signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon payment transformer constructor"}, {"query": "rust function to get last part of url string", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_last_segment\n    fn get_last_segment(canonical_uri: &str) -> String {\n        canonical_uri\n            .chars()\n            .rev()\n            .take_while(|&c| c != '/')\n            .collect::<Vec<_>>()\n            .into_iter()\n            .rev()\n            .collect()\n    }\n", "function_name": "get_last_segment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay URI segment parser"}, {"query": "hyperswitch amazonpay connector get_last_segment implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_last_segment\n    fn get_last_segment(canonical_uri: &str) -> String {\n        canonical_uri\n            .chars()\n            .rev()\n            .take_while(|&c| c != '/')\n            .collect::<Vec<_>>()\n            .into_iter()\n            .rev()\n            .collect()\n    }\n", "function_name": "get_last_segment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay URI segment parser"}, {"query": "how to extract final path segment from uri in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_last_segment\n    fn get_last_segment(canonical_uri: &str) -> String {\n        canonical_uri\n            .chars()\n            .rev()\n            .take_while(|&c| c != '/')\n            .collect::<Vec<_>>()\n            .into_iter()\n            .rev()\n            .collect()\n    }\n", "function_name": "get_last_segment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay URI segment parser"}, {"query": "amazonpay connector parsing uri last segment hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_last_segment\n    fn get_last_segment(canonical_uri: &str) -> String {\n        canonical_uri\n            .chars()\n            .rev()\n            .take_while(|&c| c != '/')\n            .collect::<Vec<_>>()\n            .into_iter()\n            .rev()\n            .collect()\n    }\n", "function_name": "get_last_segment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay URI segment parser"}, {"query": "how to set group by clause for time series analytics in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_group_by_clause\n    fn set_group_by_clause(\n        &self,\n        builder: &mut QueryBuilder<super::SqlxClient>,\n    ) -> QueryResult<()> {\n        let trunc_scale = self.get_lowest_common_granularity_level();\n\n        let granularity_bucket_scale = match self {\n            Self::OneMin => None,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin => Some(\"minute\"),\n            Self::OneHour | Self::OneDay => None,\n        };\n\n        let granularity_divisor = self.get_bucket_size();\n\n        builder\n            .add_group_by_clause(format!(\"DATE_TRUNC('{trunc_scale}', created_at)\"))\n            .attach_printable(\"Error adding time prune group by\")?;\n        if let Some(scale) = granularity_bucket_scale {\n            builder\n                .add_group_by_clause(format!(\n                    \"FLOOR(DATE_PART('{scale}', created_at)/{granularity_divisor})\"\n                ))\n                .attach_printable(\"Error adding time binning group by\")?;\n        }\n        Ok(())\n    }\n}\n", "function_name": "set_group_by_clause", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "analytics time bucketing"}, {"query": "rust function set_group_by_clause hyperswitch analytics", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_group_by_clause\n    fn set_group_by_clause(\n        &self,\n        builder: &mut QueryBuilder<super::SqlxClient>,\n    ) -> QueryResult<()> {\n        let trunc_scale = self.get_lowest_common_granularity_level();\n\n        let granularity_bucket_scale = match self {\n            Self::OneMin => None,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin => Some(\"minute\"),\n            Self::OneHour | Self::OneDay => None,\n        };\n\n        let granularity_divisor = self.get_bucket_size();\n\n        builder\n            .add_group_by_clause(format!(\"DATE_TRUNC('{trunc_scale}', created_at)\"))\n            .attach_printable(\"Error adding time prune group by\")?;\n        if let Some(scale) = granularity_bucket_scale {\n            builder\n                .add_group_by_clause(format!(\n                    \"FLOOR(DATE_PART('{scale}', created_at)/{granularity_divisor})\"\n                ))\n                .attach_printable(\"Error adding time binning group by\")?;\n        }\n        Ok(())\n    }\n}\n", "function_name": "set_group_by_clause", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "analytics time bucketing"}, {"query": "hyperswitch analytics query builder group by timestamp", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_group_by_clause\n    fn set_group_by_clause(\n        &self,\n        builder: &mut QueryBuilder<super::SqlxClient>,\n    ) -> QueryResult<()> {\n        let trunc_scale = self.get_lowest_common_granularity_level();\n\n        let granularity_bucket_scale = match self {\n            Self::OneMin => None,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin => Some(\"minute\"),\n            Self::OneHour | Self::OneDay => None,\n        };\n\n        let granularity_divisor = self.get_bucket_size();\n\n        builder\n            .add_group_by_clause(format!(\"DATE_TRUNC('{trunc_scale}', created_at)\"))\n            .attach_printable(\"Error adding time prune group by\")?;\n        if let Some(scale) = granularity_bucket_scale {\n            builder\n                .add_group_by_clause(format!(\n                    \"FLOOR(DATE_PART('{scale}', created_at)/{granularity_divisor})\"\n                ))\n                .attach_printable(\"Error adding time binning group by\")?;\n        }\n        Ok(())\n    }\n}\n", "function_name": "set_group_by_clause", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "analytics time bucketing"}, {"query": "how does hyperswitch handle time bucketing in analytics queries", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_group_by_clause\n    fn set_group_by_clause(\n        &self,\n        builder: &mut QueryBuilder<super::SqlxClient>,\n    ) -> QueryResult<()> {\n        let trunc_scale = self.get_lowest_common_granularity_level();\n\n        let granularity_bucket_scale = match self {\n            Self::OneMin => None,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin => Some(\"minute\"),\n            Self::OneHour | Self::OneDay => None,\n        };\n\n        let granularity_divisor = self.get_bucket_size();\n\n        builder\n            .add_group_by_clause(format!(\"DATE_TRUNC('{trunc_scale}', created_at)\"))\n            .attach_printable(\"Error adding time prune group by\")?;\n        if let Some(scale) = granularity_bucket_scale {\n            builder\n                .add_group_by_clause(format!(\n                    \"FLOOR(DATE_PART('{scale}', created_at)/{granularity_divisor})\"\n                ))\n                .attach_printable(\"Error adding time binning group by\")?;\n        }\n        Ok(())\n    }\n}\n", "function_name": "set_group_by_clause", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "analytics time bucketing"}, {"query": "hyperswitch router KeyManagerConfig struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: KeyManagerConfig\npub struct KeyManagerConfig {\n    pub enabled: bool,\n    pub url: String,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub cert: Secret<String>,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub ca: Secret<String>,\n    #[serde(default = \"default_key_store_decryption_behavior\")]\n    pub use_legacy_key_store_decryption: bool,\n}\n", "function_name": "KeyManagerConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "KeyManagerConfig struct definition"}, {"query": "how to configure Key Manager service in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: KeyManagerConfig\npub struct KeyManagerConfig {\n    pub enabled: bool,\n    pub url: String,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub cert: Secret<String>,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub ca: Secret<String>,\n    #[serde(default = \"default_key_store_decryption_behavior\")]\n    pub use_legacy_key_store_decryption: bool,\n}\n", "function_name": "KeyManagerConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "KeyManagerConfig struct definition"}, {"query": "enable mTLS for Key Manager in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: KeyManagerConfig\npub struct KeyManagerConfig {\n    pub enabled: bool,\n    pub url: String,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub cert: Secret<String>,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub ca: Secret<String>,\n    #[serde(default = \"default_key_store_decryption_behavior\")]\n    pub use_legacy_key_store_decryption: bool,\n}\n", "function_name": "KeyManagerConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "KeyManagerConfig struct definition"}, {"query": "hyperswitch KeyManagerConfig use_legacy_key_store_decryption", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: KeyManagerConfig\npub struct KeyManagerConfig {\n    pub enabled: bool,\n    pub url: String,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub cert: Secret<String>,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub ca: Secret<String>,\n    #[serde(default = \"default_key_store_decryption_behavior\")]\n    pub use_legacy_key_store_decryption: bool,\n}\n", "function_name": "KeyManagerConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "KeyManagerConfig struct definition"}, {"query": "how to count total refunds for a merchant in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_total_count_of_refunds\n    async fn get_total_count_of_refunds(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<i64, errors::StorageError>;\n}\n\n#[cfg(not(feature = \"kv_store\"))]\nmod storage {\n    use error_stack::report;\n    use hyperswitch_domain_models::refunds;\n    use router_env::{instrument, tracing};\n\n    use super::RefundInterface;\n    use crate::{\n        connection,\n        core::errors::{self, CustomResult},\n        services::Store,\n        types::storage::{self as storage_types, enums},\n    };\n\n    #[async_trait::async_trait]", "function_name": "get_total_count_of_refunds", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund count interface"}, {"query": "hyperswitch router get_total_count_of_refunds implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_total_count_of_refunds\n    async fn get_total_count_of_refunds(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<i64, errors::StorageError>;\n}\n\n#[cfg(not(feature = \"kv_store\"))]\nmod storage {\n    use error_stack::report;\n    use hyperswitch_domain_models::refunds;\n    use router_env::{instrument, tracing};\n\n    use super::RefundInterface;\n    use crate::{\n        connection,\n        core::errors::{self, CustomResult},\n        services::Store,\n        types::storage::{self as storage_types, enums},\n    };\n\n    #[async_trait::async_trait]", "function_name": "get_total_count_of_refunds", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund count interface"}, {"query": "rust function to get refund count by merchant_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_total_count_of_refunds\n    async fn get_total_count_of_refunds(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<i64, errors::StorageError>;\n}\n\n#[cfg(not(feature = \"kv_store\"))]\nmod storage {\n    use error_stack::report;\n    use hyperswitch_domain_models::refunds;\n    use router_env::{instrument, tracing};\n\n    use super::RefundInterface;\n    use crate::{\n        connection,\n        core::errors::{self, CustomResult},\n        services::Store,\n        types::storage::{self as storage_types, enums},\n    };\n\n    #[async_trait::async_trait]", "function_name": "get_total_count_of_refunds", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund count interface"}, {"query": "hyperswitch storage interface for refund counting", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_total_count_of_refunds\n    async fn get_total_count_of_refunds(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<i64, errors::StorageError>;\n}\n\n#[cfg(not(feature = \"kv_store\"))]\nmod storage {\n    use error_stack::report;\n    use hyperswitch_domain_models::refunds;\n    use router_env::{instrument, tracing};\n\n    use super::RefundInterface;\n    use crate::{\n        connection,\n        core::errors::{self, CustomResult},\n        services::Store,\n        types::storage::{self as storage_types, enums},\n    };\n\n    #[async_trait::async_trait]", "function_name": "get_total_count_of_refunds", "file": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "unit_type": "function", "label": "Refund count interface"}, {"query": "rust hyperswitch zift connector get_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "zift connector headers configuration"}, {"query": "how to configure headers for zift payment gateway in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "zift connector headers configuration"}, {"query": "hyperswitch zift connector source code get_headers function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "zift connector headers configuration"}, {"query": "rust hyperswitch zift authorization headers masking", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "unit_type": "function", "label": "zift connector headers configuration"}, {"query": "how to configure allowed connectors for specific merchants in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CloneConnectorAllowlistConfig\npub struct CloneConnectorAllowlistConfig {\n    #[serde(deserialize_with = \"deserialize_merchant_ids\")]\n    pub merchant_ids: HashSet<id_type::MerchantId>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub connector_names: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "CloneConnectorAllowlistConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router connector allowlist config"}, {"query": "rust struct definition for CloneConnectorAllowlistConfig", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CloneConnectorAllowlistConfig\npub struct CloneConnectorAllowlistConfig {\n    #[serde(deserialize_with = \"deserialize_merchant_ids\")]\n    pub merchant_ids: HashSet<id_type::MerchantId>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub connector_names: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "CloneConnectorAllowlistConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router connector allowlist config"}, {"query": "hyperswitch router configuration merchant_ids connector_names", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CloneConnectorAllowlistConfig\npub struct CloneConnectorAllowlistConfig {\n    #[serde(deserialize_with = \"deserialize_merchant_ids\")]\n    pub merchant_ids: HashSet<id_type::MerchantId>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub connector_names: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "CloneConnectorAllowlistConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router connector allowlist config"}, {"query": "deserialize_merchant_ids deserialize_hashset serde hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CloneConnectorAllowlistConfig\npub struct CloneConnectorAllowlistConfig {\n    #[serde(deserialize_with = \"deserialize_merchant_ids\")]\n    pub merchant_ids: HashSet<id_type::MerchantId>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub connector_names: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "function_name": "CloneConnectorAllowlistConfig", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "Router connector allowlist config"}, {"query": "rust from trait implementation for payment amount and router data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Payment DTO conversion"}, {"query": "hyperswitch connector struct conversion from tuple", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Payment DTO conversion"}, {"query": "StringMajorUnit to payment struct conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Payment DTO conversion"}, {"query": "how to convert payment amount and router data in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Payment DTO conversion"}, {"query": "how to configure globepay automatic capture url", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let query_params = get_globlepay_query_params(&req.connector_auth_type)?;\n        if matches!(\n            req.request.capture_method,\n            Some(enums::CaptureMethod::Automatic) | Some(enums::CaptureMethod::SequentialAutomatic)\n        ) {\n            Ok(format!(\n                \"{}api/v1.0/gateway/partners/{}/orders/{}{query_params}\",\n                self.base_url(connectors),\n                get_partner_code(&req.connector_auth_type)?,\n                req.payment_id\n            ))\n        } else {\n            Err(errors::ConnectorError::FlowNotSupported {\n                flow: \"Manual Capture\".to_owned(),\n                connector: \"Globepay\".to_owned(),\n            }\n            .into())\n        }\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization URL builder"}, {"query": "globepay connector get_url function automatic capture", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let query_params = get_globlepay_query_params(&req.connector_auth_type)?;\n        if matches!(\n            req.request.capture_method,\n            Some(enums::CaptureMethod::Automatic) | Some(enums::CaptureMethod::SequentialAutomatic)\n        ) {\n            Ok(format!(\n                \"{}api/v1.0/gateway/partners/{}/orders/{}{query_params}\",\n                self.base_url(connectors),\n                get_partner_code(&req.connector_auth_type)?,\n                req.payment_id\n            ))\n        } else {\n            Err(errors::ConnectorError::FlowNotSupported {\n                flow: \"Manual Capture\".to_owned(),\n                connector: \"Globepay\".to_owned(),\n            }\n            .into())\n        }\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization URL builder"}, {"query": "hyperswitch globepay manual capture error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let query_params = get_globlepay_query_params(&req.connector_auth_type)?;\n        if matches!(\n            req.request.capture_method,\n            Some(enums::CaptureMethod::Automatic) | Some(enums::CaptureMethod::SequentialAutomatic)\n        ) {\n            Ok(format!(\n                \"{}api/v1.0/gateway/partners/{}/orders/{}{query_params}\",\n                self.base_url(connectors),\n                get_partner_code(&req.connector_auth_type)?,\n                req.payment_id\n            ))\n        } else {\n            Err(errors::ConnectorError::FlowNotSupported {\n                flow: \"Manual Capture\".to_owned(),\n                connector: \"Globepay\".to_owned(),\n            }\n            .into())\n        }\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization URL builder"}, {"query": "globepay authorization endpoint query parameters rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let query_params = get_globlepay_query_params(&req.connector_auth_type)?;\n        if matches!(\n            req.request.capture_method,\n            Some(enums::CaptureMethod::Automatic) | Some(enums::CaptureMethod::SequentialAutomatic)\n        ) {\n            Ok(format!(\n                \"{}api/v1.0/gateway/partners/{}/orders/{}{query_params}\",\n                self.base_url(connectors),\n                get_partner_code(&req.connector_auth_type)?,\n                req.payment_id\n            ))\n        } else {\n            Err(errors::ConnectorError::FlowNotSupported {\n                flow: \"Manual Capture\".to_owned(),\n                connector: \"Globepay\".to_owned(),\n            }\n            .into())\n        }\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "unit_type": "function", "label": "Globepay authorization URL builder"}, {"query": "How to handle Tokenex vault insert response in Rust?", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &VaultRouterData<ExternalVaultInsertFlow>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<VaultRouterData<ExternalVaultInsertFlow>, errors::ConnectorError> {\n        let response: tokenex::TokenexInsertResponse = res\n            .response\n            .parse_struct(\"TokenexInsertResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex response handler"}, {"query": "Parse TokenexInsertResponse struct from HTTP response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &VaultRouterData<ExternalVaultInsertFlow>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<VaultRouterData<ExternalVaultInsertFlow>, errors::ConnectorError> {\n        let response: tokenex::TokenexInsertResponse = res\n            .response\n            .parse_struct(\"TokenexInsertResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex response handler"}, {"query": "Implement handle_response for Tokenex connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &VaultRouterData<ExternalVaultInsertFlow>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<VaultRouterData<ExternalVaultInsertFlow>, errors::ConnectorError> {\n        let response: tokenex::TokenexInsertResponse = res\n            .response\n            .parse_struct(\"TokenexInsertResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex response handler"}, {"query": "Rust custom error handling for Tokenex API response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &VaultRouterData<ExternalVaultInsertFlow>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<VaultRouterData<ExternalVaultInsertFlow>, errors::ConnectorError> {\n        let response: tokenex::TokenexInsertResponse = res\n            .response\n            .parse_struct(\"TokenexInsertResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex response handler"}, {"query": "how to update payment method mandate after payment hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate_impl\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n     \n\n... [truncated 4105 chars] ...\n\n                  payload,\n                    )\n                    .await\n                    {\n                        Ok(_) => {\n                            logger::info!(\"Successfully called modular payment method update\");\n                        }\n                        Err(err) => {\n                            logger::error!(\"Failed to call modular payment method update: {}\", err);\n                        }\n                    };\n                    payment_data.payment_attempt.payment_method_id =\n                        Some(payment_method_id.clone());\n                } else {\n                    logger::info!(\"No updates found for modular payment method update call\");\n                }\n            }\n            _ => {\n                logger::info!(\"Payment method is not eligible for modular update\");\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Helper function to update payment method connector mandate details.\n/// This is called after a successful payment to activate/update the connector mandate.\n#[cfg(feature = \"v1\")]", "function_name": "update_modular_pm_and_mandate_impl", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Method Update Logic"}, {"query": "hyperswitch modular payment method update function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate_impl\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n     \n\n... [truncated 4105 chars] ...\n\n                  payload,\n                    )\n                    .await\n                    {\n                        Ok(_) => {\n                            logger::info!(\"Successfully called modular payment method update\");\n                        }\n                        Err(err) => {\n                            logger::error!(\"Failed to call modular payment method update: {}\", err);\n                        }\n                    };\n                    payment_data.payment_attempt.payment_method_id =\n                        Some(payment_method_id.clone());\n                } else {\n                    logger::info!(\"No updates found for modular payment method update call\");\n                }\n            }\n            _ => {\n                logger::info!(\"Payment method is not eligible for modular update\");\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Helper function to update payment method connector mandate details.\n/// This is called after a successful payment to activate/update the connector mandate.\n#[cfg(feature = \"v1\")]", "function_name": "update_modular_pm_and_mandate_impl", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Method Update Logic"}, {"query": "update payment method connector mandate details rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate_impl\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n     \n\n... [truncated 4105 chars] ...\n\n                  payload,\n                    )\n                    .await\n                    {\n                        Ok(_) => {\n                            logger::info!(\"Successfully called modular payment method update\");\n                        }\n                        Err(err) => {\n                            logger::error!(\"Failed to call modular payment method update: {}\", err);\n                        }\n                    };\n                    payment_data.payment_attempt.payment_method_id =\n                        Some(payment_method_id.clone());\n                } else {\n                    logger::info!(\"No updates found for modular payment method update call\");\n                }\n            }\n            _ => {\n                logger::info!(\"Payment method is not eligible for modular update\");\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Helper function to update payment method connector mandate details.\n/// This is called after a successful payment to activate/update the connector mandate.\n#[cfg(feature = \"v1\")]", "function_name": "update_modular_pm_and_mandate_impl", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Method Update Logic"}, {"query": "hyperswitch payment method update network transaction id mandate", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate_impl\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n     \n\n... [truncated 4105 chars] ...\n\n                  payload,\n                    )\n                    .await\n                    {\n                        Ok(_) => {\n                            logger::info!(\"Successfully called modular payment method update\");\n                        }\n                        Err(err) => {\n                            logger::error!(\"Failed to call modular payment method update: {}\", err);\n                        }\n                    };\n                    payment_data.payment_attempt.payment_method_id =\n                        Some(payment_method_id.clone());\n                } else {\n                    logger::info!(\"No updates found for modular payment method update call\");\n                }\n            }\n            _ => {\n                logger::info!(\"Payment method is not eligible for modular update\");\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Helper function to update payment method connector mandate details.\n/// This is called after a successful payment to activate/update the connector mandate.\n#[cfg(feature = \"v1\")]", "function_name": "update_modular_pm_and_mandate_impl", "file": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "unit_type": "function", "label": "Payment Method Update Logic"}, {"query": "hyperswitch signifyd address struct secret field", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Address\npub struct Address {\n    street_address: Secret<String>,\n    unit: Option<Secret<String>>,\n    postal_code: Secret<String>,\n    city: String,\n    province_code: Secret<String>,\n    country_code: common_enums::CountryAlpha2,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "Address", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Address Struct"}, {"query": "signifyd connector address transformation rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Address\npub struct Address {\n    street_address: Secret<String>,\n    unit: Option<Secret<String>>,\n    postal_code: Secret<String>,\n    city: String,\n    province_code: Secret<String>,\n    country_code: common_enums::CountryAlpha2,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "Address", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Address Struct"}, {"query": "hyperswitch address model snake_case serde", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Address\npub struct Address {\n    street_address: Secret<String>,\n    unit: Option<Secret<String>>,\n    postal_code: Secret<String>,\n    city: String,\n    province_code: Secret<String>,\n    country_code: common_enums::CountryAlpha2,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "Address", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Address Struct"}, {"query": "signifyd api address structure hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Address\npub struct Address {\n    street_address: Secret<String>,\n    unit: Option<Secret<String>>,\n    postal_code: Secret<String>,\n    city: String,\n    province_code: Secret<String>,\n    country_code: common_enums::CountryAlpha2,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "function_name": "Address", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Address Struct"}, {"query": "how to check if merchant connector account is disabled in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: is_disabled\n    pub fn is_disabled(&self) -> bool {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.disabled.unwrap_or(false)\n            }\n            Self::MerchantConnectorDetails(_) => false,\n        }\n    }\n", "function_name": "is_disabled", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account disabled status"}, {"query": "rust function to get disabled status from merchant connector account", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: is_disabled\n    pub fn is_disabled(&self) -> bool {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.disabled.unwrap_or(false)\n            }\n            Self::MerchantConnectorDetails(_) => false,\n        }\n    }\n", "function_name": "is_disabled", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account disabled status"}, {"query": "hyperswitch domain models merchant connector account is_disabled method", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: is_disabled\n    pub fn is_disabled(&self) -> bool {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.disabled.unwrap_or(false)\n            }\n            Self::MerchantConnectorDetails(_) => false,\n        }\n    }\n", "function_name": "is_disabled", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account disabled status"}, {"query": "how to disable a connector account in hyperswitch rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: is_disabled\n    pub fn is_disabled(&self) -> bool {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.disabled.unwrap_or(false)\n            }\n            Self::MerchantConnectorDetails(_) => false,\n        }\n    }\n", "function_name": "is_disabled", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account disabled status"}, {"query": "how to get merchant connector account from payment intent", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payment_intent\npub async fn get_mca_from_payment_intent(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payment_intent: PaymentIntent,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &payment_intent.active_attempt.get_id(),\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    #[cfg(feature = \"v2\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_merchant_id(\n            key_manager_state,\n            key_store,\n            &payment_intent.active_attempt.get_id(),\n            merchant_account.get_id(),\n            merchant_account.storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    match payment_attempt.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = key_store;\n                let _ = key_manager_state;\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            let profile_id = payment_intent\n                .profile_id\n                .as_ref()\n                .get_required_value(\"profile_id\")\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"profile_id is not set in payment_intent\")?\n                .clone();\n\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _ = profile_id;\n                todo!()\n            }\n        }\n    }\n}\n#[cfg(feature = \"payouts\")]", "function_name": "get_mca_from_payment_intent", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Merchant Connector Account Retrieval"}, {"query": "rust hyperswitch get_mca_from_payment_intent implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payment_intent\npub async fn get_mca_from_payment_intent(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payment_intent: PaymentIntent,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &payment_intent.active_attempt.get_id(),\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    #[cfg(feature = \"v2\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_merchant_id(\n            key_manager_state,\n            key_store,\n            &payment_intent.active_attempt.get_id(),\n            merchant_account.get_id(),\n            merchant_account.storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    match payment_attempt.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = key_store;\n                let _ = key_manager_state;\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            let profile_id = payment_intent\n                .profile_id\n                .as_ref()\n                .get_required_value(\"profile_id\")\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"profile_id is not set in payment_intent\")?\n                .clone();\n\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _ = profile_id;\n                todo!()\n            }\n        }\n    }\n}\n#[cfg(feature = \"payouts\")]", "function_name": "get_mca_from_payment_intent", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Merchant Connector Account Retrieval"}, {"query": "find merchant connector account by profile id and connector name", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payment_intent\npub async fn get_mca_from_payment_intent(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payment_intent: PaymentIntent,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &payment_intent.active_attempt.get_id(),\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    #[cfg(feature = \"v2\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_merchant_id(\n            key_manager_state,\n            key_store,\n            &payment_intent.active_attempt.get_id(),\n            merchant_account.get_id(),\n            merchant_account.storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    match payment_attempt.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = key_store;\n                let _ = key_manager_state;\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            let profile_id = payment_intent\n                .profile_id\n                .as_ref()\n                .get_required_value(\"profile_id\")\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"profile_id is not set in payment_intent\")?\n                .clone();\n\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _ = profile_id;\n                todo!()\n            }\n        }\n    }\n}\n#[cfg(feature = \"payouts\")]", "function_name": "get_mca_from_payment_intent", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Merchant Connector Account Retrieval"}, {"query": "hyperswitch router utils get_mca_from_payment_intent", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payment_intent\npub async fn get_mca_from_payment_intent(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payment_intent: PaymentIntent,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &payment_intent.active_attempt.get_id(),\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    #[cfg(feature = \"v2\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_merchant_id(\n            key_manager_state,\n            key_store,\n            &payment_intent.active_attempt.get_id(),\n            merchant_account.get_id(),\n            merchant_account.storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    match payment_attempt.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = key_store;\n                let _ = key_manager_state;\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            let profile_id = payment_intent\n                .profile_id\n                .as_ref()\n                .get_required_value(\"profile_id\")\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"profile_id is not set in payment_intent\")?\n                .clone();\n\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _ = profile_id;\n                todo!()\n            }\n        }\n    }\n}\n#[cfg(feature = \"payouts\")]", "function_name": "get_mca_from_payment_intent", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Merchant Connector Account Retrieval"}, {"query": "rust hyperswitch cybersource connector generate_signature implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: cybersource::CybersourceAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let cybersource::CybersourceAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource HMAC Signature Generation"}, {"query": "how to sign cybersource requests in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: cybersource::CybersourceAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let cybersource::CybersourceAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource HMAC Signature Generation"}, {"query": "hyperswitch cybersource_auth_type signature generation hmac sha256", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: cybersource::CybersourceAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let cybersource::CybersourceAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource HMAC Signature Generation"}, {"query": "cybersource signature header format hyperswitch rust code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: cybersource::CybersourceAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let cybersource::CybersourceAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource HMAC Signature Generation"}, {"query": "rust hyperswitch amazonpay finalize url construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        match req.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(ref wallet_data) => match wallet_data {\n                WalletDataPaymentMethod::AmazonPay(ref req_wallet) => Ok(format!(\n                    \"{}/checkoutSessions/{}/finalize\",\n                    self.base_url(connectors),\n                    req_wallet.checkout_session_id.clone()\n                )),\n                WalletDataPaymentMethod::AliPayQr(_)\n                | WalletDataPaymentMethod::AliPayRedirect(_)\n                | WalletDataPaymentMethod::AliPayHkRedirect(_)\n                | WalletDataPaymentMethod::AmazonPayRedirect(_)\n                | WalletDataPaymentMethod::MomoRedirect(_)\n                | WalletDataPaymentMethod::KakaoPayRedirect(_)\n                | WalletDataPaymentMethod::GoPayRedirect(_)\n                | WalletDataPaymentMethod::GcashRedirect(_)\n                | WalletDataPaymentMethod::ApplePay(_)\n                | WalletDataPaymentMethod::ApplePayRedirect(_)\n                | WalletDataPaymentMethod::ApplePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::DanaRedirect {}\n                | WalletDataPaymentMethod::GooglePay(_)\n                | WalletDataPaymentMethod::GooglePayRedirect(_)\n                | WalletDataPaymentMethod::GooglePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::MbWayRedirect(_)\n                | WalletDataPaymentMethod::MobilePayRedirect(_)\n                | WalletDataPaymentMethod::PaypalRedirect(_)\n                | WalletDataPaymentMethod::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::BluecodeRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::RevolutPay(_)\n                | WalletDataPaymentMethod::Paysera(_)\n                | WalletDataPaymentMethod::Skrill(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"amazonpay\"),\n                    )\n                    .into())\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n        }\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay finalize URL builder"}, {"query": "how to get amazonpay finalize url in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        match req.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(ref wallet_data) => match wallet_data {\n                WalletDataPaymentMethod::AmazonPay(ref req_wallet) => Ok(format!(\n                    \"{}/checkoutSessions/{}/finalize\",\n                    self.base_url(connectors),\n                    req_wallet.checkout_session_id.clone()\n                )),\n                WalletDataPaymentMethod::AliPayQr(_)\n                | WalletDataPaymentMethod::AliPayRedirect(_)\n                | WalletDataPaymentMethod::AliPayHkRedirect(_)\n                | WalletDataPaymentMethod::AmazonPayRedirect(_)\n                | WalletDataPaymentMethod::MomoRedirect(_)\n                | WalletDataPaymentMethod::KakaoPayRedirect(_)\n                | WalletDataPaymentMethod::GoPayRedirect(_)\n                | WalletDataPaymentMethod::GcashRedirect(_)\n                | WalletDataPaymentMethod::ApplePay(_)\n                | WalletDataPaymentMethod::ApplePayRedirect(_)\n                | WalletDataPaymentMethod::ApplePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::DanaRedirect {}\n                | WalletDataPaymentMethod::GooglePay(_)\n                | WalletDataPaymentMethod::GooglePayRedirect(_)\n                | WalletDataPaymentMethod::GooglePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::MbWayRedirect(_)\n                | WalletDataPaymentMethod::MobilePayRedirect(_)\n                | WalletDataPaymentMethod::PaypalRedirect(_)\n                | WalletDataPaymentMethod::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::BluecodeRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::RevolutPay(_)\n                | WalletDataPaymentMethod::Paysera(_)\n                | WalletDataPaymentMethod::Skrill(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"amazonpay\"),\n                    )\n                    .into())\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n        }\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay finalize URL builder"}, {"query": "hyperswitch amazonpay connector get_url implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        match req.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(ref wallet_data) => match wallet_data {\n                WalletDataPaymentMethod::AmazonPay(ref req_wallet) => Ok(format!(\n                    \"{}/checkoutSessions/{}/finalize\",\n                    self.base_url(connectors),\n                    req_wallet.checkout_session_id.clone()\n                )),\n                WalletDataPaymentMethod::AliPayQr(_)\n                | WalletDataPaymentMethod::AliPayRedirect(_)\n                | WalletDataPaymentMethod::AliPayHkRedirect(_)\n                | WalletDataPaymentMethod::AmazonPayRedirect(_)\n                | WalletDataPaymentMethod::MomoRedirect(_)\n                | WalletDataPaymentMethod::KakaoPayRedirect(_)\n                | WalletDataPaymentMethod::GoPayRedirect(_)\n                | WalletDataPaymentMethod::GcashRedirect(_)\n                | WalletDataPaymentMethod::ApplePay(_)\n                | WalletDataPaymentMethod::ApplePayRedirect(_)\n                | WalletDataPaymentMethod::ApplePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::DanaRedirect {}\n                | WalletDataPaymentMethod::GooglePay(_)\n                | WalletDataPaymentMethod::GooglePayRedirect(_)\n                | WalletDataPaymentMethod::GooglePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::MbWayRedirect(_)\n                | WalletDataPaymentMethod::MobilePayRedirect(_)\n                | WalletDataPaymentMethod::PaypalRedirect(_)\n                | WalletDataPaymentMethod::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::BluecodeRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::RevolutPay(_)\n                | WalletDataPaymentMethod::Paysera(_)\n                | WalletDataPaymentMethod::Skrill(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"amazonpay\"),\n                    )\n                    .into())\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n        }\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay finalize URL builder"}, {"query": "rust hyperswitch amazonpay checkout session finalize endpoint", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        match req.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(ref wallet_data) => match wallet_data {\n                WalletDataPaymentMethod::AmazonPay(ref req_wallet) => Ok(format!(\n                    \"{}/checkoutSessions/{}/finalize\",\n                    self.base_url(connectors),\n                    req_wallet.checkout_session_id.clone()\n                )),\n                WalletDataPaymentMethod::AliPayQr(_)\n                | WalletDataPaymentMethod::AliPayRedirect(_)\n                | WalletDataPaymentMethod::AliPayHkRedirect(_)\n                | WalletDataPaymentMethod::AmazonPayRedirect(_)\n                | WalletDataPaymentMethod::MomoRedirect(_)\n                | WalletDataPaymentMethod::KakaoPayRedirect(_)\n                | WalletDataPaymentMethod::GoPayRedirect(_)\n                | WalletDataPaymentMethod::GcashRedirect(_)\n                | WalletDataPaymentMethod::ApplePay(_)\n                | WalletDataPaymentMethod::ApplePayRedirect(_)\n                | WalletDataPaymentMethod::ApplePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::DanaRedirect {}\n                | WalletDataPaymentMethod::GooglePay(_)\n                | WalletDataPaymentMethod::GooglePayRedirect(_)\n                | WalletDataPaymentMethod::GooglePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::MbWayRedirect(_)\n                | WalletDataPaymentMethod::MobilePayRedirect(_)\n                | WalletDataPaymentMethod::PaypalRedirect(_)\n                | WalletDataPaymentMethod::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::BluecodeRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::RevolutPay(_)\n                | WalletDataPaymentMethod::Paysera(_)\n                | WalletDataPaymentMethod::Skrill(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"amazonpay\"),\n                    )\n                    .into())\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n        }\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay finalize URL builder"}, {"query": "how to transform router data to finix create identity request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_router_data = finix::FinixRouterData::try_from((MinorUnit::zero(), req))?;\n        let connector_req = finix::FinixCreateIdentityRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Create Identity Request Mapper"}, {"query": "finix connector get_request_body implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_router_data = finix::FinixRouterData::try_from((MinorUnit::zero(), req))?;\n        let connector_req = finix::FinixCreateIdentityRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Create Identity Request Mapper"}, {"query": "map payments response data to finix create identity request", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_router_data = finix::FinixRouterData::try_from((MinorUnit::zero(), req))?;\n        let connector_req = finix::FinixCreateIdentityRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Create Identity Request Mapper"}, {"query": "hyperswitch finix connector request body transformation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_router_data = finix::FinixRouterData::try_from((MinorUnit::zero(), req))?;\n        let connector_req = finix::FinixCreateIdentityRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Create Identity Request Mapper"}, {"query": "rust hyperswitch authentication response struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationResponse\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n", "function_name": "AuthenticationResponse", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AuthenticationResponse struct definition"}, {"query": "hyperswitch AuthenticationResponse merchant_id client_secret", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationResponse\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n", "function_name": "AuthenticationResponse", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AuthenticationResponse struct definition"}, {"query": "rust struct AuthenticationResponse authentication_connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationResponse\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n", "function_name": "AuthenticationResponse", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AuthenticationResponse struct definition"}, {"query": "hyperswitch AuthenticationResponse acquirer_details customer_details", "code": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationResponse\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n", "function_name": "AuthenticationResponse", "file": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "unit_type": "function", "label": "AuthenticationResponse struct definition"}, {"query": "how to build a request for creating a connector customer in finix", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ConnectorCustomerType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ConnectorCustomerType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Customer Creation Request Builder"}, {"query": "finix connector customer creation request builder implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ConnectorCustomerType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ConnectorCustomerType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Customer Creation Request Builder"}, {"query": "rust hyperswitch finix build_request function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ConnectorCustomerType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ConnectorCustomerType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Customer Creation Request Builder"}, {"query": "how does hyperswitch finix connector handle customer creation requests", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ConnectorCustomerType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ConnectorCustomerType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix Customer Creation Request Builder"}, {"query": "Rust function get_headers Worldline connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<Void, PaymentsCancelData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline connector headers retrieval"}, {"query": "hyperswitch Worldline cancel request headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<Void, PaymentsCancelData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline connector headers retrieval"}, {"query": "Worldline connector get_headers method source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<Void, PaymentsCancelData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline connector headers retrieval"}, {"query": "hyperswitch Rust build_headers payments cancel data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<Void, PaymentsCancelData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "function_name": "get_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline connector headers retrieval"}, {"query": "How to generate rollout keys for refund flows in UCS", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_rollout_keys\nfn build_rollout_keys(\n    merchant_id: &str,\n    connector_name: &str,\n    flow_name: &str,\n    payment_method: common_enums::PaymentMethod,\n    payment_method_type: Option<PaymentMethodType>,\n) -> String {\n    // Detect if this is a refund flow based on flow name\n    let is_refund_flow = matches!(flow_name, \"Execute\" | \"RSync\");\n\n    let rollout_key = if is_refund_flow {\n        // Refund flows: UCS_merchant_connector_flow (e.g., UCS_merchant123_stripe_Execute)\n        format!(\n            \"{}_{}_{}_{}\",\n            consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n            merchant_id,\n            connector_name,\n            flow_name\n        )\n    } else {\n        match payment_method {\n            common_enums::PaymentMethod::Wallet\n            | common_enums::PaymentMethod::BankRedirect\n            | common_enums::PaymentMethod::Voucher\n            | common_enums::PaymentMethod::PayLater => {\n                let payment_method_str = payment_method.to_string();\n                let payment_method_type_str = payment_method_type\n                    .map(|pmt| pmt.to_string())\n                    .unwrap_or_else(|| \"unknown\".to_string());\n                format!(\n                    \"{}_{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    payment_method_type_str,\n                    flow_name\n                )\n            }\n            common_enums::PaymentMethod::Card\n            | common_enums::PaymentMethod::CardRedirect\n            | common_enums::PaymentMethod::Upi\n            | common_enums::PaymentMethod::Crypto\n            | common_enums::PaymentMethod::Reward\n            | common_enums::PaymentMethod::BankDebit\n            | common_enums::PaymentMethod::RealTimePayment\n            | common_enums::PaymentMethod::BankTransfer\n            | common_enums::PaymentMethod::GiftCard\n            | common_enums::PaymentMethod::MobilePayment\n            | common_enums::PaymentMethod::NetworkToken\n            | common_enums::PaymentMethod::OpenBanking => {\n                // For other payment methods, use a generic format without specific payment method type details\n                let payment_method_str = payment_method.to_string();\n                format!(\n                    \"{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    flow_name\n                )\n            }\n        }\n    };\n\n    rollout_key\n}\n\n/// Extracts the gateway system from the payment intent's feature metadata\n/// Returns None if metadata is missing, corrupted, or doesn't contain gateway_system", "function_name": "build_rollout_keys", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS rollout key builder"}, {"query": "Rust function to build UCS rollout keys for payment methods", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_rollout_keys\nfn build_rollout_keys(\n    merchant_id: &str,\n    connector_name: &str,\n    flow_name: &str,\n    payment_method: common_enums::PaymentMethod,\n    payment_method_type: Option<PaymentMethodType>,\n) -> String {\n    // Detect if this is a refund flow based on flow name\n    let is_refund_flow = matches!(flow_name, \"Execute\" | \"RSync\");\n\n    let rollout_key = if is_refund_flow {\n        // Refund flows: UCS_merchant_connector_flow (e.g., UCS_merchant123_stripe_Execute)\n        format!(\n            \"{}_{}_{}_{}\",\n            consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n            merchant_id,\n            connector_name,\n            flow_name\n        )\n    } else {\n        match payment_method {\n            common_enums::PaymentMethod::Wallet\n            | common_enums::PaymentMethod::BankRedirect\n            | common_enums::PaymentMethod::Voucher\n            | common_enums::PaymentMethod::PayLater => {\n                let payment_method_str = payment_method.to_string();\n                let payment_method_type_str = payment_method_type\n                    .map(|pmt| pmt.to_string())\n                    .unwrap_or_else(|| \"unknown\".to_string());\n                format!(\n                    \"{}_{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    payment_method_type_str,\n                    flow_name\n                )\n            }\n            common_enums::PaymentMethod::Card\n            | common_enums::PaymentMethod::CardRedirect\n            | common_enums::PaymentMethod::Upi\n            | common_enums::PaymentMethod::Crypto\n            | common_enums::PaymentMethod::Reward\n            | common_enums::PaymentMethod::BankDebit\n            | common_enums::PaymentMethod::RealTimePayment\n            | common_enums::PaymentMethod::BankTransfer\n            | common_enums::PaymentMethod::GiftCard\n            | common_enums::PaymentMethod::MobilePayment\n            | common_enums::PaymentMethod::NetworkToken\n            | common_enums::PaymentMethod::OpenBanking => {\n                // For other payment methods, use a generic format without specific payment method type details\n                let payment_method_str = payment_method.to_string();\n                format!(\n                    \"{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    flow_name\n                )\n            }\n        }\n    };\n\n    rollout_key\n}\n\n/// Extracts the gateway system from the payment intent's feature metadata\n/// Returns None if metadata is missing, corrupted, or doesn't contain gateway_system", "function_name": "build_rollout_keys", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS rollout key builder"}, {"query": "Implementation of build_rollout_keys for merchant connector routing", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_rollout_keys\nfn build_rollout_keys(\n    merchant_id: &str,\n    connector_name: &str,\n    flow_name: &str,\n    payment_method: common_enums::PaymentMethod,\n    payment_method_type: Option<PaymentMethodType>,\n) -> String {\n    // Detect if this is a refund flow based on flow name\n    let is_refund_flow = matches!(flow_name, \"Execute\" | \"RSync\");\n\n    let rollout_key = if is_refund_flow {\n        // Refund flows: UCS_merchant_connector_flow (e.g., UCS_merchant123_stripe_Execute)\n        format!(\n            \"{}_{}_{}_{}\",\n            consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n            merchant_id,\n            connector_name,\n            flow_name\n        )\n    } else {\n        match payment_method {\n            common_enums::PaymentMethod::Wallet\n            | common_enums::PaymentMethod::BankRedirect\n            | common_enums::PaymentMethod::Voucher\n            | common_enums::PaymentMethod::PayLater => {\n                let payment_method_str = payment_method.to_string();\n                let payment_method_type_str = payment_method_type\n                    .map(|pmt| pmt.to_string())\n                    .unwrap_or_else(|| \"unknown\".to_string());\n                format!(\n                    \"{}_{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    payment_method_type_str,\n                    flow_name\n                )\n            }\n            common_enums::PaymentMethod::Card\n            | common_enums::PaymentMethod::CardRedirect\n            | common_enums::PaymentMethod::Upi\n            | common_enums::PaymentMethod::Crypto\n            | common_enums::PaymentMethod::Reward\n            | common_enums::PaymentMethod::BankDebit\n            | common_enums::PaymentMethod::RealTimePayment\n            | common_enums::PaymentMethod::BankTransfer\n            | common_enums::PaymentMethod::GiftCard\n            | common_enums::PaymentMethod::MobilePayment\n            | common_enums::PaymentMethod::NetworkToken\n            | common_enums::PaymentMethod::OpenBanking => {\n                // For other payment methods, use a generic format without specific payment method type details\n                let payment_method_str = payment_method.to_string();\n                format!(\n                    \"{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    flow_name\n                )\n            }\n        }\n    };\n\n    rollout_key\n}\n\n/// Extracts the gateway system from the payment intent's feature metadata\n/// Returns None if metadata is missing, corrupted, or doesn't contain gateway_system", "function_name": "build_rollout_keys", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS rollout key builder"}, {"query": "Code for constructing rollout keys with payment method types", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_rollout_keys\nfn build_rollout_keys(\n    merchant_id: &str,\n    connector_name: &str,\n    flow_name: &str,\n    payment_method: common_enums::PaymentMethod,\n    payment_method_type: Option<PaymentMethodType>,\n) -> String {\n    // Detect if this is a refund flow based on flow name\n    let is_refund_flow = matches!(flow_name, \"Execute\" | \"RSync\");\n\n    let rollout_key = if is_refund_flow {\n        // Refund flows: UCS_merchant_connector_flow (e.g., UCS_merchant123_stripe_Execute)\n        format!(\n            \"{}_{}_{}_{}\",\n            consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n            merchant_id,\n            connector_name,\n            flow_name\n        )\n    } else {\n        match payment_method {\n            common_enums::PaymentMethod::Wallet\n            | common_enums::PaymentMethod::BankRedirect\n            | common_enums::PaymentMethod::Voucher\n            | common_enums::PaymentMethod::PayLater => {\n                let payment_method_str = payment_method.to_string();\n                let payment_method_type_str = payment_method_type\n                    .map(|pmt| pmt.to_string())\n                    .unwrap_or_else(|| \"unknown\".to_string());\n                format!(\n                    \"{}_{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    payment_method_type_str,\n                    flow_name\n                )\n            }\n            common_enums::PaymentMethod::Card\n            | common_enums::PaymentMethod::CardRedirect\n            | common_enums::PaymentMethod::Upi\n            | common_enums::PaymentMethod::Crypto\n            | common_enums::PaymentMethod::Reward\n            | common_enums::PaymentMethod::BankDebit\n            | common_enums::PaymentMethod::RealTimePayment\n            | common_enums::PaymentMethod::BankTransfer\n            | common_enums::PaymentMethod::GiftCard\n            | common_enums::PaymentMethod::MobilePayment\n            | common_enums::PaymentMethod::NetworkToken\n            | common_enums::PaymentMethod::OpenBanking => {\n                // For other payment methods, use a generic format without specific payment method type details\n                let payment_method_str = payment_method.to_string();\n                format!(\n                    \"{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    flow_name\n                )\n            }\n        }\n    };\n\n    rollout_key\n}\n\n/// Extracts the gateway system from the payment intent's feature metadata\n/// Returns None if metadata is missing, corrupted, or doesn't contain gateway_system", "function_name": "build_rollout_keys", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "UCS rollout key builder"}, {"query": "how to check if payment method supports mandate in hyperswitch airwallex connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([PaymentMethodDataType::Card]);\n        connector_utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Mandate validation gatekeeper"}, {"query": "airwallex mandate validation function implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([PaymentMethodDataType::Card]);\n        connector_utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Mandate validation gatekeeper"}, {"query": "validate_mandate_payment airwallex connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([PaymentMethodDataType::Card]);\n        connector_utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Mandate validation gatekeeper"}, {"query": "is_mandate_supported airwallex connector utils", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([PaymentMethodDataType::Card]);\n        connector_utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n", "function_name": "validate_mandate_payment", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Mandate validation gatekeeper"}, {"query": "how to handle Netcetera payment gateway error responses in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: netcetera::NetceteraErrorResponse = res\n            .response\n            .parse_struct(\"NetceteraErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_details.error_code,\n            message: response.error_details.error_description,\n            reason: response.error_details.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera error response handler"}, {"query": "Netcetera connector error response mapping function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: netcetera::NetceteraErrorResponse = res\n            .response\n            .parse_struct(\"NetceteraErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_details.error_code,\n            message: response.error_details.error_description,\n            reason: response.error_details.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera error response handler"}, {"query": "build_error_response function netcetera hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: netcetera::NetceteraErrorResponse = res\n            .response\n            .parse_struct(\"NetceteraErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_details.error_code,\n            message: response.error_details.error_description,\n            reason: response.error_details.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera error response handler"}, {"query": "convert netcetera api error to hyperswitch ErrorResponse", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: netcetera::NetceteraErrorResponse = res\n            .response\n            .parse_struct(\"NetceteraErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_details.error_code,\n            message: response.error_details.error_description,\n            reason: response.error_details.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera error response handler"}, {"query": "how to handle boku response in hyperswitch rust connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response_data = String::from_utf8(res.response.to_vec())\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        let response = response_data\n            .parse_xml::<boku::BokuResponse>()\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku response handler"}, {"query": "boku authorize response parsing hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response_data = String::from_utf8(res.response.to_vec())\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        let response = response_data\n            .parse_xml::<boku::BokuResponse>()\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku response handler"}, {"query": "rust connector handle_response boku xml", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response_data = String::from_utf8(res.response.to_vec())\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        let response = response_data\n            .parse_xml::<boku::BokuResponse>()\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku response handler"}, {"query": "hyperswitch boku connector integration example", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response_data = String::from_utf8(res.response.to_vec())\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        let response = response_data\n            .parse_xml::<boku::BokuResponse>()\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku response handler"}, {"query": "how to implement Juspay 3DS server connector in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: api\nimpl api::UasProcessWebhook for Juspaythreedsserver {}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticate,\n        UasPreAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PostAuthenticate,\n        UasPostAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        AuthenticationConfirmation,\n        UasConfirmationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        ProcessIncomingWebhook,\n        UasWebhookRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n", "function_name": "api", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server Integration"}, {"query": "Juspaythreedsserver webhook verification implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: api\nimpl api::UasProcessWebhook for Juspaythreedsserver {}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticate,\n        UasPreAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PostAuthenticate,\n        UasPostAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        AuthenticationConfirmation,\n        UasConfirmationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        ProcessIncomingWebhook,\n        UasWebhookRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n", "function_name": "api", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server Integration"}, {"query": "UasPreAuthenticationRequestData structure hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: api\nimpl api::UasProcessWebhook for Juspaythreedsserver {}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticate,\n        UasPreAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PostAuthenticate,\n        UasPostAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        AuthenticationConfirmation,\n        UasConfirmationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        ProcessIncomingWebhook,\n        UasWebhookRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n", "function_name": "api", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server Integration"}, {"query": "hyperswitch juspay 3ds server integration traits", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: api\nimpl api::UasProcessWebhook for Juspaythreedsserver {}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticate,\n        UasPreAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PostAuthenticate,\n        UasPostAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        AuthenticationConfirmation,\n        UasConfirmationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        ProcessIncomingWebhook,\n        UasWebhookRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n", "function_name": "api", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Server Integration"}, {"query": "Rust hyperswitch struct for network transaction ID and card details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndCardDetails\npub struct NetworkTransactionIdAndCardDetails {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Secret<String>,\n\n    /// The card's expiry year\n    pub card_exp_year: Secret<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    pub card_type: Option<String>,\n\n    pub card_issuing_country: Option<String>,\n\n    pub card_issuing_country_code: Option<String>,\n\n    pub bank_code: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a CIT (Customer Initiated Transaction),\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "NetworkTransactionIdAndCardDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "NetworkTransactionIdAndCardDetails struct"}, {"query": "how to store network transaction ID in hyperswitch domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndCardDetails\npub struct NetworkTransactionIdAndCardDetails {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Secret<String>,\n\n    /// The card's expiry year\n    pub card_exp_year: Secret<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    pub card_type: Option<String>,\n\n    pub card_issuing_country: Option<String>,\n\n    pub card_issuing_country_code: Option<String>,\n\n    pub bank_code: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a CIT (Customer Initiated Transaction),\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "NetworkTransactionIdAndCardDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "NetworkTransactionIdAndCardDetails struct"}, {"query": "hyperswitch off_session payment setup_future_usage network transaction id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndCardDetails\npub struct NetworkTransactionIdAndCardDetails {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Secret<String>,\n\n    /// The card's expiry year\n    pub card_exp_year: Secret<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    pub card_type: Option<String>,\n\n    pub card_issuing_country: Option<String>,\n\n    pub card_issuing_country_code: Option<String>,\n\n    pub bank_code: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a CIT (Customer Initiated Transaction),\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "NetworkTransactionIdAndCardDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "NetworkTransactionIdAndCardDetails struct"}, {"query": "Rust Secret type usage for card details in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndCardDetails\npub struct NetworkTransactionIdAndCardDetails {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Secret<String>,\n\n    /// The card's expiry year\n    pub card_exp_year: Secret<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    pub card_type: Option<String>,\n\n    pub card_issuing_country: Option<String>,\n\n    pub card_issuing_country_code: Option<String>,\n\n    pub bank_code: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a CIT (Customer Initiated Transaction),\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "function_name": "NetworkTransactionIdAndCardDetails", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "unit_type": "function", "label": "NetworkTransactionIdAndCardDetails struct"}, {"query": "How to extract gateway system from payment intent feature metadata in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: extract_gateway_system_from_payment_intent\npub fn extract_gateway_system_from_payment_intent<F: Clone, D>(\n    payment_data: &D,\n) -> Option<GatewaySystem>\nwhere\n    D: OperationSessionGetters<F>,\n{\n    #[cfg(feature = \"v1\")]\n    {\n        payment_data\n            .get_payment_intent()\n            .feature_metadata\n            .as_ref()\n            .and_then(|metadata| {\n                // Try to parse the JSON value as FeatureMetadata\n                // Log errors but don't fail the flow for corrupted metadata\n                match serde_json::from_value::<FeatureMetadata>(metadata.clone()) {\n                    Ok(feature_metadata) => feature_metadata.gateway_system,\n                    Err(err) => {\n                        router_env::logger::warn!(\n                            \"Failed to parse feature_metadata for gateway_system extraction: {}\",\n                            err\n                        );\n                        None\n                    }\n                }\n            })\n    }\n    #[cfg(feature = \"v2\")]\n    {\n        None // V2 does not use feature metadata for gateway system tracking\n    }\n}\n\n/// Updates the payment intent's feature metadata to track the gateway system being used\n#[cfg(feature = \"v1\")]", "function_name": "extract_gateway_system_from_payment_intent", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Extract gateway system from payment intent metadata"}, {"query": "Rust function to get gateway system from payment intent feature metadata", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: extract_gateway_system_from_payment_intent\npub fn extract_gateway_system_from_payment_intent<F: Clone, D>(\n    payment_data: &D,\n) -> Option<GatewaySystem>\nwhere\n    D: OperationSessionGetters<F>,\n{\n    #[cfg(feature = \"v1\")]\n    {\n        payment_data\n            .get_payment_intent()\n            .feature_metadata\n            .as_ref()\n            .and_then(|metadata| {\n                // Try to parse the JSON value as FeatureMetadata\n                // Log errors but don't fail the flow for corrupted metadata\n                match serde_json::from_value::<FeatureMetadata>(metadata.clone()) {\n                    Ok(feature_metadata) => feature_metadata.gateway_system,\n                    Err(err) => {\n                        router_env::logger::warn!(\n                            \"Failed to parse feature_metadata for gateway_system extraction: {}\",\n                            err\n                        );\n                        None\n                    }\n                }\n            })\n    }\n    #[cfg(feature = \"v2\")]\n    {\n        None // V2 does not use feature metadata for gateway system tracking\n    }\n}\n\n/// Updates the payment intent's feature metadata to track the gateway system being used\n#[cfg(feature = \"v1\")]", "function_name": "extract_gateway_system_from_payment_intent", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Extract gateway system from payment intent metadata"}, {"query": "hyperswitch extract_gateway_system_from_payment_intent implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: extract_gateway_system_from_payment_intent\npub fn extract_gateway_system_from_payment_intent<F: Clone, D>(\n    payment_data: &D,\n) -> Option<GatewaySystem>\nwhere\n    D: OperationSessionGetters<F>,\n{\n    #[cfg(feature = \"v1\")]\n    {\n        payment_data\n            .get_payment_intent()\n            .feature_metadata\n            .as_ref()\n            .and_then(|metadata| {\n                // Try to parse the JSON value as FeatureMetadata\n                // Log errors but don't fail the flow for corrupted metadata\n                match serde_json::from_value::<FeatureMetadata>(metadata.clone()) {\n                    Ok(feature_metadata) => feature_metadata.gateway_system,\n                    Err(err) => {\n                        router_env::logger::warn!(\n                            \"Failed to parse feature_metadata for gateway_system extraction: {}\",\n                            err\n                        );\n                        None\n                    }\n                }\n            })\n    }\n    #[cfg(feature = \"v2\")]\n    {\n        None // V2 does not use feature metadata for gateway system tracking\n    }\n}\n\n/// Updates the payment intent's feature metadata to track the gateway system being used\n#[cfg(feature = \"v1\")]", "function_name": "extract_gateway_system_from_payment_intent", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Extract gateway system from payment intent metadata"}, {"query": "How to parse feature metadata JSON to get gateway system in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: extract_gateway_system_from_payment_intent\npub fn extract_gateway_system_from_payment_intent<F: Clone, D>(\n    payment_data: &D,\n) -> Option<GatewaySystem>\nwhere\n    D: OperationSessionGetters<F>,\n{\n    #[cfg(feature = \"v1\")]\n    {\n        payment_data\n            .get_payment_intent()\n            .feature_metadata\n            .as_ref()\n            .and_then(|metadata| {\n                // Try to parse the JSON value as FeatureMetadata\n                // Log errors but don't fail the flow for corrupted metadata\n                match serde_json::from_value::<FeatureMetadata>(metadata.clone()) {\n                    Ok(feature_metadata) => feature_metadata.gateway_system,\n                    Err(err) => {\n                        router_env::logger::warn!(\n                            \"Failed to parse feature_metadata for gateway_system extraction: {}\",\n                            err\n                        );\n                        None\n                    }\n                }\n            })\n    }\n    #[cfg(feature = \"v2\")]\n    {\n        None // V2 does not use feature metadata for gateway system tracking\n    }\n}\n\n/// Updates the payment intent's feature metadata to track the gateway system being used\n#[cfg(feature = \"v1\")]", "function_name": "extract_gateway_system_from_payment_intent", "file": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "unit_type": "function", "label": "Extract gateway system from payment intent metadata"}, {"query": "how to configure OpenRouter settings in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: OpenRouter\npub struct OpenRouter {\n    pub dynamic_routing_enabled: bool,\n    pub static_routing_enabled: bool,\n    pub url: String,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "function_name": "OpenRouter", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "OpenRouter configuration struct"}, {"query": "hyperswitch OpenRouter struct definition and fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: OpenRouter\npub struct OpenRouter {\n    pub dynamic_routing_enabled: bool,\n    pub static_routing_enabled: bool,\n    pub url: String,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "function_name": "OpenRouter", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "OpenRouter configuration struct"}, {"query": "enable dynamic routing in hyperswitch router configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: OpenRouter\npub struct OpenRouter {\n    pub dynamic_routing_enabled: bool,\n    pub static_routing_enabled: bool,\n    pub url: String,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "function_name": "OpenRouter", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "OpenRouter configuration struct"}, {"query": "hyperswitch router OpenRouter URL configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: OpenRouter\npub struct OpenRouter {\n    pub dynamic_routing_enabled: bool,\n    pub static_routing_enabled: bool,\n    pub url: String,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "function_name": "OpenRouter", "file": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "unit_type": "function", "label": "OpenRouter configuration struct"}, {"query": "rust nordea connector handle_response function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &AccessTokenAuthenticationRouterData,\n        _event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<AccessTokenAuthenticationRouterData, errors::ConnectorError> {\n        // Handle 302 redirect response\n        if res.status_code == 302 {\n            // Extract Location header\n            let headers =\n                res.headers\n                    .as_ref()\n                    .ok_or(errors::ConnectorError::MissingRequiredField {\n                        field_name: \"headers\",\n                    })?;\n            let location_header = headers\n                .get(\"Location\")\n                .map(|value| value.to_str())\n                .and_then(|location_value| location_value.ok())\n                .ok_or(errors::ConnectorError::ParsingFailed)?;\n\n            // Parse auth code from query params\n            let url = Url::parse(location_header)\n                .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n            let code = url\n                .query_pairs()\n                .find(|(key, _)| key == \"code\")\n                .map(|(_, value)| value.to_string())\n                .ok_or(errors::ConnectorError::MissingRequiredField { field_name: \"code\" })?;\n\n            // Return auth code as \"token\" with short expiry\n            Ok(RouterData {\n                response: Ok(AccessTokenAuthenticationResponse {\n                    code: Secret::new(code),\n                    expires: 60, // 60 seconds - auth code validity\n                }),\n                ..data.clone()\n            })\n        } else {\n            Err(\n                errors::ConnectorError::UnexpectedResponseError(\"Expected 302 redirect\".into())\n                    .into(),\n            )\n        }\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea OAuth 302 redirect handler"}, {"query": "how does handle_response extract code from 302 redirect in nordea", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &AccessTokenAuthenticationRouterData,\n        _event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<AccessTokenAuthenticationRouterData, errors::ConnectorError> {\n        // Handle 302 redirect response\n        if res.status_code == 302 {\n            // Extract Location header\n            let headers =\n                res.headers\n                    .as_ref()\n                    .ok_or(errors::ConnectorError::MissingRequiredField {\n                        field_name: \"headers\",\n                    })?;\n            let location_header = headers\n                .get(\"Location\")\n                .map(|value| value.to_str())\n                .and_then(|location_value| location_value.ok())\n                .ok_or(errors::ConnectorError::ParsingFailed)?;\n\n            // Parse auth code from query params\n            let url = Url::parse(location_header)\n                .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n            let code = url\n                .query_pairs()\n                .find(|(key, _)| key == \"code\")\n                .map(|(_, value)| value.to_string())\n                .ok_or(errors::ConnectorError::MissingRequiredField { field_name: \"code\" })?;\n\n            // Return auth code as \"token\" with short expiry\n            Ok(RouterData {\n                response: Ok(AccessTokenAuthenticationResponse {\n                    code: Secret::new(code),\n                    expires: 60, // 60 seconds - auth code validity\n                }),\n                ..data.clone()\n            })\n        } else {\n            Err(\n                errors::ConnectorError::UnexpectedResponseError(\"Expected 302 redirect\".into())\n                    .into(),\n            )\n        }\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea OAuth 302 redirect handler"}, {"query": "nordea oauth authorization code flow handle_response rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &AccessTokenAuthenticationRouterData,\n        _event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<AccessTokenAuthenticationRouterData, errors::ConnectorError> {\n        // Handle 302 redirect response\n        if res.status_code == 302 {\n            // Extract Location header\n            let headers =\n                res.headers\n                    .as_ref()\n                    .ok_or(errors::ConnectorError::MissingRequiredField {\n                        field_name: \"headers\",\n                    })?;\n            let location_header = headers\n                .get(\"Location\")\n                .map(|value| value.to_str())\n                .and_then(|location_value| location_value.ok())\n                .ok_or(errors::ConnectorError::ParsingFailed)?;\n\n            // Parse auth code from query params\n            let url = Url::parse(location_header)\n                .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n            let code = url\n                .query_pairs()\n                .find(|(key, _)| key == \"code\")\n                .map(|(_, value)| value.to_string())\n                .ok_or(errors::ConnectorError::MissingRequiredField { field_name: \"code\" })?;\n\n            // Return auth code as \"token\" with short expiry\n            Ok(RouterData {\n                response: Ok(AccessTokenAuthenticationResponse {\n                    code: Secret::new(code),\n                    expires: 60, // 60 seconds - auth code validity\n                }),\n                ..data.clone()\n            })\n        } else {\n            Err(\n                errors::ConnectorError::UnexpectedResponseError(\"Expected 302 redirect\".into())\n                    .into(),\n            )\n        }\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea OAuth 302 redirect handler"}, {"query": "hyperswitch nordea connector handle_response 302 location header", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &AccessTokenAuthenticationRouterData,\n        _event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<AccessTokenAuthenticationRouterData, errors::ConnectorError> {\n        // Handle 302 redirect response\n        if res.status_code == 302 {\n            // Extract Location header\n            let headers =\n                res.headers\n                    .as_ref()\n                    .ok_or(errors::ConnectorError::MissingRequiredField {\n                        field_name: \"headers\",\n                    })?;\n            let location_header = headers\n                .get(\"Location\")\n                .map(|value| value.to_str())\n                .and_then(|location_value| location_value.ok())\n                .ok_or(errors::ConnectorError::ParsingFailed)?;\n\n            // Parse auth code from query params\n            let url = Url::parse(location_header)\n                .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n            let code = url\n                .query_pairs()\n                .find(|(key, _)| key == \"code\")\n                .map(|(_, value)| value.to_string())\n                .ok_or(errors::ConnectorError::MissingRequiredField { field_name: \"code\" })?;\n\n            // Return auth code as \"token\" with short expiry\n            Ok(RouterData {\n                response: Ok(AccessTokenAuthenticationResponse {\n                    code: Secret::new(code),\n                    expires: 60, // 60 seconds - auth code validity\n                }),\n                ..data.clone()\n            })\n        } else {\n            Err(\n                errors::ConnectorError::UnexpectedResponseError(\"Expected 302 redirect\".into())\n                    .into(),\n            )\n        }\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Nordea OAuth 302 redirect handler"}, {"query": "how to mask sensitive keys in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: mask_key\n    fn mask_key(&self, key: String) -> Secret<String> {\n        let key_len = key.len();\n        let masked_key = if key_len <= 4 {\n            \"*\".repeat(key_len)\n        } else {\n            // Show the first two and last two characters, mask the rest with '*'\n            let mut masked_key = String::new();\n            let key_len = key.len();\n            // Iterate through characters by their index\n            for (index, character) in key.chars().enumerate() {\n                if index < 2 || index >= key_len - 2 {\n                    masked_key.push(character); // Keep the first two and last two characters\n                } else {\n                    masked_key.push('*'); // Mask the middle characters\n                }\n            }\n            masked_key\n        };\n        Secret::new(masked_key)\n    }\n\n    // Mask the keys in the auth_type", "function_name": "mask_key", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Secure key masking utility"}, {"query": "hyperswitch domain models mask_key function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: mask_key\n    fn mask_key(&self, key: String) -> Secret<String> {\n        let key_len = key.len();\n        let masked_key = if key_len <= 4 {\n            \"*\".repeat(key_len)\n        } else {\n            // Show the first two and last two characters, mask the rest with '*'\n            let mut masked_key = String::new();\n            let key_len = key.len();\n            // Iterate through characters by their index\n            for (index, character) in key.chars().enumerate() {\n                if index < 2 || index >= key_len - 2 {\n                    masked_key.push(character); // Keep the first two and last two characters\n                } else {\n                    masked_key.push('*'); // Mask the middle characters\n                }\n            }\n            masked_key\n        };\n        Secret::new(masked_key)\n    }\n\n    // Mask the keys in the auth_type", "function_name": "mask_key", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Secure key masking utility"}, {"query": "rust function to hide middle characters of string", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: mask_key\n    fn mask_key(&self, key: String) -> Secret<String> {\n        let key_len = key.len();\n        let masked_key = if key_len <= 4 {\n            \"*\".repeat(key_len)\n        } else {\n            // Show the first two and last two characters, mask the rest with '*'\n            let mut masked_key = String::new();\n            let key_len = key.len();\n            // Iterate through characters by their index\n            for (index, character) in key.chars().enumerate() {\n                if index < 2 || index >= key_len - 2 {\n                    masked_key.push(character); // Keep the first two and last two characters\n                } else {\n                    masked_key.push('*'); // Mask the middle characters\n                }\n            }\n            masked_key\n        };\n        Secret::new(masked_key)\n    }\n\n    // Mask the keys in the auth_type", "function_name": "mask_key", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Secure key masking utility"}, {"query": "hyperswitch secret string masking utility", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: mask_key\n    fn mask_key(&self, key: String) -> Secret<String> {\n        let key_len = key.len();\n        let masked_key = if key_len <= 4 {\n            \"*\".repeat(key_len)\n        } else {\n            // Show the first two and last two characters, mask the rest with '*'\n            let mut masked_key = String::new();\n            let key_len = key.len();\n            // Iterate through characters by their index\n            for (index, character) in key.chars().enumerate() {\n                if index < 2 || index >= key_len - 2 {\n                    masked_key.push(character); // Keep the first two and last two characters\n                } else {\n                    masked_key.push('*'); // Mask the middle characters\n                }\n            }\n            masked_key\n        };\n        Secret::new(masked_key)\n    }\n\n    // Mask the keys in the auth_type", "function_name": "mask_key", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "Secure key masking utility"}, {"query": "Elavon XML response deserialization struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: XmlResponse\n        struct XmlResponse {\n            // Error fields\n            #[serde(rename = \"errorCode\", default)]\n            error_code: Option<String>,\n            #[serde(rename = \"errorMessage\", default)]\n            error_message: Option<String>,\n            #[serde(rename = \"errorName\", default)]\n            error_name: Option<String>,\n\n            // Success fields\n            #[serde(rename = \"ssl_result\", default)]\n            ssl_result: Option<SslResult>,\n            #[serde(rename = \"ssl_txn_id\", default)]\n            ssl_txn_id: Option<String>,\n            #[serde(rename = \"ssl_result_message\", default)]\n            ssl_result_message: Option<String>,\n            #[serde(rename = \"ssl_token\", default)]\n            ssl_token: Option<Secret<String>>,\n        }\n\n        let xml_res = XmlResponse::deserialize(deserializer)?;\n\n        let result = match (xml_res.error_message.clone(), xml_res.error_name.clone()) {\n            (Some(error_message), Some(error_name)) => ElavonResult::Error(ElavonErrorResponse {\n                error_code: xml_res.error_code.clone(),\n                error_message,\n                error_name,\n            }),\n            _ => {\n                if let (Some(ssl_result), Some(ssl_txn_id), Some(ssl_result_message)) = (\n                    xml_res.ssl_result.clone(),\n                    xml_res.ssl_txn_id.clone(),\n                    xml_res.ssl_result_message.clone(),\n                ) {\n                    ElavonResult::Success(PaymentResponse {\n                        ssl_result,\n                        ssl_txn_id,\n                        ssl_result_message,\n                        ssl_token: xml_res.ssl_token.clone(),\n                    })\n                } else {\n                    return Err(serde::de::Error::custom(\n                        \"Invalid Response XML structure - neither error nor success\",\n                    ));\n                }\n            }\n        };\n\n        Ok(Self { result })\n    }\n}", "function_name": "XmlResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon XML response deserializer"}, {"query": "Rust struct for Elavon payment gateway response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: XmlResponse\n        struct XmlResponse {\n            // Error fields\n            #[serde(rename = \"errorCode\", default)]\n            error_code: Option<String>,\n            #[serde(rename = \"errorMessage\", default)]\n            error_message: Option<String>,\n            #[serde(rename = \"errorName\", default)]\n            error_name: Option<String>,\n\n            // Success fields\n            #[serde(rename = \"ssl_result\", default)]\n            ssl_result: Option<SslResult>,\n            #[serde(rename = \"ssl_txn_id\", default)]\n            ssl_txn_id: Option<String>,\n            #[serde(rename = \"ssl_result_message\", default)]\n            ssl_result_message: Option<String>,\n            #[serde(rename = \"ssl_token\", default)]\n            ssl_token: Option<Secret<String>>,\n        }\n\n        let xml_res = XmlResponse::deserialize(deserializer)?;\n\n        let result = match (xml_res.error_message.clone(), xml_res.error_name.clone()) {\n            (Some(error_message), Some(error_name)) => ElavonResult::Error(ElavonErrorResponse {\n                error_code: xml_res.error_code.clone(),\n                error_message,\n                error_name,\n            }),\n            _ => {\n                if let (Some(ssl_result), Some(ssl_txn_id), Some(ssl_result_message)) = (\n                    xml_res.ssl_result.clone(),\n                    xml_res.ssl_txn_id.clone(),\n                    xml_res.ssl_result_message.clone(),\n                ) {\n                    ElavonResult::Success(PaymentResponse {\n                        ssl_result,\n                        ssl_txn_id,\n                        ssl_result_message,\n                        ssl_token: xml_res.ssl_token.clone(),\n                    })\n                } else {\n                    return Err(serde::de::Error::custom(\n                        \"Invalid Response XML structure - neither error nor success\",\n                    ));\n                }\n            }\n        };\n\n        Ok(Self { result })\n    }\n}", "function_name": "XmlResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon XML response deserializer"}, {"query": "XmlResponse deserialize Elavon connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: XmlResponse\n        struct XmlResponse {\n            // Error fields\n            #[serde(rename = \"errorCode\", default)]\n            error_code: Option<String>,\n            #[serde(rename = \"errorMessage\", default)]\n            error_message: Option<String>,\n            #[serde(rename = \"errorName\", default)]\n            error_name: Option<String>,\n\n            // Success fields\n            #[serde(rename = \"ssl_result\", default)]\n            ssl_result: Option<SslResult>,\n            #[serde(rename = \"ssl_txn_id\", default)]\n            ssl_txn_id: Option<String>,\n            #[serde(rename = \"ssl_result_message\", default)]\n            ssl_result_message: Option<String>,\n            #[serde(rename = \"ssl_token\", default)]\n            ssl_token: Option<Secret<String>>,\n        }\n\n        let xml_res = XmlResponse::deserialize(deserializer)?;\n\n        let result = match (xml_res.error_message.clone(), xml_res.error_name.clone()) {\n            (Some(error_message), Some(error_name)) => ElavonResult::Error(ElavonErrorResponse {\n                error_code: xml_res.error_code.clone(),\n                error_message,\n                error_name,\n            }),\n            _ => {\n                if let (Some(ssl_result), Some(ssl_txn_id), Some(ssl_result_message)) = (\n                    xml_res.ssl_result.clone(),\n                    xml_res.ssl_txn_id.clone(),\n                    xml_res.ssl_result_message.clone(),\n                ) {\n                    ElavonResult::Success(PaymentResponse {\n                        ssl_result,\n                        ssl_txn_id,\n                        ssl_result_message,\n                        ssl_token: xml_res.ssl_token.clone(),\n                    })\n                } else {\n                    return Err(serde::de::Error::custom(\n                        \"Invalid Response XML structure - neither error nor success\",\n                    ));\n                }\n            }\n        };\n\n        Ok(Self { result })\n    }\n}", "function_name": "XmlResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon XML response deserializer"}, {"query": "ElavonResult mapping from XML response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: XmlResponse\n        struct XmlResponse {\n            // Error fields\n            #[serde(rename = \"errorCode\", default)]\n            error_code: Option<String>,\n            #[serde(rename = \"errorMessage\", default)]\n            error_message: Option<String>,\n            #[serde(rename = \"errorName\", default)]\n            error_name: Option<String>,\n\n            // Success fields\n            #[serde(rename = \"ssl_result\", default)]\n            ssl_result: Option<SslResult>,\n            #[serde(rename = \"ssl_txn_id\", default)]\n            ssl_txn_id: Option<String>,\n            #[serde(rename = \"ssl_result_message\", default)]\n            ssl_result_message: Option<String>,\n            #[serde(rename = \"ssl_token\", default)]\n            ssl_token: Option<Secret<String>>,\n        }\n\n        let xml_res = XmlResponse::deserialize(deserializer)?;\n\n        let result = match (xml_res.error_message.clone(), xml_res.error_name.clone()) {\n            (Some(error_message), Some(error_name)) => ElavonResult::Error(ElavonErrorResponse {\n                error_code: xml_res.error_code.clone(),\n                error_message,\n                error_name,\n            }),\n            _ => {\n                if let (Some(ssl_result), Some(ssl_txn_id), Some(ssl_result_message)) = (\n                    xml_res.ssl_result.clone(),\n                    xml_res.ssl_txn_id.clone(),\n                    xml_res.ssl_result_message.clone(),\n                ) {\n                    ElavonResult::Success(PaymentResponse {\n                        ssl_result,\n                        ssl_txn_id,\n                        ssl_result_message,\n                        ssl_token: xml_res.ssl_token.clone(),\n                    })\n                } else {\n                    return Err(serde::de::Error::custom(\n                        \"Invalid Response XML structure - neither error nor success\",\n                    ));\n                }\n            }\n        };\n\n        Ok(Self { result })\n    }\n}", "function_name": "XmlResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon XML response deserializer"}, {"query": "rust from trait implementation for Archipel struct initialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: from\n    fn from((amount, tenant_id, router_data): (MinorUnit, ArchipelTenantId, T)) -> Self {\n        Self {\n            amount,\n            tenant_id,\n            router_data,\n        }\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel struct From trait implementation"}, {"query": "how to convert tuple to Archipel struct in hyperswitch connectors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: from\n    fn from((amount, tenant_id, router_data): (MinorUnit, ArchipelTenantId, T)) -> Self {\n        Self {\n            amount,\n            tenant_id,\n            router_data,\n        }\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel struct From trait implementation"}, {"query": "Archipel struct constructor from amount tenant_id router_data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: from\n    fn from((amount, tenant_id, router_data): (MinorUnit, ArchipelTenantId, T)) -> Self {\n        Self {\n            amount,\n            tenant_id,\n            router_data,\n        }\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel struct From trait implementation"}, {"query": "hyperswitch archipel connector data transformation from tuple", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: from\n    fn from((amount, tenant_id, router_data): (MinorUnit, ArchipelTenantId, T)) -> Self {\n        Self {\n            amount,\n            tenant_id,\n            router_data,\n        }\n    }\n}\n", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel struct From trait implementation"}, {"query": "how to handle RS256 algorithm string parsing in TokenIO connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: try_from\n    fn try_from(s: &str) -> Result<Self, Self::Error> {\n        match s.to_uppercase().as_str() {\n            \"RS256\" | \"rs256\" => Ok(Self::RS256),\n            \"ES256\" | \"es256\" => Ok(Self::ES256),\n            \"EDDSA\" | \"eddsa\" | \"EdDSA\" => Ok(Self::EDDSA),\n            _ => Err(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"Unsupported key algorithm. Select from RS256, ES256, EdDSA\",\n            }\n            .into()),\n        }\n    }\n}", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "TokenIO algorithm enum conversion"}, {"query": "rust try_from implementation for JWT algorithm constants", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: try_from\n    fn try_from(s: &str) -> Result<Self, Self::Error> {\n        match s.to_uppercase().as_str() {\n            \"RS256\" | \"rs256\" => Ok(Self::RS256),\n            \"ES256\" | \"es256\" => Ok(Self::ES256),\n            \"EDDSA\" | \"eddsa\" | \"EdDSA\" => Ok(Self::EDDSA),\n            _ => Err(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"Unsupported key algorithm. Select from RS256, ES256, EdDSA\",\n            }\n            .into()),\n        }\n    }\n}", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "TokenIO algorithm enum conversion"}, {"query": "TokenIO connector error handling for unsupported key algorithms", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: try_from\n    fn try_from(s: &str) -> Result<Self, Self::Error> {\n        match s.to_uppercase().as_str() {\n            \"RS256\" | \"rs256\" => Ok(Self::RS256),\n            \"ES256\" | \"es256\" => Ok(Self::ES256),\n            \"EDDSA\" | \"eddsa\" | \"EdDSA\" => Ok(Self::EDDSA),\n            _ => Err(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"Unsupported key algorithm. Select from RS256, ES256, EdDSA\",\n            }\n            .into()),\n        }\n    }\n}", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "TokenIO algorithm enum conversion"}, {"query": "convert string to algorithm enum RS256 ES256 EDDSA", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: try_from\n    fn try_from(s: &str) -> Result<Self, Self::Error> {\n        match s.to_uppercase().as_str() {\n            \"RS256\" | \"rs256\" => Ok(Self::RS256),\n            \"ES256\" | \"es256\" => Ok(Self::ES256),\n            \"EDDSA\" | \"eddsa\" | \"EdDSA\" => Ok(Self::EDDSA),\n            _ => Err(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"Unsupported key algorithm. Select from RS256, ES256, EdDSA\",\n            }\n            .into()),\n        }\n    }\n}", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "TokenIO algorithm enum conversion"}, {"query": "rust hyperswitch list_connector_account_by_profile_id implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_connector_account_by_profile_id\n    async fn list_connector_account_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_connector_account_by_profile_id(profile_id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "list_connector_account_by_profile_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account retrieval"}, {"query": "how to get merchant connector accounts by profile id in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_connector_account_by_profile_id\n    async fn list_connector_account_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_connector_account_by_profile_id(profile_id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "list_connector_account_by_profile_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account retrieval"}, {"query": "hyperswitch router store list_connector_account_by_profile_id function", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_connector_account_by_profile_id\n    async fn list_connector_account_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_connector_account_by_profile_id(profile_id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "list_connector_account_by_profile_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account retrieval"}, {"query": "rust code for listing merchant connector accounts hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_connector_account_by_profile_id\n    async fn list_connector_account_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_connector_account_by_profile_id(profile_id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "function_name": "list_connector_account_by_profile_id", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "merchant connector account retrieval"}, {"query": "how to get preauth_transaction_id from helcim metadata", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: connector_transaction_id\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n", "function_name": "connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim preauth transaction id extractor"}, {"query": "rust function to extract connector transaction id helcim", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: connector_transaction_id\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n", "function_name": "connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim preauth transaction id extractor"}, {"query": "helcim connector preauth transaction id mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: connector_transaction_id\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n", "function_name": "connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim preauth transaction id extractor"}, {"query": "connector_transaction_id implementation helcim rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: connector_transaction_id\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n", "function_name": "connector_transaction_id", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "helcim preauth transaction id extractor"}, {"query": "how to initialize finix connector configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: new\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector initialization"}, {"query": "rust hyperswitch finix connector setup amount conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: new\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector initialization"}, {"query": "hyperswitch finix.rs new function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: new\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector initialization"}, {"query": "configure minor unit for connector in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: new\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\n", "function_name": "new", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "unit_type": "function", "label": "Finix connector initialization"}, {"query": "how to get request body from PreAuthNRouterData in netcetera connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PreAuthNRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = netcetera::NetceteraRouterData::try_from((0, req))?;\n        let req_obj =\n            netcetera::NetceteraPreAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera pre-auth request body extraction"}, {"query": "rust code for extracting NetceteraPreAuthenticationRequest from router data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PreAuthNRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = netcetera::NetceteraRouterData::try_from((0, req))?;\n        let req_obj =\n            netcetera::NetceteraPreAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera pre-auth request body extraction"}, {"query": "hyperswitch netcetera connector get_request_body implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PreAuthNRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = netcetera::NetceteraRouterData::try_from((0, req))?;\n        let req_obj =\n            netcetera::NetceteraPreAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera pre-auth request body extraction"}, {"query": "convert PreAuthNRouterData to NetceteraPreAuthenticationRequest in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PreAuthNRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = netcetera::NetceteraRouterData::try_from((0, req))?;\n        let req_obj =\n            netcetera::NetceteraPreAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera pre-auth request body extraction"}, {"query": "Rust struct definition for PaymentsUpdateMetadataData hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsUpdateMetadataData\npub struct PaymentsUpdateMetadataData {\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub connector_transaction_id: String,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n    pub payment_method_data: Option<PaymentMethodData>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "PaymentsUpdateMetadataData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsUpdateMetadataData struct definition"}, {"query": "hyperswitch router update payment metadata struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsUpdateMetadataData\npub struct PaymentsUpdateMetadataData {\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub connector_transaction_id: String,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n    pub payment_method_data: Option<PaymentMethodData>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "PaymentsUpdateMetadataData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsUpdateMetadataData struct definition"}, {"query": "PaymentsUpdateMetadataData pii::SecretSerdeValue connector_transaction_id", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsUpdateMetadataData\npub struct PaymentsUpdateMetadataData {\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub connector_transaction_id: String,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n    pub payment_method_data: Option<PaymentMethodData>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "PaymentsUpdateMetadataData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsUpdateMetadataData struct definition"}, {"query": "how to update payment metadata in hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsUpdateMetadataData\npub struct PaymentsUpdateMetadataData {\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub connector_transaction_id: String,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n    pub payment_method_data: Option<PaymentMethodData>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "function_name": "PaymentsUpdateMetadataData", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "PaymentsUpdateMetadataData struct definition"}, {"query": "Elavon mandate payment request struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: MandatePaymentRequest\npub struct MandatePaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_email: Email,\n    pub ssl_token: Secret<String>,\n}\n", "function_name": "MandatePaymentRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon mandate request struct"}, {"query": "how to construct MandatePaymentRequest for Elavon", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: MandatePaymentRequest\npub struct MandatePaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_email: Email,\n    pub ssl_token: Secret<String>,\n}\n", "function_name": "MandatePaymentRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon mandate request struct"}, {"query": "Elavon mandate payment XML payload structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: MandatePaymentRequest\npub struct MandatePaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_email: Email,\n    pub ssl_token: Secret<String>,\n}\n", "function_name": "MandatePaymentRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon mandate request struct"}, {"query": "hyperswitch mandate payment request fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: MandatePaymentRequest\npub struct MandatePaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_email: Email,\n    pub ssl_token: Secret<String>,\n}\n", "function_name": "MandatePaymentRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon mandate request struct"}, {"query": "ArchipelOrderRequest struct definition Archipel connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelOrderRequest\npub struct ArchipelOrderRequest {\n    amount: MinorUnit,\n    currency: String,\n    certainty: ArchipelPaymentCertainty,\n    initiator: ArchipelPaymentInitiator,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]", "function_name": "ArchipelOrderRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment request struct"}, {"query": "how to create ArchipelOrderRequest in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelOrderRequest\npub struct ArchipelOrderRequest {\n    amount: MinorUnit,\n    currency: String,\n    certainty: ArchipelPaymentCertainty,\n    initiator: ArchipelPaymentInitiator,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]", "function_name": "ArchipelOrderRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment request struct"}, {"query": "ArchipelOrderRequest fields amount currency certainty initiator", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelOrderRequest\npub struct ArchipelOrderRequest {\n    amount: MinorUnit,\n    currency: String,\n    certainty: ArchipelPaymentCertainty,\n    initiator: ArchipelPaymentInitiator,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]", "function_name": "ArchipelOrderRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment request struct"}, {"query": "hyperswitch archipel payment request transformer", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelOrderRequest\npub struct ArchipelOrderRequest {\n    amount: MinorUnit,\n    currency: String,\n    certainty: ArchipelPaymentCertainty,\n    initiator: ArchipelPaymentInitiator,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]", "function_name": "ArchipelOrderRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "unit_type": "function", "label": "Archipel payment request struct"}, {"query": "TokenioAuthType struct definition hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: TokenioAuthType\npub struct TokenioAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) private_key: Secret<String>,\n    pub(super) key_id: Secret<String>,\n    pub(super) key_algorithm: CryptoAlgorithm,\n}\n\n#[derive(Debug, Deserialize, PartialEq)]", "function_name": "TokenioAuthType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "TokenioAuthType struct definition"}, {"query": "hyperswitch tokenio connector authentication configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: TokenioAuthType\npub struct TokenioAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) private_key: Secret<String>,\n    pub(super) key_id: Secret<String>,\n    pub(super) key_algorithm: CryptoAlgorithm,\n}\n\n#[derive(Debug, Deserialize, PartialEq)]", "function_name": "TokenioAuthType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "TokenioAuthType struct definition"}, {"query": "how to configure TokenioAuthType in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: TokenioAuthType\npub struct TokenioAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) private_key: Secret<String>,\n    pub(super) key_id: Secret<String>,\n    pub(super) key_algorithm: CryptoAlgorithm,\n}\n\n#[derive(Debug, Deserialize, PartialEq)]", "function_name": "TokenioAuthType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "TokenioAuthType struct definition"}, {"query": "TokenioAuthType fields merchant_id private_key hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: TokenioAuthType\npub struct TokenioAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) private_key: Secret<String>,\n    pub(super) key_id: Secret<String>,\n    pub(super) key_algorithm: CryptoAlgorithm,\n}\n\n#[derive(Debug, Deserialize, PartialEq)]", "function_name": "TokenioAuthType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "TokenioAuthType struct definition"}, {"query": "rust deserialize connector response body hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response_inner\n    fn get_response_inner<T: DeserializeOwned>(self, type_name: &'static str) -> RouterResult<T> {\n        self.get_response()?\n            .response\n            .parse_struct(type_name)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n    }\n}\n\nimpl<E> ConnectorResponseExt\n    for Result<Result<types::Response, types::Response>, error_stack::Report<E>>\n{", "function_name": "get_response_inner", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Connector response deserialization utility"}, {"query": "how to parse struct from connector response hyperswitch router", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response_inner\n    fn get_response_inner<T: DeserializeOwned>(self, type_name: &'static str) -> RouterResult<T> {\n        self.get_response()?\n            .response\n            .parse_struct(type_name)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n    }\n}\n\nimpl<E> ConnectorResponseExt\n    for Result<Result<types::Response, types::Response>, error_stack::Report<E>>\n{", "function_name": "get_response_inner", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Connector response deserialization utility"}, {"query": "hyperswitch connector response_ext trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response_inner\n    fn get_response_inner<T: DeserializeOwned>(self, type_name: &'static str) -> RouterResult<T> {\n        self.get_response()?\n            .response\n            .parse_struct(type_name)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n    }\n}\n\nimpl<E> ConnectorResponseExt\n    for Result<Result<types::Response, types::Response>, error_stack::Report<E>>\n{", "function_name": "get_response_inner", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Connector response deserialization utility"}, {"query": "rust error_stack change_context parse_struct example", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response_inner\n    fn get_response_inner<T: DeserializeOwned>(self, type_name: &'static str) -> RouterResult<T> {\n        self.get_response()?\n            .response\n            .parse_struct(type_name)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n    }\n}\n\nimpl<E> ConnectorResponseExt\n    for Result<Result<types::Response, types::Response>, error_stack::Report<E>>\n{", "function_name": "get_response_inner", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Connector response deserialization utility"}, {"query": "how to handle thunes authorize response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: thunes::ThunesPaymentsResponse = res\n            .response\n            .parse_struct(\"Thunes PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes authorize response handler"}, {"query": "thunes connector response parsing rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: thunes::ThunesPaymentsResponse = res\n            .response\n            .parse_struct(\"Thunes PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes authorize response handler"}, {"query": "hyperswitch thunes handle_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: thunes::ThunesPaymentsResponse = res\n            .response\n            .parse_struct(\"Thunes PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes authorize response handler"}, {"query": "thunes payments authorize response deserialization hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: thunes::ThunesPaymentsResponse = res\n            .response\n            .parse_struct(\"Thunes PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "unit_type": "function", "label": "Thunes authorize response handler"}, {"query": "rust hyperswitch worldline connector get_error_response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline error response handler"}, {"query": "how does worldline connector handle error responses in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline error response handler"}, {"query": "hyperswitch worldline connector build_error_response method signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline error response handler"}, {"query": "rust connector error handling worldline hyperswitch get_error_response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "unit_type": "function", "label": "Worldline error response handler"}, {"query": "How to handle error responses in JuspayThreeDSConnector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "JuspayThreeDS error response handler"}, {"query": "Implement get_error_response method in Rust connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "JuspayThreeDS error response handler"}, {"query": "JuspayThreeDSConnector error handling pattern", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "JuspayThreeDS error response handler"}, {"query": "build_error_response function signature hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "JuspayThreeDS error response handler"}, {"query": "how to serialize struct to form-urlencoded in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_form_urlencoded_payload\n    fn get_form_urlencoded_payload<T: serde::Serialize>(\n        &self,\n        form_data: &T,\n    ) -> Result<Vec<u8>, error_stack::Report<errors::ConnectorError>> {\n        let json_value = serde_json::to_value(form_data)\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let btree_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_value(json_value)\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        Ok(btree_map\n            .iter()\n            .map(|(k, v)| {\n                // Remove quotes from string values for proper form encoding\n                let value = match v {\n                    serde_json::Value::String(s) => s.clone(),\n                    _ => v.to_string(),\n                };\n                format!(\"{k}={value}\")\n            })\n            .collect::<Vec<_>>()\n            .join(\"&\")\n            .into_bytes())\n    }\n}\n", "function_name": "get_form_urlencoded_payload", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Form URL Encoding Utility"}, {"query": "rust function to convert  to url encoded string", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_form_urlencoded_payload\n    fn get_form_urlencoded_payload<T: serde::Serialize>(\n        &self,\n        form_data: &T,\n    ) -> Result<Vec<u8>, error_stack::Report<errors::ConnectorError>> {\n        let json_value = serde_json::to_value(form_data)\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let btree_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_value(json_value)\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        Ok(btree_map\n            .iter()\n            .map(|(k, v)| {\n                // Remove quotes from string values for proper form encoding\n                let value = match v {\n                    serde_json::Value::String(s) => s.clone(),\n                    _ => v.to_string(),\n                };\n                format!(\"{k}={value}\")\n            })\n            .collect::<Vec<_>>()\n            .join(\"&\")\n            .into_bytes())\n    }\n}\n", "function_name": "get_form_urlencoded_payload", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Form URL Encoding Utility"}, {"query": "hyperswitch connector form data encoding utility", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_form_urlencoded_payload\n    fn get_form_urlencoded_payload<T: serde::Serialize>(\n        &self,\n        form_data: &T,\n    ) -> Result<Vec<u8>, error_stack::Report<errors::ConnectorError>> {\n        let json_value = serde_json::to_value(form_data)\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let btree_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_value(json_value)\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        Ok(btree_map\n            .iter()\n            .map(|(k, v)| {\n                // Remove quotes from string values for proper form encoding\n                let value = match v {\n                    serde_json::Value::String(s) => s.clone(),\n                    _ => v.to_string(),\n                };\n                format!(\"{k}={value}\")\n            })\n            .collect::<Vec<_>>()\n            .join(\"&\")\n            .into_bytes())\n    }\n}\n", "function_name": "get_form_urlencoded_payload", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Form URL Encoding Utility"}, {"query": "rust serialize to application/x-www-form-urlencoded", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_form_urlencoded_payload\n    fn get_form_urlencoded_payload<T: serde::Serialize>(\n        &self,\n        form_data: &T,\n    ) -> Result<Vec<u8>, error_stack::Report<errors::ConnectorError>> {\n        let json_value = serde_json::to_value(form_data)\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let btree_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_value(json_value)\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        Ok(btree_map\n            .iter()\n            .map(|(k, v)| {\n                // Remove quotes from string values for proper form encoding\n                let value = match v {\n                    serde_json::Value::String(s) => s.clone(),\n                    _ => v.to_string(),\n                };\n                format!(\"{k}={value}\")\n            })\n            .collect::<Vec<_>>()\n            .join(\"&\")\n            .into_bytes())\n    }\n}\n", "function_name": "get_form_urlencoded_payload", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "unit_type": "function", "label": "Form URL Encoding Utility"}, {"query": "how to handle redsys payment errors in hyperswitch rust connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys error response wrapper"}, {"query": "redsys connector get_error_response implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys error response wrapper"}, {"query": "hyperswitch redsys error response builder function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys error response wrapper"}, {"query": "rust connector error handling pattern hyperswitch redsys", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys error response wrapper"}, {"query": "how to generate amazon pay signature in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_signature\n    fn create_signature(\n        private_key: &Secret<String>,\n        http_method: Method,\n        canonical_uri: &str,\n        signed_headers: &str,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> Result<String, String> {\n        let mut canonical_request = http_method.to_string() + \"\\n\" + canonical_uri + \"\\n\\n\";\n\n        let mut lowercase_sorted_header_keys: Vec<String> =\n            header.iter().map(|(key, _)| key.to_lowercase()).collect();\n\n        lowercase_sorted_header_keys.sort();\n\n        for key in lowercase_sorted_header_keys {\n            if let Some((_, maskable_value)) = header.iter().find(|(k, _)| k.to_lowercase() == key)\n            {\n                let value: String = match maskable_value {\n                    Maskable::Normal(v) => v.clone(),\n                    Maskable::Masked(secret) => secret.clone().expose(),\n                };\n                canonical_request.push_str(&format!(\"{key}:{value}\\n\"));\n            }\n        }\n\n        canonical_request.push_str(&(\"\\n\".to_owned() + signed_headers + \"\\n\" + hashed_payload));\n\n        let string_to_sign = format!(\n            \"{}\\n{}\",\n            SIGNING_ALGO,\n            hex::encode(Sha256::digest(canonical_request.as_bytes()))\n        );\n\n        Self::sign(private_key, &string_to_sign)\n            .map_err(|e| format!(\"Failed to create signature: {e}\"))\n    }\n", "function_name": "create_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Signature V4"}, {"query": "hyperswitch amazonpay connector signature creation function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_signature\n    fn create_signature(\n        private_key: &Secret<String>,\n        http_method: Method,\n        canonical_uri: &str,\n        signed_headers: &str,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> Result<String, String> {\n        let mut canonical_request = http_method.to_string() + \"\\n\" + canonical_uri + \"\\n\\n\";\n\n        let mut lowercase_sorted_header_keys: Vec<String> =\n            header.iter().map(|(key, _)| key.to_lowercase()).collect();\n\n        lowercase_sorted_header_keys.sort();\n\n        for key in lowercase_sorted_header_keys {\n            if let Some((_, maskable_value)) = header.iter().find(|(k, _)| k.to_lowercase() == key)\n            {\n                let value: String = match maskable_value {\n                    Maskable::Normal(v) => v.clone(),\n                    Maskable::Masked(secret) => secret.clone().expose(),\n                };\n                canonical_request.push_str(&format!(\"{key}:{value}\\n\"));\n            }\n        }\n\n        canonical_request.push_str(&(\"\\n\".to_owned() + signed_headers + \"\\n\" + hashed_payload));\n\n        let string_to_sign = format!(\n            \"{}\\n{}\",\n            SIGNING_ALGO,\n            hex::encode(Sha256::digest(canonical_request.as_bytes()))\n        );\n\n        Self::sign(private_key, &string_to_sign)\n            .map_err(|e| format!(\"Failed to create signature: {e}\"))\n    }\n", "function_name": "create_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Signature V4"}, {"query": "rust function to sign aws v4 request hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_signature\n    fn create_signature(\n        private_key: &Secret<String>,\n        http_method: Method,\n        canonical_uri: &str,\n        signed_headers: &str,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> Result<String, String> {\n        let mut canonical_request = http_method.to_string() + \"\\n\" + canonical_uri + \"\\n\\n\";\n\n        let mut lowercase_sorted_header_keys: Vec<String> =\n            header.iter().map(|(key, _)| key.to_lowercase()).collect();\n\n        lowercase_sorted_header_keys.sort();\n\n        for key in lowercase_sorted_header_keys {\n            if let Some((_, maskable_value)) = header.iter().find(|(k, _)| k.to_lowercase() == key)\n            {\n                let value: String = match maskable_value {\n                    Maskable::Normal(v) => v.clone(),\n                    Maskable::Masked(secret) => secret.clone().expose(),\n                };\n                canonical_request.push_str(&format!(\"{key}:{value}\\n\"));\n            }\n        }\n\n        canonical_request.push_str(&(\"\\n\".to_owned() + signed_headers + \"\\n\" + hashed_payload));\n\n        let string_to_sign = format!(\n            \"{}\\n{}\",\n            SIGNING_ALGO,\n            hex::encode(Sha256::digest(canonical_request.as_bytes()))\n        );\n\n        Self::sign(private_key, &string_to_sign)\n            .map_err(|e| format!(\"Failed to create signature: {e}\"))\n    }\n", "function_name": "create_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Signature V4"}, {"query": "create_signature implementation hyperswitch amazonpay", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_signature\n    fn create_signature(\n        private_key: &Secret<String>,\n        http_method: Method,\n        canonical_uri: &str,\n        signed_headers: &str,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> Result<String, String> {\n        let mut canonical_request = http_method.to_string() + \"\\n\" + canonical_uri + \"\\n\\n\";\n\n        let mut lowercase_sorted_header_keys: Vec<String> =\n            header.iter().map(|(key, _)| key.to_lowercase()).collect();\n\n        lowercase_sorted_header_keys.sort();\n\n        for key in lowercase_sorted_header_keys {\n            if let Some((_, maskable_value)) = header.iter().find(|(k, _)| k.to_lowercase() == key)\n            {\n                let value: String = match maskable_value {\n                    Maskable::Normal(v) => v.clone(),\n                    Maskable::Masked(secret) => secret.clone().expose(),\n                };\n                canonical_request.push_str(&format!(\"{key}:{value}\\n\"));\n            }\n        }\n\n        canonical_request.push_str(&(\"\\n\".to_owned() + signed_headers + \"\\n\" + hashed_payload));\n\n        let string_to_sign = format!(\n            \"{}\\n{}\",\n            SIGNING_ALGO,\n            hex::encode(Sha256::digest(canonical_request.as_bytes()))\n        );\n\n        Self::sign(private_key, &string_to_sign)\n            .map_err(|e| format!(\"Failed to create signature: {e}\"))\n    }\n", "function_name": "create_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay Signature V4"}, {"query": "how to implement Tokenex connector integration in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Tokenex\n{\n    // Not Implemented (R)\n}\n\npub mod auth_headers {\n    pub const TOKENEX_ID: &str = \"tx-tokenex-id\";\n    pub const TOKENEX_API_KEY: &str = \"tx-apikey\";\n    pub const TOKENEX_SCHEME: &str = \"tx-token-scheme\";\n    pub const TOKENEX_SCHEME_VALUE: &str = \"PCI\";\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Tokenex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex connector integration stub"}, {"query": "Tokenex authentication headers configuration hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Tokenex\n{\n    // Not Implemented (R)\n}\n\npub mod auth_headers {\n    pub const TOKENEX_ID: &str = \"tx-tokenex-id\";\n    pub const TOKENEX_API_KEY: &str = \"tx-apikey\";\n    pub const TOKENEX_SCHEME: &str = \"tx-token-scheme\";\n    pub const TOKENEX_SCHEME_VALUE: &str = \"PCI\";\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Tokenex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex connector integration stub"}, {"query": "hyperswitch tokenex connector trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Tokenex\n{\n    // Not Implemented (R)\n}\n\npub mod auth_headers {\n    pub const TOKENEX_ID: &str = \"tx-tokenex-id\";\n    pub const TOKENEX_API_KEY: &str = \"tx-apikey\";\n    pub const TOKENEX_SCHEME: &str = \"tx-token-scheme\";\n    pub const TOKENEX_SCHEME_VALUE: &str = \"PCI\";\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Tokenex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex connector integration stub"}, {"query": "PaymentMethodTokenizationData connector integration rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Tokenex\n{\n    // Not Implemented (R)\n}\n\npub mod auth_headers {\n    pub const TOKENEX_ID: &str = \"tx-tokenex-id\";\n    pub const TOKENEX_API_KEY: &str = \"tx-apikey\";\n    pub const TOKENEX_SCHEME: &str = \"tx-token-scheme\";\n    pub const TOKENEX_SCHEME_VALUE: &str = \"PCI\";\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Tokenex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "ConnectorIntegration", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "unit_type": "function", "label": "Tokenex connector integration stub"}, {"query": "how to generate signature for barclaycard api request rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: barclaycard::BarclaycardAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let barclaycard::BarclaycardAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let digest_str = if is_post_method { \"digest \" } else { \"\" };\n        let headers = format!(\"host date (request-target) {digest_str}{V_C_MERCHANT_ID}\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}{V_C_MERCHANT_ID}: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard Signature Generation"}, {"query": "hyperswitch barclaycard connector signature generation hmac sha256", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: barclaycard::BarclaycardAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let barclaycard::BarclaycardAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let digest_str = if is_post_method { \"digest \" } else { \"\" };\n        let headers = format!(\"host date (request-target) {digest_str}{V_C_MERCHANT_ID}\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}{V_C_MERCHANT_ID}: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard Signature Generation"}, {"query": "rust function to create barclaycard signature header hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: barclaycard::BarclaycardAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let barclaycard::BarclaycardAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let digest_str = if is_post_method { \"digest \" } else { \"\" };\n        let headers = format!(\"host date (request-target) {digest_str}{V_C_MERCHANT_ID}\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}{V_C_MERCHANT_ID}: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard Signature Generation"}, {"query": "barclaycard signature version 2.0 implementation hyperswitch connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: barclaycard::BarclaycardAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let barclaycard::BarclaycardAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let digest_str = if is_post_method { \"digest \" } else { \"\" };\n        let headers = format!(\"host date (request-target) {digest_str}{V_C_MERCHANT_ID}\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}{V_C_MERCHANT_ID}: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard Signature Generation"}, {"query": "rust struct for capturing payment amount and currency hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: CaptureIntegrityObject\npub struct CaptureIntegrityObject {\n    /// capture amount\n    pub capture_amount: Option<MinorUnit>,\n    /// capture currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "CaptureIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "payment capture data struct"}, {"query": "hyperswitch domain models CaptureIntegrityObject definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: CaptureIntegrityObject\npub struct CaptureIntegrityObject {\n    /// capture amount\n    pub capture_amount: Option<MinorUnit>,\n    /// capture currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "CaptureIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "payment capture data struct"}, {"query": "how to define capture amount and currency in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: CaptureIntegrityObject\npub struct CaptureIntegrityObject {\n    /// capture amount\n    pub capture_amount: Option<MinorUnit>,\n    /// capture currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "CaptureIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "payment capture data struct"}, {"query": "CaptureIntegrityObject hyperswitch domain models source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: CaptureIntegrityObject\npub struct CaptureIntegrityObject {\n    /// capture amount\n    pub capture_amount: Option<MinorUnit>,\n    /// capture currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "function_name": "CaptureIntegrityObject", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "unit_type": "function", "label": "payment capture data struct"}, {"query": "how to handle payone payout response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PayoutsRouterData<PoFulfill>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PayoutsRouterData<PoFulfill>, ConnectorError> {\n        let response: payone::PayonePayoutFulfillResponse = res\n            .response\n            .parse_struct(\"PayonePayoutFulfillResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Response Handler"}, {"query": "rust connector handle_response payone payouts", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PayoutsRouterData<PoFulfill>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PayoutsRouterData<PoFulfill>, ConnectorError> {\n        let response: payone::PayonePayoutFulfillResponse = res\n            .response\n            .parse_struct(\"PayonePayoutFulfillResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Response Handler"}, {"query": "hyperswitch payone payout fulfillment deserialization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PayoutsRouterData<PoFulfill>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PayoutsRouterData<PoFulfill>, ConnectorError> {\n        let response: payone::PayonePayoutFulfillResponse = res\n            .response\n            .parse_struct(\"PayonePayoutFulfillResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Response Handler"}, {"query": "connector error handling payone payout response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PayoutsRouterData<PoFulfill>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PayoutsRouterData<PoFulfill>, ConnectorError> {\n        let response: payone::PayonePayoutFulfillResponse = res\n            .response\n            .parse_struct(\"PayonePayoutFulfillResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "unit_type": "function", "label": "Payone Payout Response Handler"}, {"query": "Worldpay modular connector payment event types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: EventType\npub enum EventType {\n    #[serde(alias = \"sentForAuthorization\", alias = \"Sent for Authorization\")]\n    SentForAuthorization,\n    #[serde(alias = \"Authorized\", alias = \"authorized\")]\n    Authorized,\n    #[serde(alias = \"Sent for Settlement\", alias = \"sentForSettlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Settlement Failed\", alias = \"settlementFailed\")]\n    SettlementFailed,\n    #[serde(alias = \"Settlement Rejected\", alias = \"settlementRejected\")]\n    SettlementRejected,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    #[serde(alias = \"Sent for Refund\", alias = \"sentForRefund\")]\n    SentForRefund,\n    RefundFailed,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "function_name": "EventType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay payment event enum"}, {"query": "Rust enum for payment status in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: EventType\npub enum EventType {\n    #[serde(alias = \"sentForAuthorization\", alias = \"Sent for Authorization\")]\n    SentForAuthorization,\n    #[serde(alias = \"Authorized\", alias = \"authorized\")]\n    Authorized,\n    #[serde(alias = \"Sent for Settlement\", alias = \"sentForSettlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Settlement Failed\", alias = \"settlementFailed\")]\n    SettlementFailed,\n    #[serde(alias = \"Settlement Rejected\", alias = \"settlementRejected\")]\n    SettlementRejected,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    #[serde(alias = \"Sent for Refund\", alias = \"sentForRefund\")]\n    SentForRefund,\n    RefundFailed,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "function_name": "EventType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay payment event enum"}, {"query": "Worldpay transaction lifecycle event mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: EventType\npub enum EventType {\n    #[serde(alias = \"sentForAuthorization\", alias = \"Sent for Authorization\")]\n    SentForAuthorization,\n    #[serde(alias = \"Authorized\", alias = \"authorized\")]\n    Authorized,\n    #[serde(alias = \"Sent for Settlement\", alias = \"sentForSettlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Settlement Failed\", alias = \"settlementFailed\")]\n    SettlementFailed,\n    #[serde(alias = \"Settlement Rejected\", alias = \"settlementRejected\")]\n    SettlementRejected,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    #[serde(alias = \"Sent for Refund\", alias = \"sentForRefund\")]\n    SentForRefund,\n    RefundFailed,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "function_name": "EventType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay payment event enum"}, {"query": "hyperswitch worldpaymodular EventType definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: EventType\npub enum EventType {\n    #[serde(alias = \"sentForAuthorization\", alias = \"Sent for Authorization\")]\n    SentForAuthorization,\n    #[serde(alias = \"Authorized\", alias = \"authorized\")]\n    Authorized,\n    #[serde(alias = \"Sent for Settlement\", alias = \"sentForSettlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Settlement Failed\", alias = \"settlementFailed\")]\n    SettlementFailed,\n    #[serde(alias = \"Settlement Rejected\", alias = \"settlementRejected\")]\n    SettlementRejected,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    #[serde(alias = \"Sent for Refund\", alias = \"sentForRefund\")]\n    SentForRefund,\n    RefundFailed,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "function_name": "EventType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay payment event enum"}]