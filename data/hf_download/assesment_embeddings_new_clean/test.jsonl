{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payments__payment_intent.rs\n// SYMBOL: find_payment_intent_by_merchant_reference_id_profile_id\n    async fn find_payment_intent_by_merchant_reference_id_profile_id(\n        &self,\n        merchant_reference_id: &id_type::PaymentReferenceId,\n        profile_id: &id_type::ProfileId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: &common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v2\")]", "positive": "This function retrieves a PaymentIntent entity by matching the specific combination of merchant reference ID and profile ID. It is a critical lookup operation used during payment processing flows to locate existing intent records, verify state, or reconcile transactions. The function signature includes a `MerchantKeyStore` and `MerchantStorageScheme` parameter, indicating it handles tenant-specific cryptographic keys and database storage configurations, ensuring data isolation and secure retrieval within the multi-tenant architecture.", "queries": ["rust hyperswitch find payment intent by merchant reference id and profile id", "hyperswitch domain models how to get payment intent by merchant reference", "rust hyperswitch payment intent lookup function signature merchant reference", "hyperswitch domain models retrieve payment intent by profile id reference"], "label": "PaymentIntent lookup by reference", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payments__payment_intent.rs", "symbol": "find_payment_intent_by_merchant_reference_id_profile_id", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` function in the `tokenex` connector is responsible for constructing the HTTP headers required for secure communication with the TokenEx payment gateway. It takes the request context and a collection of connectors as input, delegating the actual header generation to the `build_headers` method. This function is a critical integration point, ensuring that all necessary authentication tokens, API keys, and custom headers are correctly formatted and attached to outgoing requests, thereby facilitating secure and compliant payment processing within the Hyperswitch orchestration platform.", "queries": ["how to configure tokenex connector authentication headers in hyperswitch", "tokenex get_headers function implementation rust hyperswitch", "hyperswitch tokenex connector header generation build_headers", "configure tokenex api keys hyperswitch tokenex connector"], "label": "tokenex connector header generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_refund_status_with_count\n    async fn get_refund_status_with_count(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        profile_id_list: Option<Vec<common_utils::id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<Vec<(common_enums::RefundStatus, i64)>, errors::StorageError>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]", "positive": "This function retrieves a list of refund statuses along with their respective counts for a specific merchant. It accepts a merchant ID, optional profile IDs, a time range constraint, and the merchant's storage scheme to query the database. The result is a vector of tuples containing the refund status and the count of refunds matching that status, returning a CustomResult type to handle potential StorageErrors. It is a core data access method used by the router to aggregate refund statistics for analytics or dashboard reporting.", "queries": ["how to get refund status counts for a specific merchant", "rust function to count refunds by status hyperswitch", "get_refund_status_with_count implementation details", "hyperswitch router refund status aggregation query"], "label": "Refund status count retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "get_refund_status_with_count", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let date = OffsetDateTime::now_utc();\n        let cybersource_req = self.get_request_body(req, connectors)?;\n        let auth = cybersource::CybersourceAuthType::try_from(&req.connector_auth_type)?;\n        let merchant_account = auth.merchant_account.clone();\n        let base_url = connectors.cybersource.base_url.as_str();\n        let cybersource_host =\n            Url::parse(base_url).change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let host = cybersource_host\n            .host_str()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?;\n        let path: String = self\n            .get_url(req, connectors)?\n            .chars()\n            .skip(base_url.len() - 1)\n            .collect();\n        let sha256 = self.generate_digest(cybersource_req.get_inner_value().expose().as_bytes());\n        let http_method = self.get_http_method();\n        let signature = self.generate_signature(\n            auth,\n            host.to_string(),\n            path.as_str(),\n            &sha256,\n            date,\n            http_method,\n        )?;\n\n        let mut headers = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/hal+json;charset=utf-8\".to_string().into(),\n            ),\n            (\n                \"v-c-merchant-id\".to_string(),\n                merchant_account.into_masked(),\n            ),\n            (\"Date\".to_string(), date.to_string().into()),\n            (\"Host\".to_string(), host.to_string().into()),\n            (\"Signature\".to_string(), signature.into_masked()),\n        ];\n        if matches!(http_method, Method::Post | Method::Put | Method::Patch) {\n            headers.push((\n                \"Digest\".to_string(),\n                format!(\"SHA-256={sha256}\").into_masked(),\n            ));\n        }\n        Ok(headers)\n    }\n}\n", "positive": "This function constructs the HTTP headers required for authenticating and communicating with the Cybersource payment gateway. It generates a cryptographic signature using the merchant account ID, request path, SHA-256 digest, timestamp, and HTTP method to ensure request integrity and authorization. It also sets standard headers like Content-Type, Accept, Host, and Date, and conditionally adds a Digest header for POST/PUT/PATCH requests. This logic is specific to the Cybersource connector implementation within the hyperswitch_connectors crate.", "queries": ["how to generate signature for cybersource api request", "rust hyperswitch cybersource build_headers function implementation", "cybersource authentication header generation hyperswitch", "hyperswitch connector cybersource signature calculation"], "label": "Cybersource signature generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "build_headers", "unit_type": "function", "num_lines": 58}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: build_endpoint\nfn build_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, ConnectorError> {\n    let metadata = gpayments::GpaymentsMetaData::try_from(connector_metadata)?;\n    let endpoint_prefix = metadata.endpoint_prefix;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl\n    ConnectorIntegration<\n        Authentication,\n        ConnectorAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "positive": "The `build_endpoint` function constructs a dynamic URL for the Gpayments connector by replacing a placeholder string in the base URL with the specific endpoint prefix derived from the connector's metadata. It validates the metadata using `GpaymentsMetaData::try_from` and returns a `CustomResult<String, ConnectorError>`, ensuring the correct API endpoint is used for subsequent payment processing requests within the Hyperswitch payment orchestration platform.", "queries": ["how to build gpayments endpoint url rust hyperswitch", "gpayments connector metadata endpoint_prefix hyperswitch rust", "hyperswitch gpayments build_endpoint function implementation", "rust hyperswitch gpayments connector url construction"], "label": "gpayments endpoint builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gpayments.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "symbol": "build_endpoint", "unit_type": "function", "num_lines": 16}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function, `get_error_response`, serves as a specialized error handling wrapper within the Hyperswitch payment orchestration platform. It accepts an HTTP `Response` object and an optional `ConnectorEvent` builder, then delegates to `build_error_response` to construct a standardized `ErrorResponse`. This ensures that failures from external payment processors (like Finix) are normalized into a consistent internal format, allowing the router to handle downstream errors uniformly regardless of the specific connector implementation.", "queries": ["how to handle finix connector errors in hyperswitch", "implement custom error response builder for hyperswitch connectors", "rust hyperswitch finix error handling get_error_response", "hyperswitch connector error response standardization"], "label": "Finix error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__finix.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: validate_connector_against_payment_request\n    fn validate_connector_against_payment_request(\n        &self,\n        capture_method: Option<enums::CaptureMethod>,\n        _payment_method: enums::PaymentMethod,\n        _pmt: Option<enums::PaymentMethodType>,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let capture_method = capture_method.unwrap_or_default();\n        match capture_method {\n            enums::CaptureMethod::Automatic\n            | enums::CaptureMethod::Manual\n            | enums::CaptureMethod::SequentialAutomatic => Ok(()),\n            enums::CaptureMethod::ManualMultiple | enums::CaptureMethod::Scheduled => Err(\n                crate::utils::construct_not_supported_error_report(capture_method, self.id()),\n            ),\n        }\n    }\n}\n", "positive": "This function validates a connector's capability to handle a specific payment request's capture method. It checks the provided capture_method against the connector's supported enum values (Automatic, Manual, SequentialAutomatic) and returns an error for unsupported methods like ManualMultiple or Scheduled. It is a critical validation step in the connector initialization flow, ensuring the selected connector can process the intended transaction flow.", "queries": ["how to implement validate_connector_against_payment_request in rust", "hyperswitch connector capture method validation error ManualMultiple", "rust enum match validate_connector_against_payment_request hyperswitch", "hyperswitch connector not supported error capture method Scheduled"], "label": "connector capture method validation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "validate_connector_against_payment_request", "unit_type": "function", "num_lines": 18}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "The `build_request` function in the `gigadat` connector is responsible for constructing the HTTP request payload for authorizing payments with Gigadat. It orchestrates the assembly of the request by setting the HTTP method to POST, defining the target URL using `PaymentsAuthorizeType::get_url`, and attaching default headers and specific headers via `get_headers`. It then sets the request body using `get_request_body` and finalizes the request construction. This function is a core part of the connector's request lifecycle, ensuring that the data structure sent to Gigadat is correctly formatted for the authorize operation.", "queries": ["how to build gigadat authorize request", "gigadat connector build_request rust implementation", "rust gigadat payments authorize request builder", "hyperswitch gigadat connector request construction"], "label": "gigadat authorize request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__gigadat.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseAddressDetails\npub struct WiseAddressDetails {\n    country: Option<CountryAlpha2>,\n    country_code: Option<CountryAlpha2>,\n    first_line: Option<Secret<String>>,\n    post_code: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n}\n\n#[allow(dead_code)]\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "The `WiseAddressDetails` struct in `hyperswitch_connectors` defines the data model for address information used during payout processing. It handles sensitive fields like street lines and state codes securely using `Secret<String>` wrappers and supports optional country specifications. This struct is utilized by the Wise connector transformer to map incoming payout address data into the internal domain model, ensuring compliance with Wise's API requirements for international transfers.", "queries": ["Rust struct definition for Wise payout address details", "hyperswitch Wise connector address transformation model", "how to handle sensitive address fields in Wise payouts", "WiseAddressDetails struct implementation in hyperswitch"], "label": "Wise payout address model", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "symbol": "WiseAddressDetails", "unit_type": "function", "num_lines": 13}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: find_merchant_connector_account_by_merchant_id_connector_label\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]", "positive": "This function retrieves a specific MerchantConnectorAccount entity from the storage layer using the composite key of MerchantId and ConnectorLabel. It serves as the primary lookup mechanism for the router to validate and retrieve the necessary credentials and configuration for a specific payment provider integration. The function delegates the actual database query execution to the underlying router_store, passing along a MerchantKeyStore for cryptographic key retrieval, ensuring the account context is fully resolved before returning the domain model.", "queries": ["how to find merchant connector account by merchant id and label", "rust hyperswitch find_merchant_connector_account implementation", "merchant connector account lookup function signature", "hyperswitch router store merchant connector account fetch"], "label": "merchant connector account lookup", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "find_merchant_connector_account_by_merchant_id_connector_label", "unit_type": "function", "num_lines": 17}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        match pm_data {\n            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n                \"validate_mandate_payment does not support cards\".to_string(),\n            )\n            .into()),\n            _ => Ok(()),\n        }\n    }\n", "positive": "This function implements the validation logic for payment mandates within the Sift connector. It checks if the provided payment method data is compatible with mandate processing. Currently, it explicitly rejects card-based mandates by returning a 'NotImplemented' error, while returning 'Ok' for all other payment method types. This acts as a gatekeeper to ensure only non-card payment methods proceed to the mandate creation or verification stage.", "queries": ["how to handle mandate validation in Sift connector", "implement validate_mandate_payment for Sift", "Sift connector mandate payment method support", "error handling for unsupported payment types in Sift"], "label": "Sift mandate validation logic", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "validate_mandate_payment", "unit_type": "function", "num_lines": 14}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "The `get_error_response` method in the Sift connector implementation serves as a specialized error handling wrapper within the `Connector` trait. It accepts an HTTP `Response` object and an optional mutable reference to a `ConnectorEvent` builder. Its primary purpose is to standardize error formatting by delegating to the internal `build_error_response` method. This ensures that errors returned by the Sift payment gateway are consistently mapped to the Hyperswitch `ErrorResponse` model, maintaining architectural integrity across the payment orchestration platform.", "queries": ["rust hypersift connector error response builder trait implementation", "how to handle sift payment gateway errors in hyperswitch rust", "hyperswitch sift connector get_error_response method signature", "rust connector trait error handling hypersift integration"], "label": "Sift connector error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__sift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: SignifydPaymentStatus\npub enum SignifydPaymentStatus {\n    Accept,\n    Challenge,\n    Credit,\n    Hold,\n    Reject,\n}\n", "positive": "This Rust enum, SignifydPaymentStatus, defines the standard status codes returned by the Signifyd fraud detection API. It is used within the Signifyd connector to map external risk assessment results to internal payment states. The 'Accept' status indicates a low fraud risk, 'Challenge' suggests manual review is needed, 'Credit' implies a refund, 'Hold' means a transaction is paused, and 'Reject' signifies a definitive fraud decision. This enum is crucial for the transformer layer to accurately update the payment's risk profile and orchestrate the subsequent flow, such as triggering a webhook or blocking a transaction.", "queries": ["SignifydPaymentStatus Rust enum usage", "hyperswitch signifyd fraud status codes", "Signifyd API response mapping Rust", "SignifydPaymentStatus accept challenge hold reject"], "label": "Signifyd fraud status enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "SignifydPaymentStatus", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: MerchantConnectorAccount\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]", "positive": "The MerchantConnectorAccount struct acts as the central configuration entity in Hyperswitch's domain models, linking a specific merchant to a payment connector (e.g., Stripe, Razorpay). It stores sensitive credentials like connector_account_details and webhook secrets, which are encrypted at rest. This entity is crucial for the router to route payment requests to the correct provider and manage the lifecycle of payment methods and webhook subscriptions associated with that specific merchant-provider pair.", "queries": ["how to configure merchant connector account details in hyperswitch", "rust struct definition merchant connector account hyperswitch", "hyperswitch merchant connector account webhook configuration", "merchant connector account encryption hyperswitch rust"], "label": "Merchant connector account configuration struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "MerchantConnectorAccount", "unit_type": "function", "num_lines": 32}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for Wells Fargo's mandate setup API. It leverages the `SetupMandateType` trait to dynamically generate the target URL, headers, and request body based on the provided `SetupMandateRouterData` and `Connectors` context. The method ensures standard HTTP verb (POST) and default headers are applied before finalizing the request object, handling potential configuration errors via `CustomResult`.", "queries": ["how to build request for Wells Fargo mandate setup", "rust function to create HTTP request for Wells Fargo SetupMandateType", "hyperswitch Wells Fargo connector build_request implementation", "SetupMandateRouterData request builder Wells Fargo"], "label": "Wells Fargo mandate setup request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 16}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_object_reference_id\npub async fn get_mca_from_object_reference_id(\n    state: &SessionState,\n    object_reference_id: webhooks::ObjectReferenceId,\n    platform: &domain::Platform,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let default_profile_id = platform\n        .get_processor()\n        .get_account()\n        .default_profile\n        .as_ref();\n\n    #[cfg(feature = \"v2\")]\n    let default_profile_id = Option::<&String>::None;\n\n    match default_profile_id {\n        Some(profile_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                let _db = db;\n                let _profile_id = profile_id;\n                todo!()\n            }\n        }\n        _ => match object_reference_id {\n            webhooks::ObjectReferenceId::PaymentId(payment_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_payment_id_type(state, payment_id_type, platform)\n                        .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::RefundId(refund_id_type) => {\n                get_mca_from_payment_intent(\n                    state,\n                    platform,\n                    find_payment_intent_from_refund_id_type(\n                        state,\n                        refund_id_type,\n                        platform,\n                        connector_name,\n                    )\n                    .await?,\n                    connector_name,\n                )\n                .await\n            }\n            webhooks::ObjectReferenceId::Manda\n\n... [truncated 544 chars] ...\n\n           }\n            webhooks::ObjectReferenceId::SubscriptionId(subscription_id_type) => {\n                #[cfg(feature = \"v1\")]\n                {\n                    let subscription_state = state.clone().into();\n                    let subscription_handler =\n                        SubscriptionHandler::new(&subscription_state, platform);\n                    let mut subscription_with_handler = subscription_handler\n                        .find_subscription(subscription_id_type)\n                        .await?;\n\n                    subscription_with_handler.get_mca(connector_name).await\n                }\n                #[cfg(feature = \"v2\")]\n                {\n                    let _db = db;\n                    todo!()\n                }\n            }\n            #[cfg(feature = \"payouts\")]\n            webhooks::ObjectReferenceId::PayoutId(payout_id_type) => {\n                get_mca_from_payout_attempt(state, platform, payout_id_type, connector_name).await\n            }\n        },\n    }\n}\n\n// validate json format for the error", "positive": "This function retrieves the MerchantConnectorAccount (MCA) associated with a specific object reference ID (Payment, Refund, Subscription, or Payout) within the Hyperswitch router. It acts as a critical resolver for webhook handlers and downstream logic, bridging the gap between an external event payload and the internal database entity required to process the transaction. It handles version-specific logic (v1 vs v2) and falls back to database lookups via `find_merchant_connector_account_by_profile_id_connector_name` when a default profile is available, or performs complex lookups like `get_mca_from_payment_intent` for specific transaction types.", "queries": ["How to get merchant connector account from payment intent id in hyperswitch router", "hyperswitch router find_mca_from_object_reference_id implementation", "rust function to resolve merchant account from webhook object reference id", "hyperswitch get_mca_from_payment_intent usage in router utils"], "label": "Router MCA resolution from object ID", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "get_mca_from_object_reference_id", "unit_type": "function", "num_lines": 110}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n\n#[async_trait::async_trait]", "positive": "This function serves as a specialized error handling wrapper within the Hyperswitch payment orchestration framework, specifically designed for the Payone connector implementation. It accepts an HTTP Response object and an optional mutable reference to a ConnectorEvent builder. Its primary purpose is to standardize error parsing and logging by delegating the actual construction of the ErrorResponse to the internal `build_error_response` method. This ensures that connector-specific error details are captured consistently, allowing the router to handle failures gracefully while maintaining a unified interface for downstream consumers.", "queries": ["rust hyperswitch payone connector error handling get_error_response", "how to implement custom error response in hyperswitch payone connector", "hyperswitch payone connector error builder pattern rust", "rust hyperswitch payone error response unit test"], "label": "Payone Connector Error Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 10}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsPreProcessingRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let minor_amount = req.request.minor_amount;\n        let currency =\n            req.request\n                .currency\n                .ok_or(errors::ConnectorError::MissingRequiredField {\n                    field_name: \"currency\",\n                })?;\n\n        let amount =\n            connector_utils::convert_amount(self.amount_converter, minor_amount, currency)?;\n        let connector_router_data = redsys::RedsysRouterData::from((amount, req, currency));\n        let connector_req = redsys::RedsysTransaction::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }", "positive": "This function prepares the JSON request body for Redsys payment gateway integration. It validates the required currency field, converts the minor amount to the specified currency using a configured converter, and constructs a `RedsysTransaction` object from the router data. The resulting `RequestContent` is then returned, ready for transmission to the Redsys connector.", "queries": ["How to convert minor amount to currency for Redsys in hyperswitch?", "Implement get_request_body for Redsys connector in Rust", "Hyperswitch Redsys transaction request body conversion logic", "Rust function to build Redsys payment request payload"], "label": "Redsys request body builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 19}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: amazonpay::AmazonpayErrorResponse = res\n            .response\n            .parse_struct(\"AmazonpayErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.reason_code.clone(),\n            message: response.message.clone(),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            reason: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from an Amazon Pay API HTTP response. It parses the raw response body into an AmazonpayErrorResponse struct to extract critical error details like reason_code and message. It logs the response for debugging and populates a ConnectorEvent if provided. Finally, it returns a unified error object containing the HTTP status code and parsed error fields, ensuring the router can handle connector-specific failures uniformly.", "queries": ["how to handle Amazon Pay error responses in hyperswitch", "build_error_response function implementation rust", "parse amazonpay error response struct", "hyperswitch connector error handling pattern"], "label": "Amazon Pay error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: remove\n    pub fn remove(&mut self, value: dir::DirValue) {\n        let set = self.keywise_values.entry(value.get_key()).or_default();\n\n        set.remove(&value);\n\n        if set.is_empty() {\n            self.keywise_values.remove(&value.get_key());\n        }\n    }\n}\n", "positive": "This function removes a specific `DirValue` from the internal `keywise_values` map. It first attempts to locate the entry for the value's key. If the set of values for that key is empty after removal, the key itself is deleted from the map to maintain data integrity. This utility is likely used within the DSSA (Directed Acyclic Graph) graph module to dynamically update or prune node relationships during payment orchestration state management.", "queries": ["how to remove a DirValue from keywise_values map in Rust", "hyperswitch dssa graph remove function implementation", "rust remove entry from hashmap if empty after removal", "dssa graph keywise_values remove method source code"], "label": "DSSA Graph Value Removal", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__euclid__src__dssa__graph.rs", "path": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "symbol": "remove", "unit_type": "function", "num_lines": 11}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            wellsfargo::WellsfargoErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Wellsfargo ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::WellsfargoErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.reason.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                            ),\n\n... [truncated 2663 chars] ...\n\n & \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"wellsfargo\")\n            }\n        }\n    }\n}\n", "positive": "This function constructs a standardized ErrorResponse object from a Wells Fargo HTTP response, handling both successful deserialization of error structures and parsing failures. It manages connector-specific error codes, populates event builder metadata, and ensures consistent error reporting for the payment orchestration platform.", "queries": ["How to handle Wells Fargo connector error responses in Rust", "Build ErrorResponse from Wells Fargo API response status 401", "Parse Wells Fargo error details and reason codes", "Handle JSON deserialization failure for Wells Fargo connector"], "label": "Wells Fargo error response builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 133}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: update_multiple_merchant_connector_accounts\n    async fn update_multiple_merchant_connector_accounts(\n        &self,\n        merchant_connector_accounts: Vec<(\n            domain::MerchantConnectorAccount,\n            storage::MerchantConnectorAccountUpdateInternal,\n        )>,\n    ) -> CustomResult<(), Self::Error> {\n        self.router_store\n            .update_multiple_merchant_connector_accounts(merchant_connector_accounts)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]", "positive": "This function serves as a domain-level abstraction for batch updating merchant connector account configurations within the Hyperswitch payment orchestration platform. It accepts a vector of tuples containing the updated domain model and internal storage instructions, then delegates the persistence logic to the router store. This pattern ensures data consistency between the business logic layer and the underlying PostgreSQL database, handling the synchronization of account settings across the orchestration engine.", "queries": ["how to update multiple merchant connector accounts in rust hyperswitch", "hyperswitch update_multiple_merchant_connector_accounts implementation", "batch update merchant connector accounts hyperswitch storage_impl", "hyperswitch router store update multiple accounts function"], "label": "Batch update merchant connector accounts", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "update_multiple_merchant_connector_accounts", "unit_type": "function", "num_lines": 14}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, ConnectorError> {\n        let netcetera_auth_type = netcetera::NetceteraAuthType::try_from(&req.connector_auth_type)?;\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorPreAuthenticationType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(ConnectorPreAuthenticationType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(ConnectorPreAuthenticationType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .add_certificate(Some(netcetera_auth_type.certificate))\n                .add_certificate_key(Some(netcetera_auth_type.private_key))\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for Netcetera pre-authentication flows. It leverages `ConnectorPreAuthenticationType` to dynamically determine the endpoint URL, headers, and body structure based on the incoming `PreAuthNRouterData` and connector configuration. It specifically handles the attachment of Netcetera-specific SSL certificates and private keys required for secure communication with the payment provider.", "queries": ["how to configure netcetera connector authentication in hyperswitch", "rust function build_request netcetera connector hyperswitch", "netcetera pre-authentication request builder hyperswitch rust", "hyperswitch netcetera connector ssl certificate configuration"], "label": "Netcetera pre-auth request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 25}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &VaultRouterData<ExternalVaultInsertFlow>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ExternalVaultInsertType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ExternalVaultInsertType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ExternalVaultInsertType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "The `build_request` function constructs the HTTP request for the TokenEx vault integration. It initializes a POST request, dynamically sets the URL and headers using `ExternalVaultInsertType` methods, and attaches the request body. This function is a core part of the connector's request pipeline, ensuring the correct payload and authentication context are sent to the TokenEx API for vault operations.", "queries": ["how to configure tokenex vault request builder in hyperswitch", "rust hyperswitch tokenex connector build_request implementation", "hyperswitch tokenex external vault insert flow request setup", "tokenex hyperswitch connector request builder method post"], "label": "TokenEx connector request builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"lowercase\")]", "positive": "This function implements a constructor for a struct (likely a payment or transaction DTO) within the Elavon connector. It accepts a tuple containing a monetary amount (StringMajorUnit) and a generic item (T), which is assigned to a router_data field. This pattern suggests the function is used to transform raw API responses or internal data structures into a standardized format required by the router or downstream processing logic within the payment orchestration flow.", "queries": ["rust elavon connector from function implementation", "how to convert elavon response to router data struct", "elavon payment transformer constructor amount router_data", "hyperswitch elavon connector from method signature"], "label": "Elavon payment transformer constructor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "from", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_last_segment\n    fn get_last_segment(canonical_uri: &str) -> String {\n        canonical_uri\n            .chars()\n            .rev()\n            .take_while(|&c| c != '/')\n            .collect::<Vec<_>>()\n            .into_iter()\n            .rev()\n            .collect()\n    }\n", "positive": "The `get_last_segment` function in the Amazon Pay connector extracts the final path component from a given URI string. It reverses the input string, iterates through characters until a slash is encountered, collects these characters, and then reverses the collection back to obtain the original segment order. This utility is essential for parsing the final part of a payment intent or webhook callback URL, ensuring the correct identifier is retrieved for downstream processing or logging within the payment orchestration flow.", "queries": ["rust function to get last part of url string", "hyperswitch amazonpay connector get_last_segment implementation", "how to extract final path segment from uri in rust", "amazonpay connector parsing uri last segment hyperswitch"], "label": "Amazon Pay URI segment parser", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "get_last_segment", "unit_type": "function", "num_lines": 11}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: set_group_by_clause\n    fn set_group_by_clause(\n        &self,\n        builder: &mut QueryBuilder<super::SqlxClient>,\n    ) -> QueryResult<()> {\n        let trunc_scale = self.get_lowest_common_granularity_level();\n\n        let granularity_bucket_scale = match self {\n            Self::OneMin => None,\n            Self::FiveMin | Self::FifteenMin | Self::ThirtyMin => Some(\"minute\"),\n            Self::OneHour | Self::OneDay => None,\n        };\n\n        let granularity_divisor = self.get_bucket_size();\n\n        builder\n            .add_group_by_clause(format!(\"DATE_TRUNC('{trunc_scale}', created_at)\"))\n            .attach_printable(\"Error adding time prune group by\")?;\n        if let Some(scale) = granularity_bucket_scale {\n            builder\n                .add_group_by_clause(format!(\n                    \"FLOOR(DATE_PART('{scale}', created_at)/{granularity_divisor})\"\n                ))\n                .attach_printable(\"Error adding time binning group by\")?;\n        }\n        Ok(())\n    }\n}\n", "positive": "This function configures the GROUP BY clause for analytics queries within the Hyperswitch payment orchestration platform. It dynamically constructs SQL time-based grouping logic to handle different aggregation granularities (OneMin, FiveMin, OneHour, etc.). It first truncates the timestamp to the lowest common granularity, then applies a floor division to create time buckets based on the specific interval size. This ensures accurate time-series reporting for metrics like transaction volume and latency.", "queries": ["how to set group by clause for time series analytics in hyperswitch", "rust function set_group_by_clause hyperswitch analytics", "hyperswitch analytics query builder group by timestamp", "how does hyperswitch handle time bucketing in analytics queries"], "label": "analytics time bucketing", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__analytics__src__query.rs", "path": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "symbol": "set_group_by_clause", "unit_type": "function", "num_lines": 28}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: KeyManagerConfig\npub struct KeyManagerConfig {\n    pub enabled: bool,\n    pub url: String,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub cert: Secret<String>,\n    #[cfg(feature = \"keymanager_mtls\")]\n    pub ca: Secret<String>,\n    #[serde(default = \"default_key_store_decryption_behavior\")]\n    pub use_legacy_key_store_decryption: bool,\n}\n", "positive": "The KeyManagerConfig struct in the router crate defines the configuration parameters for the Key Manager service, which is responsible for managing cryptographic keys and secrets required for secure payment processing. It includes a boolean flag to enable the service, the base URL for the Key Manager API, and optional fields for Mutual TLS (mTLS) certificates and CA certificates when the 'keymanager_mtls' feature is enabled. The struct also includes a boolean flag to control the decryption behavior of the key store, defaulting to a legacy mode if not specified. This configuration is essential for integrating the router with the Key Manager service to ensure secure key rotation and management.", "queries": ["hyperswitch router KeyManagerConfig struct definition", "how to configure Key Manager service in hyperswitch router", "enable mTLS for Key Manager in hyperswitch", "hyperswitch KeyManagerConfig use_legacy_key_store_decryption"], "label": "KeyManagerConfig struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "KeyManagerConfig", "unit_type": "function", "num_lines": 11}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__db__refund.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__db__refund.rs\n// SYMBOL: get_total_count_of_refunds\n    async fn get_total_count_of_refunds(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        refund_details: refunds::RefundListConstraints,\n        storage_scheme: enums::MerchantStorageScheme,\n    ) -> CustomResult<i64, errors::StorageError>;\n}\n\n#[cfg(not(feature = \"kv_store\"))]\nmod storage {\n    use error_stack::report;\n    use hyperswitch_domain_models::refunds;\n    use router_env::{instrument, tracing};\n\n    use super::RefundInterface;\n    use crate::{\n        connection,\n        core::errors::{self, CustomResult},\n        services::Store,\n        types::storage::{self as storage_types, enums},\n    };\n\n    #[async_trait::async_trait]", "positive": "This function defines the interface for retrieving the total count of refunds associated with a specific merchant. It accepts merchant identification, a set of refund list constraints (e.g., status, date range), and the storage scheme (e.g., tenant schema). The implementation is gated by the 'kv_store' feature flag, utilizing the router's connection pool and the 'Store' service abstraction to interact with the underlying PostgreSQL database. It returns a count as an i64, wrapped in a CustomResult to handle potential storage errors.", "queries": ["how to count total refunds for a merchant in hyperswitch", "hyperswitch router get_total_count_of_refunds implementation", "rust function to get refund count by merchant_id", "hyperswitch storage interface for refund counting"], "label": "Refund count interface", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__db__refund.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__db__refund.rs", "symbol": "get_total_count_of_refunds", "unit_type": "function", "num_lines": 23}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__zift.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "The `get_headers` function in the Zift connector serves as a configuration layer for API requests, dynamically generating a vector of key-value pairs required for authentication and metadata transmission. It leverages the `build_headers` method to process request data and connector configurations, ensuring that sensitive fields are masked using the `masking::Maskable` wrapper. This function is critical for the Zift integration within the Hyperswitch payment orchestration platform, ensuring that outgoing authorization requests to Zift contain the correct headers for verification and tracking.", "queries": ["rust hyperswitch zift connector get_headers implementation", "how to configure headers for zift payment gateway in hyperswitch rust", "hyperswitch zift connector source code get_headers function", "rust hyperswitch zift authorization headers masking"], "label": "zift connector headers configuration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__zift.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__zift.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: CloneConnectorAllowlistConfig\npub struct CloneConnectorAllowlistConfig {\n    #[serde(deserialize_with = \"deserialize_merchant_ids\")]\n    pub merchant_ids: HashSet<id_type::MerchantId>,\n    #[serde(deserialize_with = \"deserialize_hashset\")]\n    pub connector_names: HashSet<enums::Connector>,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]", "positive": "This struct defines the configuration for allowing specific payment connectors to process transactions for designated merchants. It utilizes Serde for deserialization, specifically handling `HashSet` types for `merchant_ids` and `connector_names`. This configuration is crucial for the router's security and routing logic, ensuring that only approved connectors can handle requests for specific merchant entities within the Hyperswitch orchestration platform.", "queries": ["how to configure allowed connectors for specific merchants in hyperswitch", "rust struct definition for CloneConnectorAllowlistConfig", "hyperswitch router configuration merchant_ids connector_names", "deserialize_merchant_ids deserialize_hashset serde hyperswitch"], "label": "Router connector allowlist config", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "CloneConnectorAllowlistConfig", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: from\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]", "positive": "This function implements a `From` trait conversion for a struct (likely a payment or transaction DTO) that accepts a tuple of `StringMajorUnit` (representing monetary amount) and a generic type `T` (representing router-specific data). It constructs the struct instance by mapping the amount directly and embedding the router data, utilizing Rust's type inference for the generic item. This is a standard data transformation pattern used in the `hyperswitch_connectors` crate to normalize incoming API payloads into internal domain models before routing.", "queries": ["rust from trait implementation for payment amount and router data", "hyperswitch connector struct conversion from tuple", "StringMajorUnit to payment struct conversion", "how to convert payment amount and router data in rust"], "label": "Payment DTO conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "from", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__globepay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let query_params = get_globlepay_query_params(&req.connector_auth_type)?;\n        if matches!(\n            req.request.capture_method,\n            Some(enums::CaptureMethod::Automatic) | Some(enums::CaptureMethod::SequentialAutomatic)\n        ) {\n            Ok(format!(\n                \"{}api/v1.0/gateway/partners/{}/orders/{}{query_params}\",\n                self.base_url(connectors),\n                get_partner_code(&req.connector_auth_type)?,\n                req.payment_id\n            ))\n        } else {\n            Err(errors::ConnectorError::FlowNotSupported {\n                flow: \"Manual Capture\".to_owned(),\n                connector: \"Globepay\".to_owned(),\n            }\n            .into())\n        }\n    }\n", "positive": "This function constructs the API endpoint URL for the Globepay connector's authorization flow. It dynamically appends the partner code and payment ID to the base URL, appending specific query parameters derived from the connector authentication type. Crucially, it enforces a strict flow validation: it only generates a valid URL for Automatic or SequentialAutomatic capture methods. If the request specifies Manual Capture, it returns a FlowNotSupported error, preventing the connector from processing invalid authorization requests.", "queries": ["how to configure globepay automatic capture url", "globepay connector get_url function automatic capture", "hyperswitch globepay manual capture error", "globepay authorization endpoint query parameters rust"], "label": "Globepay authorization URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__globepay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__globepay.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 25}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &VaultRouterData<ExternalVaultInsertFlow>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<VaultRouterData<ExternalVaultInsertFlow>, errors::ConnectorError> {\n        let response: tokenex::TokenexInsertResponse = res\n            .response\n            .parse_struct(\"TokenexInsertResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "The `handle_response` function processes the HTTP response from the Tokenex connector for a vault insert operation. It deserializes the raw response into a `TokenexInsertResponse` struct, logs the details, and constructs a `ResponseRouterData` object. This data is then used by the router to finalize the flow, ensuring the external vault's response is validated and integrated into the application state before returning a `CustomResult`.", "queries": ["How to handle Tokenex vault insert response in Rust?", "Parse TokenexInsertResponse struct from HTTP response", "Implement handle_response for Tokenex connector", "Rust custom error handling for Tokenex API response"], "label": "Tokenex response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__payments__operations__payment_response.rs\n// SYMBOL: update_modular_pm_and_mandate_impl\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n     \n\n... [truncated 4105 chars] ...\n\n                  payload,\n                    )\n                    .await\n                    {\n                        Ok(_) => {\n                            logger::info!(\"Successfully called modular payment method update\");\n                        }\n                        Err(err) => {\n                            logger::error!(\"Failed to call modular payment method update: {}\", err);\n                        }\n                    };\n                    payment_data.payment_attempt.payment_method_id =\n                        Some(payment_method_id.clone());\n                } else {\n                    logger::info!(\"No updates found for modular payment method update call\");\n                }\n            }\n            _ => {\n                logger::info!(\"Payment method is not eligible for modular update\");\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Helper function to update payment method connector mandate details.\n/// This is called after a successful payment to activate/update the connector mandate.\n#[cfg(feature = \"v1\")]", "positive": "This function handles the update of modular payment methods and mandates following a payment transaction. It specifically targets Card payment methods where the response status indicates an update is needed. It derives the network transaction ID and mandate reference from the connector response, constructs a payload, and calls the `payment_methods::update_payment_method` API to synchronize the state with the connector. This ensures that future usage tokens and mandates are correctly established for OffSession payments.", "queries": ["how to update payment method mandate after payment hyperswitch", "hyperswitch modular payment method update function implementation", "update payment method connector mandate details rust hyperswitch", "hyperswitch payment method update network transaction id mandate"], "label": "Payment Method Update Logic", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__payments__operations__payment_response.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__payments__operations__payment_response.rs", "symbol": "update_modular_pm_and_mandate_impl", "unit_type": "function", "num_lines": 155}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Address\npub struct Address {\n    street_address: Secret<String>,\n    unit: Option<Secret<String>>,\n    postal_code: Secret<String>,\n    city: String,\n    province_code: Secret<String>,\n    country_code: common_enums::CountryAlpha2,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Deserialize, Clone)]\n#[serde(rename_all(serialize = \"SCREAMING_SNAKE_CASE\", deserialize = \"snake_case\"))]", "positive": "The `Address` struct within the Signifyd connector transformer module defines the data model for shipping and billing locations. It utilizes `Secret` wrappers for sensitive fields like street address, unit, and postal code to ensure PII protection during serialization. The struct is decorated with `Serialize` and `Deserialize` traits, configured to map Rust fields to `SCREAMING_SNAKE_CASE` JSON keys, facilitating seamless integration with external Signifyd API payloads.", "queries": ["hyperswitch signifyd address struct secret field", "signifyd connector address transformation rust code", "hyperswitch address model snake_case serde", "signifyd api address structure hyperswitch rust"], "label": "Signifyd Address Struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "symbol": "Address", "unit_type": "function", "num_lines": 11}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: is_disabled\n    pub fn is_disabled(&self) -> bool {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.disabled.unwrap_or(false)\n            }\n            Self::MerchantConnectorDetails(_) => false,\n        }\n    }\n", "positive": "This method determines the operational status of a payment connector configuration within the Hyperswitch domain models. It checks the 'disabled' flag on a MerchantConnectorAccount entity, returning the boolean value if present, or defaulting to false if the flag is unset. This logic is critical for the router's routing engine to dynamically bypass specific connector integrations based on configuration, ensuring that disabled connectors are not invoked during payment or refund processing flows.", "queries": ["how to check if merchant connector account is disabled in hyperswitch", "rust function to get disabled status from merchant connector account", "hyperswitch domain models merchant connector account is_disabled method", "how to disable a connector account in hyperswitch rust code"], "label": "merchant connector account disabled status", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "symbol": "is_disabled", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payment_intent\npub async fn get_mca_from_payment_intent(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payment_intent: PaymentIntent,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n\n    #[cfg(feature = \"v1\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_processor_merchant_id(\n            &payment_intent.active_attempt.get_id(),\n            platform.get_processor().get_account().get_id(),\n            platform.get_processor().get_account().storage_scheme,\n            platform.get_processor().get_key_store(),\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    #[cfg(feature = \"v2\")]\n    let payment_attempt = db\n        .find_payment_attempt_by_attempt_id_merchant_id(\n            key_manager_state,\n            key_store,\n            &payment_intent.active_attempt.get_id(),\n            merchant_account.get_id(),\n            merchant_account.storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n\n    match payment_attempt.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = key_store;\n                let _ = key_manager_state;\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            let profile_id = payment_intent\n                .profile_id\n                .as_ref()\n                .get_required_value(\"profile_id\")\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"profile_id is not set in payment_intent\")?\n                .clone();\n\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {connector_name}\",\n                            profile_id.get_string_repr()\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _ = profile_id;\n                todo!()\n            }\n        }\n    }\n}\n#[cfg(feature = \"payouts\")]", "positive": "This utility function retrieves a MerchantConnectorAccount (MCA) based on a PaymentIntent. It handles two primary retrieval paths: using a known merchant_connector_id (for V1) or falling back to a profile_id and connector_name (for V2). It is crucial for routing payment flows to the correct payment processor account within the Hyperswitch orchestration engine.", "queries": ["how to get merchant connector account from payment intent", "rust hyperswitch get_mca_from_payment_intent implementation", "find merchant connector account by profile id and connector name", "hyperswitch router utils get_mca_from_payment_intent"], "label": "Merchant Connector Account Retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "get_mca_from_payment_intent", "unit_type": "function", "num_lines": 93}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: cybersource::CybersourceAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let cybersource::CybersourceAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "positive": "This function generates the cryptographic signature header required for authenticating requests to the Cybersource payment gateway. It constructs a canonical string based on the HTTP method (GET, POST, PATCH, DELETE), the resource path, the current timestamp, the host, and the merchant account ID. It then applies an HMAC-SHA256 hash using the provided API secret and encodes it in Base64, returning a formatted string compliant with the Cybersource API specification for the 'Authorization' header.", "queries": ["rust hyperswitch cybersource connector generate_signature implementation", "how to sign cybersource requests in hyperswitch rust", "hyperswitch cybersource_auth_type signature generation hmac sha256", "cybersource signature header format hyperswitch rust code"], "label": "Cybersource HMAC Signature Generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__cybersource.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "symbol": "generate_signature", "unit_type": "function", "num_lines": 53}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        match req.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(ref wallet_data) => match wallet_data {\n                WalletDataPaymentMethod::AmazonPay(ref req_wallet) => Ok(format!(\n                    \"{}/checkoutSessions/{}/finalize\",\n                    self.base_url(connectors),\n                    req_wallet.checkout_session_id.clone()\n                )),\n                WalletDataPaymentMethod::AliPayQr(_)\n                | WalletDataPaymentMethod::AliPayRedirect(_)\n                | WalletDataPaymentMethod::AliPayHkRedirect(_)\n                | WalletDataPaymentMethod::AmazonPayRedirect(_)\n                | WalletDataPaymentMethod::MomoRedirect(_)\n                | WalletDataPaymentMethod::KakaoPayRedirect(_)\n                | WalletDataPaymentMethod::GoPayRedirect(_)\n                | WalletDataPaymentMethod::GcashRedirect(_)\n                | WalletDataPaymentMethod::ApplePay(_)\n                | WalletDataPaymentMethod::ApplePayRedirect(_)\n                | WalletDataPaymentMethod::ApplePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::DanaRedirect {}\n                | WalletDataPaymentMethod::GooglePay(_)\n                | WalletDataPaymentMethod::GooglePayRedirect(_)\n                | WalletDataPaymentMethod::GooglePayThirdPartySdk(_)\n                | WalletDataPaymentMethod::MbWayRedirect(_)\n                | WalletDataPaymentMethod::MobilePayRedirect(_)\n                | WalletDataPaymentMethod::PaypalRedirect(_)\n                | WalletDataPaymentMethod::PaypalSdk(_)\n                | WalletDataPaymentMethod::Paze(_)\n                | WalletDataPaymentMethod::SamsungPay(_)\n                | WalletDataPaymentMethod::TwintRedirect {}\n                | WalletDataPaymentMethod::VippsRedirect {}\n                | WalletDataPaymentMethod::BluecodeRedirect {}\n                | WalletDataPaymentMethod::TouchNGoRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayRedirect(_)\n                | WalletDataPaymentMethod::WeChatPayQr(_)\n                | WalletDataPaymentMethod::CashappQr(_)\n                | WalletDataPaymentMethod::SwishQr(_)\n                | WalletDataPaymentMethod::RevolutPay(_)\n                | WalletDataPaymentMethod::Paysera(_)\n                | WalletDataPaymentMethod::Skrill(_)\n                | WalletDataPaymentMethod::Mifinity(_) => {\n                    Err(errors::ConnectorError::NotImplemented(\n                        utils::get_unimplemented_payment_method_error_message(\"amazonpay\"),\n                    )\n                    .into())\n                }\n            },\n            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n        }\n    }\n", "positive": "This function constructs the specific Amazon Pay API endpoint URL required to finalize a checkout session. It is invoked during the authorization flow within the `PaymentsAuthorizeRouterData` context, extracting the `checkout_session_id` from the `WalletDataPaymentMethod::AmazonPay` variant. It relies on the `Connectors` struct to resolve the base URL and returns a formatted string for the `/checkoutSessions/{id}/finalize` endpoint, while rejecting all other payment method types.", "queries": ["rust hyperswitch amazonpay finalize url construction", "how to get amazonpay finalize url in hyperswitch rust", "hyperswitch amazonpay connector get_url implementation", "rust hyperswitch amazonpay checkout session finalize endpoint"], "label": "Amazon Pay finalize URL builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "get_url", "unit_type": "function", "num_lines": 55}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_router_data = finix::FinixRouterData::try_from((MinorUnit::zero(), req))?;\n        let connector_req = finix::FinixCreateIdentityRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "positive": "This function, located within the Finix connector implementation, extracts and transforms the incoming router request payload into a Finix-specific format. It utilizes the `try_from` trait to convert generic router data into `FinixRouterData` and subsequently into a `FinixCreateIdentityRequest`. The function is responsible for mapping the internal `PaymentsResponseData` and `CreateConnectorCustomer` structures to the external Finix API schema, ensuring data compatibility before the request is serialized and sent to the Finix payment gateway.", "queries": ["how to transform router data to finix create identity request", "finix connector get_request_body implementation rust", "map payments response data to finix create identity request", "hyperswitch finix connector request body transformation"], "label": "Finix Create Identity Request Mapper", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__finix.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 10}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs\n// MODULE: data::code_corpus_hyperswitch::crates__api_models__src__authentication.rs\n// SYMBOL: AuthenticationResponse\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n", "positive": "The AuthenticationResponse struct defines the data model returned after a payment authentication process (e.g., 3DS verification). It encapsulates the authentication ID, merchant context, current status (e.g., Started, Success), and sensitive details like the client secret. Crucially, it links the transaction to specific connectors, acquirers, and customer profiles, while handling error states and SCA exemption types. This struct is used by the router to serialize the final state of the authentication flow back to the client.", "queries": ["rust hyperswitch authentication response struct fields", "hyperswitch AuthenticationResponse merchant_id client_secret", "rust struct AuthenticationResponse authentication_connector", "hyperswitch AuthenticationResponse acquirer_details customer_details"], "label": "AuthenticationResponse struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__api_models__src__authentication.rs", "path": "data/code_corpus_hyperswitch/crates__api_models__src__authentication.rs", "symbol": "AuthenticationResponse", "unit_type": "function", "num_lines": 68}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &RouterData<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::ConnectorCustomerType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::ConnectorCustomerType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "positive": "This function constructs the HTTP request payload for creating a customer record within the Finix payment connector. It utilizes the `types::ConnectorCustomerType` trait to dynamically generate the target URL, required headers, and the JSON body based on the incoming `RouterData` and `Connectors` configuration. The method ensures standard HTTP POST formatting and default header attachment before returning a configured `Request` object.", "queries": ["how to build a request for creating a connector customer in finix", "finix connector customer creation request builder implementation", "rust hyperswitch finix build_request function signature", "how does hyperswitch finix connector handle customer creation requests"], "label": "Finix Customer Creation Request Builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__finix.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "symbol": "build_request", "unit_type": "function", "num_lines": 22}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_headers\n    fn get_headers(\n        &self,\n        req: &RouterData<Void, PaymentsCancelData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n", "positive": "This function retrieves the HTTP headers required for a Worldline payment cancellation request. It acts as a specific implementation of the generic `build_headers` method, ensuring the correct authentication tokens and API identifiers are attached to the outgoing request payload. It is part of the Worldline connector module within the hyperswitch_connectors crate, handling the request preparation phase for the cancel flow.", "queries": ["Rust function get_headers Worldline connector hyperswitch", "hyperswitch Worldline cancel request headers implementation", "Worldline connector get_headers method source code", "hyperswitch Rust build_headers payments cancel data"], "label": "Worldline connector headers retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "get_headers", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: build_rollout_keys\nfn build_rollout_keys(\n    merchant_id: &str,\n    connector_name: &str,\n    flow_name: &str,\n    payment_method: common_enums::PaymentMethod,\n    payment_method_type: Option<PaymentMethodType>,\n) -> String {\n    // Detect if this is a refund flow based on flow name\n    let is_refund_flow = matches!(flow_name, \"Execute\" | \"RSync\");\n\n    let rollout_key = if is_refund_flow {\n        // Refund flows: UCS_merchant_connector_flow (e.g., UCS_merchant123_stripe_Execute)\n        format!(\n            \"{}_{}_{}_{}\",\n            consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n            merchant_id,\n            connector_name,\n            flow_name\n        )\n    } else {\n        match payment_method {\n            common_enums::PaymentMethod::Wallet\n            | common_enums::PaymentMethod::BankRedirect\n            | common_enums::PaymentMethod::Voucher\n            | common_enums::PaymentMethod::PayLater => {\n                let payment_method_str = payment_method.to_string();\n                let payment_method_type_str = payment_method_type\n                    .map(|pmt| pmt.to_string())\n                    .unwrap_or_else(|| \"unknown\".to_string());\n                format!(\n                    \"{}_{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    payment_method_type_str,\n                    flow_name\n                )\n            }\n            common_enums::PaymentMethod::Card\n            | common_enums::PaymentMethod::CardRedirect\n            | common_enums::PaymentMethod::Upi\n            | common_enums::PaymentMethod::Crypto\n            | common_enums::PaymentMethod::Reward\n            | common_enums::PaymentMethod::BankDebit\n            | common_enums::PaymentMethod::RealTimePayment\n            | common_enums::PaymentMethod::BankTransfer\n            | common_enums::PaymentMethod::GiftCard\n            | common_enums::PaymentMethod::MobilePayment\n            | common_enums::PaymentMethod::NetworkToken\n            | common_enums::PaymentMethod::OpenBanking => {\n                // For other payment methods, use a generic format without specific payment method type details\n                let payment_method_str = payment_method.to_string();\n                format!(\n                    \"{}_{}_{}_{}_{}\",\n                    consts::UCS_ROLLOUT_PERCENT_CONFIG_PREFIX,\n                    merchant_id,\n                    connector_name,\n                    payment_method_str,\n                    flow_name\n                )\n            }\n        }\n    };\n\n    rollout_key\n}\n\n/// Extracts the gateway system from the payment intent's feature metadata\n/// Returns None if metadata is missing, corrupted, or doesn't contain gateway_system", "positive": "This function constructs a unique rollout key string used for feature flagging and percentage-based routing in the Unified Connector Service (UCS). It differentiates logic for refund flows (e.g., 'Execute', 'RSync') versus standard payment flows. For refunds, it formats the key as UCS_ROLLOUT_PERCENT_CONFIG_PREFIX_merchant_connector_flow. For payment methods, it handles complex types like Wallets and PayLater by including specific payment method and type details, while using a generic format for standard methods like Card, UPI, and Crypto. This ensures precise feature configuration targeting specific merchants, connectors, and payment contexts.", "queries": ["How to generate rollout keys for refund flows in UCS", "Rust function to build UCS rollout keys for payment methods", "Implementation of build_rollout_keys for merchant connector routing", "Code for constructing rollout keys with payment method types"], "label": "UCS rollout key builder", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "build_rollout_keys", "unit_type": "function", "num_lines": 70}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: validate_mandate_payment\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([PaymentMethodDataType::Card]);\n        connector_utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n", "positive": "This function validates whether a specific payment method is eligible for a mandate-based payment flow. It checks if the provided payment method type and data match the supported mandate types (specifically Card) for this connector. The function relies on `connector_utils::is_mandate_supported` to perform the actual validation logic, returning a `CustomResult` to signal success or a `ConnectorError` if the mandate is not supported or data is invalid. It is a critical gatekeeper in the payment orchestration flow to ensure compliance with mandate requirements before processing.", "queries": ["how to check if payment method supports mandate in hyperswitch airwallex connector", "airwallex mandate validation function implementation rust", "validate_mandate_payment airwallex connector hyperswitch", "is_mandate_supported airwallex connector utils"], "label": "Mandate validation gatekeeper", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__airwallex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "symbol": "validate_mandate_payment", "unit_type": "function", "num_lines": 10}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: netcetera::NetceteraErrorResponse = res\n            .response\n            .parse_struct(\"NetceteraErrorResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_details.error_code,\n            message: response.error_details.error_description,\n            reason: response.error_details.error_detail,\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "positive": "The `build_error_response` function in the Netcetera connector handles the transformation of an HTTP response into a standardized `ErrorResponse` object. It deserializes the raw response body into a `NetceteraErrorResponse` struct, logs the details for debugging, and maps the specific error fields (code, message, reason) to the connector's internal error model. It also optionally attaches this response body to a `ConnectorEvent` for downstream processing or analytics. This function is a critical integration point for error handling, ensuring that failures from the Netcetera payment gateway are consistently and accurately reported to the Hyperswitch orchestration layer.", "queries": ["how to handle Netcetera payment gateway error responses in Rust", "Netcetera connector error response mapping function implementation", "build_error_response function netcetera hyperswitch rust", "convert netcetera api error to hyperswitch ErrorResponse"], "label": "Netcetera error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "build_error_response", "unit_type": "function", "num_lines": 29}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response_data = String::from_utf8(res.response.to_vec())\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        let response = response_data\n            .parse_xml::<boku::BokuResponse>()\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the Boku payment gateway. It deserializes the raw XML payload into a BokuResponse struct, logs the connector's response for debugging, and attempts to convert the data into a router-compatible format. It is a critical integration point for the Boku connector, handling the final step of the authorization flow by validating the gateway's output and preparing it for downstream processing.", "queries": ["how to handle boku response in hyperswitch rust connector", "boku authorize response parsing hyperswitch", "rust connector handle_response boku xml", "hyperswitch boku connector integration example"], "label": "Boku response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__boku.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 21}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: api\nimpl api::UasProcessWebhook for Juspaythreedsserver {}\n\nimpl\n    ConnectorIntegration<\n        PreAuthenticate,\n        UasPreAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        PostAuthenticate,\n        UasPostAuthenticationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        AuthenticationConfirmation,\n        UasConfirmationRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n\nimpl\n    ConnectorIntegration<\n        ProcessIncomingWebhook,\n        UasWebhookRequestData,\n        UasAuthenticationResponseData,\n    > for Juspaythreedsserver\n{\n}\n", "positive": "This module implements the Juspay 3DS Server connector integration for Hyperswitch. It defines the trait implementations for the UAS (Unified Authentication Service) workflow, including Pre-Authentication, Post-Authentication, Authentication Confirmation, and Process Incoming Webhook. It acts as the bridge between the router's orchestration logic and Juspay's 3D Secure payment flow, handling the specific request/response data structures and webhook verification required for secure card payments.", "queries": ["how to implement Juspay 3DS server connector in Rust", "Juspaythreedsserver webhook verification implementation", "UasPreAuthenticationRequestData structure hyperswitch", "hyperswitch juspay 3ds server integration traits"], "label": "Juspay 3DS Server Integration", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "api", "unit_type": "function", "num_lines": 38}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__payment_method_data.rs\n// SYMBOL: NetworkTransactionIdAndCardDetails\npub struct NetworkTransactionIdAndCardDetails {\n    /// The card number\n    pub card_number: cards::CardNumber,\n\n    /// The card's expiry month\n    pub card_exp_month: Secret<String>,\n\n    /// The card's expiry year\n    pub card_exp_year: Secret<String>,\n\n    /// The card holder's name\n    pub card_holder_name: Option<Secret<String>>,\n\n    /// The name of the issuer of card\n    pub card_issuer: Option<String>,\n\n    /// The card network for the card\n    pub card_network: Option<api_enums::CardNetwork>,\n\n    pub card_type: Option<String>,\n\n    pub card_issuing_country: Option<String>,\n\n    pub card_issuing_country_code: Option<String>,\n\n    pub bank_code: Option<String>,\n\n    /// The card holder's nick name\n    pub nick_name: Option<Secret<String>>,\n\n    /// The network transaction ID provided by the card network during a CIT (Customer Initiated Transaction),\n    /// when `setup_future_usage` is set to `off_session`.\n    pub network_transaction_id: Secret<String>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]", "positive": "This struct encapsulates sensitive card details and the specific network transaction ID returned by the issuer during a Customer Initiated Transaction (CIT). It is designed to handle off-session payment flows where `setup_future_usage` is set to 'off_session', ensuring the transaction ID is securely stored for future authorization attempts. The struct integrates with the domain models layer to enforce strict data privacy by wrapping sensitive fields like card number and expiry in Secret types, while exposing optional metadata such as issuer name and network type for analytics and routing logic.", "queries": ["Rust hyperswitch struct for network transaction ID and card details", "how to store network transaction ID in hyperswitch domain models", "hyperswitch off_session payment setup_future_usage network transaction id", "Rust Secret type usage for card details in hyperswitch"], "label": "NetworkTransactionIdAndCardDetails struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__payment_method_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__payment_method_data.rs", "symbol": "NetworkTransactionIdAndCardDetails", "unit_type": "function", "num_lines": 36}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__core__unified_connector_service.rs\n// SYMBOL: extract_gateway_system_from_payment_intent\npub fn extract_gateway_system_from_payment_intent<F: Clone, D>(\n    payment_data: &D,\n) -> Option<GatewaySystem>\nwhere\n    D: OperationSessionGetters<F>,\n{\n    #[cfg(feature = \"v1\")]\n    {\n        payment_data\n            .get_payment_intent()\n            .feature_metadata\n            .as_ref()\n            .and_then(|metadata| {\n                // Try to parse the JSON value as FeatureMetadata\n                // Log errors but don't fail the flow for corrupted metadata\n                match serde_json::from_value::<FeatureMetadata>(metadata.clone()) {\n                    Ok(feature_metadata) => feature_metadata.gateway_system,\n                    Err(err) => {\n                        router_env::logger::warn!(\n                            \"Failed to parse feature_metadata for gateway_system extraction: {}\",\n                            err\n                        );\n                        None\n                    }\n                }\n            })\n    }\n    #[cfg(feature = \"v2\")]\n    {\n        None // V2 does not use feature metadata for gateway system tracking\n    }\n}\n\n/// Updates the payment intent's feature metadata to track the gateway system being used\n#[cfg(feature = \"v1\")]", "positive": "This function extracts the gateway system identifier from a payment intent's feature metadata. It is designed to work with the V1 feature flag system, parsing a JSON value to retrieve the specific gateway system (e.g., Stripe, Adyen) associated with the payment. It handles potential JSON parsing errors gracefully by logging a warning and returning None, ensuring the payment flow continues even if metadata is corrupted. For V2, it returns None as the architecture uses a different tracking mechanism. This is a core utility in the router's unified connector service to map payment intents to their underlying gateway implementations.", "queries": ["How to extract gateway system from payment intent feature metadata in Rust", "Rust function to get gateway system from payment intent feature metadata", "hyperswitch extract_gateway_system_from_payment_intent implementation", "How to parse feature metadata JSON to get gateway system in Rust"], "label": "Extract gateway system from payment intent metadata", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__core__unified_connector_service.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__core__unified_connector_service.rs", "symbol": "extract_gateway_system_from_payment_intent", "unit_type": "function", "num_lines": 35}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__configs__settings.rs\n// SYMBOL: OpenRouter\npub struct OpenRouter {\n    pub dynamic_routing_enabled: bool,\n    pub static_routing_enabled: bool,\n    pub url: String,\n}\n\n#[derive(Debug, Deserialize, Clone, Default)]\n#[serde(default)]", "positive": "The OpenRouter struct in Hyperswitch's Rust router configuration manages the dynamic and static routing settings required to direct payment requests to the appropriate connector. It contains a boolean flag for dynamic routing, a boolean flag for static routing, and the target URL for the router service. This configuration is essential for configuring the routing logic within the router crate, ensuring that payment flows are correctly intercepted and processed based on the defined routing rules and target endpoints.", "queries": ["how to configure OpenRouter settings in hyperswitch router", "hyperswitch OpenRouter struct definition and fields", "enable dynamic routing in hyperswitch router configuration", "hyperswitch router OpenRouter URL configuration"], "label": "OpenRouter configuration struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__configs__settings.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__configs__settings.rs", "symbol": "OpenRouter", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &AccessTokenAuthenticationRouterData,\n        _event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<AccessTokenAuthenticationRouterData, errors::ConnectorError> {\n        // Handle 302 redirect response\n        if res.status_code == 302 {\n            // Extract Location header\n            let headers =\n                res.headers\n                    .as_ref()\n                    .ok_or(errors::ConnectorError::MissingRequiredField {\n                        field_name: \"headers\",\n                    })?;\n            let location_header = headers\n                .get(\"Location\")\n                .map(|value| value.to_str())\n                .and_then(|location_value| location_value.ok())\n                .ok_or(errors::ConnectorError::ParsingFailed)?;\n\n            // Parse auth code from query params\n            let url = Url::parse(location_header)\n                .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n            let code = url\n                .query_pairs()\n                .find(|(key, _)| key == \"code\")\n                .map(|(_, value)| value.to_string())\n                .ok_or(errors::ConnectorError::MissingRequiredField { field_name: \"code\" })?;\n\n            // Return auth code as \"token\" with short expiry\n            Ok(RouterData {\n                response: Ok(AccessTokenAuthenticationResponse {\n                    code: Secret::new(code),\n                    expires: 60, // 60 seconds - auth code validity\n                }),\n                ..data.clone()\n            })\n        } else {\n            Err(\n                errors::ConnectorError::UnexpectedResponseError(\"Expected 302 redirect\".into())\n                    .into(),\n            )\n        }\n    }\n", "positive": "This function handles the OAuth 2.0 authorization code flow for the Nordea connector by intercepting HTTP 302 redirects. It extracts the 'Location' header to retrieve the callback URL, parses the 'code' query parameter, and returns it as a short-lived token (valid for 60 seconds) within an AccessTokenAuthenticationResponse. This logic is critical for the 'authorize' flow, ensuring the router captures the temporary authorization code from the redirect response before the client exchanges it for an access token.", "queries": ["rust nordea connector handle_response function implementation", "how does handle_response extract code from 302 redirect in nordea", "nordea oauth authorization code flow handle_response rust", "hyperswitch nordea connector handle_response 302 location header"], "label": "Nordea OAuth 302 redirect handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 47}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: mask_key\n    fn mask_key(&self, key: String) -> Secret<String> {\n        let key_len = key.len();\n        let masked_key = if key_len <= 4 {\n            \"*\".repeat(key_len)\n        } else {\n            // Show the first two and last two characters, mask the rest with '*'\n            let mut masked_key = String::new();\n            let key_len = key.len();\n            // Iterate through characters by their index\n            for (index, character) in key.chars().enumerate() {\n                if index < 2 || index >= key_len - 2 {\n                    masked_key.push(character); // Keep the first two and last two characters\n                } else {\n                    masked_key.push('*'); // Mask the middle characters\n                }\n            }\n            masked_key\n        };\n        Secret::new(masked_key)\n    }\n\n    // Mask the keys in the auth_type", "positive": "The `mask_key` function in the `hyperswitch_domain_models` crate is a utility designed to securely display sensitive authentication keys. It accepts a `String` key and returns a `Secret<String>`, obfuscating the middle characters with asterisks. For keys shorter than or equal to 4 characters, it returns a string of asterisks of the same length. For longer keys, it preserves the first two and last two characters, masking the rest. This function is critical for logging and debugging scenarios where the full key must not be exposed, ensuring sensitive data remains partially visible for verification while protecting the core secret. It is likely used within authentication or authorization modules to sanitize key outputs for audit trails or user-facing error messages.", "queries": ["how to mask sensitive keys in hyperswitch rust", "hyperswitch domain models mask_key function implementation", "rust function to hide middle characters of string", "hyperswitch secret string masking utility"], "label": "Secure key masking utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_data.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "symbol": "mask_key", "unit_type": "function", "num_lines": 22}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: XmlResponse\n        struct XmlResponse {\n            // Error fields\n            #[serde(rename = \"errorCode\", default)]\n            error_code: Option<String>,\n            #[serde(rename = \"errorMessage\", default)]\n            error_message: Option<String>,\n            #[serde(rename = \"errorName\", default)]\n            error_name: Option<String>,\n\n            // Success fields\n            #[serde(rename = \"ssl_result\", default)]\n            ssl_result: Option<SslResult>,\n            #[serde(rename = \"ssl_txn_id\", default)]\n            ssl_txn_id: Option<String>,\n            #[serde(rename = \"ssl_result_message\", default)]\n            ssl_result_message: Option<String>,\n            #[serde(rename = \"ssl_token\", default)]\n            ssl_token: Option<Secret<String>>,\n        }\n\n        let xml_res = XmlResponse::deserialize(deserializer)?;\n\n        let result = match (xml_res.error_message.clone(), xml_res.error_name.clone()) {\n            (Some(error_message), Some(error_name)) => ElavonResult::Error(ElavonErrorResponse {\n                error_code: xml_res.error_code.clone(),\n                error_message,\n                error_name,\n            }),\n            _ => {\n                if let (Some(ssl_result), Some(ssl_txn_id), Some(ssl_result_message)) = (\n                    xml_res.ssl_result.clone(),\n                    xml_res.ssl_txn_id.clone(),\n                    xml_res.ssl_result_message.clone(),\n                ) {\n                    ElavonResult::Success(PaymentResponse {\n                        ssl_result,\n                        ssl_txn_id,\n                        ssl_result_message,\n                        ssl_token: xml_res.ssl_token.clone(),\n                    })\n                } else {\n                    return Err(serde::de::Error::custom(\n                        \"Invalid Response XML structure - neither error nor success\",\n                    ));\n                }\n            }\n        };\n\n        Ok(Self { result })\n    }\n}", "positive": "This struct defines the deserialization target for Elavon payment gateway XML responses. It maps XML tags (errorCode, errorMessage, ssl_result) to Rust fields, handling both error and success states. The logic determines the final result type (ElavonResult) by checking for error fields first, then validating success fields (ssl_result, ssl_txn_id) to construct a PaymentResponse, ensuring strict XML schema compliance during the connector's transformation phase.", "queries": ["Elavon XML response deserialization struct", "Rust struct for Elavon payment gateway response", "XmlResponse deserialize Elavon connector", "ElavonResult mapping from XML response"], "label": "Elavon XML response deserializer", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "XmlResponse", "unit_type": "function", "num_lines": 51}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: from\n    fn from((amount, tenant_id, router_data): (MinorUnit, ArchipelTenantId, T)) -> Self {\n        Self {\n            amount,\n            tenant_id,\n            router_data,\n        }\n    }\n}\n", "positive": "This function implements the `From` trait for the `Archipel` struct, converting a tuple containing a monetary amount (in minor units), a tenant identifier, and router-specific data into a fully initialized `Archipel` instance. It is a core data transformation utility used within the `hyperswitch_connectors` crate to prepare payment context for the Archipel payment gateway, ensuring type safety and clean initialization logic.", "queries": ["rust from trait implementation for Archipel struct initialization", "how to convert tuple to Archipel struct in hyperswitch connectors", "Archipel struct constructor from amount tenant_id router_data", "hyperswitch archipel connector data transformation from tuple"], "label": "Archipel struct From trait implementation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "from", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: try_from\n    fn try_from(s: &str) -> Result<Self, Self::Error> {\n        match s.to_uppercase().as_str() {\n            \"RS256\" | \"rs256\" => Ok(Self::RS256),\n            \"ES256\" | \"es256\" => Ok(Self::ES256),\n            \"EDDSA\" | \"eddsa\" | \"EdDSA\" => Ok(Self::EDDSA),\n            _ => Err(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"Unsupported key algorithm. Select from RS256, ES256, EdDSA\",\n            }\n            .into()),\n        }\n    }\n}", "positive": "This function implements a conversion trait for parsing string inputs into a cryptographic algorithm enum within the TokenIO connector module. It normalizes input strings to uppercase and maps them to specific algorithm constants (RS256, ES256, EDDSA). If the input does not match a supported algorithm, it returns a `ConnectorError::InvalidConnectorConfig` with a descriptive message. This utility is essential for validating and configuring security keys during the tokenization process within the Hyperswitch payment orchestration platform.", "queries": ["how to handle RS256 algorithm string parsing in TokenIO connector", "rust try_from implementation for JWT algorithm constants", "TokenIO connector error handling for unsupported key algorithms", "convert string to algorithm enum RS256 ES256 EDDSA"], "label": "TokenIO algorithm enum conversion", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "try_from", "unit_type": "function", "num_lines": 12}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: list_connector_account_by_profile_id\n    async fn list_connector_account_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_connector_account_by_profile_id(profile_id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]", "positive": "This function retrieves a list of merchant connector accounts associated with a specific profile ID. It acts as a storage abstraction layer, delegating the actual database query to `self.router_store.list_connector_account_by_profile_id`. The function accepts a `ProfileId` and a `MerchantKeyStore` reference, returning a vector of `MerchantConnectorAccount` domain models wrapped in a `CustomResult`. This is essential for the router to resolve which payment connectors are active and available for a given merchant profile during transaction processing.", "queries": ["rust hyperswitch list_connector_account_by_profile_id implementation", "how to get merchant connector accounts by profile id in hyperswitch", "hyperswitch router store list_connector_account_by_profile_id function", "rust code for listing merchant connector accounts hyperswitch"], "label": "merchant connector account retrieval", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__storage_impl__src__merchant_connector_account.rs", "path": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "symbol": "list_connector_account_by_profile_id", "unit_type": "function", "num_lines": 11}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: connector_transaction_id\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n", "positive": "This function retrieves the pre-authorization transaction ID from Helcim metadata. It accepts an optional connector metadata JSON object, deserializes it into a HelcimMetaData struct, and extracts the `preauth_transaction_id` field. The result is wrapped in a CustomResult and returned as an Option<String>. This is a utility method used within the Helcim connector implementation to map external transaction identifiers to internal tracking keys.", "queries": ["how to get preauth_transaction_id from helcim metadata", "rust function to extract connector transaction id helcim", "helcim connector preauth transaction id mapping", "connector_transaction_id implementation helcim rust"], "label": "helcim preauth transaction id extractor", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__helcim.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "symbol": "connector_transaction_id", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__finix.rs\n// SYMBOL: new\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\n", "positive": "This function initializes a static instance of the connector configuration struct, likely for the Finix integration. It sets the amount conversion logic for standard transactions to 'MinorUnitForConnector' and configures the webhook amount conversion logic to 'StringMinorUnitForConnector'. This ensures that monetary values are correctly formatted and standardized when communicating with the Finix API endpoints, handling the specific unit requirements for both payment processing and webhook payloads.", "queries": ["how to initialize finix connector configuration", "rust hyperswitch finix connector setup amount conversion", "hyperswitch finix.rs new function implementation", "configure minor unit for connector in hyperswitch"], "label": "Finix connector initialization", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__finix.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__finix.rs", "symbol": "new", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PreAuthNRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, ConnectorError> {\n        let connector_router_data = netcetera::NetceteraRouterData::try_from((0, req))?;\n        let req_obj =\n            netcetera::NetceteraPreAuthenticationRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(req_obj)))\n    }\n", "positive": "This function extracts the JSON payload from a pre-authentication request for the Netcetera payment connector. It performs a type conversion from the generic router data (`PreAuthNRouterData`) into the specific `NetceteraRouterData` and subsequently into the `NetceteraPreAuthenticationRequest` struct. The function ensures the request body is wrapped in a `RequestContent::Json` variant, ready for downstream processing within the `hyperswitch_connectors` crate.", "queries": ["how to get request body from PreAuthNRouterData in netcetera connector", "rust code for extracting NetceteraPreAuthenticationRequest from router data", "hyperswitch netcetera connector get_request_body implementation", "convert PreAuthNRouterData to NetceteraPreAuthenticationRequest in hyperswitch"], "label": "Netcetera pre-auth request body extraction", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__netcetera.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "symbol": "get_request_body", "unit_type": "function", "num_lines": 11}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: PaymentsUpdateMetadataData\npub struct PaymentsUpdateMetadataData {\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub connector_transaction_id: String,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub connector_meta: Option<serde_json::Value>,\n    pub feature_metadata: Option<api_models::payments::FeatureMetadata>,\n    pub payment_method_data: Option<PaymentMethodData>,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]", "positive": "This struct defines the data payload for updating payment metadata within the Hyperswitch orchestration platform. It encapsulates sensitive information (via `pii::SecretSerdeValue`), the external connector transaction ID, and specific payment method details. It is used to synchronize state between the router and external payment processors, ensuring that metadata updates are persisted correctly in the `storage_enums` layer and reflected in the `api_models::payments::FeatureMetadata`.", "queries": ["Rust struct definition for PaymentsUpdateMetadataData hyperswitch", "hyperswitch router update payment metadata struct fields", "PaymentsUpdateMetadataData pii::SecretSerdeValue connector_transaction_id", "how to update payment metadata in hyperswitch router"], "label": "PaymentsUpdateMetadataData struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "PaymentsUpdateMetadataData", "unit_type": "function", "num_lines": 10}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: MandatePaymentRequest\npub struct MandatePaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_email: Email,\n    pub ssl_token: Secret<String>,\n}\n", "positive": "This struct defines the data payload required to process a mandate payment request via the Elavon connector. It encapsulates sensitive authentication details like the SSL PIN and account credentials, alongside transaction metadata such as the transaction type, amount, and user email. The struct is designed to be serialized into the specific XML format expected by the Elavon API, ensuring secure and compliant transmission of mandate initiation data within the Hyperswitch payment orchestration flow.", "queries": ["Elavon mandate payment request struct definition", "how to construct MandatePaymentRequest for Elavon", "Elavon mandate payment XML payload structure", "hyperswitch mandate payment request fields"], "label": "Elavon mandate request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "symbol": "MandatePaymentRequest", "unit_type": "function", "num_lines": 10}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs\n// SYMBOL: ArchipelOrderRequest\npub struct ArchipelOrderRequest {\n    amount: MinorUnit,\n    currency: String,\n    certainty: ArchipelPaymentCertainty,\n    initiator: ArchipelPaymentInitiator,\n}\n\n#[derive(Debug, Serialize, Eq, PartialEq, Clone)]", "positive": "The `ArchipelOrderRequest` struct defines the data transfer object for initiating payment requests within the Archipel connector. It encapsulates core transaction parameters including the monetary amount and currency, the payment certainty level, and the initiator type. This struct is utilized by the `ArchipelTransformer` to map Hyperswitch's internal payment models into the specific JSON payload format required by the Archipel API, ensuring type safety and serialization compatibility for outbound HTTP requests.", "queries": ["ArchipelOrderRequest struct definition Archipel connector", "how to create ArchipelOrderRequest in hyperswitch", "ArchipelOrderRequest fields amount currency certainty initiator", "hyperswitch archipel payment request transformer"], "label": "Archipel payment request struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__archipel__transformers.rs", "symbol": "ArchipelOrderRequest", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: TokenioAuthType\npub struct TokenioAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) private_key: Secret<String>,\n    pub(super) key_id: Secret<String>,\n    pub(super) key_algorithm: CryptoAlgorithm,\n}\n\n#[derive(Debug, Deserialize, PartialEq)]", "positive": "TokenioAuthType is a struct in the hyperswitch_connectors crate designed to encapsulate the cryptographic credentials required for authenticating with the Token.io payment gateway. It stores the merchant ID, private key, and key ID securely, along with the key algorithm (e.g., RSA), ensuring that the connector can perform secure tokenization operations and verify transaction signatures. This struct is a core component of the Token.io transformer module, handling the transformation of payment requests and responses between the Hyperswitch platform and the Token.io API.", "queries": ["TokenioAuthType struct definition hyperswitch", "hyperswitch tokenio connector authentication configuration", "how to configure TokenioAuthType in hyperswitch", "TokenioAuthType fields merchant_id private_key hyperswitch rust"], "label": "TokenioAuthType struct definition", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "symbol": "TokenioAuthType", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_response_inner\n    fn get_response_inner<T: DeserializeOwned>(self, type_name: &'static str) -> RouterResult<T> {\n        self.get_response()?\n            .response\n            .parse_struct(type_name)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n    }\n}\n\nimpl<E> ConnectorResponseExt\n    for Result<Result<types::Response, types::Response>, error_stack::Report<E>>\n{", "positive": "This function extends the `ConnectorResponseExt` trait to deserialize the inner response body of a connector's HTTP response into a generic type `T`. It is a critical utility in the `router` crate's connector abstraction layer, handling the parsing of raw JSON payloads from external payment providers into structured domain models (like `PaymentResponse` or `RefundResponse`). It utilizes the `serde` crate's `parse_struct` method, ensuring type safety and error handling via `error_stack` to convert parsing failures into `ApiErrorResponse::InternalServerError`. This method is invoked after successful HTTP retrieval to finalize the data transformation before returning it to the orchestration logic.", "queries": ["rust deserialize connector response body hyperswitch", "how to parse struct from connector response hyperswitch router", "hyperswitch connector response_ext trait implementation", "rust error_stack change_context parse_struct example"], "label": "Connector response deserialization utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__router__src__utils.rs", "path": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "symbol": "get_response_inner", "unit_type": "function", "num_lines": 11}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__thunes.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: thunes::ThunesPaymentsResponse = res\n            .response\n            .parse_struct(\"Thunes PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the Thunes payment gateway after an authorization request. It deserializes the raw response body into a `ThunesPaymentsResponse` struct, logs the connector response details for observability, and constructs a `RouterData` object containing the parsed response, original request data, and HTTP status code. It is a critical step in the payment orchestration flow for the Thunes connector, ensuring data integrity before downstream processing.", "queries": ["how to handle thunes authorize response in hyperswitch", "thunes connector response parsing rust hyperswitch", "hyperswitch thunes handle_response implementation", "thunes payments authorize response deserialization hyperswitch"], "label": "Thunes authorize response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__thunes.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__thunes.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 19}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldline.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "The `get_error_response` method in the Worldline connector implementation serves as a standardized error handling interface. It accepts an HTTP `Response` object and an optional `ConnectorEvent` builder, delegating the logic to `build_error_response`. This ensures that connector-specific error details are transformed into a consistent `ErrorResponse` format, while simultaneously populating the event context for downstream tracking or webhook notifications if the builder is provided.", "queries": ["rust hyperswitch worldline connector get_error_response implementation", "how does worldline connector handle error responses in hyperswitch", "hyperswitch worldline connector build_error_response method signature", "rust connector error handling worldline hyperswitch get_error_response"], "label": "Worldline error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldline.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldline.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function serves as a specialized error handling method within the JuspayThreeDSConnector implementation. It accepts an HTTP Response object and an optional ConnectorEvent builder to construct a standardized ErrorResponse. The method delegates the actual response construction logic to `build_error_response`, ensuring that error states are consistently formatted and, if an event builder is provided, properly populated for downstream event tracking or logging within the Hyperswitch payment orchestration framework.", "queries": ["How to handle error responses in JuspayThreeDSConnector", "Implement get_error_response method in Rust connector", "JuspayThreeDSConnector error handling pattern", "build_error_response function signature hyperswitch"], "label": "JuspayThreeDS error response handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__nordea.rs\n// SYMBOL: get_form_urlencoded_payload\n    fn get_form_urlencoded_payload<T: serde::Serialize>(\n        &self,\n        form_data: &T,\n    ) -> Result<Vec<u8>, error_stack::Report<errors::ConnectorError>> {\n        let json_value = serde_json::to_value(form_data)\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        let btree_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_value(json_value)\n                .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n\n        Ok(btree_map\n            .iter()\n            .map(|(k, v)| {\n                // Remove quotes from string values for proper form encoding\n                let value = match v {\n                    serde_json::Value::String(s) => s.clone(),\n                    _ => v.to_string(),\n                };\n                format!(\"{k}={value}\")\n            })\n            .collect::<Vec<_>>()\n            .join(\"&\")\n            .into_bytes())\n    }\n}\n", "positive": "This function serializes a generic type T into a URL-encoded form payload. It first converts the input to JSON, then parses it into a BTreeMap to ensure a consistent key order. It specifically handles string values by removing surrounding quotes, which is crucial for standard form-urlencoded data. This utility is essential for constructing HTTP requests to payment gateways like Nordea that require data in this specific format.", "queries": ["how to serialize struct to form-urlencoded in rust hyperswitch", "rust function to convert  to url encoded string", "hyperswitch connector form data encoding utility", "rust serialize to application/x-www-form-urlencoded"], "label": "Form URL Encoding Utility", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__nordea.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__nordea.rs", "symbol": "get_form_urlencoded_payload", "unit_type": "function", "num_lines": 27}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\n", "positive": "This function serves as a specialized error handling wrapper within the Redsys payment connector implementation. It accepts a raw HTTP Response and an optional mutable reference to a ConnectorEvent, then delegates the construction of the error response to the inherited `build_error_response` method. It is designed to standardize error formatting and ensure that error details are correctly populated into the event stream, facilitating downstream processing and webhook notifications for failed payment attempts.", "queries": ["how to handle redsys payment errors in hyperswitch rust connector", "redsys connector get_error_response implementation hyperswitch", "hyperswitch redsys error response builder function", "rust connector error handling pattern hyperswitch redsys"], "label": "Redsys error response wrapper", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__redsys.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "symbol": "get_error_response", "unit_type": "function", "num_lines": 9}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: create_signature\n    fn create_signature(\n        private_key: &Secret<String>,\n        http_method: Method,\n        canonical_uri: &str,\n        signed_headers: &str,\n        hashed_payload: &str,\n        header: &[(String, Maskable<String>)],\n    ) -> Result<String, String> {\n        let mut canonical_request = http_method.to_string() + \"\\n\" + canonical_uri + \"\\n\\n\";\n\n        let mut lowercase_sorted_header_keys: Vec<String> =\n            header.iter().map(|(key, _)| key.to_lowercase()).collect();\n\n        lowercase_sorted_header_keys.sort();\n\n        for key in lowercase_sorted_header_keys {\n            if let Some((_, maskable_value)) = header.iter().find(|(k, _)| k.to_lowercase() == key)\n            {\n                let value: String = match maskable_value {\n                    Maskable::Normal(v) => v.clone(),\n                    Maskable::Masked(secret) => secret.clone().expose(),\n                };\n                canonical_request.push_str(&format!(\"{key}:{value}\\n\"));\n            }\n        }\n\n        canonical_request.push_str(&(\"\\n\".to_owned() + signed_headers + \"\\n\" + hashed_payload));\n\n        let string_to_sign = format!(\n            \"{}\\n{}\",\n            SIGNING_ALGO,\n            hex::encode(Sha256::digest(canonical_request.as_bytes()))\n        );\n\n        Self::sign(private_key, &string_to_sign)\n            .map_err(|e| format!(\"Failed to create signature: {e}\"))\n    }\n", "positive": "This function implements the AWS Signature Version 4 signing algorithm for Amazon Pay connectors. It constructs a canonical request by sorting headers alphabetically, masking sensitive values using the Maskable enum, and appending the hashed payload. It generates a string-to-sign using SHA-256 hashing and finalizes the process by signing the result with the provided private key. This is essential for authenticating requests to Amazon Pay's API endpoints.", "queries": ["how to generate amazon pay signature in rust hyperswitch", "hyperswitch amazonpay connector signature creation function", "rust function to sign aws v4 request hyperswitch", "create_signature implementation hyperswitch amazonpay"], "label": "Amazon Pay Signature V4", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "symbol": "create_signature", "unit_type": "function", "num_lines": 38}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenex.rs\n// SYMBOL: ConnectorIntegration\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Tokenex\n{\n    // Not Implemented (R)\n}\n\npub mod auth_headers {\n    pub const TOKENEX_ID: &str = \"tx-tokenex-id\";\n    pub const TOKENEX_API_KEY: &str = \"tx-apikey\";\n    pub const TOKENEX_SCHEME: &str = \"tx-token-scheme\";\n    pub const TOKENEX_SCHEME_VALUE: &str = \"PCI\";\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Tokenex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "positive": "This trait implementation defines the integration contract for the Tokenex connector within the Hyperswitch payment orchestration platform. It specifies how the system handles PaymentMethodTokenizationData, including the retrieval of specific authentication headers (TOKENEX_ID, TOKENEX_API_KEY, TOKENEX_SCHEME) and the logic for processing PaymentsResponseData. The implementation is currently marked as 'Not Implemented (R)', indicating it is a placeholder or stub for future development of the Tokenex tokenization service.", "queries": ["how to implement Tokenex connector integration in Rust", "Tokenex authentication headers configuration hyperswitch", "hyperswitch tokenex connector trait implementation", "PaymentMethodTokenizationData connector integration rust"], "label": "Tokenex connector integration stub", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__tokenex.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenex.rs", "symbol": "ConnectorIntegration", "unit_type": "function", "num_lines": 17}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: barclaycard::BarclaycardAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let barclaycard::BarclaycardAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let digest_str = if is_post_method { \"digest \" } else { \"\" };\n        let headers = format!(\"host date (request-target) {digest_str}{V_C_MERCHANT_ID}\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}{V_C_MERCHANT_ID}: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "positive": "This function generates an HMAC-SHA256 signature for Barclaycard API requests, implementing a custom signature scheme based on the 'Signature Version 2.0' specification. It constructs a canonical request string including the host, date, request target, and merchant ID, then signs it using the provided API secret. The resulting header includes the key ID, algorithm, signed headers list, and the base64-encoded signature, ensuring request integrity and authentication for both GET and POST methods.", "queries": ["how to generate signature for barclaycard api request rust hyperswitch", "hyperswitch barclaycard connector signature generation hmac sha256", "rust function to create barclaycard signature header hyperswitch", "barclaycard signature version 2.0 implementation hyperswitch connector"], "label": "Barclaycard Signature Generation", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "symbol": "generate_signature", "unit_type": "function", "num_lines": 43}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_request_types.rs\n// SYMBOL: CaptureIntegrityObject\npub struct CaptureIntegrityObject {\n    /// capture amount\n    pub capture_amount: Option<MinorUnit>,\n    /// capture currency\n    pub currency: storage_enums::Currency,\n}\n\n#[derive(Debug, Clone, Default, Serialize)]", "positive": "The CaptureIntegrityObject struct in hyperswitch_domain_models defines the data contract for capturing funds from a payment. It encapsulates the specific monetary value (capture_amount) and the associated currency code (currency). This object is crucial for the payment orchestration engine to validate and execute capture transactions, ensuring that the amount being captured matches the original authorization and adheres to the defined currency constraints before interacting with storage or connector layers.", "queries": ["rust struct for capturing payment amount and currency hyperswitch", "hyperswitch domain models CaptureIntegrityObject definition", "how to define capture amount and currency in hyperswitch rust", "CaptureIntegrityObject hyperswitch domain models source code"], "label": "payment capture data struct", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_domain_models__src__router_request_types.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_request_types.rs", "symbol": "CaptureIntegrityObject", "unit_type": "function", "num_lines": 8}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payone.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PayoutsRouterData<PoFulfill>,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PayoutsRouterData<PoFulfill>, ConnectorError> {\n        let response: payone::PayonePayoutFulfillResponse = res\n            .response\n            .parse_struct(\"PayonePayoutFulfillResponse\")\n            .change_context(ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "positive": "This function processes the HTTP response from the Payone payout fulfillment endpoint. It deserializes the raw JSON payload into a `PayonePayoutFulfillResponse` struct, logs the details for observability, and constructs a `ResponseRouterData` wrapper. This wrapper is essential for the router to handle the downstream logic, including webhook generation and state updates, ensuring the payment orchestration flow continues correctly after the external payout request.", "queries": ["how to handle payone payout response in hyperswitch", "rust connector handle_response payone payouts", "hyperswitch payone payout fulfillment deserialization", "connector error handling payone payout response"], "label": "Payone Payout Response Handler", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__payone.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payone.rs", "symbol": "handle_response", "unit_type": "function", "num_lines": 21}
{"split": "test", "anchor": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: EventType\npub enum EventType {\n    #[serde(alias = \"sentForAuthorization\", alias = \"Sent for Authorization\")]\n    SentForAuthorization,\n    #[serde(alias = \"Authorized\", alias = \"authorized\")]\n    Authorized,\n    #[serde(alias = \"Sent for Settlement\", alias = \"sentForSettlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Settlement Failed\", alias = \"settlementFailed\")]\n    SettlementFailed,\n    #[serde(alias = \"Settlement Rejected\", alias = \"settlementRejected\")]\n    SettlementRejected,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    #[serde(alias = \"Sent for Refund\", alias = \"sentForRefund\")]\n    SentForRefund,\n    RefundFailed,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "positive": "The EventType enum in the Worldpay Modular connector defines the lifecycle states of a payment transaction, including authorization, settlement, refund, and failure events. It supports multiple aliases for legacy compatibility (e.g., 'Sent for Authorization' and 'Sent for Settlement') and includes a catch-all 'Unknown' variant. This structure is used to map external Worldpay responses to internal Hyperswitch event models, facilitating webhook processing and state tracking within the payment orchestration router.", "queries": ["Worldpay modular connector payment event types", "Rust enum for payment status in hyperswitch", "Worldpay transaction lifecycle event mapping", "hyperswitch worldpaymodular EventType definition"], "label": "Worldpay payment event enum", "repo": "juspay/hyperswitch", "language": "Rust", "filename": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "path": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "symbol": "EventType", "unit_type": "function", "num_lines": 23}
