[{"query": "how to handle helcim error response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: helcim::HelcimErrorResponse = res\n            .response\n            .parse_struct(\"HelcimErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_string = match response {\n            transformers::HelcimErrorResponse::Payment(response) => match response.errors {\n                transformers::HelcimErrorTypes::StringType(error) => error,\n                transformers::HelcimErrorTypes::JsonType(error) => error.to_string(),\n            },\n            transformers::HelcimErrorResponse::General(error_string) => error_string,\n        };\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: NO_ERROR_CODE.to_owned(),\n            message: error_string.clone(),\n            reason: Some(error_string),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim error response builder"}, {"query": "rust function build_error_response helcim connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: helcim::HelcimErrorResponse = res\n            .response\n            .parse_struct(\"HelcimErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_string = match response {\n            transformers::HelcimErrorResponse::Payment(response) => match response.errors {\n                transformers::HelcimErrorTypes::StringType(error) => error,\n                transformers::HelcimErrorTypes::JsonType(error) => error.to_string(),\n            },\n            transformers::HelcimErrorResponse::General(error_string) => error_string,\n        };\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: NO_ERROR_CODE.to_owned(),\n            message: error_string.clone(),\n            reason: Some(error_string),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim error response builder"}, {"query": "hyperswitch helcim error parsing implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: helcim::HelcimErrorResponse = res\n            .response\n            .parse_struct(\"HelcimErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_string = match response {\n            transformers::HelcimErrorResponse::Payment(response) => match response.errors {\n                transformers::HelcimErrorTypes::StringType(error) => error,\n                transformers::HelcimErrorTypes::JsonType(error) => error.to_string(),\n            },\n            transformers::HelcimErrorResponse::General(error_string) => error_string,\n        };\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: NO_ERROR_CODE.to_owned(),\n            message: error_string.clone(),\n            reason: Some(error_string),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim error response builder"}, {"query": "helcim error types string json mapping hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__helcim.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: helcim::HelcimErrorResponse = res\n            .response\n            .parse_struct(\"HelcimErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_string = match response {\n            transformers::HelcimErrorResponse::Payment(response) => match response.errors {\n                transformers::HelcimErrorTypes::StringType(error) => error,\n                transformers::HelcimErrorTypes::JsonType(error) => error.to_string(),\n            },\n            transformers::HelcimErrorResponse::General(error_string) => error_string,\n        };\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: NO_ERROR_CODE.to_owned(),\n            message: error_string.clone(),\n            reason: Some(error_string),\n            attempt_status: None,\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__helcim.rs", "unit_type": "function", "label": "Helcim error response builder"}, {"query": "how to get mandate reference from transaction response", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_mandate_reference\n    pub fn get_mandate_reference(&self) -> Option<MandateReference> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.as_ref().clone()\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "get_mandate_reference", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "get_mandate_reference function"}, {"query": "hyperswitch get_mandate_reference function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_mandate_reference\n    pub fn get_mandate_reference(&self) -> Option<MandateReference> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.as_ref().clone()\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "get_mandate_reference", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "get_mandate_reference function"}, {"query": "rust get_mandate_reference example", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_mandate_reference\n    pub fn get_mandate_reference(&self) -> Option<MandateReference> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.as_ref().clone()\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "get_mandate_reference", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "get_mandate_reference function"}, {"query": "mandate reference extraction hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: get_mandate_reference\n    pub fn get_mandate_reference(&self) -> Option<MandateReference> {\n        if let Self::TransactionResponse {\n            mandate_reference, ..\n        } = self\n        {\n            mandate_reference.as_ref().clone()\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]", "function_name": "get_mandate_reference", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "get_mandate_reference function"}, {"query": "how to format boku xml request body hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = boku::BokuRouterData::from((amount, req));\n        let connector_req = boku::BokuPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Xml(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku XML request builder"}, {"query": "hyperswitch boku connector get_request_body implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = boku::BokuRouterData::from((amount, req));\n        let connector_req = boku::BokuPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Xml(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku XML request builder"}, {"query": "convert amount to boku xml format hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = boku::BokuRouterData::from((amount, req));\n        let connector_req = boku::BokuPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Xml(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku XML request builder"}, {"query": "boku payments request builder hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__boku.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = boku::BokuRouterData::from((amount, req));\n        let connector_req = boku::BokuPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Xml(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__boku.rs", "unit_type": "function", "label": "Boku XML request builder"}, {"query": "Worldpay Modular API response structure Rust struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularPaymentsResponse\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularPaymentsResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular API Response Model"}, {"query": "hyperswitch WorldpaymodularPaymentsResponse deserialize", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularPaymentsResponse\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularPaymentsResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular API Response Model"}, {"query": "Worldpay Modular payment response fields outcome risk_factors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularPaymentsResponse\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularPaymentsResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular API Response Model"}, {"query": "Rust struct WorldpaymodularPaymentsResponse _links description", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: WorldpaymodularPaymentsResponse\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "WorldpaymodularPaymentsResponse", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "Worldpay Modular API Response Model"}, {"query": "How to parse Cybersource API error response in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            cybersource::CybersourceErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Cybersource ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::CybersourceErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.message.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                         \n\n... [truncated 2707 chars] ...\n\n& \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"cybersource\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource error response parser"}, {"query": "Rust hyperswitch cybersource connector error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            cybersource::CybersourceErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Cybersource ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::CybersourceErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.message.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                         \n\n... [truncated 2707 chars] ...\n\n& \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"cybersource\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource error response parser"}, {"query": "Standardize Cybersource error response format hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            cybersource::CybersourceErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Cybersource ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::CybersourceErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.message.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                         \n\n... [truncated 2707 chars] ...\n\n& \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"cybersource\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource error response parser"}, {"query": "Implement error parsing logic for Cybersource connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            cybersource::CybersourceErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"Cybersource ErrorResponse\");\n\n        let error_message = if res.status_code == 401 {\n            constants::CONNECTOR_UNAUTHORIZED_ERROR\n        } else {\n            hyperswitch_interfaces::consts::NO_ERROR_MESSAGE\n        };\n        match response {\n            Ok(transformers::CybersourceErrorResponse::StandardError(response)) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n\n                let (code, message, reason) = match response.error_information {\n                    Some(ref error_info) => {\n                        let detailed_error_info = error_info.details.as_ref().map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            error_info.reason.clone(),\n                            error_info.message.clone(),\n                            transformers::get_error_reason(\n                                Some(error_info.message.clone()),\n                                detailed_error_info,\n                                None,\n                            ),\n                        )\n                    }\n                    None => {\n                        let detailed_error_info = response.details.map(|details| {\n                            details\n                                .iter()\n                                .map(|det| format!(\"{} : {}\", det.field, det.reason))\n                                .collect::<Vec<_>>()\n                                .join(\", \")\n                        });\n                        (\n                            response.reason.clone().map_or(\n                                hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                                |reason| reason.to_string(),\n                         \n\n... [truncated 2707 chars] ...\n\n& \");\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: hyperswitch_interfaces::consts::NO_ERROR_CODE.to_string(),\n                    message: error_response.clone(),\n                    reason: Some(error_response),\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": res.status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                utils::handle_json_response_deserialization_failure(res, \"cybersource\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "Cybersource error response parser"}, {"query": "How to create a Wise recipient in Rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateRequest\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]", "function_name": "WiseRecipientCreateRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise recipient creation request struct"}, {"query": "WiseRecipientCreateRequest struct definition hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateRequest\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]", "function_name": "WiseRecipientCreateRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise recipient creation request struct"}, {"query": "Hyperswitch Wise connector payout recipient creation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateRequest\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]", "function_name": "WiseRecipientCreateRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise recipient creation request struct"}, {"query": "Rust struct WiseRecipientCreateRequest fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: WiseRecipientCreateRequest\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]", "function_name": "WiseRecipientCreateRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise recipient creation request struct"}, {"query": "how to configure Powertranz connector authentication headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.common_get_content_type().to_string().into(),\n        )];\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth_header);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector header builder"}, {"query": "rust hyperswitch powertranz build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.common_get_content_type().to_string().into(),\n        )];\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth_header);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector header builder"}, {"query": "Powertranz connector HTTP header setup hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.common_get_content_type().to_string().into(),\n        )];\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth_header);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector header builder"}, {"query": "hyperswitch powertranz get_auth_header usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.common_get_content_type().to_string().into(),\n        )];\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth_header);\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz connector header builder"}, {"query": "how to format Order enum for display in hyperswitch analytics", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: fmt\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Ascending => write!(f, \"asc\"),\n            Self::Descending => write!(f, \"desc\"),\n        }\n    }\n}\n\n// Select TopN values for a group based on a metric\n// ---\n// Description -\n// columns: Columns in group to select TopN values for\n// count: N in TopN\n// order_column: metric used to sort and limit TopN\n// order: sort order of metric (Ascending / Descending)\n// ---\n// Usage -\n// Use via add_top_n_clause fn of query_builder\n// add_top_n_clause(\n//     &dimensions,\n//     distribution.distribution_cardinality.into(),\n//     \"count\",\n//     Order::Descending,\n// )\n#[allow(dead_code)]\n#[derive(Debug)]", "function_name": "fmt", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Order enum Display trait implementation"}, {"query": "hyperswitch query builder add_top_n_clause Order enum usage", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: fmt\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Ascending => write!(f, \"asc\"),\n            Self::Descending => write!(f, \"desc\"),\n        }\n    }\n}\n\n// Select TopN values for a group based on a metric\n// ---\n// Description -\n// columns: Columns in group to select TopN values for\n// count: N in TopN\n// order_column: metric used to sort and limit TopN\n// order: sort order of metric (Ascending / Descending)\n// ---\n// Usage -\n// Use via add_top_n_clause fn of query_builder\n// add_top_n_clause(\n//     &dimensions,\n//     distribution.distribution_cardinality.into(),\n//     \"count\",\n//     Order::Descending,\n// )\n#[allow(dead_code)]\n#[derive(Debug)]", "function_name": "fmt", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Order enum Display trait implementation"}, {"query": "rust fmt method implementation for Order enum hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: fmt\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Ascending => write!(f, \"asc\"),\n            Self::Descending => write!(f, \"desc\"),\n        }\n    }\n}\n\n// Select TopN values for a group based on a metric\n// ---\n// Description -\n// columns: Columns in group to select TopN values for\n// count: N in TopN\n// order_column: metric used to sort and limit TopN\n// order: sort order of metric (Ascending / Descending)\n// ---\n// Usage -\n// Use via add_top_n_clause fn of query_builder\n// add_top_n_clause(\n//     &dimensions,\n//     distribution.distribution_cardinality.into(),\n//     \"count\",\n//     Order::Descending,\n// )\n#[allow(dead_code)]\n#[derive(Debug)]", "function_name": "fmt", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Order enum Display trait implementation"}, {"query": "hyperswitch analytics sorting directions Ascending Descending fmt", "code": "// PATH: data/code_corpus_hyperswitch/crates__analytics__src__query.rs\n// MODULE: data::code_corpus_hyperswitch::crates__analytics__src__query.rs\n// SYMBOL: fmt\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Ascending => write!(f, \"asc\"),\n            Self::Descending => write!(f, \"desc\"),\n        }\n    }\n}\n\n// Select TopN values for a group based on a metric\n// ---\n// Description -\n// columns: Columns in group to select TopN values for\n// count: N in TopN\n// order_column: metric used to sort and limit TopN\n// order: sort order of metric (Ascending / Descending)\n// ---\n// Usage -\n// Use via add_top_n_clause fn of query_builder\n// add_top_n_clause(\n//     &dimensions,\n//     distribution.distribution_cardinality.into(),\n//     \"count\",\n//     Order::Descending,\n// )\n#[allow(dead_code)]\n#[derive(Debug)]", "function_name": "fmt", "file": "data/code_corpus_hyperswitch/crates__analytics__src__query.rs", "unit_type": "function", "label": "Order enum Display trait implementation"}, {"query": "Signifyd fraud decision response struct fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Decision\npub struct Decision {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    checkpoint_action: SignifydPaymentStatus,\n    checkpoint_action_reason: Option<String>,\n    checkpoint_action_policy: Option<String>,\n    score: Option<f64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "Decision", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Decision Response Struct"}, {"query": "how to parse signifyd checkpoint action in rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Decision\npub struct Decision {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    checkpoint_action: SignifydPaymentStatus,\n    checkpoint_action_reason: Option<String>,\n    checkpoint_action_policy: Option<String>,\n    score: Option<f64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "Decision", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Decision Response Struct"}, {"query": "hyperswitch signifyd connector decision struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Decision\npub struct Decision {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    checkpoint_action: SignifydPaymentStatus,\n    checkpoint_action_reason: Option<String>,\n    checkpoint_action_policy: Option<String>,\n    score: Option<f64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "Decision", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Decision Response Struct"}, {"query": "signifyd fraud score and checkpoint action types", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Decision\npub struct Decision {\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    created_at: PrimitiveDateTime,\n    checkpoint_action: SignifydPaymentStatus,\n    checkpoint_action_reason: Option<String>,\n    checkpoint_action_policy: Option<String>,\n    score: Option<f64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]", "function_name": "Decision", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Decision Response Struct"}, {"query": "hyperswitch CustomerInfo struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: CustomerInfo\npub struct CustomerInfo {\n    pub customer_id: Option<id_type::CustomerId>,\n    pub customer_email: Option<common_utils::pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub customer_phone_number: Option<Secret<String>>,\n    pub customer_phone_country_code: Option<String>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "CustomerInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "CustomerInfo struct definition"}, {"query": "how to define customer details in hyperswitch rust domain models", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: CustomerInfo\npub struct CustomerInfo {\n    pub customer_id: Option<id_type::CustomerId>,\n    pub customer_email: Option<common_utils::pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub customer_phone_number: Option<Secret<String>>,\n    pub customer_phone_country_code: Option<String>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "CustomerInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "CustomerInfo struct definition"}, {"query": "CustomerInfo struct fields hyperswitch payment orchestration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: CustomerInfo\npub struct CustomerInfo {\n    pub customer_id: Option<id_type::CustomerId>,\n    pub customer_email: Option<common_utils::pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub customer_phone_number: Option<Secret<String>>,\n    pub customer_phone_country_code: Option<String>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "CustomerInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "CustomerInfo struct definition"}, {"query": "hyperswitch domain models CustomerInfo source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: CustomerInfo\npub struct CustomerInfo {\n    pub customer_id: Option<id_type::CustomerId>,\n    pub customer_email: Option<common_utils::pii::Email>,\n    pub customer_name: Option<Secret<String>>,\n    pub customer_phone_number: Option<Secret<String>>,\n    pub customer_phone_country_code: Option<String>,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]", "function_name": "CustomerInfo", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "CustomerInfo struct definition"}, {"query": "Elavon CardPaymentRequest struct definition", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: CardPaymentRequest\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_card_number: CardNumber,\n    pub ssl_exp_date: Secret<String>,\n    pub ssl_cvv2cvc2: Secret<String>,\n    pub ssl_email: Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_add_token: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_get_token: Option<String>,\n    pub ssl_transaction_currency: Currency,\n}\n#[derive(Debug, Serialize)]", "function_name": "CardPaymentRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon payment request struct"}, {"query": "Hyperswitch Elavon connector payment request fields", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: CardPaymentRequest\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_card_number: CardNumber,\n    pub ssl_exp_date: Secret<String>,\n    pub ssl_cvv2cvc2: Secret<String>,\n    pub ssl_email: Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_add_token: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_get_token: Option<String>,\n    pub ssl_transaction_currency: Currency,\n}\n#[derive(Debug, Serialize)]", "function_name": "CardPaymentRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon payment request struct"}, {"query": "Rust struct for Elavon API payment payload", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: CardPaymentRequest\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_card_number: CardNumber,\n    pub ssl_exp_date: Secret<String>,\n    pub ssl_cvv2cvc2: Secret<String>,\n    pub ssl_email: Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_add_token: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_get_token: Option<String>,\n    pub ssl_transaction_currency: Currency,\n}\n#[derive(Debug, Serialize)]", "function_name": "CardPaymentRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon payment request struct"}, {"query": "ssl_account_id ssl_user_id Elavon hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: CardPaymentRequest\npub struct CardPaymentRequest {\n    pub ssl_transaction_type: TransactionType,\n    pub ssl_account_id: Secret<String>,\n    pub ssl_user_id: Secret<String>,\n    pub ssl_pin: Secret<String>,\n    pub ssl_amount: StringMajorUnit,\n    pub ssl_card_number: CardNumber,\n    pub ssl_exp_date: Secret<String>,\n    pub ssl_cvv2cvc2: Secret<String>,\n    pub ssl_email: Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_add_token: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ssl_get_token: Option<String>,\n    pub ssl_transaction_currency: Currency,\n}\n#[derive(Debug, Serialize)]", "function_name": "CardPaymentRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon payment request struct"}, {"query": "how to generate amazon pay authorization header in rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let http_method = self.get_http_method();\n\n        let canonical_uri: String =\n            self.get_url(req, connectors)?\n                .replacen(AMAZON_PAY_API_BASE_URL, \"\", 1);\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/json\".to_string().into(),\n            ),\n            (\n                HEADER_DATE.to_string(),\n                Utc::now()\n                    .format(\"%Y-%m-%dT%H:%M:%SZ\")\n                    .to_string()\n                    .into_masked(),\n            ),\n            (\n                HEADER_HOST.to_string(),\n                AMAZON_PAY_HOST.to_string().into_masked(),\n            ),\n            (HEADER_REGION.to_string(), \"na\".to_string().into_masked()),\n        ];\n\n        if http_method == Method::Post\n            && Self::get_last_segment(&canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            header.push((\n                HEADER_IDEMPOTENCY_KEY.to_string(),\n                req.connector_request_reference_id.clone().into_masked(),\n            ));\n        }\n\n        let hashed_payload = if http_method == Method::Get {\n            hex::encode(Sha256::digest(\"\".as_bytes()))\n        } else {\n            hex::encode(Sha256::digest(\n                self.get_request_body(req, connectors)?\n                    .get_inner_value()\n                    .expose()\n                    .as_bytes(),\n            ))\n        };\n\n        let authorization = self.create_authorization_header(\n            amazonpay::AmazonpayAuthType::try_from(&req.connector_auth_type)?,\n            &canonical_uri,\n            &http_method,\n            &hashed_payload,\n            &header,\n        );\n\n        header.push((\n            headers::AUTHORIZATION.to_string(),\n            authorization.clone().into_masked(),\n        ));\n\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay header builder"}, {"query": "hyperswitch amazonpay connector build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let http_method = self.get_http_method();\n\n        let canonical_uri: String =\n            self.get_url(req, connectors)?\n                .replacen(AMAZON_PAY_API_BASE_URL, \"\", 1);\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/json\".to_string().into(),\n            ),\n            (\n                HEADER_DATE.to_string(),\n                Utc::now()\n                    .format(\"%Y-%m-%dT%H:%M:%SZ\")\n                    .to_string()\n                    .into_masked(),\n            ),\n            (\n                HEADER_HOST.to_string(),\n                AMAZON_PAY_HOST.to_string().into_masked(),\n            ),\n            (HEADER_REGION.to_string(), \"na\".to_string().into_masked()),\n        ];\n\n        if http_method == Method::Post\n            && Self::get_last_segment(&canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            header.push((\n                HEADER_IDEMPOTENCY_KEY.to_string(),\n                req.connector_request_reference_id.clone().into_masked(),\n            ));\n        }\n\n        let hashed_payload = if http_method == Method::Get {\n            hex::encode(Sha256::digest(\"\".as_bytes()))\n        } else {\n            hex::encode(Sha256::digest(\n                self.get_request_body(req, connectors)?\n                    .get_inner_value()\n                    .expose()\n                    .as_bytes(),\n            ))\n        };\n\n        let authorization = self.create_authorization_header(\n            amazonpay::AmazonpayAuthType::try_from(&req.connector_auth_type)?,\n            &canonical_uri,\n            &http_method,\n            &hashed_payload,\n            &header,\n        );\n\n        header.push((\n            headers::AUTHORIZATION.to_string(),\n            authorization.clone().into_masked(),\n        ));\n\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay header builder"}, {"query": "rust function to create amazonpay api headers with idempotency", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let http_method = self.get_http_method();\n\n        let canonical_uri: String =\n            self.get_url(req, connectors)?\n                .replacen(AMAZON_PAY_API_BASE_URL, \"\", 1);\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/json\".to_string().into(),\n            ),\n            (\n                HEADER_DATE.to_string(),\n                Utc::now()\n                    .format(\"%Y-%m-%dT%H:%M:%SZ\")\n                    .to_string()\n                    .into_masked(),\n            ),\n            (\n                HEADER_HOST.to_string(),\n                AMAZON_PAY_HOST.to_string().into_masked(),\n            ),\n            (HEADER_REGION.to_string(), \"na\".to_string().into_masked()),\n        ];\n\n        if http_method == Method::Post\n            && Self::get_last_segment(&canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            header.push((\n                HEADER_IDEMPOTENCY_KEY.to_string(),\n                req.connector_request_reference_id.clone().into_masked(),\n            ));\n        }\n\n        let hashed_payload = if http_method == Method::Get {\n            hex::encode(Sha256::digest(\"\".as_bytes()))\n        } else {\n            hex::encode(Sha256::digest(\n                self.get_request_body(req, connectors)?\n                    .get_inner_value()\n                    .expose()\n                    .as_bytes(),\n            ))\n        };\n\n        let authorization = self.create_authorization_header(\n            amazonpay::AmazonpayAuthType::try_from(&req.connector_auth_type)?,\n            &canonical_uri,\n            &http_method,\n            &hashed_payload,\n            &header,\n        );\n\n        header.push((\n            headers::AUTHORIZATION.to_string(),\n            authorization.clone().into_masked(),\n        ));\n\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay header builder"}, {"query": "hyperswitch amazonpay signature generation build_headers", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__amazonpay.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let http_method = self.get_http_method();\n\n        let canonical_uri: String =\n            self.get_url(req, connectors)?\n                .replacen(AMAZON_PAY_API_BASE_URL, \"\", 1);\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                \"application/json\".to_string().into(),\n            ),\n            (\n                HEADER_DATE.to_string(),\n                Utc::now()\n                    .format(\"%Y-%m-%dT%H:%M:%SZ\")\n                    .to_string()\n                    .into_masked(),\n            ),\n            (\n                HEADER_HOST.to_string(),\n                AMAZON_PAY_HOST.to_string().into_masked(),\n            ),\n            (HEADER_REGION.to_string(), \"na\".to_string().into_masked()),\n        ];\n\n        if http_method == Method::Post\n            && Self::get_last_segment(&canonical_uri) != *FINALIZE_SEGMENT.to_string()\n        {\n            header.push((\n                HEADER_IDEMPOTENCY_KEY.to_string(),\n                req.connector_request_reference_id.clone().into_masked(),\n            ));\n        }\n\n        let hashed_payload = if http_method == Method::Get {\n            hex::encode(Sha256::digest(\"\".as_bytes()))\n        } else {\n            hex::encode(Sha256::digest(\n                self.get_request_body(req, connectors)?\n                    .get_inner_value()\n                    .expose()\n                    .as_bytes(),\n            ))\n        };\n\n        let authorization = self.create_authorization_header(\n            amazonpay::AmazonpayAuthType::try_from(&req.connector_auth_type)?,\n            &canonical_uri,\n            &http_method,\n            &hashed_payload,\n            &header,\n        );\n\n        header.push((\n            headers::AUTHORIZATION.to_string(),\n            authorization.clone().into_masked(),\n        ));\n\n        Ok(header)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__amazonpay.rs", "unit_type": "function", "label": "Amazon Pay header builder"}, {"query": "how to analyze value dependencies in euclid graph", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: value_analysis\n    fn value_analysis(\n        &self,\n        val: dir::DirValue,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "function_name": "value_analysis", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Euclid graph value dependency analysis"}, {"query": "euclid dssa graph value_analysis function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: value_analysis\n    fn value_analysis(\n        &self,\n        val: dir::DirValue,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "function_name": "value_analysis", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Euclid graph value dependency analysis"}, {"query": "rust euclid graph cycle detection memoization", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: value_analysis\n    fn value_analysis(\n        &self,\n        val: dir::DirValue,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "function_name": "value_analysis", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Euclid graph value dependency analysis"}, {"query": "how to filter domain analysis in euclid graph traversal", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: value_analysis\n    fn value_analysis(\n        &self,\n        val: dir::DirValue,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "function_name": "value_analysis", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "Euclid graph value dependency analysis"}, {"query": "rust hyperswitch gpayments connector error response implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\nimpl\n    ConnectorIntegration<\n        PostAuthentication,\n        ConnectorPostAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "Gpayments error response handler"}, {"query": "how does hyperswitch handle gpayments authentication errors", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\nimpl\n    ConnectorIntegration<\n        PostAuthentication,\n        ConnectorPostAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "Gpayments error response handler"}, {"query": "gpayments connector get_error_response function source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\nimpl\n    ConnectorIntegration<\n        PostAuthentication,\n        ConnectorPostAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "Gpayments error response handler"}, {"query": "hyperswitch rust connector error handling PostAuthentication", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gpayments.rs\n// SYMBOL: get_error_response\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}\nimpl\n    ConnectorIntegration<\n        PostAuthentication,\n        ConnectorPostAuthenticationRequestData,\n        AuthenticationResponseData,\n    > for Gpayments\n{", "function_name": "get_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gpayments.rs", "unit_type": "function", "label": "Gpayments error response handler"}, {"query": "how to retrieve metadata from merchant connector account", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_metadata\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.metadata.to_owned()\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_metadata", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnectorAccount metadata retrieval"}, {"query": "rust hyperswitch get_metadata function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_metadata\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.metadata.to_owned()\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_metadata", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnectorAccount metadata retrieval"}, {"query": "MerchantConnectorAccount enum metadata field access", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_metadata\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.metadata.to_owned()\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_metadata", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnectorAccount metadata retrieval"}, {"query": "hyperswitch domain models merchant connector account metadata", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_metadata\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.metadata.to_owned()\n            }\n            Self::MerchantConnectorDetails(_) => None,\n        }\n    }\n", "function_name": "get_metadata", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "MerchantConnectorAccount metadata retrieval"}, {"query": "rust function to convert authorize request to authipay json format", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = authipay::AuthipayRouterData::from((amount, req));\n        let connector_req = authipay::AuthipayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay request payload builder"}, {"query": "how does get_request_body handle currency conversion in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = authipay::AuthipayRouterData::from((amount, req));\n        let connector_req = authipay::AuthipayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay request payload builder"}, {"query": "authipay connector request body construction rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = authipay::AuthipayRouterData::from((amount, req));\n        let connector_req = authipay::AuthipayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay request payload builder"}, {"query": "PaymentsAuthorizeRouterData to AuthipayPaymentsRequest conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__authipay.rs\n// SYMBOL: get_request_body\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let amount = utils::convert_amount(\n            self.amount_converter,\n            req.request.minor_amount,\n            req.request.currency,\n        )?;\n\n        let connector_router_data = authipay::AuthipayRouterData::from((amount, req));\n        let connector_req = authipay::AuthipayPaymentsRequest::try_from(&connector_router_data)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n", "function_name": "get_request_body", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__authipay.rs", "unit_type": "function", "label": "Authipay request payload builder"}, {"query": "Klarna connector amount and router data transformation Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna connector data transformation"}, {"query": "hyperswitch Klarna from function minor unit router_data", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna connector data transformation"}, {"query": "Rust struct constructor from tuple amount router_data hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna connector data transformation"}, {"query": "Klarna payment orchestration connector data transformation Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs\n// SYMBOL: from\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__klarna__transformers.rs", "unit_type": "function", "label": "Klarna connector data transformation"}, {"query": "how to insert a new organization into the hyperswitch database", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: insert_org_in_db\n    pub async fn insert_org_in_db(self, state: SessionState) -> UserResult<Organization> {\n        state\n            .accounts_store\n            .insert_organization(self.0)\n            .await\n            .map_err(|e| {\n                if e.current_context().is_db_unique_violation() {\n                    e.change_context(UserErrors::DuplicateOrganizationId)\n                } else {\n                    e.change_context(UserErrors::InternalServerError)\n                }\n            })\n            .attach_printable(\"Error while inserting organization\")\n    }\n", "function_name": "insert_org_in_db", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Organization creation persistence"}, {"query": "rust function to create organization in accounts_store", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: insert_org_in_db\n    pub async fn insert_org_in_db(self, state: SessionState) -> UserResult<Organization> {\n        state\n            .accounts_store\n            .insert_organization(self.0)\n            .await\n            .map_err(|e| {\n                if e.current_context().is_db_unique_violation() {\n                    e.change_context(UserErrors::DuplicateOrganizationId)\n                } else {\n                    e.change_context(UserErrors::InternalServerError)\n                }\n            })\n            .attach_printable(\"Error while inserting organization\")\n    }\n", "function_name": "insert_org_in_db", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Organization creation persistence"}, {"query": "hyperswitch insert_organization_in_db error handling duplicate id", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: insert_org_in_db\n    pub async fn insert_org_in_db(self, state: SessionState) -> UserResult<Organization> {\n        state\n            .accounts_store\n            .insert_organization(self.0)\n            .await\n            .map_err(|e| {\n                if e.current_context().is_db_unique_violation() {\n                    e.change_context(UserErrors::DuplicateOrganizationId)\n                } else {\n                    e.change_context(UserErrors::InternalServerError)\n                }\n            })\n            .attach_printable(\"Error while inserting organization\")\n    }\n", "function_name": "insert_org_in_db", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Organization creation persistence"}, {"query": "code for creating a new organization tenant in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__types__domain__user.rs\n// SYMBOL: insert_org_in_db\n    pub async fn insert_org_in_db(self, state: SessionState) -> UserResult<Organization> {\n        state\n            .accounts_store\n            .insert_organization(self.0)\n            .await\n            .map_err(|e| {\n                if e.current_context().is_db_unique_violation() {\n                    e.change_context(UserErrors::DuplicateOrganizationId)\n                } else {\n                    e.change_context(UserErrors::InternalServerError)\n                }\n            })\n            .attach_printable(\"Error while inserting organization\")\n    }\n", "function_name": "insert_org_in_db", "file": "data/code_corpus_hyperswitch/crates__router__src__types__domain__user.rs", "unit_type": "function", "label": "Organization creation persistence"}, {"query": "how to handle airwallex api error responses in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =\n            res.response.parse_struct(\"Airwallex ErrorResponse\");\n\n        match response {\n            Ok(response) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                let network_error_message = response\n                    .provider_original_response_code\n                    .clone()\n                    .and_then(airwallex::map_error_code_to_message);\n                Ok(ErrorResponse {\n                    status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.source,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: response.provider_original_response_code.clone(),\n                    network_error_message,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                connector_utils::handle_json_response_deserialization_failure(res, \"tesouro\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex error response builder"}, {"query": "airwallex connector error response builder function rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =\n            res.response.parse_struct(\"Airwallex ErrorResponse\");\n\n        match response {\n            Ok(response) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                let network_error_message = response\n                    .provider_original_response_code\n                    .clone()\n                    .and_then(airwallex::map_error_code_to_message);\n                Ok(ErrorResponse {\n                    status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.source,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: response.provider_original_response_code.clone(),\n                    network_error_message,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                connector_utils::handle_json_response_deserialization_failure(res, \"tesouro\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex error response builder"}, {"query": "map airwallex error codes to hyperswitch error messages", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =\n            res.response.parse_struct(\"Airwallex ErrorResponse\");\n\n        match response {\n            Ok(response) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                let network_error_message = response\n                    .provider_original_response_code\n                    .clone()\n                    .and_then(airwallex::map_error_code_to_message);\n                Ok(ErrorResponse {\n                    status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.source,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: response.provider_original_response_code.clone(),\n                    network_error_message,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                connector_utils::handle_json_response_deserialization_failure(res, \"tesouro\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex error response builder"}, {"query": "handle  deserialization failure in airwallex connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_error_response\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =\n            res.response.parse_struct(\"Airwallex ErrorResponse\");\n\n        match response {\n            Ok(response) => {\n                event_builder.map(|i| i.set_error_response_body(&response));\n                router_env::logger::info!(connector_response=?response);\n                let network_error_message = response\n                    .provider_original_response_code\n                    .clone()\n                    .and_then(airwallex::map_error_code_to_message);\n                Ok(ErrorResponse {\n                    status_code,\n                    code: response.code,\n                    message: response.message,\n                    reason: response.source,\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    connector_response_reference_id: None,\n                    network_advice_code: None,\n                    network_decline_code: response.provider_original_response_code.clone(),\n                    network_error_message,\n                    connector_metadata: None,\n                })\n            }\n            Err(error_msg) => {\n                event_builder.map(|event| event.set_error(serde_json::json!({\"error\": res.response.escape_ascii().to_string(), \"status_code\": status_code})));\n                router_env::logger::error!(deserialization_error =? error_msg);\n                connector_utils::handle_json_response_deserialization_failure(res, \"tesouro\")\n            }\n        }\n    }\n}\n", "function_name": "build_error_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex error response builder"}, {"query": "rust euclid crate key_analysis function signature", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: key_analysis\n    fn key_analysis(\n        &self,\n        key: dir::DirKey,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "function_name": "key_analysis", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSA graph key analysis"}, {"query": "hyperswitch dsa graph key_analysis implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: key_analysis\n    fn key_analysis(\n        &self,\n        key: dir::DirKey,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "function_name": "key_analysis", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSA graph key analysis"}, {"query": "how does key_analysis work in euclid crate", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: key_analysis\n    fn key_analysis(\n        &self,\n        key: dir::DirKey,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "function_name": "key_analysis", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSA graph key analysis"}, {"query": "rust AnalysisContext key_analysis function", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: key_analysis\n    fn key_analysis(\n        &self,\n        key: dir::DirKey,\n        ctx: &AnalysisContext,\n        memo: &mut cgraph::Memoization<dir::DirValue>,\n        cycle_map: &mut cgraph::CycleCheck,\n        domains: Option<&[String]>,\n    ) -> Result<(), cgraph::GraphError<dir::DirValue>>;\n", "function_name": "key_analysis", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DSA graph key analysis"}, {"query": "how to add a new merchant connector account in hyperswitch rust storage", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: insert_merchant_connector_account\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n", "function_name": "insert_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant account persistence abstraction"}, {"query": "rust hyperswitch insert_merchant_connector_account implementation details", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: insert_merchant_connector_account\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n", "function_name": "insert_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant account persistence abstraction"}, {"query": "hyperswitch storage layer merchant connector account persistence", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: insert_merchant_connector_account\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n", "function_name": "insert_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant account persistence abstraction"}, {"query": "rust hyperswitch key_store parameter for account insertion", "code": "// PATH: data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__storage_impl__src__merchant_connector_account.rs\n// SYMBOL: insert_merchant_connector_account\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n", "function_name": "insert_merchant_connector_account", "file": "data/code_corpus_hyperswitch/crates__storage_impl__src__merchant_connector_account.rs", "unit_type": "function", "label": "Merchant account persistence abstraction"}, {"query": "How to configure recipient type for Wise payouts in Hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: RecipientType\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "RecipientType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise recipient type enum"}, {"query": "Rust enum RecipientType Wise connector implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: RecipientType\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "RecipientType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise recipient type enum"}, {"query": "Hyperswitch Wise transformer recipient types Aba Iban SortCode", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: RecipientType\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "RecipientType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise recipient type enum"}, {"query": "Wise API recipient type mapping Hyperswitch Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wise__transformers.rs\n// SYMBOL: RecipientType\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]", "function_name": "RecipientType", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wise__transformers.rs", "unit_type": "function", "label": "Wise recipient type enum"}, {"query": "rust iatapay payment status mapping function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: from\n    fn from(item: IatapayPaymentStatus) -> Self {\n        match item {\n            IatapayPaymentStatus::Authorized\n            | IatapayPaymentStatus::Settled\n            | IatapayPaymentStatus::Cleared => Self::Charged,\n            IatapayPaymentStatus::Failed | IatapayPaymentStatus::UnexpectedSettled => Self::Failure,\n            IatapayPaymentStatus::Created => Self::AuthenticationPending,\n            IatapayPaymentStatus::Initiated => Self::Pending,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay status mapping"}, {"query": "how to convert IatapayPaymentStatus to internal status", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: from\n    fn from(item: IatapayPaymentStatus) -> Self {\n        match item {\n            IatapayPaymentStatus::Authorized\n            | IatapayPaymentStatus::Settled\n            | IatapayPaymentStatus::Cleared => Self::Charged,\n            IatapayPaymentStatus::Failed | IatapayPaymentStatus::UnexpectedSettled => Self::Failure,\n            IatapayPaymentStatus::Created => Self::AuthenticationPending,\n            IatapayPaymentStatus::Initiated => Self::Pending,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay status mapping"}, {"query": "hyperswitch connector iatapay status transformation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: from\n    fn from(item: IatapayPaymentStatus) -> Self {\n        match item {\n            IatapayPaymentStatus::Authorized\n            | IatapayPaymentStatus::Settled\n            | IatapayPaymentStatus::Cleared => Self::Charged,\n            IatapayPaymentStatus::Failed | IatapayPaymentStatus::UnexpectedSettled => Self::Failure,\n            IatapayPaymentStatus::Created => Self::AuthenticationPending,\n            IatapayPaymentStatus::Initiated => Self::Pending,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay status mapping"}, {"query": "IatapayPaymentStatus enum mapping logic rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs\n// SYMBOL: from\n    fn from(item: IatapayPaymentStatus) -> Self {\n        match item {\n            IatapayPaymentStatus::Authorized\n            | IatapayPaymentStatus::Settled\n            | IatapayPaymentStatus::Cleared => Self::Charged,\n            IatapayPaymentStatus::Failed | IatapayPaymentStatus::UnexpectedSettled => Self::Failure,\n            IatapayPaymentStatus::Created => Self::AuthenticationPending,\n            IatapayPaymentStatus::Initiated => Self::Pending,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__iatapay__transformers.rs", "unit_type": "function", "label": "IATAPay status mapping"}, {"query": "how to generate wells fargo signature header rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: wellsfargo::WellsfargoAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let wellsfargo::WellsfargoAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo Signature Generation"}, {"query": "wellsfargo connector signature generation hmac sha256", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: wellsfargo::WellsfargoAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let wellsfargo::WellsfargoAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo Signature Generation"}, {"query": "rust function create wells fargo authorization header", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: wellsfargo::WellsfargoAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let wellsfargo::WellsfargoAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo Signature Generation"}, {"query": "hyperswitch wells fargo signature implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__wellsfargo.rs\n// SYMBOL: generate_signature\n    pub fn generate_signature(\n        &self,\n        auth: wellsfargo::WellsfargoAuthType,\n        host: String,\n        resource: &str,\n        payload: &String,\n        date: OffsetDateTime,\n        http_method: Method,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let wellsfargo::WellsfargoAuthType {\n            api_key,\n            merchant_account,\n            api_secret,\n        } = auth;\n        let is_post_method = matches!(http_method, Method::Post);\n        let is_patch_method = matches!(http_method, Method::Patch);\n        let is_delete_method = matches!(http_method, Method::Delete);\n        let digest_str = if is_post_method || is_patch_method {\n            \"digest \"\n        } else {\n            \"\"\n        };\n        let headers = format!(\"host date (request-target) {digest_str}v-c-merchant-id\");\n        let request_target = if is_post_method {\n            format!(\"(request-target): post {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_patch_method {\n            format!(\"(request-target): patch {resource}\\ndigest: SHA-256={payload}\\n\")\n        } else if is_delete_method {\n            format!(\"(request-target): delete {resource}\\n\")\n        } else {\n            format!(\"(request-target): get {resource}\\n\")\n        };\n        let signature_string = format!(\n            \"host: {host}\\ndate: {date}\\n{request_target}v-c-merchant-id: {}\",\n            merchant_account.peek()\n        );\n        let key_value = consts::BASE64_ENGINE\n            .decode(api_secret.expose())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"connector_account_details.api_secret\",\n            })?;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, &key_value);\n        let signature_value =\n            consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_string.as_bytes()).as_ref());\n        let signature_header = format!(\n            r#\"keyid=\"{}\", algorithm=\"HmacSHA256\", headers=\"{headers}\", signature=\"{signature_value}\"\"#,\n            api_key.peek()\n        );\n\n        Ok(signature_header)\n    }\n}\n", "function_name": "generate_signature", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__wellsfargo.rs", "unit_type": "function", "label": "Wells Fargo Signature Generation"}, {"query": "how to configure bearer token authentication in Airwallex connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex auth header builder"}, {"query": "rust function to generate authorization header for Airwallex API", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex auth header builder"}, {"query": "hyperswitch Airwallex connector build_headers implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex auth header builder"}, {"query": "how does hyperswitch handle access tokens in Airwallex integration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__airwallex.rs\n// SYMBOL: build_headers\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n", "function_name": "build_headers", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__airwallex.rs", "unit_type": "function", "label": "Airwallex auth header builder"}, {"query": "rust hyperswitch euclid dssa graph builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_node_values\n    fn from_node_values<L>(vals: impl IntoIterator<Item = L>) -> Self\n    where\n        L: Into<Self::Value>,\n    {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals.into_iter().map(L::into) {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "function_name": "from_node_values", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DsaGraph builder from DirValue"}, {"query": "how to create DssaGraph from DirValue iterator", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_node_values\n    fn from_node_values<L>(vals: impl IntoIterator<Item = L>) -> Self\n    where\n        L: Into<Self::Value>,\n    {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals.into_iter().map(L::into) {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "function_name": "from_node_values", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DsaGraph builder from DirValue"}, {"query": "euclid crate DsaGraph from_node_values implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_node_values\n    fn from_node_values<L>(vals: impl IntoIterator<Item = L>) -> Self\n    where\n        L: Into<Self::Value>,\n    {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals.into_iter().map(L::into) {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "function_name": "from_node_values", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DsaGraph builder from DirValue"}, {"query": "hyperswitch dependency subgraph analysis graph construction", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: from_node_values\n    fn from_node_values<L>(vals: impl IntoIterator<Item = L>) -> Self\n    where\n        L: Into<Self::Value>,\n    {\n        let mut keywise_values: FxHashMap<dir::DirKey, FxHashSet<dir::DirValue>> =\n            FxHashMap::default();\n\n        for dir_val in vals.into_iter().map(L::into) {\n            let key = dir_val.get_key();\n            let set = keywise_values.entry(key).or_default();\n            set.insert(dir_val);\n        }\n\n        Self { keywise_values }\n    }\n", "function_name": "from_node_values", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "DsaGraph builder from DirValue"}, {"query": "PayMe 3DS request struct fields buyer_name buyer_email", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: Pay3dsRequest\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "function_name": "Pay3dsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe 3DS Request Struct"}, {"query": "hyperswitch payme connector 3ds request structure", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: Pay3dsRequest\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "function_name": "Pay3dsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe 3DS Request Struct"}, {"query": "PayMe payment gateway 3D Secure request payload rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: Pay3dsRequest\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "function_name": "Pay3dsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe 3DS Request Struct"}, {"query": "hyperswitch payme transformer 3ds data model", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__payme__transformers.rs\n// SYMBOL: Pay3dsRequest\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]", "function_name": "Pay3dsRequest", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__payme__transformers.rs", "unit_type": "function", "label": "PayMe 3DS Request Struct"}, {"query": "how to generate basic auth header for gigadat connector hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.access_token.peek(),\n            auth.security_token.peek()\n        );\n        let auth_header = format!(\"Basic {}\", consts::BASE64_ENGINE.encode(auth_key));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_header.into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Basic Auth Header"}, {"query": "rust hyperswitch gigadat connector authentication implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.access_token.peek(),\n            auth.security_token.peek()\n        );\n        let auth_header = format!(\"Basic {}\", consts::BASE64_ENGINE.encode(auth_key));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_header.into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Basic Auth Header"}, {"query": "hyperswitch gigadat get_auth_header function source code", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.access_token.peek(),\n            auth.security_token.peek()\n        );\n        let auth_header = format!(\"Basic {}\", consts::BASE64_ENGINE.encode(auth_key));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_header.into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Basic Auth Header"}, {"query": "gigadat connector hyperswitch basic auth token generation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__gigadat.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = gigadat::GigadatAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.access_token.peek(),\n            auth.security_token.peek()\n        );\n        let auth_header = format!(\"Basic {}\", consts::BASE64_ENGINE.encode(auth_key));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_header.into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__gigadat.rs", "unit_type": "function", "label": "Gigadat Basic Auth Header"}, {"query": "how to configure 3ds versioning url for netcetera connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let base_url = build_endpoint(self.base_url(connectors), &req.connector_meta_data)?;\n        Ok(format!(\"{base_url}/3ds/versioning\"))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera 3DS URL builder"}, {"query": "netcetera connector get_url implementation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let base_url = build_endpoint(self.base_url(connectors), &req.connector_meta_data)?;\n        Ok(format!(\"{base_url}/3ds/versioning\"))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera 3DS URL builder"}, {"query": "hyperswitch netcetera 3ds endpoint configuration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let base_url = build_endpoint(self.base_url(connectors), &req.connector_meta_data)?;\n        Ok(format!(\"{base_url}/3ds/versioning\"))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera 3DS URL builder"}, {"query": "PreAuthNRouterData netcetera get_url function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__netcetera.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        req: &PreAuthNRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, ConnectorError> {\n        let base_url = build_endpoint(self.base_url(connectors), &req.connector_meta_data)?;\n        Ok(format!(\"{base_url}/3ds/versioning\"))\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__netcetera.rs", "unit_type": "function", "label": "Netcetera 3DS URL builder"}, {"query": "rust enum get connector name string", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name_as_string\n    pub fn get_connector_name_as_string(&self) -> String {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name.to_string()\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name.to_string()\n            }\n        }\n    }\n", "function_name": "get_connector_name_as_string", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Enum field extraction utility"}, {"query": "how to convert merchant connector account to string", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name_as_string\n    pub fn get_connector_name_as_string(&self) -> String {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name.to_string()\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name.to_string()\n            }\n        }\n    }\n", "function_name": "get_connector_name_as_string", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Enum field extraction utility"}, {"query": "hyperswitch domain models get_connector_name_as_string", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name_as_string\n    pub fn get_connector_name_as_string(&self) -> String {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name.to_string()\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name.to_string()\n            }\n        }\n    }\n", "function_name": "get_connector_name_as_string", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Enum field extraction utility"}, {"query": "extract connector name from merchant connector details rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__merchant_connector_account.rs\n// SYMBOL: get_connector_name_as_string\n    pub fn get_connector_name_as_string(&self) -> String {\n        match self {\n            Self::MerchantConnectorAccount(merchant_connector_account) => {\n                merchant_connector_account.connector_name.to_string()\n            }\n            Self::MerchantConnectorDetails(merchant_connector_details) => {\n                merchant_connector_details.connector_name.to_string()\n            }\n        }\n    }\n", "function_name": "get_connector_name_as_string", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__merchant_connector_account.rs", "unit_type": "function", "label": "Enum field extraction utility"}, {"query": "how to get billing city from payment object rust hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_billing_city\n    pub fn get_billing_city(&self) -> Option<String> {\n        self.billing_details\n            .as_ref()\n            .and_then(|billing| billing.address_city.clone())\n    }\n}\n// Different patterns of authentication.\n#[derive(Default, Debug, Clone, Deserialize, Serialize)]\n#[serde(tag = \"auth_type\")]", "function_name": "get_billing_city", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "billing city retrieval"}, {"query": "hyperswitch get_billing_city function implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_billing_city\n    pub fn get_billing_city(&self) -> Option<String> {\n        self.billing_details\n            .as_ref()\n            .and_then(|billing| billing.address_city.clone())\n    }\n}\n// Different patterns of authentication.\n#[derive(Default, Debug, Clone, Deserialize, Serialize)]\n#[serde(tag = \"auth_type\")]", "function_name": "get_billing_city", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "billing city retrieval"}, {"query": "rust Option<String> billing address city retrieval", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_billing_city\n    pub fn get_billing_city(&self) -> Option<String> {\n        self.billing_details\n            .as_ref()\n            .and_then(|billing| billing.address_city.clone())\n    }\n}\n// Different patterns of authentication.\n#[derive(Default, Debug, Clone, Deserialize, Serialize)]\n#[serde(tag = \"auth_type\")]", "function_name": "get_billing_city", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "billing city retrieval"}, {"query": "hyperswitch domain models router_data billing details", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_data.rs\n// SYMBOL: get_billing_city\n    pub fn get_billing_city(&self) -> Option<String> {\n        self.billing_details\n            .as_ref()\n            .and_then(|billing| billing.address_city.clone())\n    }\n}\n// Different patterns of authentication.\n#[derive(Default, Debug, Clone, Deserialize, Serialize)]\n#[serde(tag = \"auth_type\")]", "function_name": "get_billing_city", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_data.rs", "unit_type": "function", "label": "billing city retrieval"}, {"query": "Rust struct Destination hyperswitch signifyd connector", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Destination\npub struct Destination {\n    full_name: Secret<String>,\n    organization: Option<String>,\n    email: Option<Email>,\n    address: Address,\n}\n\n#[derive(Debug, Serialize, Deserialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Destination", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Destination Struct"}, {"query": "how to define destination entity in signifyd transformer", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Destination\npub struct Destination {\n    full_name: Secret<String>,\n    organization: Option<String>,\n    email: Option<Email>,\n    address: Address,\n}\n\n#[derive(Debug, Serialize, Deserialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Destination", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Destination Struct"}, {"query": "hyperswitch signifyd destination struct fields organization email", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Destination\npub struct Destination {\n    full_name: Secret<String>,\n    organization: Option<String>,\n    email: Option<Email>,\n    address: Address,\n}\n\n#[derive(Debug, Serialize, Deserialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Destination", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Destination Struct"}, {"query": "signifyd fraud detection connector destination address rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs\n// SYMBOL: Destination\npub struct Destination {\n    full_name: Secret<String>,\n    organization: Option<String>,\n    email: Option<Email>,\n    address: Address,\n}\n\n#[derive(Debug, Serialize, Deserialize, Eq, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Destination", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__signifyd__transformers__api.rs", "unit_type": "function", "label": "Signifyd Destination Struct"}, {"query": "how to build request for juspay 3ds authorization", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Authorization Request Builder"}, {"query": "PaymentsAuthorizeRouterData build_request implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Authorization Request Builder"}, {"query": "hyperswitch juspay connector request builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Authorization Request Builder"}, {"query": "juspaythreedsserver build_request function rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::PaymentsAuthorizeType::get_url(\n                    self, req, connectors,\n                )?)\n                .attach_default_headers()\n                .headers(types::PaymentsAuthorizeType::get_headers(\n                    self, req, connectors,\n                )?)\n                .set_body(types::PaymentsAuthorizeType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__juspaythreedsserver.rs", "unit_type": "function", "label": "Juspay 3DS Authorization Request Builder"}, {"query": "rust hyperswitch powertranz connector handle_response function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: powertranz::PowertranzBaseResponse = res\n            .response\n            .parse_struct(\"Powertranz PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz authorize response handler"}, {"query": "how to parse powertranz authorize response in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: powertranz::PowertranzBaseResponse = res\n            .response\n            .parse_struct(\"Powertranz PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz authorize response handler"}, {"query": "hyperswitch powertranz connector deserialization error", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: powertranz::PowertranzBaseResponse = res\n            .response\n            .parse_struct(\"Powertranz PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz authorize response handler"}, {"query": "rust connector event builder set_response_body hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__powertranz.rs\n// SYMBOL: handle_response\n    fn handle_response(\n        &self,\n        data: &PaymentsAuthorizeRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: powertranz::PowertranzBaseResponse = res\n            .response\n            .parse_struct(\"Powertranz PaymentsAuthorizeResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n", "function_name": "handle_response", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__powertranz.rs", "unit_type": "function", "label": "Powertranz authorize response handler"}, {"query": "WorldPay Modular webhook configuration struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentLinks\npub struct PaymentLinks {\n    #[serde(\n        rename = \"cardPayments:events\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub events: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:settle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialSettle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:refund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialRefund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:reverse\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub reverse_event: Option<PaymentLink>,\n    #[serde(rename = \"tokens:token\", skip_serializing_if = \"Option::is_none\")]\n    pub token: Option<SecretPaymentLink>,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "function_name": "PaymentLinks", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "WorldPay Modular webhook config struct"}, {"query": "how to configure payment link events in WorldPay Modular", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentLinks\npub struct PaymentLinks {\n    #[serde(\n        rename = \"cardPayments:events\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub events: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:settle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialSettle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:refund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialRefund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:reverse\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub reverse_event: Option<PaymentLink>,\n    #[serde(rename = \"tokens:token\", skip_serializing_if = \"Option::is_none\")]\n    pub token: Option<SecretPaymentLink>,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "function_name": "PaymentLinks", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "WorldPay Modular webhook config struct"}, {"query": "WorldPay Modular response transformer PaymentLinks struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentLinks\npub struct PaymentLinks {\n    #[serde(\n        rename = \"cardPayments:events\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub events: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:settle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialSettle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:refund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialRefund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:reverse\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub reverse_event: Option<PaymentLink>,\n    #[serde(rename = \"tokens:token\", skip_serializing_if = \"Option::is_none\")]\n    pub token: Option<SecretPaymentLink>,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "function_name": "PaymentLinks", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "WorldPay Modular webhook config struct"}, {"query": "hyperswitch worldpay modular webhook event mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs\n// SYMBOL: PaymentLinks\npub struct PaymentLinks {\n    #[serde(\n        rename = \"cardPayments:events\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub events: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:settle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialSettle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:refund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialRefund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:reverse\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub reverse_event: Option<PaymentLink>,\n    #[serde(rename = \"tokens:token\", skip_serializing_if = \"Option::is_none\")]\n    pub token: Option<SecretPaymentLink>,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]", "function_name": "PaymentLinks", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs", "unit_type": "function", "label": "WorldPay Modular webhook config struct"}, {"query": "rust hyperswitch sift connector get_url method implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector get_url placeholder"}, {"query": "hyperswitch sift connector get_url function returns NotImplemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector get_url placeholder"}, {"query": "how to implement get_url in hyperswitch sift connector rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector get_url placeholder"}, {"query": "hyperswitch sift connector get_url trait implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__sift.rs\n// SYMBOL: get_url\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"get_url method\".to_string()).into())\n    }\n", "function_name": "get_url", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__sift.rs", "unit_type": "function", "label": "Sift connector get_url placeholder"}, {"query": "rust AnalysisError enum definition euclid crate", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: AnalysisError\npub enum AnalysisError<V: cgraph::ValueNode> {\n    Graph(cgraph::GraphError<V>),\n    AssertionTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Metadata,\n    },\n    NegationTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Vec<Metadata>,\n    },\n}\n\nimpl<V: cgraph::ValueNode> AnalysisError<V> {", "function_name": "AnalysisError", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "AnalysisError enum definition"}, {"query": "hyperswitch euclid dssa graph error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: AnalysisError\npub enum AnalysisError<V: cgraph::ValueNode> {\n    Graph(cgraph::GraphError<V>),\n    AssertionTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Metadata,\n    },\n    NegationTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Vec<Metadata>,\n    },\n}\n\nimpl<V: cgraph::ValueNode> AnalysisError<V> {", "function_name": "AnalysisError", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "AnalysisError enum definition"}, {"query": "AnalysisError Graph AssertionTrace NegationTrace rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: AnalysisError\npub enum AnalysisError<V: cgraph::ValueNode> {\n    Graph(cgraph::GraphError<V>),\n    AssertionTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Metadata,\n    },\n    NegationTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Vec<Metadata>,\n    },\n}\n\nimpl<V: cgraph::ValueNode> AnalysisError<V> {", "function_name": "AnalysisError", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "AnalysisError enum definition"}, {"query": "euclid crate AnalysisError trait implementation cgraph", "code": "// PATH: data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs\n// MODULE: data::code_corpus_hyperswitch::crates__euclid__src__dssa__graph.rs\n// SYMBOL: AnalysisError\npub enum AnalysisError<V: cgraph::ValueNode> {\n    Graph(cgraph::GraphError<V>),\n    AssertionTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Metadata,\n    },\n    NegationTrace {\n        trace: Weak<cgraph::AnalysisTrace<V>>,\n        metadata: Vec<Metadata>,\n    },\n}\n\nimpl<V: cgraph::ValueNode> AnalysisError<V> {", "function_name": "AnalysisError", "file": "data/code_corpus_hyperswitch/crates__euclid__src__dssa__graph.rs", "unit_type": "function", "label": "AnalysisError enum definition"}, {"query": "rust elavon connector signature key authentication conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                account_id: api_key.to_owned(),\n                user_id: key1.to_owned(),\n                pin: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon Auth Signature Key Conversion"}, {"query": "how does hyperswitch elavon transform auth type to signature key", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                account_id: api_key.to_owned(),\n                user_id: key1.to_owned(),\n                pin: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon Auth Signature Key Conversion"}, {"query": "elavon connector try_from signature key implementation rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                account_id: api_key.to_owned(),\n                user_id: key1.to_owned(),\n                pin: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon Auth Signature Key Conversion"}, {"query": "hyperswitch elavon auth pin account_id user_id mapping", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs\n// SYMBOL: try_from\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                account_id: api_key.to_owned(),\n                user_id: key1.to_owned(),\n                pin: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]", "function_name": "try_from", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__elavon__transformers.rs", "unit_type": "function", "label": "Elavon Auth Signature Key Conversion"}, {"query": "how to get authorization header for barclaycard connector rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let auth = barclaycard::BarclaycardAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard auth header generator"}, {"query": "rust hyperswitch barclaycard get_auth_header implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let auth = barclaycard::BarclaycardAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard auth header generator"}, {"query": "barclaycard connector authentication header generation hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let auth = barclaycard::BarclaycardAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard auth header generator"}, {"query": "hyperswitch barclaycard auth_type to header conversion", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__barclaycard.rs\n// SYMBOL: get_auth_header\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let auth = barclaycard::BarclaycardAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n", "function_name": "get_auth_header", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__barclaycard.rs", "unit_type": "function", "label": "Barclaycard auth header generator"}, {"query": "rust enum Authentication redirectUrl hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Authentication\npub enum Authentication {\n    RedirectUrl {\n        #[serde(rename = \"redirectUrl\")]\n        redirect_url: String,\n    },\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Authentication", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Authentication RedirectUrl Enum"}, {"query": "hyperswitch tokenio Authentication RedirectUrl struct", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Authentication\npub enum Authentication {\n    RedirectUrl {\n        #[serde(rename = \"redirectUrl\")]\n        redirect_url: String,\n    },\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Authentication", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Authentication RedirectUrl Enum"}, {"query": "how to handle redirectUrl in hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Authentication\npub enum Authentication {\n    RedirectUrl {\n        #[serde(rename = \"redirectUrl\")]\n        redirect_url: String,\n    },\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Authentication", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Authentication RedirectUrl Enum"}, {"query": "Authentication enum definition hyperswitch tokenio", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs\n// SYMBOL: Authentication\npub enum Authentication {\n    RedirectUrl {\n        #[serde(rename = \"redirectUrl\")]\n        redirect_url: String,\n    },\n}\n\n#[derive(Debug, Serialize, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]", "function_name": "Authentication", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__tokenio__transformers.rs", "unit_type": "function", "label": "Authentication RedirectUrl Enum"}, {"query": "Redsys connector setup mandate build_request rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Redsys\".to_string())\n                .into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Redsys\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys Setup Mandate build_request"}, {"query": "hyperswitch redsys build_request function not implemented", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Redsys\".to_string())\n                .into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Redsys\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys Setup Mandate build_request"}, {"query": "how to implement setup mandate in redsys connector rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Redsys\".to_string())\n                .into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Redsys\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys Setup Mandate build_request"}, {"query": "redsys setup mandate flow hyperswitch error handling", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__redsys.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        _req: &RouterData<SetupMandate, SetupMandateRequestData, PaymentsResponseData>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(\n            errors::ConnectorError::NotImplemented(\"Setup Mandate flow for Redsys\".to_string())\n                .into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Redsys\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__redsys.rs", "unit_type": "function", "label": "Redsys Setup Mandate build_request"}, {"query": "rust hyperswitch get_mca_from_payout_attempt implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payout_attempt\npub async fn get_mca_from_payout_attempt(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payout_id_type: webhooks::PayoutIdType,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let payout = match payout_id_type {\n        webhooks::PayoutIdType::PayoutAttemptId(payout_attempt_id) => db\n            .find_payout_attempt_by_merchant_id_payout_attempt_id(\n                platform.get_processor().get_account().get_id(),\n                &payout_attempt_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n        webhooks::PayoutIdType::ConnectorPayoutId(connector_payout_id) => db\n            .find_payout_attempt_by_merchant_id_connector_payout_id(\n                platform.get_processor().get_account().get_id(),\n                &connector_payout_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n    };\n    match payout.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = platform.get_processor().get_key_store();\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &payout.profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {}\",\n                            payout.profile_id.get_string_repr(),\n                            connector_name\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                todo!()\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "get_mca_from_payout_attempt", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Payout MCA Resolution Utility"}, {"query": "how to resolve merchant connector account from payout attempt id hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payout_attempt\npub async fn get_mca_from_payout_attempt(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payout_id_type: webhooks::PayoutIdType,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let payout = match payout_id_type {\n        webhooks::PayoutIdType::PayoutAttemptId(payout_attempt_id) => db\n            .find_payout_attempt_by_merchant_id_payout_attempt_id(\n                platform.get_processor().get_account().get_id(),\n                &payout_attempt_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n        webhooks::PayoutIdType::ConnectorPayoutId(connector_payout_id) => db\n            .find_payout_attempt_by_merchant_id_connector_payout_id(\n                platform.get_processor().get_account().get_id(),\n                &connector_payout_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n    };\n    match payout.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = platform.get_processor().get_key_store();\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &payout.profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {}\",\n                            payout.profile_id.get_string_repr(),\n                            connector_name\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                todo!()\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "get_mca_from_payout_attempt", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Payout MCA Resolution Utility"}, {"query": "hyperswitch router utils get_mca_from_payout_attempt v1 v2 feature flag", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payout_attempt\npub async fn get_mca_from_payout_attempt(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payout_id_type: webhooks::PayoutIdType,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let payout = match payout_id_type {\n        webhooks::PayoutIdType::PayoutAttemptId(payout_attempt_id) => db\n            .find_payout_attempt_by_merchant_id_payout_attempt_id(\n                platform.get_processor().get_account().get_id(),\n                &payout_attempt_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n        webhooks::PayoutIdType::ConnectorPayoutId(connector_payout_id) => db\n            .find_payout_attempt_by_merchant_id_connector_payout_id(\n                platform.get_processor().get_account().get_id(),\n                &connector_payout_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n    };\n    match payout.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = platform.get_processor().get_key_store();\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &payout.profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {}\",\n                            payout.profile_id.get_string_repr(),\n                            connector_name\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                todo!()\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "get_mca_from_payout_attempt", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Payout MCA Resolution Utility"}, {"query": "find merchant connector account by payout attempt hyperswitch rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__router__src__utils.rs\n// MODULE: data::code_corpus_hyperswitch::crates__router__src__utils.rs\n// SYMBOL: get_mca_from_payout_attempt\npub async fn get_mca_from_payout_attempt(\n    state: &SessionState,\n    platform: &domain::Platform,\n    payout_id_type: webhooks::PayoutIdType,\n    connector_name: &str,\n) -> CustomResult<domain::MerchantConnectorAccount, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let payout = match payout_id_type {\n        webhooks::PayoutIdType::PayoutAttemptId(payout_attempt_id) => db\n            .find_payout_attempt_by_merchant_id_payout_attempt_id(\n                platform.get_processor().get_account().get_id(),\n                &payout_attempt_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n        webhooks::PayoutIdType::ConnectorPayoutId(connector_payout_id) => db\n            .find_payout_attempt_by_merchant_id_connector_payout_id(\n                platform.get_processor().get_account().get_id(),\n                &connector_payout_id,\n                platform.get_processor().get_account().storage_scheme,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::PayoutNotFound)?,\n    };\n    match payout.merchant_connector_id {\n        Some(merchant_connector_id) => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                    platform.get_processor().get_account().get_id(),\n                    &merchant_connector_id,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: merchant_connector_id.get_string_repr().to_string(),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                //get mca using id\n                let _id = merchant_connector_id;\n                let _ = platform.get_processor().get_key_store();\n                let _ = connector_name;\n                todo!()\n            }\n        }\n        None => {\n            #[cfg(feature = \"v1\")]\n            {\n                db.find_merchant_connector_account_by_profile_id_connector_name(\n                    &payout.profile_id,\n                    connector_name,\n                    platform.get_processor().get_key_store(),\n                )\n                .await\n                .to_not_found_response(\n                    errors::ApiErrorResponse::MerchantConnectorAccountNotFound {\n                        id: format!(\n                            \"profile_id {} and connector_name {}\",\n                            payout.profile_id.get_string_repr(),\n                            connector_name\n                        ),\n                    },\n                )\n            }\n            #[cfg(feature = \"v2\")]\n            {\n                todo!()\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]", "function_name": "get_mca_from_payout_attempt", "file": "data/code_corpus_hyperswitch/crates__router__src__utils.rs", "unit_type": "function", "label": "Payout MCA Resolution Utility"}, {"query": "how to merge authorization and capture transaction responses in Rust", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: merge_transaction_responses\n    pub fn merge_transaction_responses(\n        auth_response: &Self,\n        capture_response: &Self,\n    ) -> Result<Self, error_stack::Report<ApiErrorResponse>> {\n        match (auth_response, capture_response) {\n            (\n                Self::TransactionResponse {\n                    resource_id: _,\n                    redirection_data: auth_redirection_data,\n                    mandate_reference: auth_mandate_reference,\n                    connector_metadata: auth_connector_metadata,\n                    network_txn_id: auth_network_txn_id,\n                    connector_response_reference_id: auth_connector_response_reference_id,\n                    incremental_authorization_allowed: auth_incremental_auth_allowed,\n                    authentication_data: auth_authentication_data,\n                    charges: auth_charges,\n                },\n                Self::TransactionResponse {\n                    resource_id: capture_resource_id,\n                    redirection_data: capture_redirection_data,\n                    mandate_reference: capture_mandate_reference,\n                    connector_metadata: capture_connector_metadata,\n                    network_txn_id: capture_network_txn_id,\n                    connector_response_reference_id: capture_connector_response_reference_id,\n                    incremental_authorization_allowed: capture_incremental_auth_allowed,\n                    authentication_data: capture_authentication_data,\n                    charges: capture_charges,\n                },\n            ) => Ok(Self::TransactionResponse {\n                resource_id: capture_resource_id.clone(),\n                redirection_data: Box::new(\n                    capture_redirection_data\n                        .clone()\n                        .or_else(|| *auth_redirection_data.clone()),\n                ),\n                mandate_reference: Box::new(\n                    auth_mandate_reference\n                        .clone()\n                        .or_else(|| *capture_mandate_reference.clone()),\n                ),\n                connector_metadata: capture_connector_metadata\n                    .clone()\n                    .or(auth_connector_metadata.clone()),\n                network_txn_id: capture_network_txn_id\n                    .clone()\n                    .or(auth_network_txn_id.clone()),\n                connector_response_reference_id: capture_connector_response_reference_id\n                    .clone()\n                    .or(auth_connector_response_reference_id.clone()),\n                incremental_authorization_allowed: (*capture_incremental_auth_allowed)\n                    .or(*auth_incremental_auth_allowed),\n                authentication_data: capture_authentication_data\n                    .clone()\n                    .or(auth_authentication_data.clone()),\n                charges: auth_charges.clone().or(capture_charges.clone()),\n            }),\n            _ => Err(ApiErrorResponse::NotSupported {\n                message: \"Invalid Flow \".to_owned(),\n            }\n            .into()),\n        }\n    }\n\n    #[cfg(feature = \"v2\")]", "function_name": "merge_transaction_responses", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "merge transaction responses function"}, {"query": "hyperswitch router_response_types merge_transaction_responses function", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: merge_transaction_responses\n    pub fn merge_transaction_responses(\n        auth_response: &Self,\n        capture_response: &Self,\n    ) -> Result<Self, error_stack::Report<ApiErrorResponse>> {\n        match (auth_response, capture_response) {\n            (\n                Self::TransactionResponse {\n                    resource_id: _,\n                    redirection_data: auth_redirection_data,\n                    mandate_reference: auth_mandate_reference,\n                    connector_metadata: auth_connector_metadata,\n                    network_txn_id: auth_network_txn_id,\n                    connector_response_reference_id: auth_connector_response_reference_id,\n                    incremental_authorization_allowed: auth_incremental_auth_allowed,\n                    authentication_data: auth_authentication_data,\n                    charges: auth_charges,\n                },\n                Self::TransactionResponse {\n                    resource_id: capture_resource_id,\n                    redirection_data: capture_redirection_data,\n                    mandate_reference: capture_mandate_reference,\n                    connector_metadata: capture_connector_metadata,\n                    network_txn_id: capture_network_txn_id,\n                    connector_response_reference_id: capture_connector_response_reference_id,\n                    incremental_authorization_allowed: capture_incremental_auth_allowed,\n                    authentication_data: capture_authentication_data,\n                    charges: capture_charges,\n                },\n            ) => Ok(Self::TransactionResponse {\n                resource_id: capture_resource_id.clone(),\n                redirection_data: Box::new(\n                    capture_redirection_data\n                        .clone()\n                        .or_else(|| *auth_redirection_data.clone()),\n                ),\n                mandate_reference: Box::new(\n                    auth_mandate_reference\n                        .clone()\n                        .or_else(|| *capture_mandate_reference.clone()),\n                ),\n                connector_metadata: capture_connector_metadata\n                    .clone()\n                    .or(auth_connector_metadata.clone()),\n                network_txn_id: capture_network_txn_id\n                    .clone()\n                    .or(auth_network_txn_id.clone()),\n                connector_response_reference_id: capture_connector_response_reference_id\n                    .clone()\n                    .or(auth_connector_response_reference_id.clone()),\n                incremental_authorization_allowed: (*capture_incremental_auth_allowed)\n                    .or(*auth_incremental_auth_allowed),\n                authentication_data: capture_authentication_data\n                    .clone()\n                    .or(auth_authentication_data.clone()),\n                charges: auth_charges.clone().or(capture_charges.clone()),\n            }),\n            _ => Err(ApiErrorResponse::NotSupported {\n                message: \"Invalid Flow \".to_owned(),\n            }\n            .into()),\n        }\n    }\n\n    #[cfg(feature = \"v2\")]", "function_name": "merge_transaction_responses", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "merge transaction responses function"}, {"query": "combine auth and capture response objects in payment orchestration", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: merge_transaction_responses\n    pub fn merge_transaction_responses(\n        auth_response: &Self,\n        capture_response: &Self,\n    ) -> Result<Self, error_stack::Report<ApiErrorResponse>> {\n        match (auth_response, capture_response) {\n            (\n                Self::TransactionResponse {\n                    resource_id: _,\n                    redirection_data: auth_redirection_data,\n                    mandate_reference: auth_mandate_reference,\n                    connector_metadata: auth_connector_metadata,\n                    network_txn_id: auth_network_txn_id,\n                    connector_response_reference_id: auth_connector_response_reference_id,\n                    incremental_authorization_allowed: auth_incremental_auth_allowed,\n                    authentication_data: auth_authentication_data,\n                    charges: auth_charges,\n                },\n                Self::TransactionResponse {\n                    resource_id: capture_resource_id,\n                    redirection_data: capture_redirection_data,\n                    mandate_reference: capture_mandate_reference,\n                    connector_metadata: capture_connector_metadata,\n                    network_txn_id: capture_network_txn_id,\n                    connector_response_reference_id: capture_connector_response_reference_id,\n                    incremental_authorization_allowed: capture_incremental_auth_allowed,\n                    authentication_data: capture_authentication_data,\n                    charges: capture_charges,\n                },\n            ) => Ok(Self::TransactionResponse {\n                resource_id: capture_resource_id.clone(),\n                redirection_data: Box::new(\n                    capture_redirection_data\n                        .clone()\n                        .or_else(|| *auth_redirection_data.clone()),\n                ),\n                mandate_reference: Box::new(\n                    auth_mandate_reference\n                        .clone()\n                        .or_else(|| *capture_mandate_reference.clone()),\n                ),\n                connector_metadata: capture_connector_metadata\n                    .clone()\n                    .or(auth_connector_metadata.clone()),\n                network_txn_id: capture_network_txn_id\n                    .clone()\n                    .or(auth_network_txn_id.clone()),\n                connector_response_reference_id: capture_connector_response_reference_id\n                    .clone()\n                    .or(auth_connector_response_reference_id.clone()),\n                incremental_authorization_allowed: (*capture_incremental_auth_allowed)\n                    .or(*auth_incremental_auth_allowed),\n                authentication_data: capture_authentication_data\n                    .clone()\n                    .or(auth_authentication_data.clone()),\n                charges: auth_charges.clone().or(capture_charges.clone()),\n            }),\n            _ => Err(ApiErrorResponse::NotSupported {\n                message: \"Invalid Flow \".to_owned(),\n            }\n            .into()),\n        }\n    }\n\n    #[cfg(feature = \"v2\")]", "function_name": "merge_transaction_responses", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "merge transaction responses function"}, {"query": "rust function to merge TransactionResponse structs hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_domain_models__src__router_response_types.rs\n// SYMBOL: merge_transaction_responses\n    pub fn merge_transaction_responses(\n        auth_response: &Self,\n        capture_response: &Self,\n    ) -> Result<Self, error_stack::Report<ApiErrorResponse>> {\n        match (auth_response, capture_response) {\n            (\n                Self::TransactionResponse {\n                    resource_id: _,\n                    redirection_data: auth_redirection_data,\n                    mandate_reference: auth_mandate_reference,\n                    connector_metadata: auth_connector_metadata,\n                    network_txn_id: auth_network_txn_id,\n                    connector_response_reference_id: auth_connector_response_reference_id,\n                    incremental_authorization_allowed: auth_incremental_auth_allowed,\n                    authentication_data: auth_authentication_data,\n                    charges: auth_charges,\n                },\n                Self::TransactionResponse {\n                    resource_id: capture_resource_id,\n                    redirection_data: capture_redirection_data,\n                    mandate_reference: capture_mandate_reference,\n                    connector_metadata: capture_connector_metadata,\n                    network_txn_id: capture_network_txn_id,\n                    connector_response_reference_id: capture_connector_response_reference_id,\n                    incremental_authorization_allowed: capture_incremental_auth_allowed,\n                    authentication_data: capture_authentication_data,\n                    charges: capture_charges,\n                },\n            ) => Ok(Self::TransactionResponse {\n                resource_id: capture_resource_id.clone(),\n                redirection_data: Box::new(\n                    capture_redirection_data\n                        .clone()\n                        .or_else(|| *auth_redirection_data.clone()),\n                ),\n                mandate_reference: Box::new(\n                    auth_mandate_reference\n                        .clone()\n                        .or_else(|| *capture_mandate_reference.clone()),\n                ),\n                connector_metadata: capture_connector_metadata\n                    .clone()\n                    .or(auth_connector_metadata.clone()),\n                network_txn_id: capture_network_txn_id\n                    .clone()\n                    .or(auth_network_txn_id.clone()),\n                connector_response_reference_id: capture_connector_response_reference_id\n                    .clone()\n                    .or(auth_connector_response_reference_id.clone()),\n                incremental_authorization_allowed: (*capture_incremental_auth_allowed)\n                    .or(*auth_incremental_auth_allowed),\n                authentication_data: capture_authentication_data\n                    .clone()\n                    .or(auth_authentication_data.clone()),\n                charges: auth_charges.clone().or(capture_charges.clone()),\n            }),\n            _ => Err(ApiErrorResponse::NotSupported {\n                message: \"Invalid Flow \".to_owned(),\n            }\n            .into()),\n        }\n    }\n\n    #[cfg(feature = \"v2\")]", "function_name": "merge_transaction_responses", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_domain_models__src__router_response_types.rs", "unit_type": "function", "label": "merge transaction responses function"}, {"query": "rust hyperswitch cybersource setup mandate request builder", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "CyberSource Setup Mandate Request Builder"}, {"query": "how to build cybersource setup mandate api request in hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "CyberSource Setup Mandate Request Builder"}, {"query": "hyperswitch cybersource connector setup mandate request implementation", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "CyberSource Setup Mandate Request Builder"}, {"query": "rust function build_request setup mandate router data hyperswitch", "code": "// PATH: data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// MODULE: data::code_corpus_hyperswitch::crates__hyperswitch_connectors__src__connectors__cybersource.rs\n// SYMBOL: build_request\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(SetupMandateType::get_request_body(self, req, connectors)?)\n                .build(),\n        ))\n    }\n", "function_name": "build_request", "file": "data/code_corpus_hyperswitch/crates__hyperswitch_connectors__src__connectors__cybersource.rs", "unit_type": "function", "label": "CyberSource Setup Mandate Request Builder"}]