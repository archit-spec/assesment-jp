[
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs",
    "code": "use api_models::{payouts, webhooks};\nuse common_enums::enums;\nuse common_utils::pii;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::types::{self, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse super::{AdyenPlatformRouterData, Error};\nuse crate::{\n    connectors::adyen::transformers as adyen,\n    types::PayoutsResponseRouterData,\n    utils::{\n        self, AdditionalPayoutMethodData as _, AddressDetailsData, CardData,\n        PayoutFulfillRequestData, PayoutsData as _, RouterData as _,\n    },\n};\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct AdyenPlatformConnectorMetadataObject {\n    source_balance_account: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for AdyenPlatformConnectorMetadataObject {\n    type Error = Error;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(ConnectorError::InvalidConnectorConfig { config: \"metadata\" })?;\n        Ok(metadata)\n    }\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferRequest {\n    amount: adyen::Amount,\n    balance_account_id: Secret<String>,\n    category: AdyenPayoutMethod,\n    counterparty: AdyenPayoutMethodDetails,\n    priority: Option<AdyenPayoutPriority>,\n    reference: String,\n    reference_for_beneficiary: String,\n    description: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethod {\n    Bank,\n    Card,\n    PlatformPayment,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethodDetails {\n    BankAccount(AdyenBankAccountDetails),\n    Card(AdyenCardDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenBankAccountDetails {\n    account_holder: AdyenAccountHolder,\n    account_identification: AdyenBankAccountIdentification,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenAccountHolder {\n    address: Option<AdyenAddress>,\n    first_name: Option<Secret<String>>,\n    last_name: Option<Secret<String>>,\n    full_name: Option<Secret<String>>,\n    email: Option<pii::Email>,\n    #[serde(rename = \"reference\")]\n    customer_id: Option<String>,\n    #[serde(rename = \"type\")]\n    entity_type: Option<EntityType>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Default, Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenAddress {\n    line1: Secret<String>,\n    line2: Secret<String>,\n    postal_code: Option<Secret<String>>,\n    state_or_province: Option<Secret<String>>,\n    city: String,\n    country: enums::CountryAlpha2,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AdyenBankAccountIdentification {\n    #[serde(rename = \"type\")]\n    bank_type: String,\n    #[serde(flatten)]\n    account_details: AdyenBankAccountIdentificationDetails,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum AdyenBankAccountIdentificationDetails {\n    Sepa(SepaDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SepaDetails {\n    iban: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenCardDetails {\n    card_holder: AdyenAccountHolder,\n    card_identification: AdyenCardIdentification,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum AdyenCardIdentification {\n    Card(AdyenRawCardIdentification),\n    Stored(AdyenStoredCardIdentification),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenRawCardIdentification {\n    #[serde(rename = \"number\")]\n    card_number: cards::CardNumber,\n    expiry_month: Secret<String>,\n    expiry_year: Secret<String>,\n    issue_number: Option<String>,\n    start_month: Option<String>,\n    start_year: Option<String>,\n}\n",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs",
    "code": "use api_models::{payouts, webhooks};\nuse common_enums::enums;\nuse common_utils::pii;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::types::{self, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse super::{AdyenPlatformRouterData, Error};\nuse crate::{\n    connectors::adyen::transformers as adyen,\n    types::PayoutsResponseRouterData,\n    utils::{\n        self, AdditionalPayoutMethodData as _, AddressDetailsData, CardData,\n        PayoutFulfillRequestData, PayoutsData as _, RouterData as _,\n    },\n};\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct AdyenPlatformConnectorMetadataObject {\n    source_balance_account: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for AdyenPlatformConnectorMetadataObject {\n    type Error = Error;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(ConnectorError::InvalidConnectorConfig { config: \"metadata\" })?;\n        Ok(metadata)\n    }\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferRequest {\n    amount: adyen::Amount,\n    balance_account_id: Secret<String>,\n    category: AdyenPayoutMethod,\n    counterparty: AdyenPayoutMethodDetails,\n    priority: Option<AdyenPayoutPriority>,\n    reference: String,\n    reference_for_beneficiary: String,\n    description: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethod {\n    Bank,\n    Card,\n    PlatformPayment,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethodDetails {\n    BankAccount(AdyenBankAccountDetails),\n    Card(AdyenCardDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenBankAccountDetails {\n    account_holder: AdyenAccountHolder,\n    account_identification: AdyenBankAccountIdentification,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenAccountHolder {\n    address: Option<AdyenAddress>,\n    first_name: Option<Secret<String>>,\n    last_name: Option<Secret<String>>,\n    full_name: Option<Secret<String>>,\n    email: Option<pii::Email>,\n    #[serde(rename = \"reference\")]\n    customer_id: Option<String>,\n    #[serde(rename = \"type\")]\n    entity_type: Option<EntityType>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Default, Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenAddress {\n    line1: Secret<String>,\n    line2: Secret<String>,\n    postal_code: Option<Secret<String>>,\n    state_or_province: Option<Secret<String>>,\n    city: String,\n    country: enums::CountryAlpha2,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AdyenBankAccountIdentification {\n    #[serde(rename = \"type\")]\n    bank_type: String,\n    #[serde(flatten)]\n    account_details: AdyenBankAccountIdentificationDetails,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum AdyenBankAccountIdentificationDetails {\n    Sepa(SepaDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SepaDetails {\n    iban: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenCardDetails {\n    card_holder: AdyenAccountHolder,\n    card_identification: AdyenCardIdentification,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum AdyenCardIdentification {\n    Card(AdyenRawCardIdentification),\n    Stored(AdyenStoredCardIdentification),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenRawCardIdentification {\n    #[serde(rename = \"number\")]\n    card_number: cards::CardNumber,\n    expiry_month: Secret<String>,\n    expiry_year: Secret<String>,\n    issue_number: Option<String>,\n    start_month: Option<String>,\n    start_year: Option<String>,\n}\n",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use api_models::{payouts, webhooks};\nuse common_enums::enums;\nuse common_utils::pii;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::types::{self, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse super::{AdyenPlatformRouterData, Error};\nuse crate::{\n    connectors::adyen::transformers as adyen,\n    types::PayoutsResponseRouterData,\n    utils::{\n        self, AdditionalPayoutMethodData as _, AddressDetailsData, CardData,\n        PayoutFulfillRequestData, PayoutsData as _, RouterData as _,\n    },\n};\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct AdyenPlatformConnectorMetadataObject {\n    source_balance_account: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for AdyenPlatformConnectorMetadataObject {\n    type Error = Error;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(ConnectorError::InvalidConnectorConfig { config: \"metadata\" })?;\n        Ok(metadata)\n    }\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenTransferRequest {\n    amount: adyen::Amount,\n    balance_account_id: Secret<String>,\n    category: AdyenPayoutMethod,\n    counterparty: AdyenPayoutMethodDetails,\n    priority: Option<AdyenPayoutPriority>,\n    reference: String,\n    reference_for_beneficiary: String,\n    description: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethod {\n    Bank,\n    Card,\n    PlatformPayment,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum AdyenPayoutMethodDetails {\n    BankAccount(AdyenBankAccountDetails),\n    Card(AdyenCardDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenBankAccountDetails {\n    account_holder: AdyenAccountHolder,\n    account_identification: AdyenBankAccountIdentification,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenAccountHolder {\n    address: Option<AdyenAddress>,\n    first_name: Option<Secret<String>>,\n    last_name: Option<Secret<String>>,\n    full_name: Option<Secret<String>>,\n    email: Option<pii::Email>,\n    #[serde(rename = \"reference\")]\n    customer_id: Option<String>,\n    #[serde(rename = \"type\")]\n    entity_type: Option<EntityType>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Default, Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenAddress {\n    line1: Secret<String>,\n    line2: Secret<String>,\n    postal_code: Option<Secret<String>>,\n    state_or_province: Option<Secret<String>>,\n    city: String,\n    country: enums::CountryAlpha2,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AdyenBankAccountIdentification {\n    #[serde(rename = \"type\")]\n    bank_type: String,\n    #[serde(flatten)]\n    account_details: AdyenBankAccountIdentificationDetails,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum AdyenBankAccountIdentificationDetails {\n    Sepa(SepaDetails),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SepaDetails {\n    iban: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenCardDetails {\n    card_holder: AdyenAccountHolder,\n    card_identification: AdyenCardIdentification,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum AdyenCardIdentification {\n    Card(AdyenRawCardIdentification),\n    Stored(AdyenStoredCardIdentification),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AdyenRawCardIdentification {\n    #[serde(rename = \"number\")]\n    card_number: cards::CardNumber,\n    expiry_month: Secret<String>,\n    expiry_year: Secret<String>,\n    issue_number: Option<String>,\n    start_month: Option<String>,\n    start_year: Option<String>,\n}\n",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__adyenplatform__transformers__payouts.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__chargebee.rs",
    "code": "pub mod transformers;\n\nuse api_models::subscription::SubscriptionItemType;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{revenue_recovery, router_data_v2::RouterDataV2};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::flow_common_types::{\n        GetSubscriptionItemPricesData, GetSubscriptionItemsData, SubscriptionCreateData,\n        SubscriptionCustomerData,\n    },\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery::InvoiceRecordBack,\n        subscriptions::{\n            GetSubscriptionEstimate, GetSubscriptionItemPrices, GetSubscriptionItems,\n            SubscriptionCancel, SubscriptionCreate, SubscriptionPause, SubscriptionResume,\n        },\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        revenue_recovery::InvoiceRecordBackRequest,\n        subscriptions::{\n            GetSubscriptionEstimateRequest, GetSubscriptionItemPricesRequest,\n            GetSubscriptionItemsRequest, SubscriptionCancelRequest, SubscriptionCreateRequest,\n            SubscriptionPauseRequest, SubscriptionResumeRequest,\n        },\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n            GetSubscriptionEstimateResponse, GetSubscriptionItemPricesResponse,\n            GetSubscriptionItemsResponse, SubscriptionCancelResponse, SubscriptionCreateResponse,\n            SubscriptionPauseResponse, SubscriptionResumeResponse,\n        },\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, GetSubscriptionEstimateRouterData,\n        GetSubscriptionItemsRouterData, GetSubscriptionPlanPricesRouterData,\n        InvoiceRecordBackRouterData, PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SubscriptionCancelRouterData, SubscriptionCreateRouterData, SubscriptionPauseRouterData,\n        SubscriptionResumeRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        payments::ConnectorCustomer,\n        subscriptions_v2::{GetSubscriptionPlanPricesV2, GetSubscriptionPlansV2},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    connector_integration_v2::ConnectorIntegrationV2,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as chargebee;\n\nuse crate::{\n    connectors::chargebee::transformers::{\n        ChargebeeGetPlanPricesResponse, ChargebeeListPlansResponse,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils,\n};\n\n#[derive(Clone)]\npub struct Chargebee {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Chargebee {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\nimpl ConnectorCustomer for Chargebee {}\nimpl api::Payment for Chargebee {}\nimpl api::PaymentSession for Chargebee {}\nimpl api::ConnectorAccessToken for Chargebee {}\nimpl api::MandateSetup for Chargebee {}\nimpl api::PaymentAuthorize for Chargebee {}\nimpl api::PaymentSync for Chargebee {}\nimpl api::PaymentCapture for Chargebee {}\nimpl api::PaymentVoid for Chargebee {}\nimpl api::Refund for Chargebee {}\nimpl api::RefundExecute for Chargebee {}\nimpl api::RefundSync for Chargebee {}\nimpl api::PaymentToken for Chargebee {}\nimpl api::subscriptions::Subscriptions for Chargebee {}\n\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nimpl api::revenue_recovery::RevenueRecoveryRecordBack for Chargebee {}\n\nfn build_chargebee_url<Flow, Request, Response>(\n    connector: &Chargebee,\n    req: &RouterData<Flow, Request, Response>,\n    connectors: &Connectors,\n    path: &str,\n) -> CustomResult<String, errors::ConnectorError> {\n    let metadata: chargebee::ChargebeeMetadata =\n        utils::to_connector_meta_from_secret(req.connector_meta_data.clone())?;\n\n    let site = metadata.site.peek();\n    let mut base = connector.base_url(connectors).to_string();\n\n    base = base.replace(\"{{merchant_endpoint_prefix}}\", site);\n    base = base.replace(\"$\", site);\n\n    if base.contains(\"{{merchant_endpoint_prefix}}\") || base.contains('$') {\n        return Err(errors::ConnectorError::InvalidConnectorConfig {\n            config: \"Chargebee base_url has an unresolved placeholder\",\n        }\n        .into());\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__chargebee.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__chargebee.rs",
    "code": "pub mod transformers;\n\nuse api_models::subscription::SubscriptionItemType;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{revenue_recovery, router_data_v2::RouterDataV2};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::flow_common_types::{\n        GetSubscriptionItemPricesData, GetSubscriptionItemsData, SubscriptionCreateData,\n        SubscriptionCustomerData,\n    },\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery::InvoiceRecordBack,\n        subscriptions::{\n            GetSubscriptionEstimate, GetSubscriptionItemPrices, GetSubscriptionItems,\n            SubscriptionCancel, SubscriptionCreate, SubscriptionPause, SubscriptionResume,\n        },\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        revenue_recovery::InvoiceRecordBackRequest,\n        subscriptions::{\n            GetSubscriptionEstimateRequest, GetSubscriptionItemPricesRequest,\n            GetSubscriptionItemsRequest, SubscriptionCancelRequest, SubscriptionCreateRequest,\n            SubscriptionPauseRequest, SubscriptionResumeRequest,\n        },\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n            GetSubscriptionEstimateResponse, GetSubscriptionItemPricesResponse,\n            GetSubscriptionItemsResponse, SubscriptionCancelResponse, SubscriptionCreateResponse,\n            SubscriptionPauseResponse, SubscriptionResumeResponse,\n        },\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, GetSubscriptionEstimateRouterData,\n        GetSubscriptionItemsRouterData, GetSubscriptionPlanPricesRouterData,\n        InvoiceRecordBackRouterData, PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SubscriptionCancelRouterData, SubscriptionCreateRouterData, SubscriptionPauseRouterData,\n        SubscriptionResumeRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        payments::ConnectorCustomer,\n        subscriptions_v2::{GetSubscriptionPlanPricesV2, GetSubscriptionPlansV2},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    connector_integration_v2::ConnectorIntegrationV2,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as chargebee;\n\nuse crate::{\n    connectors::chargebee::transformers::{\n        ChargebeeGetPlanPricesResponse, ChargebeeListPlansResponse,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils,\n};\n\n#[derive(Clone)]\npub struct Chargebee {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Chargebee {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\nimpl ConnectorCustomer for Chargebee {}\nimpl api::Payment for Chargebee {}\nimpl api::PaymentSession for Chargebee {}\nimpl api::ConnectorAccessToken for Chargebee {}\nimpl api::MandateSetup for Chargebee {}\nimpl api::PaymentAuthorize for Chargebee {}\nimpl api::PaymentSync for Chargebee {}\nimpl api::PaymentCapture for Chargebee {}\nimpl api::PaymentVoid for Chargebee {}\nimpl api::Refund for Chargebee {}\nimpl api::RefundExecute for Chargebee {}\nimpl api::RefundSync for Chargebee {}\nimpl api::PaymentToken for Chargebee {}\nimpl api::subscriptions::Subscriptions for Chargebee {}\n\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nimpl api::revenue_recovery::RevenueRecoveryRecordBack for Chargebee {}\n\nfn build_chargebee_url<Flow, Request, Response>(\n    connector: &Chargebee,\n    req: &RouterData<Flow, Request, Response>,\n    connectors: &Connectors,\n    path: &str,\n) -> CustomResult<String, errors::ConnectorError> {\n    let metadata: chargebee::ChargebeeMetadata =\n        utils::to_connector_meta_from_secret(req.connector_meta_data.clone())?;\n\n    let site = metadata.site.peek();\n    let mut base = connector.base_url(connectors).to_string();\n\n    base = base.replace(\"{{merchant_endpoint_prefix}}\", site);\n    base = base.replace(\"$\", site);\n\n    if base.contains(\"{{merchant_endpoint_prefix}}\") || base.contains('$') {\n        return Err(errors::ConnectorError::InvalidConnectorConfig {\n            config: \"Chargebee base_url has an unresolved placeholder\",\n        }\n        .into());\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__chargebee.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse api_models::subscription::SubscriptionItemType;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::{revenue_recovery, router_data_v2::RouterDataV2};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_data_v2::flow_common_types::{\n        GetSubscriptionItemPricesData, GetSubscriptionItemsData, SubscriptionCreateData,\n        SubscriptionCustomerData,\n    },\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery::InvoiceRecordBack,\n        subscriptions::{\n            GetSubscriptionEstimate, GetSubscriptionItemPrices, GetSubscriptionItems,\n            SubscriptionCancel, SubscriptionCreate, SubscriptionPause, SubscriptionResume,\n        },\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        revenue_recovery::InvoiceRecordBackRequest,\n        subscriptions::{\n            GetSubscriptionEstimateRequest, GetSubscriptionItemPricesRequest,\n            GetSubscriptionItemsRequest, SubscriptionCancelRequest, SubscriptionCreateRequest,\n            SubscriptionPauseRequest, SubscriptionResumeRequest,\n        },\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery::InvoiceRecordBackResponse,\n        subscriptions::{\n            GetSubscriptionEstimateResponse, GetSubscriptionItemPricesResponse,\n            GetSubscriptionItemsResponse, SubscriptionCancelResponse, SubscriptionCreateResponse,\n            SubscriptionPauseResponse, SubscriptionResumeResponse,\n        },\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, GetSubscriptionEstimateRouterData,\n        GetSubscriptionItemsRouterData, GetSubscriptionPlanPricesRouterData,\n        InvoiceRecordBackRouterData, PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SubscriptionCancelRouterData, SubscriptionCreateRouterData, SubscriptionPauseRouterData,\n        SubscriptionResumeRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        payments::ConnectorCustomer,\n        subscriptions_v2::{GetSubscriptionPlanPricesV2, GetSubscriptionPlansV2},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    connector_integration_v2::ConnectorIntegrationV2,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as chargebee;\n\nuse crate::{\n    connectors::chargebee::transformers::{\n        ChargebeeGetPlanPricesResponse, ChargebeeListPlansResponse,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils,\n};\n\n#[derive(Clone)]\npub struct Chargebee {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Chargebee {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\nimpl ConnectorCustomer for Chargebee {}\nimpl api::Payment for Chargebee {}\nimpl api::PaymentSession for Chargebee {}\nimpl api::ConnectorAccessToken for Chargebee {}\nimpl api::MandateSetup for Chargebee {}\nimpl api::PaymentAuthorize for Chargebee {}\nimpl api::PaymentSync for Chargebee {}\nimpl api::PaymentCapture for Chargebee {}\nimpl api::PaymentVoid for Chargebee {}\nimpl api::Refund for Chargebee {}\nimpl api::RefundExecute for Chargebee {}\nimpl api::RefundSync for Chargebee {}\nimpl api::PaymentToken for Chargebee {}\nimpl api::subscriptions::Subscriptions for Chargebee {}\n\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nimpl api::revenue_recovery::RevenueRecoveryRecordBack for Chargebee {}\n\nfn build_chargebee_url<Flow, Request, Response>(\n    connector: &Chargebee,\n    req: &RouterData<Flow, Request, Response>,\n    connectors: &Connectors,\n    path: &str,\n) -> CustomResult<String, errors::ConnectorError> {\n    let metadata: chargebee::ChargebeeMetadata =\n        utils::to_connector_meta_from_secret(req.connector_meta_data.clone())?;\n\n    let site = metadata.site.peek();\n    let mut base = connector.base_url(connectors).to_string();\n\n    base = base.replace(\"{{merchant_endpoint_prefix}}\", site);\n    base = base.replace(\"$\", site);\n\n    if base.contains(\"{{merchant_endpoint_prefix}}\") || base.contains('$') {\n        return Err(errors::ConnectorError::InvalidConnectorConfig {\n            config: \"Chargebee base_url has an unresolved placeholder\",\n        }\n        .into());\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__chargebee.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    pii::{self, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, Card as CardData, CryptoData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, to_connector_meta, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait Shift4AuthorizePreprocessingCommon {\n    fn is_automatic_capture(&self) -> Result<bool, Error>;\n    fn get_router_return_url(&self) -> Option<String>;\n    fn get_email_optional(&self) -> Option<pii::Email>;\n    fn get_complete_authorize_url(&self) -> Option<String>;\n    fn get_currency_required(&self) -> Result<enums::Currency, Error>;\n    fn get_metadata(&self) -> Result<Option<serde_json::Value>, Error>;\n    fn get_payment_method_data_required(&self) -> Result<PaymentMethodData, Error>;\n}\n\npub struct Shift4RouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for Shift4RouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\nimpl Shift4AuthorizePreprocessingCommon for PaymentsAuthorizeData {\n    fn get_email_optional(&self) -> Option<pii::Email> {\n        self.email.clone()\n    }\n\n    fn get_complete_authorize_url(&self) -> Option<String> {\n        self.complete_authorize_url.clone()\n    }\n\n    fn get_currency_required(\n        &self,\n    ) -> Result<enums::Currency, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.currency)\n    }\n    fn get_payment_method_data_required(\n        &self,\n    ) -> Result<PaymentMethodData, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.payment_method_data.clone())\n    }\n\n    fn is_automatic_capture(&self) -> Result<bool, Error> {\n        self.is_auto_capture()\n    }\n\n    fn get_router_return_url(&self) -> Option<String> {\n        self.router_return_url.clone()\n    }\n\n    fn get_metadata(\n        &self,\n    ) -> Result<Option<serde_json::Value>, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.metadata.clone())\n    }\n}\n\nimpl Shift4AuthorizePreprocessingCommon for PaymentsPreAuthenticateData {\n    fn get_email_optional(&self) -> Option<pii::Email> {\n        self.email.clone()\n    }\n\n    fn get_complete_authorize_url(&self) -> Option<String> {\n        self.complete_authorize_url.clone()\n    }\n\n    fn get_currency_required(\n        &self,\n    ) -> Result<enums::Currency, error_stack::Report<errors::ConnectorError>> {\n        self.currency.ok_or(\n            errors::ConnectorError::MissingRequiredField {\n                field_name: \"currency\",\n            }\n            .into(),\n        )\n    }\n    fn get_payment_method_data_required(\n        &self,\n    ) -> Result<PaymentMethodData, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.payment_method_data.clone())\n    }\n\n    fn is_automatic_capture(&self) -> Result<bool, Error> {\n        self.is_auto_capture()\n    }\n\n    fn get_router_return_url(&self) -> Option<String> {\n        self.router_return_url.clone()\n    }\n\n    fn get_metadata(\n        &self,\n    ) -> Result<Option<serde_json::Value>, error_stack::Report<errors::ConnectorError>> {",
    "function_name": "is_automatic_capture",
    "file": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    pii::{self, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, Card as CardData, CryptoData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, to_connector_meta, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait Shift4AuthorizePreprocessingCommon {\n    fn is_automatic_capture(&self) -> Result<bool, Error>;\n    fn get_router_return_url(&self) -> Option<String>;\n    fn get_email_optional(&self) -> Option<pii::Email>;\n    fn get_complete_authorize_url(&self) -> Option<String>;\n    fn get_currency_required(&self) -> Result<enums::Currency, Error>;\n    fn get_metadata(&self) -> Result<Option<serde_json::Value>, Error>;\n    fn get_payment_method_data_required(&self) -> Result<PaymentMethodData, Error>;\n}\n\npub struct Shift4RouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for Shift4RouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\nimpl Shift4AuthorizePreprocessingCommon for PaymentsAuthorizeData {\n    fn get_email_optional(&self) -> Option<pii::Email> {\n        self.email.clone()\n    }\n\n    fn get_complete_authorize_url(&self) -> Option<String> {\n        self.complete_authorize_url.clone()\n    }\n\n    fn get_currency_required(\n        &self,\n    ) -> Result<enums::Currency, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.currency)\n    }\n    fn get_payment_method_data_required(\n        &self,\n    ) -> Result<PaymentMethodData, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.payment_method_data.clone())\n    }\n\n    fn is_automatic_capture(&self) -> Result<bool, Error> {\n        self.is_auto_capture()\n    }\n\n    fn get_router_return_url(&self) -> Option<String> {\n        self.router_return_url.clone()\n    }\n\n    fn get_metadata(\n        &self,\n    ) -> Result<Option<serde_json::Value>, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.metadata.clone())\n    }\n}\n\nimpl Shift4AuthorizePreprocessingCommon for PaymentsPreAuthenticateData {\n    fn get_email_optional(&self) -> Option<pii::Email> {\n        self.email.clone()\n    }\n\n    fn get_complete_authorize_url(&self) -> Option<String> {\n        self.complete_authorize_url.clone()\n    }\n\n    fn get_currency_required(\n        &self,\n    ) -> Result<enums::Currency, error_stack::Report<errors::ConnectorError>> {\n        self.currency.ok_or(\n            errors::ConnectorError::MissingRequiredField {\n                field_name: \"currency\",\n            }\n            .into(),\n        )\n    }\n    fn get_payment_method_data_required(\n        &self,\n    ) -> Result<PaymentMethodData, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.payment_method_data.clone())\n    }\n\n    fn is_automatic_capture(&self) -> Result<bool, Error> {\n        self.is_auto_capture()\n    }\n\n    fn get_router_return_url(&self) -> Option<String> {\n        self.router_return_url.clone()\n    }\n\n    fn get_metadata(\n        &self,\n    ) -> Result<Option<serde_json::Value>, error_stack::Report<errors::ConnectorError>> {",
    "function_name": "is_automatic_capture",
    "file": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for is_automatic_capture",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{\n    pii::{self, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, Card as CardData, CryptoData, GiftCardData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentsAuthorizeData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, to_connector_meta, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\ntrait Shift4AuthorizePreprocessingCommon {\n    fn is_automatic_capture(&self) -> Result<bool, Error>;\n    fn get_router_return_url(&self) -> Option<String>;\n    fn get_email_optional(&self) -> Option<pii::Email>;\n    fn get_complete_authorize_url(&self) -> Option<String>;\n    fn get_currency_required(&self) -> Result<enums::Currency, Error>;\n    fn get_metadata(&self) -> Result<Option<serde_json::Value>, Error>;\n    fn get_payment_method_data_required(&self) -> Result<PaymentMethodData, Error>;\n}\n\npub struct Shift4RouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for Shift4RouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\nimpl Shift4AuthorizePreprocessingCommon for PaymentsAuthorizeData {\n    fn get_email_optional(&self) -> Option<pii::Email> {\n        self.email.clone()\n    }\n\n    fn get_complete_authorize_url(&self) -> Option<String> {\n        self.complete_authorize_url.clone()\n    }\n\n    fn get_currency_required(\n        &self,\n    ) -> Result<enums::Currency, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.currency)\n    }\n    fn get_payment_method_data_required(\n        &self,\n    ) -> Result<PaymentMethodData, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.payment_method_data.clone())\n    }\n\n    fn is_automatic_capture(&self) -> Result<bool, Error> {\n        self.is_auto_capture()\n    }\n\n    fn get_router_return_url(&self) -> Option<String> {\n        self.router_return_url.clone()\n    }\n\n    fn get_metadata(\n        &self,\n    ) -> Result<Option<serde_json::Value>, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.metadata.clone())\n    }\n}\n\nimpl Shift4AuthorizePreprocessingCommon for PaymentsPreAuthenticateData {\n    fn get_email_optional(&self) -> Option<pii::Email> {\n        self.email.clone()\n    }\n\n    fn get_complete_authorize_url(&self) -> Option<String> {\n        self.complete_authorize_url.clone()\n    }\n\n    fn get_currency_required(\n        &self,\n    ) -> Result<enums::Currency, error_stack::Report<errors::ConnectorError>> {\n        self.currency.ok_or(\n            errors::ConnectorError::MissingRequiredField {\n                field_name: \"currency\",\n            }\n            .into(),\n        )\n    }\n    fn get_payment_method_data_required(\n        &self,\n    ) -> Result<PaymentMethodData, error_stack::Report<errors::ConnectorError>> {\n        Ok(self.payment_method_data.clone())\n    }\n\n    fn is_automatic_capture(&self) -> Result<bool, Error> {\n        self.is_auto_capture()\n    }\n\n    fn get_router_return_url(&self) -> Option<String> {\n        self.router_return_url.clone()\n    }\n\n    fn get_metadata(\n        &self,\n    ) -> Result<Option<serde_json::Value>, error_stack::Report<errors::ConnectorError>> {",
    "function_name": "is_automatic_capture",
    "file": "crates__hyperswitch_connectors__src__connectors__shift4__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__api_models__src__events__routing.rs",
    "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\nuse crate::routing::{\n    ContractBasedRoutingPayloadWrapper, ContractBasedRoutingSetupPayloadWrapper,\n    CreateDynamicRoutingWrapper, DynamicRoutingUpdateConfigQuery, EliminationRoutingPayloadWrapper,\n    LinkedRoutingConfigRetrieveResponse, MerchantRoutingAlgorithm, ProfileDefaultRoutingConfig,\n    RoutingAlgorithmId, RoutingConfigRequest, RoutingDictionaryRecord, RoutingKind,\n    RoutingLinkWrapper, RoutingPayloadWrapper, RoutingRetrieveLinkQuery,\n    RoutingRetrieveLinkQueryWrapper, RoutingRetrieveQuery, RoutingVolumeSplit,\n    RoutingVolumeSplitResponse, RoutingVolumeSplitWrapper, RuleMigrationError, RuleMigrationQuery,\n    RuleMigrationResponse, RuleMigrationResult, SuccessBasedRoutingConfig,\n    SuccessBasedRoutingPayloadWrapper, ToggleDynamicRoutingPath, ToggleDynamicRoutingQuery,\n    ToggleDynamicRoutingWrapper,\n};\n\nimpl ApiEventMetric for RoutingKind {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for MerchantRoutingAlgorithm {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingAlgorithmId {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingDictionaryRecord {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for LinkedRoutingConfigRetrieveResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for ProfileDefaultRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingRetrieveQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingConfigRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingRetrieveLinkQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingLinkWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for RoutingRetrieveLinkQueryWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ToggleDynamicRoutingQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for SuccessBasedRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for SuccessBasedRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for EliminationRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ContractBasedRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ContractBasedRoutingSetupPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ToggleDynamicRoutingWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for CreateDynamicRoutingWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for DynamicRoutingUpdateConfigQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingVolumeSplitWrapper {",
    "function_name": "get_api_event_type",
    "file": "crates__api_models__src__events__routing.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__api_models__src__events__routing.rs",
    "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\nuse crate::routing::{\n    ContractBasedRoutingPayloadWrapper, ContractBasedRoutingSetupPayloadWrapper,\n    CreateDynamicRoutingWrapper, DynamicRoutingUpdateConfigQuery, EliminationRoutingPayloadWrapper,\n    LinkedRoutingConfigRetrieveResponse, MerchantRoutingAlgorithm, ProfileDefaultRoutingConfig,\n    RoutingAlgorithmId, RoutingConfigRequest, RoutingDictionaryRecord, RoutingKind,\n    RoutingLinkWrapper, RoutingPayloadWrapper, RoutingRetrieveLinkQuery,\n    RoutingRetrieveLinkQueryWrapper, RoutingRetrieveQuery, RoutingVolumeSplit,\n    RoutingVolumeSplitResponse, RoutingVolumeSplitWrapper, RuleMigrationError, RuleMigrationQuery,\n    RuleMigrationResponse, RuleMigrationResult, SuccessBasedRoutingConfig,\n    SuccessBasedRoutingPayloadWrapper, ToggleDynamicRoutingPath, ToggleDynamicRoutingQuery,\n    ToggleDynamicRoutingWrapper,\n};\n\nimpl ApiEventMetric for RoutingKind {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for MerchantRoutingAlgorithm {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingAlgorithmId {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingDictionaryRecord {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for LinkedRoutingConfigRetrieveResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for ProfileDefaultRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingRetrieveQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingConfigRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingRetrieveLinkQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingLinkWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for RoutingRetrieveLinkQueryWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ToggleDynamicRoutingQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for SuccessBasedRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for SuccessBasedRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for EliminationRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ContractBasedRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ContractBasedRoutingSetupPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ToggleDynamicRoutingWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for CreateDynamicRoutingWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for DynamicRoutingUpdateConfigQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingVolumeSplitWrapper {",
    "function_name": "get_api_event_type",
    "file": "crates__api_models__src__events__routing.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_api_event_type",
    "code": "use common_utils::events::{ApiEventMetric, ApiEventsType};\n\nuse crate::routing::{\n    ContractBasedRoutingPayloadWrapper, ContractBasedRoutingSetupPayloadWrapper,\n    CreateDynamicRoutingWrapper, DynamicRoutingUpdateConfigQuery, EliminationRoutingPayloadWrapper,\n    LinkedRoutingConfigRetrieveResponse, MerchantRoutingAlgorithm, ProfileDefaultRoutingConfig,\n    RoutingAlgorithmId, RoutingConfigRequest, RoutingDictionaryRecord, RoutingKind,\n    RoutingLinkWrapper, RoutingPayloadWrapper, RoutingRetrieveLinkQuery,\n    RoutingRetrieveLinkQueryWrapper, RoutingRetrieveQuery, RoutingVolumeSplit,\n    RoutingVolumeSplitResponse, RoutingVolumeSplitWrapper, RuleMigrationError, RuleMigrationQuery,\n    RuleMigrationResponse, RuleMigrationResult, SuccessBasedRoutingConfig,\n    SuccessBasedRoutingPayloadWrapper, ToggleDynamicRoutingPath, ToggleDynamicRoutingQuery,\n    ToggleDynamicRoutingWrapper,\n};\n\nimpl ApiEventMetric for RoutingKind {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for MerchantRoutingAlgorithm {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingAlgorithmId {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingDictionaryRecord {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for LinkedRoutingConfigRetrieveResponse {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for ProfileDefaultRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingRetrieveQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingConfigRequest {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingRetrieveLinkQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingLinkWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\nimpl ApiEventMetric for RoutingRetrieveLinkQueryWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ToggleDynamicRoutingQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for SuccessBasedRoutingConfig {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for SuccessBasedRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for EliminationRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ContractBasedRoutingPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ContractBasedRoutingSetupPayloadWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for ToggleDynamicRoutingWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for CreateDynamicRoutingWrapper {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for DynamicRoutingUpdateConfigQuery {\n    fn get_api_event_type(&self) -> Option<ApiEventsType> {\n        Some(ApiEventsType::Routing)\n    }\n}\n\nimpl ApiEventMetric for RoutingVolumeSplitWrapper {",
    "function_name": "get_api_event_type",
    "file": "crates__api_models__src__events__routing.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse api_models::{\n    self,\n    payouts::{BankRedirect, PayoutMethodData},\n};\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    id_type,\n    pii::{self, Email, IpAddress},\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        InteracCustomerInfo, RouterData,\n    },\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::PoQuote, router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::{types::PayoutsResponseRouterData, utils::PayoutsData as _};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, BrowserInformationData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\npub struct GigadatRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GigadatRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst CONNECTOR_BASE_URL: &str = \"https://interac.express-connect.com/\";\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct GigadatConnectorMetadataObject {\n    pub site: String,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for GigadatConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"merchant_connector_account.metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n// CPI (Combined Pay-in) Request Structure for Gigadat\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GigadatCpiRequest {\n    pub user_id: id_type::CustomerId,\n    pub site: String,\n    pub user_ip: Secret<String, IpAddress>,\n    pub currency: Currency,\n    pub amount: FloatMajorUnit,\n    pub transaction_id: String,\n    #[serde(rename = \"type\")]\n    pub transaction_type: GidadatTransactionType,\n    pub sandbox: bool,\n    pub name: Secret<String>,\n    pub email: Email,\n    pub mobile: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum GidadatTransactionType {\n    Cpi,\n    Eto,\n}\n\nimpl TryFrom<&GigadatRouterData<&PaymentsAuthorizeRouterData>> for GigadatCpiRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &GigadatRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let metadata: GigadatConnectorMetadataObject =\n            utils::to_connector_meta_from_secret(item.router_data.connector_meta_data.clone())\n                .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"merchant_connector_account.metadata\",\n                })?;\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::BankRedirect(BankRedirectData::Interac { .. }) => {\n                let router_data = item.router_data;\n                let name = router_data.get_billing_full_name()?;\n                let email = router_data.get_billing_email()?;\n                let mobile = router_data.get_billing_phone_number()?;\n                let currency = item.router_data.request.currency;\n                let sandbox = match item.router_data.test_mode {\n                    Some(true) => true,\n                    Some(false) | None => false,\n                };\n                let user_ip = router_data.request.get_browser_info()?.get_ip_address()?;\n                Ok(Self {\n                    user_id: router_data.get_customer_id()?,\n                    site: metadata.site,\n                    user_ip,\n                    currency,\n                    amount: item.amount,\n                    transaction_id: router_data.connector_request_reference_id.clone(),\n                    transaction_type: GidadatTransactionType::Cpi,\n                    name,\n                    sandbox,\n                    email,\n                    mobile,\n                })\n            }\n            PaymentMethodData::BankRedirect(_) => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),\n            ))?,\n\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse api_models::{\n    self,\n    payouts::{BankRedirect, PayoutMethodData},\n};\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    id_type,\n    pii::{self, Email, IpAddress},\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        InteracCustomerInfo, RouterData,\n    },\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::PoQuote, router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::{types::PayoutsResponseRouterData, utils::PayoutsData as _};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, BrowserInformationData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\npub struct GigadatRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GigadatRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst CONNECTOR_BASE_URL: &str = \"https://interac.express-connect.com/\";\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct GigadatConnectorMetadataObject {\n    pub site: String,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for GigadatConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"merchant_connector_account.metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n// CPI (Combined Pay-in) Request Structure for Gigadat\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GigadatCpiRequest {\n    pub user_id: id_type::CustomerId,\n    pub site: String,\n    pub user_ip: Secret<String, IpAddress>,\n    pub currency: Currency,\n    pub amount: FloatMajorUnit,\n    pub transaction_id: String,\n    #[serde(rename = \"type\")]\n    pub transaction_type: GidadatTransactionType,\n    pub sandbox: bool,\n    pub name: Secret<String>,\n    pub email: Email,\n    pub mobile: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum GidadatTransactionType {\n    Cpi,\n    Eto,\n}\n\nimpl TryFrom<&GigadatRouterData<&PaymentsAuthorizeRouterData>> for GigadatCpiRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &GigadatRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let metadata: GigadatConnectorMetadataObject =\n            utils::to_connector_meta_from_secret(item.router_data.connector_meta_data.clone())\n                .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"merchant_connector_account.metadata\",\n                })?;\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::BankRedirect(BankRedirectData::Interac { .. }) => {\n                let router_data = item.router_data;\n                let name = router_data.get_billing_full_name()?;\n                let email = router_data.get_billing_email()?;\n                let mobile = router_data.get_billing_phone_number()?;\n                let currency = item.router_data.request.currency;\n                let sandbox = match item.router_data.test_mode {\n                    Some(true) => true,\n                    Some(false) | None => false,\n                };\n                let user_ip = router_data.request.get_browser_info()?.get_ip_address()?;\n                Ok(Self {\n                    user_id: router_data.get_customer_id()?,\n                    site: metadata.site,\n                    user_ip,\n                    currency,\n                    amount: item.amount,\n                    transaction_id: router_data.connector_request_reference_id.clone(),\n                    transaction_type: GidadatTransactionType::Cpi,\n                    name,\n                    sandbox,\n                    email,\n                    mobile,\n                })\n            }\n            PaymentMethodData::BankRedirect(_) => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),\n            ))?,\n\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\n#[cfg(feature = \"payouts\")]\nuse api_models::{\n    self,\n    payouts::{BankRedirect, PayoutMethodData},\n};\nuse common_enums::{enums, Currency};\nuse common_utils::{\n    id_type,\n    pii::{self, Email, IpAddress},\n    request::Method,\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PaymentMethodData},\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        InteracCustomerInfo, RouterData,\n    },\n    router_flow_types::refunds::Execute,\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::PoQuote, router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::{types::PayoutsResponseRouterData, utils::PayoutsData as _};\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, BrowserInformationData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\npub struct GigadatRouterData<T> {\n    pub amount: FloatMajorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GigadatRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst CONNECTOR_BASE_URL: &str = \"https://interac.express-connect.com/\";\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct GigadatConnectorMetadataObject {\n    pub site: String,\n}\n\nimpl TryFrom<&Option<pii::SecretSerdeValue>> for GigadatConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<pii::SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"merchant_connector_account.metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\n// CPI (Combined Pay-in) Request Structure for Gigadat\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GigadatCpiRequest {\n    pub user_id: id_type::CustomerId,\n    pub site: String,\n    pub user_ip: Secret<String, IpAddress>,\n    pub currency: Currency,\n    pub amount: FloatMajorUnit,\n    pub transaction_id: String,\n    #[serde(rename = \"type\")]\n    pub transaction_type: GidadatTransactionType,\n    pub sandbox: bool,\n    pub name: Secret<String>,\n    pub email: Email,\n    pub mobile: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum GidadatTransactionType {\n    Cpi,\n    Eto,\n}\n\nimpl TryFrom<&GigadatRouterData<&PaymentsAuthorizeRouterData>> for GigadatCpiRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &GigadatRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let metadata: GigadatConnectorMetadataObject =\n            utils::to_connector_meta_from_secret(item.router_data.connector_meta_data.clone())\n                .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                    config: \"merchant_connector_account.metadata\",\n                })?;\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::BankRedirect(BankRedirectData::Interac { .. }) => {\n                let router_data = item.router_data;\n                let name = router_data.get_billing_full_name()?;\n                let email = router_data.get_billing_email()?;\n                let mobile = router_data.get_billing_phone_number()?;\n                let currency = item.router_data.request.currency;\n                let sandbox = match item.router_data.test_mode {\n                    Some(true) => true,\n                    Some(false) | None => false,\n                };\n                let user_ip = router_data.request.get_browser_info()?.get_ip_address()?;\n                Ok(Self {\n                    user_id: router_data.get_customer_id()?,\n                    site: metadata.site,\n                    user_ip,\n                    currency,\n                    amount: item.amount,\n                    transaction_id: router_data.connector_request_reference_id.clone(),\n                    transaction_type: GidadatTransactionType::Cpi,\n                    name,\n                    sandbox,\n                    email,\n                    mobile,\n                })\n            }\n            PaymentMethodData::BankRedirect(_) => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),\n            ))?,\n\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Gigadat\"),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__gigadat__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__api_models__src__authentication.rs",
    "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__authentication.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__api_models__src__authentication.rs",
    "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__authentication.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_api_event_type",
    "code": "use common_enums::{enums, AuthenticationConnectors};\n#[cfg(feature = \"v1\")]\nuse common_utils::errors::{self, CustomResult};\nuse common_utils::{\n    events::{ApiEventMetric, ApiEventsType},\n    id_type,\n};\n#[cfg(feature = \"v1\")]\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::{Address, BrowserInformation, PaymentMethodData};\nuse crate::payments::{\n    ClickToPaySessionResponse, CustomerDetails, DeviceChannel, SdkInformation,\n    ThreeDsCompletionIndicator,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationCreateRequest {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: Option<id_type::AuthenticationId>,\n\n    /// The business profile that is associated with this authentication\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<CustomerDetails>,\n\n    /// The amount for the transaction, required.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// The currency for the transaction, required.\n    #[schema(value_type = Currency)]\n    pub currency: common_enums::Currency,\n\n    /// The URL to which the user should be redirected after authentication.\n    #[schema(value_type = Option<String>, example = \"https://example.com/redirect\")]\n    pub return_url: Option<String>,\n\n    /// Force 3DS challenge.\n    #[serde(default)]\n    pub force_3ds_challenge: Option<bool>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n\n    /// Profile Acquirer ID get from profile acquirer configuration\n    #[schema(value_type = Option<String>)]\n    pub profile_acquirer_id: Option<id_type::ProfileAcquirerId>,\n\n    /// Acquirer details information\n    #[schema(value_type = Option<AcquirerDetails>)]\n    pub acquirer_details: Option<AcquirerDetails>,\n\n    /// Customer details.\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer_details: Option<CustomerDetails>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AcquirerDetails {\n    /// The bin of the card.\n    #[schema(value_type = Option<String>, example = \"123456\")]\n    pub acquirer_bin: Option<String>,\n    /// The merchant id of the card.\n    #[schema(value_type = Option<String>, example = \"merchant_abc\")]\n    pub acquirer_merchant_id: Option<String>,\n    /// The country code of the card.\n    #[schema(value_type = Option<String>, example = \"US/34456\")]\n    pub merchant_country_code: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationResponse {\n    /// The unique identifier for this authentication.\n    #[schema(value_type = String, example = \"auth_mbabizu24mvu3mela5njyhpit4\")]\n    pub authentication_id: id_type::AuthenticationId,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key\n    /// provided during the request\n    #[schema(value_type = String, example = \"merchant_abc\")]\n    pub merchant_id: id_type::MerchantId,\n\n    /// The current status of the authentication (e.g., Started).\n    #[schema(value_type = AuthenticationStatus)]\n    pub status: common_enums::AuthenticationStatus,\n\n    /// The client secret for this authentication, to be used for client-side operations.\n    #[schema(value_type = Option<String>, example = \"auth_mbabizu24mvu3mela5njyhpit4_secret_el9ksDkiB8hi6j9N78yo\")]\n    pub client_secret: Option<masking::Secret<String>>,\n\n    /// The amount for the transaction.\n    #[schema(value_type = MinorUnit, example = 1000)]\n    pub amount: common_utils::types::MinorUnit,\n\n    /// The currency for the transaction.\n    #[schema(value_type = Currency)]\n    pub currency: enums::Currency,\n\n    /// The connector to be used for authentication, if known.\n    #[schema(value_type = Option<AuthenticationConnectors>, example = \"netcetera\")]\n    pub authentication_connector: Option<AuthenticationConnectors>,\n\n    /// Whether 3DS challenge was forced.\n    pub force_3ds_challenge: Option<bool>,\n\n    /// The URL to which the user should be redirected after authentication, if provided.\n    pub return_url: Option<String>,\n\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601::option\")]\n    pub created_at: Option<PrimitiveDateTime>,\n\n    #[schema(example = \"E0001\")]\n    pub error_code: Option<String>,\n\n    /// If there was an error while calling the connector the error message is received here\n    #[schema(example = \"Failed while verifying the card\")]\n    pub error_message: Option<String>,\n\n    /// The business profile that is associated with this payment\n    #[schema(value_type = Option<String>)]\n    pub profile_id: Option<id_type::ProfileId>,\n\n    /// Choose what kind of sca exemption is required for this payment\n    #[schema(value_type = Option<ScaExemptionType>)]\n    pub psd2_sca_exemption_type: Option<common_enums::ScaExemptionType>,\n",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__authentication.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__payments__payment_intent.rs",
    "code": "use api_models::customers::CustomerDocumentDetails;\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_utils::consts::PAYMENTS_LIST_MAX_LIMIT_V2;\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::ParsingError;\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::{Encode, ValueExt};\nuse common_utils::{\n    consts::PAYMENTS_LIST_MAX_LIMIT_V1,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type,\n    pii::{self, Email},\n    type_name,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        CreatedBy, MinorUnit,\n    },\n};\nuse diesel_models::{\n    PaymentIntent as DieselPaymentIntent, PaymentIntentNew as DieselPaymentIntentNew,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{Deserialize, PeekInterface, Secret};\nuse serde::Serialize;\nuse time::PrimitiveDateTime;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::payment_attempt::PaymentAttempt;\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v2\")]\nuse crate::routing;\nuse crate::{\n    behaviour,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{errors, RemoteStorageObject};\n\n#[async_trait::async_trait]\npub trait PaymentIntentInterface {\n    type Error;\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_intent_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_intent_by_merchant_reference_id_profile_id(\n        &self,\n        merchant_reference_id: &id_type::PaymentReferenceId,\n        profile_id: &id_type::ProfileId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: &common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_intent_by_id(\n        &self,\n        id: &id_type::GlobalPaymentId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn filter_payment_intent_by_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        filters: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn filter_payment_intents_by_time_range_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        time_range: &common_utils::types::TimeRange,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(feature = \"olap\")]\n    async fn get_intent_status_with_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        profile_id_list: Option<Vec<id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n    ) -> error_stack::Result<Vec<(common_enums::IntentStatus, i64)>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<(PaymentIntent, PaymentAttempt)>, Self::Error>;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<\n        Vec<(\n            PaymentIntent,\n            Option<super::payment_attempt::PaymentAttempt>,\n        )>,\n        Self::Error,\n    >;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]",
    "function_name": "update_payment_intent",
    "file": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_domain_models__src__payments__payment_intent.rs",
    "code": "use api_models::customers::CustomerDocumentDetails;\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_utils::consts::PAYMENTS_LIST_MAX_LIMIT_V2;\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::ParsingError;\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::{Encode, ValueExt};\nuse common_utils::{\n    consts::PAYMENTS_LIST_MAX_LIMIT_V1,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type,\n    pii::{self, Email},\n    type_name,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        CreatedBy, MinorUnit,\n    },\n};\nuse diesel_models::{\n    PaymentIntent as DieselPaymentIntent, PaymentIntentNew as DieselPaymentIntentNew,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{Deserialize, PeekInterface, Secret};\nuse serde::Serialize;\nuse time::PrimitiveDateTime;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::payment_attempt::PaymentAttempt;\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v2\")]\nuse crate::routing;\nuse crate::{\n    behaviour,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{errors, RemoteStorageObject};\n\n#[async_trait::async_trait]\npub trait PaymentIntentInterface {\n    type Error;\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_intent_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_intent_by_merchant_reference_id_profile_id(\n        &self,\n        merchant_reference_id: &id_type::PaymentReferenceId,\n        profile_id: &id_type::ProfileId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: &common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_intent_by_id(\n        &self,\n        id: &id_type::GlobalPaymentId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn filter_payment_intent_by_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        filters: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn filter_payment_intents_by_time_range_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        time_range: &common_utils::types::TimeRange,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(feature = \"olap\")]\n    async fn get_intent_status_with_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        profile_id_list: Option<Vec<id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n    ) -> error_stack::Result<Vec<(common_enums::IntentStatus, i64)>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<(PaymentIntent, PaymentAttempt)>, Self::Error>;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<\n        Vec<(\n            PaymentIntent,\n            Option<super::payment_attempt::PaymentAttempt>,\n        )>,\n        Self::Error,\n    >;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]",
    "function_name": "update_payment_intent",
    "file": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for update_payment_intent",
    "code": "use api_models::customers::CustomerDocumentDetails;\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v1\")]\nuse common_utils::consts::PAYMENTS_LIST_MAX_LIMIT_V2;\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::ParsingError;\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::{Encode, ValueExt};\nuse common_utils::{\n    consts::PAYMENTS_LIST_MAX_LIMIT_V1,\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type,\n    pii::{self, Email},\n    type_name,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        CreatedBy, MinorUnit,\n    },\n};\nuse diesel_models::{\n    PaymentIntent as DieselPaymentIntent, PaymentIntentNew as DieselPaymentIntentNew,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{Deserialize, PeekInterface, Secret};\nuse serde::Serialize;\nuse time::PrimitiveDateTime;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::payment_attempt::PaymentAttempt;\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::address::Address;\n#[cfg(feature = \"v2\")]\nuse crate::routing;\nuse crate::{\n    behaviour,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\nuse crate::{errors, RemoteStorageObject};\n\n#[async_trait::async_trait]\npub trait PaymentIntentInterface {\n    type Error;\n    async fn update_payment_intent(\n        &self,\n        this: PaymentIntent,\n        payment_intent: PaymentIntentUpdate,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    async fn insert_payment_intent(\n        &self,\n        new: PaymentIntent,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_intent_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_intent_by_merchant_reference_id_profile_id(\n        &self,\n        merchant_reference_id: &id_type::PaymentReferenceId,\n        profile_id: &id_type::ProfileId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: &common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_intent_by_id(\n        &self,\n        id: &id_type::GlobalPaymentId,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentIntent, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn filter_payment_intent_by_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        filters: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn filter_payment_intents_by_time_range_constraints(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        time_range: &common_utils::types::TimeRange,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<PaymentIntent>, Self::Error>;\n\n    #[cfg(feature = \"olap\")]\n    async fn get_intent_status_with_count(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        profile_id_list: Option<Vec<id_type::ProfileId>>,\n        constraints: &common_utils::types::TimeRange,\n    ) -> error_stack::Result<Vec<(common_enums::IntentStatus, i64)>, Self::Error>;\n\n    #[cfg(all(feature = \"v1\", feature = \"olap\"))]\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        processor_merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<Vec<(PaymentIntent, PaymentAttempt)>, Self::Error>;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]\n    async fn get_filtered_payment_intents_attempt(\n        &self,\n        merchant_id: &id_type::MerchantId,\n        constraints: &PaymentIntentFetchConstraints,\n        merchant_key_store: &MerchantKeyStore,\n        storage_scheme: common_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<\n        Vec<(\n            PaymentIntent,\n            Option<super::payment_attempt::PaymentAttempt>,\n        )>,\n        Self::Error,\n    >;\n\n    #[cfg(all(feature = \"v2\", feature = \"olap\"))]",
    "function_name": "update_payment_intent",
    "file": "crates__hyperswitch_domain_models__src__payments__payment_intent.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__core__payments__operations__payment_response.rs",
    "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_data,\n            },\n            tokenization,\n            types::MultipleCaptureData,\n            OperationSessionGetters, PaymentData, PaymentMethodChecker,\n        },\n        utils as core_utils,\n    },\n    routes::{metrics, SessionState},\n    types::{\n        self, domain,\n        storage::{self, enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n        CaptureSyncResponse, ErrorResponse,\n    },\n    utils,\n};\n\n/// This implementation executes the flow only when\n/// 1. Payment was created with supported payment methods\n/// 2. Payment attempt's status was not a terminal failure\n#[cfg(feature = \"v1\")]\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n                            update_connector_mandate_details_for_the_flow(\n                                mandate_reference.connector_mandate_id.clone(),\n                                mandate_reference.mandate_metadata.clone(),\n                                mandate_reference\n                                    .connector_mandate_request_reference_id\n                                    .clone(),\n                                payment_data,\n                            )\n                            .change_context(\n                                ::payment_methods::errors::ModularPaymentMethodError::UpdateFailed,\n                            )?;\n                            mandate_reference\n                                .connector_mandate_id\n                                .map(|connector_mandate_id| {\n                                    ::payment_methods::types::ConnectorTokenDetails {",
    "function_name": "update_modular_pm_and_mandate_impl",
    "file": "crates__router__src__core__payments__operations__payment_response.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__core__payments__operations__payment_response.rs",
    "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_data,\n            },\n            tokenization,\n            types::MultipleCaptureData,\n            OperationSessionGetters, PaymentData, PaymentMethodChecker,\n        },\n        utils as core_utils,\n    },\n    routes::{metrics, SessionState},\n    types::{\n        self, domain,\n        storage::{self, enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n        CaptureSyncResponse, ErrorResponse,\n    },\n    utils,\n};\n\n/// This implementation executes the flow only when\n/// 1. Payment was created with supported payment methods\n/// 2. Payment attempt's status was not a terminal failure\n#[cfg(feature = \"v1\")]\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n                            update_connector_mandate_details_for_the_flow(\n                                mandate_reference.connector_mandate_id.clone(),\n                                mandate_reference.mandate_metadata.clone(),\n                                mandate_reference\n                                    .connector_mandate_request_reference_id\n                                    .clone(),\n                                payment_data,\n                            )\n                            .change_context(\n                                ::payment_methods::errors::ModularPaymentMethodError::UpdateFailed,\n                            )?;\n                            mandate_reference\n                                .connector_mandate_id\n                                .map(|connector_mandate_id| {\n                                    ::payment_methods::types::ConnectorTokenDetails {",
    "function_name": "update_modular_pm_and_mandate_impl",
    "file": "crates__router__src__core__payments__operations__payment_response.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for update_modular_pm_and_mandate_impl",
    "code": "use std::{collections::HashMap, ops::Deref};\n\n#[cfg(feature = \"v1\")]\nuse ::payment_methods::client::{\n    CardDetailUpdate, PaymentMethodUpdateData, UpdatePaymentMethodV1Payload,\n};\nuse api_models::payments::{ConnectorMandateReferenceId, MandateReferenceId};\n#[cfg(feature = \"dynamic_routing\")]\nuse api_models::routing::RoutableConnectorChoice;\nuse async_trait::async_trait;\nuse common_enums::AuthorizationStatus;\n#[cfg(feature = \"v1\")]\nuse common_enums::{ConnectorTokenStatus, TokenizationType};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode},\n    types::{keymanager::KeyManagerState, ConnectorTransactionId, MinorUnit},\n};\nuse error_stack::{report, ResultExt};\nuse futures::FutureExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::{\n    PaymentConfirmData, PaymentIntentData, PaymentStatusData,\n};\nuse hyperswitch_domain_models::{behaviour::Conversion, payments::payment_attempt::PaymentAttempt};\n#[cfg(feature = \"v2\")]\nuse masking::{ExposeInterface, PeekInterface};\nuse router_derive;\nuse router_env::{instrument, logger, tracing};\n#[cfg(feature = \"v1\")]\nuse tracing_futures::Instrument;\n\nuse super::{Operation, OperationSessionSetters, PostUpdateTracker};\n#[cfg(feature = \"v1\")]\nuse crate::core::payment_methods::transformers::call_modular_payment_method_update;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse crate::core::routing::helpers as routing_helpers;\n#[cfg(feature = \"v2\")]\nuse crate::utils::OptionExt;\nuse crate::{\n    connector::utils::PaymentResponseRouterData,\n    consts,\n    core::{\n        card_testing_guard::utils as card_testing_guard_utils,\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate,\n        payment_methods::{self, cards::create_encrypted_data},\n        payments::{\n            helpers::{\n                self as payments_helpers,\n                update_additional_payment_data_with_connector_response_pm_data,\n            },\n            tokenization,\n            types::MultipleCaptureData,\n            OperationSessionGetters, PaymentData, PaymentMethodChecker,\n        },\n        utils as core_utils,\n    },\n    routes::{metrics, SessionState},\n    types::{\n        self, domain,\n        storage::{self, enums},\n        transformers::{ForeignFrom, ForeignTryFrom},\n        CaptureSyncResponse, ErrorResponse,\n    },\n    utils,\n};\n\n/// This implementation executes the flow only when\n/// 1. Payment was created with supported payment methods\n/// 2. Payment attempt's status was not a terminal failure\n#[cfg(feature = \"v1\")]\nasync fn update_modular_pm_and_mandate_impl<F, T>(\n    state: &SessionState,\n    resp: &types::RouterData<F, T, types::PaymentsResponseData>,\n    request_payment_method_data: Option<&domain::PaymentMethodData>,\n    payment_data: &mut PaymentData<F>,\n) -> CustomResult<(), ::payment_methods::errors::ModularPaymentMethodError>\nwhere\n    F: Clone + Send + Sync,\n{\n    if matches!(\n        payment_data.payment_attempt.payment_method,\n        Some(enums::PaymentMethod::Card)\n    ) && resp.status.should_update_payment_method()\n    {\n        //#1 - Check if Payment method id is present in the payment data\n        match payment_data\n            .payment_method_info\n            .as_ref()\n            .map(|pm_info| pm_info.get_id().clone())\n        {\n            Some(payment_method_id) => {\n                logger::info!(\"Payment method is card and eligible for modular update\");\n\n                // #2 - Derive network transaction ID from the connector response.\n                let (network_transaction_id, connector_token_details) = if matches!(\n                    payment_data.payment_attempt.setup_future_usage_applied,\n                    Some(common_enums::FutureUsage::OffSession)\n                ) {\n                    let network_transaction_id = resp\n                    .response\n                    .as_ref()\n                    .map_err(|err| {\n                        logger::debug!(error=?err, \"Failed to obtain the network_transaction_id from payment response in modular payment method update call\");\n                    })\n                    .ok()\n                    .and_then(types::PaymentsResponseData::get_network_transaction_id);\n\n                    let connector_token_details = match resp\n                        .response\n                        .as_ref()\n                        .ok()\n                        .and_then(types::PaymentsResponseData::get_mandate_reference)\n                    {\n                        Some(mandate_reference) => {\n                            let connector_id = payment_data\n                            .payment_attempt\n                            .merchant_connector_id\n                            .clone()\n                            .ok_or_else(|| {\n                                logger::error!(\"Missing required Param merchant_connector_id\");\n                                ::payment_methods::errors::ModularPaymentMethodError::RetrieveFailed\n                            })?;\n                            update_connector_mandate_details_for_the_flow(\n                                mandate_reference.connector_mandate_id.clone(),\n                                mandate_reference.mandate_metadata.clone(),\n                                mandate_reference\n                                    .connector_mandate_request_reference_id\n                                    .clone(),\n                                payment_data,\n                            )\n                            .change_context(\n                                ::payment_methods::errors::ModularPaymentMethodError::UpdateFailed,\n                            )?;\n                            mandate_reference\n                                .connector_mandate_id\n                                .map(|connector_mandate_id| {\n                                    ::payment_methods::types::ConnectorTokenDetails {",
    "function_name": "update_modular_pm_and_mandate_impl",
    "file": "crates__router__src__core__payments__operations__payment_response.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__types__domain__user.rs",
    "code": "use std::{\n    collections::HashSet,\n    ops::{Deref, Not},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    admin as admin_api, organization as api_org, user as user_api, user_role as user_role_api,\n};\nuse common_enums::EntityType;\nuse common_utils::{\n    crypto::Encryptable, id_type, new_type::MerchantName, pii, type_name,\n    types::keymanager::Identifier,\n};\nuse diesel_models::{\n    enums::{TotpStatus, UserRoleVersion, UserStatus},\n    organization::{self as diesel_org, Organization, OrganizationBridge},\n    user as storage_user,\n    user_role::{UserRole, UserRoleNew},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::api::ApplicationResponse;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse time::PrimitiveDateTime;\nuse unicode_segmentation::UnicodeSegmentation;\n#[cfg(feature = \"keymanager_create\")]\nuse {base64::Engine, common_utils::types::keymanager::EncryptionTransferRequest};\n\nuse crate::{\n    consts,\n    core::{\n        admin,\n        errors::{UserErrors, UserResult},\n    },\n    db::GlobalStorageInterface,\n    routes::SessionState,\n    services::{\n        self,\n        authentication::{AuthenticationDataWithOrg, UserFromToken},\n    },\n    types::{domain, transformers::ForeignFrom},\n    utils::{self, user::password},\n};\n\npub mod dashboard_metadata;\npub mod decision_manager;\npub use decision_manager::*;\npub mod oidc;\npub mod user_authentication_method;\n\nuse super::{types as domain_types, UserKeyStore};\n\n#[derive(Clone)]\npub struct UserName(Secret<String>);\n\nimpl UserName {\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_characters.contains(&g));\n\n        if is_empty_or_whitespace || is_too_long || contains_forbidden_characters {\n            Err(UserErrors::NameParsingError.into())\n        } else {\n            Ok(Self(name.into()))\n        }\n    }\n\n    pub fn get_secret(self) -> Secret<String> {\n        self.0\n    }\n}\n\nimpl TryFrom<pii::Email> for UserName {\n    type Error = error_stack::Report<UserErrors>;\n\n    fn try_from(value: pii::Email) -> UserResult<Self> {\n        Self::new(Secret::new(\n            value\n                .peek()\n                .split_once('@')\n                .ok_or(UserErrors::InvalidEmailError)?\n                .0\n                .to_string(),\n        ))\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct UserEmail(pii::Email);\n\nstatic BLOCKED_EMAIL: LazyLock<HashSet<String>> = LazyLock::new(|| {\n    let blocked_emails_content = include_str!(\"../../utils/user/blocker_emails.txt\");\n    let blocked_emails: HashSet<String> = blocked_emails_content\n        .lines()\n        .map(|s| s.trim().to_owned())\n        .collect();\n    blocked_emails\n});\n\nimpl UserEmail {\n    pub fn new(email: Secret<String, pii::EmailStrategy>) -> UserResult<Self> {\n        use validator::ValidateEmail;\n\n        let email_string = email.expose().to_lowercase();\n        let email =\n            pii::Email::from_str(&email_string).change_context(UserErrors::EmailParsingError)?;\n\n        if email_string.validate_email() {\n            let (_username, domain) = match email_string.as_str().split_once('@') {\n                Some((u, d)) => (u, d),\n                None => return Err(UserErrors::EmailParsingError.into()),\n            };\n\n            if BLOCKED_EMAIL.contains(domain) {\n                return Err(UserErrors::InvalidEmailError.into());\n            }\n            Ok(Self(email))\n        } else {\n            Err(UserErrors::EmailParsingError.into())\n        }\n    }\n\n    pub fn from_pii_email(email: pii::Email) -> UserResult<Self> {\n        let email_string = email.expose().map(|inner| inner.to_lowercase());\n        Self::new(email_string)\n    }\n\n    pub fn into_inner(self) -> pii::Email {\n        self.0\n    }\n\n    pub fn get_inner(&self) -> &pii::Email {\n        &self.0\n    }",
    "function_name": "new",
    "file": "crates__router__src__types__domain__user.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__types__domain__user.rs",
    "code": "use std::{\n    collections::HashSet,\n    ops::{Deref, Not},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    admin as admin_api, organization as api_org, user as user_api, user_role as user_role_api,\n};\nuse common_enums::EntityType;\nuse common_utils::{\n    crypto::Encryptable, id_type, new_type::MerchantName, pii, type_name,\n    types::keymanager::Identifier,\n};\nuse diesel_models::{\n    enums::{TotpStatus, UserRoleVersion, UserStatus},\n    organization::{self as diesel_org, Organization, OrganizationBridge},\n    user as storage_user,\n    user_role::{UserRole, UserRoleNew},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::api::ApplicationResponse;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse time::PrimitiveDateTime;\nuse unicode_segmentation::UnicodeSegmentation;\n#[cfg(feature = \"keymanager_create\")]\nuse {base64::Engine, common_utils::types::keymanager::EncryptionTransferRequest};\n\nuse crate::{\n    consts,\n    core::{\n        admin,\n        errors::{UserErrors, UserResult},\n    },\n    db::GlobalStorageInterface,\n    routes::SessionState,\n    services::{\n        self,\n        authentication::{AuthenticationDataWithOrg, UserFromToken},\n    },\n    types::{domain, transformers::ForeignFrom},\n    utils::{self, user::password},\n};\n\npub mod dashboard_metadata;\npub mod decision_manager;\npub use decision_manager::*;\npub mod oidc;\npub mod user_authentication_method;\n\nuse super::{types as domain_types, UserKeyStore};\n\n#[derive(Clone)]\npub struct UserName(Secret<String>);\n\nimpl UserName {\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_characters.contains(&g));\n\n        if is_empty_or_whitespace || is_too_long || contains_forbidden_characters {\n            Err(UserErrors::NameParsingError.into())\n        } else {\n            Ok(Self(name.into()))\n        }\n    }\n\n    pub fn get_secret(self) -> Secret<String> {\n        self.0\n    }\n}\n\nimpl TryFrom<pii::Email> for UserName {\n    type Error = error_stack::Report<UserErrors>;\n\n    fn try_from(value: pii::Email) -> UserResult<Self> {\n        Self::new(Secret::new(\n            value\n                .peek()\n                .split_once('@')\n                .ok_or(UserErrors::InvalidEmailError)?\n                .0\n                .to_string(),\n        ))\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct UserEmail(pii::Email);\n\nstatic BLOCKED_EMAIL: LazyLock<HashSet<String>> = LazyLock::new(|| {\n    let blocked_emails_content = include_str!(\"../../utils/user/blocker_emails.txt\");\n    let blocked_emails: HashSet<String> = blocked_emails_content\n        .lines()\n        .map(|s| s.trim().to_owned())\n        .collect();\n    blocked_emails\n});\n\nimpl UserEmail {\n    pub fn new(email: Secret<String, pii::EmailStrategy>) -> UserResult<Self> {\n        use validator::ValidateEmail;\n\n        let email_string = email.expose().to_lowercase();\n        let email =\n            pii::Email::from_str(&email_string).change_context(UserErrors::EmailParsingError)?;\n\n        if email_string.validate_email() {\n            let (_username, domain) = match email_string.as_str().split_once('@') {\n                Some((u, d)) => (u, d),\n                None => return Err(UserErrors::EmailParsingError.into()),\n            };\n\n            if BLOCKED_EMAIL.contains(domain) {\n                return Err(UserErrors::InvalidEmailError.into());\n            }\n            Ok(Self(email))\n        } else {\n            Err(UserErrors::EmailParsingError.into())\n        }\n    }\n\n    pub fn from_pii_email(email: pii::Email) -> UserResult<Self> {\n        let email_string = email.expose().map(|inner| inner.to_lowercase());\n        Self::new(email_string)\n    }\n\n    pub fn into_inner(self) -> pii::Email {\n        self.0\n    }\n\n    pub fn get_inner(&self) -> &pii::Email {\n        &self.0\n    }",
    "function_name": "new",
    "file": "crates__router__src__types__domain__user.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "use std::{\n    collections::HashSet,\n    ops::{Deref, Not},\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{\n    admin as admin_api, organization as api_org, user as user_api, user_role as user_role_api,\n};\nuse common_enums::EntityType;\nuse common_utils::{\n    crypto::Encryptable, id_type, new_type::MerchantName, pii, type_name,\n    types::keymanager::Identifier,\n};\nuse diesel_models::{\n    enums::{TotpStatus, UserRoleVersion, UserStatus},\n    organization::{self as diesel_org, Organization, OrganizationBridge},\n    user as storage_user,\n    user_role::{UserRole, UserRoleNew},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::api::ApplicationResponse;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse rand::distributions::{Alphanumeric, DistString};\nuse time::PrimitiveDateTime;\nuse unicode_segmentation::UnicodeSegmentation;\n#[cfg(feature = \"keymanager_create\")]\nuse {base64::Engine, common_utils::types::keymanager::EncryptionTransferRequest};\n\nuse crate::{\n    consts,\n    core::{\n        admin,\n        errors::{UserErrors, UserResult},\n    },\n    db::GlobalStorageInterface,\n    routes::SessionState,\n    services::{\n        self,\n        authentication::{AuthenticationDataWithOrg, UserFromToken},\n    },\n    types::{domain, transformers::ForeignFrom},\n    utils::{self, user::password},\n};\n\npub mod dashboard_metadata;\npub mod decision_manager;\npub use decision_manager::*;\npub mod oidc;\npub mod user_authentication_method;\n\nuse super::{types as domain_types, UserKeyStore};\n\n#[derive(Clone)]\npub struct UserName(Secret<String>);\n\nimpl UserName {\n    pub fn new(name: Secret<String>) -> UserResult<Self> {\n        let name = name.expose();\n        let is_empty_or_whitespace = name.trim().is_empty();\n        let is_too_long = name.graphemes(true).count() > consts::user::MAX_NAME_LENGTH;\n\n        let forbidden_characters = ['/', '(', ')', '\"', '<', '>', '\\\\', '{', '}'];\n        let contains_forbidden_characters = name.chars().any(|g| forbidden_characters.contains(&g));\n\n        if is_empty_or_whitespace || is_too_long || contains_forbidden_characters {\n            Err(UserErrors::NameParsingError.into())\n        } else {\n            Ok(Self(name.into()))\n        }\n    }\n\n    pub fn get_secret(self) -> Secret<String> {\n        self.0\n    }\n}\n\nimpl TryFrom<pii::Email> for UserName {\n    type Error = error_stack::Report<UserErrors>;\n\n    fn try_from(value: pii::Email) -> UserResult<Self> {\n        Self::new(Secret::new(\n            value\n                .peek()\n                .split_once('@')\n                .ok_or(UserErrors::InvalidEmailError)?\n                .0\n                .to_string(),\n        ))\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct UserEmail(pii::Email);\n\nstatic BLOCKED_EMAIL: LazyLock<HashSet<String>> = LazyLock::new(|| {\n    let blocked_emails_content = include_str!(\"../../utils/user/blocker_emails.txt\");\n    let blocked_emails: HashSet<String> = blocked_emails_content\n        .lines()\n        .map(|s| s.trim().to_owned())\n        .collect();\n    blocked_emails\n});\n\nimpl UserEmail {\n    pub fn new(email: Secret<String, pii::EmailStrategy>) -> UserResult<Self> {\n        use validator::ValidateEmail;\n\n        let email_string = email.expose().to_lowercase();\n        let email =\n            pii::Email::from_str(&email_string).change_context(UserErrors::EmailParsingError)?;\n\n        if email_string.validate_email() {\n            let (_username, domain) = match email_string.as_str().split_once('@') {\n                Some((u, d)) => (u, d),\n                None => return Err(UserErrors::EmailParsingError.into()),\n            };\n\n            if BLOCKED_EMAIL.contains(domain) {\n                return Err(UserErrors::InvalidEmailError.into());\n            }\n            Ok(Self(email))\n        } else {\n            Err(UserErrors::EmailParsingError.into())\n        }\n    }\n\n    pub fn from_pii_email(email: pii::Email) -> UserResult<Self> {\n        let email_string = email.expose().map(|inner| inner.to_lowercase());\n        Self::new(email_string)\n    }\n\n    pub fn into_inner(self) -> pii::Email {\n        self.0\n    }\n\n    pub fn get_inner(&self) -> &pii::Email {\n        &self.0\n    }",
    "function_name": "new",
    "file": "crates__router__src__types__domain__user.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    consts::{PROPHETPAY_REDIRECT_URL, PROPHETPAY_TOKEN},\n    errors::CustomResult,\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{CardRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{api, consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, to_connector_meta},\n};\n\npub struct ProphetpayRouterData<T> {\n    pub amount: f64,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ProphetpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_f64(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub struct ProphetpayAuthType {\n    pub(super) user_name: Secret<String>,\n    pub(super) password: Secret<String>,\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ProphetpayAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                user_name: api_key.to_owned(),\n                password: key1.to_owned(),\n                profile_id: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"PascalCase\")]\npub struct ProphetpayTokenRequest {\n    ref_info: String,\n    profile: Secret<String>,\n    entry_method: i8,\n    token_type: i8,\n    card_entry_context: i8,\n}\n\n#[derive(Debug, Clone)]\npub enum ProphetpayEntryMethod {\n    ManualEntry,\n    CardSwipe,\n}\n\nimpl ProphetpayEntryMethod {\n    fn get_entry_method(&self) -> i8 {\n        match self {\n            Self::ManualEntry => 1,\n            Self::CardSwipe => 2,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[repr(i8)]\npub enum ProphetpayTokenType {\n    Normal,\n    SaleTab,\n    TemporarySave,\n}\n\nimpl ProphetpayTokenType {\n    fn get_token_type(&self) -> i8 {\n        match self {\n            Self::Normal => 0,\n            Self::SaleTab => 1,\n            Self::TemporarySave => 2,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[repr(i8)]\npub enum ProphetpayCardContext {\n    NotApplicable,\n    WebConsumerInitiated,\n}\n\nimpl ProphetpayCardContext {\n    fn get_card_context(&self) -> i8 {\n        match self {\n            Self::NotApplicable => 0,\n            Self::WebConsumerInitiated => 5,\n        }\n    }\n}\n\nimpl TryFrom<&ProphetpayRouterData<&types::PaymentsAuthorizeRouterData>>\n    for ProphetpayTokenRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &ProphetpayRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        if item.router_data.request.currency == api_models::enums::Currency::USD {\n            match item.router_data.request.payment_method_data.clone() {\n                PaymentMethodData::CardRedirect(CardRedirectData::CardRedirect {}) => {\n                    let auth_data =\n                        ProphetpayAuthType::try_from(&item.router_data.connector_auth_type)?;",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    consts::{PROPHETPAY_REDIRECT_URL, PROPHETPAY_TOKEN},\n    errors::CustomResult,\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{CardRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{api, consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, to_connector_meta},\n};\n\npub struct ProphetpayRouterData<T> {\n    pub amount: f64,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ProphetpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_f64(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub struct ProphetpayAuthType {\n    pub(super) user_name: Secret<String>,\n    pub(super) password: Secret<String>,\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ProphetpayAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                user_name: api_key.to_owned(),\n                password: key1.to_owned(),\n                profile_id: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"PascalCase\")]\npub struct ProphetpayTokenRequest {\n    ref_info: String,\n    profile: Secret<String>,\n    entry_method: i8,\n    token_type: i8,\n    card_entry_context: i8,\n}\n\n#[derive(Debug, Clone)]\npub enum ProphetpayEntryMethod {\n    ManualEntry,\n    CardSwipe,\n}\n\nimpl ProphetpayEntryMethod {\n    fn get_entry_method(&self) -> i8 {\n        match self {\n            Self::ManualEntry => 1,\n            Self::CardSwipe => 2,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[repr(i8)]\npub enum ProphetpayTokenType {\n    Normal,\n    SaleTab,\n    TemporarySave,\n}\n\nimpl ProphetpayTokenType {\n    fn get_token_type(&self) -> i8 {\n        match self {\n            Self::Normal => 0,\n            Self::SaleTab => 1,\n            Self::TemporarySave => 2,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[repr(i8)]\npub enum ProphetpayCardContext {\n    NotApplicable,\n    WebConsumerInitiated,\n}\n\nimpl ProphetpayCardContext {\n    fn get_card_context(&self) -> i8 {\n        match self {\n            Self::NotApplicable => 0,\n            Self::WebConsumerInitiated => 5,\n        }\n    }\n}\n\nimpl TryFrom<&ProphetpayRouterData<&types::PaymentsAuthorizeRouterData>>\n    for ProphetpayTokenRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &ProphetpayRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        if item.router_data.request.currency == api_models::enums::Currency::USD {\n            match item.router_data.request.payment_method_data.clone() {\n                PaymentMethodData::CardRedirect(CardRedirectData::CardRedirect {}) => {\n                    let auth_data =\n                        ProphetpayAuthType::try_from(&item.router_data.connector_auth_type)?;",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    consts::{PROPHETPAY_REDIRECT_URL, PROPHETPAY_TOKEN},\n    errors::CustomResult,\n    request::Method,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{CardRedirectData, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId},\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{api, consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, to_connector_meta},\n};\n\npub struct ProphetpayRouterData<T> {\n    pub amount: f64,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(&api::CurrencyUnit, enums::Currency, i64, T)> for ProphetpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        (currency_unit, currency, amount, item): (&api::CurrencyUnit, enums::Currency, i64, T),\n    ) -> Result<Self, Self::Error> {\n        let amount = utils::get_amount_as_f64(currency_unit, amount, currency)?;\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub struct ProphetpayAuthType {\n    pub(super) user_name: Secret<String>,\n    pub(super) password: Secret<String>,\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for ProphetpayAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                user_name: api_key.to_owned(),\n                password: key1.to_owned(),\n                profile_id: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"PascalCase\")]\npub struct ProphetpayTokenRequest {\n    ref_info: String,\n    profile: Secret<String>,\n    entry_method: i8,\n    token_type: i8,\n    card_entry_context: i8,\n}\n\n#[derive(Debug, Clone)]\npub enum ProphetpayEntryMethod {\n    ManualEntry,\n    CardSwipe,\n}\n\nimpl ProphetpayEntryMethod {\n    fn get_entry_method(&self) -> i8 {\n        match self {\n            Self::ManualEntry => 1,\n            Self::CardSwipe => 2,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[repr(i8)]\npub enum ProphetpayTokenType {\n    Normal,\n    SaleTab,\n    TemporarySave,\n}\n\nimpl ProphetpayTokenType {\n    fn get_token_type(&self) -> i8 {\n        match self {\n            Self::Normal => 0,\n            Self::SaleTab => 1,\n            Self::TemporarySave => 2,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n#[repr(i8)]\npub enum ProphetpayCardContext {\n    NotApplicable,\n    WebConsumerInitiated,\n}\n\nimpl ProphetpayCardContext {\n    fn get_card_context(&self) -> i8 {\n        match self {\n            Self::NotApplicable => 0,\n            Self::WebConsumerInitiated => 5,\n        }\n    }\n}\n\nimpl TryFrom<&ProphetpayRouterData<&types::PaymentsAuthorizeRouterData>>\n    for ProphetpayTokenRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &ProphetpayRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        if item.router_data.request.currency == api_models::enums::Currency::USD {\n            match item.router_data.request.payment_method_data.clone() {\n                PaymentMethodData::CardRedirect(CardRedirectData::CardRedirect {}) => {\n                    let auth_data =\n                        ProphetpayAuthType::try_from(&item.router_data.connector_auth_type)?;",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__prophetpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__forte__transformers.rs",
    "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{PaymentsCaptureResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _PaymentsAuthorizeRequestData,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ForteRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for ForteRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FortePaymentsRequest {\n    action: ForteAction,\n    authorization_amount: FloatMajorUnit,\n    billing_address: BillingAddress,\n    card: Card,\n}\n#[derive(Debug, Serialize, Deserialize)]\npub struct BillingAddress {\n    first_name: Secret<String>,\n    last_name: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Card {\n    card_type: ForteCardType,\n    name_on_card: Secret<String>,\n    account_number: CardNumber,\n    expire_month: Secret<String>,\n    expire_year: Secret<String>,\n    card_verification_value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ForteCardType {\n    Visa,\n    MasterCard,\n    Amex,\n    Discover,\n    DinersClub,\n    Jcb,\n}\n\nimpl TryFrom<utils::CardIssuer> for ForteCardType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(issuer: utils::CardIssuer) -> Result<Self, Self::Error> {\n        match issuer {\n            utils::CardIssuer::AmericanExpress => Ok(Self::Amex),\n            utils::CardIssuer::Master => Ok(Self::MasterCard),\n            utils::CardIssuer::Discover => Ok(Self::Discover),\n            utils::CardIssuer::Visa => Ok(Self::Visa),\n            utils::CardIssuer::DinersClub => Ok(Self::DinersClub),\n            utils::CardIssuer::JCB => Ok(Self::Jcb),\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Forte\"),\n            )\n            .into()),\n        }\n    }\n}\n\nimpl TryFrom<&ForteRouterData<&types::PaymentsAuthorizeRouterData>> for FortePaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item_data: &ForteRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let item = item_data.router_data;\n\n        match item.request.payment_method_data {\n            PaymentMethodData::Card(ref ccard) => {\n                if item.is_three_ds() {\n                    Err(errors::ConnectorError::NotSupported {\n                        message: \"Cards 3DS\".to_string(),\n                        connector: \"Forte\",\n                    })?\n                }\n                let action = match item.request.is_auto_capture()? {\n                    true => ForteAction::Sale,\n                    false => ForteAction::Authorize,\n                };\n                let card_type = ForteCardType::try_from(ccard.get_card_issuer()?)?;\n                let address = item.get_billing_address()?;\n                let card = Card {\n                    card_type,\n                    name_on_card: item\n                        .get_optional_billing_full_name()\n                        .unwrap_or(Secret::new(\"\".to_string())),\n                    account_number: ccard.card_number.clone(),\n                    expire_month: ccard.card_exp_month.clone(),\n                    expire_year: ccard.card_exp_year.clone(),\n                    card_verification_value: ccard.card_cvc.clone(),\n                };\n                let first_name = address.get_first_name()?;\n                let billing_address = BillingAddress {\n                    first_name: first_name.clone(),\n                    last_name: address.get_last_name().unwrap_or(first_name).clone(),\n                };\n                let authorization_amount = item_data.amount;\n                Ok(Self {\n                    action,\n                    authorization_amount,\n                    billing_address,\n                    card,\n                })\n            }\n            PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::Wallet(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__forte__transformers.rs",
    "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{PaymentsCaptureResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _PaymentsAuthorizeRequestData,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ForteRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for ForteRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FortePaymentsRequest {\n    action: ForteAction,\n    authorization_amount: FloatMajorUnit,\n    billing_address: BillingAddress,\n    card: Card,\n}\n#[derive(Debug, Serialize, Deserialize)]\npub struct BillingAddress {\n    first_name: Secret<String>,\n    last_name: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Card {\n    card_type: ForteCardType,\n    name_on_card: Secret<String>,\n    account_number: CardNumber,\n    expire_month: Secret<String>,\n    expire_year: Secret<String>,\n    card_verification_value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ForteCardType {\n    Visa,\n    MasterCard,\n    Amex,\n    Discover,\n    DinersClub,\n    Jcb,\n}\n\nimpl TryFrom<utils::CardIssuer> for ForteCardType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(issuer: utils::CardIssuer) -> Result<Self, Self::Error> {\n        match issuer {\n            utils::CardIssuer::AmericanExpress => Ok(Self::Amex),\n            utils::CardIssuer::Master => Ok(Self::MasterCard),\n            utils::CardIssuer::Discover => Ok(Self::Discover),\n            utils::CardIssuer::Visa => Ok(Self::Visa),\n            utils::CardIssuer::DinersClub => Ok(Self::DinersClub),\n            utils::CardIssuer::JCB => Ok(Self::Jcb),\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Forte\"),\n            )\n            .into()),\n        }\n    }\n}\n\nimpl TryFrom<&ForteRouterData<&types::PaymentsAuthorizeRouterData>> for FortePaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item_data: &ForteRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let item = item_data.router_data;\n\n        match item.request.payment_method_data {\n            PaymentMethodData::Card(ref ccard) => {\n                if item.is_three_ds() {\n                    Err(errors::ConnectorError::NotSupported {\n                        message: \"Cards 3DS\".to_string(),\n                        connector: \"Forte\",\n                    })?\n                }\n                let action = match item.request.is_auto_capture()? {\n                    true => ForteAction::Sale,\n                    false => ForteAction::Authorize,\n                };\n                let card_type = ForteCardType::try_from(ccard.get_card_issuer()?)?;\n                let address = item.get_billing_address()?;\n                let card = Card {\n                    card_type,\n                    name_on_card: item\n                        .get_optional_billing_full_name()\n                        .unwrap_or(Secret::new(\"\".to_string())),\n                    account_number: ccard.card_number.clone(),\n                    expire_month: ccard.card_exp_month.clone(),\n                    expire_year: ccard.card_exp_year.clone(),\n                    card_verification_value: ccard.card_cvc.clone(),\n                };\n                let first_name = address.get_first_name()?;\n                let billing_address = BillingAddress {\n                    first_name: first_name.clone(),\n                    last_name: address.get_last_name().unwrap_or(first_name).clone(),\n                };\n                let authorization_amount = item_data.amount;\n                Ok(Self {\n                    action,\n                    authorization_amount,\n                    billing_address,\n                    card,\n                })\n            }\n            PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::Wallet(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{PaymentsCaptureResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _PaymentsAuthorizeRequestData,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct ForteRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for ForteRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FortePaymentsRequest {\n    action: ForteAction,\n    authorization_amount: FloatMajorUnit,\n    billing_address: BillingAddress,\n    card: Card,\n}\n#[derive(Debug, Serialize, Deserialize)]\npub struct BillingAddress {\n    first_name: Secret<String>,\n    last_name: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Card {\n    card_type: ForteCardType,\n    name_on_card: Secret<String>,\n    account_number: CardNumber,\n    expire_month: Secret<String>,\n    expire_year: Secret<String>,\n    card_verification_value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ForteCardType {\n    Visa,\n    MasterCard,\n    Amex,\n    Discover,\n    DinersClub,\n    Jcb,\n}\n\nimpl TryFrom<utils::CardIssuer> for ForteCardType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(issuer: utils::CardIssuer) -> Result<Self, Self::Error> {\n        match issuer {\n            utils::CardIssuer::AmericanExpress => Ok(Self::Amex),\n            utils::CardIssuer::Master => Ok(Self::MasterCard),\n            utils::CardIssuer::Discover => Ok(Self::Discover),\n            utils::CardIssuer::Visa => Ok(Self::Visa),\n            utils::CardIssuer::DinersClub => Ok(Self::DinersClub),\n            utils::CardIssuer::JCB => Ok(Self::Jcb),\n            _ => Err(errors::ConnectorError::NotImplemented(\n                utils::get_unimplemented_payment_method_error_message(\"Forte\"),\n            )\n            .into()),\n        }\n    }\n}\n\nimpl TryFrom<&ForteRouterData<&types::PaymentsAuthorizeRouterData>> for FortePaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item_data: &ForteRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let item = item_data.router_data;\n\n        match item.request.payment_method_data {\n            PaymentMethodData::Card(ref ccard) => {\n                if item.is_three_ds() {\n                    Err(errors::ConnectorError::NotSupported {\n                        message: \"Cards 3DS\".to_string(),\n                        connector: \"Forte\",\n                    })?\n                }\n                let action = match item.request.is_auto_capture()? {\n                    true => ForteAction::Sale,\n                    false => ForteAction::Authorize,\n                };\n                let card_type = ForteCardType::try_from(ccard.get_card_issuer()?)?;\n                let address = item.get_billing_address()?;\n                let card = Card {\n                    card_type,\n                    name_on_card: item\n                        .get_optional_billing_full_name()\n                        .unwrap_or(Secret::new(\"\".to_string())),\n                    account_number: ccard.card_number.clone(),\n                    expire_month: ccard.card_exp_month.clone(),\n                    expire_year: ccard.card_exp_year.clone(),\n                    card_verification_value: ccard.card_cvc.clone(),\n                };\n                let first_name = address.get_first_name()?;\n                let billing_address = BillingAddress {\n                    first_name: first_name.clone(),\n                    last_name: address.get_last_name().unwrap_or(first_name).clone(),\n                };\n                let authorization_amount = item_data.amount;\n                Ok(Self {\n                    action,\n                    authorization_amount,\n                    billing_address,\n                    card,\n                })\n            }\n            PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::Wallet(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__forte__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__celero__transformers.rs",
    "code": "use common_enums::{enums, Currency};\nuse common_utils::{id_type::CustomerId, pii::Email, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    address::Address as DomainAddress,\n    payment_method_data::PaymentMethodData,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        RouterData,\n    },\n    router_flow_types::{\n        payments::Capture,\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{PaymentsCaptureData, ResponseId},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts,\n    errors::{self},\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        get_unimplemented_payment_method_error_message, AddressDetailsData,\n        PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct CeleroRouterData<T> {\n    pub amount: MinorUnit, // CeleroCommerce expects integer cents\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for CeleroRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n// CeleroCommerce Search Request for sync operations - POST /api/transaction/search\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroSearchRequest {\n    transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsSyncRouterData> for CeleroSearchRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsSyncRouterData) -> Result<Self, Self::Error> {\n        let transaction_id = match &item.request.connector_transaction_id {\n            ResponseId::ConnectorTransactionId(id) => id.clone(),\n            _ => {\n                return Err(errors::ConnectorError::MissingConnectorTransactionID.into());\n            }\n        };\n        Ok(Self { transaction_id })\n    }\n}\n\nimpl TryFrom<&RefundSyncRouterData> for CeleroSearchRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &RefundSyncRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            transaction_id: item.request.get_connector_refund_id()?,\n        })\n    }\n}\n\n// CeleroCommerce Payment Request according to API specs\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroPaymentsRequest {\n    idempotency_key: String,\n    #[serde(rename = \"type\")]\n    transaction_type: TransactionType,\n    amount: MinorUnit, // CeleroCommerce expects integer cents\n    currency: Currency,\n    payment_method: CeleroPaymentMethod,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<CeleroAddress>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shipping_address: Option<CeleroAddress>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    create_vault_record: Option<bool>,\n    // CIT/MIT fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    card_on_file_indicator: Option<CardOnFileIndicator>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    initiated_by: Option<InitiatedBy>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    initial_transaction_id: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stored_credential_indicator: Option<StoredCredentialIndicator>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_method: Option<BillingMethod>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroAddress {\n    first_name: Option<Secret<String>>,\n    last_name: Option<Secret<String>>,\n    address_line_1: Option<Secret<String>>,\n    address_line_2: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n    postal_code: Option<Secret<String>>,\n    country: Option<common_enums::CountryAlpha2>,\n    phone: Option<Secret<String>>,\n    email: Option<Email>,\n}\n\nimpl TryFrom<&DomainAddress> for CeleroAddress {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(address: &DomainAddress) -> Result<Self, Self::Error> {\n        let address_details = address.address.as_ref();\n        match address_details {\n            Some(address_details) => Ok(Self {\n                first_name: address_details.get_optional_first_name(),\n                last_name: address_details.get_optional_last_name(),\n                address_line_1: address_details.get_optional_line1(),\n                address_line_2: address_details.get_optional_line2(),\n                city: address_details.get_optional_city(),\n                state: address_details.get_optional_state(),\n                postal_code: address_details.get_optional_zip(),\n                country: address_details.get_optional_country(),\n                phone: address\n                    .phone\n                    .as_ref()\n                    .and_then(|phone| phone.number.clone()),\n                email: address.email.clone(),\n            }),",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__celero__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__celero__transformers.rs",
    "code": "use common_enums::{enums, Currency};\nuse common_utils::{id_type::CustomerId, pii::Email, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    address::Address as DomainAddress,\n    payment_method_data::PaymentMethodData,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        RouterData,\n    },\n    router_flow_types::{\n        payments::Capture,\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{PaymentsCaptureData, ResponseId},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts,\n    errors::{self},\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        get_unimplemented_payment_method_error_message, AddressDetailsData,\n        PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct CeleroRouterData<T> {\n    pub amount: MinorUnit, // CeleroCommerce expects integer cents\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for CeleroRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n// CeleroCommerce Search Request for sync operations - POST /api/transaction/search\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroSearchRequest {\n    transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsSyncRouterData> for CeleroSearchRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsSyncRouterData) -> Result<Self, Self::Error> {\n        let transaction_id = match &item.request.connector_transaction_id {\n            ResponseId::ConnectorTransactionId(id) => id.clone(),\n            _ => {\n                return Err(errors::ConnectorError::MissingConnectorTransactionID.into());\n            }\n        };\n        Ok(Self { transaction_id })\n    }\n}\n\nimpl TryFrom<&RefundSyncRouterData> for CeleroSearchRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &RefundSyncRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            transaction_id: item.request.get_connector_refund_id()?,\n        })\n    }\n}\n\n// CeleroCommerce Payment Request according to API specs\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroPaymentsRequest {\n    idempotency_key: String,\n    #[serde(rename = \"type\")]\n    transaction_type: TransactionType,\n    amount: MinorUnit, // CeleroCommerce expects integer cents\n    currency: Currency,\n    payment_method: CeleroPaymentMethod,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<CeleroAddress>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shipping_address: Option<CeleroAddress>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    create_vault_record: Option<bool>,\n    // CIT/MIT fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    card_on_file_indicator: Option<CardOnFileIndicator>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    initiated_by: Option<InitiatedBy>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    initial_transaction_id: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stored_credential_indicator: Option<StoredCredentialIndicator>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_method: Option<BillingMethod>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroAddress {\n    first_name: Option<Secret<String>>,\n    last_name: Option<Secret<String>>,\n    address_line_1: Option<Secret<String>>,\n    address_line_2: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n    postal_code: Option<Secret<String>>,\n    country: Option<common_enums::CountryAlpha2>,\n    phone: Option<Secret<String>>,\n    email: Option<Email>,\n}\n\nimpl TryFrom<&DomainAddress> for CeleroAddress {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(address: &DomainAddress) -> Result<Self, Self::Error> {\n        let address_details = address.address.as_ref();\n        match address_details {\n            Some(address_details) => Ok(Self {\n                first_name: address_details.get_optional_first_name(),\n                last_name: address_details.get_optional_last_name(),\n                address_line_1: address_details.get_optional_line1(),\n                address_line_2: address_details.get_optional_line2(),\n                city: address_details.get_optional_city(),\n                state: address_details.get_optional_state(),\n                postal_code: address_details.get_optional_zip(),\n                country: address_details.get_optional_country(),\n                phone: address\n                    .phone\n                    .as_ref()\n                    .and_then(|phone| phone.number.clone()),\n                email: address.email.clone(),\n            }),",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__celero__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use common_enums::{enums, Currency};\nuse common_utils::{id_type::CustomerId, pii::Email, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    address::Address as DomainAddress,\n    payment_method_data::PaymentMethodData,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        RouterData,\n    },\n    router_flow_types::{\n        payments::Capture,\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{PaymentsCaptureData, ResponseId},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts,\n    errors::{self},\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        get_unimplemented_payment_method_error_message, AddressDetailsData,\n        PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\n//TODO: Fill the struct with respective fields\npub struct CeleroRouterData<T> {\n    pub amount: MinorUnit, // CeleroCommerce expects integer cents\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for CeleroRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n// CeleroCommerce Search Request for sync operations - POST /api/transaction/search\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroSearchRequest {\n    transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsSyncRouterData> for CeleroSearchRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsSyncRouterData) -> Result<Self, Self::Error> {\n        let transaction_id = match &item.request.connector_transaction_id {\n            ResponseId::ConnectorTransactionId(id) => id.clone(),\n            _ => {\n                return Err(errors::ConnectorError::MissingConnectorTransactionID.into());\n            }\n        };\n        Ok(Self { transaction_id })\n    }\n}\n\nimpl TryFrom<&RefundSyncRouterData> for CeleroSearchRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &RefundSyncRouterData) -> Result<Self, Self::Error> {\n        Ok(Self {\n            transaction_id: item.request.get_connector_refund_id()?,\n        })\n    }\n}\n\n// CeleroCommerce Payment Request according to API specs\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroPaymentsRequest {\n    idempotency_key: String,\n    #[serde(rename = \"type\")]\n    transaction_type: TransactionType,\n    amount: MinorUnit, // CeleroCommerce expects integer cents\n    currency: Currency,\n    payment_method: CeleroPaymentMethod,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<CeleroAddress>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shipping_address: Option<CeleroAddress>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    create_vault_record: Option<bool>,\n    // CIT/MIT fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    card_on_file_indicator: Option<CardOnFileIndicator>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    initiated_by: Option<InitiatedBy>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    initial_transaction_id: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stored_credential_indicator: Option<StoredCredentialIndicator>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_method: Option<BillingMethod>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\npub struct CeleroAddress {\n    first_name: Option<Secret<String>>,\n    last_name: Option<Secret<String>>,\n    address_line_1: Option<Secret<String>>,\n    address_line_2: Option<Secret<String>>,\n    city: Option<String>,\n    state: Option<Secret<String>>,\n    postal_code: Option<Secret<String>>,\n    country: Option<common_enums::CountryAlpha2>,\n    phone: Option<Secret<String>>,\n    email: Option<Email>,\n}\n\nimpl TryFrom<&DomainAddress> for CeleroAddress {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(address: &DomainAddress) -> Result<Self, Self::Error> {\n        let address_details = address.address.as_ref();\n        match address_details {\n            Some(address_details) => Ok(Self {\n                first_name: address_details.get_optional_first_name(),\n                last_name: address_details.get_optional_last_name(),\n                address_line_1: address_details.get_optional_line1(),\n                address_line_2: address_details.get_optional_line2(),\n                city: address_details.get_optional_city(),\n                state: address_details.get_optional_state(),\n                postal_code: address_details.get_optional_zip(),\n                country: address_details.get_optional_country(),\n                phone: address\n                    .phone\n                    .as_ref()\n                    .and_then(|phone| phone.number.clone()),\n                email: address.email.clone(),\n            }),",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__celero__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments::PollConfig;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    pii::{self, Email, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, UpiData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::{Duration, OffsetDateTime};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, missing_field_err,\n        PaymentsAuthorizeRequestData, RouterData as OtherRouterData,\n    },\n};\n\npub struct RazorpayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for RazorpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub const VERSION: i32 = 1;\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderRequest {\n    pub amount: MinorUnit,\n    pub currency: enums::Currency,\n    pub receipt: String,\n    pub partial_payment: Option<bool>,\n    pub first_payment_min_amount: Option<MinorUnit>,\n    pub notes: Option<RazorpayNotes>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum RazorpayNotes {\n    Map(HashMap<String, String>),\n    EmptyMap(HashMap<String, String>),\n}\n\nimpl TryFrom<&RazorpayRouterData<&types::CreateOrderRouterData>> for RazorpayOrderRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &RazorpayRouterData<&types::CreateOrderRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let currency = item.router_data.request.currency;\n        let receipt = item.router_data.connector_request_reference_id.clone();\n\n        Ok(Self {\n            amount: item.amount,\n            currency,\n            receipt,\n            partial_payment: None,\n            first_payment_min_amount: None,\n            notes: None,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RazorpayMetaData {\n    pub order_id: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderResponse {\n    pub id: String,\n}\n\nimpl TryFrom<CreateOrderResponseRouterData<RazorpayOrderResponse>>\n    for types::CreateOrderRouterData\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: CreateOrderResponseRouterData<RazorpayOrderResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(PaymentsResponseData::PaymentsCreateOrderResponse {\n                order_id: item.response.id.clone(),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct UpiDetails {\n    flow: UpiFlow,\n    vpa: Secret<String, pii::UpiVpaMaskingStrategy>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum UpiFlow {\n    Collect,\n    Intent,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayPaymentsRequest {\n    amount: MinorUnit,\n    currency: enums::Currency,\n    order_id: String,\n    email: Email,\n    contact: Secret<String>,\n    method: RazorpayPaymentMethod,\n    upi: UpiDetails,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    ip: Option<Secret<String, IpAddress>>,",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments::PollConfig;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    pii::{self, Email, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, UpiData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::{Duration, OffsetDateTime};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, missing_field_err,\n        PaymentsAuthorizeRequestData, RouterData as OtherRouterData,\n    },\n};\n\npub struct RazorpayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for RazorpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub const VERSION: i32 = 1;\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderRequest {\n    pub amount: MinorUnit,\n    pub currency: enums::Currency,\n    pub receipt: String,\n    pub partial_payment: Option<bool>,\n    pub first_payment_min_amount: Option<MinorUnit>,\n    pub notes: Option<RazorpayNotes>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum RazorpayNotes {\n    Map(HashMap<String, String>),\n    EmptyMap(HashMap<String, String>),\n}\n\nimpl TryFrom<&RazorpayRouterData<&types::CreateOrderRouterData>> for RazorpayOrderRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &RazorpayRouterData<&types::CreateOrderRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let currency = item.router_data.request.currency;\n        let receipt = item.router_data.connector_request_reference_id.clone();\n\n        Ok(Self {\n            amount: item.amount,\n            currency,\n            receipt,\n            partial_payment: None,\n            first_payment_min_amount: None,\n            notes: None,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RazorpayMetaData {\n    pub order_id: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderResponse {\n    pub id: String,\n}\n\nimpl TryFrom<CreateOrderResponseRouterData<RazorpayOrderResponse>>\n    for types::CreateOrderRouterData\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: CreateOrderResponseRouterData<RazorpayOrderResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(PaymentsResponseData::PaymentsCreateOrderResponse {\n                order_id: item.response.id.clone(),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct UpiDetails {\n    flow: UpiFlow,\n    vpa: Secret<String, pii::UpiVpaMaskingStrategy>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum UpiFlow {\n    Collect,\n    Intent,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayPaymentsRequest {\n    amount: MinorUnit,\n    currency: enums::Currency,\n    order_id: String,\n    email: Email,\n    contact: Secret<String>,\n    method: RazorpayPaymentMethod,\n    upi: UpiDetails,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    ip: Option<Secret<String, IpAddress>>,",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments::PollConfig;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    pii::{self, Email, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, UpiData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::{Duration, OffsetDateTime};\n\nuse crate::{\n    types::{\n        CreateOrderResponseRouterData, PaymentsResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, missing_field_err,\n        PaymentsAuthorizeRequestData, RouterData as OtherRouterData,\n    },\n};\n\npub struct RazorpayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for RazorpayRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\npub const VERSION: i32 = 1;\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderRequest {\n    pub amount: MinorUnit,\n    pub currency: enums::Currency,\n    pub receipt: String,\n    pub partial_payment: Option<bool>,\n    pub first_payment_min_amount: Option<MinorUnit>,\n    pub notes: Option<RazorpayNotes>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum RazorpayNotes {\n    Map(HashMap<String, String>),\n    EmptyMap(HashMap<String, String>),\n}\n\nimpl TryFrom<&RazorpayRouterData<&types::CreateOrderRouterData>> for RazorpayOrderRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &RazorpayRouterData<&types::CreateOrderRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let currency = item.router_data.request.currency;\n        let receipt = item.router_data.connector_request_reference_id.clone();\n\n        Ok(Self {\n            amount: item.amount,\n            currency,\n            receipt,\n            partial_payment: None,\n            first_payment_min_amount: None,\n            notes: None,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RazorpayMetaData {\n    pub order_id: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayOrderResponse {\n    pub id: String,\n}\n\nimpl TryFrom<CreateOrderResponseRouterData<RazorpayOrderResponse>>\n    for types::CreateOrderRouterData\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: CreateOrderResponseRouterData<RazorpayOrderResponse>,\n    ) -> Result<Self, Self::Error> {\n        Ok(Self {\n            response: Ok(PaymentsResponseData::PaymentsCreateOrderResponse {\n                order_id: item.response.id.clone(),\n            }),\n            ..item.data\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct UpiDetails {\n    flow: UpiFlow,\n    vpa: Secret<String, pii::UpiVpaMaskingStrategy>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum UpiFlow {\n    Collect,\n    Intent,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct RazorpayPaymentsRequest {\n    amount: MinorUnit,\n    currency: enums::Currency,\n    order_id: String,\n    email: Email,\n    contact: Secret<String>,\n    method: RazorpayPaymentMethod,\n    upi: UpiDetails,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    ip: Option<Secret<String, IpAddress>>,",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__razorpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__masking__src__serde.rs",
    "code": "//! Serde-related.\n\npub use erased_serde::Serialize as ErasedSerialize;\npub use serde::{de, Deserialize, Serialize, Serializer};\nuse serde_json::{value::Serializer as JsonValueSerializer, Value};\n\nuse crate::{Secret, Strategy, StrongSecret, ZeroizableSecret};\n\n/// Marker trait for secret types which can be [`Serialize`]-d by [`serde`].\n///\n/// When the `serde` feature of this crate is enabled and types are marked with\n/// this trait, they receive a [`Serialize` impl] for `Secret<T>`.\n/// (NOTE: all types which impl `DeserializeOwned` receive a [`Deserialize`]\n/// impl)\n///\n/// This is done deliberately to prevent accidental exfiltration of secrets\n/// via `serde` serialization.\n#[cfg_attr(docsrs, cfg(feature = \"serde\"))]\npub trait SerializableSecret: Serialize {}\n// #[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n// pub trait NonSerializableSecret: Serialize {}\n\nimpl SerializableSecret for Value {}\nimpl SerializableSecret for u8 {}\nimpl SerializableSecret for u16 {}\nimpl SerializableSecret for i8 {}\nimpl SerializableSecret for i32 {}\nimpl SerializableSecret for i64 {}\nimpl SerializableSecret for url::Url {}\n\n#[cfg(feature = \"time\")]\nimpl SerializableSecret for time::Date {}\n\nimpl<T: SerializableSecret> SerializableSecret for &T {}\n\nimpl<'de, T, I> Deserialize<'de> for Secret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for Secret<T, I>\nwhere\n    T: SerializableSecret + Serialize + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\nimpl<'de, T, I> Deserialize<'de> for StrongSecret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized + ZeroizableSecret,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for StrongSecret<T, I>\nwhere\n    T: SerializableSecret + Serialize + ZeroizableSecret + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\n/// Masked serialization.\n///\n/// the default behaviour for secrets is to serialize in exposed format since the common use cases\n/// for storing the secret to database or sending it over the network requires the secret to be exposed\n/// This method allows to serialize the secret in masked format if needed for logs or other insecure exposures\npub fn masked_serialize<T: Serialize>(value: &T) -> Result<Value, serde_json::Error> {\n    value.serialize(PIISerializer {\n        inner: JsonValueSerializer,\n    })\n}\n\n/// Masked serialization.\n///\n/// Trait object for supporting serialization to Value while accounting for masking\n/// The usual Serde Serialize trait cannot be used as trait objects\n/// like &dyn Serialize or boxed trait objects like Box<dyn Serialize> because of Rust's \"object safety\" rules.\n/// In particular, the trait contains generic methods which cannot be made into a trait object.\n/// In this case we remove the generic for assuming the serialization to be of 2 types only raw json or masked json\npub trait ErasedMaskSerialize: ErasedSerialize {\n    /// Masked serialization.\n    fn masked_serialize(&self) -> Result<Value, serde_json::Error>;\n}\n\nimpl<T: Serialize + ErasedSerialize> ErasedMaskSerialize for T {\n    fn masked_serialize(&self) -> Result<Value, serde_json::Error> {\n        masked_serialize(self)\n    }\n}\n\nimpl Serialize for dyn ErasedMaskSerialize + '_ {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        erased_serde::serialize(self, serializer)\n    }\n}\n\nimpl Serialize for dyn ErasedMaskSerialize + '_ + Send {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        erased_serde::serialize(self, serializer)\n    }\n}\n\nuse pii_serializer::PIISerializer;\n\nmod pii_serializer {\n    use std::fmt::Display;\n\n    pub(super) fn pii_serialize<",
    "function_name": "deserialize",
    "file": "crates__masking__src__serde.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__masking__src__serde.rs",
    "code": "//! Serde-related.\n\npub use erased_serde::Serialize as ErasedSerialize;\npub use serde::{de, Deserialize, Serialize, Serializer};\nuse serde_json::{value::Serializer as JsonValueSerializer, Value};\n\nuse crate::{Secret, Strategy, StrongSecret, ZeroizableSecret};\n\n/// Marker trait for secret types which can be [`Serialize`]-d by [`serde`].\n///\n/// When the `serde` feature of this crate is enabled and types are marked with\n/// this trait, they receive a [`Serialize` impl] for `Secret<T>`.\n/// (NOTE: all types which impl `DeserializeOwned` receive a [`Deserialize`]\n/// impl)\n///\n/// This is done deliberately to prevent accidental exfiltration of secrets\n/// via `serde` serialization.\n#[cfg_attr(docsrs, cfg(feature = \"serde\"))]\npub trait SerializableSecret: Serialize {}\n// #[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n// pub trait NonSerializableSecret: Serialize {}\n\nimpl SerializableSecret for Value {}\nimpl SerializableSecret for u8 {}\nimpl SerializableSecret for u16 {}\nimpl SerializableSecret for i8 {}\nimpl SerializableSecret for i32 {}\nimpl SerializableSecret for i64 {}\nimpl SerializableSecret for url::Url {}\n\n#[cfg(feature = \"time\")]\nimpl SerializableSecret for time::Date {}\n\nimpl<T: SerializableSecret> SerializableSecret for &T {}\n\nimpl<'de, T, I> Deserialize<'de> for Secret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for Secret<T, I>\nwhere\n    T: SerializableSecret + Serialize + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\nimpl<'de, T, I> Deserialize<'de> for StrongSecret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized + ZeroizableSecret,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for StrongSecret<T, I>\nwhere\n    T: SerializableSecret + Serialize + ZeroizableSecret + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\n/// Masked serialization.\n///\n/// the default behaviour for secrets is to serialize in exposed format since the common use cases\n/// for storing the secret to database or sending it over the network requires the secret to be exposed\n/// This method allows to serialize the secret in masked format if needed for logs or other insecure exposures\npub fn masked_serialize<T: Serialize>(value: &T) -> Result<Value, serde_json::Error> {\n    value.serialize(PIISerializer {\n        inner: JsonValueSerializer,\n    })\n}\n\n/// Masked serialization.\n///\n/// Trait object for supporting serialization to Value while accounting for masking\n/// The usual Serde Serialize trait cannot be used as trait objects\n/// like &dyn Serialize or boxed trait objects like Box<dyn Serialize> because of Rust's \"object safety\" rules.\n/// In particular, the trait contains generic methods which cannot be made into a trait object.\n/// In this case we remove the generic for assuming the serialization to be of 2 types only raw json or masked json\npub trait ErasedMaskSerialize: ErasedSerialize {\n    /// Masked serialization.\n    fn masked_serialize(&self) -> Result<Value, serde_json::Error>;\n}\n\nimpl<T: Serialize + ErasedSerialize> ErasedMaskSerialize for T {\n    fn masked_serialize(&self) -> Result<Value, serde_json::Error> {\n        masked_serialize(self)\n    }\n}\n\nimpl Serialize for dyn ErasedMaskSerialize + '_ {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        erased_serde::serialize(self, serializer)\n    }\n}\n\nimpl Serialize for dyn ErasedMaskSerialize + '_ + Send {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        erased_serde::serialize(self, serializer)\n    }\n}\n\nuse pii_serializer::PIISerializer;\n\nmod pii_serializer {\n    use std::fmt::Display;\n\n    pub(super) fn pii_serialize<",
    "function_name": "deserialize",
    "file": "crates__masking__src__serde.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for deserialize",
    "code": "//! Serde-related.\n\npub use erased_serde::Serialize as ErasedSerialize;\npub use serde::{de, Deserialize, Serialize, Serializer};\nuse serde_json::{value::Serializer as JsonValueSerializer, Value};\n\nuse crate::{Secret, Strategy, StrongSecret, ZeroizableSecret};\n\n/// Marker trait for secret types which can be [`Serialize`]-d by [`serde`].\n///\n/// When the `serde` feature of this crate is enabled and types are marked with\n/// this trait, they receive a [`Serialize` impl] for `Secret<T>`.\n/// (NOTE: all types which impl `DeserializeOwned` receive a [`Deserialize`]\n/// impl)\n///\n/// This is done deliberately to prevent accidental exfiltration of secrets\n/// via `serde` serialization.\n#[cfg_attr(docsrs, cfg(feature = \"serde\"))]\npub trait SerializableSecret: Serialize {}\n// #[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\n// pub trait NonSerializableSecret: Serialize {}\n\nimpl SerializableSecret for Value {}\nimpl SerializableSecret for u8 {}\nimpl SerializableSecret for u16 {}\nimpl SerializableSecret for i8 {}\nimpl SerializableSecret for i32 {}\nimpl SerializableSecret for i64 {}\nimpl SerializableSecret for url::Url {}\n\n#[cfg(feature = \"time\")]\nimpl SerializableSecret for time::Date {}\n\nimpl<T: SerializableSecret> SerializableSecret for &T {}\n\nimpl<'de, T, I> Deserialize<'de> for Secret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for Secret<T, I>\nwhere\n    T: SerializableSecret + Serialize + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\nimpl<'de, T, I> Deserialize<'de> for StrongSecret<T, I>\nwhere\n    T: Clone + de::DeserializeOwned + Sized + ZeroizableSecret,\n    I: Strategy<T>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Self::new)\n    }\n}\n\nimpl<T, I> Serialize for StrongSecret<T, I>\nwhere\n    T: SerializableSecret + Serialize + ZeroizableSecret + Sized,\n    I: Strategy<T>,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        pii_serializer::pii_serialize(self, serializer)\n    }\n}\n\n/// Masked serialization.\n///\n/// the default behaviour for secrets is to serialize in exposed format since the common use cases\n/// for storing the secret to database or sending it over the network requires the secret to be exposed\n/// This method allows to serialize the secret in masked format if needed for logs or other insecure exposures\npub fn masked_serialize<T: Serialize>(value: &T) -> Result<Value, serde_json::Error> {\n    value.serialize(PIISerializer {\n        inner: JsonValueSerializer,\n    })\n}\n\n/// Masked serialization.\n///\n/// Trait object for supporting serialization to Value while accounting for masking\n/// The usual Serde Serialize trait cannot be used as trait objects\n/// like &dyn Serialize or boxed trait objects like Box<dyn Serialize> because of Rust's \"object safety\" rules.\n/// In particular, the trait contains generic methods which cannot be made into a trait object.\n/// In this case we remove the generic for assuming the serialization to be of 2 types only raw json or masked json\npub trait ErasedMaskSerialize: ErasedSerialize {\n    /// Masked serialization.\n    fn masked_serialize(&self) -> Result<Value, serde_json::Error>;\n}\n\nimpl<T: Serialize + ErasedSerialize> ErasedMaskSerialize for T {\n    fn masked_serialize(&self) -> Result<Value, serde_json::Error> {\n        masked_serialize(self)\n    }\n}\n\nimpl Serialize for dyn ErasedMaskSerialize + '_ {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        erased_serde::serialize(self, serializer)\n    }\n}\n\nimpl Serialize for dyn ErasedMaskSerialize + '_ + Send {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        erased_serde::serialize(self, serializer)\n    }\n}\n\nuse pii_serializer::PIISerializer;\n\nmod pii_serializer {\n    use std::fmt::Display;\n\n    pub(super) fn pii_serialize<",
    "function_name": "deserialize",
    "file": "crates__masking__src__serde.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::*,\n    router_request_types::*,\n    router_response_types::*,\n    types::*,\n};\nuse hyperswitch_interfaces::{\n    api::{ConnectorCommonExt, ConnectorIntegration, *},\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::*,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, Maskable};\nuse transformers::*;\n\nuse crate::{\n    connectors::worldpaymodular::transformers::request::{\n        WorldpaymodularPartialRefundRequest, WorldpaymodularPaymentsRequest,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, get_header_key_value, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Worldpaymodular {}\n\nimpl Worldpaymodular {\n    pub const fn new() -> &'static Self {\n        &Self {}\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpaymodular\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut api_key);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Worldpaymodular {\n    fn id(&self) -> &'static str {\n        \"worldpaymodular\"\n    }\n\n    fn get_currency_unit(&self) -> CurrencyUnit {\n        CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/vnd.worldpay.payments-v7+json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.worldpaymodular.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = WorldpaymodularAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response = if !res.response.is_empty() {\n            res.response\n                .parse_struct(\"WorldpaymodularErrorResponse\")\n                .change_context(ConnectorError::ResponseDeserializationFailed)?\n        } else {\n            WorldpaymodularErrorResponse::default(res.status_code)\n        };\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_name,\n            message: response.message,\n            reason: response.validation_errors.map(|e| e.to_string()),\n            attempt_status: Some(enums::AttemptStatus::Failure),\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n\nimpl ConnectorValidation for Worldpaymodular {\n    fn validate_mandate_payment(",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::*,\n    router_request_types::*,\n    router_response_types::*,\n    types::*,\n};\nuse hyperswitch_interfaces::{\n    api::{ConnectorCommonExt, ConnectorIntegration, *},\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::*,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, Maskable};\nuse transformers::*;\n\nuse crate::{\n    connectors::worldpaymodular::transformers::request::{\n        WorldpaymodularPartialRefundRequest, WorldpaymodularPaymentsRequest,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, get_header_key_value, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Worldpaymodular {}\n\nimpl Worldpaymodular {\n    pub const fn new() -> &'static Self {\n        &Self {}\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpaymodular\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut api_key);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Worldpaymodular {\n    fn id(&self) -> &'static str {\n        \"worldpaymodular\"\n    }\n\n    fn get_currency_unit(&self) -> CurrencyUnit {\n        CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/vnd.worldpay.payments-v7+json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.worldpaymodular.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = WorldpaymodularAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response = if !res.response.is_empty() {\n            res.response\n                .parse_struct(\"WorldpaymodularErrorResponse\")\n                .change_context(ConnectorError::ResponseDeserializationFailed)?\n        } else {\n            WorldpaymodularErrorResponse::default(res.status_code)\n        };\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_name,\n            message: response.message,\n            reason: response.validation_errors.map(|e| e.to_string()),\n            attempt_status: Some(enums::AttemptStatus::Failure),\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n\nimpl ConnectorValidation for Worldpaymodular {\n    fn validate_mandate_payment(",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::*,\n    router_request_types::*,\n    router_response_types::*,\n    types::*,\n};\nuse hyperswitch_interfaces::{\n    api::{ConnectorCommonExt, ConnectorIntegration, *},\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::*,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, Maskable};\nuse transformers::*;\n\nuse crate::{\n    connectors::worldpaymodular::transformers::request::{\n        WorldpaymodularPartialRefundRequest, WorldpaymodularPaymentsRequest,\n    },\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, get_header_key_value, RefundsRequestData as _},\n};\n\n#[derive(Clone)]\npub struct Worldpaymodular {}\n\nimpl Worldpaymodular {\n    pub const fn new() -> &'static Self {\n        &Self {}\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpaymodular\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut api_key);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Worldpaymodular {\n    fn id(&self) -> &'static str {\n        \"worldpaymodular\"\n    }\n\n    fn get_currency_unit(&self) -> CurrencyUnit {\n        CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/vnd.worldpay.payments-v7+json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.worldpaymodular.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = WorldpaymodularAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response = if !res.response.is_empty() {\n            res.response\n                .parse_struct(\"WorldpaymodularErrorResponse\")\n                .change_context(ConnectorError::ResponseDeserializationFailed)?\n        } else {\n            WorldpaymodularErrorResponse::default(res.status_code)\n        };\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.error_name,\n            message: response.message,\n            reason: response.validation_errors.map(|e| e.to_string()),\n            attempt_status: Some(enums::AttemptStatus::Failure),\n            connector_transaction_id: None,\n            connector_response_reference_id: None,\n            network_decline_code: None,\n            network_advice_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        })\n    }\n}\n\nimpl ConnectorValidation for Worldpaymodular {\n    fn validate_mandate_payment(",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::types::MinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{RefundsData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub struct BamboraapacRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for BamboraapacRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BamboraapacMeta {\n    pub authorize_id: String,\n}\n\n// request body in soap format\npub fn get_payment_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<Vec<u8>, Error> {\n    let transaction_data = get_transaction_body(req)?;\n    let body = format!(\n        r#\"\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n            xmlns:dts=\"http://www.ippayments.com.au/interface/api/dts\">\n                <soapenv:Body>\n                    <dts:SubmitSinglePayment>\n                        <dts:trnXML>\n                            <![CDATA[\n                                {transaction_data}\n                            ]]>\n                        </dts:trnXML>\n                    </dts:SubmitSinglePayment>\n                </soapenv:Body>\n            </soapenv:Envelope>\n        \"#,\n    );\n\n    Ok(body.as_bytes().to_vec())\n}\n\nfn get_transaction_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<String, Error> {\n    let auth_details = BamboraapacAuthType::try_from(&req.router_data.connector_auth_type)?;\n    let transaction_type = get_transaction_type(req.router_data.request.capture_method)?;\n    let card_info = get_card_data(req.router_data)?;\n    let transaction_data = format!(\n        r#\"\n        <Transaction>\n            <CustRef>{}</CustRef>\n            <Amount>{}</Amount>\n            <TrnType>{}</TrnType>\n            <AccountNumber>{}</AccountNumber>\n            {}\n            <Security>\n                    <UserName>{}</UserName>\n                    <Password>{}</Password>\n            </Security>\n        </Transaction>\n    \"#,\n        req.router_data.connector_request_reference_id.to_owned(),\n        req.amount,\n        transaction_type,\n        auth_details.account_number.peek(),\n        card_info,\n        auth_details.username.peek(),\n        auth_details.password.peek(),\n    );\n\n    Ok(transaction_data)\n}\n\nfn get_card_data(req: &types::PaymentsAuthorizeRouterData) -> Result<String, Error> {\n    let card_data = match &req.request.payment_method_data {\n        PaymentMethodData::Card(card) => {\n            if req.is_three_ds() {\n                Err(errors::ConnectorError::NotSupported {\n                    message: \"Cards 3DS\".to_string(),\n                    connector: \"Bamboraapac\",\n                })?\n            }\n            let card_holder_name = req.get_billing_full_name()?;\n\n            if req.request.setup_future_usage == Some(enums::FutureUsage::OffSession) {\n                format!(\n                    r#\"\n                    <CreditCard Registered=\"False\">\n                        <TokeniseAlgorithmID>2</TokeniseAlgorithmID>\n                        <CardNumber>{}</CardNumber>\n                        <ExpM>{}</ExpM>\n                        <ExpY>{}</ExpY>\n                        <CVN>{}</CVN>\n                        <CardHolderName>{}</CardHolderName>\n                    </CreditCard>\n                \"#,\n                    card.card_number.get_card_no(),\n                    card.card_exp_month.peek(),\n                    card.get_expiry_year_4_digit().peek(),\n                    card.card_cvc.peek(),\n                    card_holder_name.peek(),\n                )\n            } else {\n                format!(\n                    r#\"\n                    <CreditCard Registered=\"False\">\n                        <CardNumber>{}</CardNumber>\n                        <ExpM>{}</ExpM>\n                        <ExpY>{}</ExpY>",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::types::MinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{RefundsData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub struct BamboraapacRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for BamboraapacRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BamboraapacMeta {\n    pub authorize_id: String,\n}\n\n// request body in soap format\npub fn get_payment_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<Vec<u8>, Error> {\n    let transaction_data = get_transaction_body(req)?;\n    let body = format!(\n        r#\"\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n            xmlns:dts=\"http://www.ippayments.com.au/interface/api/dts\">\n                <soapenv:Body>\n                    <dts:SubmitSinglePayment>\n                        <dts:trnXML>\n                            <![CDATA[\n                                {transaction_data}\n                            ]]>\n                        </dts:trnXML>\n                    </dts:SubmitSinglePayment>\n                </soapenv:Body>\n            </soapenv:Envelope>\n        \"#,\n    );\n\n    Ok(body.as_bytes().to_vec())\n}\n\nfn get_transaction_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<String, Error> {\n    let auth_details = BamboraapacAuthType::try_from(&req.router_data.connector_auth_type)?;\n    let transaction_type = get_transaction_type(req.router_data.request.capture_method)?;\n    let card_info = get_card_data(req.router_data)?;\n    let transaction_data = format!(\n        r#\"\n        <Transaction>\n            <CustRef>{}</CustRef>\n            <Amount>{}</Amount>\n            <TrnType>{}</TrnType>\n            <AccountNumber>{}</AccountNumber>\n            {}\n            <Security>\n                    <UserName>{}</UserName>\n                    <Password>{}</Password>\n            </Security>\n        </Transaction>\n    \"#,\n        req.router_data.connector_request_reference_id.to_owned(),\n        req.amount,\n        transaction_type,\n        auth_details.account_number.peek(),\n        card_info,\n        auth_details.username.peek(),\n        auth_details.password.peek(),\n    );\n\n    Ok(transaction_data)\n}\n\nfn get_card_data(req: &types::PaymentsAuthorizeRouterData) -> Result<String, Error> {\n    let card_data = match &req.request.payment_method_data {\n        PaymentMethodData::Card(card) => {\n            if req.is_three_ds() {\n                Err(errors::ConnectorError::NotSupported {\n                    message: \"Cards 3DS\".to_string(),\n                    connector: \"Bamboraapac\",\n                })?\n            }\n            let card_holder_name = req.get_billing_full_name()?;\n\n            if req.request.setup_future_usage == Some(enums::FutureUsage::OffSession) {\n                format!(\n                    r#\"\n                    <CreditCard Registered=\"False\">\n                        <TokeniseAlgorithmID>2</TokeniseAlgorithmID>\n                        <CardNumber>{}</CardNumber>\n                        <ExpM>{}</ExpM>\n                        <ExpY>{}</ExpY>\n                        <CVN>{}</CVN>\n                        <CardHolderName>{}</CardHolderName>\n                    </CreditCard>\n                \"#,\n                    card.card_number.get_card_no(),\n                    card.card_exp_month.peek(),\n                    card.get_expiry_year_4_digit().peek(),\n                    card.card_cvc.peek(),\n                    card_holder_name.peek(),\n                )\n            } else {\n                format!(\n                    r#\"\n                    <CreditCard Registered=\"False\">\n                        <CardNumber>{}</CardNumber>\n                        <ExpM>{}</ExpM>\n                        <ExpY>{}</ExpY>",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use common_enums::enums;\nuse common_utils::types::MinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{RefundsData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, ResponseRouterData,\n    },\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\npub struct BamboraapacRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for BamboraapacRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BamboraapacMeta {\n    pub authorize_id: String,\n}\n\n// request body in soap format\npub fn get_payment_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<Vec<u8>, Error> {\n    let transaction_data = get_transaction_body(req)?;\n    let body = format!(\n        r#\"\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\n            xmlns:dts=\"http://www.ippayments.com.au/interface/api/dts\">\n                <soapenv:Body>\n                    <dts:SubmitSinglePayment>\n                        <dts:trnXML>\n                            <![CDATA[\n                                {transaction_data}\n                            ]]>\n                        </dts:trnXML>\n                    </dts:SubmitSinglePayment>\n                </soapenv:Body>\n            </soapenv:Envelope>\n        \"#,\n    );\n\n    Ok(body.as_bytes().to_vec())\n}\n\nfn get_transaction_body(\n    req: &BamboraapacRouterData<&types::PaymentsAuthorizeRouterData>,\n) -> Result<String, Error> {\n    let auth_details = BamboraapacAuthType::try_from(&req.router_data.connector_auth_type)?;\n    let transaction_type = get_transaction_type(req.router_data.request.capture_method)?;\n    let card_info = get_card_data(req.router_data)?;\n    let transaction_data = format!(\n        r#\"\n        <Transaction>\n            <CustRef>{}</CustRef>\n            <Amount>{}</Amount>\n            <TrnType>{}</TrnType>\n            <AccountNumber>{}</AccountNumber>\n            {}\n            <Security>\n                    <UserName>{}</UserName>\n                    <Password>{}</Password>\n            </Security>\n        </Transaction>\n    \"#,\n        req.router_data.connector_request_reference_id.to_owned(),\n        req.amount,\n        transaction_type,\n        auth_details.account_number.peek(),\n        card_info,\n        auth_details.username.peek(),\n        auth_details.password.peek(),\n    );\n\n    Ok(transaction_data)\n}\n\nfn get_card_data(req: &types::PaymentsAuthorizeRouterData) -> Result<String, Error> {\n    let card_data = match &req.request.payment_method_data {\n        PaymentMethodData::Card(card) => {\n            if req.is_three_ds() {\n                Err(errors::ConnectorError::NotSupported {\n                    message: \"Cards 3DS\".to_string(),\n                    connector: \"Bamboraapac\",\n                })?\n            }\n            let card_holder_name = req.get_billing_full_name()?;\n\n            if req.request.setup_future_usage == Some(enums::FutureUsage::OffSession) {\n                format!(\n                    r#\"\n                    <CreditCard Registered=\"False\">\n                        <TokeniseAlgorithmID>2</TokeniseAlgorithmID>\n                        <CardNumber>{}</CardNumber>\n                        <ExpM>{}</ExpM>\n                        <ExpY>{}</ExpY>\n                        <CVN>{}</CVN>\n                        <CardHolderName>{}</CardHolderName>\n                    </CreditCard>\n                \"#,\n                    card.card_number.get_card_no(),\n                    card.card_exp_month.peek(),\n                    card.get_expiry_year_4_digit().peek(),\n                    card.card_cvc.peek(),\n                    card_holder_name.peek(),\n                )\n            } else {\n                format!(\n                    r#\"\n                    <CreditCard Registered=\"False\">\n                        <CardNumber>{}</CardNumber>\n                        <ExpM>{}</ExpM>\n                        <ExpY>{}</ExpY>",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, PSync, PaymentMethodToken, PostCaptureVoid, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Dsync, Evidence, Fetch, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DisputeSyncData,\n        FetchDisputesRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCancelPostCaptureData, PaymentsCaptureData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, RetrieveFileRequestData,\n        SetupMandateRequestData, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DisputeSyncResponse, FetchDisputesResponse,\n        PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, RetrieveFileResponse,\n        SubmitEvidenceResponse, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n        UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, Dispute, DisputeSync, FetchDisputes, SubmitEvidence},\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as worldpayvantiv;\n\nuse crate::{\n    constants::headers,\n    types::{\n        AcceptDisputeRouterData, DisputeSyncRouterData, FetchDisputeRouterData, ResponseRouterData,\n        RetrieveFileRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    utils as connector_utils,\n};\n\n#[derive(Clone)]\npub struct Worldpayvantiv {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Worldpayvantiv {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Worldpayvantiv {}\nimpl api::PaymentSession for Worldpayvantiv {}\nimpl api::ConnectorAccessToken for Worldpayvantiv {}\nimpl api::MandateSetup for Worldpayvantiv {}\nimpl api::PaymentAuthorize for Worldpayvantiv {}\nimpl api::PaymentSync for Worldpayvantiv {}\nimpl api::PaymentCapture for Worldpayvantiv {}\nimpl api::PaymentVoid for Worldpayvantiv {}\nimpl api::Refund for Worldpayvantiv {}\nimpl api::RefundExecute for Worldpayvantiv {}\nimpl api::RefundSync for Worldpayvantiv {}\nimpl api::PaymentToken for Worldpayvantiv {}\nimpl api::PaymentPostCaptureVoid for Worldpayvantiv {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Worldpayvantiv\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpayvantiv\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Worldpayvantiv {\n    fn id(&self) -> &'static str {\n        \"worldpayvantiv\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"text/xml\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.worldpayvantiv.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, PSync, PaymentMethodToken, PostCaptureVoid, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Dsync, Evidence, Fetch, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DisputeSyncData,\n        FetchDisputesRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCancelPostCaptureData, PaymentsCaptureData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, RetrieveFileRequestData,\n        SetupMandateRequestData, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DisputeSyncResponse, FetchDisputesResponse,\n        PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, RetrieveFileResponse,\n        SubmitEvidenceResponse, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n        UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, Dispute, DisputeSync, FetchDisputes, SubmitEvidence},\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as worldpayvantiv;\n\nuse crate::{\n    constants::headers,\n    types::{\n        AcceptDisputeRouterData, DisputeSyncRouterData, FetchDisputeRouterData, ResponseRouterData,\n        RetrieveFileRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    utils as connector_utils,\n};\n\n#[derive(Clone)]\npub struct Worldpayvantiv {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Worldpayvantiv {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Worldpayvantiv {}\nimpl api::PaymentSession for Worldpayvantiv {}\nimpl api::ConnectorAccessToken for Worldpayvantiv {}\nimpl api::MandateSetup for Worldpayvantiv {}\nimpl api::PaymentAuthorize for Worldpayvantiv {}\nimpl api::PaymentSync for Worldpayvantiv {}\nimpl api::PaymentCapture for Worldpayvantiv {}\nimpl api::PaymentVoid for Worldpayvantiv {}\nimpl api::Refund for Worldpayvantiv {}\nimpl api::RefundExecute for Worldpayvantiv {}\nimpl api::RefundSync for Worldpayvantiv {}\nimpl api::PaymentToken for Worldpayvantiv {}\nimpl api::PaymentPostCaptureVoid for Worldpayvantiv {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Worldpayvantiv\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpayvantiv\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Worldpayvantiv {\n    fn id(&self) -> &'static str {\n        \"worldpayvantiv\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"text/xml\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.worldpayvantiv.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, PSync, PaymentMethodToken, PostCaptureVoid, Session, SetupMandate,\n            Void,\n        },\n        refunds::{Execute, RSync},\n        Accept, Dsync, Evidence, Fetch, Retrieve, Upload,\n    },\n    router_request_types::{\n        AcceptDisputeRequestData, AccessTokenRequestData, DisputeSyncData,\n        FetchDisputesRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCancelPostCaptureData, PaymentsCaptureData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, RetrieveFileRequestData,\n        SetupMandateRequestData, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        AcceptDisputeResponse, ConnectorInfo, DisputeSyncResponse, FetchDisputesResponse,\n        PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, RetrieveFileResponse,\n        SubmitEvidenceResponse, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n        UploadFileResponse,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::{AcceptDispute, Dispute, DisputeSync, FetchDisputes, SubmitEvidence},\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as worldpayvantiv;\n\nuse crate::{\n    constants::headers,\n    types::{\n        AcceptDisputeRouterData, DisputeSyncRouterData, FetchDisputeRouterData, ResponseRouterData,\n        RetrieveFileRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    utils as connector_utils,\n};\n\n#[derive(Clone)]\npub struct Worldpayvantiv {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Worldpayvantiv {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Worldpayvantiv {}\nimpl api::PaymentSession for Worldpayvantiv {}\nimpl api::ConnectorAccessToken for Worldpayvantiv {}\nimpl api::MandateSetup for Worldpayvantiv {}\nimpl api::PaymentAuthorize for Worldpayvantiv {}\nimpl api::PaymentSync for Worldpayvantiv {}\nimpl api::PaymentCapture for Worldpayvantiv {}\nimpl api::PaymentVoid for Worldpayvantiv {}\nimpl api::Refund for Worldpayvantiv {}\nimpl api::RefundExecute for Worldpayvantiv {}\nimpl api::RefundSync for Worldpayvantiv {}\nimpl api::PaymentToken for Worldpayvantiv {}\nimpl api::PaymentPostCaptureVoid for Worldpayvantiv {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Worldpayvantiv\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpayvantiv\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Worldpayvantiv {\n    fn id(&self) -> &'static str {\n        \"worldpayvantiv\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"text/xml\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.worldpayvantiv.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpayvantiv.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Flexiti {}\nimpl api::PaymentSession for Flexiti {}\nimpl api::ConnectorAccessToken for Flexiti {}\nimpl api::MandateSetup for Flexiti {}\nimpl api::PaymentAuthorize for Flexiti {}\nimpl api::PaymentSync for Flexiti {}\nimpl api::PaymentCapture for Flexiti {}\nimpl api::PaymentVoid for Flexiti {}\nimpl api::Refund for Flexiti {}\nimpl api::RefundExecute for Flexiti {}\nimpl api::RefundSync for Flexiti {}\nimpl api::PaymentToken for Flexiti {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Flexiti\n{\n    // Not Implemented (R)\n}\n\nimpl Flexiti {\n    fn get_default_header() -> (String, masking::Maskable<String>) {\n        (\n            \"x-reference-id\".to_string(),\n            Uuid::new_v4().to_string().into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Flexiti\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let mut header = vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into(),\n        )];\n        header.push(Self::get_default_header());\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Flexiti {\n    fn id(&self) -> &'static str {\n        \"flexiti\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.flexiti.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Flexiti {}\nimpl api::PaymentSession for Flexiti {}\nimpl api::ConnectorAccessToken for Flexiti {}\nimpl api::MandateSetup for Flexiti {}\nimpl api::PaymentAuthorize for Flexiti {}\nimpl api::PaymentSync for Flexiti {}\nimpl api::PaymentCapture for Flexiti {}\nimpl api::PaymentVoid for Flexiti {}\nimpl api::Refund for Flexiti {}\nimpl api::RefundExecute for Flexiti {}\nimpl api::RefundSync for Flexiti {}\nimpl api::PaymentToken for Flexiti {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Flexiti\n{\n    // Not Implemented (R)\n}\n\nimpl Flexiti {\n    fn get_default_header() -> (String, masking::Maskable<String>) {\n        (\n            \"x-reference-id\".to_string(),\n            Uuid::new_v4().to_string().into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Flexiti\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let mut header = vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into(),\n        )];\n        header.push(Self::get_default_header());\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Flexiti {\n    fn id(&self) -> &'static str {\n        \"flexiti\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.flexiti.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as flexiti;\nuse uuid::Uuid;\n\nuse crate::{\n    capture_method_not_supported,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils,\n};\n\n#[derive(Clone)]\npub struct Flexiti {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Flexiti {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Flexiti {}\nimpl api::PaymentSession for Flexiti {}\nimpl api::ConnectorAccessToken for Flexiti {}\nimpl api::MandateSetup for Flexiti {}\nimpl api::PaymentAuthorize for Flexiti {}\nimpl api::PaymentSync for Flexiti {}\nimpl api::PaymentCapture for Flexiti {}\nimpl api::PaymentVoid for Flexiti {}\nimpl api::Refund for Flexiti {}\nimpl api::RefundExecute for Flexiti {}\nimpl api::RefundSync for Flexiti {}\nimpl api::PaymentToken for Flexiti {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Flexiti\n{\n    // Not Implemented (R)\n}\n\nimpl Flexiti {\n    fn get_default_header() -> (String, masking::Maskable<String>) {\n        (\n            \"x-reference-id\".to_string(),\n            Uuid::new_v4().to_string().into(),\n        )\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Flexiti\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let mut header = vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into(),\n        )];\n        header.push(Self::get_default_header());\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Flexiti {\n    fn id(&self) -> &'static str {\n        \"flexiti\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.flexiti.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__flexiti.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payme.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateOrder, InitPayment, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentsPreProcessing,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsPreProcessingType, PaymentsSyncType, PaymentsVoidType, RefundExecuteType,\n        RefundSyncType, Response, TokenizationType,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Secret};\nuse transformers as payme;\n\nuse crate::{\n    types::ResponseRouterData,\n    utils::{self, ForeignTryFrom, PaymentsPreProcessingRequestData},\n};\n\n#[derive(Clone)]\npub struct Payme {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n    apple_pay_google_pay_amount_converter:\n        &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_webhooks: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Payme {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            apple_pay_google_pay_amount_converter: &StringMajorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\nimpl api::Payment for Payme {}\nimpl api::PaymentsCreateOrder for Payme {}\nimpl api::PaymentSession for Payme {}\nimpl api::PaymentsCompleteAuthorize for Payme {}\nimpl api::ConnectorAccessToken for Payme {}\nimpl api::MandateSetup for Payme {}\nimpl api::PaymentAuthorize for Payme {}\nimpl api::PaymentSync for Payme {}\nimpl api::PaymentCapture for Payme {}\nimpl api::PaymentVoid for Payme {}\nimpl api::Refund for Payme {}\nimpl api::RefundExecute for Payme {}\nimpl api::RefundSync for Payme {}\nimpl api::PaymentToken for Payme {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payme\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            crate::constants::headers::CONTENT_TYPE.to_string(),\n            Self::get_content_type(self).to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Payme {\n    fn id(&self) -> &'static str {\n        \"payme\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.payme.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            payme::PaymeErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"PaymeErrorResponse\");",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__payme.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payme.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateOrder, InitPayment, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentsPreProcessing,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsPreProcessingType, PaymentsSyncType, PaymentsVoidType, RefundExecuteType,\n        RefundSyncType, Response, TokenizationType,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Secret};\nuse transformers as payme;\n\nuse crate::{\n    types::ResponseRouterData,\n    utils::{self, ForeignTryFrom, PaymentsPreProcessingRequestData},\n};\n\n#[derive(Clone)]\npub struct Payme {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n    apple_pay_google_pay_amount_converter:\n        &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_webhooks: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Payme {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            apple_pay_google_pay_amount_converter: &StringMajorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\nimpl api::Payment for Payme {}\nimpl api::PaymentsCreateOrder for Payme {}\nimpl api::PaymentSession for Payme {}\nimpl api::PaymentsCompleteAuthorize for Payme {}\nimpl api::ConnectorAccessToken for Payme {}\nimpl api::MandateSetup for Payme {}\nimpl api::PaymentAuthorize for Payme {}\nimpl api::PaymentSync for Payme {}\nimpl api::PaymentCapture for Payme {}\nimpl api::PaymentVoid for Payme {}\nimpl api::Refund for Payme {}\nimpl api::RefundExecute for Payme {}\nimpl api::RefundSync for Payme {}\nimpl api::PaymentToken for Payme {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payme\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            crate::constants::headers::CONTENT_TYPE.to_string(),\n            Self::get_content_type(self).to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Payme {\n    fn id(&self) -> &'static str {\n        \"payme\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.payme.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            payme::PaymeErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"PaymeErrorResponse\");",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__payme.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateOrder, InitPayment, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, CreateOrderRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentsPreProcessing,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsPreProcessingType, PaymentsSyncType, PaymentsVoidType, RefundExecuteType,\n        RefundSyncType, Response, TokenizationType,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Secret};\nuse transformers as payme;\n\nuse crate::{\n    types::ResponseRouterData,\n    utils::{self, ForeignTryFrom, PaymentsPreProcessingRequestData},\n};\n\n#[derive(Clone)]\npub struct Payme {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n    apple_pay_google_pay_amount_converter:\n        &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_webhooks: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Payme {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            apple_pay_google_pay_amount_converter: &StringMajorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\nimpl api::Payment for Payme {}\nimpl api::PaymentsCreateOrder for Payme {}\nimpl api::PaymentSession for Payme {}\nimpl api::PaymentsCompleteAuthorize for Payme {}\nimpl api::ConnectorAccessToken for Payme {}\nimpl api::MandateSetup for Payme {}\nimpl api::PaymentAuthorize for Payme {}\nimpl api::PaymentSync for Payme {}\nimpl api::PaymentCapture for Payme {}\nimpl api::PaymentVoid for Payme {}\nimpl api::Refund for Payme {}\nimpl api::RefundExecute for Payme {}\nimpl api::RefundSync for Payme {}\nimpl api::PaymentToken for Payme {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payme\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            crate::constants::headers::CONTENT_TYPE.to_string(),\n            Self::get_content_type(self).to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Payme {\n    fn id(&self) -> &'static str {\n        \"payme\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.payme.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: Result<\n            payme::PaymeErrorResponse,\n            Report<common_utils::errors::ParsingError>,\n        > = res.response.parse_struct(\"PaymeErrorResponse\");",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__payme.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs",
    "code": "use common_enums::{enums, CountryAlpha2, Currency};\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\npub struct AffirmRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for AffirmRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmPaymentsRequest {\n    pub merchant: Merchant,\n    pub items: Vec<Item>,\n    pub shipping: Option<Shipping>,\n    pub billing: Option<Billing>,\n    pub total: MinorUnit,\n    pub currency: Currency,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmCompleteAuthorizeRequest {\n    pub order_id: Option<String>,\n    pub reference_id: Option<String>,\n    pub transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsCompleteAuthorizeRouterData> for AffirmCompleteAuthorizeRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsCompleteAuthorizeRouterData) -> Result<Self, Self::Error> {\n        let transaction_id = item.request.connector_transaction_id.clone().ok_or(\n            errors::ConnectorError::MissingRequiredField {\n                field_name: \"connector_transaction_id\",\n            },\n        )?;\n\n        let reference_id = item.reference_id.clone();\n        let order_id = item.connector_request_reference_id.clone();\n        Ok(Self {\n            transaction_id,\n            order_id: Some(order_id),\n            reference_id,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Merchant {\n    pub public_api_key: Secret<String>,\n    pub user_confirmation_url: String,\n    pub user_cancel_url: String,\n    pub user_confirmation_url_action: Option<String>,\n    pub use_vcn: Option<String>,\n    pub name: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Item {\n    pub display_name: String,\n    pub sku: String,\n    pub unit_price: MinorUnit,\n    pub qty: i64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Shipping {\n    pub name: Name,\n    pub address: Address,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub phone_number: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option<pii::Email>,\n}\n#[derive(Debug, Serialize)]\npub struct Billing {\n    pub name: Name,\n    pub address: Address,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub phone_number: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option<pii::Email>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Name {\n    pub first: Option<Secret<String>>,\n    pub last: Option<Secret<String>>,\n    pub full: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Address {\n    pub line1: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub line2: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub zipcode: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Metadata {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub shipping_type: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub entity_name: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub platform_type: Option<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs",
    "code": "use common_enums::{enums, CountryAlpha2, Currency};\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\npub struct AffirmRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for AffirmRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmPaymentsRequest {\n    pub merchant: Merchant,\n    pub items: Vec<Item>,\n    pub shipping: Option<Shipping>,\n    pub billing: Option<Billing>,\n    pub total: MinorUnit,\n    pub currency: Currency,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmCompleteAuthorizeRequest {\n    pub order_id: Option<String>,\n    pub reference_id: Option<String>,\n    pub transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsCompleteAuthorizeRouterData> for AffirmCompleteAuthorizeRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsCompleteAuthorizeRouterData) -> Result<Self, Self::Error> {\n        let transaction_id = item.request.connector_transaction_id.clone().ok_or(\n            errors::ConnectorError::MissingRequiredField {\n                field_name: \"connector_transaction_id\",\n            },\n        )?;\n\n        let reference_id = item.reference_id.clone();\n        let order_id = item.connector_request_reference_id.clone();\n        Ok(Self {\n            transaction_id,\n            order_id: Some(order_id),\n            reference_id,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Merchant {\n    pub public_api_key: Secret<String>,\n    pub user_confirmation_url: String,\n    pub user_cancel_url: String,\n    pub user_confirmation_url_action: Option<String>,\n    pub use_vcn: Option<String>,\n    pub name: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Item {\n    pub display_name: String,\n    pub sku: String,\n    pub unit_price: MinorUnit,\n    pub qty: i64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Shipping {\n    pub name: Name,\n    pub address: Address,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub phone_number: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option<pii::Email>,\n}\n#[derive(Debug, Serialize)]\npub struct Billing {\n    pub name: Name,\n    pub address: Address,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub phone_number: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option<pii::Email>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Name {\n    pub first: Option<Secret<String>>,\n    pub last: Option<Secret<String>>,\n    pub full: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Address {\n    pub line1: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub line2: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub zipcode: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Metadata {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub shipping_type: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub entity_name: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub platform_type: Option<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::{enums, CountryAlpha2, Currency};\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PayLaterData, PaymentMethodData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{PaymentsAuthorizeRequestData, RouterData as OtherRouterData},\n};\npub struct AffirmRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for AffirmRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmPaymentsRequest {\n    pub merchant: Merchant,\n    pub items: Vec<Item>,\n    pub shipping: Option<Shipping>,\n    pub billing: Option<Billing>,\n    pub total: MinorUnit,\n    pub currency: Currency,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct AffirmCompleteAuthorizeRequest {\n    pub order_id: Option<String>,\n    pub reference_id: Option<String>,\n    pub transaction_id: String,\n}\n\nimpl TryFrom<&PaymentsCompleteAuthorizeRouterData> for AffirmCompleteAuthorizeRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsCompleteAuthorizeRouterData) -> Result<Self, Self::Error> {\n        let transaction_id = item.request.connector_transaction_id.clone().ok_or(\n            errors::ConnectorError::MissingRequiredField {\n                field_name: \"connector_transaction_id\",\n            },\n        )?;\n\n        let reference_id = item.reference_id.clone();\n        let order_id = item.connector_request_reference_id.clone();\n        Ok(Self {\n            transaction_id,\n            order_id: Some(order_id),\n            reference_id,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Merchant {\n    pub public_api_key: Secret<String>,\n    pub user_confirmation_url: String,\n    pub user_cancel_url: String,\n    pub user_confirmation_url_action: Option<String>,\n    pub use_vcn: Option<String>,\n    pub name: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Item {\n    pub display_name: String,\n    pub sku: String,\n    pub unit_price: MinorUnit,\n    pub qty: i64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Shipping {\n    pub name: Name,\n    pub address: Address,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub phone_number: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option<pii::Email>,\n}\n#[derive(Debug, Serialize)]\npub struct Billing {\n    pub name: Name,\n    pub address: Address,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub phone_number: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option<pii::Email>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Name {\n    pub first: Option<Secret<String>>,\n    pub last: Option<Secret<String>>,\n    pub full: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Address {\n    pub line1: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub line2: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub zipcode: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[derive(Debug, Serialize)]\npub struct Metadata {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub shipping_type: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub entity_name: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub platform_type: Option<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__affirm__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__api_models__src__payouts.rs",
    "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::BrowserInformation;\nuse common_utils::{\n    consts::default_payouts_list_limit,\n    crypto, id_type, link_utils, payout_method_utils,\n    pii::{self, Email},\n    transformers::ForeignFrom,\n    types::{UnifiedCode, UnifiedMessage},\n};\nuse masking::Secret;\n#[cfg(feature = \"v1\")]\nuse payments::BrowserInformation;\nuse router_derive::FlatStruct;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{admin, enums as api_enums, payment_methods::RequiredFieldInfo, payments};\n\n#[derive(Debug, Serialize, Clone, ToSchema)]\npub enum PayoutRequest {\n    PayoutActionRequest(PayoutActionRequest),\n    PayoutCreateRequest(Box<PayoutCreateRequest>),\n    PayoutRetrieveRequest(PayoutRetrieveRequest),\n}\n\n#[derive(\n    Default, Debug, Deserialize, Serialize, Clone, ToSchema, router_derive::PolymorphicSchema,\n)]\n#[generate_schemas(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n#[serde(deny_unknown_fields)]\npub struct PayoutCreateRequest {\n    /// Unique identifier for the payout. This ensures idempotency for multiple payouts that have been done by a single merchant. This field is auto generated and is returned in the API response, **not required to be included in the Payout Create/Update Request.**\n    #[schema(\n        value_type = Option<String>,\n        min_length = 30,\n        max_length = 30,\n        example = \"187282ab-40ef-47a9-9206-5099ba31e432\"\n    )]\n    #[remove_in(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n    pub payout_id: Option<id_type::PayoutId>,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key provided during the request, **not required to be included in the Payout Create/Update Request.**\n    #[schema(max_length = 255, value_type = Option<String>, example = \"merchant_1668273825\")]\n    #[remove_in(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n    pub merchant_id: Option<id_type::MerchantId>,\n\n    /// Your unique identifier for this payout or order. This ID helps you reconcile payouts on your system. If provided, it is passed to the connector if supported.\n    #[schema(value_type = Option<String>, max_length = 255, example = \"merchant_order_ref_123\")]\n    pub merchant_order_reference_id: Option<String>,\n\n    /// The payout amount. Amount for the payout in lowest denomination of the currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc.,\n    #[schema(value_type = Option<u64>, example = 1000)]\n    #[mandatory_in(PayoutsCreateRequest = u64)]\n    #[remove_in(PayoutsConfirmRequest)]\n    #[serde(default, deserialize_with = \"payments::amount::deserialize_option\")]\n    pub amount: Option<payments::Amount>,\n\n    /// The currency of the payout request can be specified here\n    #[schema(value_type = Option<Currency>, example = \"USD\")]\n    #[mandatory_in(PayoutsCreateRequest = Currency)]\n    #[remove_in(PayoutsConfirmRequest)]\n    pub currency: Option<api_enums::Currency>,\n\n    /// Specifies routing algorithm for selecting a connector\n    #[schema(value_type = Option<StaticRoutingAlgorithm>, example = json!({\n        \"type\": \"single\",\n        \"data\": \"adyen\"\n    }))]\n    pub routing: Option<serde_json::Value>,\n\n    /// This field allows the merchant to manually select a connector with which the payout can go through.\n    #[schema(value_type = Option<Vec<PayoutConnectors>>, max_length = 255, example = json!([\"wise\", \"adyen\"]))]\n    pub connector: Option<Vec<api_enums::PayoutConnectors>>,\n\n    /// This field is used when merchant wants to confirm the payout, thus useful for the payout _Confirm_ request. Ideally merchants should _Create_ a payout, _Update_ it (if required), then _Confirm_ it.\n    #[schema(value_type = Option<bool>, example = true, default = false)]\n    #[remove_in(PayoutConfirmRequest)]\n    pub confirm: Option<bool>,\n\n    /// The payout_type of the payout request can be specified here, this is a mandatory field to _Confirm_ the payout, i.e., should be passed in _Create_ request, if not then should be updated in the payout _Update_ request, then only it can be confirmed.\n    #[schema(value_type = Option<PayoutType>, example = \"card\")]\n    pub payout_type: Option<api_enums::PayoutType>,\n\n    /// The payout method information required for carrying out a payout\n    #[schema(value_type = Option<PayoutMethodData>)]\n    pub payout_method_data: Option<PayoutMethodData>,\n\n    /// The billing address for the payout\n    #[schema(value_type = Option<Address>, example = json!(r#\"{\n        \"address\": {\n            \"line1\": \"1467\",\n            \"line2\": \"Harrison Street\",\n            \"line3\": \"Harrison Street\",\n            \"city\": \"San Francisco\",\n            \"state\": \"CA\",\n            \"zip\": \"94122\",\n            \"country\": \"US\",\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\"\n        },\n        \"phone\": { \"number\": \"9123456789\", \"country_code\": \"+1\" }\n    }\"#))]\n    pub billing: Option<payments::Address>,\n\n    /// Set to true to confirm the payout without review, no further action required\n    #[schema(value_type = Option<bool>, example = true, default = false)]\n    pub auto_fulfill: Option<bool>,\n\n    /// The identifier for the customer object. If not provided the customer ID will be autogenerated. _Deprecated: Use customer_id instead._\n    #[schema(deprecated, value_type = Option<String>, max_length = 255, example = \"cus_y3oqhf46pyzuxjbcn2giaqnb44\")]\n    pub customer_id: Option<id_type::CustomerId>,\n\n    /// Passing this object creates a new customer or attaches an existing customer to the payout\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<payments::CustomerDetails>,\n\n    /// It's a token used for client side verification.\n    #[schema(value_type = Option<String>, example = \"pay_U42c409qyHwOkWo3vK60_secret_el9ksDkiB8hi6j9N78yo\")]\n    #[remove_in(PayoutsCreateRequest)]\n    #[mandatory_in(PayoutConfirmRequest = String)]\n    pub client_secret: Option<String>,\n\n    /// The URL to redirect after the completion of the operation\n    #[schema(value_type = Option<String>, example = \"https://hyperswitch.io\")]\n    pub return_url: Option<String>,\n\n    /// Business country of the merchant for this payout. _Deprecated: Use profile_id instead._\n    #[schema(deprecated, example = \"US\", value_type = Option<CountryAlpha2>)]\n    pub business_country: Option<api_enums::CountryAlpha2>,\n\n    /// Business label of the merchant for this payout. _Deprecated: Use profile_id instead._\n    #[schema(deprecated, example = \"food\", value_type = Option<String>)]\n    pub business_label: Option<String>,\n\n    /// A description of the payout",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__payouts.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__api_models__src__payouts.rs",
    "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v2\")]\nuse common_utils::types::BrowserInformation;\nuse common_utils::{\n    consts::default_payouts_list_limit,\n    crypto, id_type, link_utils, payout_method_utils,\n    pii::{self, Email},\n    transformers::ForeignFrom,\n    types::{UnifiedCode, UnifiedMessage},\n};\nuse masking::Secret;\n#[cfg(feature = \"v1\")]\nuse payments::BrowserInformation;\nuse router_derive::FlatStruct;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{admin, enums as api_enums, payment_methods::RequiredFieldInfo, payments};\n\n#[derive(Debug, Serialize, Clone, ToSchema)]\npub enum PayoutRequest {\n    PayoutActionRequest(PayoutActionRequest),\n    PayoutCreateRequest(Box<PayoutCreateRequest>),\n    PayoutRetrieveRequest(PayoutRetrieveRequest),\n}\n\n#[derive(\n    Default, Debug, Deserialize, Serialize, Clone, ToSchema, router_derive::PolymorphicSchema,\n)]\n#[generate_schemas(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n#[serde(deny_unknown_fields)]\npub struct PayoutCreateRequest {\n    /// Unique identifier for the payout. This ensures idempotency for multiple payouts that have been done by a single merchant. This field is auto generated and is returned in the API response, **not required to be included in the Payout Create/Update Request.**\n    #[schema(\n        value_type = Option<String>,\n        min_length = 30,\n        max_length = 30,\n        example = \"187282ab-40ef-47a9-9206-5099ba31e432\"\n    )]\n    #[remove_in(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n    pub payout_id: Option<id_type::PayoutId>,\n\n    /// This is an identifier for the merchant account. This is inferred from the API key provided during the request, **not required to be included in the Payout Create/Update Request.**\n    #[schema(max_length = 255, value_type = Option<String>, example = \"merchant_1668273825\")]\n    #[remove_in(PayoutsCreateRequest, PayoutUpdateRequest, PayoutConfirmRequest)]\n    pub merchant_id: Option<id_type::MerchantId>,\n\n    /// Your unique identifier for this payout or order. This ID helps you reconcile payouts on your system. If provided, it is passed to the connector if supported.\n    #[schema(value_type = Option<String>, max_length = 255, example = \"merchant_order_ref_123\")]\n    pub merchant_order_reference_id: Option<String>,\n\n    /// The payout amount. Amount for the payout in lowest denomination of the currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc.,\n    #[schema(value_type = Option<u64>, example = 1000)]\n    #[mandatory_in(PayoutsCreateRequest = u64)]\n    #[remove_in(PayoutsConfirmRequest)]\n    #[serde(default, deserialize_with = \"payments::amount::deserialize_option\")]\n    pub amount: Option<payments::Amount>,\n\n    /// The currency of the payout request can be specified here\n    #[schema(value_type = Option<Currency>, example = \"USD\")]\n    #[mandatory_in(PayoutsCreateRequest = Currency)]\n    #[remove_in(PayoutsConfirmRequest)]\n    pub currency: Option<api_enums::Currency>,\n\n    /// Specifies routing algorithm for selecting a connector\n    #[schema(value_type = Option<StaticRoutingAlgorithm>, example = json!({\n        \"type\": \"single\",\n        \"data\": \"adyen\"\n    }))]\n    pub routing: Option<serde_json::Value>,\n\n    /// This field allows the merchant to manually select a connector with which the payout can go through.\n    #[schema(value_type = Option<Vec<PayoutConnectors>>, max_length = 255, example = json!([\"wise\", \"adyen\"]))]\n    pub connector: Option<Vec<api_enums::PayoutConnectors>>,\n\n    /// This field is used when merchant wants to confirm the payout, thus useful for the payout _Confirm_ request. Ideally merchants should _Create_ a payout, _Update_ it (if required), then _Confirm_ it.\n    #[schema(value_type = Option<bool>, example = true, default = false)]\n    #[remove_in(PayoutConfirmRequest)]\n    pub confirm: Option<bool>,\n\n    /// The payout_type of the payout request can be specified here, this is a mandatory field to _Confirm_ the payout, i.e., should be passed in _Create_ request, if not then should be updated in the payout _Update_ request, then only it can be confirmed.\n    #[schema(value_type = Option<PayoutType>, example = \"card\")]\n    pub payout_type: Option<api_enums::PayoutType>,\n\n    /// The payout method information required for carrying out a payout\n    #[schema(value_type = Option<PayoutMethodData>)]\n    pub payout_method_data: Option<PayoutMethodData>,\n\n    /// The billing address for the payout\n    #[schema(value_type = Option<Address>, example = json!(r#\"{\n        \"address\": {\n            \"line1\": \"1467\",\n            \"line2\": \"Harrison Street\",\n            \"line3\": \"Harrison Street\",\n            \"city\": \"San Francisco\",\n            \"state\": \"CA\",\n            \"zip\": \"94122\",\n            \"country\": \"US\",\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\"\n        },\n        \"phone\": { \"number\": \"9123456789\", \"country_code\": \"+1\" }\n    }\"#))]\n    pub billing: Option<payments::Address>,\n\n    /// Set to true to confirm the payout without review, no further action required\n    #[schema(value_type = Option<bool>, example = true, default = false)]\n    pub auto_fulfill: Option<bool>,\n\n    /// The identifier for the customer object. If not provided the customer ID will be autogenerated. _Deprecated: Use customer_id instead._\n    #[schema(deprecated, value_type = Option<String>, max_length = 255, example = \"cus_y3oqhf46pyzuxjbcn2giaqnb44\")]\n    pub customer_id: Option<id_type::CustomerId>,\n\n    /// Passing this object creates a new customer or attaches an existing customer to the payout\n    #[schema(value_type = Option<CustomerDetails>)]\n    pub customer: Option<payments::CustomerDetails>,\n\n    /// It's a token used for client side verification.\n    #[schema(value_type = Option<String>, example = \"pay_U42c409qyHwOkWo3vK60_secret_el9ksDkiB8hi6j9N78yo\")]\n    #[remove_in(PayoutsCreateRequest)]\n    #[mandatory_in(PayoutConfirmRequest = String)]\n    pub client_secret: Option<String>,\n\n    /// The URL to redirect after the completion of the operation\n    #[schema(value_type = Option<String>, example = \"https://hyperswitch.io\")]\n    pub return_url: Option<String>,\n\n    /// Business country of the merchant for this payout. _Deprecated: Use profile_id instead._\n    #[schema(deprecated, example = \"US\", value_type = Option<CountryAlpha2>)]\n    pub business_country: Option<api_enums::CountryAlpha2>,\n\n    /// Business label of the merchant for this payout. _Deprecated: Use profile_id instead._\n    #[schema(deprecated, example = \"food\", value_type = Option<String>)]\n    pub business_label: Option<String>,\n\n    /// A description of the payout",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__payouts.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__common_utils__src__pii.rs",
    "code": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse serde::Deserialize;\n\nuse crate::{\n    crypto::Encryptable,\n    errors::{self, ValidationError},\n    validation::{validate_email, validate_phone_number},\n};\n\n/// A string constant representing a redacted or masked value.\npub const REDACTED: &str = \"Redacted\";\n\n/// Type alias for serde_json value which has Secret Information\npub type SecretSerdeValue = Secret<serde_json::Value>;\n\n/// Strategy for masking a PhoneNumber\n#[derive(Debug)]\npub enum PhoneNumberStrategy {}\n\n/// Phone Number\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(try_from = \"String\")]\npub struct PhoneNumber(Secret<String, PhoneNumberStrategy>);\n\nimpl<T> Strategy<T> for PhoneNumberStrategy\nwhere\n    T: AsRef<str> + fmt::Debug,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    }\n}\n\nimpl FromStr for PhoneNumber {\n    type Err = error_stack::Report<ValidationError>;\n    fn from_str(phone_number: &str) -> Result<Self, Self::Err> {\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    }\n}\n\nimpl TryFrom<String> for PhoneNumber {\n    type Error = error_stack::Report<errors::ParsingError>;\n\n    fn try_from(value: String) -> Result<Self, Self::Error> {\n        Self::from_str(&value).change_context(errors::ParsingError::PhoneNumberParsingError)\n    }\n}\n\nimpl ops::Deref for PhoneNumber {\n    type Target = Secret<String, PhoneNumberStrategy>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl ops::DerefMut for PhoneNumber {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<DB> Queryable<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    Self: FromSql<sql_types::Text, DB>,\n{\n    type Row = Self;\n\n    fn build(row: Self::Row) -> deserialize::Result<Self> {\n        Ok(row)\n    }\n}\n\nimpl<DB> FromSql<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    String: FromSql<sql_types::Text, DB>,\n{\n    fn from_sql(bytes: DB::RawValue<'_>) -> deserialize::Result<Self> {\n        let val = String::from_sql(bytes)?;\n        Ok(Self::from_str(val.as_str())?)\n    }\n}\n\nimpl<DB> ToSql<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    String: ToSql<sql_types::Text, DB>,\n{\n    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, DB>) -> diesel::serialize::Result {\n        self.0.to_sql(out)\n    }\n}\n\n/*\n/// Phone number\n#[derive(Debug)]\npub struct PhoneNumber;\n\nimpl<T> Strategy<T> for PhoneNumber\nwhere\n    T: AsRef<str>,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if val_str.len() < 10 || val_str.len() > 12 {\n            return WithType::fmt(val, f);\n        }\n\n        write!(\n            f,\n            \"{}{}{}\",",
    "function_name": "fmt",
    "file": "crates__common_utils__src__pii.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__common_utils__src__pii.rs",
    "code": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse serde::Deserialize;\n\nuse crate::{\n    crypto::Encryptable,\n    errors::{self, ValidationError},\n    validation::{validate_email, validate_phone_number},\n};\n\n/// A string constant representing a redacted or masked value.\npub const REDACTED: &str = \"Redacted\";\n\n/// Type alias for serde_json value which has Secret Information\npub type SecretSerdeValue = Secret<serde_json::Value>;\n\n/// Strategy for masking a PhoneNumber\n#[derive(Debug)]\npub enum PhoneNumberStrategy {}\n\n/// Phone Number\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(try_from = \"String\")]\npub struct PhoneNumber(Secret<String, PhoneNumberStrategy>);\n\nimpl<T> Strategy<T> for PhoneNumberStrategy\nwhere\n    T: AsRef<str> + fmt::Debug,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    }\n}\n\nimpl FromStr for PhoneNumber {\n    type Err = error_stack::Report<ValidationError>;\n    fn from_str(phone_number: &str) -> Result<Self, Self::Err> {\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    }\n}\n\nimpl TryFrom<String> for PhoneNumber {\n    type Error = error_stack::Report<errors::ParsingError>;\n\n    fn try_from(value: String) -> Result<Self, Self::Error> {\n        Self::from_str(&value).change_context(errors::ParsingError::PhoneNumberParsingError)\n    }\n}\n\nimpl ops::Deref for PhoneNumber {\n    type Target = Secret<String, PhoneNumberStrategy>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl ops::DerefMut for PhoneNumber {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<DB> Queryable<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    Self: FromSql<sql_types::Text, DB>,\n{\n    type Row = Self;\n\n    fn build(row: Self::Row) -> deserialize::Result<Self> {\n        Ok(row)\n    }\n}\n\nimpl<DB> FromSql<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    String: FromSql<sql_types::Text, DB>,\n{\n    fn from_sql(bytes: DB::RawValue<'_>) -> deserialize::Result<Self> {\n        let val = String::from_sql(bytes)?;\n        Ok(Self::from_str(val.as_str())?)\n    }\n}\n\nimpl<DB> ToSql<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    String: ToSql<sql_types::Text, DB>,\n{\n    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, DB>) -> diesel::serialize::Result {\n        self.0.to_sql(out)\n    }\n}\n\n/*\n/// Phone number\n#[derive(Debug)]\npub struct PhoneNumber;\n\nimpl<T> Strategy<T> for PhoneNumber\nwhere\n    T: AsRef<str>,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if val_str.len() < 10 || val_str.len() > 12 {\n            return WithType::fmt(val, f);\n        }\n\n        write!(\n            f,\n            \"{}{}{}\",",
    "function_name": "fmt",
    "file": "crates__common_utils__src__pii.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for fmt",
    "code": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse serde::Deserialize;\n\nuse crate::{\n    crypto::Encryptable,\n    errors::{self, ValidationError},\n    validation::{validate_email, validate_phone_number},\n};\n\n/// A string constant representing a redacted or masked value.\npub const REDACTED: &str = \"Redacted\";\n\n/// Type alias for serde_json value which has Secret Information\npub type SecretSerdeValue = Secret<serde_json::Value>;\n\n/// Strategy for masking a PhoneNumber\n#[derive(Debug)]\npub enum PhoneNumberStrategy {}\n\n/// Phone Number\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(try_from = \"String\")]\npub struct PhoneNumber(Secret<String, PhoneNumberStrategy>);\n\nimpl<T> Strategy<T> for PhoneNumberStrategy\nwhere\n    T: AsRef<str> + fmt::Debug,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    }\n}\n\nimpl FromStr for PhoneNumber {\n    type Err = error_stack::Report<ValidationError>;\n    fn from_str(phone_number: &str) -> Result<Self, Self::Err> {\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    }\n}\n\nimpl TryFrom<String> for PhoneNumber {\n    type Error = error_stack::Report<errors::ParsingError>;\n\n    fn try_from(value: String) -> Result<Self, Self::Error> {\n        Self::from_str(&value).change_context(errors::ParsingError::PhoneNumberParsingError)\n    }\n}\n\nimpl ops::Deref for PhoneNumber {\n    type Target = Secret<String, PhoneNumberStrategy>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl ops::DerefMut for PhoneNumber {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<DB> Queryable<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    Self: FromSql<sql_types::Text, DB>,\n{\n    type Row = Self;\n\n    fn build(row: Self::Row) -> deserialize::Result<Self> {\n        Ok(row)\n    }\n}\n\nimpl<DB> FromSql<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    String: FromSql<sql_types::Text, DB>,\n{\n    fn from_sql(bytes: DB::RawValue<'_>) -> deserialize::Result<Self> {\n        let val = String::from_sql(bytes)?;\n        Ok(Self::from_str(val.as_str())?)\n    }\n}\n\nimpl<DB> ToSql<sql_types::Text, DB> for PhoneNumber\nwhere\n    DB: Backend,\n    String: ToSql<sql_types::Text, DB>,\n{\n    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, DB>) -> diesel::serialize::Result {\n        self.0.to_sql(out)\n    }\n}\n\n/*\n/// Phone number\n#[derive(Debug)]\npub struct PhoneNumber;\n\nimpl<T> Strategy<T> for PhoneNumber\nwhere\n    T: AsRef<str>,\n{\n    fn fmt(val: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let val_str: &str = val.as_ref();\n\n        if val_str.len() < 10 || val_str.len() > 12 {\n            return WithType::fmt(val, f);\n        }\n\n        write!(\n            f,\n            \"{}{}{}\",",
    "function_name": "fmt",
    "file": "crates__common_utils__src__pii.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__authorizedotnet.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, MandateSetup,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        ConnectorCustomerType, PaymentsAuthorizeType, PaymentsCaptureType,\n        PaymentsCompleteAuthorizeType, PaymentsSyncType, PaymentsVoidType, RefundExecuteType,\n        RefundSyncType, Response, SetupMandateType,\n    },\n    webhooks,\n};\nuse masking::Maskable;\nuse transformers as authorizedotnet;\n\nuse crate::{\n    connectors::authorizedotnet::transformers::AuthorizedotnetRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        self as connector_utils, convert_amount, ForeignTryFrom, PaymentMethodDataType,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n    },\n};\n\n#[derive(Clone)]\npub struct Authorizedotnet {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Authorizedotnet {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Authorizedotnet\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )])\n    }\n}\n\nimpl ConnectorCommon for Authorizedotnet {\n    fn id(&self) -> &'static str {\n        \"authorizedotnet\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.authorizedotnet.base_url.as_ref()\n    }\n}\n\nimpl ConnectorValidation for Authorizedotnet {\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::GooglePay,\n            PaymentMethodDataType::ApplePay,\n        ]);\n        connector_utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl api::Payment for Authorizedotnet {}\nimpl api::PaymentAuthorize for Authorizedotnet {}\nimpl api::PaymentSync for Authorizedotnet {}\nimpl api::PaymentVoid for Authorizedotnet {}\nimpl api::PaymentCapture for Authorizedotnet {}\nimpl api::PaymentSession for Authorizedotnet {}\nimpl api::ConnectorAccessToken for Authorizedotnet {}\nimpl api::PaymentToken for Authorizedotnet {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Authorizedotnet\n{\n    // Not Implemented (R)",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__authorizedotnet.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__authorizedotnet.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, MandateSetup,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        ConnectorCustomerType, PaymentsAuthorizeType, PaymentsCaptureType,\n        PaymentsCompleteAuthorizeType, PaymentsSyncType, PaymentsVoidType, RefundExecuteType,\n        RefundSyncType, Response, SetupMandateType,\n    },\n    webhooks,\n};\nuse masking::Maskable;\nuse transformers as authorizedotnet;\n\nuse crate::{\n    connectors::authorizedotnet::transformers::AuthorizedotnetRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        self as connector_utils, convert_amount, ForeignTryFrom, PaymentMethodDataType,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n    },\n};\n\n#[derive(Clone)]\npub struct Authorizedotnet {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Authorizedotnet {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Authorizedotnet\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )])\n    }\n}\n\nimpl ConnectorCommon for Authorizedotnet {\n    fn id(&self) -> &'static str {\n        \"authorizedotnet\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.authorizedotnet.base_url.as_ref()\n    }\n}\n\nimpl ConnectorValidation for Authorizedotnet {\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::GooglePay,\n            PaymentMethodDataType::ApplePay,\n        ]);\n        connector_utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl api::Payment for Authorizedotnet {}\nimpl api::PaymentAuthorize for Authorizedotnet {}\nimpl api::PaymentSync for Authorizedotnet {}\nimpl api::PaymentVoid for Authorizedotnet {}\nimpl api::PaymentCapture for Authorizedotnet {}\nimpl api::PaymentSession for Authorizedotnet {}\nimpl api::ConnectorAccessToken for Authorizedotnet {}\nimpl api::PaymentToken for Authorizedotnet {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Authorizedotnet\n{\n    // Not Implemented (R)",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__authorizedotnet.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, MandateSetup,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        ConnectorCustomerType, PaymentsAuthorizeType, PaymentsCaptureType,\n        PaymentsCompleteAuthorizeType, PaymentsSyncType, PaymentsVoidType, RefundExecuteType,\n        RefundSyncType, Response, SetupMandateType,\n    },\n    webhooks,\n};\nuse masking::Maskable;\nuse transformers as authorizedotnet;\n\nuse crate::{\n    connectors::authorizedotnet::transformers::AuthorizedotnetRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        self as connector_utils, convert_amount, ForeignTryFrom, PaymentMethodDataType,\n        PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n    },\n};\n\n#[derive(Clone)]\npub struct Authorizedotnet {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Authorizedotnet {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Authorizedotnet\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )])\n    }\n}\n\nimpl ConnectorCommon for Authorizedotnet {\n    fn id(&self) -> &'static str {\n        \"authorizedotnet\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.authorizedotnet.base_url.as_ref()\n    }\n}\n\nimpl ConnectorValidation for Authorizedotnet {\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let mandate_supported_pmd = std::collections::HashSet::from([\n            PaymentMethodDataType::Card,\n            PaymentMethodDataType::GooglePay,\n            PaymentMethodDataType::ApplePay,\n        ]);\n        connector_utils::is_mandate_supported(pm_data, pm_type, mandate_supported_pmd, self.id())\n    }\n}\n\nimpl api::Payment for Authorizedotnet {}\nimpl api::PaymentAuthorize for Authorizedotnet {}\nimpl api::PaymentSync for Authorizedotnet {}\nimpl api::PaymentVoid for Authorizedotnet {}\nimpl api::PaymentCapture for Authorizedotnet {}\nimpl api::PaymentSession for Authorizedotnet {}\nimpl api::ConnectorAccessToken for Authorizedotnet {}\nimpl api::PaymentToken for Authorizedotnet {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Authorizedotnet\n{\n    // Not Implemented (R)",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__authorizedotnet.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs",
    "code": "use common_enums::{\n    enums::{self, AttemptStatus, PaymentChannel},\n    CountryAlpha2,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    ext_traits::ByteSliceExt,\n    request::{Method, RequestContent},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    payment_methods::storage_enums::MitCategory,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{Execute, RSync, SetupMandate},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors, webhooks};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse serde_with::skip_serializing_none;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AdditionalCardInfo, PaymentsAuthorizeRequestData, PaymentsCaptureRequestData,\n        PaymentsSyncRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct CheckoutRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for CheckoutRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\n#[serde(tag = \"type\", content = \"token_data\")]\npub enum TokenRequest {\n    Googlepay(CheckoutGooglePayData),\n    Applepay(CheckoutApplePayData),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\n#[serde(tag = \"type\", content = \"token_data\")]\npub enum PreDecryptedTokenRequest {\n    Applepay(Box<CheckoutApplePayData>),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CheckoutGooglePayData {\n    protocol_version: Secret<String>,\n    signature: Secret<String>,\n    signed_message: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CheckoutApplePayData {\n    version: Secret<String>,\n    data: Secret<String>,\n    signature: Secret<String>,\n    header: CheckoutApplePayHeader,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CheckoutApplePayHeader {\n    ephemeral_public_key: Secret<String>,\n    public_key_hash: Secret<String>,\n    transaction_id: Secret<String>,\n}\n\nimpl TryFrom<&TokenizationRouterData> for TokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &TokenizationRouterData) -> Result<Self, Self::Error> {\n        match item.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(wallet_data) => match wallet_data.clone() {\n                WalletData::GooglePay(_data) => {\n                    let json_wallet_data: CheckoutGooglePayData =\n                        wallet_data.get_wallet_token_as_json(\"Google Pay\".to_string())?;\n                    Ok(Self::Googlepay(json_wallet_data))\n                }\n                WalletData::ApplePay(_data) => {\n                    let json_wallet_data: CheckoutApplePayData =\n                        wallet_data.get_wallet_token_as_json(\"Apple Pay\".to_string())?;\n                    Ok(Self::Applepay(json_wallet_data))\n                }\n                WalletData::AliPayQr(_)\n                | WalletData::AliPayRedirect(_)\n                | WalletData::AliPayHkRedirect(_)\n                | WalletData::AmazonPay(_)\n                | WalletData::AmazonPayRedirect(_)\n                | WalletData::Paysera(_)\n                | WalletData::Skrill(_)\n                | WalletData::BluecodeRedirect {}\n                | WalletData::MomoRedirect(_)\n                | WalletData::KakaoPayRedirect(_)\n                | WalletData::GoPayRedirect(_)\n                | WalletData::GcashRedirect(_)\n                | WalletData::ApplePayRedirect(_)\n                | WalletData::ApplePayThirdPartySdk(_)\n                | WalletData::DanaRedirect {}\n                | WalletData::GooglePayRedirect(_)\n                | WalletData::GooglePayThirdPartySdk(_)\n                | WalletData::MbWayRedirect(_)\n                | WalletData::MobilePayRedirect(_)\n                | WalletData::PaypalRedirect(_)\n                | WalletData::PaypalSdk(_)\n                | WalletData::Paze(_)",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs",
    "code": "use common_enums::{\n    enums::{self, AttemptStatus, PaymentChannel},\n    CountryAlpha2,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    ext_traits::ByteSliceExt,\n    request::{Method, RequestContent},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    payment_methods::storage_enums::MitCategory,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{Execute, RSync, SetupMandate},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors, webhooks};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse serde_with::skip_serializing_none;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AdditionalCardInfo, PaymentsAuthorizeRequestData, PaymentsCaptureRequestData,\n        PaymentsSyncRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct CheckoutRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for CheckoutRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\n#[serde(tag = \"type\", content = \"token_data\")]\npub enum TokenRequest {\n    Googlepay(CheckoutGooglePayData),\n    Applepay(CheckoutApplePayData),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\n#[serde(tag = \"type\", content = \"token_data\")]\npub enum PreDecryptedTokenRequest {\n    Applepay(Box<CheckoutApplePayData>),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CheckoutGooglePayData {\n    protocol_version: Secret<String>,\n    signature: Secret<String>,\n    signed_message: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CheckoutApplePayData {\n    version: Secret<String>,\n    data: Secret<String>,\n    signature: Secret<String>,\n    header: CheckoutApplePayHeader,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CheckoutApplePayHeader {\n    ephemeral_public_key: Secret<String>,\n    public_key_hash: Secret<String>,\n    transaction_id: Secret<String>,\n}\n\nimpl TryFrom<&TokenizationRouterData> for TokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &TokenizationRouterData) -> Result<Self, Self::Error> {\n        match item.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(wallet_data) => match wallet_data.clone() {\n                WalletData::GooglePay(_data) => {\n                    let json_wallet_data: CheckoutGooglePayData =\n                        wallet_data.get_wallet_token_as_json(\"Google Pay\".to_string())?;\n                    Ok(Self::Googlepay(json_wallet_data))\n                }\n                WalletData::ApplePay(_data) => {\n                    let json_wallet_data: CheckoutApplePayData =\n                        wallet_data.get_wallet_token_as_json(\"Apple Pay\".to_string())?;\n                    Ok(Self::Applepay(json_wallet_data))\n                }\n                WalletData::AliPayQr(_)\n                | WalletData::AliPayRedirect(_)\n                | WalletData::AliPayHkRedirect(_)\n                | WalletData::AmazonPay(_)\n                | WalletData::AmazonPayRedirect(_)\n                | WalletData::Paysera(_)\n                | WalletData::Skrill(_)\n                | WalletData::BluecodeRedirect {}\n                | WalletData::MomoRedirect(_)\n                | WalletData::KakaoPayRedirect(_)\n                | WalletData::GoPayRedirect(_)\n                | WalletData::GcashRedirect(_)\n                | WalletData::ApplePayRedirect(_)\n                | WalletData::ApplePayThirdPartySdk(_)\n                | WalletData::DanaRedirect {}\n                | WalletData::GooglePayRedirect(_)\n                | WalletData::GooglePayThirdPartySdk(_)\n                | WalletData::MbWayRedirect(_)\n                | WalletData::MobilePayRedirect(_)\n                | WalletData::PaypalRedirect(_)\n                | WalletData::PaypalSdk(_)\n                | WalletData::Paze(_)",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::{\n    enums::{self, AttemptStatus, PaymentChannel},\n    CountryAlpha2,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    ext_traits::ByteSliceExt,\n    request::{Method, RequestContent},\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    payment_methods::storage_enums::MitCategory,\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{Execute, RSync, SetupMandate},\n    router_request_types::{ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors, webhooks};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse serde_with::skip_serializing_none;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AdditionalCardInfo, PaymentsAuthorizeRequestData, PaymentsCaptureRequestData,\n        PaymentsSyncRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct CheckoutRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for CheckoutRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\n#[serde(tag = \"type\", content = \"token_data\")]\npub enum TokenRequest {\n    Googlepay(CheckoutGooglePayData),\n    Applepay(CheckoutApplePayData),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\n#[serde(tag = \"type\", content = \"token_data\")]\npub enum PreDecryptedTokenRequest {\n    Applepay(Box<CheckoutApplePayData>),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CheckoutGooglePayData {\n    protocol_version: Secret<String>,\n    signature: Secret<String>,\n    signed_message: Secret<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CheckoutApplePayData {\n    version: Secret<String>,\n    data: Secret<String>,\n    signature: Secret<String>,\n    header: CheckoutApplePayHeader,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CheckoutApplePayHeader {\n    ephemeral_public_key: Secret<String>,\n    public_key_hash: Secret<String>,\n    transaction_id: Secret<String>,\n}\n\nimpl TryFrom<&TokenizationRouterData> for TokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &TokenizationRouterData) -> Result<Self, Self::Error> {\n        match item.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(wallet_data) => match wallet_data.clone() {\n                WalletData::GooglePay(_data) => {\n                    let json_wallet_data: CheckoutGooglePayData =\n                        wallet_data.get_wallet_token_as_json(\"Google Pay\".to_string())?;\n                    Ok(Self::Googlepay(json_wallet_data))\n                }\n                WalletData::ApplePay(_data) => {\n                    let json_wallet_data: CheckoutApplePayData =\n                        wallet_data.get_wallet_token_as_json(\"Apple Pay\".to_string())?;\n                    Ok(Self::Applepay(json_wallet_data))\n                }\n                WalletData::AliPayQr(_)\n                | WalletData::AliPayRedirect(_)\n                | WalletData::AliPayHkRedirect(_)\n                | WalletData::AmazonPay(_)\n                | WalletData::AmazonPayRedirect(_)\n                | WalletData::Paysera(_)\n                | WalletData::Skrill(_)\n                | WalletData::BluecodeRedirect {}\n                | WalletData::MomoRedirect(_)\n                | WalletData::KakaoPayRedirect(_)\n                | WalletData::GoPayRedirect(_)\n                | WalletData::GcashRedirect(_)\n                | WalletData::ApplePayRedirect(_)\n                | WalletData::ApplePayThirdPartySdk(_)\n                | WalletData::DanaRedirect {}\n                | WalletData::GooglePayRedirect(_)\n                | WalletData::GooglePayThirdPartySdk(_)\n                | WalletData::MbWayRedirect(_)\n                | WalletData::MobilePayRedirect(_)\n                | WalletData::PaypalRedirect(_)\n                | WalletData::PaypalSdk(_)\n                | WalletData::Paze(_)",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__checkout__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__helcim.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse masking::{ExposeInterface, Mask};\nuse transformers as helcim;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, to_connector_meta, PaymentsAuthorizeRequestData},\n};\n\n#[derive(Clone)]\npub struct Helcim {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Helcim {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Helcim {}\nimpl api::PaymentSession for Helcim {}\nimpl api::ConnectorAccessToken for Helcim {}\nimpl api::MandateSetup for Helcim {}\nimpl api::PaymentAuthorize for Helcim {}\nimpl api::PaymentSync for Helcim {}\nimpl api::PaymentCapture for Helcim {}\nimpl api::PaymentVoid for Helcim {}\nimpl api::Refund for Helcim {}\nimpl api::RefundExecute for Helcim {}\nimpl api::RefundSync for Helcim {}\nimpl api::PaymentToken for Helcim {}\n\nimpl Helcim {\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Helcim {\n    fn id(&self) -> &'static str {\n        \"helcim\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__helcim.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__helcim.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse masking::{ExposeInterface, Mask};\nuse transformers as helcim;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, to_connector_meta, PaymentsAuthorizeRequestData},\n};\n\n#[derive(Clone)]\npub struct Helcim {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Helcim {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Helcim {}\nimpl api::PaymentSession for Helcim {}\nimpl api::ConnectorAccessToken for Helcim {}\nimpl api::MandateSetup for Helcim {}\nimpl api::PaymentAuthorize for Helcim {}\nimpl api::PaymentSync for Helcim {}\nimpl api::PaymentCapture for Helcim {}\nimpl api::PaymentVoid for Helcim {}\nimpl api::Refund for Helcim {}\nimpl api::RefundExecute for Helcim {}\nimpl api::RefundSync for Helcim {}\nimpl api::PaymentToken for Helcim {}\n\nimpl Helcim {\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Helcim {\n    fn id(&self) -> &'static str {\n        \"helcim\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__helcim.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse masking::{ExposeInterface, Mask};\nuse transformers as helcim;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, to_connector_meta, PaymentsAuthorizeRequestData},\n};\n\n#[derive(Clone)]\npub struct Helcim {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Helcim {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Helcim {}\nimpl api::PaymentSession for Helcim {}\nimpl api::ConnectorAccessToken for Helcim {}\nimpl api::MandateSetup for Helcim {}\nimpl api::PaymentAuthorize for Helcim {}\nimpl api::PaymentSync for Helcim {}\nimpl api::PaymentCapture for Helcim {}\nimpl api::PaymentVoid for Helcim {}\nimpl api::Refund for Helcim {}\nimpl api::RefundExecute for Helcim {}\nimpl api::RefundSync for Helcim {}\nimpl api::PaymentToken for Helcim {}\n\nimpl Helcim {\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: helcim::HelcimMetaData = to_connector_meta(connector_meta.cloned())?;\n        Ok(Some(meta.preauth_transaction_id.to_string()))\n    }\n}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Helcim\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Helcim\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::maskable::Maskable<String>)>, errors::ConnectorError>\n    {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n\n        //Helcim requires an Idempotency Key of length 25. We prefix every ID by \"HS_\".\n        const ID_LENGTH: usize = 22;\n        let mut idempotency_key = vec![(\n            headers::IDEMPOTENCY_KEY.to_string(),\n            common_utils::generate_id(ID_LENGTH, \"HS\").into_masked(),\n        )];\n\n        header.append(&mut api_key);\n        header.append(&mut idempotency_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Helcim {\n    fn id(&self) -> &'static str {\n        \"helcim\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__helcim.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__core__payment_methods__vault.rs",
    "code": "use common_enums::PaymentMethodType;\n#[cfg(feature = \"v2\")]\nuse common_utils::encryption::Encryption;\nuse common_utils::{\n    crypto::{DecodeMessage, EncodeMessage, GcmAes256},\n    ext_traits::{BytesExt, Encode},\n    generate_id_with_default_len, id_type,\n    pii::Email,\n    request,\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::router_flow_types::{\n    ExternalVaultDeleteFlow, ExternalVaultRetrieveFlow,\n};\nuse hyperswitch_domain_models::{\n    router_data_v2::flow_common_types::VaultConnectorFlowData, types::VaultRouterData,\n};\nuse masking::PeekInterface;\nuse router_env::{instrument, tracing};\nuse scheduler::{types::process_data, utils as process_tracker_utils};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::api::payouts;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, ConnectorErrorExt, CustomResult, RouterResult},\n        payment_methods::transformers as pm_transforms,\n        payments, utils as core_utils,\n    },\n    db, headers, logger,\n    routes::{self, metrics},\n    services::{self, connector_integration_interface::RouterDataConversion},\n    settings,\n    types::{\n        self, api, domain, payment_methods as pm_types,\n        storage::{self, enums},\n    },\n    utils::{ConnectorResponseExt, StringExt},\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    core::{\n        errors::StorageErrorExt,\n        payment_methods::{cards as pm_cards, utils},\n        payments::{self as payments_core, helpers as payment_helpers},\n    },\n    utils::ext_traits::OptionExt,\n};\n\nconst VAULT_SERVICE_NAME: &str = \"CARD\";\n\npub struct SupplementaryVaultData {\n    pub customer_id: Option<id_type::CustomerId>,\n    pub payment_method_id: Option<String>,\n}\n\npub trait Vaultable: Sized {\n    fn get_value1(\n        &self,\n        customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError>;\n    fn get_value2(\n        &self,\n        _customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        Ok(String::new())\n    }\n    fn from_values(\n        value1: String,\n        value2: String,\n    ) -> CustomResult<(Self, SupplementaryVaultData), errors::VaultError>;\n}\n\nimpl Vaultable for domain::Card {\n    fn get_value1(\n        &self,\n        _customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        let value1 = domain::TokenizedCardValue1 {\n            card_number: self.card_number.peek().clone(),\n            exp_year: self.card_exp_year.peek().clone(),\n            exp_month: self.card_exp_month.peek().clone(),\n            nickname: self.nick_name.as_ref().map(|name| name.peek().clone()),\n            card_last_four: None,\n            card_token: None,\n            card_holder_name: self.card_holder_name.clone(),\n        };\n\n        value1\n            .encode_to_string_of_json()\n            .change_context(errors::VaultError::RequestEncodingFailed)\n            .attach_printable(\"Failed to encode card value1\")\n    }\n\n    fn get_value2(\n        &self,\n        customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        let value2 = domain::TokenizedCardValue2 {\n            card_security_code: Some(self.card_cvc.peek().clone()),\n            card_fingerprint: None,\n            external_id: None,\n            customer_id,\n            payment_method_id: None,\n        };\n\n        value2\n            .encode_to_string_of_json()\n            .change_context(errors::VaultError::RequestEncodingFailed)\n            .attach_printable(\"Failed to encode card value2\")\n    }\n\n    fn from_values(\n        value1: String,\n        value2: String,\n    ) -> CustomResult<(Self, SupplementaryVaultData), errors::VaultError> {\n        let value1: domain::TokenizedCardValue1 = value1\n            .parse_struct(\"TokenizedCardValue1\")\n            .change_context(errors::VaultError::ResponseDeserializationFailed)\n            .attach_printable(\"Could not deserialize into card value1\")?;\n\n        let value2: domain::TokenizedCardValue2 = value2\n            .parse_struct(\"TokenizedCardValue2\")\n            .change_context(errors::VaultError::ResponseDeserializationFailed)\n            .attach_printable(\"Could not deserialize into card value2\")?;\n\n        let card = Self {\n            card_number: cards::CardNumber::try_from(value1.card_number)\n                .change_context(errors::VaultError::ResponseDeserializationFailed)\n                .attach_printable(\"Invalid card number format from the mock locker\")?,\n            card_exp_month: value1.exp_month.into(),\n            card_exp_year: value1.exp_year.into(),\n            card_cvc: value2.card_security_code.unwrap_or_default().into(),\n            card_issuer: None,\n            card_network: None,\n            bank_code: None,\n            card_issuing_country: None,\n            card_issuing_country_code: None,",
    "function_name": "get_value1",
    "file": "crates__router__src__core__payment_methods__vault.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__core__payment_methods__vault.rs",
    "code": "use common_enums::PaymentMethodType;\n#[cfg(feature = \"v2\")]\nuse common_utils::encryption::Encryption;\nuse common_utils::{\n    crypto::{DecodeMessage, EncodeMessage, GcmAes256},\n    ext_traits::{BytesExt, Encode},\n    generate_id_with_default_len, id_type,\n    pii::Email,\n    request,\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::router_flow_types::{\n    ExternalVaultDeleteFlow, ExternalVaultRetrieveFlow,\n};\nuse hyperswitch_domain_models::{\n    router_data_v2::flow_common_types::VaultConnectorFlowData, types::VaultRouterData,\n};\nuse masking::PeekInterface;\nuse router_env::{instrument, tracing};\nuse scheduler::{types::process_data, utils as process_tracker_utils};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::api::payouts;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, ConnectorErrorExt, CustomResult, RouterResult},\n        payment_methods::transformers as pm_transforms,\n        payments, utils as core_utils,\n    },\n    db, headers, logger,\n    routes::{self, metrics},\n    services::{self, connector_integration_interface::RouterDataConversion},\n    settings,\n    types::{\n        self, api, domain, payment_methods as pm_types,\n        storage::{self, enums},\n    },\n    utils::{ConnectorResponseExt, StringExt},\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    core::{\n        errors::StorageErrorExt,\n        payment_methods::{cards as pm_cards, utils},\n        payments::{self as payments_core, helpers as payment_helpers},\n    },\n    utils::ext_traits::OptionExt,\n};\n\nconst VAULT_SERVICE_NAME: &str = \"CARD\";\n\npub struct SupplementaryVaultData {\n    pub customer_id: Option<id_type::CustomerId>,\n    pub payment_method_id: Option<String>,\n}\n\npub trait Vaultable: Sized {\n    fn get_value1(\n        &self,\n        customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError>;\n    fn get_value2(\n        &self,\n        _customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        Ok(String::new())\n    }\n    fn from_values(\n        value1: String,\n        value2: String,\n    ) -> CustomResult<(Self, SupplementaryVaultData), errors::VaultError>;\n}\n\nimpl Vaultable for domain::Card {\n    fn get_value1(\n        &self,\n        _customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        let value1 = domain::TokenizedCardValue1 {\n            card_number: self.card_number.peek().clone(),\n            exp_year: self.card_exp_year.peek().clone(),\n            exp_month: self.card_exp_month.peek().clone(),\n            nickname: self.nick_name.as_ref().map(|name| name.peek().clone()),\n            card_last_four: None,\n            card_token: None,\n            card_holder_name: self.card_holder_name.clone(),\n        };\n\n        value1\n            .encode_to_string_of_json()\n            .change_context(errors::VaultError::RequestEncodingFailed)\n            .attach_printable(\"Failed to encode card value1\")\n    }\n\n    fn get_value2(\n        &self,\n        customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        let value2 = domain::TokenizedCardValue2 {\n            card_security_code: Some(self.card_cvc.peek().clone()),\n            card_fingerprint: None,\n            external_id: None,\n            customer_id,\n            payment_method_id: None,\n        };\n\n        value2\n            .encode_to_string_of_json()\n            .change_context(errors::VaultError::RequestEncodingFailed)\n            .attach_printable(\"Failed to encode card value2\")\n    }\n\n    fn from_values(\n        value1: String,\n        value2: String,\n    ) -> CustomResult<(Self, SupplementaryVaultData), errors::VaultError> {\n        let value1: domain::TokenizedCardValue1 = value1\n            .parse_struct(\"TokenizedCardValue1\")\n            .change_context(errors::VaultError::ResponseDeserializationFailed)\n            .attach_printable(\"Could not deserialize into card value1\")?;\n\n        let value2: domain::TokenizedCardValue2 = value2\n            .parse_struct(\"TokenizedCardValue2\")\n            .change_context(errors::VaultError::ResponseDeserializationFailed)\n            .attach_printable(\"Could not deserialize into card value2\")?;\n\n        let card = Self {\n            card_number: cards::CardNumber::try_from(value1.card_number)\n                .change_context(errors::VaultError::ResponseDeserializationFailed)\n                .attach_printable(\"Invalid card number format from the mock locker\")?,\n            card_exp_month: value1.exp_month.into(),\n            card_exp_year: value1.exp_year.into(),\n            card_cvc: value2.card_security_code.unwrap_or_default().into(),\n            card_issuer: None,\n            card_network: None,\n            bank_code: None,\n            card_issuing_country: None,\n            card_issuing_country_code: None,",
    "function_name": "get_value1",
    "file": "crates__router__src__core__payment_methods__vault.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_value1",
    "code": "use common_enums::PaymentMethodType;\n#[cfg(feature = \"v2\")]\nuse common_utils::encryption::Encryption;\nuse common_utils::{\n    crypto::{DecodeMessage, EncodeMessage, GcmAes256},\n    ext_traits::{BytesExt, Encode},\n    generate_id_with_default_len, id_type,\n    pii::Email,\n    request,\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::router_flow_types::{\n    ExternalVaultDeleteFlow, ExternalVaultRetrieveFlow,\n};\nuse hyperswitch_domain_models::{\n    router_data_v2::flow_common_types::VaultConnectorFlowData, types::VaultRouterData,\n};\nuse masking::PeekInterface;\nuse router_env::{instrument, tracing};\nuse scheduler::{types::process_data, utils as process_tracker_utils};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::api::payouts;\nuse crate::{\n    consts,\n    core::{\n        errors::{self, ConnectorErrorExt, CustomResult, RouterResult},\n        payment_methods::transformers as pm_transforms,\n        payments, utils as core_utils,\n    },\n    db, headers, logger,\n    routes::{self, metrics},\n    services::{self, connector_integration_interface::RouterDataConversion},\n    settings,\n    types::{\n        self, api, domain, payment_methods as pm_types,\n        storage::{self, enums},\n    },\n    utils::{ConnectorResponseExt, StringExt},\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    core::{\n        errors::StorageErrorExt,\n        payment_methods::{cards as pm_cards, utils},\n        payments::{self as payments_core, helpers as payment_helpers},\n    },\n    utils::ext_traits::OptionExt,\n};\n\nconst VAULT_SERVICE_NAME: &str = \"CARD\";\n\npub struct SupplementaryVaultData {\n    pub customer_id: Option<id_type::CustomerId>,\n    pub payment_method_id: Option<String>,\n}\n\npub trait Vaultable: Sized {\n    fn get_value1(\n        &self,\n        customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError>;\n    fn get_value2(\n        &self,\n        _customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        Ok(String::new())\n    }\n    fn from_values(\n        value1: String,\n        value2: String,\n    ) -> CustomResult<(Self, SupplementaryVaultData), errors::VaultError>;\n}\n\nimpl Vaultable for domain::Card {\n    fn get_value1(\n        &self,\n        _customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        let value1 = domain::TokenizedCardValue1 {\n            card_number: self.card_number.peek().clone(),\n            exp_year: self.card_exp_year.peek().clone(),\n            exp_month: self.card_exp_month.peek().clone(),\n            nickname: self.nick_name.as_ref().map(|name| name.peek().clone()),\n            card_last_four: None,\n            card_token: None,\n            card_holder_name: self.card_holder_name.clone(),\n        };\n\n        value1\n            .encode_to_string_of_json()\n            .change_context(errors::VaultError::RequestEncodingFailed)\n            .attach_printable(\"Failed to encode card value1\")\n    }\n\n    fn get_value2(\n        &self,\n        customer_id: Option<id_type::CustomerId>,\n    ) -> CustomResult<String, errors::VaultError> {\n        let value2 = domain::TokenizedCardValue2 {\n            card_security_code: Some(self.card_cvc.peek().clone()),\n            card_fingerprint: None,\n            external_id: None,\n            customer_id,\n            payment_method_id: None,\n        };\n\n        value2\n            .encode_to_string_of_json()\n            .change_context(errors::VaultError::RequestEncodingFailed)\n            .attach_printable(\"Failed to encode card value2\")\n    }\n\n    fn from_values(\n        value1: String,\n        value2: String,\n    ) -> CustomResult<(Self, SupplementaryVaultData), errors::VaultError> {\n        let value1: domain::TokenizedCardValue1 = value1\n            .parse_struct(\"TokenizedCardValue1\")\n            .change_context(errors::VaultError::ResponseDeserializationFailed)\n            .attach_printable(\"Could not deserialize into card value1\")?;\n\n        let value2: domain::TokenizedCardValue2 = value2\n            .parse_struct(\"TokenizedCardValue2\")\n            .change_context(errors::VaultError::ResponseDeserializationFailed)\n            .attach_printable(\"Could not deserialize into card value2\")?;\n\n        let card = Self {\n            card_number: cards::CardNumber::try_from(value1.card_number)\n                .change_context(errors::VaultError::ResponseDeserializationFailed)\n                .attach_printable(\"Invalid card number format from the mock locker\")?,\n            card_exp_month: value1.exp_month.into(),\n            card_exp_year: value1.exp_year.into(),\n            card_cvc: value2.card_security_code.unwrap_or_default().into(),\n            card_issuer: None,\n            card_network: None,\n            bank_code: None,\n            card_issuing_country: None,\n            card_issuing_country_code: None,",
    "function_name": "get_value1",
    "file": "crates__router__src__core__payment_methods__vault.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__diesel_models__src__payment_method.rs",
    "code": "use std::collections::HashMap;\n\nuse common_enums::MerchantStorageScheme;\nuse common_utils::{\n    encryption::Encryption,\n    errors::{CustomResult, ParsingError},\n    pii,\n};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse masking::ExposeInterface;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::{enums as storage_enums, schema::payment_methods};\n#[cfg(feature = \"v2\")]\nuse crate::{enums as storage_enums, schema_v2::payment_methods};\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Identifiable, Queryable, Selectable, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods, primary_key(payment_method_id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    #[diesel(deserialize_as = super::OptionalDieselArray<storage_enums::Currency>)]\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    #[diesel(deserialize_as = super::OptionalDieselArray<String>)]\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub payment_method_data: Option<Encryption>,\n    pub locker_id: Option<String>,\n    pub last_used_at: PrimitiveDateTime,\n    pub connector_mandate_details: Option<serde_json::Value>,\n    pub customer_acceptance: Option<pii::SecretSerdeValue>,\n    pub status: storage_enums::PaymentMethodStatus,\n    pub network_transaction_id: Option<String>,\n    pub client_secret: Option<String>,\n    pub payment_method_billing_address: Option<Encryption>,\n    pub updated_by: Option<String>,\n    pub version: common_enums::ApiVersion,\n    pub network_token_requestor_reference_id: Option<String>,\n    pub network_token_locker_id: Option<String>,\n    pub network_token_payment_method_data: Option<Encryption>,\n    pub external_vault_source: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub vault_type: Option<storage_enums::VaultType>,\n    pub created_by: Option<String>,\n    pub last_modified_by: Option<String>,\n    pub customer_details: Option<Encryption>,\n    pub locker_fingerprint_id: Option<String>,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, Identifiable, Queryable, Selectable, Serialize, Deserialize)]\n#[diesel(table_name = payment_methods, primary_key(id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::GlobalCustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method_data: Option<Encryption>,\n    pub locker_id: Option<String>,\n    pub last_used_at: PrimitiveDateTime,\n    pub connector_mandate_details: Option<CommonMandateReference>,\n    pub customer_acceptance: Option<pii::SecretSerdeValue>,\n    pub status: storage_enums::PaymentMethodStatus,\n    pub network_transaction_id: Option<Secret<String>>,\n    pub client_secret: Option<String>,\n    pub payment_method_billing_address: Option<Encryption>,\n    pub updated_by: Option<String>,\n    pub version: common_enums::ApiVersion,\n    pub network_token_requestor_reference_id: Option<String>,\n    pub network_token_locker_id: Option<String>,\n    pub network_token_payment_method_data: Option<Encryption>,\n    pub external_vault_source: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub vault_type: Option<storage_enums::VaultType>,\n    pub created_by: Option<String>,\n    pub last_modified_by: Option<String>,\n    pub customer_details: Option<Encryption>,\n    pub locker_fingerprint_id: Option<String>,\n    pub payment_method_type_v2: Option<storage_enums::PaymentMethod>,\n    pub payment_method_subtype: Option<storage_enums::PaymentMethodType>,\n    pub id: common_utils::id_type::GlobalPaymentMethodId,\n    pub external_vault_token_data: Option<Encryption>,\n}\n\nimpl PaymentMethod {\n    #[cfg(feature = \"v1\")]\n    pub fn get_id(&self) -> &String {\n        &self.payment_method_id\n    }\n\n    #[cfg(feature = \"v2\")]\n    pub fn get_id(&self) -> &common_utils::id_type::GlobalPaymentMethodId {\n        &self.id\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Insertable, router_derive::DebugAsDisplay, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods)]\npub struct PaymentMethodNew {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,",
    "function_name": "get_id",
    "file": "crates__diesel_models__src__payment_method.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__diesel_models__src__payment_method.rs",
    "code": "use std::collections::HashMap;\n\nuse common_enums::MerchantStorageScheme;\nuse common_utils::{\n    encryption::Encryption,\n    errors::{CustomResult, ParsingError},\n    pii,\n};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse masking::ExposeInterface;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::{enums as storage_enums, schema::payment_methods};\n#[cfg(feature = \"v2\")]\nuse crate::{enums as storage_enums, schema_v2::payment_methods};\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Identifiable, Queryable, Selectable, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods, primary_key(payment_method_id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    #[diesel(deserialize_as = super::OptionalDieselArray<storage_enums::Currency>)]\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    #[diesel(deserialize_as = super::OptionalDieselArray<String>)]\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub payment_method_data: Option<Encryption>,\n    pub locker_id: Option<String>,\n    pub last_used_at: PrimitiveDateTime,\n    pub connector_mandate_details: Option<serde_json::Value>,\n    pub customer_acceptance: Option<pii::SecretSerdeValue>,\n    pub status: storage_enums::PaymentMethodStatus,\n    pub network_transaction_id: Option<String>,\n    pub client_secret: Option<String>,\n    pub payment_method_billing_address: Option<Encryption>,\n    pub updated_by: Option<String>,\n    pub version: common_enums::ApiVersion,\n    pub network_token_requestor_reference_id: Option<String>,\n    pub network_token_locker_id: Option<String>,\n    pub network_token_payment_method_data: Option<Encryption>,\n    pub external_vault_source: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub vault_type: Option<storage_enums::VaultType>,\n    pub created_by: Option<String>,\n    pub last_modified_by: Option<String>,\n    pub customer_details: Option<Encryption>,\n    pub locker_fingerprint_id: Option<String>,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, Identifiable, Queryable, Selectable, Serialize, Deserialize)]\n#[diesel(table_name = payment_methods, primary_key(id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::GlobalCustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method_data: Option<Encryption>,\n    pub locker_id: Option<String>,\n    pub last_used_at: PrimitiveDateTime,\n    pub connector_mandate_details: Option<CommonMandateReference>,\n    pub customer_acceptance: Option<pii::SecretSerdeValue>,\n    pub status: storage_enums::PaymentMethodStatus,\n    pub network_transaction_id: Option<Secret<String>>,\n    pub client_secret: Option<String>,\n    pub payment_method_billing_address: Option<Encryption>,\n    pub updated_by: Option<String>,\n    pub version: common_enums::ApiVersion,\n    pub network_token_requestor_reference_id: Option<String>,\n    pub network_token_locker_id: Option<String>,\n    pub network_token_payment_method_data: Option<Encryption>,\n    pub external_vault_source: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub vault_type: Option<storage_enums::VaultType>,\n    pub created_by: Option<String>,\n    pub last_modified_by: Option<String>,\n    pub customer_details: Option<Encryption>,\n    pub locker_fingerprint_id: Option<String>,\n    pub payment_method_type_v2: Option<storage_enums::PaymentMethod>,\n    pub payment_method_subtype: Option<storage_enums::PaymentMethodType>,\n    pub id: common_utils::id_type::GlobalPaymentMethodId,\n    pub external_vault_token_data: Option<Encryption>,\n}\n\nimpl PaymentMethod {\n    #[cfg(feature = \"v1\")]\n    pub fn get_id(&self) -> &String {\n        &self.payment_method_id\n    }\n\n    #[cfg(feature = \"v2\")]\n    pub fn get_id(&self) -> &common_utils::id_type::GlobalPaymentMethodId {\n        &self.id\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Insertable, router_derive::DebugAsDisplay, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods)]\npub struct PaymentMethodNew {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,",
    "function_name": "get_id",
    "file": "crates__diesel_models__src__payment_method.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_id",
    "code": "use std::collections::HashMap;\n\nuse common_enums::MerchantStorageScheme;\nuse common_utils::{\n    encryption::Encryption,\n    errors::{CustomResult, ParsingError},\n    pii,\n};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v1\")]\nuse masking::ExposeInterface;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::{enums as storage_enums, schema::payment_methods};\n#[cfg(feature = \"v2\")]\nuse crate::{enums as storage_enums, schema_v2::payment_methods};\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Identifiable, Queryable, Selectable, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods, primary_key(payment_method_id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    #[diesel(deserialize_as = super::OptionalDieselArray<storage_enums::Currency>)]\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    #[diesel(deserialize_as = super::OptionalDieselArray<String>)]\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub payment_method_data: Option<Encryption>,\n    pub locker_id: Option<String>,\n    pub last_used_at: PrimitiveDateTime,\n    pub connector_mandate_details: Option<serde_json::Value>,\n    pub customer_acceptance: Option<pii::SecretSerdeValue>,\n    pub status: storage_enums::PaymentMethodStatus,\n    pub network_transaction_id: Option<String>,\n    pub client_secret: Option<String>,\n    pub payment_method_billing_address: Option<Encryption>,\n    pub updated_by: Option<String>,\n    pub version: common_enums::ApiVersion,\n    pub network_token_requestor_reference_id: Option<String>,\n    pub network_token_locker_id: Option<String>,\n    pub network_token_payment_method_data: Option<Encryption>,\n    pub external_vault_source: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub vault_type: Option<storage_enums::VaultType>,\n    pub created_by: Option<String>,\n    pub last_modified_by: Option<String>,\n    pub customer_details: Option<Encryption>,\n    pub locker_fingerprint_id: Option<String>,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug, Identifiable, Queryable, Selectable, Serialize, Deserialize)]\n#[diesel(table_name = payment_methods, primary_key(id), check_for_backend(diesel::pg::Pg))]\npub struct PaymentMethod {\n    pub customer_id: common_utils::id_type::GlobalCustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub created_at: PrimitiveDateTime,\n    pub last_modified: PrimitiveDateTime,\n    pub payment_method_data: Option<Encryption>,\n    pub locker_id: Option<String>,\n    pub last_used_at: PrimitiveDateTime,\n    pub connector_mandate_details: Option<CommonMandateReference>,\n    pub customer_acceptance: Option<pii::SecretSerdeValue>,\n    pub status: storage_enums::PaymentMethodStatus,\n    pub network_transaction_id: Option<Secret<String>>,\n    pub client_secret: Option<String>,\n    pub payment_method_billing_address: Option<Encryption>,\n    pub updated_by: Option<String>,\n    pub version: common_enums::ApiVersion,\n    pub network_token_requestor_reference_id: Option<String>,\n    pub network_token_locker_id: Option<String>,\n    pub network_token_payment_method_data: Option<Encryption>,\n    pub external_vault_source: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub vault_type: Option<storage_enums::VaultType>,\n    pub created_by: Option<String>,\n    pub last_modified_by: Option<String>,\n    pub customer_details: Option<Encryption>,\n    pub locker_fingerprint_id: Option<String>,\n    pub payment_method_type_v2: Option<storage_enums::PaymentMethod>,\n    pub payment_method_subtype: Option<storage_enums::PaymentMethodType>,\n    pub id: common_utils::id_type::GlobalPaymentMethodId,\n    pub external_vault_token_data: Option<Encryption>,\n}\n\nimpl PaymentMethod {\n    #[cfg(feature = \"v1\")]\n    pub fn get_id(&self) -> &String {\n        &self.payment_method_id\n    }\n\n    #[cfg(feature = \"v2\")]\n    pub fn get_id(&self) -> &common_utils::id_type::GlobalPaymentMethodId {\n        &self.id\n    }\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(\n    Clone, Debug, Eq, PartialEq, Insertable, router_derive::DebugAsDisplay, Serialize, Deserialize,\n)]\n#[diesel(table_name = payment_methods)]\npub struct PaymentMethodNew {\n    pub customer_id: common_utils::id_type::CustomerId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub payment_method_id: String,\n    pub payment_method: Option<storage_enums::PaymentMethod>,\n    pub payment_method_type: Option<storage_enums::PaymentMethodType>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuer_code: Option<storage_enums::PaymentMethodIssuerCode>,\n    pub accepted_currency: Option<Vec<storage_enums::Currency>>,\n    pub scheme: Option<String>,\n    pub token: Option<String>,\n    pub cardholder_name: Option<Secret<String>>,\n    pub issuer_name: Option<String>,\n    pub issuer_country: Option<String>,\n    pub payer_country: Option<Vec<String>>,\n    pub is_stored: Option<bool>,\n    pub swift_code: Option<String>,\n    pub direct_debit_token: Option<String>,",
    "function_name": "get_id",
    "file": "crates__diesel_models__src__payment_method.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs",
    "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        UasAuthenticationConfirmationRouterData, UasAuthenticationRouterData,\n        UasPostAuthenticationRouterData, UasPreAuthenticationRouterData,\n        UasProcessWebhookRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as unified_authentication_service;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct UnifiedAuthenticationService {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl UnifiedAuthenticationService {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for UnifiedAuthenticationService {}\nimpl api::PaymentSession for UnifiedAuthenticationService {}\nimpl api::ConnectorAccessToken for UnifiedAuthenticationService {}\nimpl api::MandateSetup for UnifiedAuthenticationService {}\nimpl api::PaymentAuthorize for UnifiedAuthenticationService {}\nimpl api::PaymentSync for UnifiedAuthenticationService {}\nimpl api::PaymentCapture for UnifiedAuthenticationService {}\nimpl api::PaymentVoid for UnifiedAuthenticationService {}\nimpl api::Refund for UnifiedAuthenticationService {}\nimpl api::RefundExecute for UnifiedAuthenticationService {}\nimpl api::RefundSync for UnifiedAuthenticationService {}\nimpl api::PaymentToken for UnifiedAuthenticationService {}\nimpl api::UnifiedAuthenticationService for UnifiedAuthenticationService {}\nimpl api::UasPreAuthentication for UnifiedAuthenticationService {}\nimpl api::UasPostAuthentication for UnifiedAuthenticationService {}\nimpl api::UasAuthenticationConfirmation for UnifiedAuthenticationService {}\nimpl api::UasAuthentication for UnifiedAuthenticationService {}\nimpl api::UasProcessWebhook for UnifiedAuthenticationService {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for UnifiedAuthenticationService\n{\n}\n\nimpl ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>\n    for UnifiedAuthenticationService\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response>\n    for UnifiedAuthenticationService\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::SOURCE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for UnifiedAuthenticationService {\n    fn id(&self) -> &'static str {\n        \"unified_authentication_service\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.unified_authentication_service.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: unified_authentication_service::UnifiedAuthenticationServiceErrorResponse =",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs",
    "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        UasAuthenticationConfirmationRouterData, UasAuthenticationRouterData,\n        UasPostAuthenticationRouterData, UasPreAuthenticationRouterData,\n        UasProcessWebhookRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as unified_authentication_service;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct UnifiedAuthenticationService {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl UnifiedAuthenticationService {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for UnifiedAuthenticationService {}\nimpl api::PaymentSession for UnifiedAuthenticationService {}\nimpl api::ConnectorAccessToken for UnifiedAuthenticationService {}\nimpl api::MandateSetup for UnifiedAuthenticationService {}\nimpl api::PaymentAuthorize for UnifiedAuthenticationService {}\nimpl api::PaymentSync for UnifiedAuthenticationService {}\nimpl api::PaymentCapture for UnifiedAuthenticationService {}\nimpl api::PaymentVoid for UnifiedAuthenticationService {}\nimpl api::Refund for UnifiedAuthenticationService {}\nimpl api::RefundExecute for UnifiedAuthenticationService {}\nimpl api::RefundSync for UnifiedAuthenticationService {}\nimpl api::PaymentToken for UnifiedAuthenticationService {}\nimpl api::UnifiedAuthenticationService for UnifiedAuthenticationService {}\nimpl api::UasPreAuthentication for UnifiedAuthenticationService {}\nimpl api::UasPostAuthentication for UnifiedAuthenticationService {}\nimpl api::UasAuthenticationConfirmation for UnifiedAuthenticationService {}\nimpl api::UasAuthentication for UnifiedAuthenticationService {}\nimpl api::UasProcessWebhook for UnifiedAuthenticationService {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for UnifiedAuthenticationService\n{\n}\n\nimpl ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>\n    for UnifiedAuthenticationService\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response>\n    for UnifiedAuthenticationService\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::SOURCE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for UnifiedAuthenticationService {\n    fn id(&self) -> &'static str {\n        \"unified_authentication_service\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.unified_authentication_service.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: unified_authentication_service::UnifiedAuthenticationServiceErrorResponse =",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        Authenticate, AuthenticationConfirmation, PostAuthenticate, PreAuthenticate,\n        ProcessIncomingWebhook,\n    },\n    router_request_types::{\n        unified_authentication_service::{\n            UasAuthenticationRequestData, UasAuthenticationResponseData,\n            UasConfirmationRequestData, UasPostAuthenticationRequestData,\n            UasPreAuthenticationRequestData, UasWebhookRequestData,\n        },\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        UasAuthenticationConfirmationRouterData, UasAuthenticationRouterData,\n        UasPostAuthenticationRouterData, UasPreAuthenticationRouterData,\n        UasProcessWebhookRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::PeekInterface;\nuse transformers as unified_authentication_service;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct UnifiedAuthenticationService {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl UnifiedAuthenticationService {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for UnifiedAuthenticationService {}\nimpl api::PaymentSession for UnifiedAuthenticationService {}\nimpl api::ConnectorAccessToken for UnifiedAuthenticationService {}\nimpl api::MandateSetup for UnifiedAuthenticationService {}\nimpl api::PaymentAuthorize for UnifiedAuthenticationService {}\nimpl api::PaymentSync for UnifiedAuthenticationService {}\nimpl api::PaymentCapture for UnifiedAuthenticationService {}\nimpl api::PaymentVoid for UnifiedAuthenticationService {}\nimpl api::Refund for UnifiedAuthenticationService {}\nimpl api::RefundExecute for UnifiedAuthenticationService {}\nimpl api::RefundSync for UnifiedAuthenticationService {}\nimpl api::PaymentToken for UnifiedAuthenticationService {}\nimpl api::UnifiedAuthenticationService for UnifiedAuthenticationService {}\nimpl api::UasPreAuthentication for UnifiedAuthenticationService {}\nimpl api::UasPostAuthentication for UnifiedAuthenticationService {}\nimpl api::UasAuthenticationConfirmation for UnifiedAuthenticationService {}\nimpl api::UasAuthentication for UnifiedAuthenticationService {}\nimpl api::UasProcessWebhook for UnifiedAuthenticationService {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for UnifiedAuthenticationService\n{\n}\n\nimpl ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>\n    for UnifiedAuthenticationService\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response>\n    for UnifiedAuthenticationService\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::SOURCE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for UnifiedAuthenticationService {\n    fn id(&self) -> &'static str {\n        \"unified_authentication_service\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.unified_authentication_service.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: unified_authentication_service::UnifiedAuthenticationServiceErrorResponse =",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__unified_authentication_service.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__trustpay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsPreProcessingType, PaymentsSyncType,\n        RefreshTokenType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as trustpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, self as connector_utils, ConnectorErrorType, PaymentsPreProcessingRequestData},\n};\n\n#[derive(Clone)]\npub struct Trustpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n    amount_converter_to_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Trustpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_float_major_unit: &FloatMajorUnitForConnector,\n            amount_converter_to_string_minor_unit: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Trustpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        match req.payment_method {\n            enums::PaymentMethod::BankRedirect | enums::PaymentMethod::BankTransfer => {\n                let token = req\n                    .access_token\n                    .clone()\n                    .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n                Ok(vec![\n                    (\n                        headers::CONTENT_TYPE.to_string(),\n                        \"application/json\".to_owned().into(),\n                    ),\n                    (\n                        headers::AUTHORIZATION.to_string(),\n                        format!(\"Bearer {}\", token.token.peek()).into_masked(),\n                    ),\n                ])\n            }\n            _ => {\n                let mut header = vec![(\n                    headers::CONTENT_TYPE.to_string(),\n                    self.get_content_type().to_string().into(),\n                )];\n                let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n                header.append(&mut api_key);\n                Ok(header)\n            }\n        }\n    }\n}\n\nimpl ConnectorCommon for Trustpay {\n    fn id(&self) -> &'static str {\n        \"trustpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.trustpay.base_url.as_ref()\n    }\n\n    fn get_auth_header(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__trustpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__trustpay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsPreProcessingType, PaymentsSyncType,\n        RefreshTokenType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as trustpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, self as connector_utils, ConnectorErrorType, PaymentsPreProcessingRequestData},\n};\n\n#[derive(Clone)]\npub struct Trustpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n    amount_converter_to_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Trustpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_float_major_unit: &FloatMajorUnitForConnector,\n            amount_converter_to_string_minor_unit: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Trustpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        match req.payment_method {\n            enums::PaymentMethod::BankRedirect | enums::PaymentMethod::BankTransfer => {\n                let token = req\n                    .access_token\n                    .clone()\n                    .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n                Ok(vec![\n                    (\n                        headers::CONTENT_TYPE.to_string(),\n                        \"application/json\".to_owned().into(),\n                    ),\n                    (\n                        headers::AUTHORIZATION.to_string(),\n                        format!(\"Bearer {}\", token.token.peek()).into_masked(),\n                    ),\n                ])\n            }\n            _ => {\n                let mut header = vec![(\n                    headers::CONTENT_TYPE.to_string(),\n                    self.get_content_type().to_string().into(),\n                )];\n                let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n                header.append(&mut api_key);\n                Ok(header)\n            }\n        }\n    }\n}\n\nimpl ConnectorCommon for Trustpay {\n    fn id(&self) -> &'static str {\n        \"trustpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.trustpay.base_url.as_ref()\n    }\n\n    fn get_auth_header(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__trustpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateOrder, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CreateOrderRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsPreProcessingRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        CreateOrderType, PaymentsAuthorizeType, PaymentsPreProcessingType, PaymentsSyncType,\n        RefreshTokenType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as trustpay;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, self as connector_utils, ConnectorErrorType, PaymentsPreProcessingRequestData},\n};\n\n#[derive(Clone)]\npub struct Trustpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n    amount_converter_to_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Trustpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_float_major_unit: &FloatMajorUnitForConnector,\n            amount_converter_to_string_minor_unit: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Trustpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        match req.payment_method {\n            enums::PaymentMethod::BankRedirect | enums::PaymentMethod::BankTransfer => {\n                let token = req\n                    .access_token\n                    .clone()\n                    .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n                Ok(vec![\n                    (\n                        headers::CONTENT_TYPE.to_string(),\n                        \"application/json\".to_owned().into(),\n                    ),\n                    (\n                        headers::AUTHORIZATION.to_string(),\n                        format!(\"Bearer {}\", token.token.peek()).into_masked(),\n                    ),\n                ])\n            }\n            _ => {\n                let mut header = vec![(\n                    headers::CONTENT_TYPE.to_string(),\n                    self.get_content_type().to_string().into(),\n                )];\n                let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n                header.append(&mut api_key);\n                Ok(header)\n            }\n        }\n    }\n}\n\nimpl ConnectorCommon for Trustpay {\n    fn id(&self) -> &'static str {\n        \"trustpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.trustpay.base_url.as_ref()\n    }\n\n    fn get_auth_header(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__trustpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__analytics__src__clickhouse.rs",
    "code": "use std::sync::Arc;\n\nuse actix_web::http::StatusCode;\nuse common_utils::errors::ParsingError;\nuse error_stack::{report, Report, ResultExt};\nuse router_env::logger;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    active_payments::metrics::ActivePaymentsMetricRow,\n    auth_events::metrics::AuthEventMetricRow,\n    frm::{filters::FrmFilterRow, metrics::FrmMetricRow},\n    health_check::HealthCheck,\n    payment_intents::{filters::PaymentIntentFilterRow, metrics::PaymentIntentMetricRow},\n    payments::{\n        distribution::PaymentDistributionRow, filters::PaymentFilterRow, metrics::PaymentMetricRow,\n    },\n    query::{Aggregate, ToSql, Window},\n    refunds::{\n        distribution::RefundDistributionRow, filters::RefundFilterRow, metrics::RefundMetricRow,\n    },\n    sdk_events::{filters::SdkEventFilter, metrics::SdkEventMetricRow},\n    types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, QueryExecutionError},\n};\nuse crate::{\n    api_event::{\n        events::ApiLogsResult,\n        filters::ApiEventFilter,\n        metrics::{latency::LatencyAvg, ApiEventMetricRow},\n    },\n    auth_events::filters::AuthEventFilterRow,\n    connector_events::events::ConnectorEventsResult,\n    disputes::{filters::DisputeFilterRow, metrics::DisputeMetricRow},\n    outgoing_webhook_event::events::OutgoingWebhookLogsResult,\n    routing_events::events::RoutingEventsResult,\n    sdk_events::events::SdkEventsResult,\n    types::TableEngine,\n};\n\npub type ClickhouseResult<T> = error_stack::Result<T, ClickhouseError>;\n\n#[derive(Clone, Debug)]\npub struct ClickhouseClient {\n    pub config: Arc<ClickhouseConfig>,\n    pub database: String,\n}\n\n#[derive(Clone, Debug, serde::Deserialize)]\npub struct ClickhouseConfig {\n    username: String,\n    password: Option<String>,\n    host: String,\n}\n\nimpl Default for ClickhouseConfig {\n    fn default() -> Self {\n        Self {\n            username: \"default\".to_string(),\n            password: None,\n            host: \"http://localhost:8123\".to_string(),\n        }\n    }\n}\n\nimpl ClickhouseClient {\n    async fn execute_query(&self, query: &str) -> ClickhouseResult<Vec<serde_json::Value>> {\n        logger::debug!(\"Executing query: {query}\");\n        let client = reqwest::Client::new();\n        let params = CkhQuery {\n            date_time_output_format: String::from(\"iso\"),\n            output_format_json_quote_64bit_integers: 0,\n            database: self.database.clone(),\n        };\n        let response = client\n            .post(&self.config.host)\n            .query(&params)\n            .basic_auth(self.config.username.clone(), self.config.password.clone())\n            .body(format!(\"{query}\\nFORMAT JSON\"))\n            .send()\n            .await\n            .change_context(ClickhouseError::ConnectionError)?;\n\n        logger::debug!(clickhouse_response=?response, query=?query, \"Clickhouse response\");\n        if response.status() != StatusCode::OK {\n            response.text().await.map_or_else(\n                |er| {\n                    Err(ClickhouseError::ResponseError)\n                        .attach_printable_lazy(|| format!(\"Error: {er:?}\"))\n                },\n                |t| Err(report!(ClickhouseError::ResponseNotOK(t))),\n            )\n        } else {\n            Ok(response\n                .json::<CkhOutput<serde_json::Value>>()\n                .await\n                .change_context(ClickhouseError::ResponseError)?\n                .data)\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl HealthCheck for ClickhouseClient {\n    async fn deep_health_check(\n        &self,\n    ) -> common_utils::errors::CustomResult<(), QueryExecutionError> {\n        self.execute_query(\"SELECT 1\")\n            .await\n            .map(|_| ())\n            .change_context(QueryExecutionError::DatabaseError)\n    }\n}\n\n#[async_trait::async_trait]\nimpl AnalyticsDataSource for ClickhouseClient {\n    type Row = serde_json::Value;\n\n    async fn load_results<T>(\n        &self,\n        query: &str,\n    ) -> common_utils::errors::CustomResult<Vec<T>, QueryExecutionError>\n    where\n        Self: LoadRow<T>,\n    {\n        self.execute_query(query)\n            .await\n            .change_context(QueryExecutionError::DatabaseError)?\n            .into_iter()\n            .map(Self::load_row)\n            .collect::<Result<Vec<_>, _>>()\n            .change_context(QueryExecutionError::RowExtractionFailure)\n    }\n\n    fn get_table_engine(table: AnalyticsCollection) -> TableEngine {\n        match table {\n            AnalyticsCollection::Payment\n            | AnalyticsCollection::PaymentSessionized\n            | AnalyticsCollection::Refund\n            | AnalyticsCollection::RefundSessionized\n            | AnalyticsCollection::FraudCheck",
    "function_name": "default",
    "file": "crates__analytics__src__clickhouse.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__analytics__src__clickhouse.rs",
    "code": "use std::sync::Arc;\n\nuse actix_web::http::StatusCode;\nuse common_utils::errors::ParsingError;\nuse error_stack::{report, Report, ResultExt};\nuse router_env::logger;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    active_payments::metrics::ActivePaymentsMetricRow,\n    auth_events::metrics::AuthEventMetricRow,\n    frm::{filters::FrmFilterRow, metrics::FrmMetricRow},\n    health_check::HealthCheck,\n    payment_intents::{filters::PaymentIntentFilterRow, metrics::PaymentIntentMetricRow},\n    payments::{\n        distribution::PaymentDistributionRow, filters::PaymentFilterRow, metrics::PaymentMetricRow,\n    },\n    query::{Aggregate, ToSql, Window},\n    refunds::{\n        distribution::RefundDistributionRow, filters::RefundFilterRow, metrics::RefundMetricRow,\n    },\n    sdk_events::{filters::SdkEventFilter, metrics::SdkEventMetricRow},\n    types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, QueryExecutionError},\n};\nuse crate::{\n    api_event::{\n        events::ApiLogsResult,\n        filters::ApiEventFilter,\n        metrics::{latency::LatencyAvg, ApiEventMetricRow},\n    },\n    auth_events::filters::AuthEventFilterRow,\n    connector_events::events::ConnectorEventsResult,\n    disputes::{filters::DisputeFilterRow, metrics::DisputeMetricRow},\n    outgoing_webhook_event::events::OutgoingWebhookLogsResult,\n    routing_events::events::RoutingEventsResult,\n    sdk_events::events::SdkEventsResult,\n    types::TableEngine,\n};\n\npub type ClickhouseResult<T> = error_stack::Result<T, ClickhouseError>;\n\n#[derive(Clone, Debug)]\npub struct ClickhouseClient {\n    pub config: Arc<ClickhouseConfig>,\n    pub database: String,\n}\n\n#[derive(Clone, Debug, serde::Deserialize)]\npub struct ClickhouseConfig {\n    username: String,\n    password: Option<String>,\n    host: String,\n}\n\nimpl Default for ClickhouseConfig {\n    fn default() -> Self {\n        Self {\n            username: \"default\".to_string(),\n            password: None,\n            host: \"http://localhost:8123\".to_string(),\n        }\n    }\n}\n\nimpl ClickhouseClient {\n    async fn execute_query(&self, query: &str) -> ClickhouseResult<Vec<serde_json::Value>> {\n        logger::debug!(\"Executing query: {query}\");\n        let client = reqwest::Client::new();\n        let params = CkhQuery {\n            date_time_output_format: String::from(\"iso\"),\n            output_format_json_quote_64bit_integers: 0,\n            database: self.database.clone(),\n        };\n        let response = client\n            .post(&self.config.host)\n            .query(&params)\n            .basic_auth(self.config.username.clone(), self.config.password.clone())\n            .body(format!(\"{query}\\nFORMAT JSON\"))\n            .send()\n            .await\n            .change_context(ClickhouseError::ConnectionError)?;\n\n        logger::debug!(clickhouse_response=?response, query=?query, \"Clickhouse response\");\n        if response.status() != StatusCode::OK {\n            response.text().await.map_or_else(\n                |er| {\n                    Err(ClickhouseError::ResponseError)\n                        .attach_printable_lazy(|| format!(\"Error: {er:?}\"))\n                },\n                |t| Err(report!(ClickhouseError::ResponseNotOK(t))),\n            )\n        } else {\n            Ok(response\n                .json::<CkhOutput<serde_json::Value>>()\n                .await\n                .change_context(ClickhouseError::ResponseError)?\n                .data)\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl HealthCheck for ClickhouseClient {\n    async fn deep_health_check(\n        &self,\n    ) -> common_utils::errors::CustomResult<(), QueryExecutionError> {\n        self.execute_query(\"SELECT 1\")\n            .await\n            .map(|_| ())\n            .change_context(QueryExecutionError::DatabaseError)\n    }\n}\n\n#[async_trait::async_trait]\nimpl AnalyticsDataSource for ClickhouseClient {\n    type Row = serde_json::Value;\n\n    async fn load_results<T>(\n        &self,\n        query: &str,\n    ) -> common_utils::errors::CustomResult<Vec<T>, QueryExecutionError>\n    where\n        Self: LoadRow<T>,\n    {\n        self.execute_query(query)\n            .await\n            .change_context(QueryExecutionError::DatabaseError)?\n            .into_iter()\n            .map(Self::load_row)\n            .collect::<Result<Vec<_>, _>>()\n            .change_context(QueryExecutionError::RowExtractionFailure)\n    }\n\n    fn get_table_engine(table: AnalyticsCollection) -> TableEngine {\n        match table {\n            AnalyticsCollection::Payment\n            | AnalyticsCollection::PaymentSessionized\n            | AnalyticsCollection::Refund\n            | AnalyticsCollection::RefundSessionized\n            | AnalyticsCollection::FraudCheck",
    "function_name": "default",
    "file": "crates__analytics__src__clickhouse.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for default",
    "code": "use std::sync::Arc;\n\nuse actix_web::http::StatusCode;\nuse common_utils::errors::ParsingError;\nuse error_stack::{report, Report, ResultExt};\nuse router_env::logger;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    active_payments::metrics::ActivePaymentsMetricRow,\n    auth_events::metrics::AuthEventMetricRow,\n    frm::{filters::FrmFilterRow, metrics::FrmMetricRow},\n    health_check::HealthCheck,\n    payment_intents::{filters::PaymentIntentFilterRow, metrics::PaymentIntentMetricRow},\n    payments::{\n        distribution::PaymentDistributionRow, filters::PaymentFilterRow, metrics::PaymentMetricRow,\n    },\n    query::{Aggregate, ToSql, Window},\n    refunds::{\n        distribution::RefundDistributionRow, filters::RefundFilterRow, metrics::RefundMetricRow,\n    },\n    sdk_events::{filters::SdkEventFilter, metrics::SdkEventMetricRow},\n    types::{AnalyticsCollection, AnalyticsDataSource, LoadRow, QueryExecutionError},\n};\nuse crate::{\n    api_event::{\n        events::ApiLogsResult,\n        filters::ApiEventFilter,\n        metrics::{latency::LatencyAvg, ApiEventMetricRow},\n    },\n    auth_events::filters::AuthEventFilterRow,\n    connector_events::events::ConnectorEventsResult,\n    disputes::{filters::DisputeFilterRow, metrics::DisputeMetricRow},\n    outgoing_webhook_event::events::OutgoingWebhookLogsResult,\n    routing_events::events::RoutingEventsResult,\n    sdk_events::events::SdkEventsResult,\n    types::TableEngine,\n};\n\npub type ClickhouseResult<T> = error_stack::Result<T, ClickhouseError>;\n\n#[derive(Clone, Debug)]\npub struct ClickhouseClient {\n    pub config: Arc<ClickhouseConfig>,\n    pub database: String,\n}\n\n#[derive(Clone, Debug, serde::Deserialize)]\npub struct ClickhouseConfig {\n    username: String,\n    password: Option<String>,\n    host: String,\n}\n\nimpl Default for ClickhouseConfig {\n    fn default() -> Self {\n        Self {\n            username: \"default\".to_string(),\n            password: None,\n            host: \"http://localhost:8123\".to_string(),\n        }\n    }\n}\n\nimpl ClickhouseClient {\n    async fn execute_query(&self, query: &str) -> ClickhouseResult<Vec<serde_json::Value>> {\n        logger::debug!(\"Executing query: {query}\");\n        let client = reqwest::Client::new();\n        let params = CkhQuery {\n            date_time_output_format: String::from(\"iso\"),\n            output_format_json_quote_64bit_integers: 0,\n            database: self.database.clone(),\n        };\n        let response = client\n            .post(&self.config.host)\n            .query(&params)\n            .basic_auth(self.config.username.clone(), self.config.password.clone())\n            .body(format!(\"{query}\\nFORMAT JSON\"))\n            .send()\n            .await\n            .change_context(ClickhouseError::ConnectionError)?;\n\n        logger::debug!(clickhouse_response=?response, query=?query, \"Clickhouse response\");\n        if response.status() != StatusCode::OK {\n            response.text().await.map_or_else(\n                |er| {\n                    Err(ClickhouseError::ResponseError)\n                        .attach_printable_lazy(|| format!(\"Error: {er:?}\"))\n                },\n                |t| Err(report!(ClickhouseError::ResponseNotOK(t))),\n            )\n        } else {\n            Ok(response\n                .json::<CkhOutput<serde_json::Value>>()\n                .await\n                .change_context(ClickhouseError::ResponseError)?\n                .data)\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl HealthCheck for ClickhouseClient {\n    async fn deep_health_check(\n        &self,\n    ) -> common_utils::errors::CustomResult<(), QueryExecutionError> {\n        self.execute_query(\"SELECT 1\")\n            .await\n            .map(|_| ())\n            .change_context(QueryExecutionError::DatabaseError)\n    }\n}\n\n#[async_trait::async_trait]\nimpl AnalyticsDataSource for ClickhouseClient {\n    type Row = serde_json::Value;\n\n    async fn load_results<T>(\n        &self,\n        query: &str,\n    ) -> common_utils::errors::CustomResult<Vec<T>, QueryExecutionError>\n    where\n        Self: LoadRow<T>,\n    {\n        self.execute_query(query)\n            .await\n            .change_context(QueryExecutionError::DatabaseError)?\n            .into_iter()\n            .map(Self::load_row)\n            .collect::<Result<Vec<_>, _>>()\n            .change_context(QueryExecutionError::RowExtractionFailure)\n    }\n\n    fn get_table_engine(table: AnalyticsCollection) -> TableEngine {\n        match table {\n            AnalyticsCollection::Payment\n            | AnalyticsCollection::PaymentSessionized\n            | AnalyticsCollection::Refund\n            | AnalyticsCollection::RefundSessionized\n            | AnalyticsCollection::FraudCheck",
    "function_name": "default",
    "file": "crates__analytics__src__clickhouse.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__noon.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{ConnectorWebhookSecrets, IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, MandateRevokeRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        MandateRevokeType, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType,\n        PaymentsVoidType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as noon;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self as connector_utils, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Noon {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Noon {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Noon {}\nimpl api::PaymentSession for Noon {}\nimpl api::ConnectorAccessToken for Noon {}\nimpl api::MandateSetup for Noon {}\nimpl api::PaymentAuthorize for Noon {}\nimpl api::PaymentSync for Noon {}\nimpl api::PaymentCapture for Noon {}\nimpl api::PaymentVoid for Noon {}\nimpl api::Refund for Noon {}\nimpl api::RefundExecute for Noon {}\nimpl api::RefundSync for Noon {}\nimpl api::PaymentToken for Noon {}\nimpl api::ConnectorMandateRevoke for Noon {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Noon\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Noon\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nfn get_auth_header(\n    auth_type: &ConnectorAuthType,\n) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n    let auth = noon::NoonAuthType::try_from(auth_type)?;\n\n    let encoded_api_key = auth\n        .business_identifier\n        .zip(auth.application_identifier)\n        .zip(auth.api_key)\n        .map(|((business_identifier, application_identifier), api_key)| {\n            common_utils::consts::BASE64_ENGINE.encode(format!(\n                \"{business_identifier}.{application_identifier}:{api_key}\",\n            ))\n        });\n\n    Ok(vec![(\n        headers::AUTHORIZATION.to_string(),\n        format!(\"Key {}\", encoded_api_key.peek()).into_masked(),\n    )])\n}\n\nimpl ConnectorCommon for Noon {\n    fn id(&self) -> &'static str {\n        \"noon\"\n    }",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__noon.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__noon.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{ConnectorWebhookSecrets, IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, MandateRevokeRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        MandateRevokeType, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType,\n        PaymentsVoidType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as noon;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self as connector_utils, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Noon {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Noon {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Noon {}\nimpl api::PaymentSession for Noon {}\nimpl api::ConnectorAccessToken for Noon {}\nimpl api::MandateSetup for Noon {}\nimpl api::PaymentAuthorize for Noon {}\nimpl api::PaymentSync for Noon {}\nimpl api::PaymentCapture for Noon {}\nimpl api::PaymentVoid for Noon {}\nimpl api::Refund for Noon {}\nimpl api::RefundExecute for Noon {}\nimpl api::RefundSync for Noon {}\nimpl api::PaymentToken for Noon {}\nimpl api::ConnectorMandateRevoke for Noon {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Noon\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Noon\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nfn get_auth_header(\n    auth_type: &ConnectorAuthType,\n) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n    let auth = noon::NoonAuthType::try_from(auth_type)?;\n\n    let encoded_api_key = auth\n        .business_identifier\n        .zip(auth.application_identifier)\n        .zip(auth.api_key)\n        .map(|((business_identifier, application_identifier), api_key)| {\n            common_utils::consts::BASE64_ENGINE.encode(format!(\n                \"{business_identifier}.{application_identifier}:{api_key}\",\n            ))\n        });\n\n    Ok(vec![(\n        headers::AUTHORIZATION.to_string(),\n        format!(\"Key {}\", encoded_api_key.peek()).into_masked(),\n    )])\n}\n\nimpl ConnectorCommon for Noon {\n    fn id(&self) -> &'static str {\n        \"noon\"\n    }",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__noon.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{ConnectorWebhookSecrets, IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, MandateRevokeRequestData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        MandateRevokeType, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType,\n        PaymentsVoidType, RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as noon;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self as connector_utils, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Noon {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Noon {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Noon {}\nimpl api::PaymentSession for Noon {}\nimpl api::ConnectorAccessToken for Noon {}\nimpl api::MandateSetup for Noon {}\nimpl api::PaymentAuthorize for Noon {}\nimpl api::PaymentSync for Noon {}\nimpl api::PaymentCapture for Noon {}\nimpl api::PaymentVoid for Noon {}\nimpl api::Refund for Noon {}\nimpl api::RefundExecute for Noon {}\nimpl api::RefundSync for Noon {}\nimpl api::PaymentToken for Noon {}\nimpl api::ConnectorMandateRevoke for Noon {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Noon\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Noon\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nfn get_auth_header(\n    auth_type: &ConnectorAuthType,\n) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n    let auth = noon::NoonAuthType::try_from(auth_type)?;\n\n    let encoded_api_key = auth\n        .business_identifier\n        .zip(auth.application_identifier)\n        .zip(auth.api_key)\n        .map(|((business_identifier, application_identifier), api_key)| {\n            common_utils::consts::BASE64_ENGINE.encode(format!(\n                \"{business_identifier}.{application_identifier}:{api_key}\",\n            ))\n        });\n\n    Ok(vec![(\n        headers::AUTHORIZATION.to_string(),\n        format!(\"Key {}\", encoded_api_key.peek()).into_masked(),\n    )])\n}\n\nimpl ConnectorCommon for Noon {\n    fn id(&self) -> &'static str {\n        \"noon\"\n    }",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__noon.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__plaid.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, PostProcessing,\n        RSync, Session, SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsPostProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{PaymentsAuthorizeRouterData, PaymentsSyncRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        PaymentsPostProcessing, Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsPostProcessingType, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask as _, Maskable};\nuse transformers as plaid;\n\nuse crate::{\n    constants::headers,\n    types::{PaymentsPostProcessingRouterData, ResponseRouterData},\n    utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Plaid {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Plaid {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl Payment for Plaid {}\nimpl PaymentSession for Plaid {}\nimpl ConnectorAccessToken for Plaid {}\nimpl MandateSetup for Plaid {}\nimpl PaymentAuthorize for Plaid {}\nimpl PaymentSync for Plaid {}\nimpl PaymentCapture for Plaid {}\nimpl PaymentVoid for Plaid {}\nimpl Refund for Plaid {}\nimpl RefundExecute for Plaid {}\nimpl RefundSync for Plaid {}\nimpl PaymentToken for Plaid {}\nimpl PaymentsPostProcessing for Plaid {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Plaid\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Plaid\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut auth = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Plaid {\n    fn id(&self) -> &'static str {\n        \"plaid\"\n    }\n\n    fn get_currency_unit(&self) -> CurrencyUnit {\n        CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.plaid.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = plaid::PlaidAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        let client_id = auth.client_id.into_masked();\n        let secret = auth.secret.into_masked();\n\n        Ok(vec![\n            (\"PLAID-CLIENT-ID\".to_string(), client_id),\n            (\"PLAID-SECRET\".to_string(), secret),\n        ])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__plaid.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__plaid.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, PostProcessing,\n        RSync, Session, SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsPostProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{PaymentsAuthorizeRouterData, PaymentsSyncRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        PaymentsPostProcessing, Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsPostProcessingType, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask as _, Maskable};\nuse transformers as plaid;\n\nuse crate::{\n    constants::headers,\n    types::{PaymentsPostProcessingRouterData, ResponseRouterData},\n    utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Plaid {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Plaid {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl Payment for Plaid {}\nimpl PaymentSession for Plaid {}\nimpl ConnectorAccessToken for Plaid {}\nimpl MandateSetup for Plaid {}\nimpl PaymentAuthorize for Plaid {}\nimpl PaymentSync for Plaid {}\nimpl PaymentCapture for Plaid {}\nimpl PaymentVoid for Plaid {}\nimpl Refund for Plaid {}\nimpl RefundExecute for Plaid {}\nimpl RefundSync for Plaid {}\nimpl PaymentToken for Plaid {}\nimpl PaymentsPostProcessing for Plaid {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Plaid\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Plaid\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut auth = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Plaid {\n    fn id(&self) -> &'static str {\n        \"plaid\"\n    }\n\n    fn get_currency_unit(&self) -> CurrencyUnit {\n        CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.plaid.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = plaid::PlaidAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        let client_id = auth.client_id.into_masked();\n        let secret = auth.secret.into_masked();\n\n        Ok(vec![\n            (\"PLAID-CLIENT-ID\".to_string(), client_id),\n            (\"PLAID-SECRET\".to_string(), secret),\n        ])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__plaid.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, PostProcessing,\n        RSync, Session, SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsPostProcessingData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{PaymentsAuthorizeRouterData, PaymentsSyncRouterData},\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        PaymentsPostProcessing, Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsPostProcessingType, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask as _, Maskable};\nuse transformers as plaid;\n\nuse crate::{\n    constants::headers,\n    types::{PaymentsPostProcessingRouterData, ResponseRouterData},\n    utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Plaid {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Plaid {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl Payment for Plaid {}\nimpl PaymentSession for Plaid {}\nimpl ConnectorAccessToken for Plaid {}\nimpl MandateSetup for Plaid {}\nimpl PaymentAuthorize for Plaid {}\nimpl PaymentSync for Plaid {}\nimpl PaymentCapture for Plaid {}\nimpl PaymentVoid for Plaid {}\nimpl Refund for Plaid {}\nimpl RefundExecute for Plaid {}\nimpl RefundSync for Plaid {}\nimpl PaymentToken for Plaid {}\nimpl PaymentsPostProcessing for Plaid {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Plaid\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Plaid\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut auth = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Plaid {\n    fn id(&self) -> &'static str {\n        \"plaid\"\n    }\n\n    fn get_currency_unit(&self) -> CurrencyUnit {\n        CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.plaid.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = plaid::PlaidAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        let client_id = auth.client_id.into_masked();\n        let secret = auth.secret.into_masked();\n\n        Ok(vec![\n            (\"PLAID-CLIENT-ID\".to_string(), client_id),\n            (\"PLAID-SECRET\".to_string(), secret),\n        ])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__plaid.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__worldpay__response.rs",
    "code": "use error_stack::ResultExt;\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::requests::*;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    pub transaction_reference: Option<String>,\n    #[serde(flatten)]\n    pub other_fields: Option<WorldpayPaymentResponseFields>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayPaymentResponseFields {\n    RefusedResponse(RefusedResponse),\n    DDCResponse(DDCResponse),\n    ThreeDsChallenged(ThreeDsChallengedResponse),\n    FraudHighRisk(FraudHighRiskResponse),\n    AuthorizedResponse(Box<AuthorizedResponse>),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthorizedResponse {\n    pub payment_instrument: PaymentsResPaymentInstrument,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<SelfLink>,\n    #[serde(rename = \"_actions\")]\n    pub actions: Option<ActionLinks>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    pub fraud: Option<Fraud>,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MandateToken {\n    pub href: Secret<String>,\n    pub token_id: String,\n    pub token_expiry_date_time: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct FraudHighRiskResponse {\n    pub score: f32,\n    pub reason: Vec<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct RefusedResponse {\n    pub refusal_description: String,\n    // Access Worldpay returns a raw response code in the refusalCode field (if enabled) containing the unmodified response code received either directly from the card scheme for Worldpay-acquired transactions, or from third party acquirers.\n    pub refusal_code: String,\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    pub fraud: Option<Fraud>,\n    #[serde(rename = \"threeDS\")]\n    pub three_ds: Option<ThreeDsResponse>,\n    pub advice: Option<Advice>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct Advice {\n    pub code: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ThreeDsResponse {\n    pub outcome: String,\n    pub issuer_response: IssuerResponse,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ThreeDsChallengedResponse {\n    pub authentication: AuthenticationResponse,\n    pub challenge: ThreeDsChallenge,\n    #[serde(rename = \"_actions\")]\n    pub actions: CompleteThreeDsActionLink,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct AuthenticationResponse {\n    pub version: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct ThreeDsChallenge {\n    pub reference: String,\n    pub url: Url,\n    pub jwt: Secret<String>,\n    pub payload: Secret<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct CompleteThreeDsActionLink {\n    #[serde(rename = \"complete3dsChallenge\")]\n    pub complete_three_ds_challenge: ActionLink,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum IssuerResponse {\n    Challenged,\n    Frictionless,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct DDCResponse {\n    pub device_data_collection: DDCToken,\n    #[serde(rename = \"_actions\")]\n    pub actions: DDCActionLink,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct DDCToken {\n    pub jwt: Secret<String>,\n    pub url: Url,\n    pub bin: Secret<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct DDCActionLink {",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__worldpay__response.rs",
    "code": "use error_stack::ResultExt;\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse super::requests::*;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    pub transaction_reference: Option<String>,\n    #[serde(flatten)]\n    pub other_fields: Option<WorldpayPaymentResponseFields>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayPaymentResponseFields {\n    RefusedResponse(RefusedResponse),\n    DDCResponse(DDCResponse),\n    ThreeDsChallenged(ThreeDsChallengedResponse),\n    FraudHighRisk(FraudHighRiskResponse),\n    AuthorizedResponse(Box<AuthorizedResponse>),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AuthorizedResponse {\n    pub payment_instrument: PaymentsResPaymentInstrument,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<SelfLink>,\n    #[serde(rename = \"_actions\")]\n    pub actions: Option<ActionLinks>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    pub fraud: Option<Fraud>,\n    /// Mandate's token\n    pub token: Option<MandateToken>,\n    /// Network transaction ID\n    pub scheme_reference: Option<Secret<String>>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MandateToken {\n    pub href: Secret<String>,\n    pub token_id: String,\n    pub token_expiry_date_time: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct FraudHighRiskResponse {\n    pub score: f32,\n    pub reason: Vec<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct RefusedResponse {\n    pub refusal_description: String,\n    // Access Worldpay returns a raw response code in the refusalCode field (if enabled) containing the unmodified response code received either directly from the card scheme for Worldpay-acquired transactions, or from third party acquirers.\n    pub refusal_code: String,\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    pub fraud: Option<Fraud>,\n    #[serde(rename = \"threeDS\")]\n    pub three_ds: Option<ThreeDsResponse>,\n    pub advice: Option<Advice>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct Advice {\n    pub code: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ThreeDsResponse {\n    pub outcome: String,\n    pub issuer_response: IssuerResponse,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ThreeDsChallengedResponse {\n    pub authentication: AuthenticationResponse,\n    pub challenge: ThreeDsChallenge,\n    #[serde(rename = \"_actions\")]\n    pub actions: CompleteThreeDsActionLink,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct AuthenticationResponse {\n    pub version: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct ThreeDsChallenge {\n    pub reference: String,\n    pub url: Url,\n    pub jwt: Secret<String>,\n    pub payload: Secret<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct CompleteThreeDsActionLink {\n    #[serde(rename = \"complete3dsChallenge\")]\n    pub complete_three_ds_challenge: ActionLink,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum IssuerResponse {\n    Challenged,\n    Frictionless,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct DDCResponse {\n    pub device_data_collection: DDCToken,\n    #[serde(rename = \"_actions\")]\n    pub actions: DDCActionLink,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct DDCToken {\n    pub jwt: Secret<String>,\n    pub url: Url,\n    pub bin: Secret<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct DDCActionLink {",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpay__response.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs",
    "code": "use common_enums::{enums, AttemptStatus, BankNames};\nuse common_utils::{\n    errors::ParsingError,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{self},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct MultisafepayRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for MultisafepayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Type {\n    Direct,\n    Redirect,\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum Gateway {\n    Amex,\n    CreditCard,\n    Discover,\n    Maestro,\n    MasterCard,\n    Visa,\n    Klarna,\n    Googlepay,\n    Paypal,\n    Ideal,\n    Giropay,\n    Trustly,\n    Alipay,\n    #[serde(rename = \"WECHAT\")]\n    WeChatPay,\n    Eps,\n    MbWay,\n    #[serde(rename = \"DIRECTBANK\")]\n    Sofort,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Coupons {\n    pub allow: Option<Vec<Secret<String>>>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Mistercash {\n    pub mobile_pay_button_position: Option<String>,\n    pub disable_mobile_pay_button: Option<String>,\n    pub qr_only: Option<String>,\n    pub qr_size: Option<String>,\n}\n\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub struct Gateways {\n    pub mistercash: Option<Mistercash>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Settings {\n    pub coupons: Option<Coupons>,\n    pub gateways: Option<Gateways>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct PaymentOptions {\n    pub notification_url: Option<String>,\n    pub notification_method: Option<String>,\n    pub redirect_url: String,\n    pub cancel_url: String,\n    pub close_window: Option<bool>,\n    pub settings: Option<Settings>,\n    pub template_id: Option<String>,\n    pub allowed_countries: Option<Vec<String>>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Browser {\n    pub javascript_enabled: Option<bool>,\n    pub java_enabled: Option<bool>,\n    pub cookies_enabled: Option<bool>,\n    pub language: Option<String>,\n    pub screen_color_depth: Option<i32>,\n    pub screen_height: Option<i32>,\n    pub screen_width: Option<i32>,\n    pub time_zone: Option<i32>,\n    pub user_agent: Option<String>,\n    pub platform: Option<String>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Customer {\n    pub browser: Option<Browser>,\n    pub locale: Option<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs",
    "code": "use common_enums::{enums, AttemptStatus, BankNames};\nuse common_utils::{\n    errors::ParsingError,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{self},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct MultisafepayRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for MultisafepayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Type {\n    Direct,\n    Redirect,\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum Gateway {\n    Amex,\n    CreditCard,\n    Discover,\n    Maestro,\n    MasterCard,\n    Visa,\n    Klarna,\n    Googlepay,\n    Paypal,\n    Ideal,\n    Giropay,\n    Trustly,\n    Alipay,\n    #[serde(rename = \"WECHAT\")]\n    WeChatPay,\n    Eps,\n    MbWay,\n    #[serde(rename = \"DIRECTBANK\")]\n    Sofort,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Coupons {\n    pub allow: Option<Vec<Secret<String>>>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Mistercash {\n    pub mobile_pay_button_position: Option<String>,\n    pub disable_mobile_pay_button: Option<String>,\n    pub qr_only: Option<String>,\n    pub qr_size: Option<String>,\n}\n\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub struct Gateways {\n    pub mistercash: Option<Mistercash>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Settings {\n    pub coupons: Option<Coupons>,\n    pub gateways: Option<Gateways>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct PaymentOptions {\n    pub notification_url: Option<String>,\n    pub notification_method: Option<String>,\n    pub redirect_url: String,\n    pub cancel_url: String,\n    pub close_window: Option<bool>,\n    pub settings: Option<Settings>,\n    pub template_id: Option<String>,\n    pub allowed_countries: Option<Vec<String>>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Browser {\n    pub javascript_enabled: Option<bool>,\n    pub java_enabled: Option<bool>,\n    pub cookies_enabled: Option<bool>,\n    pub language: Option<String>,\n    pub screen_color_depth: Option<i32>,\n    pub screen_height: Option<i32>,\n    pub screen_width: Option<i32>,\n    pub time_zone: Option<i32>,\n    pub user_agent: Option<String>,\n    pub platform: Option<String>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Customer {\n    pub browser: Option<Browser>,\n    pub locale: Option<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::{enums, AttemptStatus, BankNames};\nuse common_utils::{\n    errors::ParsingError,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{FloatMajorUnit, MinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankRedirectData, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{self},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct MultisafepayRouterData<T> {\n    amount: MinorUnit,\n    router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for MultisafepayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Type {\n    Direct,\n    Redirect,\n}\n\n#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum Gateway {\n    Amex,\n    CreditCard,\n    Discover,\n    Maestro,\n    MasterCard,\n    Visa,\n    Klarna,\n    Googlepay,\n    Paypal,\n    Ideal,\n    Giropay,\n    Trustly,\n    Alipay,\n    #[serde(rename = \"WECHAT\")]\n    WeChatPay,\n    Eps,\n    MbWay,\n    #[serde(rename = \"DIRECTBANK\")]\n    Sofort,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Coupons {\n    pub allow: Option<Vec<Secret<String>>>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Mistercash {\n    pub mobile_pay_button_position: Option<String>,\n    pub disable_mobile_pay_button: Option<String>,\n    pub qr_only: Option<String>,\n    pub qr_size: Option<String>,\n}\n\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub struct Gateways {\n    pub mistercash: Option<Mistercash>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Settings {\n    pub coupons: Option<Coupons>,\n    pub gateways: Option<Gateways>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct PaymentOptions {\n    pub notification_url: Option<String>,\n    pub notification_method: Option<String>,\n    pub redirect_url: String,\n    pub cancel_url: String,\n    pub close_window: Option<bool>,\n    pub settings: Option<Settings>,\n    pub template_id: Option<String>,\n    pub allowed_countries: Option<Vec<String>>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Browser {\n    pub javascript_enabled: Option<bool>,\n    pub java_enabled: Option<bool>,\n    pub cookies_enabled: Option<bool>,\n    pub language: Option<String>,\n    pub screen_color_depth: Option<i32>,\n    pub screen_height: Option<i32>,\n    pub screen_width: Option<i32>,\n    pub time_zone: Option<i32>,\n    pub user_agent: Option<String>,\n    pub platform: Option<String>,\n}\n\n#[serde_with::skip_serializing_none]\n#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]\npub struct Customer {\n    pub browser: Option<Browser>,\n    pub locale: Option<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__multisafepay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__bitpay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as bitpay;\n\nuse self::bitpay::BitpayWebhookDetails;\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Bitpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bitpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bitpay {}\nimpl api::PaymentToken for Bitpay {}\nimpl api::PaymentSession for Bitpay {}\nimpl api::ConnectorAccessToken for Bitpay {}\nimpl api::MandateSetup for Bitpay {}\nimpl api::PaymentAuthorize for Bitpay {}\nimpl api::PaymentSync for Bitpay {}\nimpl api::PaymentCapture for Bitpay {}\nimpl api::PaymentVoid for Bitpay {}\nimpl api::Refund for Bitpay {}\nimpl api::RefundExecute for Bitpay {}\nimpl api::RefundSync for Bitpay {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Bitpay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bitpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\n                headers::X_ACCEPT_VERSION.to_string(),\n                \"2.0.0\".to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bitpay {\n    fn id(&self) -> &'static str {\n        \"bitpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bitpay.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bitpay::BitpayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bitpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__bitpay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as bitpay;\n\nuse self::bitpay::BitpayWebhookDetails;\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Bitpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bitpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bitpay {}\nimpl api::PaymentToken for Bitpay {}\nimpl api::PaymentSession for Bitpay {}\nimpl api::ConnectorAccessToken for Bitpay {}\nimpl api::MandateSetup for Bitpay {}\nimpl api::PaymentAuthorize for Bitpay {}\nimpl api::PaymentSync for Bitpay {}\nimpl api::PaymentCapture for Bitpay {}\nimpl api::PaymentVoid for Bitpay {}\nimpl api::Refund for Bitpay {}\nimpl api::RefundExecute for Bitpay {}\nimpl api::RefundSync for Bitpay {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Bitpay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bitpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\n                headers::X_ACCEPT_VERSION.to_string(),\n                \"2.0.0\".to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bitpay {\n    fn id(&self) -> &'static str {\n        \"bitpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bitpay.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bitpay::BitpayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bitpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as bitpay;\n\nuse self::bitpay::BitpayWebhookDetails;\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Bitpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bitpay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bitpay {}\nimpl api::PaymentToken for Bitpay {}\nimpl api::PaymentSession for Bitpay {}\nimpl api::ConnectorAccessToken for Bitpay {}\nimpl api::MandateSetup for Bitpay {}\nimpl api::PaymentAuthorize for Bitpay {}\nimpl api::PaymentSync for Bitpay {}\nimpl api::PaymentCapture for Bitpay {}\nimpl api::PaymentVoid for Bitpay {}\nimpl api::Refund for Bitpay {}\nimpl api::RefundExecute for Bitpay {}\nimpl api::RefundSync for Bitpay {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Bitpay\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bitpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                PaymentsAuthorizeType::get_content_type(self)\n                    .to_string()\n                    .into(),\n            ),\n            (\n                headers::X_ACCEPT_VERSION.to_string(),\n                \"2.0.0\".to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bitpay {\n    fn id(&self) -> &'static str {\n        \"bitpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bitpay.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bitpay::BitpayAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bitpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__core__payment_methods__transformers.rs",
    "code": "pub use ::payment_methods::controller::{DataDuplicationCheck, DeleteCardResp};\nuse api_models::payment_methods::Card;\n#[cfg(feature = \"v2\")]\nuse api_models::{enums as api_enums, payment_methods::PaymentMethodResponseItem};\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v1\")]\nuse common_utils::{crypto::Encryptable, request::Headers, types::keymanager::KeyManagerState};\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, StringExt},\n    id_type,\n    pii::{Email, SecretSerdeValue},\n    request::RequestContent,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data;\nuse josekit::jwe;\n#[cfg(feature = \"v1\")]\nuse masking::Mask;\nuse masking::{ExposeInterface, PeekInterface};\n#[cfg(feature = \"v1\")]\nuse payment_methods::client::{\n    self as pm_client,\n    create::{CreatePaymentMethodResponse, CreatePaymentMethodV1Request},\n    retrieve::{RetrievePaymentMethodResponse, RetrievePaymentMethodV1Request},\n    UpdatePaymentMethod, UpdatePaymentMethodV1Payload, UpdatePaymentMethodV1Request,\n};\nuse router_env::RequestId;\n#[cfg(feature = \"v1\")]\nuse router_env::{logger, RequestIdentifier};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    configs::settings,\n    core::{\n        errors::{self, CustomResult},\n        payment_methods::cards::{call_vault_service, create_encrypted_data},\n    },\n    headers,\n    pii::Secret,\n    routes,\n    services::{api as services, encryption, EncryptionAlgorithm},\n    types::{api, domain},\n    utils::OptionExt,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    consts,\n    types::{payment_methods as pm_types, transformers},\n};\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum StoreLockerReq {\n    LockerCard(StoreCardReq),\n    LockerGeneric(StoreGenericReq),\n}\n\nimpl StoreLockerReq {\n    pub fn update_requestor_card_reference(&mut self, card_reference: Option<String>) {\n        match self {\n            Self::LockerCard(c) => c.requestor_card_reference = card_reference,\n            Self::LockerGeneric(_) => (),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardReq {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub requestor_card_reference: Option<String>,\n    pub card: Card,\n    pub ttl: i64,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreGenericReq {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    #[serde(rename = \"enc_card_data\")]\n    pub enc_data: String,\n    pub ttl: i64,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardResp {\n    pub status: String,\n    pub error_message: Option<String>,\n    pub error_code: Option<String>,\n    pub payload: Option<StoreCardRespPayload>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardRespPayload {\n    pub card_reference: String,\n    pub duplication_check: Option<DataDuplicationCheck>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct CardReqBody {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    pub card_reference: String,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, Deserialize, Serialize)]\npub struct CardReqBodyV2 {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: String, // Not changing this as it might lead to api contract failure\n    pub card_reference: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct RetrieveCardResp {\n    pub status: String,\n    pub error_message: Option<String>,\n    pub error_code: Option<String>,\n    pub payload: Option<RetrieveCardRespPayload>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct RetrieveCardRespPayload {\n    pub card: Option<Card>,\n    pub enc_card_data: Option<Secret<String>>,\n    /// Additional metadata containing PAR, UPT, and other tokens   \n    pub metadata: Option<SecretSerdeValue>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddCardRequest {\n    pub card_number: cards::CardNumber,\n    pub customer_id: id_type::CustomerId,\n    pub card_exp_month: Secret<String>,\n    pub card_exp_year: Secret<String>,\n    pub merchant_id: id_type::MerchantId,\n    pub email_address: Option<Email>,",
    "function_name": "update_requestor_card_reference",
    "file": "crates__router__src__core__payment_methods__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__core__payment_methods__transformers.rs",
    "code": "pub use ::payment_methods::controller::{DataDuplicationCheck, DeleteCardResp};\nuse api_models::payment_methods::Card;\n#[cfg(feature = \"v2\")]\nuse api_models::{enums as api_enums, payment_methods::PaymentMethodResponseItem};\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v1\")]\nuse common_utils::{crypto::Encryptable, request::Headers, types::keymanager::KeyManagerState};\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, StringExt},\n    id_type,\n    pii::{Email, SecretSerdeValue},\n    request::RequestContent,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data;\nuse josekit::jwe;\n#[cfg(feature = \"v1\")]\nuse masking::Mask;\nuse masking::{ExposeInterface, PeekInterface};\n#[cfg(feature = \"v1\")]\nuse payment_methods::client::{\n    self as pm_client,\n    create::{CreatePaymentMethodResponse, CreatePaymentMethodV1Request},\n    retrieve::{RetrievePaymentMethodResponse, RetrievePaymentMethodV1Request},\n    UpdatePaymentMethod, UpdatePaymentMethodV1Payload, UpdatePaymentMethodV1Request,\n};\nuse router_env::RequestId;\n#[cfg(feature = \"v1\")]\nuse router_env::{logger, RequestIdentifier};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    configs::settings,\n    core::{\n        errors::{self, CustomResult},\n        payment_methods::cards::{call_vault_service, create_encrypted_data},\n    },\n    headers,\n    pii::Secret,\n    routes,\n    services::{api as services, encryption, EncryptionAlgorithm},\n    types::{api, domain},\n    utils::OptionExt,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    consts,\n    types::{payment_methods as pm_types, transformers},\n};\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum StoreLockerReq {\n    LockerCard(StoreCardReq),\n    LockerGeneric(StoreGenericReq),\n}\n\nimpl StoreLockerReq {\n    pub fn update_requestor_card_reference(&mut self, card_reference: Option<String>) {\n        match self {\n            Self::LockerCard(c) => c.requestor_card_reference = card_reference,\n            Self::LockerGeneric(_) => (),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardReq {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub requestor_card_reference: Option<String>,\n    pub card: Card,\n    pub ttl: i64,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreGenericReq {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    #[serde(rename = \"enc_card_data\")]\n    pub enc_data: String,\n    pub ttl: i64,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardResp {\n    pub status: String,\n    pub error_message: Option<String>,\n    pub error_code: Option<String>,\n    pub payload: Option<StoreCardRespPayload>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardRespPayload {\n    pub card_reference: String,\n    pub duplication_check: Option<DataDuplicationCheck>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct CardReqBody {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    pub card_reference: String,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, Deserialize, Serialize)]\npub struct CardReqBodyV2 {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: String, // Not changing this as it might lead to api contract failure\n    pub card_reference: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct RetrieveCardResp {\n    pub status: String,\n    pub error_message: Option<String>,\n    pub error_code: Option<String>,\n    pub payload: Option<RetrieveCardRespPayload>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct RetrieveCardRespPayload {\n    pub card: Option<Card>,\n    pub enc_card_data: Option<Secret<String>>,\n    /// Additional metadata containing PAR, UPT, and other tokens   \n    pub metadata: Option<SecretSerdeValue>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddCardRequest {\n    pub card_number: cards::CardNumber,\n    pub customer_id: id_type::CustomerId,\n    pub card_exp_month: Secret<String>,\n    pub card_exp_year: Secret<String>,\n    pub merchant_id: id_type::MerchantId,\n    pub email_address: Option<Email>,",
    "function_name": "update_requestor_card_reference",
    "file": "crates__router__src__core__payment_methods__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for update_requestor_card_reference",
    "code": "pub use ::payment_methods::controller::{DataDuplicationCheck, DeleteCardResp};\nuse api_models::payment_methods::Card;\n#[cfg(feature = \"v2\")]\nuse api_models::{enums as api_enums, payment_methods::PaymentMethodResponseItem};\nuse common_enums::CardNetwork;\n#[cfg(feature = \"v1\")]\nuse common_utils::{crypto::Encryptable, request::Headers, types::keymanager::KeyManagerState};\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, StringExt},\n    id_type,\n    pii::{Email, SecretSerdeValue},\n    request::RequestContent,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data;\nuse josekit::jwe;\n#[cfg(feature = \"v1\")]\nuse masking::Mask;\nuse masking::{ExposeInterface, PeekInterface};\n#[cfg(feature = \"v1\")]\nuse payment_methods::client::{\n    self as pm_client,\n    create::{CreatePaymentMethodResponse, CreatePaymentMethodV1Request},\n    retrieve::{RetrievePaymentMethodResponse, RetrievePaymentMethodV1Request},\n    UpdatePaymentMethod, UpdatePaymentMethodV1Payload, UpdatePaymentMethodV1Request,\n};\nuse router_env::RequestId;\n#[cfg(feature = \"v1\")]\nuse router_env::{logger, RequestIdentifier};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    configs::settings,\n    core::{\n        errors::{self, CustomResult},\n        payment_methods::cards::{call_vault_service, create_encrypted_data},\n    },\n    headers,\n    pii::Secret,\n    routes,\n    services::{api as services, encryption, EncryptionAlgorithm},\n    types::{api, domain},\n    utils::OptionExt,\n};\n#[cfg(feature = \"v2\")]\nuse crate::{\n    consts,\n    types::{payment_methods as pm_types, transformers},\n};\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum StoreLockerReq {\n    LockerCard(StoreCardReq),\n    LockerGeneric(StoreGenericReq),\n}\n\nimpl StoreLockerReq {\n    pub fn update_requestor_card_reference(&mut self, card_reference: Option<String>) {\n        match self {\n            Self::LockerCard(c) => c.requestor_card_reference = card_reference,\n            Self::LockerGeneric(_) => (),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardReq {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub requestor_card_reference: Option<String>,\n    pub card: Card,\n    pub ttl: i64,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreGenericReq {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    #[serde(rename = \"enc_card_data\")]\n    pub enc_data: String,\n    pub ttl: i64,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardResp {\n    pub status: String,\n    pub error_message: Option<String>,\n    pub error_code: Option<String>,\n    pub payload: Option<StoreCardRespPayload>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StoreCardRespPayload {\n    pub card_reference: String,\n    pub duplication_check: Option<DataDuplicationCheck>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct CardReqBody {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: id_type::CustomerId,\n    pub card_reference: String,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, Deserialize, Serialize)]\npub struct CardReqBodyV2 {\n    pub merchant_id: id_type::MerchantId,\n    pub merchant_customer_id: String, // Not changing this as it might lead to api contract failure\n    pub card_reference: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct RetrieveCardResp {\n    pub status: String,\n    pub error_message: Option<String>,\n    pub error_code: Option<String>,\n    pub payload: Option<RetrieveCardRespPayload>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct RetrieveCardRespPayload {\n    pub card: Option<Card>,\n    pub enc_card_data: Option<Secret<String>>,\n    /// Additional metadata containing PAR, UPT, and other tokens   \n    pub metadata: Option<SecretSerdeValue>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddCardRequest {\n    pub card_number: cards::CardNumber,\n    pub customer_id: id_type::CustomerId,\n    pub card_exp_month: Secret<String>,\n    pub card_exp_year: Secret<String>,\n    pub merchant_id: id_type::MerchantId,\n    pub email_address: Option<Email>,",
    "function_name": "update_requestor_card_reference",
    "file": "crates__router__src__core__payment_methods__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__square__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, Card, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::{refunds::Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{self, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\nimpl TryFrom<(&types::TokenizationRouterData, BankDebitData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, BankDebitData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, bank_debit_data) = value;\n        match bank_debit_data {\n            BankDebitData::AchBankDebit { .. }\n            | BankDebitData::SepaBankDebit { .. }\n            | BankDebitData::BecsBankDebit { .. }\n            | BankDebitData::BacsBankDebit { .. }\n            | BankDebitData::SepaGuarenteedBankDebit { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, Card)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, Card)) -> Result<Self, Self::Error> {\n        let (item, card_data) = value;\n        let auth = SquareAuthType::try_from(&item.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let exp_year = Secret::new(\n            card_data\n                .get_expiry_year_4_digit()\n                .peek()\n                .parse::<u16>()\n                .change_context(errors::ConnectorError::DateFormattingFailed)?,\n        );\n        let exp_month = Secret::new(\n            card_data\n                .card_exp_month\n                .peek()\n                .parse::<u16>()\n                .change_context(errors::ConnectorError::DateFormattingFailed)?,\n        );\n        //The below error will never happen because if session-id is not generated it would give error in execute_pretasks itself.\n        let session_id = Secret::new(\n            item.session_token\n                .clone()\n                .ok_or(errors::ConnectorError::RequestEncodingFailed)?,\n        );\n        Ok(Self::Card(SquareTokenizeData {\n            client_id: auth.key1,\n            session_id,\n            card_data: SquareCardData {\n                exp_year,\n                exp_month,\n                number: card_data.card_number,\n                cvv: card_data.card_cvc,\n            },\n        }))\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, PayLaterData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, PayLaterData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, pay_later_data) = value;\n        match pay_later_data {\n            PayLaterData::AfterpayClearpayRedirect { .. }\n            | PayLaterData::KlarnaRedirect { .. }\n            | PayLaterData::KlarnaSdk { .. }\n            | PayLaterData::AffirmRedirect { .. }\n            | PayLaterData::PayBrightRedirect { .. }\n            | PayLaterData::WalleyRedirect { .. }\n            | PayLaterData::AlmaRedirect { .. }\n            | PayLaterData::FlexitiRedirect { .. }\n            | PayLaterData::AtomeRedirect { .. }\n            | PayLaterData::BreadpayRedirect { .. }\n            | PayLaterData::PayjustnowRedirect { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, WalletData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, WalletData)) -> Result<Self, Self::Error> {\n        let (_item, wallet_data) = value;\n        match wallet_data {\n            WalletData::AmazonPay(_)\n            | WalletData::ApplePay(_)\n            | WalletData::GooglePay(_)\n            | WalletData::BluecodeRedirect {}\n            | WalletData::AliPayQr(_)\n            | WalletData::AliPayRedirect(_)\n            | WalletData::AliPayHkRedirect(_)\n            | WalletData::AmazonPayRedirect(_)\n            | WalletData::Paysera(_)\n            | WalletData::Skrill(_)\n            | WalletData::MomoRedirect(_)\n            | WalletData::KakaoPayRedirect(_)\n            | WalletData::GoPayRedirect(_)\n            | WalletData::GcashRedirect(_)\n            | WalletData::ApplePayRedirect(_)\n            | WalletData::ApplePayThirdPartySdk(_)\n            | WalletData::DanaRedirect {}\n            | WalletData::GooglePayRedirect(_)\n            | WalletData::GooglePayThirdPartySdk(_)\n            | WalletData::MbWayRedirect(_)\n            | WalletData::MobilePayRedirect(_)\n            | WalletData::PaypalRedirect(_)\n            | WalletData::PaypalSdk(_)\n            | WalletData::Paze(_)\n            | WalletData::SamsungPay(_)\n            | WalletData::TwintRedirect {}\n            | WalletData::VippsRedirect {}\n            | WalletData::TouchNGoRedirect(_)\n            | WalletData::WeChatPayRedirect(_)",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__square__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, Card, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::{refunds::Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{self, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\nimpl TryFrom<(&types::TokenizationRouterData, BankDebitData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, BankDebitData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, bank_debit_data) = value;\n        match bank_debit_data {\n            BankDebitData::AchBankDebit { .. }\n            | BankDebitData::SepaBankDebit { .. }\n            | BankDebitData::BecsBankDebit { .. }\n            | BankDebitData::BacsBankDebit { .. }\n            | BankDebitData::SepaGuarenteedBankDebit { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, Card)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, Card)) -> Result<Self, Self::Error> {\n        let (item, card_data) = value;\n        let auth = SquareAuthType::try_from(&item.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let exp_year = Secret::new(\n            card_data\n                .get_expiry_year_4_digit()\n                .peek()\n                .parse::<u16>()\n                .change_context(errors::ConnectorError::DateFormattingFailed)?,\n        );\n        let exp_month = Secret::new(\n            card_data\n                .card_exp_month\n                .peek()\n                .parse::<u16>()\n                .change_context(errors::ConnectorError::DateFormattingFailed)?,\n        );\n        //The below error will never happen because if session-id is not generated it would give error in execute_pretasks itself.\n        let session_id = Secret::new(\n            item.session_token\n                .clone()\n                .ok_or(errors::ConnectorError::RequestEncodingFailed)?,\n        );\n        Ok(Self::Card(SquareTokenizeData {\n            client_id: auth.key1,\n            session_id,\n            card_data: SquareCardData {\n                exp_year,\n                exp_month,\n                number: card_data.card_number,\n                cvv: card_data.card_cvc,\n            },\n        }))\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, PayLaterData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, PayLaterData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, pay_later_data) = value;\n        match pay_later_data {\n            PayLaterData::AfterpayClearpayRedirect { .. }\n            | PayLaterData::KlarnaRedirect { .. }\n            | PayLaterData::KlarnaSdk { .. }\n            | PayLaterData::AffirmRedirect { .. }\n            | PayLaterData::PayBrightRedirect { .. }\n            | PayLaterData::WalleyRedirect { .. }\n            | PayLaterData::AlmaRedirect { .. }\n            | PayLaterData::FlexitiRedirect { .. }\n            | PayLaterData::AtomeRedirect { .. }\n            | PayLaterData::BreadpayRedirect { .. }\n            | PayLaterData::PayjustnowRedirect { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, WalletData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, WalletData)) -> Result<Self, Self::Error> {\n        let (_item, wallet_data) = value;\n        match wallet_data {\n            WalletData::AmazonPay(_)\n            | WalletData::ApplePay(_)\n            | WalletData::GooglePay(_)\n            | WalletData::BluecodeRedirect {}\n            | WalletData::AliPayQr(_)\n            | WalletData::AliPayRedirect(_)\n            | WalletData::AliPayHkRedirect(_)\n            | WalletData::AmazonPayRedirect(_)\n            | WalletData::Paysera(_)\n            | WalletData::Skrill(_)\n            | WalletData::MomoRedirect(_)\n            | WalletData::KakaoPayRedirect(_)\n            | WalletData::GoPayRedirect(_)\n            | WalletData::GcashRedirect(_)\n            | WalletData::ApplePayRedirect(_)\n            | WalletData::ApplePayThirdPartySdk(_)\n            | WalletData::DanaRedirect {}\n            | WalletData::GooglePayRedirect(_)\n            | WalletData::GooglePayThirdPartySdk(_)\n            | WalletData::MbWayRedirect(_)\n            | WalletData::MobilePayRedirect(_)\n            | WalletData::PaypalRedirect(_)\n            | WalletData::PaypalSdk(_)\n            | WalletData::Paze(_)\n            | WalletData::SamsungPay(_)\n            | WalletData::TwintRedirect {}\n            | WalletData::VippsRedirect {}\n            | WalletData::TouchNGoRedirect(_)\n            | WalletData::WeChatPayRedirect(_)",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankDebitData, Card, PayLaterData, PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::{refunds::Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{self, CardData, PaymentsAuthorizeRequestData, RouterData as _},\n};\n\nimpl TryFrom<(&types::TokenizationRouterData, BankDebitData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, BankDebitData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, bank_debit_data) = value;\n        match bank_debit_data {\n            BankDebitData::AchBankDebit { .. }\n            | BankDebitData::SepaBankDebit { .. }\n            | BankDebitData::BecsBankDebit { .. }\n            | BankDebitData::BacsBankDebit { .. }\n            | BankDebitData::SepaGuarenteedBankDebit { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, Card)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, Card)) -> Result<Self, Self::Error> {\n        let (item, card_data) = value;\n        let auth = SquareAuthType::try_from(&item.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let exp_year = Secret::new(\n            card_data\n                .get_expiry_year_4_digit()\n                .peek()\n                .parse::<u16>()\n                .change_context(errors::ConnectorError::DateFormattingFailed)?,\n        );\n        let exp_month = Secret::new(\n            card_data\n                .card_exp_month\n                .peek()\n                .parse::<u16>()\n                .change_context(errors::ConnectorError::DateFormattingFailed)?,\n        );\n        //The below error will never happen because if session-id is not generated it would give error in execute_pretasks itself.\n        let session_id = Secret::new(\n            item.session_token\n                .clone()\n                .ok_or(errors::ConnectorError::RequestEncodingFailed)?,\n        );\n        Ok(Self::Card(SquareTokenizeData {\n            client_id: auth.key1,\n            session_id,\n            card_data: SquareCardData {\n                exp_year,\n                exp_month,\n                number: card_data.card_number,\n                cvv: card_data.card_cvc,\n            },\n        }))\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, PayLaterData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        value: (&types::TokenizationRouterData, PayLaterData),\n    ) -> Result<Self, Self::Error> {\n        let (_item, pay_later_data) = value;\n        match pay_later_data {\n            PayLaterData::AfterpayClearpayRedirect { .. }\n            | PayLaterData::KlarnaRedirect { .. }\n            | PayLaterData::KlarnaSdk { .. }\n            | PayLaterData::AffirmRedirect { .. }\n            | PayLaterData::PayBrightRedirect { .. }\n            | PayLaterData::WalleyRedirect { .. }\n            | PayLaterData::AlmaRedirect { .. }\n            | PayLaterData::FlexitiRedirect { .. }\n            | PayLaterData::AtomeRedirect { .. }\n            | PayLaterData::BreadpayRedirect { .. }\n            | PayLaterData::PayjustnowRedirect { .. } => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"Square\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl TryFrom<(&types::TokenizationRouterData, WalletData)> for SquareTokenRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(value: (&types::TokenizationRouterData, WalletData)) -> Result<Self, Self::Error> {\n        let (_item, wallet_data) = value;\n        match wallet_data {\n            WalletData::AmazonPay(_)\n            | WalletData::ApplePay(_)\n            | WalletData::GooglePay(_)\n            | WalletData::BluecodeRedirect {}\n            | WalletData::AliPayQr(_)\n            | WalletData::AliPayRedirect(_)\n            | WalletData::AliPayHkRedirect(_)\n            | WalletData::AmazonPayRedirect(_)\n            | WalletData::Paysera(_)\n            | WalletData::Skrill(_)\n            | WalletData::MomoRedirect(_)\n            | WalletData::KakaoPayRedirect(_)\n            | WalletData::GoPayRedirect(_)\n            | WalletData::GcashRedirect(_)\n            | WalletData::ApplePayRedirect(_)\n            | WalletData::ApplePayThirdPartySdk(_)\n            | WalletData::DanaRedirect {}\n            | WalletData::GooglePayRedirect(_)\n            | WalletData::GooglePayThirdPartySdk(_)\n            | WalletData::MbWayRedirect(_)\n            | WalletData::MobilePayRedirect(_)\n            | WalletData::PaypalRedirect(_)\n            | WalletData::PaypalSdk(_)\n            | WalletData::Paze(_)\n            | WalletData::SamsungPay(_)\n            | WalletData::TwintRedirect {}\n            | WalletData::VippsRedirect {}\n            | WalletData::TouchNGoRedirect(_)\n            | WalletData::WeChatPayRedirect(_)",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__square__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__lib.rs",
    "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    ApplePayRecurringDetails, ApplePayRegularBillingDetails, FeatureMetadata,\n    OrderDetailsWithAmount, RecurringPaymentIntervalUnit, RedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{\n    BillingConnectorAdditionalCardInfo, BillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails, PaymentRevenueRecoveryMetadata,\n};\n\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize)]\npub enum RemoteStorageObject<T: ForeignIDRef> {\n    ForeignID(String),\n    Object(T),\n}\n\nimpl<T: ForeignIDRef> From<T> for RemoteStorageObject<T> {\n    fn from(value: T) -> Self {\n        Self::Object(value)\n    }\n}\n\npub trait ForeignIDRef {\n    fn foreign_id(&self) -> String;\n}\n\nimpl<T: ForeignIDRef> RemoteStorageObject<T> {\n    pub fn get_id(&self) -> String {\n        match self {\n            Self::ForeignID(id) => id.clone(),\n            Self::Object(i) => i.foreign_id(),\n        }\n    }\n}\n\nuse std::fmt::Debug;\n\npub trait ApiModelToDieselModelConvertor<F> {\n    /// Convert from a foreign type to the current type\n    fn convert_from(from: F) -> Self;\n    fn convert_back(self) -> F;\n}\n\n#[cfg(feature = \"v1\")]\nimpl ApiModelToDieselModelConvertor<ApiFeatureMetadata> for FeatureMetadata {\n    fn convert_from(from: ApiFeatureMetadata) -> Self {\n        let ApiFeatureMetadata {\n            redirect_response,\n            search_tags,\n            apple_pay_recurring_details,\n            pix_additional_details,\n            boleto_additional_details,\n            ..\n        } = from;\n\n        Self {\n            redirect_response: redirect_response.map(RedirectResponse::convert_from),\n            search_tags,\n            apple_pay_recurring_details: apple_pay_recurring_details\n                .map(ApplePayRecurringDetails::convert_from),\n            gateway_system: None,\n            pix_additional_details: pix_additional_details\n                .map(diesel_models::types::PixAdditionalDetails::convert_from),\n            boleto_additional_details: boleto_additional_details\n                .map(diesel_models::types::BoletoAdditionalDetails::convert_from),\n        }\n    }\n\n    fn convert_back(self) -> ApiFeatureMetadata {\n        let Self {",
    "function_name": "from",
    "file": "crates__hyperswitch_domain_models__src__lib.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_domain_models__src__lib.rs",
    "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    ApplePayRecurringDetails, ApplePayRegularBillingDetails, FeatureMetadata,\n    OrderDetailsWithAmount, RecurringPaymentIntervalUnit, RedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{\n    BillingConnectorAdditionalCardInfo, BillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails, PaymentRevenueRecoveryMetadata,\n};\n\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize)]\npub enum RemoteStorageObject<T: ForeignIDRef> {\n    ForeignID(String),\n    Object(T),\n}\n\nimpl<T: ForeignIDRef> From<T> for RemoteStorageObject<T> {\n    fn from(value: T) -> Self {\n        Self::Object(value)\n    }\n}\n\npub trait ForeignIDRef {\n    fn foreign_id(&self) -> String;\n}\n\nimpl<T: ForeignIDRef> RemoteStorageObject<T> {\n    pub fn get_id(&self) -> String {\n        match self {\n            Self::ForeignID(id) => id.clone(),\n            Self::Object(i) => i.foreign_id(),\n        }\n    }\n}\n\nuse std::fmt::Debug;\n\npub trait ApiModelToDieselModelConvertor<F> {\n    /// Convert from a foreign type to the current type\n    fn convert_from(from: F) -> Self;\n    fn convert_back(self) -> F;\n}\n\n#[cfg(feature = \"v1\")]\nimpl ApiModelToDieselModelConvertor<ApiFeatureMetadata> for FeatureMetadata {\n    fn convert_from(from: ApiFeatureMetadata) -> Self {\n        let ApiFeatureMetadata {\n            redirect_response,\n            search_tags,\n            apple_pay_recurring_details,\n            pix_additional_details,\n            boleto_additional_details,\n            ..\n        } = from;\n\n        Self {\n            redirect_response: redirect_response.map(RedirectResponse::convert_from),\n            search_tags,\n            apple_pay_recurring_details: apple_pay_recurring_details\n                .map(ApplePayRecurringDetails::convert_from),\n            gateway_system: None,\n            pix_additional_details: pix_additional_details\n                .map(diesel_models::types::PixAdditionalDetails::convert_from),\n            boleto_additional_details: boleto_additional_details\n                .map(diesel_models::types::BoletoAdditionalDetails::convert_from),\n        }\n    }\n\n    fn convert_back(self) -> ApiFeatureMetadata {\n        let Self {",
    "function_name": "from",
    "file": "crates__hyperswitch_domain_models__src__lib.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "pub mod address;\npub mod api;\npub mod authentication;\npub mod behaviour;\npub mod bulk_tokenization;\npub mod business_profile;\npub mod callback_mapper;\npub mod card_testing_guard_data;\npub mod cards_info;\npub mod chat;\npub mod configs;\npub mod connector_endpoints;\npub mod consts;\npub mod customer;\npub mod disputes;\npub mod errors;\npub mod ext_traits;\npub mod gsm;\npub mod invoice;\npub mod mandates;\npub mod master_key;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod payment_address;\npub mod payment_method_data;\npub mod payment_methods;\npub mod payments;\n#[cfg(feature = \"payouts\")]\npub mod payouts;\npub mod platform;\npub mod refunds;\npub mod relay;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\npub mod revenue_recovery;\npub mod router_data;\npub mod router_data_v2;\npub mod router_flow_types;\npub mod router_request_types;\npub mod router_response_types;\npub mod routing;\npub mod sdk_auth;\npub mod subscription;\n#[cfg(feature = \"tokenization_v2\")]\npub mod tokenization;\npub mod transformers;\npub mod type_encryption;\npub mod types;\npub mod vault;\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutAttemptInterface {}\n\n#[cfg(not(feature = \"payouts\"))]\npub trait PayoutsInterface {}\n\nuse api_models::payments::{\n    ApplePayRecurringDetails as ApiApplePayRecurringDetails,\n    ApplePayRegularBillingDetails as ApiApplePayRegularBillingDetails,\n    FeatureMetadata as ApiFeatureMetadata, OrderDetailsWithAmount as ApiOrderDetailsWithAmount,\n    RecurringPaymentIntervalUnit as ApiRecurringPaymentIntervalUnit,\n    RedirectResponse as ApiRedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{\n    BillingConnectorAdditionalCardInfo as ApiBillingConnectorAdditionalCardInfo,\n    BillingConnectorPaymentDetails as ApiBillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails as ApiBillingConnectorPaymentMethodDetails,\n    PaymentRevenueRecoveryMetadata as ApiRevenueRecoveryMetadata,\n};\nuse diesel_models::types::{\n    ApplePayRecurringDetails, ApplePayRegularBillingDetails, FeatureMetadata,\n    OrderDetailsWithAmount, RecurringPaymentIntervalUnit, RedirectResponse,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::types::{\n    BillingConnectorAdditionalCardInfo, BillingConnectorPaymentDetails,\n    BillingConnectorPaymentMethodDetails, PaymentRevenueRecoveryMetadata,\n};\n\n#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize)]\npub enum RemoteStorageObject<T: ForeignIDRef> {\n    ForeignID(String),\n    Object(T),\n}\n\nimpl<T: ForeignIDRef> From<T> for RemoteStorageObject<T> {\n    fn from(value: T) -> Self {\n        Self::Object(value)\n    }\n}\n\npub trait ForeignIDRef {\n    fn foreign_id(&self) -> String;\n}\n\nimpl<T: ForeignIDRef> RemoteStorageObject<T> {\n    pub fn get_id(&self) -> String {\n        match self {\n            Self::ForeignID(id) => id.clone(),\n            Self::Object(i) => i.foreign_id(),\n        }\n    }\n}\n\nuse std::fmt::Debug;\n\npub trait ApiModelToDieselModelConvertor<F> {\n    /// Convert from a foreign type to the current type\n    fn convert_from(from: F) -> Self;\n    fn convert_back(self) -> F;\n}\n\n#[cfg(feature = \"v1\")]\nimpl ApiModelToDieselModelConvertor<ApiFeatureMetadata> for FeatureMetadata {\n    fn convert_from(from: ApiFeatureMetadata) -> Self {\n        let ApiFeatureMetadata {\n            redirect_response,\n            search_tags,\n            apple_pay_recurring_details,\n            pix_additional_details,\n            boleto_additional_details,\n            ..\n        } = from;\n\n        Self {\n            redirect_response: redirect_response.map(RedirectResponse::convert_from),\n            search_tags,\n            apple_pay_recurring_details: apple_pay_recurring_details\n                .map(ApplePayRecurringDetails::convert_from),\n            gateway_system: None,\n            pix_additional_details: pix_additional_details\n                .map(diesel_models::types::PixAdditionalDetails::convert_from),\n            boleto_additional_details: boleto_additional_details\n                .map(diesel_models::types::BoletoAdditionalDetails::convert_from),\n        }\n    }\n\n    fn convert_back(self) -> ApiFeatureMetadata {\n        let Self {",
    "function_name": "from",
    "file": "crates__hyperswitch_domain_models__src__lib.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__forte.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Forte {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Forte {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Forte {}\nimpl api::PaymentSession for Forte {}\nimpl api::ConnectorAccessToken for Forte {}\nimpl api::MandateSetup for Forte {}\nimpl api::PaymentAuthorize for Forte {}\nimpl api::PaymentSync for Forte {}\nimpl api::PaymentCapture for Forte {}\nimpl api::PaymentVoid for Forte {}\nimpl api::Refund for Forte {}\nimpl api::RefundExecute for Forte {}\nimpl api::RefundSync for Forte {}\nimpl api::PaymentToken for Forte {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Forte\n{\n}\npub const AUTH_ORG_ID_HEADER: &str = \"X-Forte-Auth-Organization-Id\";\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Forte\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let content_type = ConnectorCommon::common_get_content_type(self);\n        let mut common_headers = self.get_auth_header(&req.connector_auth_type)?;\n        common_headers.push((\n            headers::CONTENT_TYPE.to_string(),\n            content_type.to_string().into(),\n        ));\n        Ok(common_headers)\n    }\n}\n\nimpl ConnectorCommon for Forte {\n    fn id(&self) -> &'static str {\n        \"forte\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.forte.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = forte::ForteAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let raw_basic_token = format!(\n            \"{}:{}\",\n            auth.api_access_id.peek(),\n            auth.api_secret_key.peek()\n        );\n        let basic_token = format!(\"Basic {}\", BASE64_ENGINE.encode(raw_basic_token));\n        Ok(vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                basic_token.into_masked(),\n            ),\n            (\n                AUTH_ORG_ID_HEADER.to_string(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__forte.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__forte.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Forte {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Forte {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Forte {}\nimpl api::PaymentSession for Forte {}\nimpl api::ConnectorAccessToken for Forte {}\nimpl api::MandateSetup for Forte {}\nimpl api::PaymentAuthorize for Forte {}\nimpl api::PaymentSync for Forte {}\nimpl api::PaymentCapture for Forte {}\nimpl api::PaymentVoid for Forte {}\nimpl api::Refund for Forte {}\nimpl api::RefundExecute for Forte {}\nimpl api::RefundSync for Forte {}\nimpl api::PaymentToken for Forte {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Forte\n{\n}\npub const AUTH_ORG_ID_HEADER: &str = \"X-Forte-Auth-Organization-Id\";\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Forte\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let content_type = ConnectorCommon::common_get_content_type(self);\n        let mut common_headers = self.get_auth_header(&req.connector_auth_type)?;\n        common_headers.push((\n            headers::CONTENT_TYPE.to_string(),\n            content_type.to_string().into(),\n        ));\n        Ok(common_headers)\n    }\n}\n\nimpl ConnectorCommon for Forte {\n    fn id(&self) -> &'static str {\n        \"forte\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.forte.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = forte::ForteAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let raw_basic_token = format!(\n            \"{}:{}\",\n            auth.api_access_id.peek(),\n            auth.api_secret_key.peek()\n        );\n        let basic_token = format!(\"Basic {}\", BASE64_ENGINE.encode(raw_basic_token));\n        Ok(vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                basic_token.into_masked(),\n            ),\n            (\n                AUTH_ORG_ID_HEADER.to_string(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__forte.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_CODE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as forte;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Forte {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Forte {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Forte {}\nimpl api::PaymentSession for Forte {}\nimpl api::ConnectorAccessToken for Forte {}\nimpl api::MandateSetup for Forte {}\nimpl api::PaymentAuthorize for Forte {}\nimpl api::PaymentSync for Forte {}\nimpl api::PaymentCapture for Forte {}\nimpl api::PaymentVoid for Forte {}\nimpl api::Refund for Forte {}\nimpl api::RefundExecute for Forte {}\nimpl api::RefundSync for Forte {}\nimpl api::PaymentToken for Forte {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Forte\n{\n}\npub const AUTH_ORG_ID_HEADER: &str = \"X-Forte-Auth-Organization-Id\";\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Forte\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let content_type = ConnectorCommon::common_get_content_type(self);\n        let mut common_headers = self.get_auth_header(&req.connector_auth_type)?;\n        common_headers.push((\n            headers::CONTENT_TYPE.to_string(),\n            content_type.to_string().into(),\n        ));\n        Ok(common_headers)\n    }\n}\n\nimpl ConnectorCommon for Forte {\n    fn id(&self) -> &'static str {\n        \"forte\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.forte.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = forte::ForteAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let raw_basic_token = format!(\n            \"{}:{}\",\n            auth.api_access_id.peek(),\n            auth.api_secret_key.peek()\n        );\n        let basic_token = format!(\"Basic {}\", BASE64_ENGINE.encode(raw_basic_token));\n        Ok(vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                basic_token.into_masked(),\n            ),\n            (\n                AUTH_ORG_ID_HEADER.to_string(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__forte.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__archipel.rs",
    "code": "use std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        IncrementalAuthorization,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse router_env::{error, info};\nuse transformers::{\n    self as archipel, ArchipelCardAuthorizationRequest, ArchipelIncrementalAuthorizationRequest,\n    ArchipelPaymentsCancelRequest, ArchipelRefundRequest, ArchipelWalletAuthorizationRequest,\n};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{is_mandate_supported, PaymentMethodDataType, PaymentsAuthorizeRequestData},\n};\n\npub mod transformers;\n\n#[derive(Clone)]\npub struct Archipel {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Archipel {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::PaymentAuthorize for Archipel {}\nimpl api::PaymentSync for Archipel {}\nimpl api::PaymentVoid for Archipel {}\nimpl api::PaymentCapture for Archipel {}\nimpl api::MandateSetup for Archipel {}\nimpl api::ConnectorAccessToken for Archipel {}\nimpl api::PaymentToken for Archipel {}\nimpl api::PaymentSession for Archipel {}\nimpl api::Refund for Archipel {}\nimpl api::RefundExecute for Archipel {}\nimpl api::RefundSync for Archipel {}\nimpl api::Payment for Archipel {}\nimpl api::PaymentIncrementalAuthorization for Archipel {}\n\nfn build_env_specific_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, errors::ConnectorError> {\n    let archipel_connector_metadata_object =\n        transformers::ArchipelConfigData::try_from(connector_metadata)?;\n    let endpoint_prefix = archipel_connector_metadata_object.platform_url;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Archipel\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Archipel {\n    fn id(&self) -> &'static str {\n        \"archipel\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.archipel.base_url.as_ref()",
    "function_name": "build_env_specific_endpoint",
    "file": "crates__hyperswitch_connectors__src__connectors__archipel.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__archipel.rs",
    "code": "use std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        IncrementalAuthorization,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse router_env::{error, info};\nuse transformers::{\n    self as archipel, ArchipelCardAuthorizationRequest, ArchipelIncrementalAuthorizationRequest,\n    ArchipelPaymentsCancelRequest, ArchipelRefundRequest, ArchipelWalletAuthorizationRequest,\n};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{is_mandate_supported, PaymentMethodDataType, PaymentsAuthorizeRequestData},\n};\n\npub mod transformers;\n\n#[derive(Clone)]\npub struct Archipel {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Archipel {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::PaymentAuthorize for Archipel {}\nimpl api::PaymentSync for Archipel {}\nimpl api::PaymentVoid for Archipel {}\nimpl api::PaymentCapture for Archipel {}\nimpl api::MandateSetup for Archipel {}\nimpl api::ConnectorAccessToken for Archipel {}\nimpl api::PaymentToken for Archipel {}\nimpl api::PaymentSession for Archipel {}\nimpl api::Refund for Archipel {}\nimpl api::RefundExecute for Archipel {}\nimpl api::RefundSync for Archipel {}\nimpl api::Payment for Archipel {}\nimpl api::PaymentIncrementalAuthorization for Archipel {}\n\nfn build_env_specific_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, errors::ConnectorError> {\n    let archipel_connector_metadata_object =\n        transformers::ArchipelConfigData::try_from(connector_metadata)?;\n    let endpoint_prefix = archipel_connector_metadata_object.platform_url;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Archipel\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Archipel {\n    fn id(&self) -> &'static str {\n        \"archipel\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.archipel.base_url.as_ref()",
    "function_name": "build_env_specific_endpoint",
    "file": "crates__hyperswitch_connectors__src__connectors__archipel.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_env_specific_endpoint",
    "code": "use std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        IncrementalAuthorization,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Maskable;\nuse router_env::{error, info};\nuse transformers::{\n    self as archipel, ArchipelCardAuthorizationRequest, ArchipelIncrementalAuthorizationRequest,\n    ArchipelPaymentsCancelRequest, ArchipelRefundRequest, ArchipelWalletAuthorizationRequest,\n};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{is_mandate_supported, PaymentMethodDataType, PaymentsAuthorizeRequestData},\n};\n\npub mod transformers;\n\n#[derive(Clone)]\npub struct Archipel {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Archipel {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::PaymentAuthorize for Archipel {}\nimpl api::PaymentSync for Archipel {}\nimpl api::PaymentVoid for Archipel {}\nimpl api::PaymentCapture for Archipel {}\nimpl api::MandateSetup for Archipel {}\nimpl api::ConnectorAccessToken for Archipel {}\nimpl api::PaymentToken for Archipel {}\nimpl api::PaymentSession for Archipel {}\nimpl api::Refund for Archipel {}\nimpl api::RefundExecute for Archipel {}\nimpl api::RefundSync for Archipel {}\nimpl api::Payment for Archipel {}\nimpl api::PaymentIncrementalAuthorization for Archipel {}\n\nfn build_env_specific_endpoint(\n    base_url: &str,\n    connector_metadata: &Option<common_utils::pii::SecretSerdeValue>,\n) -> CustomResult<String, errors::ConnectorError> {\n    let archipel_connector_metadata_object =\n        transformers::ArchipelConfigData::try_from(connector_metadata)?;\n    let endpoint_prefix = archipel_connector_metadata_object.platform_url;\n    Ok(base_url.replace(\"{{merchant_endpoint_prefix}}\", &endpoint_prefix))\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Archipel\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Archipel {\n    fn id(&self) -> &'static str {\n        \"archipel\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.archipel.base_url.as_ref()",
    "function_name": "build_env_specific_endpoint",
    "file": "crates__hyperswitch_connectors__src__connectors__archipel.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__checkbook.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{enums, payments::PaymentIdType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as checkbook;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Checkbook {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Checkbook {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Checkbook {}\nimpl api::PaymentSession for Checkbook {}\nimpl api::ConnectorAccessToken for Checkbook {}\nimpl api::MandateSetup for Checkbook {}\nimpl api::PaymentAuthorize for Checkbook {}\nimpl api::PaymentSync for Checkbook {}\nimpl api::PaymentCapture for Checkbook {}\nimpl api::PaymentVoid for Checkbook {}\nimpl api::Refund for Checkbook {}\nimpl api::RefundExecute for Checkbook {}\nimpl api::RefundSync for Checkbook {}\nimpl api::PaymentToken for Checkbook {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Checkbook\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Checkbook\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Checkbook {\n    fn id(&self) -> &'static str {\n        \"checkbook\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.checkbook.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = checkbook::CheckbookAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.publishable_key.expose(),\n            auth.secret_key.expose()\n        );\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__checkbook.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__checkbook.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{enums, payments::PaymentIdType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as checkbook;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Checkbook {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Checkbook {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Checkbook {}\nimpl api::PaymentSession for Checkbook {}\nimpl api::ConnectorAccessToken for Checkbook {}\nimpl api::MandateSetup for Checkbook {}\nimpl api::PaymentAuthorize for Checkbook {}\nimpl api::PaymentSync for Checkbook {}\nimpl api::PaymentCapture for Checkbook {}\nimpl api::PaymentVoid for Checkbook {}\nimpl api::Refund for Checkbook {}\nimpl api::RefundExecute for Checkbook {}\nimpl api::RefundSync for Checkbook {}\nimpl api::PaymentToken for Checkbook {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Checkbook\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Checkbook\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Checkbook {\n    fn id(&self) -> &'static str {\n        \"checkbook\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.checkbook.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = checkbook::CheckbookAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.publishable_key.expose(),\n            auth.secret_key.expose()\n        );\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__checkbook.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{enums, payments::PaymentIdType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as checkbook;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Clone)]\npub struct Checkbook {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Checkbook {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Checkbook {}\nimpl api::PaymentSession for Checkbook {}\nimpl api::ConnectorAccessToken for Checkbook {}\nimpl api::MandateSetup for Checkbook {}\nimpl api::PaymentAuthorize for Checkbook {}\nimpl api::PaymentSync for Checkbook {}\nimpl api::PaymentCapture for Checkbook {}\nimpl api::PaymentVoid for Checkbook {}\nimpl api::Refund for Checkbook {}\nimpl api::RefundExecute for Checkbook {}\nimpl api::RefundSync for Checkbook {}\nimpl api::PaymentToken for Checkbook {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Checkbook\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Checkbook\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Checkbook {\n    fn id(&self) -> &'static str {\n        \"checkbook\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.checkbook.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = checkbook::CheckbookAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let auth_key = format!(\n            \"{}:{}\",\n            auth.publishable_key.expose(),\n            auth.secret_key.expose()\n        );\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__checkbook.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__powertranz.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as powertranz;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, PaymentsAuthorizeRequestData as _,\n        PaymentsCompleteAuthorizeRequestData as _,\n    },\n};\n\n#[derive(Clone)]\npub struct Powertranz {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Powertranz {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Powertranz {}\nimpl api::PaymentSession for Powertranz {}\nimpl api::ConnectorAccessToken for Powertranz {}\nimpl api::MandateSetup for Powertranz {}\nimpl api::PaymentAuthorize for Powertranz {}\nimpl api::PaymentsCompleteAuthorize for Powertranz {}\nimpl api::PaymentSync for Powertranz {}\nimpl api::PaymentCapture for Powertranz {}\nimpl api::PaymentVoid for Powertranz {}\nimpl api::Refund for Powertranz {}\nimpl api::RefundExecute for Powertranz {}\nimpl api::RefundSync for Powertranz {}\nimpl api::PaymentToken for Powertranz {}\n\nconst POWER_TRANZ_ID: &str = \"PowerTranz-PowerTranzId\";\nconst POWER_TRANZ_PASSWORD: &str = \"PowerTranz-PowerTranzPassword\";\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Powertranz\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Powertranz\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.common_get_content_type().to_string().into(),\n        )];\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth_header);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Powertranz {\n    fn id(&self) -> &'static str {\n        \"powertranz\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.powertranz.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = powertranz::PowertranzAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                POWER_TRANZ_ID.to_string(),\n                auth.power_tranz_id.expose().into_masked(),\n            ),\n            (",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__powertranz.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__powertranz.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as powertranz;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, PaymentsAuthorizeRequestData as _,\n        PaymentsCompleteAuthorizeRequestData as _,\n    },\n};\n\n#[derive(Clone)]\npub struct Powertranz {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Powertranz {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Powertranz {}\nimpl api::PaymentSession for Powertranz {}\nimpl api::ConnectorAccessToken for Powertranz {}\nimpl api::MandateSetup for Powertranz {}\nimpl api::PaymentAuthorize for Powertranz {}\nimpl api::PaymentsCompleteAuthorize for Powertranz {}\nimpl api::PaymentSync for Powertranz {}\nimpl api::PaymentCapture for Powertranz {}\nimpl api::PaymentVoid for Powertranz {}\nimpl api::Refund for Powertranz {}\nimpl api::RefundExecute for Powertranz {}\nimpl api::RefundSync for Powertranz {}\nimpl api::PaymentToken for Powertranz {}\n\nconst POWER_TRANZ_ID: &str = \"PowerTranz-PowerTranzId\";\nconst POWER_TRANZ_PASSWORD: &str = \"PowerTranz-PowerTranzPassword\";\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Powertranz\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Powertranz\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.common_get_content_type().to_string().into(),\n        )];\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth_header);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Powertranz {\n    fn id(&self) -> &'static str {\n        \"powertranz\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.powertranz.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = powertranz::PowertranzAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                POWER_TRANZ_ID.to_string(),\n                auth.power_tranz_id.expose().into_masked(),\n            ),\n            (",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__powertranz.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::enums::AuthenticationType;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as powertranz;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, PaymentsAuthorizeRequestData as _,\n        PaymentsCompleteAuthorizeRequestData as _,\n    },\n};\n\n#[derive(Clone)]\npub struct Powertranz {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Powertranz {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Powertranz {}\nimpl api::PaymentSession for Powertranz {}\nimpl api::ConnectorAccessToken for Powertranz {}\nimpl api::MandateSetup for Powertranz {}\nimpl api::PaymentAuthorize for Powertranz {}\nimpl api::PaymentsCompleteAuthorize for Powertranz {}\nimpl api::PaymentSync for Powertranz {}\nimpl api::PaymentCapture for Powertranz {}\nimpl api::PaymentVoid for Powertranz {}\nimpl api::Refund for Powertranz {}\nimpl api::RefundExecute for Powertranz {}\nimpl api::RefundSync for Powertranz {}\nimpl api::PaymentToken for Powertranz {}\n\nconst POWER_TRANZ_ID: &str = \"PowerTranz-PowerTranzId\";\nconst POWER_TRANZ_PASSWORD: &str = \"PowerTranz-PowerTranzPassword\";\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Powertranz\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Powertranz\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.common_get_content_type().to_string().into(),\n        )];\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut auth_header);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Powertranz {\n    fn id(&self) -> &'static str {\n        \"powertranz\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.powertranz.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = powertranz::PowertranzAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                POWER_TRANZ_ID.to_string(),\n                auth.power_tranz_id.expose().into_masked(),\n            ),\n            (",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__powertranz.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::{\n    AttemptStatus, CaptureMethod, CountryAlpha2, CountryAlpha3, Currency, RefundStatus,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{\n        CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId,\n        SetupMandateRequestData, UcsAuthenticationData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_with::skip_serializing_none;\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPostAuthenticateResponseRouterData, PaymentsPreAuthenticateResponseRouterData,\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, to_connector_meta,\n        to_connector_meta_from_secret, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPostAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSetupMandateRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\n#[derive(Clone, Copy, Debug)]\nenum AddressKind {\n    Billing,\n    Shipping,\n}\n\ntrait AddressConstructor {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self;\n}\n\nimpl AddressConstructor for BillingAddress {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self {\n        Self {\n            name,\n            street,\n            city,\n            post_code,\n            country,\n        }\n    }\n}\n\nimpl AddressConstructor for ShippingAddress {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self {\n        Self {\n            name,\n            street,\n            city,\n            post_code,\n            country,\n        }\n    }\n}\n\nfn get_validated_address_details_generic<RouterContextDataAlias, AddressOutput>(\n    data: &RouterContextDataAlias,\n    address_kind: AddressKind,\n) -> Result<Option<AddressOutput>, error_stack::Report<errors::ConnectorError>>\nwhere\n    RouterContextDataAlias: crate::utils::RouterData,\n    AddressOutput: AddressConstructor + Sized,\n{\n    let (\n        opt_line1,\n        opt_line2,\n        opt_full_name,\n        opt_city,\n        opt_zip,\n        opt_country,\n        has_address_details_check,\n        address_type_str,\n        max_name_len,\n        max_street_len,\n        max_city_len,\n        max_post_code_len,\n        max_country_len,\n    ) = match address_kind {\n        AddressKind::Billing => (\n            data.get_optional_billing_line1(),\n            data.get_optional_billing_line2(),\n            data.get_optional_billing_full_name(),\n            data.get_optional_billing_city(),\n            data.get_optional_billing_zip(),\n            data.get_optional_billing_country()\n                .map(CountryAlpha2::from_alpha2_to_alpha3),\n            data.get_optional_billing().is_some(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::{\n    AttemptStatus, CaptureMethod, CountryAlpha2, CountryAlpha3, Currency, RefundStatus,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{\n        CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId,\n        SetupMandateRequestData, UcsAuthenticationData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_with::skip_serializing_none;\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPostAuthenticateResponseRouterData, PaymentsPreAuthenticateResponseRouterData,\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, to_connector_meta,\n        to_connector_meta_from_secret, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPostAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSetupMandateRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\n#[derive(Clone, Copy, Debug)]\nenum AddressKind {\n    Billing,\n    Shipping,\n}\n\ntrait AddressConstructor {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self;\n}\n\nimpl AddressConstructor for BillingAddress {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self {\n        Self {\n            name,\n            street,\n            city,\n            post_code,\n            country,\n        }\n    }\n}\n\nimpl AddressConstructor for ShippingAddress {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self {\n        Self {\n            name,\n            street,\n            city,\n            post_code,\n            country,\n        }\n    }\n}\n\nfn get_validated_address_details_generic<RouterContextDataAlias, AddressOutput>(\n    data: &RouterContextDataAlias,\n    address_kind: AddressKind,\n) -> Result<Option<AddressOutput>, error_stack::Report<errors::ConnectorError>>\nwhere\n    RouterContextDataAlias: crate::utils::RouterData,\n    AddressOutput: AddressConstructor + Sized,\n{\n    let (\n        opt_line1,\n        opt_line2,\n        opt_full_name,\n        opt_city,\n        opt_zip,\n        opt_country,\n        has_address_details_check,\n        address_type_str,\n        max_name_len,\n        max_street_len,\n        max_city_len,\n        max_post_code_len,\n        max_country_len,\n    ) = match address_kind {\n        AddressKind::Billing => (\n            data.get_optional_billing_line1(),\n            data.get_optional_billing_line2(),\n            data.get_optional_billing_full_name(),\n            data.get_optional_billing_city(),\n            data.get_optional_billing_zip(),\n            data.get_optional_billing_country()\n                .map(CountryAlpha2::from_alpha2_to_alpha3),\n            data.get_optional_billing().is_some(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "use std::collections::HashMap;\n\nuse cards::CardNumber;\nuse common_enums::{\n    AttemptStatus, CaptureMethod, CountryAlpha2, CountryAlpha3, Currency, RefundStatus,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ValueExt,\n    request::Method,\n    types::{MinorUnit, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{\n        CompleteAuthorizeData, CompleteAuthorizeRedirectResponse, ResponseId,\n        SetupMandateRequestData, UcsAuthenticationData,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts::NO_ERROR_CODE, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_with::skip_serializing_none;\nuse strum::Display;\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPostAuthenticateResponseRouterData, PaymentsPreAuthenticateResponseRouterData,\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, to_connector_meta,\n        to_connector_meta_from_secret, CardData, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPostAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSetupMandateRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\n#[derive(Clone, Copy, Debug)]\nenum AddressKind {\n    Billing,\n    Shipping,\n}\n\ntrait AddressConstructor {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self;\n}\n\nimpl AddressConstructor for BillingAddress {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self {\n        Self {\n            name,\n            street,\n            city,\n            post_code,\n            country,\n        }\n    }\n}\n\nimpl AddressConstructor for ShippingAddress {\n    fn new(\n        name: Option<Secret<String>>,\n        street: Option<Secret<String>>,\n        city: Option<String>,\n        post_code: Option<Secret<String>>,\n        country: Option<CountryAlpha3>,\n    ) -> Self {\n        Self {\n            name,\n            street,\n            city,\n            post_code,\n            country,\n        }\n    }\n}\n\nfn get_validated_address_details_generic<RouterContextDataAlias, AddressOutput>(\n    data: &RouterContextDataAlias,\n    address_kind: AddressKind,\n) -> Result<Option<AddressOutput>, error_stack::Report<errors::ConnectorError>>\nwhere\n    RouterContextDataAlias: crate::utils::RouterData,\n    AddressOutput: AddressConstructor + Sized,\n{\n    let (\n        opt_line1,\n        opt_line2,\n        opt_full_name,\n        opt_city,\n        opt_zip,\n        opt_country,\n        has_address_details_check,\n        address_type_str,\n        max_name_len,\n        max_street_len,\n        max_city_len,\n        max_post_code_len,\n        max_country_len,\n    ) = match address_kind {\n        AddressKind::Billing => (\n            data.get_optional_billing_line1(),\n            data.get_optional_billing_line2(),\n            data.get_optional_billing_full_name(),\n            data.get_optional_billing_city(),\n            data.get_optional_billing_zip(),\n            data.get_optional_billing_country()\n                .map(CountryAlpha2::from_alpha2_to_alpha3),\n            data.get_optional_billing().is_some(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nexixpay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payeezy.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse rand::distributions::DistString;\nuse ring::hmac;\nuse transformers as payeezy;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Payeezy;\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payeezy\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = payeezy::PayeezyAuthType::try_from(&req.connector_auth_type)?;\n        let request_payload = self\n            .get_request_body(req, connectors)?\n            .get_inner_value()\n            .expose();\n        let timestamp = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .ok()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .as_millis()\n            .to_string();\n        let nonce = rand::distributions::Alphanumeric.sample_string(&mut rand::thread_rng(), 19);\n        let signature_string = auth.api_key.clone().zip(auth.merchant_token.clone()).map(\n            |(api_key, merchant_token)| {\n                format!(\"{api_key}{nonce}{timestamp}{merchant_token}{request_payload}\")\n            },\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, auth.api_secret.expose().as_bytes());\n        let tag = hmac::sign(&key, signature_string.expose().as_bytes());\n        let hmac_sign = hex::encode(tag);\n        let signature_value = common_utils::consts::BASE64_ENGINE_URL_SAFE.encode(hmac_sign);\n        Ok(vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                Self.get_content_type().to_string().into(),\n            ),\n            (headers::APIKEY.to_string(), auth.api_key.into_masked()),\n            (\n                headers::TOKEN.to_string(),\n                auth.merchant_token.into_masked(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signature_value.into_masked(),\n            ),\n            (headers::NONCE.to_string(), nonce.into_masked()),\n            (headers::TIMESTAMP.to_string(), timestamp.into()),\n        ])\n    }\n}\n\nimpl ConnectorCommon for Payeezy {\n    fn id(&self) -> &'static str {\n        \"payeezy\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.payeezy.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: payeezy::PayeezyErrorResponse = res\n            .response\n            .parse_struct(\"payeezy ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_messages: Vec<String> = response\n            .error\n            .messages\n            .iter()",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__payeezy.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payeezy.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse rand::distributions::DistString;\nuse ring::hmac;\nuse transformers as payeezy;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Payeezy;\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payeezy\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = payeezy::PayeezyAuthType::try_from(&req.connector_auth_type)?;\n        let request_payload = self\n            .get_request_body(req, connectors)?\n            .get_inner_value()\n            .expose();\n        let timestamp = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .ok()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .as_millis()\n            .to_string();\n        let nonce = rand::distributions::Alphanumeric.sample_string(&mut rand::thread_rng(), 19);\n        let signature_string = auth.api_key.clone().zip(auth.merchant_token.clone()).map(\n            |(api_key, merchant_token)| {\n                format!(\"{api_key}{nonce}{timestamp}{merchant_token}{request_payload}\")\n            },\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, auth.api_secret.expose().as_bytes());\n        let tag = hmac::sign(&key, signature_string.expose().as_bytes());\n        let hmac_sign = hex::encode(tag);\n        let signature_value = common_utils::consts::BASE64_ENGINE_URL_SAFE.encode(hmac_sign);\n        Ok(vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                Self.get_content_type().to_string().into(),\n            ),\n            (headers::APIKEY.to_string(), auth.api_key.into_masked()),\n            (\n                headers::TOKEN.to_string(),\n                auth.merchant_token.into_masked(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signature_value.into_masked(),\n            ),\n            (headers::NONCE.to_string(), nonce.into_masked()),\n            (headers::TIMESTAMP.to_string(), timestamp.into()),\n        ])\n    }\n}\n\nimpl ConnectorCommon for Payeezy {\n    fn id(&self) -> &'static str {\n        \"payeezy\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.payeezy.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: payeezy::PayeezyErrorResponse = res\n            .response\n            .parse_struct(\"payeezy ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_messages: Vec<String> = response\n            .error\n            .messages\n            .iter()",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__payeezy.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsVoidType, RefundExecuteType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse rand::distributions::DistString;\nuse ring::hmac;\nuse transformers as payeezy;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Payeezy;\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payeezy\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = payeezy::PayeezyAuthType::try_from(&req.connector_auth_type)?;\n        let request_payload = self\n            .get_request_body(req, connectors)?\n            .get_inner_value()\n            .expose();\n        let timestamp = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .ok()\n            .ok_or(errors::ConnectorError::RequestEncodingFailed)?\n            .as_millis()\n            .to_string();\n        let nonce = rand::distributions::Alphanumeric.sample_string(&mut rand::thread_rng(), 19);\n        let signature_string = auth.api_key.clone().zip(auth.merchant_token.clone()).map(\n            |(api_key, merchant_token)| {\n                format!(\"{api_key}{nonce}{timestamp}{merchant_token}{request_payload}\")\n            },\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, auth.api_secret.expose().as_bytes());\n        let tag = hmac::sign(&key, signature_string.expose().as_bytes());\n        let hmac_sign = hex::encode(tag);\n        let signature_value = common_utils::consts::BASE64_ENGINE_URL_SAFE.encode(hmac_sign);\n        Ok(vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                Self.get_content_type().to_string().into(),\n            ),\n            (headers::APIKEY.to_string(), auth.api_key.into_masked()),\n            (\n                headers::TOKEN.to_string(),\n                auth.merchant_token.into_masked(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signature_value.into_masked(),\n            ),\n            (headers::NONCE.to_string(), nonce.into_masked()),\n            (headers::TIMESTAMP.to_string(), timestamp.into()),\n        ])\n    }\n}\n\nimpl ConnectorCommon for Payeezy {\n    fn id(&self) -> &'static str {\n        \"payeezy\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.payeezy.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: payeezy::PayeezyErrorResponse = res\n            .response\n            .parse_struct(\"payeezy ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        let error_messages: Vec<String> = response\n            .error\n            .messages\n            .iter()",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__payeezy.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__envoy.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as envoy;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Envoy {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Envoy {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Envoy {}\nimpl api::PaymentSession for Envoy {}\nimpl api::ConnectorAccessToken for Envoy {}\nimpl api::MandateSetup for Envoy {}\nimpl api::PaymentAuthorize for Envoy {}\nimpl api::PaymentSync for Envoy {}\nimpl api::PaymentCapture for Envoy {}\nimpl api::PaymentVoid for Envoy {}\nimpl api::Refund for Envoy {}\nimpl api::RefundExecute for Envoy {}\nimpl api::RefundSync for Envoy {}\nimpl api::PaymentToken for Envoy {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Envoy\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Envoy\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Envoy {\n    fn id(&self) -> &'static str {\n        \"envoy\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.envoy.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = envoy::EnvoyAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: envoy::EnvoyErrorResponse =\n            res.response\n                .parse_struct(\"EnvoyErrorResponse\")\n                .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__envoy.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__envoy.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as envoy;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Envoy {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Envoy {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Envoy {}\nimpl api::PaymentSession for Envoy {}\nimpl api::ConnectorAccessToken for Envoy {}\nimpl api::MandateSetup for Envoy {}\nimpl api::PaymentAuthorize for Envoy {}\nimpl api::PaymentSync for Envoy {}\nimpl api::PaymentCapture for Envoy {}\nimpl api::PaymentVoid for Envoy {}\nimpl api::Refund for Envoy {}\nimpl api::RefundExecute for Envoy {}\nimpl api::RefundSync for Envoy {}\nimpl api::PaymentToken for Envoy {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Envoy\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Envoy\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Envoy {\n    fn id(&self) -> &'static str {\n        \"envoy\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.envoy.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = envoy::EnvoyAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: envoy::EnvoyErrorResponse =\n            res.response\n                .parse_struct(\"EnvoyErrorResponse\")\n                .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__envoy.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as envoy;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Envoy {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Envoy {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Envoy {}\nimpl api::PaymentSession for Envoy {}\nimpl api::ConnectorAccessToken for Envoy {}\nimpl api::MandateSetup for Envoy {}\nimpl api::PaymentAuthorize for Envoy {}\nimpl api::PaymentSync for Envoy {}\nimpl api::PaymentCapture for Envoy {}\nimpl api::PaymentVoid for Envoy {}\nimpl api::Refund for Envoy {}\nimpl api::RefundExecute for Envoy {}\nimpl api::RefundSync for Envoy {}\nimpl api::PaymentToken for Envoy {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Envoy\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Envoy\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Envoy {\n    fn id(&self) -> &'static str {\n        \"envoy\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.envoy.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = envoy::EnvoyAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: envoy::EnvoyErrorResponse =\n            res.response\n                .parse_struct(\"EnvoyErrorResponse\")\n                .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__envoy.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__zift.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as zift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Zift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Zift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Zift {}\nimpl api::PaymentSession for Zift {}\nimpl api::ConnectorAccessToken for Zift {}\nimpl api::PaymentAuthorize for Zift {}\nimpl api::PaymentSync for Zift {}\nimpl api::PaymentCapture for Zift {}\nimpl api::PaymentVoid for Zift {}\nimpl api::Refund for Zift {}\nimpl api::RefundExecute for Zift {}\nimpl api::RefundSync for Zift {}\nimpl api::PaymentToken for Zift {}\nimpl api::MandateSetup for Zift {}\n\nimpl ConnectorIntegration<SetupMandate, SetupMandateRequestData, PaymentsResponseData> for Zift {\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_content_type(&self) -> &'static str {\n        self.common_get_content_type()\n    }\n\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__zift.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__zift.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as zift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Zift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Zift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Zift {}\nimpl api::PaymentSession for Zift {}\nimpl api::ConnectorAccessToken for Zift {}\nimpl api::PaymentAuthorize for Zift {}\nimpl api::PaymentSync for Zift {}\nimpl api::PaymentCapture for Zift {}\nimpl api::PaymentVoid for Zift {}\nimpl api::Refund for Zift {}\nimpl api::RefundExecute for Zift {}\nimpl api::RefundSync for Zift {}\nimpl api::PaymentToken for Zift {}\nimpl api::MandateSetup for Zift {}\n\nimpl ConnectorIntegration<SetupMandate, SetupMandateRequestData, PaymentsResponseData> for Zift {\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_content_type(&self) -> &'static str {\n        self.common_get_content_type()\n    }\n\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__zift.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse transformers as zift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Zift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Zift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Zift {}\nimpl api::PaymentSession for Zift {}\nimpl api::ConnectorAccessToken for Zift {}\nimpl api::PaymentAuthorize for Zift {}\nimpl api::PaymentSync for Zift {}\nimpl api::PaymentCapture for Zift {}\nimpl api::PaymentVoid for Zift {}\nimpl api::Refund for Zift {}\nimpl api::RefundExecute for Zift {}\nimpl api::RefundSync for Zift {}\nimpl api::PaymentToken for Zift {}\nimpl api::MandateSetup for Zift {}\n\nimpl ConnectorIntegration<SetupMandate, SetupMandateRequestData, PaymentsResponseData> for Zift {\n    fn get_headers(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_content_type(&self) -> &'static str {\n        self.common_get_content_type()\n    }\n\n    fn get_url(\n        &self,\n        _req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}gates/xurl\", self.base_url(connectors)))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &SetupMandateRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = zift::ZiftSetupMandateRequest::try_from(req)?;\n        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &SetupMandateRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&types::SetupMandateType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(types::SetupMandateType::get_headers(self, req, connectors)?)\n                .set_body(types::SetupMandateType::get_request_body(\n                    self, req, connectors,\n                )?)\n                .build(),\n        ))\n    }\n\n    fn handle_response(\n        &self,\n        data: &SetupMandateRouterData,\n        event_builder: Option<&mut ConnectorEvent>,\n        res: Response,\n    ) -> CustomResult<SetupMandateRouterData, errors::ConnectorError> {\n        let response: zift::ZiftAuthPaymentsResponse = serde_urlencoded::from_bytes(&res.response)\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n        RouterData::try_from(ResponseRouterData {\n            response,\n            data: data.clone(),\n            http_code: res.status_code,\n        })\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__zift.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payload.rs",
    "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{HmacSha256, VerifySignature},\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, PaymentsVoidType, Response, SetupMandateType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as payload;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Payload {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Payload {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Payload {}\nimpl api::PaymentSession for Payload {}\nimpl api::ConnectorAccessToken for Payload {}\nimpl api::MandateSetup for Payload {}\nimpl api::PaymentAuthorize for Payload {}\nimpl api::PaymentSync for Payload {}\nimpl api::PaymentCapture for Payload {}\nimpl api::PaymentVoid for Payload {}\nimpl api::Refund for Payload {}\nimpl api::RefundExecute for Payload {}\nimpl api::RefundSync for Payload {}\nimpl api::PaymentToken for Payload {}\nimpl api::ConnectorCustomer for Payload {}\n\nimpl ConnectorIntegration<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>\n    for Payload\n{\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            \"application/json\".to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/customers\", self.base_url(connectors),))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = requests::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payload.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payload.rs",
    "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{HmacSha256, VerifySignature},\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, PaymentsVoidType, Response, SetupMandateType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as payload;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Payload {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Payload {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Payload {}\nimpl api::PaymentSession for Payload {}\nimpl api::ConnectorAccessToken for Payload {}\nimpl api::MandateSetup for Payload {}\nimpl api::PaymentAuthorize for Payload {}\nimpl api::PaymentSync for Payload {}\nimpl api::PaymentCapture for Payload {}\nimpl api::PaymentVoid for Payload {}\nimpl api::Refund for Payload {}\nimpl api::RefundExecute for Payload {}\nimpl api::RefundSync for Payload {}\nimpl api::PaymentToken for Payload {}\nimpl api::ConnectorCustomer for Payload {}\n\nimpl ConnectorIntegration<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>\n    for Payload\n{\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            \"application/json\".to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/customers\", self.base_url(connectors),))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = requests::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payload.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "mod requests;\nmod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{HmacSha256, VerifySignature},\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, PaymentsVoidType, Response, SetupMandateType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as payload;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentsSyncRequestData, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Payload {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Payload {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Payload {}\nimpl api::PaymentSession for Payload {}\nimpl api::ConnectorAccessToken for Payload {}\nimpl api::MandateSetup for Payload {}\nimpl api::PaymentAuthorize for Payload {}\nimpl api::PaymentSync for Payload {}\nimpl api::PaymentCapture for Payload {}\nimpl api::PaymentVoid for Payload {}\nimpl api::Refund for Payload {}\nimpl api::RefundExecute for Payload {}\nimpl api::RefundSync for Payload {}\nimpl api::PaymentToken for Payload {}\nimpl api::ConnectorCustomer for Payload {}\n\nimpl ConnectorIntegration<CreateConnectorCustomer, ConnectorCustomerData, PaymentsResponseData>\n    for Payload\n{\n    fn get_headers(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            \"application/json\".to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n    fn get_url(\n        &self,\n        _req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}/customers\", self.base_url(connectors),))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = requests::CustomerRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &ConnectorCustomerRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Ok(Some(\n            RequestBuilder::new()\n                .method(Method::Post)\n                .url(&ConnectorCustomerType::get_url(self, req, connectors)?)\n                .attach_default_headers()\n                .headers(ConnectorCustomerType::get_headers(self, req, connectors)?)\n                .set_body(ConnectorCustomerType::get_request_body(\n                    self, req, connectors,\n                )?)",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payload.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__hipay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{self as common_errors, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse reqwest::multipart::Form;\nuse serde::Serialize;\nuse serde_json::Value;\nuse transformers as hipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub fn build_form_from_struct<T: Serialize + Send + 'static>(\n    data: T,\n) -> Result<RequestContent, common_errors::ParsingError> {\n    let mut form = Form::new();\n    let serialized = serde_json::to_value(&data).map_err(|e| {\n        router_env::logger::error!(\"Error serializing data to JSON value: {:?}\", e);\n        common_errors::ParsingError::EncodeError(\"json-value\")\n    })?;\n    let serialized_object = serialized.as_object().ok_or_else(|| {\n        router_env::logger::error!(\"Error: Expected JSON object but got something else\");\n        common_errors::ParsingError::EncodeError(\"Expected object\")\n    })?;\n    for (key, values) in serialized_object {\n        let value = match values {\n            Value::String(s) => s.clone(),\n            Value::Number(n) => n.to_string(),\n            Value::Bool(b) => b.to_string(),\n            Value::Null => \"\".to_string(),\n            Value::Array(_) | Value::Object(_) => {\n                router_env::logger::error!(serialization_error =? \"Form Construction Failed.\");\n                \"\".to_string()\n            }\n        };\n        form = form.text(key.clone(), value.clone());\n    }\n    Ok(RequestContent::FormData((form, Box::new(data))))\n}\n#[derive(Clone)]\npub struct Hipay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Hipay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hipay {}\nimpl api::PaymentSession for Hipay {}\nimpl api::ConnectorAccessToken for Hipay {}\nimpl api::MandateSetup for Hipay {}\nimpl api::PaymentAuthorize for Hipay {}\nimpl api::PaymentSync for Hipay {}\nimpl api::PaymentCapture for Hipay {}\nimpl api::PaymentVoid for Hipay {}\nimpl api::Refund for Hipay {}\nimpl api::RefundExecute for Hipay {}\nimpl api::RefundSync for Hipay {}\nimpl api::PaymentToken for Hipay {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Hipay\n{\n    fn get_headers(\n        &self,\n        req: &TokenizationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_url(\n        &self,\n        _req: &TokenizationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}v2/token/create\",\n            connectors.hipay.secondary_base_url.clone()\n        ))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &TokenizationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = transformers::HiPayTokenRequest::try_from(req)?;\n        router_env::logger::info!(raw_connector_request=?connector_req);\n        build_form_from_struct(connector_req).change_context(errors::ConnectorError::ParsingFailed)\n    }\n\n    fn build_request(\n        &self,",
    "function_name": "build_form_from_struct",
    "file": "crates__hyperswitch_connectors__src__connectors__hipay.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__hipay.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{self as common_errors, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse reqwest::multipart::Form;\nuse serde::Serialize;\nuse serde_json::Value;\nuse transformers as hipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub fn build_form_from_struct<T: Serialize + Send + 'static>(\n    data: T,\n) -> Result<RequestContent, common_errors::ParsingError> {\n    let mut form = Form::new();\n    let serialized = serde_json::to_value(&data).map_err(|e| {\n        router_env::logger::error!(\"Error serializing data to JSON value: {:?}\", e);\n        common_errors::ParsingError::EncodeError(\"json-value\")\n    })?;\n    let serialized_object = serialized.as_object().ok_or_else(|| {\n        router_env::logger::error!(\"Error: Expected JSON object but got something else\");\n        common_errors::ParsingError::EncodeError(\"Expected object\")\n    })?;\n    for (key, values) in serialized_object {\n        let value = match values {\n            Value::String(s) => s.clone(),\n            Value::Number(n) => n.to_string(),\n            Value::Bool(b) => b.to_string(),\n            Value::Null => \"\".to_string(),\n            Value::Array(_) | Value::Object(_) => {\n                router_env::logger::error!(serialization_error =? \"Form Construction Failed.\");\n                \"\".to_string()\n            }\n        };\n        form = form.text(key.clone(), value.clone());\n    }\n    Ok(RequestContent::FormData((form, Box::new(data))))\n}\n#[derive(Clone)]\npub struct Hipay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Hipay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hipay {}\nimpl api::PaymentSession for Hipay {}\nimpl api::ConnectorAccessToken for Hipay {}\nimpl api::MandateSetup for Hipay {}\nimpl api::PaymentAuthorize for Hipay {}\nimpl api::PaymentSync for Hipay {}\nimpl api::PaymentCapture for Hipay {}\nimpl api::PaymentVoid for Hipay {}\nimpl api::Refund for Hipay {}\nimpl api::RefundExecute for Hipay {}\nimpl api::RefundSync for Hipay {}\nimpl api::PaymentToken for Hipay {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Hipay\n{\n    fn get_headers(\n        &self,\n        req: &TokenizationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_url(\n        &self,\n        _req: &TokenizationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}v2/token/create\",\n            connectors.hipay.secondary_base_url.clone()\n        ))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &TokenizationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = transformers::HiPayTokenRequest::try_from(req)?;\n        router_env::logger::info!(raw_connector_request=?connector_req);\n        build_form_from_struct(connector_req).change_context(errors::ConnectorError::ParsingFailed)\n    }\n\n    fn build_request(\n        &self,",
    "function_name": "build_form_from_struct",
    "file": "crates__hyperswitch_connectors__src__connectors__hipay.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_form_from_struct",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{self as common_errors, CustomResult},\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse reqwest::multipart::Form;\nuse serde::Serialize;\nuse serde_json::Value;\nuse transformers as hipay;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub fn build_form_from_struct<T: Serialize + Send + 'static>(\n    data: T,\n) -> Result<RequestContent, common_errors::ParsingError> {\n    let mut form = Form::new();\n    let serialized = serde_json::to_value(&data).map_err(|e| {\n        router_env::logger::error!(\"Error serializing data to JSON value: {:?}\", e);\n        common_errors::ParsingError::EncodeError(\"json-value\")\n    })?;\n    let serialized_object = serialized.as_object().ok_or_else(|| {\n        router_env::logger::error!(\"Error: Expected JSON object but got something else\");\n        common_errors::ParsingError::EncodeError(\"Expected object\")\n    })?;\n    for (key, values) in serialized_object {\n        let value = match values {\n            Value::String(s) => s.clone(),\n            Value::Number(n) => n.to_string(),\n            Value::Bool(b) => b.to_string(),\n            Value::Null => \"\".to_string(),\n            Value::Array(_) | Value::Object(_) => {\n                router_env::logger::error!(serialization_error =? \"Form Construction Failed.\");\n                \"\".to_string()\n            }\n        };\n        form = form.text(key.clone(), value.clone());\n    }\n    Ok(RequestContent::FormData((form, Box::new(data))))\n}\n#[derive(Clone)]\npub struct Hipay {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Hipay {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hipay {}\nimpl api::PaymentSession for Hipay {}\nimpl api::ConnectorAccessToken for Hipay {}\nimpl api::MandateSetup for Hipay {}\nimpl api::PaymentAuthorize for Hipay {}\nimpl api::PaymentSync for Hipay {}\nimpl api::PaymentCapture for Hipay {}\nimpl api::PaymentVoid for Hipay {}\nimpl api::Refund for Hipay {}\nimpl api::RefundExecute for Hipay {}\nimpl api::RefundSync for Hipay {}\nimpl api::PaymentToken for Hipay {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Hipay\n{\n    fn get_headers(\n        &self,\n        req: &TokenizationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_url(\n        &self,\n        _req: &TokenizationRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\n            \"{}v2/token/create\",\n            connectors.hipay.secondary_base_url.clone()\n        ))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &TokenizationRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = transformers::HiPayTokenRequest::try_from(req)?;\n        router_env::logger::info!(raw_connector_request=?connector_req);\n        build_form_from_struct(connector_req).change_context(errors::ConnectorError::ParsingFailed)\n    }\n\n    fn build_request(\n        &self,",
    "function_name": "build_form_from_struct",
    "file": "crates__hyperswitch_connectors__src__connectors__hipay.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__noon__transformers.rs",
    "code": "use common_enums::enums::{self, AttemptStatus};\nuse common_utils::{ext_traits::Encode, pii, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::{MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, GooglePayWalletData, PaymentsAuthorizeRequestData,\n        RevokeMandateRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\n#[derive(Debug, Serialize)]\npub struct NoonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    pub mandate_amount: Option<StringMajorUnit>,\n}\n\nimpl<T> From<(StringMajorUnit, T, Option<StringMajorUnit>)> for NoonRouterData<T> {\n    fn from(\n        (amount, router_data, mandate_amount): (StringMajorUnit, T, Option<StringMajorUnit>),\n    ) -> Self {\n        Self {\n            amount,\n            router_data,\n            mandate_amount,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonChannels {\n    Web,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonSubscriptionType {\n    Unscheduled,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonSubscriptionData {\n    #[serde(rename = \"type\")]\n    subscription_type: NoonSubscriptionType,\n    //Short description about the subscription.\n    name: String,\n    max_amount: StringMajorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonBillingAddress {\n    street: Option<Secret<String>>,\n    street2: Option<Secret<String>>,\n    city: Option<String>,\n    state_province: Option<Secret<String>>,\n    country: Option<api_models::enums::CountryAlpha2>,\n    postal_code: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonBilling {\n    address: NoonBillingAddress,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonOrder {\n    amount: StringMajorUnit,\n    currency: Option<enums::Currency>,\n    channel: NoonChannels,\n    category: Option<String>,\n    reference: String,\n    //Short description of the order.\n    name: String,\n    nvp: Option<NoonOrderNvp>,\n    ip_address: Option<Secret<String, pii::IpAddress>>,\n}\n\n#[derive(Debug, Serialize)]\npub struct NoonOrderNvp {\n    #[serde(flatten)]\n    inner: std::collections::BTreeMap<String, Secret<String>>,\n}\n\nfn get_value_as_string(value: &serde_json::Value) -> String {\n    match value {\n        serde_json::Value::String(string) => string.to_owned(),\n        serde_json::Value::Null\n        | serde_json::Value::Bool(_)\n        | serde_json::Value::Number(_)\n        | serde_json::Value::Array(_)\n        | serde_json::Value::Object(_) => value.to_string(),\n    }\n}\n\nimpl NoonOrderNvp {\n    pub fn new(metadata: &serde_json::Value) -> Self {\n        let metadata_as_string = metadata.to_string();\n        let hash_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_str(&metadata_as_string).unwrap_or(std::collections::BTreeMap::new());\n        let inner = hash_map\n            .into_iter()\n            .enumerate()\n            .map(|(index, (hs_key, hs_value))| {\n                let noon_key = format!(\"{}\", index + 1);\n                // to_string() function on serde_json::Value returns a string with \"\" quotes. Noon doesn't allow this. Hence get_value_as_string function\n                let noon_value = format!(\"{hs_key}={}\", get_value_as_string(&hs_value));\n                (noon_key, Secret::new(noon_value))\n            })\n            .collect();\n        Self { inner }\n    }\n}",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__noon__transformers.rs",
    "code": "use common_enums::enums::{self, AttemptStatus};\nuse common_utils::{ext_traits::Encode, pii, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::{MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, GooglePayWalletData, PaymentsAuthorizeRequestData,\n        RevokeMandateRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\n#[derive(Debug, Serialize)]\npub struct NoonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    pub mandate_amount: Option<StringMajorUnit>,\n}\n\nimpl<T> From<(StringMajorUnit, T, Option<StringMajorUnit>)> for NoonRouterData<T> {\n    fn from(\n        (amount, router_data, mandate_amount): (StringMajorUnit, T, Option<StringMajorUnit>),\n    ) -> Self {\n        Self {\n            amount,\n            router_data,\n            mandate_amount,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonChannels {\n    Web,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonSubscriptionType {\n    Unscheduled,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonSubscriptionData {\n    #[serde(rename = \"type\")]\n    subscription_type: NoonSubscriptionType,\n    //Short description about the subscription.\n    name: String,\n    max_amount: StringMajorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonBillingAddress {\n    street: Option<Secret<String>>,\n    street2: Option<Secret<String>>,\n    city: Option<String>,\n    state_province: Option<Secret<String>>,\n    country: Option<api_models::enums::CountryAlpha2>,\n    postal_code: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonBilling {\n    address: NoonBillingAddress,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonOrder {\n    amount: StringMajorUnit,\n    currency: Option<enums::Currency>,\n    channel: NoonChannels,\n    category: Option<String>,\n    reference: String,\n    //Short description of the order.\n    name: String,\n    nvp: Option<NoonOrderNvp>,\n    ip_address: Option<Secret<String, pii::IpAddress>>,\n}\n\n#[derive(Debug, Serialize)]\npub struct NoonOrderNvp {\n    #[serde(flatten)]\n    inner: std::collections::BTreeMap<String, Secret<String>>,\n}\n\nfn get_value_as_string(value: &serde_json::Value) -> String {\n    match value {\n        serde_json::Value::String(string) => string.to_owned(),\n        serde_json::Value::Null\n        | serde_json::Value::Bool(_)\n        | serde_json::Value::Number(_)\n        | serde_json::Value::Array(_)\n        | serde_json::Value::Object(_) => value.to_string(),\n    }\n}\n\nimpl NoonOrderNvp {\n    pub fn new(metadata: &serde_json::Value) -> Self {\n        let metadata_as_string = metadata.to_string();\n        let hash_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_str(&metadata_as_string).unwrap_or(std::collections::BTreeMap::new());\n        let inner = hash_map\n            .into_iter()\n            .enumerate()\n            .map(|(index, (hs_key, hs_value))| {\n                let noon_key = format!(\"{}\", index + 1);\n                // to_string() function on serde_json::Value returns a string with \"\" quotes. Noon doesn't allow this. Hence get_value_as_string function\n                let noon_value = format!(\"{hs_key}={}\", get_value_as_string(&hs_value));\n                (noon_key, Secret::new(noon_value))\n            })\n            .collect();\n        Self { inner }\n    }\n}",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::enums::{self, AttemptStatus};\nuse common_utils::{ext_traits::Encode, pii, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{Execute, RSync},\n    router_request_types::{MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, CardData, GooglePayWalletData, PaymentsAuthorizeRequestData,\n        RevokeMandateRequestData, RouterData as OtherRouterData, WalletData as OtherWalletData,\n    },\n};\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\n#[derive(Debug, Serialize)]\npub struct NoonRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n    pub mandate_amount: Option<StringMajorUnit>,\n}\n\nimpl<T> From<(StringMajorUnit, T, Option<StringMajorUnit>)> for NoonRouterData<T> {\n    fn from(\n        (amount, router_data, mandate_amount): (StringMajorUnit, T, Option<StringMajorUnit>),\n    ) -> Self {\n        Self {\n            amount,\n            router_data,\n            mandate_amount,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonChannels {\n    Web,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum NoonSubscriptionType {\n    Unscheduled,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonSubscriptionData {\n    #[serde(rename = \"type\")]\n    subscription_type: NoonSubscriptionType,\n    //Short description about the subscription.\n    name: String,\n    max_amount: StringMajorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonBillingAddress {\n    street: Option<Secret<String>>,\n    street2: Option<Secret<String>>,\n    city: Option<String>,\n    state_province: Option<Secret<String>>,\n    country: Option<api_models::enums::CountryAlpha2>,\n    postal_code: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonBilling {\n    address: NoonBillingAddress,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NoonOrder {\n    amount: StringMajorUnit,\n    currency: Option<enums::Currency>,\n    channel: NoonChannels,\n    category: Option<String>,\n    reference: String,\n    //Short description of the order.\n    name: String,\n    nvp: Option<NoonOrderNvp>,\n    ip_address: Option<Secret<String, pii::IpAddress>>,\n}\n\n#[derive(Debug, Serialize)]\npub struct NoonOrderNvp {\n    #[serde(flatten)]\n    inner: std::collections::BTreeMap<String, Secret<String>>,\n}\n\nfn get_value_as_string(value: &serde_json::Value) -> String {\n    match value {\n        serde_json::Value::String(string) => string.to_owned(),\n        serde_json::Value::Null\n        | serde_json::Value::Bool(_)\n        | serde_json::Value::Number(_)\n        | serde_json::Value::Array(_)\n        | serde_json::Value::Object(_) => value.to_string(),\n    }\n}\n\nimpl NoonOrderNvp {\n    pub fn new(metadata: &serde_json::Value) -> Self {\n        let metadata_as_string = metadata.to_string();\n        let hash_map: std::collections::BTreeMap<String, serde_json::Value> =\n            serde_json::from_str(&metadata_as_string).unwrap_or(std::collections::BTreeMap::new());\n        let inner = hash_map\n            .into_iter()\n            .enumerate()\n            .map(|(index, (hs_key, hs_value))| {\n                let noon_key = format!(\"{}\", index + 1);\n                // to_string() function on serde_json::Value returns a string with \"\" quotes. Noon doesn't allow this. Hence get_value_as_string function\n                let noon_value = format!(\"{hs_key}={}\", get_value_as_string(&hs_value));\n                (noon_key, Secret::new(noon_value))\n            })\n            .collect();\n        Self { inner }\n    }\n}",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__noon__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__routes__payments.rs",
    "code": "use crate::{\n    core::api_locking::{self, GetLockingInput},\n    services::authorization::permissions::Permission,\n};\npub mod helpers;\nuse actix_web::{web, Responder};\nuse error_stack::report;\nuse hyperswitch_domain_models::{ext_traits::OptionExt, payments::HeaderPayload};\nuse masking::{PeekInterface, Secret};\nuse router_env::{env, instrument, logger, tracing, types, Flow};\n\nuse super::app::ReqState;\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_method_balance;\n#[cfg(feature = \"v2\")]\nuse crate::core::revenue_recovery::api as recovery;\nuse crate::{\n    self as app,\n    core::{\n        errors::{self, http_not_implemented},\n        payments::{self, PaymentRedirectFlow},\n    },\n    routes::lock_utils,\n    services::{api, authentication as auth},\n    types::{\n        api::{\n            self as api_types, enums as api_enums,\n            payments::{self as payment_types, PaymentIdTypeExt},\n        },\n        domain,\n        transformers::ForeignTryFrom,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentsCreate, payment_id))]\npub async fn payments_create(\n    state: web::Data<app::AppState>,\n    req: actix_web::HttpRequest,\n    json_payload: web::Json<payment_types::PaymentsRequest>,\n) -> impl Responder {\n    let flow = Flow::PaymentsCreate;\n    let mut payload = json_payload.into_inner();\n    if let Err(err) = payload\n        .validate()\n        .map_err(|message| errors::ApiErrorResponse::InvalidRequestData { message })\n    {\n        return api::log_and_return_error_response(err.into());\n    };\n\n    if let Err(err) = payload\n        .payment_link_config\n        .as_ref()\n        .map(|cfg| {\n            cfg.theme_config\n                .validate()\n                .map_err(|message| errors::ApiErrorResponse::InvalidRequestData { message })\n        })\n        .transpose()\n    {\n        return api::log_and_return_error_response(err.into());\n    };\n\n    if let Some(api_enums::CaptureMethod::Scheduled) = payload.capture_method {\n        return http_not_implemented();\n    };\n\n    if let Err(err) = get_or_generate_payment_id(&mut payload) {\n        return api::log_and_return_error_response(err);\n    }\n\n    let header_payload = match HeaderPayload::foreign_try_from(req.headers()) {\n        Ok(headers) => headers,\n        Err(err) => {\n            return api::log_and_return_error_response(err);\n        }\n    };\n\n    tracing::Span::current().record(\n        \"payment_id\",\n        payload\n            .payment_id\n            .as_ref()\n            .map(|payment_id_type| payment_id_type.get_payment_intent_id())\n            .transpose()\n            .unwrap_or_default()\n            .as_ref()\n            .map(|id| id.get_string_repr())\n            .unwrap_or_default(),\n    );\n\n    let locking_action = payload.get_locking_input(flow.clone());\n\n    let auth_type = match env::which() {\n        env::Env::Production => {\n            &auth::InternalMerchantIdProfileIdAuth(auth::HeaderAuth(auth::ApiKeyAuth {\n                allow_connected_scope_operation: true,\n                allow_platform_self_operation: false,\n            }))\n        }\n        _ => auth::auth_type(\n            &auth::InternalMerchantIdProfileIdAuth(auth::HeaderAuth(auth::ApiKeyAuth {\n                allow_connected_scope_operation: true,\n                allow_platform_self_operation: false,\n            })),\n            &auth::InternalMerchantIdProfileIdAuth(auth::JWTAuth {\n                permission: Permission::ProfilePaymentWrite,\n            }),\n            req.headers(),\n        ),\n    };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        payload,\n        |state, auth: auth::AuthenticationData, req, req_state| {\n            authorize_verify_select::<_>(\n                payments::PaymentCreate,\n                state,\n                req_state,\n                auth.platform,\n                auth.profile.map(|profile| profile.get_id().clone()),\n                header_payload.clone(),\n                req,\n                api::AuthFlow::Client,\n            )\n        },\n        auth_type,\n        locking_action,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\npub async fn recovery_payments_create(\n    state: web::Data<app::AppState>,\n    req: actix_web::HttpRequest,\n    json_payload: web::Json<payment_types::RecoveryPaymentsCreate>,",
    "function_name": "payments_create",
    "file": "crates__router__src__routes__payments.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__routes__payments.rs",
    "code": "use crate::{\n    core::api_locking::{self, GetLockingInput},\n    services::authorization::permissions::Permission,\n};\npub mod helpers;\nuse actix_web::{web, Responder};\nuse error_stack::report;\nuse hyperswitch_domain_models::{ext_traits::OptionExt, payments::HeaderPayload};\nuse masking::{PeekInterface, Secret};\nuse router_env::{env, instrument, logger, tracing, types, Flow};\n\nuse super::app::ReqState;\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_method_balance;\n#[cfg(feature = \"v2\")]\nuse crate::core::revenue_recovery::api as recovery;\nuse crate::{\n    self as app,\n    core::{\n        errors::{self, http_not_implemented},\n        payments::{self, PaymentRedirectFlow},\n    },\n    routes::lock_utils,\n    services::{api, authentication as auth},\n    types::{\n        api::{\n            self as api_types, enums as api_enums,\n            payments::{self as payment_types, PaymentIdTypeExt},\n        },\n        domain,\n        transformers::ForeignTryFrom,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentsCreate, payment_id))]\npub async fn payments_create(\n    state: web::Data<app::AppState>,\n    req: actix_web::HttpRequest,\n    json_payload: web::Json<payment_types::PaymentsRequest>,\n) -> impl Responder {\n    let flow = Flow::PaymentsCreate;\n    let mut payload = json_payload.into_inner();\n    if let Err(err) = payload\n        .validate()\n        .map_err(|message| errors::ApiErrorResponse::InvalidRequestData { message })\n    {\n        return api::log_and_return_error_response(err.into());\n    };\n\n    if let Err(err) = payload\n        .payment_link_config\n        .as_ref()\n        .map(|cfg| {\n            cfg.theme_config\n                .validate()\n                .map_err(|message| errors::ApiErrorResponse::InvalidRequestData { message })\n        })\n        .transpose()\n    {\n        return api::log_and_return_error_response(err.into());\n    };\n\n    if let Some(api_enums::CaptureMethod::Scheduled) = payload.capture_method {\n        return http_not_implemented();\n    };\n\n    if let Err(err) = get_or_generate_payment_id(&mut payload) {\n        return api::log_and_return_error_response(err);\n    }\n\n    let header_payload = match HeaderPayload::foreign_try_from(req.headers()) {\n        Ok(headers) => headers,\n        Err(err) => {\n            return api::log_and_return_error_response(err);\n        }\n    };\n\n    tracing::Span::current().record(\n        \"payment_id\",\n        payload\n            .payment_id\n            .as_ref()\n            .map(|payment_id_type| payment_id_type.get_payment_intent_id())\n            .transpose()\n            .unwrap_or_default()\n            .as_ref()\n            .map(|id| id.get_string_repr())\n            .unwrap_or_default(),\n    );\n\n    let locking_action = payload.get_locking_input(flow.clone());\n\n    let auth_type = match env::which() {\n        env::Env::Production => {\n            &auth::InternalMerchantIdProfileIdAuth(auth::HeaderAuth(auth::ApiKeyAuth {\n                allow_connected_scope_operation: true,\n                allow_platform_self_operation: false,\n            }))\n        }\n        _ => auth::auth_type(\n            &auth::InternalMerchantIdProfileIdAuth(auth::HeaderAuth(auth::ApiKeyAuth {\n                allow_connected_scope_operation: true,\n                allow_platform_self_operation: false,\n            })),\n            &auth::InternalMerchantIdProfileIdAuth(auth::JWTAuth {\n                permission: Permission::ProfilePaymentWrite,\n            }),\n            req.headers(),\n        ),\n    };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        payload,\n        |state, auth: auth::AuthenticationData, req, req_state| {\n            authorize_verify_select::<_>(\n                payments::PaymentCreate,\n                state,\n                req_state,\n                auth.platform,\n                auth.profile.map(|profile| profile.get_id().clone()),\n                header_payload.clone(),\n                req,\n                api::AuthFlow::Client,\n            )\n        },\n        auth_type,\n        locking_action,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\npub async fn recovery_payments_create(\n    state: web::Data<app::AppState>,\n    req: actix_web::HttpRequest,\n    json_payload: web::Json<payment_types::RecoveryPaymentsCreate>,",
    "function_name": "payments_create",
    "file": "crates__router__src__routes__payments.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for payments_create",
    "code": "use crate::{\n    core::api_locking::{self, GetLockingInput},\n    services::authorization::permissions::Permission,\n};\npub mod helpers;\nuse actix_web::{web, Responder};\nuse error_stack::report;\nuse hyperswitch_domain_models::{ext_traits::OptionExt, payments::HeaderPayload};\nuse masking::{PeekInterface, Secret};\nuse router_env::{env, instrument, logger, tracing, types, Flow};\n\nuse super::app::ReqState;\n#[cfg(feature = \"v2\")]\nuse crate::core::payment_method_balance;\n#[cfg(feature = \"v2\")]\nuse crate::core::revenue_recovery::api as recovery;\nuse crate::{\n    self as app,\n    core::{\n        errors::{self, http_not_implemented},\n        payments::{self, PaymentRedirectFlow},\n    },\n    routes::lock_utils,\n    services::{api, authentication as auth},\n    types::{\n        api::{\n            self as api_types, enums as api_enums,\n            payments::{self as payment_types, PaymentIdTypeExt},\n        },\n        domain,\n        transformers::ForeignTryFrom,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentsCreate, payment_id))]\npub async fn payments_create(\n    state: web::Data<app::AppState>,\n    req: actix_web::HttpRequest,\n    json_payload: web::Json<payment_types::PaymentsRequest>,\n) -> impl Responder {\n    let flow = Flow::PaymentsCreate;\n    let mut payload = json_payload.into_inner();\n    if let Err(err) = payload\n        .validate()\n        .map_err(|message| errors::ApiErrorResponse::InvalidRequestData { message })\n    {\n        return api::log_and_return_error_response(err.into());\n    };\n\n    if let Err(err) = payload\n        .payment_link_config\n        .as_ref()\n        .map(|cfg| {\n            cfg.theme_config\n                .validate()\n                .map_err(|message| errors::ApiErrorResponse::InvalidRequestData { message })\n        })\n        .transpose()\n    {\n        return api::log_and_return_error_response(err.into());\n    };\n\n    if let Some(api_enums::CaptureMethod::Scheduled) = payload.capture_method {\n        return http_not_implemented();\n    };\n\n    if let Err(err) = get_or_generate_payment_id(&mut payload) {\n        return api::log_and_return_error_response(err);\n    }\n\n    let header_payload = match HeaderPayload::foreign_try_from(req.headers()) {\n        Ok(headers) => headers,\n        Err(err) => {\n            return api::log_and_return_error_response(err);\n        }\n    };\n\n    tracing::Span::current().record(\n        \"payment_id\",\n        payload\n            .payment_id\n            .as_ref()\n            .map(|payment_id_type| payment_id_type.get_payment_intent_id())\n            .transpose()\n            .unwrap_or_default()\n            .as_ref()\n            .map(|id| id.get_string_repr())\n            .unwrap_or_default(),\n    );\n\n    let locking_action = payload.get_locking_input(flow.clone());\n\n    let auth_type = match env::which() {\n        env::Env::Production => {\n            &auth::InternalMerchantIdProfileIdAuth(auth::HeaderAuth(auth::ApiKeyAuth {\n                allow_connected_scope_operation: true,\n                allow_platform_self_operation: false,\n            }))\n        }\n        _ => auth::auth_type(\n            &auth::InternalMerchantIdProfileIdAuth(auth::HeaderAuth(auth::ApiKeyAuth {\n                allow_connected_scope_operation: true,\n                allow_platform_self_operation: false,\n            })),\n            &auth::InternalMerchantIdProfileIdAuth(auth::JWTAuth {\n                permission: Permission::ProfilePaymentWrite,\n            }),\n            req.headers(),\n        ),\n    };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        payload,\n        |state, auth: auth::AuthenticationData, req, req_state| {\n            authorize_verify_select::<_>(\n                payments::PaymentCreate,\n                state,\n                req_state,\n                auth.platform,\n                auth.profile.map(|profile| profile.get_id().clone()),\n                header_payload.clone(),\n                req,\n                api::AuthFlow::Client,\n            )\n        },\n        auth_type,\n        locking_action,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\npub async fn recovery_payments_create(\n    state: web::Data<app::AppState>,\n    req: actix_web::HttpRequest,\n    json_payload: web::Json<payment_types::RecoveryPaymentsCreate>,",
    "function_name": "payments_create",
    "file": "crates__router__src__routes__payments.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__wise__transformers.rs",
    "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum WiseHttpStatus {\n    String(String),\n    Number(u16),\n}\n\nimpl Default for WiseHttpStatus {\n    fn default() -> Self {\n        Self::String(\"\".to_string())\n    }\n}\n\nimpl WiseHttpStatus {\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum AccountType {\n    Checking,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__wise__transformers.rs",
    "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum WiseHttpStatus {\n    String(String),\n    Number(u16),\n}\n\nimpl Default for WiseHttpStatus {\n    fn default() -> Self {\n        Self::String(\"\".to_string())\n    }\n}\n\nimpl WiseHttpStatus {\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum AccountType {\n    Checking,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "#[cfg(feature = \"payouts\")]\nuse api_models::payouts::Bank;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts::PayoutMethodData;\n#[cfg(feature = \"payouts\")]\nuse common_enums::PayoutEntityType;\n#[cfg(feature = \"payouts\")]\nuse common_enums::{CountryAlpha2, PayoutStatus, PayoutType};\n#[cfg(feature = \"payouts\")]\nuse common_utils::pii::Email;\nuse common_utils::types::FloatMajorUnit;\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::types::{PayoutsResponseData, PayoutsRouterData};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"payouts\")]\nuse crate::types::PayoutsResponseRouterData;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::get_unimplemented_payment_method_error_message;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as _, RouterData as _};\n\ntype Error = error_stack::Report<ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct WiseRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for WiseRouterData<T> {\n    fn from((amount, router_data): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\npub struct WiseAuthType {\n    pub(super) api_key: Secret<String>,\n    #[allow(dead_code)]\n    pub(super) profile_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for WiseAuthType {\n    type Error = Error;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                api_key: api_key.to_owned(),\n                profile_id: key1.to_owned(),\n            }),\n            _ => Err(ConnectorError::FailedToObtainAuthType)?,\n        }\n    }\n}\n\n// Wise error response\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorResponse {\n    pub timestamp: Option<String>,\n    pub errors: Option<Vec<SubError>>,\n    pub status: Option<WiseHttpStatus>,\n    pub error: Option<String>,\n    pub error_description: Option<String>,\n    pub message: Option<String>,\n    pub path: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(untagged)]\npub enum WiseHttpStatus {\n    String(String),\n    Number(u16),\n}\n\nimpl Default for WiseHttpStatus {\n    fn default() -> Self {\n        Self::String(\"\".to_string())\n    }\n}\n\nimpl WiseHttpStatus {\n    pub fn get_status(&self) -> String {\n        match self {\n            Self::String(val) => val.clone(),\n            Self::Number(val) => val.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct SubError {\n    pub code: String,\n    pub message: String,\n    pub path: Option<String>,\n    pub field: Option<String>,\n}\n\n// Payouts\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseRecipientCreateRequest {\n    currency: String,\n    #[serde(rename = \"type\")]\n    recipient_type: RecipientType,\n    profile: Secret<String>,\n    account_holder_name: Secret<String>,\n    details: WiseBankDetails,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"snake_case\")]\n#[allow(dead_code)]\npub enum RecipientType {\n    Aba,\n    Iban,\n    SortCode,\n    SwiftCode,\n}\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum AccountType {\n    Checking,\n}\n\n#[cfg(feature = \"payouts\")]\n#[derive(Debug, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WiseBankDetails {\n    legal_type: LegalType,\n    account_type: Option<AccountType>,\n    address: Option<WiseAddressDetails>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__wise__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__hyperpg.rs",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as hyperpg;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Hyperpg {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Hyperpg {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hyperpg {}\nimpl api::PaymentSession for Hyperpg {}\nimpl api::ConnectorAccessToken for Hyperpg {}\nimpl api::MandateSetup for Hyperpg {}\nimpl api::PaymentAuthorize for Hyperpg {}\nimpl api::PaymentSync for Hyperpg {}\nimpl api::PaymentCapture for Hyperpg {}\nimpl api::PaymentVoid for Hyperpg {}\nimpl api::Refund for Hyperpg {}\nimpl api::RefundExecute for Hyperpg {}\nimpl api::RefundSync for Hyperpg {}\nimpl api::PaymentToken for Hyperpg {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Hyperpg\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Hyperpg\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Hyperpg {\n    fn id(&self) -> &'static str {\n        \"hyperpg\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.hyperpg.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        // This method is not implemented for Phonepe, as it will always call the UCS service which has the logic to create headers.\n        Err(errors::ConnectorError::NotImplemented(\"get_auth_header method\".to_string()).into())\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: hyperpg::HyperpgErrorResponse = res\n            .response\n            .parse_struct(\"HyperpgErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__hyperpg.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__hyperpg.rs",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as hyperpg;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Hyperpg {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Hyperpg {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hyperpg {}\nimpl api::PaymentSession for Hyperpg {}\nimpl api::ConnectorAccessToken for Hyperpg {}\nimpl api::MandateSetup for Hyperpg {}\nimpl api::PaymentAuthorize for Hyperpg {}\nimpl api::PaymentSync for Hyperpg {}\nimpl api::PaymentCapture for Hyperpg {}\nimpl api::PaymentVoid for Hyperpg {}\nimpl api::Refund for Hyperpg {}\nimpl api::RefundExecute for Hyperpg {}\nimpl api::RefundSync for Hyperpg {}\nimpl api::PaymentToken for Hyperpg {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Hyperpg\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Hyperpg\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Hyperpg {\n    fn id(&self) -> &'static str {\n        \"hyperpg\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.hyperpg.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        // This method is not implemented for Phonepe, as it will always call the UCS service which has the logic to create headers.\n        Err(errors::ConnectorError::NotImplemented(\"get_auth_header method\".to_string()).into())\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: hyperpg::HyperpgErrorResponse = res\n            .response\n            .parse_struct(\"HyperpgErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__hyperpg.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse transformers as hyperpg;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Hyperpg {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Hyperpg {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Hyperpg {}\nimpl api::PaymentSession for Hyperpg {}\nimpl api::ConnectorAccessToken for Hyperpg {}\nimpl api::MandateSetup for Hyperpg {}\nimpl api::PaymentAuthorize for Hyperpg {}\nimpl api::PaymentSync for Hyperpg {}\nimpl api::PaymentCapture for Hyperpg {}\nimpl api::PaymentVoid for Hyperpg {}\nimpl api::Refund for Hyperpg {}\nimpl api::RefundExecute for Hyperpg {}\nimpl api::RefundSync for Hyperpg {}\nimpl api::PaymentToken for Hyperpg {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Hyperpg\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Hyperpg\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Hyperpg {\n    fn id(&self) -> &'static str {\n        \"hyperpg\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.hyperpg.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        // This method is not implemented for Phonepe, as it will always call the UCS service which has the logic to create headers.\n        Err(errors::ConnectorError::NotImplemented(\"get_auth_header method\".to_string()).into())\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: hyperpg::HyperpgErrorResponse = res\n            .response\n            .parse_struct(\"HyperpgErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: response.code,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__hyperpg.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs",
    "code": "use api_models::{\n    payments as payment_types,\n    payments::{ApplePaySessionResponse, SessionToken},\n    webhooks::IncomingWebhookEvent,\n};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::{OptionExt, ValueExt},\n    pii,\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        RefundsRequestData, RouterData as _,\n    },\n};\n\npub const CHANNEL_CODE: &str = \"HyperSwitchBT_Ecom\";\npub const CLIENT_TOKEN_MUTATION: &str = \"mutation createClientToken($input: CreateClientTokenInput!) { createClientToken(input: $input) { clientToken}}\";\npub const TOKENIZE_CREDIT_CARD: &str = \"mutation  tokenizeCreditCard($input: TokenizeCreditCardInput!) { tokenizeCreditCard(input: $input) { clientMutationId paymentMethod { id } } }\";\npub const CHARGE_CREDIT_CARD_MUTATION: &str = \"mutation ChargeCreditCard($input: ChargeCreditCardInput!) { chargeCreditCard(input: $input) { transaction { id legacyId createdAt amount { value currencyCode } status } } }\";\npub const AUTHORIZE_CREDIT_CARD_MUTATION: &str = \"mutation authorizeCreditCard($input: AuthorizeCreditCardInput!) { authorizeCreditCard(input: $input) {  transaction { id legacyId amount { value currencyCode } status } } }\";\npub const CAPTURE_TRANSACTION_MUTATION: &str = \"mutation captureTransaction($input: CaptureTransactionInput!) { captureTransaction(input: $input) { clientMutationId transaction { id legacyId amount { value currencyCode } status } } }\";\npub const VOID_TRANSACTION_MUTATION: &str = \"mutation voidTransaction($input:  ReverseTransactionInput!) { reverseTransaction(input: $input) { clientMutationId reversal { ...  on Transaction { id legacyId amount { value currencyCode } status } } } }\";\npub const REFUND_TRANSACTION_MUTATION: &str = \"mutation refundTransaction($input:  RefundTransactionInput!) { refundTransaction(input: $input) {clientMutationId refund { id legacyId amount { value currencyCode } status } } }\";\npub const AUTHORIZE_AND_VAULT_CREDIT_CARD_MUTATION: &str=\"mutation authorizeCreditCard($input: AuthorizeCreditCardInput!) { authorizeCreditCard(input: $input) { transaction { id status createdAt paymentMethod { id } } } }\";\npub const CHARGE_AND_VAULT_TRANSACTION_MUTATION: &str =\"mutation ChargeCreditCard($input: ChargeCreditCardInput!) { chargeCreditCard(input: $input) { transaction { id status createdAt paymentMethod { id } } } }\";\npub const DELETE_PAYMENT_METHOD_FROM_VAULT_MUTATION: &str = \"mutation deletePaymentMethodFromVault($input: DeletePaymentMethodFromVaultInput!) { deletePaymentMethodFromVault(input: $input) { clientMutationId } }\";\npub const TRANSACTION_QUERY: &str = \"query($input: TransactionSearchInput!) { search { transactions(input: $input) { edges { node { id status } } } } }\";\npub const REFUND_QUERY: &str = \"query($input: RefundSearchInput!) { search { refunds(input: $input, first: 1) { edges { node { id status createdAt amount { value currencyCode } orderId } } } } }\";\npub const CHARGE_GOOGLE_PAY_MUTATION: &str = \"mutation ChargeGPay($input: ChargePaymentMethodInput!) { chargePaymentMethod(input: $input) { transaction { id status amount { value currencyCode } } } }\";\npub const AUTHORIZE_GOOGLE_PAY_MUTATION: &str = \"mutation authorizeGPay($input: AuthorizePaymentMethodInput!) { authorizePaymentMethod(input: $input) { transaction { id legacyId amount { value currencyCode } status } } }\";\npub const CHARGE_APPLE_PAY_MUTATION: &str = \"mutation ChargeApplepay($input: ChargePaymentMethodInput!) { chargePaymentMethod(input: $input) { transaction { id status amount { value currencyCode } } } }\";\npub const AUTHORIZE_APPLE_PAY_MUTATION: &str = \"mutation authorizeApplepay($input: AuthorizePaymentMethodInput!) { authorizePaymentMethod(input: $input) { transaction { id legacyId amount { value currencyCode } status } } }\";\npub const CHARGE_AND_VAULT_APPLE_PAY_MUTATION: &str = \"mutation ChargeApplepay($input: ChargePaymentMethodInput!) { chargePaymentMethod(input: $input) { transaction { id status amount { value currencyCode } paymentMethod { id } } } }\";\npub const AUTHORIZE_AND_VAULT_APPLE_PAY_MUTATION: &str = \"mutation authorizeApplepay($input: AuthorizePaymentMethodInput!) { authorizePaymentMethod(input: $input) { transaction { id legacyId amount { value currencyCode } status paymentMethod { id } } } }\";\npub const CHARGE_PAYPAL_MUTATION: &str = \"mutation ChargePaypal($input: ChargePaymentMethodInput!) { chargePaymentMethod(input: $input) { transaction { id status amount { value currencyCode } } } }\";\npub const AUTHORIZE_PAYPAL_MUTATION: &str = \"mutation authorizePaypal($input: AuthorizePaymentMethodInput!) { authorizePaymentMethod(input: $input) { transaction { id legacyId amount { value currencyCode } status } } }\";\npub const TOKENIZE_NETWORK_TOKEN: &str = \"mutation tokenizeNetworkToken($input: TokenizeNetworkTokenInput!) { tokenizeNetworkToken(input: $input) { clientMutationId paymentMethod { id } } }\";\n\npub type CardPaymentRequest = GenericBraintreeRequest<VariablePaymentInput>;\npub type MandatePaymentRequest = GenericBraintreeRequest<VariablePaymentInput>;\npub type BraintreeClientTokenRequest = GenericBraintreeRequest<VariableClientTokenInput>;\npub type BraintreeTokenRequest = GenericBraintreeRequest<VariableInput>;\npub type BraintreeCaptureRequest = GenericBraintreeRequest<VariableCaptureInput>;\npub type BraintreeRefundRequest = GenericBraintreeRequest<BraintreeRefundVariables>;\npub type BraintreePSyncRequest = GenericBraintreeRequest<PSyncInput>;\npub type BraintreeRSyncRequest = GenericBraintreeRequest<RSyncInput>;\n\npub type BraintreeApplePayTokenizeRequest = GenericBraintreeRequest<VariablePaymentInput>;\n\npub type BraintreeRefundResponse = GenericBraintreeResponse<RefundResponse>;\npub type BraintreeCaptureResponse = GenericBraintreeResponse<CaptureResponse>;\npub type BraintreePSyncResponse = GenericBraintreeResponse<PSyncResponse>;\n\npub type VariablePaymentInput = GenericVariableInput<PaymentInput>;\npub type VariableClientTokenInput = GenericVariableInput<InputClientTokenData>;\npub type VariableInput = GenericVariableInput<InputData>;\npub type VariableCaptureInput = GenericVariableInput<CaptureInputData>;\npub type BraintreeRefundVariables = GenericVariableInput<BraintreeRefundInput>;\npub type PSyncInput = GenericVariableInput<TransactionSearchInput>;\npub type RSyncInput = GenericVariableInput<RefundSearchInput>;\n\npub type BraintreeWalletRequest = GenericBraintreeRequest<GenericVariableInput<WalletPaymentInput>>;\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NetworkTokenData {\n    cryptogram: Secret<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    e_commerce_indicator: Option<String>,\n    expiration_month: Secret<String>,\n    expiration_year: Secret<String>,\n    number: cards::CardNumber,\n    origin_details: NetworkTokenOriginDetailsInput,\n}\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NetworkTokenOriginDetailsInput {\n    origin: NetworkTokenOrigin,\n}\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum NetworkTokenOrigin {\n    ApplePay,\n    GooglePay,\n    NetworkToken,\n}\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WalletTransactionBody {\n    amount: StringMajorUnit,\n    merchant_account_id: Secret<String>,\n    order_id: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer_details: Option<CustomerBody>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    vault_payment_method_after_transacting: Option<TransactionTiming>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WalletPaymentInput {\n    payment_method_id: Secret<String>,\n    transaction: WalletTransactionBody,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GenericBraintreeRequest<T> {\n    query: String,\n    variables: T,\n}\n#[derive(Debug, Clone, Deserialize, Serialize)]",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs",
    "code": "use api_models::{\n    payments as payment_types,\n    payments::{ApplePaySessionResponse, SessionToken},\n    webhooks::IncomingWebhookEvent,\n};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::{OptionExt, ValueExt},\n    pii,\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, MandateRevokeRequestData, ResponseId},\n    router_response_types::{\n        MandateReference, MandateRevokeResponseData, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    types::{\n        PaymentsCaptureResponseRouterData, PaymentsResponseRouterData,\n        PaymentsSessionResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, ForeignTryFrom, PaymentsAuthorizeRequestData, PaymentsCompleteAuthorizeRequestData,\n        RefundsRequestData, RouterData as _,\n    },\n};\n\npub const CHANNEL_CODE: &str = \"HyperSwitchBT_Ecom\";\npub const CLIENT_TOKEN_MUTATION: &str = \"mutation createClientToken($input: CreateClientTokenInput!) { createClientToken(input: $input) { clientToken}}\";\npub const TOKENIZE_CREDIT_CARD: &str = \"mutation  tokenizeCreditCard($input: TokenizeCreditCardInput!) { tokenizeCreditCard(input: $input) { clientMutationId paymentMethod { id } } }\";\npub const CHARGE_CREDIT_CARD_MUTATION: &str = \"mutation ChargeCreditCard($input: ChargeCreditCardInput!) { chargeCreditCard(input: $input) { transaction { id legacyId createdAt amount { value currencyCode } status } } }\";\npub const AUTHORIZE_CREDIT_CARD_MUTATION: &str = \"mutation authorizeCreditCard($input: AuthorizeCreditCardInput!) { authorizeCreditCard(input: $input) {  transaction { id legacyId amount { value currencyCode } status } } }\";\npub const CAPTURE_TRANSACTION_MUTATION: &str = \"mutation captureTransaction($input: CaptureTransactionInput!) { captureTransaction(input: $input) { clientMutationId transaction { id legacyId amount { value currencyCode } status } } }\";\npub const VOID_TRANSACTION_MUTATION: &str = \"mutation voidTransaction($input:  ReverseTransactionInput!) { reverseTransaction(input: $input) { clientMutationId reversal { ...  on Transaction { id legacyId amount { value currencyCode } status } } } }\";\npub const REFUND_TRANSACTION_MUTATION: &str = \"mutation refundTransaction($input:  RefundTransactionInput!) { refundTransaction(input: $input) {clientMutationId refund { id legacyId amount { value currencyCode } status } } }\";\npub const AUTHORIZE_AND_VAULT_CREDIT_CARD_MUTATION: &str=\"mutation authorizeCreditCard($input: AuthorizeCreditCardInput!) { authorizeCreditCard(input: $input) { transaction { id status createdAt paymentMethod { id } } } }\";\npub const CHARGE_AND_VAULT_TRANSACTION_MUTATION: &str =\"mutation ChargeCreditCard($input: ChargeCreditCardInput!) { chargeCreditCard(input: $input) { transaction { id status createdAt paymentMethod { id } } } }\";\npub const DELETE_PAYMENT_METHOD_FROM_VAULT_MUTATION: &str = \"mutation deletePaymentMethodFromVault($input: DeletePaymentMethodFromVaultInput!) { deletePaymentMethodFromVault(input: $input) { clientMutationId } }\";\npub const TRANSACTION_QUERY: &str = \"query($input: TransactionSearchInput!) { search { transactions(input: $input) { edges { node { id status } } } } }\";\npub const REFUND_QUERY: &str = \"query($input: RefundSearchInput!) { search { refunds(input: $input, first: 1) { edges { node { id status createdAt amount { value currencyCode } orderId } } } } }\";\npub const CHARGE_GOOGLE_PAY_MUTATION: &str = \"mutation ChargeGPay($input: ChargePaymentMethodInput!) { chargePaymentMethod(input: $input) { transaction { id status amount { value currencyCode } } } }\";\npub const AUTHORIZE_GOOGLE_PAY_MUTATION: &str = \"mutation authorizeGPay($input: AuthorizePaymentMethodInput!) { authorizePaymentMethod(input: $input) { transaction { id legacyId amount { value currencyCode } status } } }\";\npub const CHARGE_APPLE_PAY_MUTATION: &str = \"mutation ChargeApplepay($input: ChargePaymentMethodInput!) { chargePaymentMethod(input: $input) { transaction { id status amount { value currencyCode } } } }\";\npub const AUTHORIZE_APPLE_PAY_MUTATION: &str = \"mutation authorizeApplepay($input: AuthorizePaymentMethodInput!) { authorizePaymentMethod(input: $input) { transaction { id legacyId amount { value currencyCode } status } } }\";\npub const CHARGE_AND_VAULT_APPLE_PAY_MUTATION: &str = \"mutation ChargeApplepay($input: ChargePaymentMethodInput!) { chargePaymentMethod(input: $input) { transaction { id status amount { value currencyCode } paymentMethod { id } } } }\";\npub const AUTHORIZE_AND_VAULT_APPLE_PAY_MUTATION: &str = \"mutation authorizeApplepay($input: AuthorizePaymentMethodInput!) { authorizePaymentMethod(input: $input) { transaction { id legacyId amount { value currencyCode } status paymentMethod { id } } } }\";\npub const CHARGE_PAYPAL_MUTATION: &str = \"mutation ChargePaypal($input: ChargePaymentMethodInput!) { chargePaymentMethod(input: $input) { transaction { id status amount { value currencyCode } } } }\";\npub const AUTHORIZE_PAYPAL_MUTATION: &str = \"mutation authorizePaypal($input: AuthorizePaymentMethodInput!) { authorizePaymentMethod(input: $input) { transaction { id legacyId amount { value currencyCode } status } } }\";\npub const TOKENIZE_NETWORK_TOKEN: &str = \"mutation tokenizeNetworkToken($input: TokenizeNetworkTokenInput!) { tokenizeNetworkToken(input: $input) { clientMutationId paymentMethod { id } } }\";\n\npub type CardPaymentRequest = GenericBraintreeRequest<VariablePaymentInput>;\npub type MandatePaymentRequest = GenericBraintreeRequest<VariablePaymentInput>;\npub type BraintreeClientTokenRequest = GenericBraintreeRequest<VariableClientTokenInput>;\npub type BraintreeTokenRequest = GenericBraintreeRequest<VariableInput>;\npub type BraintreeCaptureRequest = GenericBraintreeRequest<VariableCaptureInput>;\npub type BraintreeRefundRequest = GenericBraintreeRequest<BraintreeRefundVariables>;\npub type BraintreePSyncRequest = GenericBraintreeRequest<PSyncInput>;\npub type BraintreeRSyncRequest = GenericBraintreeRequest<RSyncInput>;\n\npub type BraintreeApplePayTokenizeRequest = GenericBraintreeRequest<VariablePaymentInput>;\n\npub type BraintreeRefundResponse = GenericBraintreeResponse<RefundResponse>;\npub type BraintreeCaptureResponse = GenericBraintreeResponse<CaptureResponse>;\npub type BraintreePSyncResponse = GenericBraintreeResponse<PSyncResponse>;\n\npub type VariablePaymentInput = GenericVariableInput<PaymentInput>;\npub type VariableClientTokenInput = GenericVariableInput<InputClientTokenData>;\npub type VariableInput = GenericVariableInput<InputData>;\npub type VariableCaptureInput = GenericVariableInput<CaptureInputData>;\npub type BraintreeRefundVariables = GenericVariableInput<BraintreeRefundInput>;\npub type PSyncInput = GenericVariableInput<TransactionSearchInput>;\npub type RSyncInput = GenericVariableInput<RefundSearchInput>;\n\npub type BraintreeWalletRequest = GenericBraintreeRequest<GenericVariableInput<WalletPaymentInput>>;\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NetworkTokenData {\n    cryptogram: Secret<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    e_commerce_indicator: Option<String>,\n    expiration_month: Secret<String>,\n    expiration_year: Secret<String>,\n    number: cards::CardNumber,\n    origin_details: NetworkTokenOriginDetailsInput,\n}\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NetworkTokenOriginDetailsInput {\n    origin: NetworkTokenOrigin,\n}\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum NetworkTokenOrigin {\n    ApplePay,\n    GooglePay,\n    NetworkToken,\n}\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WalletTransactionBody {\n    amount: StringMajorUnit,\n    merchant_account_id: Secret<String>,\n    order_id: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer_details: Option<CustomerBody>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    vault_payment_method_after_transacting: Option<TransactionTiming>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WalletPaymentInput {\n    payment_method_id: Secret<String>,\n    transaction: WalletTransactionBody,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GenericBraintreeRequest<T> {\n    query: String,\n    variables: T,\n}\n#[derive(Debug, Clone, Deserialize, Serialize)]",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__braintree__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__api_models__src__user.rs",
    "code": "use std::fmt::Debug;\n\nuse common_enums::{EntityType, TokenPurpose};\nuse common_utils::{crypto::OptionalEncryptableName, id_type, pii};\nuse masking::Secret;\nuse utoipa::ToSchema;\n\nuse crate::user_role::UserStatus;\npub mod dashboard_metadata;\n#[cfg(feature = \"dummy_connector\")]\npub mod sample_data;\n#[cfg(feature = \"control_center_theme\")]\npub mod theme;\n\n#[derive(serde::Deserialize, Debug, Clone, serde::Serialize)]\npub struct SignUpWithMerchantIdRequest {\n    pub name: Secret<String>,\n    pub email: pii::Email,\n    pub password: Secret<String>,\n    pub company_name: String,\n    pub organization_type: Option<common_enums::OrganizationType>,\n}\n\npub type SignUpWithMerchantIdResponse = AuthorizeResponse;\n\n#[derive(serde::Deserialize, Debug, Clone, serde::Serialize)]\npub struct SignUpRequest {\n    pub email: pii::Email,\n    pub password: Secret<String>,\n}\n\npub type SignInRequest = SignUpRequest;\n\n#[derive(serde::Deserialize, Debug, Clone, serde::Serialize)]\npub struct ConnectAccountRequest {\n    pub email: pii::Email,\n}\n\npub type ConnectAccountResponse = AuthorizeResponse;\n\n#[derive(serde::Serialize, Debug, Clone)]\npub struct AuthorizeResponse {\n    pub is_email_sent: bool,\n    //this field is added for audit/debug reasons\n    #[serde(skip_serializing)]\n    pub user_id: String,\n}\n\n#[derive(serde::Deserialize, Debug, serde::Serialize)]\npub struct ChangePasswordRequest {\n    pub new_password: Secret<String>,\n    pub old_password: Secret<String>,\n}\n\n#[derive(serde::Deserialize, Debug, serde::Serialize)]\npub struct ForgotPasswordRequest {\n    pub email: pii::Email,\n}\n\n#[derive(serde::Deserialize, Debug, serde::Serialize)]\npub struct ResetPasswordRequest {\n    pub token: Secret<String>,\n    pub password: Secret<String>,\n}\n\n#[derive(serde::Deserialize, Debug, serde::Serialize)]\npub struct RotatePasswordRequest {\n    pub password: Secret<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct InviteUserRequest {\n    pub email: pii::Email,\n    pub name: Secret<String>,\n    pub role_id: String,\n}\n\n#[derive(Debug, serde::Serialize)]\npub struct InviteMultipleUserResponse {\n    pub email: pii::Email,\n    pub is_email_sent: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub password: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error: Option<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct ReInviteUserRequest {\n    pub email: pii::Email,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct AcceptInviteFromEmailRequest {\n    pub token: Secret<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct ValidateOnlyQueryParam {\n    pub status_check: Option<bool>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub enum InvitationAcceptanceStatus {\n    AlreadyAccepted,\n    SuccessfullyAccepted,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(untagged)]\npub enum AcceptInviteResponse {\n    Token(TokenResponse),\n    Status(InvitationAcceptanceStatus),\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct SwitchOrganizationRequest {\n    pub org_id: id_type::OrganizationId,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct SwitchMerchantRequest {\n    pub merchant_id: id_type::MerchantId,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct SwitchProfileRequest {\n    pub profile_id: id_type::ProfileId,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct CloneConnectorSource {\n    pub mca_id: id_type::MerchantConnectorAccountId,\n    pub merchant_id: id_type::MerchantId,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct CloneConnectorDestination {\n    pub connector_label: Option<String>,\n    pub profile_id: id_type::ProfileId,",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__user.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__api_models__src__user.rs",
    "code": "use std::fmt::Debug;\n\nuse common_enums::{EntityType, TokenPurpose};\nuse common_utils::{crypto::OptionalEncryptableName, id_type, pii};\nuse masking::Secret;\nuse utoipa::ToSchema;\n\nuse crate::user_role::UserStatus;\npub mod dashboard_metadata;\n#[cfg(feature = \"dummy_connector\")]\npub mod sample_data;\n#[cfg(feature = \"control_center_theme\")]\npub mod theme;\n\n#[derive(serde::Deserialize, Debug, Clone, serde::Serialize)]\npub struct SignUpWithMerchantIdRequest {\n    pub name: Secret<String>,\n    pub email: pii::Email,\n    pub password: Secret<String>,\n    pub company_name: String,\n    pub organization_type: Option<common_enums::OrganizationType>,\n}\n\npub type SignUpWithMerchantIdResponse = AuthorizeResponse;\n\n#[derive(serde::Deserialize, Debug, Clone, serde::Serialize)]\npub struct SignUpRequest {\n    pub email: pii::Email,\n    pub password: Secret<String>,\n}\n\npub type SignInRequest = SignUpRequest;\n\n#[derive(serde::Deserialize, Debug, Clone, serde::Serialize)]\npub struct ConnectAccountRequest {\n    pub email: pii::Email,\n}\n\npub type ConnectAccountResponse = AuthorizeResponse;\n\n#[derive(serde::Serialize, Debug, Clone)]\npub struct AuthorizeResponse {\n    pub is_email_sent: bool,\n    //this field is added for audit/debug reasons\n    #[serde(skip_serializing)]\n    pub user_id: String,\n}\n\n#[derive(serde::Deserialize, Debug, serde::Serialize)]\npub struct ChangePasswordRequest {\n    pub new_password: Secret<String>,\n    pub old_password: Secret<String>,\n}\n\n#[derive(serde::Deserialize, Debug, serde::Serialize)]\npub struct ForgotPasswordRequest {\n    pub email: pii::Email,\n}\n\n#[derive(serde::Deserialize, Debug, serde::Serialize)]\npub struct ResetPasswordRequest {\n    pub token: Secret<String>,\n    pub password: Secret<String>,\n}\n\n#[derive(serde::Deserialize, Debug, serde::Serialize)]\npub struct RotatePasswordRequest {\n    pub password: Secret<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct InviteUserRequest {\n    pub email: pii::Email,\n    pub name: Secret<String>,\n    pub role_id: String,\n}\n\n#[derive(Debug, serde::Serialize)]\npub struct InviteMultipleUserResponse {\n    pub email: pii::Email,\n    pub is_email_sent: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub password: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error: Option<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct ReInviteUserRequest {\n    pub email: pii::Email,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]\npub struct AcceptInviteFromEmailRequest {\n    pub token: Secret<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct ValidateOnlyQueryParam {\n    pub status_check: Option<bool>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub enum InvitationAcceptanceStatus {\n    AlreadyAccepted,\n    SuccessfullyAccepted,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\n#[serde(untagged)]\npub enum AcceptInviteResponse {\n    Token(TokenResponse),\n    Status(InvitationAcceptanceStatus),\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct SwitchOrganizationRequest {\n    pub org_id: id_type::OrganizationId,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct SwitchMerchantRequest {\n    pub merchant_id: id_type::MerchantId,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct SwitchProfileRequest {\n    pub profile_id: id_type::ProfileId,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct CloneConnectorSource {\n    pub mca_id: id_type::MerchantConnectorAccountId,\n    pub merchant_id: id_type::MerchantId,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct CloneConnectorDestination {\n    pub connector_label: Option<String>,\n    pub profile_id: id_type::ProfileId,",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__user.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__db.rs",
    "code": "pub mod address;\npub mod api_keys;\npub mod authentication;\npub mod authorization;\npub mod blocklist;\npub mod blocklist_fingerprint;\npub mod blocklist_lookup;\npub mod business_profile;\npub mod callback_mapper;\npub mod capture;\npub mod configs;\npub mod customers;\npub mod dashboard_metadata;\npub mod dispute;\npub mod dynamic_routing_stats;\npub mod ephemeral_key;\npub mod events;\npub mod file;\npub mod fraud_check;\npub mod generic_link;\npub mod gsm;\npub mod health_check;\npub mod hyperswitch_ai_interaction;\npub mod kafka_store;\npub mod locker_mock_up;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod organization;\npub mod payment_link;\npub mod payment_method_session;\npub mod refund;\npub mod relay;\npub mod reverse_lookup;\npub mod role;\npub mod routing_algorithm;\npub mod unified_translations;\npub mod user;\npub mod user_authentication_method;\npub mod user_key_store;\npub mod user_role;\n\nuse ::payment_methods::state::PaymentMethodsStorageInterface;\nuse common_utils::{id_type, types::keymanager::KeyManagerState};\nuse diesel_models::{\n    fraud_check::{FraudCheck, FraudCheckUpdate},\n    organization::{Organization, OrganizationNew, OrganizationUpdate},\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::payouts::{\n    payout_attempt::PayoutAttemptInterface, payouts::PayoutsInterface,\n};\nuse hyperswitch_domain_models::{\n    cards_info::CardsInfoInterface,\n    master_key::MasterKeyInterface,\n    payment_methods::PaymentMethodInterface,\n    payments::{payment_attempt::PaymentAttemptInterface, payment_intent::PaymentIntentInterface},\n};\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\nuse redis_interface::errors::RedisError;\nuse router_env::logger;\nuse storage_impl::{\n    errors::StorageError, redis::kv_store::RedisConnInterface, tokenization, MockDb,\n};\n\npub use self::kafka_store::KafkaStore;\nuse self::{fraud_check::FraudCheckInterface, organization::OrganizationInterface};\npub use crate::{\n    core::errors::{self, ProcessTrackerError},\n    errors::CustomResult,\n    services::{\n        kafka::{KafkaError, KafkaProducer, MQResult},\n        Store,\n    },\n    types::{\n        domain,\n        storage::{self},\n        AccessToken,\n    },\n};\n\n#[derive(PartialEq, Eq)]\npub enum StorageImpl {\n    Postgresql,\n    PostgresqlTest,\n    Mock,\n}\n\n#[async_trait::async_trait]\npub trait StorageInterface:\n    Send\n    + Sync\n    + dyn_clone::DynClone\n    + address::AddressInterface\n    + api_keys::ApiKeyInterface\n    + blocklist_lookup::BlocklistLookupInterface\n    + configs::ConfigInterface<Error = StorageError>\n    + capture::CaptureInterface\n    + customers::CustomerInterface<Error = StorageError>\n    + dashboard_metadata::DashboardMetadataInterface\n    + dispute::DisputeInterface\n    + ephemeral_key::EphemeralKeyInterface\n    + ephemeral_key::ClientSecretInterface\n    + events::EventInterface\n    + file::FileMetadataInterface\n    + FraudCheckInterface\n    + locker_mock_up::LockerMockUpInterface\n    + mandate::MandateInterface\n    + merchant_account::MerchantAccountInterface<Error = StorageError>\n    + merchant_connector_account::ConnectorAccessToken\n    + merchant_connector_account::MerchantConnectorAccountInterface<Error = StorageError>\n    + PaymentAttemptInterface<Error = StorageError>\n    + PaymentIntentInterface<Error = StorageError>\n    + PaymentMethodInterface<Error = StorageError>\n    + blocklist::BlocklistInterface\n    + blocklist_fingerprint::BlocklistFingerprintInterface\n    + dynamic_routing_stats::DynamicRoutingStatsInterface\n    + scheduler::SchedulerInterface\n    + PayoutAttemptInterface<Error = StorageError>\n    + PayoutsInterface<Error = StorageError>\n    + refund::RefundInterface\n    + reverse_lookup::ReverseLookupInterface\n    + CardsInfoInterface<Error = StorageError>\n    + merchant_key_store::MerchantKeyStoreInterface<Error = StorageError>\n    + MasterKeyInterface\n    + payment_link::PaymentLinkInterface\n    + RedisConnInterface\n    + RequestIdStore\n    + business_profile::ProfileInterface<Error = StorageError>\n    + routing_algorithm::RoutingAlgorithmInterface\n    + gsm::GsmInterface\n    + unified_translations::UnifiedTranslationsInterface\n    + authorization::AuthorizationInterface\n    + user::sample_data::BatchSampleDataInterface\n    + health_check::HealthCheckDbInterface\n    + user_authentication_method::UserAuthenticationMethodInterface\n    + hyperswitch_ai_interaction::HyperswitchAiInteractionInterface",
    "function_name": "unknown_symbol",
    "file": "crates__router__src__db.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__db.rs",
    "code": "pub mod address;\npub mod api_keys;\npub mod authentication;\npub mod authorization;\npub mod blocklist;\npub mod blocklist_fingerprint;\npub mod blocklist_lookup;\npub mod business_profile;\npub mod callback_mapper;\npub mod capture;\npub mod configs;\npub mod customers;\npub mod dashboard_metadata;\npub mod dispute;\npub mod dynamic_routing_stats;\npub mod ephemeral_key;\npub mod events;\npub mod file;\npub mod fraud_check;\npub mod generic_link;\npub mod gsm;\npub mod health_check;\npub mod hyperswitch_ai_interaction;\npub mod kafka_store;\npub mod locker_mock_up;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod organization;\npub mod payment_link;\npub mod payment_method_session;\npub mod refund;\npub mod relay;\npub mod reverse_lookup;\npub mod role;\npub mod routing_algorithm;\npub mod unified_translations;\npub mod user;\npub mod user_authentication_method;\npub mod user_key_store;\npub mod user_role;\n\nuse ::payment_methods::state::PaymentMethodsStorageInterface;\nuse common_utils::{id_type, types::keymanager::KeyManagerState};\nuse diesel_models::{\n    fraud_check::{FraudCheck, FraudCheckUpdate},\n    organization::{Organization, OrganizationNew, OrganizationUpdate},\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::payouts::{\n    payout_attempt::PayoutAttemptInterface, payouts::PayoutsInterface,\n};\nuse hyperswitch_domain_models::{\n    cards_info::CardsInfoInterface,\n    master_key::MasterKeyInterface,\n    payment_methods::PaymentMethodInterface,\n    payments::{payment_attempt::PaymentAttemptInterface, payment_intent::PaymentIntentInterface},\n};\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\nuse redis_interface::errors::RedisError;\nuse router_env::logger;\nuse storage_impl::{\n    errors::StorageError, redis::kv_store::RedisConnInterface, tokenization, MockDb,\n};\n\npub use self::kafka_store::KafkaStore;\nuse self::{fraud_check::FraudCheckInterface, organization::OrganizationInterface};\npub use crate::{\n    core::errors::{self, ProcessTrackerError},\n    errors::CustomResult,\n    services::{\n        kafka::{KafkaError, KafkaProducer, MQResult},\n        Store,\n    },\n    types::{\n        domain,\n        storage::{self},\n        AccessToken,\n    },\n};\n\n#[derive(PartialEq, Eq)]\npub enum StorageImpl {\n    Postgresql,\n    PostgresqlTest,\n    Mock,\n}\n\n#[async_trait::async_trait]\npub trait StorageInterface:\n    Send\n    + Sync\n    + dyn_clone::DynClone\n    + address::AddressInterface\n    + api_keys::ApiKeyInterface\n    + blocklist_lookup::BlocklistLookupInterface\n    + configs::ConfigInterface<Error = StorageError>\n    + capture::CaptureInterface\n    + customers::CustomerInterface<Error = StorageError>\n    + dashboard_metadata::DashboardMetadataInterface\n    + dispute::DisputeInterface\n    + ephemeral_key::EphemeralKeyInterface\n    + ephemeral_key::ClientSecretInterface\n    + events::EventInterface\n    + file::FileMetadataInterface\n    + FraudCheckInterface\n    + locker_mock_up::LockerMockUpInterface\n    + mandate::MandateInterface\n    + merchant_account::MerchantAccountInterface<Error = StorageError>\n    + merchant_connector_account::ConnectorAccessToken\n    + merchant_connector_account::MerchantConnectorAccountInterface<Error = StorageError>\n    + PaymentAttemptInterface<Error = StorageError>\n    + PaymentIntentInterface<Error = StorageError>\n    + PaymentMethodInterface<Error = StorageError>\n    + blocklist::BlocklistInterface\n    + blocklist_fingerprint::BlocklistFingerprintInterface\n    + dynamic_routing_stats::DynamicRoutingStatsInterface\n    + scheduler::SchedulerInterface\n    + PayoutAttemptInterface<Error = StorageError>\n    + PayoutsInterface<Error = StorageError>\n    + refund::RefundInterface\n    + reverse_lookup::ReverseLookupInterface\n    + CardsInfoInterface<Error = StorageError>\n    + merchant_key_store::MerchantKeyStoreInterface<Error = StorageError>\n    + MasterKeyInterface\n    + payment_link::PaymentLinkInterface\n    + RedisConnInterface\n    + RequestIdStore\n    + business_profile::ProfileInterface<Error = StorageError>\n    + routing_algorithm::RoutingAlgorithmInterface\n    + gsm::GsmInterface\n    + unified_translations::UnifiedTranslationsInterface\n    + authorization::AuthorizationInterface\n    + user::sample_data::BatchSampleDataInterface\n    + health_check::HealthCheckDbInterface\n    + user_authentication_method::UserAuthenticationMethodInterface\n    + hyperswitch_ai_interaction::HyperswitchAiInteractionInterface",
    "function_name": "unknown_symbol",
    "file": "crates__router__src__db.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_scheduler_db",
    "code": "pub mod address;\npub mod api_keys;\npub mod authentication;\npub mod authorization;\npub mod blocklist;\npub mod blocklist_fingerprint;\npub mod blocklist_lookup;\npub mod business_profile;\npub mod callback_mapper;\npub mod capture;\npub mod configs;\npub mod customers;\npub mod dashboard_metadata;\npub mod dispute;\npub mod dynamic_routing_stats;\npub mod ephemeral_key;\npub mod events;\npub mod file;\npub mod fraud_check;\npub mod generic_link;\npub mod gsm;\npub mod health_check;\npub mod hyperswitch_ai_interaction;\npub mod kafka_store;\npub mod locker_mock_up;\npub mod mandate;\npub mod merchant_account;\npub mod merchant_connector_account;\npub mod merchant_key_store;\npub mod organization;\npub mod payment_link;\npub mod payment_method_session;\npub mod refund;\npub mod relay;\npub mod reverse_lookup;\npub mod role;\npub mod routing_algorithm;\npub mod unified_translations;\npub mod user;\npub mod user_authentication_method;\npub mod user_key_store;\npub mod user_role;\n\nuse ::payment_methods::state::PaymentMethodsStorageInterface;\nuse common_utils::{id_type, types::keymanager::KeyManagerState};\nuse diesel_models::{\n    fraud_check::{FraudCheck, FraudCheckUpdate},\n    organization::{Organization, OrganizationNew, OrganizationUpdate},\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::payouts::{\n    payout_attempt::PayoutAttemptInterface, payouts::PayoutsInterface,\n};\nuse hyperswitch_domain_models::{\n    cards_info::CardsInfoInterface,\n    master_key::MasterKeyInterface,\n    payment_methods::PaymentMethodInterface,\n    payments::{payment_attempt::PaymentAttemptInterface, payment_intent::PaymentIntentInterface},\n};\n#[cfg(not(feature = \"payouts\"))]\nuse hyperswitch_domain_models::{PayoutAttemptInterface, PayoutsInterface};\nuse redis_interface::errors::RedisError;\nuse router_env::logger;\nuse storage_impl::{\n    errors::StorageError, redis::kv_store::RedisConnInterface, tokenization, MockDb,\n};\n\npub use self::kafka_store::KafkaStore;\nuse self::{fraud_check::FraudCheckInterface, organization::OrganizationInterface};\npub use crate::{\n    core::errors::{self, ProcessTrackerError},\n    errors::CustomResult,\n    services::{\n        kafka::{KafkaError, KafkaProducer, MQResult},\n        Store,\n    },\n    types::{\n        domain,\n        storage::{self},\n        AccessToken,\n    },\n};\n\n#[derive(PartialEq, Eq)]\npub enum StorageImpl {\n    Postgresql,\n    PostgresqlTest,\n    Mock,\n}\n\n#[async_trait::async_trait]\npub trait StorageInterface:\n    Send\n    + Sync\n    + dyn_clone::DynClone\n    + address::AddressInterface\n    + api_keys::ApiKeyInterface\n    + blocklist_lookup::BlocklistLookupInterface\n    + configs::ConfigInterface<Error = StorageError>\n    + capture::CaptureInterface\n    + customers::CustomerInterface<Error = StorageError>\n    + dashboard_metadata::DashboardMetadataInterface\n    + dispute::DisputeInterface\n    + ephemeral_key::EphemeralKeyInterface\n    + ephemeral_key::ClientSecretInterface\n    + events::EventInterface\n    + file::FileMetadataInterface\n    + FraudCheckInterface\n    + locker_mock_up::LockerMockUpInterface\n    + mandate::MandateInterface\n    + merchant_account::MerchantAccountInterface<Error = StorageError>\n    + merchant_connector_account::ConnectorAccessToken\n    + merchant_connector_account::MerchantConnectorAccountInterface<Error = StorageError>\n    + PaymentAttemptInterface<Error = StorageError>\n    + PaymentIntentInterface<Error = StorageError>\n    + PaymentMethodInterface<Error = StorageError>\n    + blocklist::BlocklistInterface\n    + blocklist_fingerprint::BlocklistFingerprintInterface\n    + dynamic_routing_stats::DynamicRoutingStatsInterface\n    + scheduler::SchedulerInterface\n    + PayoutAttemptInterface<Error = StorageError>\n    + PayoutsInterface<Error = StorageError>\n    + refund::RefundInterface\n    + reverse_lookup::ReverseLookupInterface\n    + CardsInfoInterface<Error = StorageError>\n    + merchant_key_store::MerchantKeyStoreInterface<Error = StorageError>\n    + MasterKeyInterface\n    + payment_link::PaymentLinkInterface\n    + RedisConnInterface\n    + RequestIdStore\n    + business_profile::ProfileInterface<Error = StorageError>\n    + routing_algorithm::RoutingAlgorithmInterface\n    + gsm::GsmInterface\n    + unified_translations::UnifiedTranslationsInterface\n    + authorization::AuthorizationInterface\n    + user::sample_data::BatchSampleDataInterface\n    + health_check::HealthCheckDbInterface\n    + user_authentication_method::UserAuthenticationMethodInterface\n    + hyperswitch_ai_interaction::HyperswitchAiInteractionInterface",
    "function_name": "unknown_symbol",
    "file": "crates__router__src__db.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs",
    "code": "use common_enums::{enums, Currency};\nuse common_utils::{consts::BASE64_ENGINE, date_time, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, generate_random_bytes, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct PlacetopayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PlacetopayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPaymentsRequest {\n    auth: PlacetopayAuth,\n    payment: PlacetopayPayment,\n    instrument: PlacetopayInstrument,\n    ip_address: Secret<String, common_utils::pii::IpAddress>,\n    user_agent: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PlacetopayAuthorizeAction {\n    Checkin,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuthType {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuth {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n    nonce: Secret<String>,\n    seed: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPayment {\n    reference: String,\n    description: String,\n    amount: PlacetopayAmount,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAmount {\n    currency: Currency,\n    total: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayInstrument {\n    card: PlacetopayCard,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayCard {\n    number: cards::CardNumber,\n    expiration: Secret<String>,\n    cvv: Secret<String>,\n}\n\nimpl TryFrom<&PlacetopayRouterData<&types::PaymentsAuthorizeRouterData>>\n    for PlacetopayPaymentsRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &PlacetopayRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let browser_info = item.router_data.request.get_browser_info()?;\n        let ip_address = browser_info.get_ip_address()?;\n        let user_agent = browser_info.get_user_agent()?;\n        let auth = PlacetopayAuth::try_from(&item.router_data.connector_auth_type)?;\n        let payment = PlacetopayPayment {\n            reference: item.router_data.connector_request_reference_id.clone(),\n            description: item.router_data.get_description()?,\n            amount: PlacetopayAmount {\n                currency: item.router_data.request.currency,\n                total: item.amount,\n            },\n        };\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::Card(req_card) => {\n                if item.router_data.is_three_ds() {\n                    Err(errors::ConnectorError::NotSupported {\n                        message: \"Cards 3DS\".to_string(),\n                        connector: \"Placetopay\",\n                    })?\n                }\n                let card = PlacetopayCard {\n                    number: req_card.card_number.clone(),\n                    expiration: req_card\n                        .clone()\n                        .get_card_expiry_month_year_2_digit_with_delimiter(\"/\".to_owned())?,\n                    cvv: req_card.card_cvc.clone(),\n                };\n                Ok(Self {\n                    ip_address,\n                    user_agent,\n                    auth,\n                    payment,\n                    instrument: PlacetopayInstrument {\n                        card: card.to_owned(),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs",
    "code": "use common_enums::{enums, Currency};\nuse common_utils::{consts::BASE64_ENGINE, date_time, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, generate_random_bytes, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct PlacetopayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PlacetopayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPaymentsRequest {\n    auth: PlacetopayAuth,\n    payment: PlacetopayPayment,\n    instrument: PlacetopayInstrument,\n    ip_address: Secret<String, common_utils::pii::IpAddress>,\n    user_agent: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PlacetopayAuthorizeAction {\n    Checkin,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuthType {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuth {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n    nonce: Secret<String>,\n    seed: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPayment {\n    reference: String,\n    description: String,\n    amount: PlacetopayAmount,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAmount {\n    currency: Currency,\n    total: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayInstrument {\n    card: PlacetopayCard,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayCard {\n    number: cards::CardNumber,\n    expiration: Secret<String>,\n    cvv: Secret<String>,\n}\n\nimpl TryFrom<&PlacetopayRouterData<&types::PaymentsAuthorizeRouterData>>\n    for PlacetopayPaymentsRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &PlacetopayRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let browser_info = item.router_data.request.get_browser_info()?;\n        let ip_address = browser_info.get_ip_address()?;\n        let user_agent = browser_info.get_user_agent()?;\n        let auth = PlacetopayAuth::try_from(&item.router_data.connector_auth_type)?;\n        let payment = PlacetopayPayment {\n            reference: item.router_data.connector_request_reference_id.clone(),\n            description: item.router_data.get_description()?,\n            amount: PlacetopayAmount {\n                currency: item.router_data.request.currency,\n                total: item.amount,\n            },\n        };\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::Card(req_card) => {\n                if item.router_data.is_three_ds() {\n                    Err(errors::ConnectorError::NotSupported {\n                        message: \"Cards 3DS\".to_string(),\n                        connector: \"Placetopay\",\n                    })?\n                }\n                let card = PlacetopayCard {\n                    number: req_card.card_number.clone(),\n                    expiration: req_card\n                        .clone()\n                        .get_card_expiry_month_year_2_digit_with_delimiter(\"/\".to_owned())?,\n                    cvv: req_card.card_cvc.clone(),\n                };\n                Ok(Self {\n                    ip_address,\n                    user_agent,\n                    auth,\n                    payment,\n                    instrument: PlacetopayInstrument {\n                        card: card.to_owned(),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::{enums, Currency};\nuse common_utils::{consts::BASE64_ENGINE, date_time, types::MinorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse ring::digest;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, generate_random_bytes, BrowserInformationData, CardData as _,\n        PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _,\n    },\n};\n\npub struct PlacetopayRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PlacetopayRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPaymentsRequest {\n    auth: PlacetopayAuth,\n    payment: PlacetopayPayment,\n    instrument: PlacetopayInstrument,\n    ip_address: Secret<String, common_utils::pii::IpAddress>,\n    user_agent: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PlacetopayAuthorizeAction {\n    Checkin,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuthType {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAuth {\n    login: Secret<String>,\n    tran_key: Secret<String>,\n    nonce: Secret<String>,\n    seed: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayPayment {\n    reference: String,\n    description: String,\n    amount: PlacetopayAmount,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayAmount {\n    currency: Currency,\n    total: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayInstrument {\n    card: PlacetopayCard,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct PlacetopayCard {\n    number: cards::CardNumber,\n    expiration: Secret<String>,\n    cvv: Secret<String>,\n}\n\nimpl TryFrom<&PlacetopayRouterData<&types::PaymentsAuthorizeRouterData>>\n    for PlacetopayPaymentsRequest\n{\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &PlacetopayRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let browser_info = item.router_data.request.get_browser_info()?;\n        let ip_address = browser_info.get_ip_address()?;\n        let user_agent = browser_info.get_user_agent()?;\n        let auth = PlacetopayAuth::try_from(&item.router_data.connector_auth_type)?;\n        let payment = PlacetopayPayment {\n            reference: item.router_data.connector_request_reference_id.clone(),\n            description: item.router_data.get_description()?,\n            amount: PlacetopayAmount {\n                currency: item.router_data.request.currency,\n                total: item.amount,\n            },\n        };\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::Card(req_card) => {\n                if item.router_data.is_three_ds() {\n                    Err(errors::ConnectorError::NotSupported {\n                        message: \"Cards 3DS\".to_string(),\n                        connector: \"Placetopay\",\n                    })?\n                }\n                let card = PlacetopayCard {\n                    number: req_card.card_number.clone(),\n                    expiration: req_card\n                        .clone()\n                        .get_card_expiry_month_year_2_digit_with_delimiter(\"/\".to_owned())?,\n                    cvv: req_card.card_cvc.clone(),\n                };\n                Ok(Self {\n                    ip_address,\n                    user_agent,\n                    auth,\n                    payment,\n                    instrument: PlacetopayInstrument {\n                        card: card.to_owned(),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__placetopay__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__storage_impl__src__payments__payment_attempt.rs",
    "code": "use common_utils::{errors::CustomResult, ext_traits::AsyncExt};\n#[cfg(feature = \"v1\")]\nuse common_utils::{fallback_reverse_lookup_not_found, types::ConnectorTransactionId};\nuse diesel_models::{\n    enums::{\n        MandateAmountData as DieselMandateAmountData, MandateDataType as DieselMandateType,\n        MandateDetails as DieselMandateDetails, MerchantStorageScheme,\n    },\n    kv,\n    payment_attempt::PaymentAttempt as DieselPaymentAttempt,\n    reverse_lookup::{ReverseLookup, ReverseLookupNew},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse futures::future::{try_join_all, FutureExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    mandates::{MandateAmountData, MandateDataType, MandateDetails},\n    merchant_key_store::MerchantKeyStore,\n    payments::payment_attempt::{PaymentAttempt, PaymentAttemptInterface, PaymentAttemptUpdate},\n};\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse hyperswitch_domain_models::{\n    payments::payment_attempt::PaymentListFilters, payments::PaymentIntent,\n};\n#[cfg(feature = \"v2\")]\nuse label::*;\nuse redis_interface::HsetnxReply;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::kv_router_store::{FilterResourceParams, FindResourceBy, UpdateResourceParams};\nuse crate::{\n    diesel_error_to_data_error, errors,\n    errors::RedisErrorExt,\n    kv_router_store::KVRouterStore,\n    lookup::ReverseLookupInterface,\n    redis::kv_store::{decide_storage_scheme, kv_wrapper, KvOperation, Op, PartitionKey},\n    utils::{pg_connection_read, pg_connection_write, try_redis_get_else_try_database_get},\n    DataModelExt, DatabaseStore, RouterStore,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentAttemptInterface for RouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: PaymentAttempt,\n        _storage_scheme: MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        let diesel_payment_attempt = payment_attempt\n            .construct_new()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?;\n        let key_manager_state = self\n            .get_keymanager_state()\n            .attach_printable(\"Missing KeyManagerState\")?;\n        diesel_payment_attempt\n            .insert(&conn)\n            .await\n            .map_err(|er| {\n                let new_err = diesel_error_to_data_error(*er.current_context());\n                er.change_context(new_err)\n            })\n            .async_map(|diesel_payment_attempt| async {\n                PaymentAttempt::convert_back(\n                    key_manager_state,\n                    diesel_payment_attempt,\n                    merchant_key_store.key.get_inner(),\n                    merchant_key_store.merchant_id.clone().into(),\n                )\n                .await\n                .change_context(errors::StorageError::DecryptionError)\n            })\n            .await?\n    }\n\n    #[cfg(feature = \"v2\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_attempt: PaymentAttempt,\n        _storage_scheme: MerchantStorageScheme,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        payment_attempt\n            .construct_new()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?\n            .insert(&conn)\n            .await\n            .map_err(|error| {\n                let new_error = diesel_error_to_data_error(*error.current_context());\n                error.change_context(new_error)\n            })?\n            .convert(\n                self.get_keymanager_state()\n                    .attach_printable(\"Missing KeyManagerState\")?,\n                merchant_key_store.key.get_inner(),\n                merchant_key_store.merchant_id.clone().into(),\n            )\n            .await\n            .change_context(errors::StorageError::DecryptionError)\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn update_payment_attempt_with_attempt_id(\n        &self,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        _storage_scheme: MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        let key_manager_state = self\n            .get_keymanager_state()\n            .attach_printable(\"Missing KeyManagerState\")?;\n        this.convert()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?\n            .update_with_attempt_id(&conn, payment_attempt.to_storage_model())\n            .await\n            .map_err(|er| {\n                let new_err = diesel_error_to_data_error(*er.current_context());\n                er.change_context(new_err)\n            })\n            .async_map(|diesel_payment_attempt| async {\n                PaymentAttempt::convert_back(\n                    key_manager_state,\n                    diesel_payment_attempt,\n                    merchant_key_store.key.get_inner(),\n                    merchant_key_store.merchant_id.clone().into(),",
    "function_name": "insert_payment_attempt",
    "file": "crates__storage_impl__src__payments__payment_attempt.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__storage_impl__src__payments__payment_attempt.rs",
    "code": "use common_utils::{errors::CustomResult, ext_traits::AsyncExt};\n#[cfg(feature = \"v1\")]\nuse common_utils::{fallback_reverse_lookup_not_found, types::ConnectorTransactionId};\nuse diesel_models::{\n    enums::{\n        MandateAmountData as DieselMandateAmountData, MandateDataType as DieselMandateType,\n        MandateDetails as DieselMandateDetails, MerchantStorageScheme,\n    },\n    kv,\n    payment_attempt::PaymentAttempt as DieselPaymentAttempt,\n    reverse_lookup::{ReverseLookup, ReverseLookupNew},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse futures::future::{try_join_all, FutureExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    mandates::{MandateAmountData, MandateDataType, MandateDetails},\n    merchant_key_store::MerchantKeyStore,\n    payments::payment_attempt::{PaymentAttempt, PaymentAttemptInterface, PaymentAttemptUpdate},\n};\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse hyperswitch_domain_models::{\n    payments::payment_attempt::PaymentListFilters, payments::PaymentIntent,\n};\n#[cfg(feature = \"v2\")]\nuse label::*;\nuse redis_interface::HsetnxReply;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::kv_router_store::{FilterResourceParams, FindResourceBy, UpdateResourceParams};\nuse crate::{\n    diesel_error_to_data_error, errors,\n    errors::RedisErrorExt,\n    kv_router_store::KVRouterStore,\n    lookup::ReverseLookupInterface,\n    redis::kv_store::{decide_storage_scheme, kv_wrapper, KvOperation, Op, PartitionKey},\n    utils::{pg_connection_read, pg_connection_write, try_redis_get_else_try_database_get},\n    DataModelExt, DatabaseStore, RouterStore,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentAttemptInterface for RouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: PaymentAttempt,\n        _storage_scheme: MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        let diesel_payment_attempt = payment_attempt\n            .construct_new()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?;\n        let key_manager_state = self\n            .get_keymanager_state()\n            .attach_printable(\"Missing KeyManagerState\")?;\n        diesel_payment_attempt\n            .insert(&conn)\n            .await\n            .map_err(|er| {\n                let new_err = diesel_error_to_data_error(*er.current_context());\n                er.change_context(new_err)\n            })\n            .async_map(|diesel_payment_attempt| async {\n                PaymentAttempt::convert_back(\n                    key_manager_state,\n                    diesel_payment_attempt,\n                    merchant_key_store.key.get_inner(),\n                    merchant_key_store.merchant_id.clone().into(),\n                )\n                .await\n                .change_context(errors::StorageError::DecryptionError)\n            })\n            .await?\n    }\n\n    #[cfg(feature = \"v2\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_attempt: PaymentAttempt,\n        _storage_scheme: MerchantStorageScheme,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        payment_attempt\n            .construct_new()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?\n            .insert(&conn)\n            .await\n            .map_err(|error| {\n                let new_error = diesel_error_to_data_error(*error.current_context());\n                error.change_context(new_error)\n            })?\n            .convert(\n                self.get_keymanager_state()\n                    .attach_printable(\"Missing KeyManagerState\")?,\n                merchant_key_store.key.get_inner(),\n                merchant_key_store.merchant_id.clone().into(),\n            )\n            .await\n            .change_context(errors::StorageError::DecryptionError)\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn update_payment_attempt_with_attempt_id(\n        &self,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        _storage_scheme: MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        let key_manager_state = self\n            .get_keymanager_state()\n            .attach_printable(\"Missing KeyManagerState\")?;\n        this.convert()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?\n            .update_with_attempt_id(&conn, payment_attempt.to_storage_model())\n            .await\n            .map_err(|er| {\n                let new_err = diesel_error_to_data_error(*er.current_context());\n                er.change_context(new_err)\n            })\n            .async_map(|diesel_payment_attempt| async {\n                PaymentAttempt::convert_back(\n                    key_manager_state,\n                    diesel_payment_attempt,\n                    merchant_key_store.key.get_inner(),\n                    merchant_key_store.merchant_id.clone().into(),",
    "function_name": "insert_payment_attempt",
    "file": "crates__storage_impl__src__payments__payment_attempt.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for insert_payment_attempt",
    "code": "use common_utils::{errors::CustomResult, ext_traits::AsyncExt};\n#[cfg(feature = \"v1\")]\nuse common_utils::{fallback_reverse_lookup_not_found, types::ConnectorTransactionId};\nuse diesel_models::{\n    enums::{\n        MandateAmountData as DieselMandateAmountData, MandateDataType as DieselMandateType,\n        MandateDetails as DieselMandateDetails, MerchantStorageScheme,\n    },\n    kv,\n    payment_attempt::PaymentAttempt as DieselPaymentAttempt,\n    reverse_lookup::{ReverseLookup, ReverseLookupNew},\n};\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse futures::future::{try_join_all, FutureExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::behaviour::ReverseConversion;\nuse hyperswitch_domain_models::{\n    behaviour::Conversion,\n    mandates::{MandateAmountData, MandateDataType, MandateDetails},\n    merchant_key_store::MerchantKeyStore,\n    payments::payment_attempt::{PaymentAttempt, PaymentAttemptInterface, PaymentAttemptUpdate},\n};\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse hyperswitch_domain_models::{\n    payments::payment_attempt::PaymentListFilters, payments::PaymentIntent,\n};\n#[cfg(feature = \"v2\")]\nuse label::*;\nuse redis_interface::HsetnxReply;\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"v2\")]\nuse crate::kv_router_store::{FilterResourceParams, FindResourceBy, UpdateResourceParams};\nuse crate::{\n    diesel_error_to_data_error, errors,\n    errors::RedisErrorExt,\n    kv_router_store::KVRouterStore,\n    lookup::ReverseLookupInterface,\n    redis::kv_store::{decide_storage_scheme, kv_wrapper, KvOperation, Op, PartitionKey},\n    utils::{pg_connection_read, pg_connection_write, try_redis_get_else_try_database_get},\n    DataModelExt, DatabaseStore, RouterStore,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> PaymentAttemptInterface for RouterStore<T> {\n    type Error = errors::StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: PaymentAttempt,\n        _storage_scheme: MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        let diesel_payment_attempt = payment_attempt\n            .construct_new()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?;\n        let key_manager_state = self\n            .get_keymanager_state()\n            .attach_printable(\"Missing KeyManagerState\")?;\n        diesel_payment_attempt\n            .insert(&conn)\n            .await\n            .map_err(|er| {\n                let new_err = diesel_error_to_data_error(*er.current_context());\n                er.change_context(new_err)\n            })\n            .async_map(|diesel_payment_attempt| async {\n                PaymentAttempt::convert_back(\n                    key_manager_state,\n                    diesel_payment_attempt,\n                    merchant_key_store.key.get_inner(),\n                    merchant_key_store.merchant_id.clone().into(),\n                )\n                .await\n                .change_context(errors::StorageError::DecryptionError)\n            })\n            .await?\n    }\n\n    #[cfg(feature = \"v2\")]\n    #[instrument(skip_all)]\n    async fn insert_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_attempt: PaymentAttempt,\n        _storage_scheme: MerchantStorageScheme,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        payment_attempt\n            .construct_new()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?\n            .insert(&conn)\n            .await\n            .map_err(|error| {\n                let new_error = diesel_error_to_data_error(*error.current_context());\n                error.change_context(new_error)\n            })?\n            .convert(\n                self.get_keymanager_state()\n                    .attach_printable(\"Missing KeyManagerState\")?,\n                merchant_key_store.key.get_inner(),\n                merchant_key_store.merchant_id.clone().into(),\n            )\n            .await\n            .change_context(errors::StorageError::DecryptionError)\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn update_payment_attempt_with_attempt_id(\n        &self,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        _storage_scheme: MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> CustomResult<PaymentAttempt, errors::StorageError> {\n        let conn = pg_connection_write(self).await?;\n        let key_manager_state = self\n            .get_keymanager_state()\n            .attach_printable(\"Missing KeyManagerState\")?;\n        this.convert()\n            .await\n            .change_context(errors::StorageError::EncryptionError)?\n            .update_with_attempt_id(&conn, payment_attempt.to_storage_model())\n            .await\n            .map_err(|er| {\n                let new_err = diesel_error_to_data_error(*er.current_context());\n                er.change_context(new_err)\n            })\n            .async_map(|diesel_payment_attempt| async {\n                PaymentAttempt::convert_back(\n                    key_manager_state,\n                    diesel_payment_attempt,\n                    merchant_key_store.key.get_inner(),\n                    merchant_key_store.merchant_id.clone().into(),",
    "function_name": "insert_payment_attempt",
    "file": "crates__storage_impl__src__payments__payment_attempt.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs",
    "code": "use api_models::payments;\nuse base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    consts, pii,\n    types::{SemanticVersion, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankDebitData, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct WellsfargoRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for WellsfargoRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WellsfargoZeroMandateRequest {\n    processing_information: ProcessingInformation,\n    payment_information: PaymentInformation,\n    order_information: OrderInformationWithBill,\n    client_reference_information: ClientReferenceInformation,\n}\n\nimpl TryFrom<&SetupMandateRouterData> for WellsfargoZeroMandateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &SetupMandateRouterData) -> Result<Self, Self::Error> {\n        let email = item.request.get_email()?;\n        let bill_to = build_bill_to(item.get_optional_billing(), email)?;\n\n        let order_information = OrderInformationWithBill {\n            amount_details: Amount {\n                total_amount: StringMajorUnit::zero(),\n                currency: item.request.currency,\n            },\n            bill_to: Some(bill_to),\n        };\n        let (action_list, action_token_types, authorization_options) = (\n            Some(vec![WellsfargoActionsList::TokenCreate]),\n            Some(vec![\n                WellsfargoActionsTokenType::PaymentInstrument,\n                WellsfargoActionsTokenType::Customer,\n            ]),\n            Some(WellsfargoAuthorizationOptions {\n                initiator: Some(WellsfargoPaymentInitiator {\n                    initiator_type: Some(WellsfargoPaymentInitiatorTypes::Customer),\n                    credential_stored_on_file: Some(true),\n                    stored_credential_used: None,\n                }),\n                merchant_initiated_transaction: None,\n            }),\n        );\n\n        let client_reference_information = ClientReferenceInformation {\n            code: Some(item.connector_request_reference_id.clone()),\n        };\n\n        let (payment_information, solution) = match item.request.payment_method_data.clone() {\n            PaymentMethodData::Card(ccard) => {\n                let card_issuer = ccard.get_card_issuer();\n                let card_type = match card_issuer {\n                    Ok(issuer) => Some(String::from(issuer)),\n                    Err(_) => None,\n                };\n                (\n                    PaymentInformation::Cards(Box::new(CardPaymentInformation {\n                        card: Card {\n                            number: ccard.card_number,\n                            expiration_month: ccard.card_exp_month,\n                            expiration_year: ccard.card_exp_year,\n                            security_code: Some(ccard.card_cvc),\n                            card_type,\n                        },\n                    })),\n                    None,\n                )\n            }\n\n            PaymentMethodData::Wallet(wallet_data) => match wallet_data {\n                WalletData::ApplePay(apple_pay_data) => match item.payment_method_token.clone() {\n                    Some(payment_method_token) => match payment_method_token {\n                        PaymentMethodToken::ApplePayDecrypt(decrypt_data) => {\n                            let expiration_month = decrypt_data.get_expiry_month().change_context(\n                                errors::ConnectorError::InvalidDataFormat {\n                                    field_name: \"expiration_month\",\n                                },\n                            )?;\n                            let expiration_year = decrypt_data.get_four_digit_expiry_year();\n                            (\n                                PaymentInformation::ApplePay(Box::new(\n                                    ApplePayPaymentInformation {",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs",
    "code": "use api_models::payments;\nuse base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    consts, pii,\n    types::{SemanticVersion, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankDebitData, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct WellsfargoRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for WellsfargoRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WellsfargoZeroMandateRequest {\n    processing_information: ProcessingInformation,\n    payment_information: PaymentInformation,\n    order_information: OrderInformationWithBill,\n    client_reference_information: ClientReferenceInformation,\n}\n\nimpl TryFrom<&SetupMandateRouterData> for WellsfargoZeroMandateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &SetupMandateRouterData) -> Result<Self, Self::Error> {\n        let email = item.request.get_email()?;\n        let bill_to = build_bill_to(item.get_optional_billing(), email)?;\n\n        let order_information = OrderInformationWithBill {\n            amount_details: Amount {\n                total_amount: StringMajorUnit::zero(),\n                currency: item.request.currency,\n            },\n            bill_to: Some(bill_to),\n        };\n        let (action_list, action_token_types, authorization_options) = (\n            Some(vec![WellsfargoActionsList::TokenCreate]),\n            Some(vec![\n                WellsfargoActionsTokenType::PaymentInstrument,\n                WellsfargoActionsTokenType::Customer,\n            ]),\n            Some(WellsfargoAuthorizationOptions {\n                initiator: Some(WellsfargoPaymentInitiator {\n                    initiator_type: Some(WellsfargoPaymentInitiatorTypes::Customer),\n                    credential_stored_on_file: Some(true),\n                    stored_credential_used: None,\n                }),\n                merchant_initiated_transaction: None,\n            }),\n        );\n\n        let client_reference_information = ClientReferenceInformation {\n            code: Some(item.connector_request_reference_id.clone()),\n        };\n\n        let (payment_information, solution) = match item.request.payment_method_data.clone() {\n            PaymentMethodData::Card(ccard) => {\n                let card_issuer = ccard.get_card_issuer();\n                let card_type = match card_issuer {\n                    Ok(issuer) => Some(String::from(issuer)),\n                    Err(_) => None,\n                };\n                (\n                    PaymentInformation::Cards(Box::new(CardPaymentInformation {\n                        card: Card {\n                            number: ccard.card_number,\n                            expiration_month: ccard.card_exp_month,\n                            expiration_year: ccard.card_exp_year,\n                            security_code: Some(ccard.card_cvc),\n                            card_type,\n                        },\n                    })),\n                    None,\n                )\n            }\n\n            PaymentMethodData::Wallet(wallet_data) => match wallet_data {\n                WalletData::ApplePay(apple_pay_data) => match item.payment_method_token.clone() {\n                    Some(payment_method_token) => match payment_method_token {\n                        PaymentMethodToken::ApplePayDecrypt(decrypt_data) => {\n                            let expiration_month = decrypt_data.get_expiry_month().change_context(\n                                errors::ConnectorError::InvalidDataFormat {\n                                    field_name: \"expiration_month\",\n                                },\n                            )?;\n                            let expiration_year = decrypt_data.get_four_digit_expiry_year();\n                            (\n                                PaymentInformation::ApplePay(Box::new(\n                                    ApplePayPaymentInformation {",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use api_models::payments;\nuse base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    consts, pii,\n    types::{SemanticVersion, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankDebitData, GooglePayWalletData, PaymentMethodData, WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::{\n        payments::Authorize,\n        refunds::{Execute, RSync},\n        SetupMandate,\n    },\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\n\n#[derive(Debug, Serialize)]\npub struct WellsfargoRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for WellsfargoRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WellsfargoZeroMandateRequest {\n    processing_information: ProcessingInformation,\n    payment_information: PaymentInformation,\n    order_information: OrderInformationWithBill,\n    client_reference_information: ClientReferenceInformation,\n}\n\nimpl TryFrom<&SetupMandateRouterData> for WellsfargoZeroMandateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &SetupMandateRouterData) -> Result<Self, Self::Error> {\n        let email = item.request.get_email()?;\n        let bill_to = build_bill_to(item.get_optional_billing(), email)?;\n\n        let order_information = OrderInformationWithBill {\n            amount_details: Amount {\n                total_amount: StringMajorUnit::zero(),\n                currency: item.request.currency,\n            },\n            bill_to: Some(bill_to),\n        };\n        let (action_list, action_token_types, authorization_options) = (\n            Some(vec![WellsfargoActionsList::TokenCreate]),\n            Some(vec![\n                WellsfargoActionsTokenType::PaymentInstrument,\n                WellsfargoActionsTokenType::Customer,\n            ]),\n            Some(WellsfargoAuthorizationOptions {\n                initiator: Some(WellsfargoPaymentInitiator {\n                    initiator_type: Some(WellsfargoPaymentInitiatorTypes::Customer),\n                    credential_stored_on_file: Some(true),\n                    stored_credential_used: None,\n                }),\n                merchant_initiated_transaction: None,\n            }),\n        );\n\n        let client_reference_information = ClientReferenceInformation {\n            code: Some(item.connector_request_reference_id.clone()),\n        };\n\n        let (payment_information, solution) = match item.request.payment_method_data.clone() {\n            PaymentMethodData::Card(ccard) => {\n                let card_issuer = ccard.get_card_issuer();\n                let card_type = match card_issuer {\n                    Ok(issuer) => Some(String::from(issuer)),\n                    Err(_) => None,\n                };\n                (\n                    PaymentInformation::Cards(Box::new(CardPaymentInformation {\n                        card: Card {\n                            number: ccard.card_number,\n                            expiration_month: ccard.card_exp_month,\n                            expiration_year: ccard.card_exp_year,\n                            security_code: Some(ccard.card_cvc),\n                            card_type,\n                        },\n                    })),\n                    None,\n                )\n            }\n\n            PaymentMethodData::Wallet(wallet_data) => match wallet_data {\n                WalletData::ApplePay(apple_pay_data) => match item.payment_method_token.clone() {\n                    Some(payment_method_token) => match payment_method_token {\n                        PaymentMethodToken::ApplePayDecrypt(decrypt_data) => {\n                            let expiration_month = decrypt_data.get_expiry_month().change_context(\n                                errors::ConnectorError::InvalidDataFormat {\n                                    field_name: \"expiration_month\",\n                                },\n                            )?;\n                            let expiration_year = decrypt_data.get_four_digit_expiry_year();\n                            (\n                                PaymentInformation::ApplePay(Box::new(\n                                    ApplePayPaymentInformation {",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__wellsfargo__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__worldline.rs",
    "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, PaymentCapture, PaymentSync,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse router_env::logger;\nuse time::{format_description, OffsetDateTime};\nuse transformers as worldline;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(Debug, Clone)]\npub struct Worldline;\n\nimpl Worldline {\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n\nimpl ConnectorCommon for Worldline {\n    fn id(&self) -> &'static str {\n        \"worldline\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {",
    "function_name": "generate_authorization_token",
    "file": "crates__hyperswitch_connectors__src__connectors__worldline.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__worldline.rs",
    "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, PaymentCapture, PaymentSync,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse router_env::logger;\nuse time::{format_description, OffsetDateTime};\nuse transformers as worldline;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(Debug, Clone)]\npub struct Worldline;\n\nimpl Worldline {\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n\nimpl ConnectorCommon for Worldline {\n    fn id(&self) -> &'static str {\n        \"worldline\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {",
    "function_name": "generate_authorization_token",
    "file": "crates__hyperswitch_connectors__src__connectors__worldline.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for generate_authorization_token",
    "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts, crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, OptionExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation, PaymentCapture, PaymentSync,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{self, IncomingWebhookFlowError},\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse router_env::logger;\nuse time::{format_description, OffsetDateTime};\nuse transformers as worldline;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData as _},\n};\n\n#[derive(Debug, Clone)]\npub struct Worldline;\n\nimpl Worldline {\n    pub fn generate_authorization_token(\n        &self,\n        auth: worldline::WorldlineAuthType,\n        http_method: Method,\n        content_type: &str,\n        date: &str,\n        endpoint: &str,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let signature_data: String = format!(\n            \"{}\\n{}\\n{}\\n/{}\\n\",\n            http_method,\n            content_type.trim(),\n            date.trim(),\n            endpoint.trim()\n        );\n        let worldline::WorldlineAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let signed_data = consts::BASE64_ENGINE.encode(hmac::sign(&key, signature_data.as_bytes()));\n\n        Ok(format!(\"GCS v1HMAC:{}:{signed_data}\", api_key.peek()))\n    }\n\n    pub fn get_current_date_time() -> CustomResult<String, errors::ConnectorError> {\n        let format = format_description::parse(\n            \"[weekday repr:short], [day] [month repr:short] [year] [hour]:[minute]:[second] GMT\",\n        )\n        .change_context(errors::ConnectorError::InvalidDateFormat)?;\n        OffsetDateTime::now_utc()\n            .format(&format)\n            .change_context(errors::ConnectorError::InvalidDateFormat)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldline\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let base_url = self.base_url(connectors);\n        let url = Self::get_url(self, req, connectors)?;\n        let endpoint = url.replace(base_url, \"\");\n        let http_method = Self::get_http_method(self);\n        let auth = worldline::WorldlineAuthType::try_from(&req.connector_auth_type)?;\n        let date = Self::get_current_date_time()?;\n        let content_type = Self::get_content_type(self);\n        let signed_data: String =\n            self.generate_authorization_token(auth, http_method, content_type, &date, &endpoint)?;\n\n        Ok(vec![\n            (headers::DATE.to_string(), date.into()),\n            (\n                headers::AUTHORIZATION.to_string(),\n                signed_data.into_masked(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                content_type.to_string().into(),\n            ),\n        ])\n    }\n}\n\nimpl ConnectorCommon for Worldline {\n    fn id(&self) -> &'static str {\n        \"worldline\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {",
    "function_name": "generate_authorization_token",
    "file": "crates__hyperswitch_connectors__src__connectors__worldline.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__core__routing__helpers.rs",
    "code": "//! Analysis for usage of all helper functions for use case of routing\n//!\n//! Functions that are used to perform the retrieval of merchant's\n//! routing dict, configs, defaults\nuse std::fmt::Debug;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::str::FromStr;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::sync::Arc;\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router;\nuse api_models::routing as routing_types;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{ext_traits::Encode, id_type};\nuse diesel_models::configs;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse diesel_models::dynamic_routing_stats::{DynamicRoutingStatsNew, DynamicRoutingStatsUpdate};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse diesel_models::routing_algorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_domain_models::api::ApplicationResponse;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v1\")]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashSet;\nuse storage_impl::redis::cache;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse storage_impl::redis::cache::Cacheable;\n\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::db::errors::StorageErrorExt;\n#[cfg(feature = \"v2\")]\nuse crate::types::domain::MerchantConnectorAccount;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::types::transformers::ForeignFrom;\nuse crate::{\n    core::errors::{self, RouterResult},\n    db::StorageInterface,\n    routes::SessionState,\n    types::{domain, storage},\n    utils::StringExt,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    core::payments::{\n        routing::utils::{self as routing_utils, DecisionEngineApiHandler},\n        OperationSessionGetters, OperationSessionSetters,\n    },\n    services,\n};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::{\n    core::{metrics as core_metrics, routing},\n    routes::app::SessionStateInfo,\n    types::transformers::ForeignInto,\n};\npub const SUCCESS_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Success rate based dynamic routing algorithm\";\npub const ELIMINATION_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Elimination based dynamic routing algorithm\";\npub const CONTRACT_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Contract based dynamic routing algorithm\";\n\npub const DECISION_ENGINE_RULE_CREATE_ENDPOINT: &str = \"rule/create\";\npub const DECISION_ENGINE_RULE_UPDATE_ENDPOINT: &str = \"rule/update\";\npub const DECISION_ENGINE_RULE_GET_ENDPOINT: &str = \"rule/get\";\npub const DECISION_ENGINE_RULE_DELETE_ENDPOINT: &str = \"rule/delete\";\npub const DECISION_ENGINE_MERCHANT_BASE_ENDPOINT: &str = \"merchant-account\";\npub const DECISION_ENGINE_MERCHANT_CREATE_ENDPOINT: &str = \"merchant-account/create\";\n\n/// Provides us with all the configured configs of the Merchant in the ascending time configured\n/// manner and chooses the first of them\npub async fn get_merchant_default_config(\n    db: &dyn StorageInterface,\n    // Cannot make this as merchant id domain type because, we are passing profile id also here\n    merchant_id: &str,\n    transaction_type: &storage::enums::TransactionType,\n) -> RouterResult<Vec<routing_types::RoutableConnectorChoice>> {\n    let key = get_default_config_key(merchant_id, transaction_type);\n    let maybe_config = db.find_config_by_key(&key).await;\n\n    match maybe_config {\n        Ok(config) => config\n            .config\n            .parse_struct(\"Vec<RoutableConnectors>\")\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Merchant default config has invalid structure\"),\n\n        Err(e) if e.current_context().is_db_not_found() => {\n            let new_config_conns = Vec::<routing_types::RoutableConnectorChoice>::new();\n            let serialized = new_config_conns\n                .encode_to_string_of_json()\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\n                    \"Error while creating and serializing new merchant default config\",\n                )?;\n\n            let new_config = configs::ConfigNew {\n                key,\n                config: serialized,\n            };\n\n            db.insert_config(new_config)\n                .await\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"Error inserting new default routing config into DB\")?;\n\n            Ok(new_config_conns)\n        }\n\n        Err(e) => Err(e)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Error fetching default config for merchant\"),\n    }\n}\n\n/// Merchant's already created config can be updated and this change will be reflected\n/// in DB as well for the particular updated config\npub async fn update_merchant_default_config(\n    db: &dyn StorageInterface,\n    merchant_id: &str,\n    connectors: Vec<routing_types::RoutableConnectorChoice>,\n    transaction_type: &storage::enums::TransactionType,\n) -> RouterResult<()> {\n    let key = get_default_config_key(merchant_id, transaction_type);\n    let config_str = connectors\n        .encode_to_string_of_json()\n        .change_context(errors::ApiErrorResponse::InternalServerError)",
    "function_name": "get_merchant_default_config",
    "file": "crates__router__src__core__routing__helpers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__core__routing__helpers.rs",
    "code": "//! Analysis for usage of all helper functions for use case of routing\n//!\n//! Functions that are used to perform the retrieval of merchant's\n//! routing dict, configs, defaults\nuse std::fmt::Debug;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::str::FromStr;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::sync::Arc;\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router;\nuse api_models::routing as routing_types;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{ext_traits::Encode, id_type};\nuse diesel_models::configs;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse diesel_models::dynamic_routing_stats::{DynamicRoutingStatsNew, DynamicRoutingStatsUpdate};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse diesel_models::routing_algorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_domain_models::api::ApplicationResponse;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v1\")]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashSet;\nuse storage_impl::redis::cache;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse storage_impl::redis::cache::Cacheable;\n\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::db::errors::StorageErrorExt;\n#[cfg(feature = \"v2\")]\nuse crate::types::domain::MerchantConnectorAccount;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::types::transformers::ForeignFrom;\nuse crate::{\n    core::errors::{self, RouterResult},\n    db::StorageInterface,\n    routes::SessionState,\n    types::{domain, storage},\n    utils::StringExt,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    core::payments::{\n        routing::utils::{self as routing_utils, DecisionEngineApiHandler},\n        OperationSessionGetters, OperationSessionSetters,\n    },\n    services,\n};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::{\n    core::{metrics as core_metrics, routing},\n    routes::app::SessionStateInfo,\n    types::transformers::ForeignInto,\n};\npub const SUCCESS_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Success rate based dynamic routing algorithm\";\npub const ELIMINATION_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Elimination based dynamic routing algorithm\";\npub const CONTRACT_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Contract based dynamic routing algorithm\";\n\npub const DECISION_ENGINE_RULE_CREATE_ENDPOINT: &str = \"rule/create\";\npub const DECISION_ENGINE_RULE_UPDATE_ENDPOINT: &str = \"rule/update\";\npub const DECISION_ENGINE_RULE_GET_ENDPOINT: &str = \"rule/get\";\npub const DECISION_ENGINE_RULE_DELETE_ENDPOINT: &str = \"rule/delete\";\npub const DECISION_ENGINE_MERCHANT_BASE_ENDPOINT: &str = \"merchant-account\";\npub const DECISION_ENGINE_MERCHANT_CREATE_ENDPOINT: &str = \"merchant-account/create\";\n\n/// Provides us with all the configured configs of the Merchant in the ascending time configured\n/// manner and chooses the first of them\npub async fn get_merchant_default_config(\n    db: &dyn StorageInterface,\n    // Cannot make this as merchant id domain type because, we are passing profile id also here\n    merchant_id: &str,\n    transaction_type: &storage::enums::TransactionType,\n) -> RouterResult<Vec<routing_types::RoutableConnectorChoice>> {\n    let key = get_default_config_key(merchant_id, transaction_type);\n    let maybe_config = db.find_config_by_key(&key).await;\n\n    match maybe_config {\n        Ok(config) => config\n            .config\n            .parse_struct(\"Vec<RoutableConnectors>\")\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Merchant default config has invalid structure\"),\n\n        Err(e) if e.current_context().is_db_not_found() => {\n            let new_config_conns = Vec::<routing_types::RoutableConnectorChoice>::new();\n            let serialized = new_config_conns\n                .encode_to_string_of_json()\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\n                    \"Error while creating and serializing new merchant default config\",\n                )?;\n\n            let new_config = configs::ConfigNew {\n                key,\n                config: serialized,\n            };\n\n            db.insert_config(new_config)\n                .await\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"Error inserting new default routing config into DB\")?;\n\n            Ok(new_config_conns)\n        }\n\n        Err(e) => Err(e)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Error fetching default config for merchant\"),\n    }\n}\n\n/// Merchant's already created config can be updated and this change will be reflected\n/// in DB as well for the particular updated config\npub async fn update_merchant_default_config(\n    db: &dyn StorageInterface,\n    merchant_id: &str,\n    connectors: Vec<routing_types::RoutableConnectorChoice>,\n    transaction_type: &storage::enums::TransactionType,\n) -> RouterResult<()> {\n    let key = get_default_config_key(merchant_id, transaction_type);\n    let config_str = connectors\n        .encode_to_string_of_json()\n        .change_context(errors::ApiErrorResponse::InternalServerError)",
    "function_name": "get_merchant_default_config",
    "file": "crates__router__src__core__routing__helpers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_merchant_default_config",
    "code": "//! Analysis for usage of all helper functions for use case of routing\n//!\n//! Functions that are used to perform the retrieval of merchant's\n//! routing dict, configs, defaults\nuse std::fmt::Debug;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::str::FromStr;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse std::sync::Arc;\n\n#[cfg(feature = \"v1\")]\nuse api_models::open_router;\nuse api_models::routing as routing_types;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse common_utils::ext_traits::ValueExt;\nuse common_utils::{ext_traits::Encode, id_type};\nuse diesel_models::configs;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse diesel_models::dynamic_routing_stats::{DynamicRoutingStatsNew, DynamicRoutingStatsUpdate};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse diesel_models::routing_algorithm;\nuse error_stack::ResultExt;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse external_services::grpc_client::dynamic_routing::{\n    contract_routing_client::ContractBasedDynamicRouting,\n    elimination_based_client::EliminationBasedRouting,\n    success_rate_client::SuccessBasedDynamicRouting,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_domain_models::api::ApplicationResponse;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse hyperswitch_interfaces::events::routing_api_logs as routing_events;\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\n#[cfg(feature = \"v1\")]\nuse router_env::{instrument, tracing};\nuse rustc_hash::FxHashSet;\nuse storage_impl::redis::cache;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse storage_impl::redis::cache::Cacheable;\n\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::db::errors::StorageErrorExt;\n#[cfg(feature = \"v2\")]\nuse crate::types::domain::MerchantConnectorAccount;\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::types::transformers::ForeignFrom;\nuse crate::{\n    core::errors::{self, RouterResult},\n    db::StorageInterface,\n    routes::SessionState,\n    types::{domain, storage},\n    utils::StringExt,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    core::payments::{\n        routing::utils::{self as routing_utils, DecisionEngineApiHandler},\n        OperationSessionGetters, OperationSessionSetters,\n    },\n    services,\n};\n#[cfg(all(feature = \"dynamic_routing\", feature = \"v1\"))]\nuse crate::{\n    core::{metrics as core_metrics, routing},\n    routes::app::SessionStateInfo,\n    types::transformers::ForeignInto,\n};\npub const SUCCESS_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Success rate based dynamic routing algorithm\";\npub const ELIMINATION_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Elimination based dynamic routing algorithm\";\npub const CONTRACT_BASED_DYNAMIC_ROUTING_ALGORITHM: &str =\n    \"Contract based dynamic routing algorithm\";\n\npub const DECISION_ENGINE_RULE_CREATE_ENDPOINT: &str = \"rule/create\";\npub const DECISION_ENGINE_RULE_UPDATE_ENDPOINT: &str = \"rule/update\";\npub const DECISION_ENGINE_RULE_GET_ENDPOINT: &str = \"rule/get\";\npub const DECISION_ENGINE_RULE_DELETE_ENDPOINT: &str = \"rule/delete\";\npub const DECISION_ENGINE_MERCHANT_BASE_ENDPOINT: &str = \"merchant-account\";\npub const DECISION_ENGINE_MERCHANT_CREATE_ENDPOINT: &str = \"merchant-account/create\";\n\n/// Provides us with all the configured configs of the Merchant in the ascending time configured\n/// manner and chooses the first of them\npub async fn get_merchant_default_config(\n    db: &dyn StorageInterface,\n    // Cannot make this as merchant id domain type because, we are passing profile id also here\n    merchant_id: &str,\n    transaction_type: &storage::enums::TransactionType,\n) -> RouterResult<Vec<routing_types::RoutableConnectorChoice>> {\n    let key = get_default_config_key(merchant_id, transaction_type);\n    let maybe_config = db.find_config_by_key(&key).await;\n\n    match maybe_config {\n        Ok(config) => config\n            .config\n            .parse_struct(\"Vec<RoutableConnectors>\")\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Merchant default config has invalid structure\"),\n\n        Err(e) if e.current_context().is_db_not_found() => {\n            let new_config_conns = Vec::<routing_types::RoutableConnectorChoice>::new();\n            let serialized = new_config_conns\n                .encode_to_string_of_json()\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\n                    \"Error while creating and serializing new merchant default config\",\n                )?;\n\n            let new_config = configs::ConfigNew {\n                key,\n                config: serialized,\n            };\n\n            db.insert_config(new_config)\n                .await\n                .change_context(errors::ApiErrorResponse::InternalServerError)\n                .attach_printable(\"Error inserting new default routing config into DB\")?;\n\n            Ok(new_config_conns)\n        }\n\n        Err(e) => Err(e)\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Error fetching default config for merchant\"),\n    }\n}\n\n/// Merchant's already created config can be updated and this change will be reflected\n/// in DB as well for the particular updated config\npub async fn update_merchant_default_config(\n    db: &dyn StorageInterface,\n    merchant_id: &str,\n    connectors: Vec<routing_types::RoutableConnectorChoice>,\n    transaction_type: &storage::enums::TransactionType,\n) -> RouterResult<()> {\n    let key = get_default_config_key(merchant_id, transaction_type);\n    let config_str = connectors\n        .encode_to_string_of_json()\n        .change_context(errors::ApiErrorResponse::InternalServerError)",
    "function_name": "get_merchant_default_config",
    "file": "crates__router__src__core__routing__helpers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__common_utils__src__types.rs",
    "code": "//! Types that can be used in other crates\npub mod keymanager;\n\n/// Enum for Authentication Level\npub mod authentication;\n/// User related types\npub mod user;\n\n/// types that are wrappers around primitive types\npub mod primitive_wrappers;\n\nuse std::{\n    borrow::Cow,\n    fmt::Display,\n    iter::Sum,\n    num::NonZeroI64,\n    ops::{Add, Mul, Sub},\n    primitive::i64,\n    str::FromStr,\n};\n\nuse common_enums::enums;\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    serialize::{Output, ToSql},\n    sql_types,\n    sql_types::Jsonb,\n    AsExpression, FromSqlRow, Queryable,\n};\nuse error_stack::{report, ResultExt};\npub use primitive_wrappers::bool_wrappers::{\n    AlwaysRequestExtendedAuthorization, ExtendedAuthorizationAppliedBool,\n    RequestExtendedAuthorizationBool,\n};\nuse rust_decimal::{\n    prelude::{FromPrimitive, ToPrimitive},\n    Decimal,\n};\nuse semver::Version;\nuse serde::{de::Visitor, Deserialize, Deserializer, Serialize};\nuse thiserror::Error;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    consts::{\n        self, MAX_DESCRIPTION_LENGTH, MAX_STATEMENT_DESCRIPTOR_LENGTH, PUBLISHABLE_KEY_LENGTH,\n    },\n    errors::{CustomResult, ParsingError, PercentageError, ValidationError},\n    fp_utils::when,\n    id_type, impl_enum_str,\n};\n\n/// Represents Percentage Value between 0 and 100 both inclusive\n#[derive(Clone, Default, Debug, PartialEq, Serialize)]\npub struct Percentage<const PRECISION: u8> {\n    // this value will range from 0 to 100, decimal length defined by precision macro\n    /// Percentage value ranging between 0 and 100\n    percentage: f32,\n}\n\nfn get_invalid_percentage_error_message(precision: u8) -> String {\n    format!(\n        \"value should be a float between 0 to 100 and precise to only upto {precision} decimal digits\",\n\n    )\n}\n\nimpl<const PRECISION: u8> Percentage<PRECISION> {\n    /// construct percentage using a string representation of float value\n    pub fn from_string(value: String) -> CustomResult<Self, PercentageError> {\n        if Self::is_valid_string_value(&value)? {\n            Ok(Self {\n                percentage: value\n                    .parse::<f32>()\n                    .change_context(PercentageError::InvalidPercentageValue)?,\n            })\n        } else {\n            Err(report!(PercentageError::InvalidPercentageValue))\n                .attach_printable(get_invalid_percentage_error_message(PRECISION))\n        }\n    }\n    /// function to get percentage value\n    pub fn get_percentage(&self) -> f32 {\n        self.percentage\n    }\n\n    /// apply the percentage to amount and ceil the result\n    #[allow(clippy::as_conversions)]\n    pub fn apply_and_ceil_result(\n        &self,\n        amount: MinorUnit,\n    ) -> CustomResult<MinorUnit, PercentageError> {\n        let max_amount = i64::MAX / 10000;\n        let amount = amount.0;\n        if amount > max_amount {\n            // value gets rounded off after i64::MAX/10000\n            Err(report!(PercentageError::UnableToApplyPercentage {\n                percentage: self.percentage,\n                amount: MinorUnit::new(amount),\n            }))\n            .attach_printable(format!(\n                \"Cannot calculate percentage for amount greater than {max_amount}\",\n            ))\n        } else {\n            let percentage_f64 = f64::from(self.percentage);\n            let result = (amount as f64 * (percentage_f64 / 100.0)).ceil() as i64;\n            Ok(MinorUnit::new(result))\n        }\n    }\n\n    fn is_valid_string_value(value: &str) -> CustomResult<bool, PercentageError> {\n        let float_value = Self::is_valid_float_string(value)?;\n        Ok(Self::is_valid_range(float_value) && Self::is_valid_precision_length(value))\n    }\n    fn is_valid_float_string(value: &str) -> CustomResult<f32, PercentageError> {\n        value\n            .parse::<f32>()\n            .change_context(PercentageError::InvalidPercentageValue)\n    }\n    fn is_valid_range(value: f32) -> bool {\n        (0.0..=100.0).contains(&value)\n    }\n    fn is_valid_precision_length(value: &str) -> bool {\n        if value.contains('.') {\n            // if string has '.' then take the decimal part and verify precision length\n            match value.split('.').next_back() {\n                Some(decimal_part) => {\n                    decimal_part.trim_end_matches('0').len() <= <u8 as Into<usize>>::into(PRECISION)\n                }\n                // will never be None\n                None => false,\n            }\n        } else {\n            // if there is no '.' then it is a whole number with no decimal part. So return true\n            true\n        }\n    }",
    "function_name": "get_invalid_percentage_error_message",
    "file": "crates__common_utils__src__types.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__common_utils__src__types.rs",
    "code": "//! Types that can be used in other crates\npub mod keymanager;\n\n/// Enum for Authentication Level\npub mod authentication;\n/// User related types\npub mod user;\n\n/// types that are wrappers around primitive types\npub mod primitive_wrappers;\n\nuse std::{\n    borrow::Cow,\n    fmt::Display,\n    iter::Sum,\n    num::NonZeroI64,\n    ops::{Add, Mul, Sub},\n    primitive::i64,\n    str::FromStr,\n};\n\nuse common_enums::enums;\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    serialize::{Output, ToSql},\n    sql_types,\n    sql_types::Jsonb,\n    AsExpression, FromSqlRow, Queryable,\n};\nuse error_stack::{report, ResultExt};\npub use primitive_wrappers::bool_wrappers::{\n    AlwaysRequestExtendedAuthorization, ExtendedAuthorizationAppliedBool,\n    RequestExtendedAuthorizationBool,\n};\nuse rust_decimal::{\n    prelude::{FromPrimitive, ToPrimitive},\n    Decimal,\n};\nuse semver::Version;\nuse serde::{de::Visitor, Deserialize, Deserializer, Serialize};\nuse thiserror::Error;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    consts::{\n        self, MAX_DESCRIPTION_LENGTH, MAX_STATEMENT_DESCRIPTOR_LENGTH, PUBLISHABLE_KEY_LENGTH,\n    },\n    errors::{CustomResult, ParsingError, PercentageError, ValidationError},\n    fp_utils::when,\n    id_type, impl_enum_str,\n};\n\n/// Represents Percentage Value between 0 and 100 both inclusive\n#[derive(Clone, Default, Debug, PartialEq, Serialize)]\npub struct Percentage<const PRECISION: u8> {\n    // this value will range from 0 to 100, decimal length defined by precision macro\n    /// Percentage value ranging between 0 and 100\n    percentage: f32,\n}\n\nfn get_invalid_percentage_error_message(precision: u8) -> String {\n    format!(\n        \"value should be a float between 0 to 100 and precise to only upto {precision} decimal digits\",\n\n    )\n}\n\nimpl<const PRECISION: u8> Percentage<PRECISION> {\n    /// construct percentage using a string representation of float value\n    pub fn from_string(value: String) -> CustomResult<Self, PercentageError> {\n        if Self::is_valid_string_value(&value)? {\n            Ok(Self {\n                percentage: value\n                    .parse::<f32>()\n                    .change_context(PercentageError::InvalidPercentageValue)?,\n            })\n        } else {\n            Err(report!(PercentageError::InvalidPercentageValue))\n                .attach_printable(get_invalid_percentage_error_message(PRECISION))\n        }\n    }\n    /// function to get percentage value\n    pub fn get_percentage(&self) -> f32 {\n        self.percentage\n    }\n\n    /// apply the percentage to amount and ceil the result\n    #[allow(clippy::as_conversions)]\n    pub fn apply_and_ceil_result(\n        &self,\n        amount: MinorUnit,\n    ) -> CustomResult<MinorUnit, PercentageError> {\n        let max_amount = i64::MAX / 10000;\n        let amount = amount.0;\n        if amount > max_amount {\n            // value gets rounded off after i64::MAX/10000\n            Err(report!(PercentageError::UnableToApplyPercentage {\n                percentage: self.percentage,\n                amount: MinorUnit::new(amount),\n            }))\n            .attach_printable(format!(\n                \"Cannot calculate percentage for amount greater than {max_amount}\",\n            ))\n        } else {\n            let percentage_f64 = f64::from(self.percentage);\n            let result = (amount as f64 * (percentage_f64 / 100.0)).ceil() as i64;\n            Ok(MinorUnit::new(result))\n        }\n    }\n\n    fn is_valid_string_value(value: &str) -> CustomResult<bool, PercentageError> {\n        let float_value = Self::is_valid_float_string(value)?;\n        Ok(Self::is_valid_range(float_value) && Self::is_valid_precision_length(value))\n    }\n    fn is_valid_float_string(value: &str) -> CustomResult<f32, PercentageError> {\n        value\n            .parse::<f32>()\n            .change_context(PercentageError::InvalidPercentageValue)\n    }\n    fn is_valid_range(value: f32) -> bool {\n        (0.0..=100.0).contains(&value)\n    }\n    fn is_valid_precision_length(value: &str) -> bool {\n        if value.contains('.') {\n            // if string has '.' then take the decimal part and verify precision length\n            match value.split('.').next_back() {\n                Some(decimal_part) => {\n                    decimal_part.trim_end_matches('0').len() <= <u8 as Into<usize>>::into(PRECISION)\n                }\n                // will never be None\n                None => false,\n            }\n        } else {\n            // if there is no '.' then it is a whole number with no decimal part. So return true\n            true\n        }\n    }",
    "function_name": "get_invalid_percentage_error_message",
    "file": "crates__common_utils__src__types.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_invalid_percentage_error_message",
    "code": "//! Types that can be used in other crates\npub mod keymanager;\n\n/// Enum for Authentication Level\npub mod authentication;\n/// User related types\npub mod user;\n\n/// types that are wrappers around primitive types\npub mod primitive_wrappers;\n\nuse std::{\n    borrow::Cow,\n    fmt::Display,\n    iter::Sum,\n    num::NonZeroI64,\n    ops::{Add, Mul, Sub},\n    primitive::i64,\n    str::FromStr,\n};\n\nuse common_enums::enums;\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    serialize::{Output, ToSql},\n    sql_types,\n    sql_types::Jsonb,\n    AsExpression, FromSqlRow, Queryable,\n};\nuse error_stack::{report, ResultExt};\npub use primitive_wrappers::bool_wrappers::{\n    AlwaysRequestExtendedAuthorization, ExtendedAuthorizationAppliedBool,\n    RequestExtendedAuthorizationBool,\n};\nuse rust_decimal::{\n    prelude::{FromPrimitive, ToPrimitive},\n    Decimal,\n};\nuse semver::Version;\nuse serde::{de::Visitor, Deserialize, Deserializer, Serialize};\nuse thiserror::Error;\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\nuse crate::{\n    consts::{\n        self, MAX_DESCRIPTION_LENGTH, MAX_STATEMENT_DESCRIPTOR_LENGTH, PUBLISHABLE_KEY_LENGTH,\n    },\n    errors::{CustomResult, ParsingError, PercentageError, ValidationError},\n    fp_utils::when,\n    id_type, impl_enum_str,\n};\n\n/// Represents Percentage Value between 0 and 100 both inclusive\n#[derive(Clone, Default, Debug, PartialEq, Serialize)]\npub struct Percentage<const PRECISION: u8> {\n    // this value will range from 0 to 100, decimal length defined by precision macro\n    /// Percentage value ranging between 0 and 100\n    percentage: f32,\n}\n\nfn get_invalid_percentage_error_message(precision: u8) -> String {\n    format!(\n        \"value should be a float between 0 to 100 and precise to only upto {precision} decimal digits\",\n\n    )\n}\n\nimpl<const PRECISION: u8> Percentage<PRECISION> {\n    /// construct percentage using a string representation of float value\n    pub fn from_string(value: String) -> CustomResult<Self, PercentageError> {\n        if Self::is_valid_string_value(&value)? {\n            Ok(Self {\n                percentage: value\n                    .parse::<f32>()\n                    .change_context(PercentageError::InvalidPercentageValue)?,\n            })\n        } else {\n            Err(report!(PercentageError::InvalidPercentageValue))\n                .attach_printable(get_invalid_percentage_error_message(PRECISION))\n        }\n    }\n    /// function to get percentage value\n    pub fn get_percentage(&self) -> f32 {\n        self.percentage\n    }\n\n    /// apply the percentage to amount and ceil the result\n    #[allow(clippy::as_conversions)]\n    pub fn apply_and_ceil_result(\n        &self,\n        amount: MinorUnit,\n    ) -> CustomResult<MinorUnit, PercentageError> {\n        let max_amount = i64::MAX / 10000;\n        let amount = amount.0;\n        if amount > max_amount {\n            // value gets rounded off after i64::MAX/10000\n            Err(report!(PercentageError::UnableToApplyPercentage {\n                percentage: self.percentage,\n                amount: MinorUnit::new(amount),\n            }))\n            .attach_printable(format!(\n                \"Cannot calculate percentage for amount greater than {max_amount}\",\n            ))\n        } else {\n            let percentage_f64 = f64::from(self.percentage);\n            let result = (amount as f64 * (percentage_f64 / 100.0)).ceil() as i64;\n            Ok(MinorUnit::new(result))\n        }\n    }\n\n    fn is_valid_string_value(value: &str) -> CustomResult<bool, PercentageError> {\n        let float_value = Self::is_valid_float_string(value)?;\n        Ok(Self::is_valid_range(float_value) && Self::is_valid_precision_length(value))\n    }\n    fn is_valid_float_string(value: &str) -> CustomResult<f32, PercentageError> {\n        value\n            .parse::<f32>()\n            .change_context(PercentageError::InvalidPercentageValue)\n    }\n    fn is_valid_range(value: f32) -> bool {\n        (0.0..=100.0).contains(&value)\n    }\n    fn is_valid_precision_length(value: &str) -> bool {\n        if value.contains('.') {\n            // if string has '.' then take the decimal part and verify precision length\n            match value.split('.').next_back() {\n                Some(decimal_part) => {\n                    decimal_part.trim_end_matches('0').len() <= <u8 as Into<usize>>::into(PRECISION)\n                }\n                // will never be None\n                None => false,\n            }\n        } else {\n            // if there is no '.' then it is a whole number with no decimal part. So return true\n            true\n        }\n    }",
    "function_name": "get_invalid_percentage_error_message",
    "file": "crates__common_utils__src__types.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__bluesnap.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{BytesExt, StringExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RedirectForm,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSessionRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as bluesnap;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        construct_not_supported_error_report, convert_amount, convert_back_amount_to_minor_units,\n        get_error_code_error_message_based_on_priority, get_header_key_value, get_http_header,\n        handle_json_response_deserialization_failure, to_connector_meta_from_secret,\n        ConnectorErrorType, ConnectorErrorTypeMapping, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub const BLUESNAP_TRANSACTION_NOT_FOUND: &str = \"is not authorized to view merchant-transaction:\";\n\npub const REQUEST_TIMEOUT_PAYMENT_NOT_FOUND: &str = \"Timed out ,payment not found\";\n\n#[derive(Clone)]\npub struct Bluesnap {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n    amount_converter_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bluesnap {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor_unit: &StringMinorUnitForConnector,\n            amount_converter_float_major_unit: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bluesnap\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = self.get_auth_header(&req.connector_auth_type)?;\n        header.push((\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        ));\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bluesnap {\n    fn id(&self) -> &'static str {\n        \"bluesnap\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bluesnap.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bluesnap::BluesnapAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key =\n            BASE64_ENGINE.encode(format!(\"{}:{}\", auth.key1.peek(), auth.api_key.peek()));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),\n        )])",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__bluesnap.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{BytesExt, StringExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RedirectForm,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSessionRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as bluesnap;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        construct_not_supported_error_report, convert_amount, convert_back_amount_to_minor_units,\n        get_error_code_error_message_based_on_priority, get_header_key_value, get_http_header,\n        handle_json_response_deserialization_failure, to_connector_meta_from_secret,\n        ConnectorErrorType, ConnectorErrorTypeMapping, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub const BLUESNAP_TRANSACTION_NOT_FOUND: &str = \"is not authorized to view merchant-transaction:\";\n\npub const REQUEST_TIMEOUT_PAYMENT_NOT_FOUND: &str = \"Timed out ,payment not found\";\n\n#[derive(Clone)]\npub struct Bluesnap {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n    amount_converter_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bluesnap {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor_unit: &StringMinorUnitForConnector,\n            amount_converter_float_major_unit: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bluesnap\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = self.get_auth_header(&req.connector_auth_type)?;\n        header.push((\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        ));\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bluesnap {\n    fn id(&self) -> &'static str {\n        \"bluesnap\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bluesnap.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bluesnap::BluesnapAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key =\n            BASE64_ENGINE.encode(format!(\"{}:{}\", auth.key1.peek(), auth.api_key.peek()));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),\n        )])",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{BytesExt, StringExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RedirectForm,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSessionRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as bluesnap;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        construct_not_supported_error_report, convert_amount, convert_back_amount_to_minor_units,\n        get_error_code_error_message_based_on_priority, get_header_key_value, get_http_header,\n        handle_json_response_deserialization_failure, to_connector_meta_from_secret,\n        ConnectorErrorType, ConnectorErrorTypeMapping, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, RefundsRequestData, RouterData as _,\n    },\n};\n\npub const BLUESNAP_TRANSACTION_NOT_FOUND: &str = \"is not authorized to view merchant-transaction:\";\n\npub const REQUEST_TIMEOUT_PAYMENT_NOT_FOUND: &str = \"Timed out ,payment not found\";\n\n#[derive(Clone)]\npub struct Bluesnap {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n    amount_converter_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bluesnap {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor_unit: &StringMinorUnitForConnector,\n            amount_converter_float_major_unit: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bluesnap\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = self.get_auth_header(&req.connector_auth_type)?;\n        header.push((\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        ));\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bluesnap {\n    fn id(&self) -> &'static str {\n        \"bluesnap\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bluesnap.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bluesnap::BluesnapAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key =\n            BASE64_ENGINE.encode(format!(\"{}:{}\", auth.key1.peek(), auth.api_key.peek()));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),\n        )])",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bluesnap.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__paybox.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as paybox;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType, RouterData as _},\n};\n\n#[derive(Clone)]\npub struct Paybox {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Paybox {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paybox {}\nimpl api::PaymentSession for Paybox {}\nimpl api::ConnectorAccessToken for Paybox {}\nimpl api::MandateSetup for Paybox {}\nimpl api::PaymentAuthorize for Paybox {}\nimpl api::PaymentSync for Paybox {}\nimpl api::PaymentCapture for Paybox {}\nimpl api::PaymentVoid for Paybox {}\nimpl api::Refund for Paybox {}\nimpl api::RefundExecute for Paybox {}\nimpl api::RefundSync for Paybox {}\nimpl api::PaymentToken for Paybox {}\nimpl api::PaymentsCompleteAuthorize for Paybox {}\nimpl ConnectorIntegration<Void, PaymentsCancelData, PaymentsResponseData> for Paybox {\n    fn build_request(\n        &self,\n        _req: &PaymentsCancelRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"Cancel/Void flow\".to_string()).into())\n    }\n}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Paybox\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Paybox\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Paybox {\n    fn id(&self) -> &'static str {\n        \"paybox\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.paybox.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = paybox::PayboxAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.cle.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__paybox.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__paybox.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as paybox;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType, RouterData as _},\n};\n\n#[derive(Clone)]\npub struct Paybox {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Paybox {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paybox {}\nimpl api::PaymentSession for Paybox {}\nimpl api::ConnectorAccessToken for Paybox {}\nimpl api::MandateSetup for Paybox {}\nimpl api::PaymentAuthorize for Paybox {}\nimpl api::PaymentSync for Paybox {}\nimpl api::PaymentCapture for Paybox {}\nimpl api::PaymentVoid for Paybox {}\nimpl api::Refund for Paybox {}\nimpl api::RefundExecute for Paybox {}\nimpl api::RefundSync for Paybox {}\nimpl api::PaymentToken for Paybox {}\nimpl api::PaymentsCompleteAuthorize for Paybox {}\nimpl ConnectorIntegration<Void, PaymentsCancelData, PaymentsResponseData> for Paybox {\n    fn build_request(\n        &self,\n        _req: &PaymentsCancelRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"Cancel/Void flow\".to_string()).into())\n    }\n}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Paybox\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Paybox\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Paybox {\n    fn id(&self) -> &'static str {\n        \"paybox\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.paybox.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = paybox::PayboxAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.cle.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__paybox.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as paybox;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType, RouterData as _},\n};\n\n#[derive(Clone)]\npub struct Paybox {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Paybox {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Paybox {}\nimpl api::PaymentSession for Paybox {}\nimpl api::ConnectorAccessToken for Paybox {}\nimpl api::MandateSetup for Paybox {}\nimpl api::PaymentAuthorize for Paybox {}\nimpl api::PaymentSync for Paybox {}\nimpl api::PaymentCapture for Paybox {}\nimpl api::PaymentVoid for Paybox {}\nimpl api::Refund for Paybox {}\nimpl api::RefundExecute for Paybox {}\nimpl api::RefundSync for Paybox {}\nimpl api::PaymentToken for Paybox {}\nimpl api::PaymentsCompleteAuthorize for Paybox {}\nimpl ConnectorIntegration<Void, PaymentsCancelData, PaymentsResponseData> for Paybox {\n    fn build_request(\n        &self,\n        _req: &PaymentsCancelRouterData,\n        _connectors: &Connectors,\n    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n        Err(errors::ConnectorError::NotImplemented(\"Cancel/Void flow\".to_string()).into())\n    }\n}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Paybox\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Paybox\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Paybox {\n    fn id(&self) -> &'static str {\n        \"paybox\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.paybox.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = paybox::PayboxAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.cle.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__paybox.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n    ForeignIDRef,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    mandates::{MandateDataType, MandateDetails},\n    router_request_types,\n};\n\n#[async_trait::async_trait]\npub trait PaymentAttemptInterface {\n    type Error;\n    #[cfg(feature = \"v1\")]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn insert_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn update_payment_attempt_with_attempt_id(\n        &self,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn update_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_by_connector_transaction_id_payment_id_processor_merchant_id(\n        &self,\n        connector_transaction_id: &ConnectorTransactionId,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_id: &id_type::GlobalPaymentId,\n        storage_scheme: storage_enums::MerchantStorageScheme,",
    "function_name": "insert_payment_attempt",
    "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n    ForeignIDRef,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    mandates::{MandateDataType, MandateDetails},\n    router_request_types,\n};\n\n#[async_trait::async_trait]\npub trait PaymentAttemptInterface {\n    type Error;\n    #[cfg(feature = \"v1\")]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn insert_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn update_payment_attempt_with_attempt_id(\n        &self,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn update_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_by_connector_transaction_id_payment_id_processor_merchant_id(\n        &self,\n        connector_transaction_id: &ConnectorTransactionId,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_id: &id_type::GlobalPaymentId,\n        storage_scheme: storage_enums::MerchantStorageScheme,",
    "function_name": "insert_payment_attempt",
    "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for insert_payment_attempt",
    "code": "#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse api_models::enums::Connector;\n#[cfg(feature = \"v2\")]\nuse api_models::payments::{additional_info::UpiAdditionalData, AdditionalPaymentData};\nuse common_enums as storage_enums;\n#[cfg(feature = \"v2\")]\nuse common_types::payments as common_payments_types;\n#[cfg(feature = \"v1\")]\nuse common_types::primitive_wrappers::{\n    ExtendedAuthorizationAppliedBool, OvercaptureEnabledBool, RequestExtendedAuthorizationBool,\n};\n#[cfg(feature = \"v2\")]\nuse common_utils::ext_traits::Encode;\nuse common_utils::{\n    crypto::Encryptable,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        ConnectorTransactionId, ConnectorTransactionIdTrait, CreatedBy, MinorUnit,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse diesel_models::{\n    ConnectorMandateReferenceId, ErrorDetails as DieselErrorDetails, NetworkDetails,\n    PaymentAttemptUpdate as DieselPaymentAttemptUpdate,\n};\nuse diesel_models::{\n    PaymentAttempt as DieselPaymentAttempt, PaymentAttemptNew as DieselPaymentAttemptNew,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::{\n    PaymentAttemptFeatureMetadata as DieselPaymentAttemptFeatureMetadata,\n    PaymentAttemptRecoveryData as DieselPassiveChurnRecoveryData,\n};\nuse error_stack::ResultExt;\n#[cfg(feature = \"v2\")]\nuse masking::ExposeInterface;\nuse masking::{PeekInterface, Secret};\n#[cfg(feature = \"v1\")]\nuse router_env::logger;\nuse rustc_hash::FxHashMap;\n#[cfg(feature = \"v1\")]\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Value;\nuse time::PrimitiveDateTime;\nuse url::Url;\n\n#[cfg(all(feature = \"v1\", feature = \"olap\"))]\nuse super::PaymentIntent;\n#[cfg(feature = \"v2\")]\nuse crate::{\n    address::Address, consts, payment_method_data::PaymentMethodData, router_response_types,\n};\nuse crate::{\n    behaviour, errors,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, CryptoOperation},\n    ForeignIDRef,\n};\n#[cfg(feature = \"v1\")]\nuse crate::{\n    mandates::{MandateDataType, MandateDetails},\n    router_request_types,\n};\n\n#[async_trait::async_trait]\npub trait PaymentAttemptInterface {\n    type Error;\n    #[cfg(feature = \"v1\")]\n    async fn insert_payment_attempt(\n        &self,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn insert_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_attempt: PaymentAttempt,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn update_payment_attempt_with_attempt_id(\n        &self,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn update_payment_attempt(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        this: PaymentAttempt,\n        payment_attempt: PaymentAttemptUpdate,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_by_connector_transaction_id_payment_id_processor_merchant_id(\n        &self,\n        connector_transaction_id: &ConnectorTransactionId,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v1\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id_processor_merchant_id(\n        &self,\n        payment_id: &id_type::PaymentId,\n        processor_merchant_id: &id_type::MerchantId,\n        storage_scheme: storage_enums::MerchantStorageScheme,\n        merchant_key_store: &MerchantKeyStore,\n    ) -> error_stack::Result<PaymentAttempt, Self::Error>;\n\n    #[cfg(feature = \"v2\")]\n    async fn find_payment_attempt_last_successful_or_partially_captured_attempt_by_payment_id(\n        &self,\n        merchant_key_store: &MerchantKeyStore,\n        payment_id: &id_type::GlobalPaymentId,\n        storage_scheme: storage_enums::MerchantStorageScheme,",
    "function_name": "insert_payment_attempt",
    "file": "crates__hyperswitch_domain_models__src__payments__payment_attempt.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payme__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::enums::{AuthenticationType, PaymentMethod};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    pii,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::{Execute, Void},\n    router_request_types::{\n        CreateOrderRequestData, PaymentsCancelData, PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, PreprocessingResponseId, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsCancelResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSyncRequestData, RouterData as OtherRouterData,\n    },\n};\n\nconst LANGUAGE: &str = \"en\";\n\n#[derive(Debug, Serialize)]\npub struct PaymeRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PaymeRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PaymePaymentRequest {\n    MandateRequest(MandateRequest),\n    PayRequest(PayRequest),\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeQuerySaleRequest {\n    sale_payme_id: String,\n    seller_payme_id: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeQueryTransactionRequest {\n    payme_transaction_id: String,\n    seller_payme_id: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeCard {\n    credit_card_cvv: Secret<String>,\n    credit_card_exp: Secret<String>,\n    credit_card_number: cards::CardNumber,\n}\n\n#[derive(Debug, Serialize)]\npub struct CaptureBuyerRequest {\n    seller_payme_id: Secret<String>,\n    #[serde(flatten)]\n    card: PaymeCard,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct CaptureBuyerResponse {\n    buyer_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payme__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::enums::{AuthenticationType, PaymentMethod};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    pii,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::{Execute, Void},\n    router_request_types::{\n        CreateOrderRequestData, PaymentsCancelData, PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, PreprocessingResponseId, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsCancelResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSyncRequestData, RouterData as OtherRouterData,\n    },\n};\n\nconst LANGUAGE: &str = \"en\";\n\n#[derive(Debug, Serialize)]\npub struct PaymeRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PaymeRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PaymePaymentRequest {\n    MandateRequest(MandateRequest),\n    PayRequest(PayRequest),\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeQuerySaleRequest {\n    sale_payme_id: String,\n    seller_payme_id: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeQueryTransactionRequest {\n    payme_transaction_id: String,\n    seller_payme_id: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeCard {\n    credit_card_cvv: Secret<String>,\n    credit_card_exp: Secret<String>,\n    credit_card_number: cards::CardNumber,\n}\n\n#[derive(Debug, Serialize)]\npub struct CaptureBuyerRequest {\n    seller_payme_id: Secret<String>,\n    #[serde(flatten)]\n    card: PaymeCard,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct CaptureBuyerResponse {\n    buyer_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use std::collections::HashMap;\n\nuse api_models::enums::{AuthenticationType, PaymentMethod};\nuse common_enums::enums;\nuse common_utils::{\n    ext_traits::OptionExt,\n    pii,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_flow_types::{Execute, Void},\n    router_request_types::{\n        CreateOrderRequestData, PaymentsCancelData, PaymentsPreProcessingData, ResponseId,\n    },\n    router_response_types::{\n        MandateReference, PaymentsResponseData, PreprocessingResponseId, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        CreateOrderRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{PaymentsCancelResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsCancelRequestData, PaymentsCompleteAuthorizeRequestData,\n        PaymentsPreProcessingRequestData, PaymentsSyncRequestData, RouterData as OtherRouterData,\n    },\n};\n\nconst LANGUAGE: &str = \"en\";\n\n#[derive(Debug, Serialize)]\npub struct PaymeRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(MinorUnit, T)> for PaymeRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (MinorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct PayRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    payme_sale_id: String,\n    #[serde(flatten)]\n    card: PaymeCard,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct MandateRequest {\n    currency: enums::Currency,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,\n    sale_callback_url: String,\n    buyer_key: Secret<String>,\n    language: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct Pay3dsRequest {\n    buyer_name: Secret<String>,\n    buyer_email: pii::Email,\n    buyer_key: Secret<String>,\n    payme_sale_id: String,\n    meta_data_jwt: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PaymePaymentRequest {\n    MandateRequest(MandateRequest),\n    PayRequest(PayRequest),\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeQuerySaleRequest {\n    sale_payme_id: String,\n    seller_payme_id: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeQueryTransactionRequest {\n    payme_transaction_id: String,\n    seller_payme_id: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymeCard {\n    credit_card_cvv: Secret<String>,\n    credit_card_exp: Secret<String>,\n    credit_card_number: cards::CardNumber,\n}\n\n#[derive(Debug, Serialize)]\npub struct CaptureBuyerRequest {\n    seller_payme_id: Secret<String>,\n    #[serde(flatten)]\n    card: PaymeCard,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct CaptureBuyerResponse {\n    buyer_key: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct GenerateSaleRequest {\n    currency: enums::Currency,\n    sale_type: SaleType,\n    sale_price: MinorUnit,\n    transaction_id: String,\n    product_name: String,\n    sale_return_url: String,\n    seller_payme_id: Secret<String>,",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__payme__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__airwallex.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        CreateOrderRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, CreateOrderType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as airwallex;\n\nuse crate::{\n    connectors::airwallex::transformers::AirwallexAuthorizeResponse,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{\n        self as connector_utils, convert_amount, AccessTokenRequestInfo, ForeignTryFrom,\n        PaymentMethodDataType, PaymentsAuthorizeRequestData, RefundsRequestData,\n    },\n};\n\n#[derive(Clone)]\npub struct Airwallex {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_string_minor:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Airwallex {\n    fn id(&self) -> &'static str {\n        \"airwallex\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.airwallex.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__airwallex.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__airwallex.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        CreateOrderRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, CreateOrderType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as airwallex;\n\nuse crate::{\n    connectors::airwallex::transformers::AirwallexAuthorizeResponse,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{\n        self as connector_utils, convert_amount, AccessTokenRequestInfo, ForeignTryFrom,\n        PaymentMethodDataType, PaymentsAuthorizeRequestData, RefundsRequestData,\n    },\n};\n\n#[derive(Clone)]\npub struct Airwallex {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_string_minor:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Airwallex {\n    fn id(&self) -> &'static str {\n        \"airwallex\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.airwallex.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__airwallex.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateOrder, PSync, PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        CreateOrderRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, CreateOrderRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes::DisputePayload,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, ConnectorCustomerType, CreateOrderType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse router_env::logger;\nuse transformers as airwallex;\n\nuse crate::{\n    connectors::airwallex::transformers::AirwallexAuthorizeResponse,\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{\n        self as connector_utils, convert_amount, AccessTokenRequestInfo, ForeignTryFrom,\n        PaymentMethodDataType, PaymentsAuthorizeRequestData, RefundsRequestData,\n    },\n};\n\n#[derive(Clone)]\npub struct Airwallex {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_to_string_minor:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Airwallex {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n            amount_converter_to_string_minor: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Airwallex\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let auth_header = (\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", access_token.token.peek()).into_masked(),\n        );\n\n        headers.push(auth_header);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Airwallex {\n    fn id(&self) -> &'static str {\n        \"airwallex\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.airwallex.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        logger::debug!(payu_error_response=?res);\n\n        let status_code = res.status_code;\n        let response: Result<airwallex::AirwallexErrorResponse, _> =",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__airwallex.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs",
    "code": "use bytes::Bytes;\nuse common_enums::enums;\nuse common_utils::{\n    date_time::DateFormat, errors::CustomResult, ext_traits::ValueExt, types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, CardMandateInfo, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\npub struct PayboxRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayboxRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst AUTH_REQUEST: &str = \"00001\";\nconst CAPTURE_REQUEST: &str = \"00002\";\nconst AUTH_AND_CAPTURE_REQUEST: &str = \"00003\";\nconst SYNC_REQUEST: &str = \"00017\";\nconst REFUND_REQUEST: &str = \"00014\";\nconst SUCCESS_CODE: &str = \"00000\";\nconst VERSION_PAYBOX: &str = \"00104\";\nconst PAY_ORIGIN_INTERNET: &str = \"024\";\nconst THREE_DS_FAIL_CODE: &str = \"00000000\";\nconst RECURRING_ORIGIN: &str = \"027\";\nconst MANDATE_REQUEST: &str = \"00056\";\nconst MANDATE_AUTH_ONLY: &str = \"00051\";\nconst MANDATE_AUTH_AND_CAPTURE_ONLY: &str = \"00053\";\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PayboxPaymentsRequest {\n    Card(PaymentsRequest),\n    CardThreeDs(ThreeDSPaymentsRequest),\n    Mandate(MandatePaymentRequest),\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymentsRequest {\n    #[serde(rename = \"DATEQ\")]\n    pub date: String,\n\n    #[serde(rename = \"TYPE\")]\n    pub transaction_type: String,\n\n    #[serde(rename = \"NUMQUESTION\")]\n    pub paybox_request_number: String,\n\n    #[serde(rename = \"MONTANT\")]\n    pub amount: MinorUnit,\n\n    #[serde(rename = \"REFERENCE\")]\n    pub description_reference: String,\n\n    #[serde(rename = \"VERSION\")]\n    pub version: String,\n\n    #[serde(rename = \"DEVISE\")]\n    pub currency: String,\n\n    #[serde(rename = \"PORTEUR\")]\n    pub card_number: cards::CardNumber,\n\n    #[serde(rename = \"DATEVAL\")]\n    pub expiration_date: Secret<String>,\n\n    #[serde(rename = \"CVV\")]\n    pub cvv: Secret<String>,\n\n    #[serde(rename = \"ACTIVITE\")]\n    pub activity: String,\n\n    #[serde(rename = \"SITE\")]\n    pub site: Secret<String>,\n\n    #[serde(rename = \"RANG\")]\n    pub rank: Secret<String>,\n\n    #[serde(rename = \"CLE\")]\n    pub key: Secret<String>,\n\n    #[serde(rename = \"ID3D\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub three_ds_data: Option<Secret<String>>,\n\n    #[serde(rename = \"REFABONNE\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub customer_id: Option<Secret<String>>,\n}\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"PascalCase\")]\npub struct ThreeDSPaymentsRequest {\n    id_merchant: Secret<String>,\n    id_session: String,\n    amount: MinorUnit,\n    currency: String,\n    #[serde(rename = \"CCNumber\")]\n    cc_number: cards::CardNumber,\n    #[serde(rename = \"CCExpDate\")]\n    cc_exp_date: Secret<String>,\n    #[serde(rename = \"CVVCode\")]\n    cvv_code: Secret<String>,\n    #[serde(rename = \"URLRetour\")]\n    url_retour: String,\n    #[serde(rename = \"URLHttpDirect\")]\n    url_http_direct: String,\n    email_porteur: common_utils::pii::Email,\n    first_name: Secret<String>,\n    last_name: Secret<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs",
    "code": "use bytes::Bytes;\nuse common_enums::enums;\nuse common_utils::{\n    date_time::DateFormat, errors::CustomResult, ext_traits::ValueExt, types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, CardMandateInfo, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\npub struct PayboxRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayboxRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst AUTH_REQUEST: &str = \"00001\";\nconst CAPTURE_REQUEST: &str = \"00002\";\nconst AUTH_AND_CAPTURE_REQUEST: &str = \"00003\";\nconst SYNC_REQUEST: &str = \"00017\";\nconst REFUND_REQUEST: &str = \"00014\";\nconst SUCCESS_CODE: &str = \"00000\";\nconst VERSION_PAYBOX: &str = \"00104\";\nconst PAY_ORIGIN_INTERNET: &str = \"024\";\nconst THREE_DS_FAIL_CODE: &str = \"00000000\";\nconst RECURRING_ORIGIN: &str = \"027\";\nconst MANDATE_REQUEST: &str = \"00056\";\nconst MANDATE_AUTH_ONLY: &str = \"00051\";\nconst MANDATE_AUTH_AND_CAPTURE_ONLY: &str = \"00053\";\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PayboxPaymentsRequest {\n    Card(PaymentsRequest),\n    CardThreeDs(ThreeDSPaymentsRequest),\n    Mandate(MandatePaymentRequest),\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymentsRequest {\n    #[serde(rename = \"DATEQ\")]\n    pub date: String,\n\n    #[serde(rename = \"TYPE\")]\n    pub transaction_type: String,\n\n    #[serde(rename = \"NUMQUESTION\")]\n    pub paybox_request_number: String,\n\n    #[serde(rename = \"MONTANT\")]\n    pub amount: MinorUnit,\n\n    #[serde(rename = \"REFERENCE\")]\n    pub description_reference: String,\n\n    #[serde(rename = \"VERSION\")]\n    pub version: String,\n\n    #[serde(rename = \"DEVISE\")]\n    pub currency: String,\n\n    #[serde(rename = \"PORTEUR\")]\n    pub card_number: cards::CardNumber,\n\n    #[serde(rename = \"DATEVAL\")]\n    pub expiration_date: Secret<String>,\n\n    #[serde(rename = \"CVV\")]\n    pub cvv: Secret<String>,\n\n    #[serde(rename = \"ACTIVITE\")]\n    pub activity: String,\n\n    #[serde(rename = \"SITE\")]\n    pub site: Secret<String>,\n\n    #[serde(rename = \"RANG\")]\n    pub rank: Secret<String>,\n\n    #[serde(rename = \"CLE\")]\n    pub key: Secret<String>,\n\n    #[serde(rename = \"ID3D\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub three_ds_data: Option<Secret<String>>,\n\n    #[serde(rename = \"REFABONNE\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub customer_id: Option<Secret<String>>,\n}\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"PascalCase\")]\npub struct ThreeDSPaymentsRequest {\n    id_merchant: Secret<String>,\n    id_session: String,\n    amount: MinorUnit,\n    currency: String,\n    #[serde(rename = \"CCNumber\")]\n    cc_number: cards::CardNumber,\n    #[serde(rename = \"CCExpDate\")]\n    cc_exp_date: Secret<String>,\n    #[serde(rename = \"CVVCode\")]\n    cvv_code: Secret<String>,\n    #[serde(rename = \"URLRetour\")]\n    url_retour: String,\n    #[serde(rename = \"URLHttpDirect\")]\n    url_http_direct: String,\n    email_porteur: common_utils::pii::Email,\n    first_name: Secret<String>,\n    last_name: Secret<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use bytes::Bytes;\nuse common_enums::enums;\nuse common_utils::{\n    date_time::DateFormat, errors::CustomResult, ext_traits::ValueExt, types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{CompleteAuthorizeData, PaymentsAuthorizeData, ResponseId},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, AddressDetailsData, CardData as _, CardMandateInfo, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, RouterData as _,\n    },\n};\npub struct PayboxRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayboxRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nconst AUTH_REQUEST: &str = \"00001\";\nconst CAPTURE_REQUEST: &str = \"00002\";\nconst AUTH_AND_CAPTURE_REQUEST: &str = \"00003\";\nconst SYNC_REQUEST: &str = \"00017\";\nconst REFUND_REQUEST: &str = \"00014\";\nconst SUCCESS_CODE: &str = \"00000\";\nconst VERSION_PAYBOX: &str = \"00104\";\nconst PAY_ORIGIN_INTERNET: &str = \"024\";\nconst THREE_DS_FAIL_CODE: &str = \"00000000\";\nconst RECURRING_ORIGIN: &str = \"027\";\nconst MANDATE_REQUEST: &str = \"00056\";\nconst MANDATE_AUTH_ONLY: &str = \"00051\";\nconst MANDATE_AUTH_AND_CAPTURE_ONLY: &str = \"00053\";\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\n#[serde(untagged)]\npub enum PayboxPaymentsRequest {\n    Card(PaymentsRequest),\n    CardThreeDs(ThreeDSPaymentsRequest),\n    Mandate(MandatePaymentRequest),\n}\n\n#[derive(Debug, Serialize)]\npub struct PaymentsRequest {\n    #[serde(rename = \"DATEQ\")]\n    pub date: String,\n\n    #[serde(rename = \"TYPE\")]\n    pub transaction_type: String,\n\n    #[serde(rename = \"NUMQUESTION\")]\n    pub paybox_request_number: String,\n\n    #[serde(rename = \"MONTANT\")]\n    pub amount: MinorUnit,\n\n    #[serde(rename = \"REFERENCE\")]\n    pub description_reference: String,\n\n    #[serde(rename = \"VERSION\")]\n    pub version: String,\n\n    #[serde(rename = \"DEVISE\")]\n    pub currency: String,\n\n    #[serde(rename = \"PORTEUR\")]\n    pub card_number: cards::CardNumber,\n\n    #[serde(rename = \"DATEVAL\")]\n    pub expiration_date: Secret<String>,\n\n    #[serde(rename = \"CVV\")]\n    pub cvv: Secret<String>,\n\n    #[serde(rename = \"ACTIVITE\")]\n    pub activity: String,\n\n    #[serde(rename = \"SITE\")]\n    pub site: Secret<String>,\n\n    #[serde(rename = \"RANG\")]\n    pub rank: Secret<String>,\n\n    #[serde(rename = \"CLE\")]\n    pub key: Secret<String>,\n\n    #[serde(rename = \"ID3D\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub three_ds_data: Option<Secret<String>>,\n\n    #[serde(rename = \"REFABONNE\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub customer_id: Option<Secret<String>>,\n}\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"PascalCase\")]\npub struct ThreeDSPaymentsRequest {\n    id_merchant: Secret<String>,\n    id_session: String,\n    amount: MinorUnit,\n    currency: String,\n    #[serde(rename = \"CCNumber\")]\n    cc_number: cards::CardNumber,\n    #[serde(rename = \"CCExpDate\")]\n    cc_exp_date: Secret<String>,\n    #[serde(rename = \"CVVCode\")]\n    cvv_code: Secret<String>,\n    #[serde(rename = \"URLRetour\")]\n    url_retour: String,\n    #[serde(rename = \"URLHttpDirect\")]\n    url_http_direct: String,\n    email_porteur: common_utils::pii::Email,\n    first_name: Secret<String>,\n    last_name: Secret<String>,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__paybox__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__stax.rs",
    "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as stax;\n\nuse self::stax::StaxWebhookEventType;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n#[derive(Debug, Clone)]\npub struct Stax;\n\nimpl api::Payment for Stax {}\nimpl api::PaymentSession for Stax {}\nimpl api::ConnectorAccessToken for Stax {}\nimpl api::MandateSetup for Stax {}\nimpl api::PaymentAuthorize for Stax {}\nimpl api::PaymentSync for Stax {}\nimpl api::PaymentCapture for Stax {}\nimpl api::PaymentVoid for Stax {}\nimpl api::Refund for Stax {}\nimpl api::RefundExecute for Stax {}\nimpl api::RefundSync for Stax {}\nimpl api::PaymentToken for Stax {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Stax\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            types::PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Stax {\n    fn id(&self) -> &'static str {\n        \"stax\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.stax.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = stax::StaxAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        _event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: Some(\n                std::str::from_utf8(&res.response)\n                    .change_context(errors::ConnectorError::ResponseDeserializationFailed)?\n                    .to_owned(),\n            ),\n            attempt_status: None,\n            connector_transaction_id: None,",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__stax.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__stax.rs",
    "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as stax;\n\nuse self::stax::StaxWebhookEventType;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n#[derive(Debug, Clone)]\npub struct Stax;\n\nimpl api::Payment for Stax {}\nimpl api::PaymentSession for Stax {}\nimpl api::ConnectorAccessToken for Stax {}\nimpl api::MandateSetup for Stax {}\nimpl api::PaymentAuthorize for Stax {}\nimpl api::PaymentSync for Stax {}\nimpl api::PaymentCapture for Stax {}\nimpl api::PaymentVoid for Stax {}\nimpl api::Refund for Stax {}\nimpl api::RefundExecute for Stax {}\nimpl api::RefundSync for Stax {}\nimpl api::PaymentToken for Stax {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Stax\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            types::PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Stax {\n    fn id(&self) -> &'static str {\n        \"stax\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.stax.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = stax::StaxAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        _event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: Some(\n                std::str::from_utf8(&res.response)\n                    .change_context(errors::ConnectorError::ResponseDeserializationFailed)?\n                    .to_owned(),\n            ),\n            attempt_status: None,\n            connector_transaction_id: None,",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__stax.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\n\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CreateConnectorCustomer, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers as stax;\n\nuse self::stax::StaxWebhookEventType;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n#[derive(Debug, Clone)]\npub struct Stax;\n\nimpl api::Payment for Stax {}\nimpl api::PaymentSession for Stax {}\nimpl api::ConnectorAccessToken for Stax {}\nimpl api::MandateSetup for Stax {}\nimpl api::PaymentAuthorize for Stax {}\nimpl api::PaymentSync for Stax {}\nimpl api::PaymentCapture for Stax {}\nimpl api::PaymentVoid for Stax {}\nimpl api::Refund for Stax {}\nimpl api::RefundExecute for Stax {}\nimpl api::RefundSync for Stax {}\nimpl api::PaymentToken for Stax {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Stax\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            types::PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Stax {\n    fn id(&self) -> &'static str {\n        \"stax\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.stax.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = stax::StaxAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        _event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: consts::NO_ERROR_MESSAGE.to_string(),\n            reason: Some(\n                std::str::from_utf8(&res.response)\n                    .change_context(errors::ConnectorError::ResponseDeserializationFailed)?\n                    .to_owned(),\n            ),\n            attempt_status: None,\n            connector_transaction_id: None,",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__stax.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__types__payment_methods.rs",
    "code": "use std::fmt::Debug;\n\nuse api_models::enums as api_enums;\nuse cards::{CardNumber, NetworkToken};\n#[cfg(feature = \"v2\")]\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v2\")]\nuse common_utils::generate_id;\nuse common_utils::id_type;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data::NetworkTokenDetails;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"v2\")]\nuse crate::types::storage;\nuse crate::{\n    consts,\n    types::{api, domain},\n};\n\npub trait VaultingInterface {\n    fn get_vaulting_request_url() -> &'static str;\n\n    fn get_vaulting_flow_name() -> &'static str;\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultFingerprintRequest {\n    pub data: String,\n    pub key: String,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultFingerprintResponse {\n    pub fingerprint_id: String,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultRequest<D> {\n    pub entity_id: hyperswitch_domain_models::vault::V1VaultEntityId,\n    pub vault_id: domain::VaultId,\n    pub data: D,\n    pub ttl: i64,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultRequest<D> {\n    pub entity_id: id_type::GlobalCustomerId,\n    pub vault_id: domain::VaultId,\n    pub data: D,\n    pub ttl: i64,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultResponse {\n    #[cfg(feature = \"v2\")]\n    pub entity_id: Option<id_type::GlobalCustomerId>,\n    #[cfg(feature = \"v1\")]\n    pub entity_id: Option<id_type::CustomerId>,\n    #[cfg(feature = \"v2\")]\n    pub vault_id: domain::VaultId,\n    #[cfg(feature = \"v1\")]\n    pub vault_id: hyperswitch_domain_models::router_response_types::VaultIdType,\n    pub fingerprint_id: Option<String>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct InternalAddVaultResponse {\n    pub entity_id: Option<hyperswitch_domain_models::vault::V1VaultEntityId>,\n    pub vault_id: domain::VaultId,\n    pub fingerprint_id: Option<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVault;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct GetVaultFingerprint;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultRetrieve;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultDelete;\n\nimpl VaultingInterface for AddVault {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_ADD_VAULT_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_ADD_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for GetVaultFingerprint {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_FINGERPRINT_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_GET_FINGERPRINT_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for VaultRetrieve {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_RETRIEVE_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_RETRIEVE_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for VaultDelete {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_DELETE_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_DELETE_FLOW_TYPE\n    }\n}\n\n#[cfg(feature = \"v2\")]\npub struct SavedPMLPaymentsInfo {\n    pub payment_intent: storage::PaymentIntent,\n    pub profile: domain::Profile,\n    pub collect_cvv_during_payment: Option<primitive_wrappers::ShouldCollectCvvDuringPayment>,\n    pub off_session_payment_flag: bool,\n    pub is_connector_agnostic_mit_enabled: bool,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]",
    "function_name": "get_vaulting_request_url",
    "file": "crates__router__src__types__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__types__payment_methods.rs",
    "code": "use std::fmt::Debug;\n\nuse api_models::enums as api_enums;\nuse cards::{CardNumber, NetworkToken};\n#[cfg(feature = \"v2\")]\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v2\")]\nuse common_utils::generate_id;\nuse common_utils::id_type;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data::NetworkTokenDetails;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"v2\")]\nuse crate::types::storage;\nuse crate::{\n    consts,\n    types::{api, domain},\n};\n\npub trait VaultingInterface {\n    fn get_vaulting_request_url() -> &'static str;\n\n    fn get_vaulting_flow_name() -> &'static str;\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultFingerprintRequest {\n    pub data: String,\n    pub key: String,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultFingerprintResponse {\n    pub fingerprint_id: String,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultRequest<D> {\n    pub entity_id: hyperswitch_domain_models::vault::V1VaultEntityId,\n    pub vault_id: domain::VaultId,\n    pub data: D,\n    pub ttl: i64,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultRequest<D> {\n    pub entity_id: id_type::GlobalCustomerId,\n    pub vault_id: domain::VaultId,\n    pub data: D,\n    pub ttl: i64,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultResponse {\n    #[cfg(feature = \"v2\")]\n    pub entity_id: Option<id_type::GlobalCustomerId>,\n    #[cfg(feature = \"v1\")]\n    pub entity_id: Option<id_type::CustomerId>,\n    #[cfg(feature = \"v2\")]\n    pub vault_id: domain::VaultId,\n    #[cfg(feature = \"v1\")]\n    pub vault_id: hyperswitch_domain_models::router_response_types::VaultIdType,\n    pub fingerprint_id: Option<String>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct InternalAddVaultResponse {\n    pub entity_id: Option<hyperswitch_domain_models::vault::V1VaultEntityId>,\n    pub vault_id: domain::VaultId,\n    pub fingerprint_id: Option<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVault;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct GetVaultFingerprint;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultRetrieve;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultDelete;\n\nimpl VaultingInterface for AddVault {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_ADD_VAULT_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_ADD_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for GetVaultFingerprint {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_FINGERPRINT_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_GET_FINGERPRINT_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for VaultRetrieve {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_RETRIEVE_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_RETRIEVE_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for VaultDelete {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_DELETE_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_DELETE_FLOW_TYPE\n    }\n}\n\n#[cfg(feature = \"v2\")]\npub struct SavedPMLPaymentsInfo {\n    pub payment_intent: storage::PaymentIntent,\n    pub profile: domain::Profile,\n    pub collect_cvv_during_payment: Option<primitive_wrappers::ShouldCollectCvvDuringPayment>,\n    pub off_session_payment_flag: bool,\n    pub is_connector_agnostic_mit_enabled: bool,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]",
    "function_name": "get_vaulting_request_url",
    "file": "crates__router__src__types__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_vaulting_request_url",
    "code": "use std::fmt::Debug;\n\nuse api_models::enums as api_enums;\nuse cards::{CardNumber, NetworkToken};\n#[cfg(feature = \"v2\")]\nuse common_types::primitive_wrappers;\n#[cfg(feature = \"v2\")]\nuse common_utils::generate_id;\nuse common_utils::id_type;\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payment_method_data::NetworkTokenDetails;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"v2\")]\nuse crate::types::storage;\nuse crate::{\n    consts,\n    types::{api, domain},\n};\n\npub trait VaultingInterface {\n    fn get_vaulting_request_url() -> &'static str;\n\n    fn get_vaulting_flow_name() -> &'static str;\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultFingerprintRequest {\n    pub data: String,\n    pub key: String,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultFingerprintResponse {\n    pub fingerprint_id: String,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultRequest<D> {\n    pub entity_id: hyperswitch_domain_models::vault::V1VaultEntityId,\n    pub vault_id: domain::VaultId,\n    pub data: D,\n    pub ttl: i64,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultRequest<D> {\n    pub entity_id: id_type::GlobalCustomerId,\n    pub vault_id: domain::VaultId,\n    pub data: D,\n    pub ttl: i64,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVaultResponse {\n    #[cfg(feature = \"v2\")]\n    pub entity_id: Option<id_type::GlobalCustomerId>,\n    #[cfg(feature = \"v1\")]\n    pub entity_id: Option<id_type::CustomerId>,\n    #[cfg(feature = \"v2\")]\n    pub vault_id: domain::VaultId,\n    #[cfg(feature = \"v1\")]\n    pub vault_id: hyperswitch_domain_models::router_response_types::VaultIdType,\n    pub fingerprint_id: Option<String>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct InternalAddVaultResponse {\n    pub entity_id: Option<hyperswitch_domain_models::vault::V1VaultEntityId>,\n    pub vault_id: domain::VaultId,\n    pub fingerprint_id: Option<String>,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct AddVault;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct GetVaultFingerprint;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultRetrieve;\n\n#[derive(Debug, serde::Deserialize, serde::Serialize)]\npub struct VaultDelete;\n\nimpl VaultingInterface for AddVault {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_ADD_VAULT_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_ADD_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for GetVaultFingerprint {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_FINGERPRINT_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_GET_FINGERPRINT_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for VaultRetrieve {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_RETRIEVE_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_RETRIEVE_FLOW_TYPE\n    }\n}\n\nimpl VaultingInterface for VaultDelete {\n    fn get_vaulting_request_url() -> &'static str {\n        consts::V2_VAULT_DELETE_REQUEST_URL\n    }\n\n    fn get_vaulting_flow_name() -> &'static str {\n        consts::V2_VAULT_DELETE_FLOW_TYPE\n    }\n}\n\n#[cfg(feature = \"v2\")]\npub struct SavedPMLPaymentsInfo {\n    pub payment_intent: storage::PaymentIntent,\n    pub profile: domain::Profile,\n    pub collect_cvv_during_payment: Option<primitive_wrappers::ShouldCollectCvvDuringPayment>,\n    pub off_session_payment_flag: bool,\n    pub is_connector_agnostic_mit_enabled: bool,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize)]",
    "function_name": "get_vaulting_request_url",
    "file": "crates__router__src__types__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__zen.rs",
    "code": "pub mod transformers;\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers::{self as zen, ZenPaymentStatus, ZenWebhookTxnType};\nuse uuid::Uuid;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Zen;\n\nimpl api::Payment for Zen {}\nimpl api::PaymentSession for Zen {}\nimpl api::ConnectorAccessToken for Zen {}\nimpl api::MandateSetup for Zen {}\nimpl api::PaymentAuthorize for Zen {}\nimpl api::PaymentSync for Zen {}\nimpl api::PaymentCapture for Zen {}\nimpl api::PaymentVoid for Zen {}\nimpl api::PaymentToken for Zen {}\nimpl api::Refund for Zen {}\nimpl api::RefundExecute for Zen {}\nimpl api::RefundSync for Zen {}\n\nimpl Zen {\n    fn get_default_header() -> (String, masking::Maskable<String>) {\n        (\"request-id\".to_string(), Uuid::new_v4().to_string().into())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Zen\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut auth_header);\n\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Zen {\n    fn id(&self) -> &'static str {\n        \"zen\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        mime::APPLICATION_JSON.essence_str()\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.zen.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = zen::ZenAuthType::try_from(auth_type)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: zen::ZenErrorResponse = res\n            .response\n            .parse_struct(\"Zen ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {",
    "function_name": "get_default_header",
    "file": "crates__hyperswitch_connectors__src__connectors__zen.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__zen.rs",
    "code": "pub mod transformers;\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers::{self as zen, ZenPaymentStatus, ZenWebhookTxnType};\nuse uuid::Uuid;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Zen;\n\nimpl api::Payment for Zen {}\nimpl api::PaymentSession for Zen {}\nimpl api::ConnectorAccessToken for Zen {}\nimpl api::MandateSetup for Zen {}\nimpl api::PaymentAuthorize for Zen {}\nimpl api::PaymentSync for Zen {}\nimpl api::PaymentCapture for Zen {}\nimpl api::PaymentVoid for Zen {}\nimpl api::PaymentToken for Zen {}\nimpl api::Refund for Zen {}\nimpl api::RefundExecute for Zen {}\nimpl api::RefundSync for Zen {}\n\nimpl Zen {\n    fn get_default_header() -> (String, masking::Maskable<String>) {\n        (\"request-id\".to_string(), Uuid::new_v4().to_string().into())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Zen\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut auth_header);\n\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Zen {\n    fn id(&self) -> &'static str {\n        \"zen\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        mime::APPLICATION_JSON.essence_str()\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.zen.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = zen::ZenAuthType::try_from(auth_type)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: zen::ZenErrorResponse = res\n            .response\n            .parse_struct(\"Zen ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {",
    "function_name": "get_default_header",
    "file": "crates__hyperswitch_connectors__src__connectors__zen.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_default_header",
    "code": "pub mod transformers;\nuse std::{fmt::Debug, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    api::ApplicationResponse,\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{PaymentsAuthorizeType, PaymentsSyncType, RefundExecuteType, RefundSyncType, Response},\n    webhooks::{\n        IncomingWebhook, IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext,\n    },\n};\nuse masking::{Mask, PeekInterface, Secret};\nuse transformers::{self as zen, ZenPaymentStatus, ZenWebhookTxnType};\nuse uuid::Uuid;\n\nuse crate::{constants::headers, types::ResponseRouterData};\n\n#[derive(Debug, Clone)]\npub struct Zen;\n\nimpl api::Payment for Zen {}\nimpl api::PaymentSession for Zen {}\nimpl api::ConnectorAccessToken for Zen {}\nimpl api::MandateSetup for Zen {}\nimpl api::PaymentAuthorize for Zen {}\nimpl api::PaymentSync for Zen {}\nimpl api::PaymentCapture for Zen {}\nimpl api::PaymentVoid for Zen {}\nimpl api::PaymentToken for Zen {}\nimpl api::Refund for Zen {}\nimpl api::RefundExecute for Zen {}\nimpl api::RefundSync for Zen {}\n\nimpl Zen {\n    fn get_default_header() -> (String, masking::Maskable<String>) {\n        (\"request-id\".to_string(), Uuid::new_v4().to_string().into())\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Zen\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n\n        let mut auth_header = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut auth_header);\n\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Zen {\n    fn id(&self) -> &'static str {\n        \"zen\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        mime::APPLICATION_JSON.essence_str()\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.zen.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = zen::ZenAuthType::try_from(auth_type)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: zen::ZenErrorResponse = res\n            .response\n            .parse_struct(\"Zen ErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {",
    "function_name": "get_default_header",
    "file": "crates__hyperswitch_connectors__src__connectors__zen.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__santander.rs",
    "code": "pub mod requests;\npub mod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        UpdateMetadata,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorAccessTokenSuffix, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{Maskable, PeekInterface};\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            SantanderAuthRequest, SantanderAuthType, SantanderMetadataObject,\n            SantanderPaymentRequest, SantanderRefundRequest, SantanderRouterData,\n        },\n        responses::{\n            SanatanderAccessTokenResponse, SantanderErrorResponse, SantanderGenericErrorResponse,\n            SantanderPaymentsResponse, SantanderPaymentsSyncResponse, SantanderRefundResponse,\n            SantanderUpdateMetadataResponse, SantanderVoidResponse,\n        },\n    },\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{self as connector_utils, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Santander {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Santander {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\npub mod santander_constants {\n    pub const SANTANDER_VERSION: &str = \"v2\";\n    pub const PIX_MIN_LEN_PAYMENT_ID: usize = 26;\n    pub const PIX_MAX_LEN_PAYMENT_ID: usize = 35;\n    pub const BOLETO_MIN_LEN_PAYMENT_ID: usize = 13;\n    pub const BOLETO_MAX_LEN_PAYMENT_ID: usize = 13;\n}\n\nimpl api::Payment for Santander {}\nimpl api::PaymentSession for Santander {}\nimpl api::ConnectorAccessToken for Santander {}\nimpl api::MandateSetup for Santander {}\nimpl api::PaymentAuthorize for Santander {}\nimpl api::PaymentSync for Santander {}\nimpl api::PaymentCapture for Santander {}\nimpl api::PaymentVoid for Santander {}\nimpl api::Refund for Santander {}\nimpl api::RefundExecute for Santander {}\nimpl api::RefundSync for Santander {}\nimpl api::PaymentToken for Santander {}\nimpl api::PaymentUpdateMetadata for Santander {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Santander\n{\n    // Not Implemented (R)\n}\n\nimpl ConnectorIntegration<UpdateMetadata, PaymentsUpdateMetadataData, PaymentsResponseData>\n    for Santander\n{\n    fn get_headers(\n        &self,\n        req: &RouterData<UpdateMetadata, PaymentsUpdateMetadataData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_content_type(&self) -> &'static str {\n        self.common_get_content_type()\n    }\n\n    fn get_url(\n        &self,\n        req: &PaymentsUpdateMetadataRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let santander_mca_metadata = SantanderMetadataObject::try_from(&req.connector_meta_data)?;\n\n        match req.payment_method {\n            enums::PaymentMethod::BankTransfer => match req.request.payment_method_type {\n                Some(enums::PaymentMethodType::Pix) => {\n                    let santander_variant =\n                        transformers::get_qr_code_type(req.request.connector_meta.clone())?;\n\n                    match santander_variant {\n                        enums::ExpiryType::Immediate => Ok(format!(\n                            \"{}api/v1/cob/{}\",",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__santander.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__santander.rs",
    "code": "pub mod requests;\npub mod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        UpdateMetadata,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorAccessTokenSuffix, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{Maskable, PeekInterface};\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            SantanderAuthRequest, SantanderAuthType, SantanderMetadataObject,\n            SantanderPaymentRequest, SantanderRefundRequest, SantanderRouterData,\n        },\n        responses::{\n            SanatanderAccessTokenResponse, SantanderErrorResponse, SantanderGenericErrorResponse,\n            SantanderPaymentsResponse, SantanderPaymentsSyncResponse, SantanderRefundResponse,\n            SantanderUpdateMetadataResponse, SantanderVoidResponse,\n        },\n    },\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{self as connector_utils, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Santander {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Santander {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\npub mod santander_constants {\n    pub const SANTANDER_VERSION: &str = \"v2\";\n    pub const PIX_MIN_LEN_PAYMENT_ID: usize = 26;\n    pub const PIX_MAX_LEN_PAYMENT_ID: usize = 35;\n    pub const BOLETO_MIN_LEN_PAYMENT_ID: usize = 13;\n    pub const BOLETO_MAX_LEN_PAYMENT_ID: usize = 13;\n}\n\nimpl api::Payment for Santander {}\nimpl api::PaymentSession for Santander {}\nimpl api::ConnectorAccessToken for Santander {}\nimpl api::MandateSetup for Santander {}\nimpl api::PaymentAuthorize for Santander {}\nimpl api::PaymentSync for Santander {}\nimpl api::PaymentCapture for Santander {}\nimpl api::PaymentVoid for Santander {}\nimpl api::Refund for Santander {}\nimpl api::RefundExecute for Santander {}\nimpl api::RefundSync for Santander {}\nimpl api::PaymentToken for Santander {}\nimpl api::PaymentUpdateMetadata for Santander {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Santander\n{\n    // Not Implemented (R)\n}\n\nimpl ConnectorIntegration<UpdateMetadata, PaymentsUpdateMetadataData, PaymentsResponseData>\n    for Santander\n{\n    fn get_headers(\n        &self,\n        req: &RouterData<UpdateMetadata, PaymentsUpdateMetadataData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_content_type(&self) -> &'static str {\n        self.common_get_content_type()\n    }\n\n    fn get_url(\n        &self,\n        req: &PaymentsUpdateMetadataRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let santander_mca_metadata = SantanderMetadataObject::try_from(&req.connector_meta_data)?;\n\n        match req.payment_method {\n            enums::PaymentMethod::BankTransfer => match req.request.payment_method_type {\n                Some(enums::PaymentMethodType::Pix) => {\n                    let santander_variant =\n                        transformers::get_qr_code_type(req.request.connector_meta.clone())?;\n\n                    match santander_variant {\n                        enums::ExpiryType::Immediate => Ok(format!(\n                            \"{}api/v1/cob/{}\",",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__santander.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod requests;\npub mod responses;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        UpdateMetadata,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorAccessTokenSuffix, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response},\n    webhooks,\n};\nuse masking::{Maskable, PeekInterface};\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            SantanderAuthRequest, SantanderAuthType, SantanderMetadataObject,\n            SantanderPaymentRequest, SantanderRefundRequest, SantanderRouterData,\n        },\n        responses::{\n            SanatanderAccessTokenResponse, SantanderErrorResponse, SantanderGenericErrorResponse,\n            SantanderPaymentsResponse, SantanderPaymentsSyncResponse, SantanderRefundResponse,\n            SantanderUpdateMetadataResponse, SantanderVoidResponse,\n        },\n    },\n    constants::headers,\n    types::{RefreshTokenRouterData, ResponseRouterData},\n    utils::{self as connector_utils, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Santander {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Santander {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\npub mod santander_constants {\n    pub const SANTANDER_VERSION: &str = \"v2\";\n    pub const PIX_MIN_LEN_PAYMENT_ID: usize = 26;\n    pub const PIX_MAX_LEN_PAYMENT_ID: usize = 35;\n    pub const BOLETO_MIN_LEN_PAYMENT_ID: usize = 13;\n    pub const BOLETO_MAX_LEN_PAYMENT_ID: usize = 13;\n}\n\nimpl api::Payment for Santander {}\nimpl api::PaymentSession for Santander {}\nimpl api::ConnectorAccessToken for Santander {}\nimpl api::MandateSetup for Santander {}\nimpl api::PaymentAuthorize for Santander {}\nimpl api::PaymentSync for Santander {}\nimpl api::PaymentCapture for Santander {}\nimpl api::PaymentVoid for Santander {}\nimpl api::Refund for Santander {}\nimpl api::RefundExecute for Santander {}\nimpl api::RefundSync for Santander {}\nimpl api::PaymentToken for Santander {}\nimpl api::PaymentUpdateMetadata for Santander {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Santander\n{\n    // Not Implemented (R)\n}\n\nimpl ConnectorIntegration<UpdateMetadata, PaymentsUpdateMetadataData, PaymentsResponseData>\n    for Santander\n{\n    fn get_headers(\n        &self,\n        req: &RouterData<UpdateMetadata, PaymentsUpdateMetadataData, PaymentsResponseData>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        self.build_headers(req, connectors)\n    }\n\n    fn get_content_type(&self) -> &'static str {\n        self.common_get_content_type()\n    }\n\n    fn get_url(\n        &self,\n        req: &PaymentsUpdateMetadataRouterData,\n        connectors: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        let santander_mca_metadata = SantanderMetadataObject::try_from(&req.connector_meta_data)?;\n\n        match req.payment_method {\n            enums::PaymentMethod::BankTransfer => match req.request.payment_method_type {\n                Some(enums::PaymentMethodType::Pix) => {\n                    let santander_variant =\n                        transformers::get_qr_code_type(req.request.connector_meta.clone())?;\n\n                    match santander_variant {\n                        enums::ExpiryType::Immediate => Ok(format!(\n                            \"{}api/v1/cob/{}\",",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__santander.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::{\n    errors::ParsingError,\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        PSync,\n    },\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{CreateOrderResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData as _, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\npub struct AirwallexAuthType {\n    pub x_api_key: Secret<String>,\n    pub x_client_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for AirwallexAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::BodyKey { api_key, key1 } = auth_type {\n            Ok(Self {\n                x_api_key: api_key.clone(),\n                x_client_id: key1.clone(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ReferrerData {\n    #[serde(rename = \"type\")]\n    r_type: String,\n    version: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct AirwallexIntentRequest {\n    // Unique ID to be sent for each transaction/operation request to the connector\n    request_id: String,\n    amount: StringMajorUnit,\n    currency: enums::Currency,\n    //ID created in merchant's order system that corresponds to this PaymentIntent.\n    merchant_order_id: String,\n    // This data is required to whitelist Hyperswitch at Airwallex.\n    referrer_data: ReferrerData,\n    order: Option<AirwallexOrderData>,\n}\n\nimpl TryFrom<&AirwallexRouterData<&types::CreateOrderRouterData>> for AirwallexIntentRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &AirwallexRouterData<&types::CreateOrderRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let referrer_data = ReferrerData {\n            r_type: \"hyperswitch\".to_string(),\n            version: \"1.0.0\".to_string(),\n        };\n        let amount = item.amount.clone();\n        let currency = item.router_data.request.currency;\n\n        let order = match item.router_data.request.payment_method_data {\n            Some(PaymentMethodData::PayLater(_)) => Some(\n                item.router_data\n                    .request\n                    .order_details\n                    .as_ref()\n                    .map(|order_data| AirwallexOrderData {\n                        products: order_data\n                            .iter()\n                            .map(|product| AirwallexProductData {\n                                name: product.product_name.clone(),\n                                quantity: product.quantity,\n                                unit_price: product.amount,\n                            })\n                            .collect(),\n                        shipping: Some(AirwallexShippingData {\n                            first_name: item.router_data.get_optional_shipping_first_name(),\n                            last_name: item.router_data.get_optional_shipping_last_name(),\n                            phone_number: item.router_data.get_optional_shipping_phone_number(),\n                            address: AirwallexPLShippingAddress {\n                                country_code: item.router_data.get_optional_shipping_country(),\n                                city: item.router_data.get_optional_shipping_city(),\n                                street: item.router_data.get_optional_shipping_line1(),\n                                postcode: item.router_data.get_optional_shipping_zip(),\n                            },\n                        }),\n                    })\n                    .ok_or(errors::ConnectorError::MissingRequiredField {\n                        field_name: \"order_details\",\n                    })?,\n            ),\n            _ => None,\n        };\n\n        Ok(Self {\n            request_id: Uuid::new_v4().to_string(),\n            amount,\n            currency,\n            merchant_order_id: item.router_data.connector_request_reference_id.clone(),\n            referrer_data,\n            order,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AirwallexOrderResponse {",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::{\n    errors::ParsingError,\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        PSync,\n    },\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{CreateOrderResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData as _, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\npub struct AirwallexAuthType {\n    pub x_api_key: Secret<String>,\n    pub x_client_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for AirwallexAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::BodyKey { api_key, key1 } = auth_type {\n            Ok(Self {\n                x_api_key: api_key.clone(),\n                x_client_id: key1.clone(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ReferrerData {\n    #[serde(rename = \"type\")]\n    r_type: String,\n    version: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct AirwallexIntentRequest {\n    // Unique ID to be sent for each transaction/operation request to the connector\n    request_id: String,\n    amount: StringMajorUnit,\n    currency: enums::Currency,\n    //ID created in merchant's order system that corresponds to this PaymentIntent.\n    merchant_order_id: String,\n    // This data is required to whitelist Hyperswitch at Airwallex.\n    referrer_data: ReferrerData,\n    order: Option<AirwallexOrderData>,\n}\n\nimpl TryFrom<&AirwallexRouterData<&types::CreateOrderRouterData>> for AirwallexIntentRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &AirwallexRouterData<&types::CreateOrderRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let referrer_data = ReferrerData {\n            r_type: \"hyperswitch\".to_string(),\n            version: \"1.0.0\".to_string(),\n        };\n        let amount = item.amount.clone();\n        let currency = item.router_data.request.currency;\n\n        let order = match item.router_data.request.payment_method_data {\n            Some(PaymentMethodData::PayLater(_)) => Some(\n                item.router_data\n                    .request\n                    .order_details\n                    .as_ref()\n                    .map(|order_data| AirwallexOrderData {\n                        products: order_data\n                            .iter()\n                            .map(|product| AirwallexProductData {\n                                name: product.product_name.clone(),\n                                quantity: product.quantity,\n                                unit_price: product.amount,\n                            })\n                            .collect(),\n                        shipping: Some(AirwallexShippingData {\n                            first_name: item.router_data.get_optional_shipping_first_name(),\n                            last_name: item.router_data.get_optional_shipping_last_name(),\n                            phone_number: item.router_data.get_optional_shipping_phone_number(),\n                            address: AirwallexPLShippingAddress {\n                                country_code: item.router_data.get_optional_shipping_country(),\n                                city: item.router_data.get_optional_shipping_city(),\n                                street: item.router_data.get_optional_shipping_line1(),\n                                postcode: item.router_data.get_optional_shipping_zip(),\n                            },\n                        }),\n                    })\n                    .ok_or(errors::ConnectorError::MissingRequiredField {\n                        field_name: \"order_details\",\n                    })?,\n            ),\n            _ => None,\n        };\n\n        Ok(Self {\n            request_id: Uuid::new_v4().to_string(),\n            amount,\n            currency,\n            merchant_order_id: item.router_data.connector_request_reference_id.clone(),\n            referrer_data,\n            order,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AirwallexOrderResponse {",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use common_enums::enums;\nuse common_utils::{\n    errors::ParsingError,\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress},\n    request::Method,\n    types::{MinorUnit, StringMajorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, BankTransferData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{AccessToken, ConnectorAuthType, RouterData},\n    router_flow_types::{\n        refunds::{Execute, RSync},\n        PSync,\n    },\n    router_request_types::{PaymentsSyncData, ResponseId},\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{CreateOrderResponseRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{\n        self, BrowserInformationData, CardData as _, ForeignTryFrom, PaymentsAuthorizeRequestData,\n        PhoneDetailsData, RouterData as _,\n    },\n};\n\npub struct AirwallexAuthType {\n    pub x_api_key: Secret<String>,\n    pub x_client_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for AirwallexAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::BodyKey { api_key, key1 } = auth_type {\n            Ok(Self {\n                x_api_key: api_key.clone(),\n                x_client_id: key1.clone(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct ReferrerData {\n    #[serde(rename = \"type\")]\n    r_type: String,\n    version: String,\n}\n\n#[derive(Default, Debug, Serialize, Eq, PartialEq)]\npub struct AirwallexIntentRequest {\n    // Unique ID to be sent for each transaction/operation request to the connector\n    request_id: String,\n    amount: StringMajorUnit,\n    currency: enums::Currency,\n    //ID created in merchant's order system that corresponds to this PaymentIntent.\n    merchant_order_id: String,\n    // This data is required to whitelist Hyperswitch at Airwallex.\n    referrer_data: ReferrerData,\n    order: Option<AirwallexOrderData>,\n}\n\nimpl TryFrom<&AirwallexRouterData<&types::CreateOrderRouterData>> for AirwallexIntentRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &AirwallexRouterData<&types::CreateOrderRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let referrer_data = ReferrerData {\n            r_type: \"hyperswitch\".to_string(),\n            version: \"1.0.0\".to_string(),\n        };\n        let amount = item.amount.clone();\n        let currency = item.router_data.request.currency;\n\n        let order = match item.router_data.request.payment_method_data {\n            Some(PaymentMethodData::PayLater(_)) => Some(\n                item.router_data\n                    .request\n                    .order_details\n                    .as_ref()\n                    .map(|order_data| AirwallexOrderData {\n                        products: order_data\n                            .iter()\n                            .map(|product| AirwallexProductData {\n                                name: product.product_name.clone(),\n                                quantity: product.quantity,\n                                unit_price: product.amount,\n                            })\n                            .collect(),\n                        shipping: Some(AirwallexShippingData {\n                            first_name: item.router_data.get_optional_shipping_first_name(),\n                            last_name: item.router_data.get_optional_shipping_last_name(),\n                            phone_number: item.router_data.get_optional_shipping_phone_number(),\n                            address: AirwallexPLShippingAddress {\n                                country_code: item.router_data.get_optional_shipping_country(),\n                                city: item.router_data.get_optional_shipping_city(),\n                                street: item.router_data.get_optional_shipping_line1(),\n                                postcode: item.router_data.get_optional_shipping_zip(),\n                            },\n                        }),\n                    })\n                    .ok_or(errors::ConnectorError::MissingRequiredField {\n                        field_name: \"order_details\",\n                    })?,\n            ),\n            _ => None,\n        };\n\n        Ok(Self {\n            request_id: Uuid::new_v4().to_string(),\n            amount,\n            currency,\n            merchant_order_id: item.router_data.connector_request_reference_id.clone(),\n            referrer_data,\n            order,\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AirwallexOrderResponse {",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__airwallex__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__dlocal.rs",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, SignMessage},\n    date_time,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hex::encode;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers as dlocal;\n\nuse crate::{\n    connectors::dlocal::transformers::DlocalRouterData, constants::headers,\n    types::ResponseRouterData, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Dlocal {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Dlocal {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Dlocal {}\nimpl api::PaymentToken for Dlocal {}\nimpl api::PaymentSession for Dlocal {}\nimpl api::ConnectorAccessToken for Dlocal {}\nimpl api::MandateSetup for Dlocal {}\nimpl api::PaymentAuthorize for Dlocal {}\nimpl api::PaymentSync for Dlocal {}\nimpl api::PaymentCapture for Dlocal {}\nimpl api::PaymentVoid for Dlocal {}\nimpl api::Refund for Dlocal {}\nimpl api::RefundExecute for Dlocal {}\nimpl api::RefundSync for Dlocal {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Dlocal\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let dlocal_req = self.get_request_body(req, connectors)?;\n        let date = date_time::date_as_yyyymmddthhmmssmmmz()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let auth = dlocal::DlocalAuthType::try_from(&req.connector_auth_type)?;\n\n        let sign_req: String = if dlocal_req.get_inner_value().peek() == r#\"\"{}\"\"# {\n            format!(\"{}{}\", auth.x_login.peek(), date)\n        } else {\n            format!(\n                \"{}{}{}\",\n                auth.x_login.peek(),\n                date,\n                dlocal_req.get_inner_value().peek()\n            )\n        };\n\n        let authz = crypto::HmacSha256::sign_message(\n            &crypto::HmacSha256,\n            auth.secret.peek().as_bytes(),\n            sign_req.as_bytes(),\n        )\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"Failed to sign the message\")?;\n        let auth_string: String = format!(\"V2-HMAC-SHA256, Signature: {}\", encode(authz));\n        let headers = vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                auth_string.into_masked(),\n            ),\n            (headers::X_LOGIN.to_string(), auth.x_login.into_masked()),\n            (\n                headers::X_TRANS_KEY.to_string(),\n                auth.x_trans_key.into_masked(),\n            ),\n            (headers::X_VERSION.to_string(), \"2.1\".to_string().into()),\n            (headers::X_DATE.to_string(), date.into()),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Dlocal {\n    fn id(&self) -> &'static str {\n        \"dlocal\"\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__dlocal.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__dlocal.rs",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, SignMessage},\n    date_time,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hex::encode;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers as dlocal;\n\nuse crate::{\n    connectors::dlocal::transformers::DlocalRouterData, constants::headers,\n    types::ResponseRouterData, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Dlocal {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Dlocal {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Dlocal {}\nimpl api::PaymentToken for Dlocal {}\nimpl api::PaymentSession for Dlocal {}\nimpl api::ConnectorAccessToken for Dlocal {}\nimpl api::MandateSetup for Dlocal {}\nimpl api::PaymentAuthorize for Dlocal {}\nimpl api::PaymentSync for Dlocal {}\nimpl api::PaymentCapture for Dlocal {}\nimpl api::PaymentVoid for Dlocal {}\nimpl api::Refund for Dlocal {}\nimpl api::RefundExecute for Dlocal {}\nimpl api::RefundSync for Dlocal {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Dlocal\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let dlocal_req = self.get_request_body(req, connectors)?;\n        let date = date_time::date_as_yyyymmddthhmmssmmmz()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let auth = dlocal::DlocalAuthType::try_from(&req.connector_auth_type)?;\n\n        let sign_req: String = if dlocal_req.get_inner_value().peek() == r#\"\"{}\"\"# {\n            format!(\"{}{}\", auth.x_login.peek(), date)\n        } else {\n            format!(\n                \"{}{}{}\",\n                auth.x_login.peek(),\n                date,\n                dlocal_req.get_inner_value().peek()\n            )\n        };\n\n        let authz = crypto::HmacSha256::sign_message(\n            &crypto::HmacSha256,\n            auth.secret.peek().as_bytes(),\n            sign_req.as_bytes(),\n        )\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"Failed to sign the message\")?;\n        let auth_string: String = format!(\"V2-HMAC-SHA256, Signature: {}\", encode(authz));\n        let headers = vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                auth_string.into_masked(),\n            ),\n            (headers::X_LOGIN.to_string(), auth.x_login.into_masked()),\n            (\n                headers::X_TRANS_KEY.to_string(),\n                auth.x_trans_key.into_masked(),\n            ),\n            (headers::X_VERSION.to_string(), \"2.1\".to_string().into()),\n            (headers::X_DATE.to_string(), date.into()),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Dlocal {\n    fn id(&self) -> &'static str {\n        \"dlocal\"\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__dlocal.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::enums;\nuse common_utils::{\n    crypto::{self, SignMessage},\n    date_time,\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hex::encode;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, Maskable, PeekInterface};\nuse transformers as dlocal;\n\nuse crate::{\n    connectors::dlocal::transformers::DlocalRouterData, constants::headers,\n    types::ResponseRouterData, utils::convert_amount,\n};\n\n#[derive(Clone)]\npub struct Dlocal {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Dlocal {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Dlocal {}\nimpl api::PaymentToken for Dlocal {}\nimpl api::PaymentSession for Dlocal {}\nimpl api::ConnectorAccessToken for Dlocal {}\nimpl api::MandateSetup for Dlocal {}\nimpl api::PaymentAuthorize for Dlocal {}\nimpl api::PaymentSync for Dlocal {}\nimpl api::PaymentCapture for Dlocal {}\nimpl api::PaymentVoid for Dlocal {}\nimpl api::Refund for Dlocal {}\nimpl api::RefundExecute for Dlocal {}\nimpl api::RefundSync for Dlocal {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Dlocal\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {\n        let dlocal_req = self.get_request_body(req, connectors)?;\n        let date = date_time::date_as_yyyymmddthhmmssmmmz()\n            .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        let auth = dlocal::DlocalAuthType::try_from(&req.connector_auth_type)?;\n\n        let sign_req: String = if dlocal_req.get_inner_value().peek() == r#\"\"{}\"\"# {\n            format!(\"{}{}\", auth.x_login.peek(), date)\n        } else {\n            format!(\n                \"{}{}{}\",\n                auth.x_login.peek(),\n                date,\n                dlocal_req.get_inner_value().peek()\n            )\n        };\n\n        let authz = crypto::HmacSha256::sign_message(\n            &crypto::HmacSha256,\n            auth.secret.peek().as_bytes(),\n            sign_req.as_bytes(),\n        )\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"Failed to sign the message\")?;\n        let auth_string: String = format!(\"V2-HMAC-SHA256, Signature: {}\", encode(authz));\n        let headers = vec![\n            (\n                headers::AUTHORIZATION.to_string(),\n                auth_string.into_masked(),\n            ),\n            (headers::X_LOGIN.to_string(), auth.x_login.into_masked()),\n            (\n                headers::X_TRANS_KEY.to_string(),\n                auth.x_trans_key.into_masked(),\n            ),\n            (headers::X_VERSION.to_string(), \"2.1\".to_string().into()),\n            (headers::X_DATE.to_string(), date.into()),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n        ];\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Dlocal {\n    fn id(&self) -> &'static str {\n        \"dlocal\"\n    }\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__dlocal.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__bankofamerica__transformers.rs",
    "code": "use base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{consts, ext_traits::OptionExt, pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, GooglePayWalletData, PaymentMethodData, SamsungPayWalletData,\n        WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\npub struct BankOfAmericaAuthType {\n    pub(super) api_key: Secret<String>,\n    pub(super) merchant_account: Secret<String>,\n    pub(super) api_secret: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for BankOfAmericaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                api_key: api_key.to_owned(),\n                merchant_account: key1.to_owned(),\n                api_secret: api_secret.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\npub struct BankOfAmericaRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for BankOfAmericaRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaPaymentsRequest {\n    processing_information: ProcessingInformation,\n    payment_information: PaymentInformation,\n    order_information: OrderInformationWithBill,\n    client_reference_information: ClientReferenceInformation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    consumer_authentication_information: Option<BankOfAmericaConsumerAuthInformation>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    merchant_defined_information: Option<Vec<MerchantDefinedInformation>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProcessingInformation {\n    action_list: Option<Vec<BankOfAmericaActionsList>>,\n    action_token_types: Option<Vec<BankOfAmericaActionsTokenType>>,\n    authorization_options: Option<BankOfAmericaAuthorizationOptions>,\n    commerce_indicator: String,\n    capture: Option<bool>,\n    capture_options: Option<CaptureOptions>,\n    payment_solution: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum BankOfAmericaActionsList {\n    TokenCreate,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum BankOfAmericaActionsTokenType {\n    PaymentInstrument,\n    Customer,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaAuthorizationOptions {\n    initiator: Option<BankOfAmericaPaymentInitiator>,\n    merchant_initiated_transaction: Option<MerchantInitiatedTransaction>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaPaymentInitiator {\n    #[serde(rename = \"type\")]\n    initiator_type: Option<BankOfAmericaPaymentInitiatorTypes>,\n    credential_stored_on_file: Option<bool>,\n    stored_credential_used: Option<bool>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum BankOfAmericaPaymentInitiatorTypes {\n    Customer,\n}",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__bankofamerica__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__bankofamerica__transformers.rs",
    "code": "use base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{consts, ext_traits::OptionExt, pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, GooglePayWalletData, PaymentMethodData, SamsungPayWalletData,\n        WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\npub struct BankOfAmericaAuthType {\n    pub(super) api_key: Secret<String>,\n    pub(super) merchant_account: Secret<String>,\n    pub(super) api_secret: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for BankOfAmericaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                api_key: api_key.to_owned(),\n                merchant_account: key1.to_owned(),\n                api_secret: api_secret.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\npub struct BankOfAmericaRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for BankOfAmericaRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaPaymentsRequest {\n    processing_information: ProcessingInformation,\n    payment_information: PaymentInformation,\n    order_information: OrderInformationWithBill,\n    client_reference_information: ClientReferenceInformation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    consumer_authentication_information: Option<BankOfAmericaConsumerAuthInformation>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    merchant_defined_information: Option<Vec<MerchantDefinedInformation>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProcessingInformation {\n    action_list: Option<Vec<BankOfAmericaActionsList>>,\n    action_token_types: Option<Vec<BankOfAmericaActionsTokenType>>,\n    authorization_options: Option<BankOfAmericaAuthorizationOptions>,\n    commerce_indicator: String,\n    capture: Option<bool>,\n    capture_options: Option<CaptureOptions>,\n    payment_solution: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum BankOfAmericaActionsList {\n    TokenCreate,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum BankOfAmericaActionsTokenType {\n    PaymentInstrument,\n    Customer,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaAuthorizationOptions {\n    initiator: Option<BankOfAmericaPaymentInitiator>,\n    merchant_initiated_transaction: Option<MerchantInitiatedTransaction>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaPaymentInitiator {\n    #[serde(rename = \"type\")]\n    initiator_type: Option<BankOfAmericaPaymentInitiatorTypes>,\n    credential_stored_on_file: Option<bool>,\n    stored_credential_used: Option<bool>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum BankOfAmericaPaymentInitiatorTypes {\n    Customer,\n}",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__bankofamerica__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for try_from",
    "code": "use base64::Engine;\nuse common_enums::{enums, FutureUsage};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{consts, ext_traits::OptionExt, pii, types::StringMajorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, GooglePayWalletData, PaymentMethodData, SamsungPayWalletData,\n        WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ErrorResponse, PaymentMethodToken, RouterData,\n    },\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{MandateReference, PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{api, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{\n        self, AddressDetailsData, CardData, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, PaymentsSyncRequestData, RecurringMandateData,\n        RouterData as OtherRouterData,\n    },\n};\npub struct BankOfAmericaAuthType {\n    pub(super) api_key: Secret<String>,\n    pub(super) merchant_account: Secret<String>,\n    pub(super) api_secret: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for BankOfAmericaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                api_key: api_key.to_owned(),\n                merchant_account: key1.to_owned(),\n                api_secret: api_secret.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtainAuthType)?\n        }\n    }\n}\n\npub struct BankOfAmericaRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> TryFrom<(StringMajorUnit, T)> for BankOfAmericaRouterData<T> {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from((amount, item): (StringMajorUnit, T)) -> Result<Self, Self::Error> {\n        Ok(Self {\n            amount,\n            router_data: item,\n        })\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaPaymentsRequest {\n    processing_information: ProcessingInformation,\n    payment_information: PaymentInformation,\n    order_information: OrderInformationWithBill,\n    client_reference_information: ClientReferenceInformation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    consumer_authentication_information: Option<BankOfAmericaConsumerAuthInformation>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    merchant_defined_information: Option<Vec<MerchantDefinedInformation>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProcessingInformation {\n    action_list: Option<Vec<BankOfAmericaActionsList>>,\n    action_token_types: Option<Vec<BankOfAmericaActionsTokenType>>,\n    authorization_options: Option<BankOfAmericaAuthorizationOptions>,\n    commerce_indicator: String,\n    capture: Option<bool>,\n    capture_options: Option<CaptureOptions>,\n    payment_solution: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum BankOfAmericaActionsList {\n    TokenCreate,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum BankOfAmericaActionsTokenType {\n    PaymentInstrument,\n    Customer,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaAuthorizationOptions {\n    initiator: Option<BankOfAmericaPaymentInitiator>,\n    merchant_initiated_transaction: Option<MerchantInitiatedTransaction>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BankOfAmericaPaymentInitiator {\n    #[serde(rename = \"type\")]\n    initiator_type: Option<BankOfAmericaPaymentInitiatorTypes>,\n    credential_stored_on_file: Option<bool>,\n    stored_credential_used: Option<bool>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum BankOfAmericaPaymentInitiatorTypes {\n    Customer,\n}",
    "function_name": "try_from",
    "file": "crates__hyperswitch_connectors__src__connectors__bankofamerica__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_types::payments::{ApplePayPaymentData, ApplePayPredecryptData};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, GiftCardData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentMethodTokenizationData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, missing_field_err, to_connector_meta, BrowserInformationData, CardData,\n        PaymentMethodTokenizationRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as RouterDataUtils,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 36;\n\npub struct PaysafeRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PaysafeRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PaysafeConnectorMetadataObject {\n    pub account_id: PaysafePaymentMethodDetails,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PaysafePaymentMethodDetails {\n    pub apple_pay: Option<HashMap<Currency, ApplePayAccountDetails>>,\n    pub card: Option<HashMap<Currency, CardAccountId>>,\n    pub interac: Option<HashMap<Currency, RedirectAccountId>>,\n    pub pay_safe_card: Option<HashMap<Currency, RedirectAccountId>>,\n    pub skrill: Option<HashMap<Currency, RedirectAccountId>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct CardAccountId {\n    no_three_ds: Option<Secret<String>>,\n    three_ds: Option<Secret<String>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct ApplePayAccountDetails {\n    encrypt: Option<Secret<String>>,\n    decrypt: Option<Secret<String>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct RedirectAccountId {\n    three_ds: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<SecretSerdeValue>> for PaysafeConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"merchant_connector_account.metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nimpl TryFrom<&ConnectorCustomerRouterData> for PaysafeCustomerDetails {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(customer_data: &ConnectorCustomerRouterData) -> Result<Self, Self::Error> {\n        let merchant_customer_id = match customer_data.customer_id.as_ref() {\n            Some(customer_id) if customer_id.get_string_repr().len() <= MAX_ID_LENGTH => {\n                Ok(customer_id.get_string_repr().to_string())\n            }\n            Some(customer_id) => Err(errors::ConnectorError::MaxFieldLengthViolated {\n                connector: \"Paysafe\".to_string(),\n                field_name: \"customer_id\".to_string(),\n                max_length: MAX_ID_LENGTH,\n                received_length: customer_id.get_string_repr().len(),\n            }),\n            None => Err(errors::ConnectorError::MissingRequiredField {\n                field_name: \"customer_id\",\n            }),\n        }?;\n\n        Ok(Self {\n            merchant_customer_id,\n            first_name: customer_data.get_optional_billing_first_name(),\n            last_name: customer_data.get_optional_billing_last_name(),\n            email: customer_data.get_optional_billing_email(),\n            phone: customer_data.get_optional_billing_phone_number(),\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaysafeCustomerDetails {\n    pub merchant_customer_id: String,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_types::payments::{ApplePayPaymentData, ApplePayPredecryptData};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, GiftCardData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentMethodTokenizationData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, missing_field_err, to_connector_meta, BrowserInformationData, CardData,\n        PaymentMethodTokenizationRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as RouterDataUtils,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 36;\n\npub struct PaysafeRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PaysafeRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PaysafeConnectorMetadataObject {\n    pub account_id: PaysafePaymentMethodDetails,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PaysafePaymentMethodDetails {\n    pub apple_pay: Option<HashMap<Currency, ApplePayAccountDetails>>,\n    pub card: Option<HashMap<Currency, CardAccountId>>,\n    pub interac: Option<HashMap<Currency, RedirectAccountId>>,\n    pub pay_safe_card: Option<HashMap<Currency, RedirectAccountId>>,\n    pub skrill: Option<HashMap<Currency, RedirectAccountId>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct CardAccountId {\n    no_three_ds: Option<Secret<String>>,\n    three_ds: Option<Secret<String>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct ApplePayAccountDetails {\n    encrypt: Option<Secret<String>>,\n    decrypt: Option<Secret<String>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct RedirectAccountId {\n    three_ds: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<SecretSerdeValue>> for PaysafeConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"merchant_connector_account.metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nimpl TryFrom<&ConnectorCustomerRouterData> for PaysafeCustomerDetails {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(customer_data: &ConnectorCustomerRouterData) -> Result<Self, Self::Error> {\n        let merchant_customer_id = match customer_data.customer_id.as_ref() {\n            Some(customer_id) if customer_id.get_string_repr().len() <= MAX_ID_LENGTH => {\n                Ok(customer_id.get_string_repr().to_string())\n            }\n            Some(customer_id) => Err(errors::ConnectorError::MaxFieldLengthViolated {\n                connector: \"Paysafe\".to_string(),\n                field_name: \"customer_id\".to_string(),\n                max_length: MAX_ID_LENGTH,\n                received_length: customer_id.get_string_repr().len(),\n            }),\n            None => Err(errors::ConnectorError::MissingRequiredField {\n                field_name: \"customer_id\",\n            }),\n        }?;\n\n        Ok(Self {\n            merchant_customer_id,\n            first_name: customer_data.get_optional_billing_first_name(),\n            last_name: customer_data.get_optional_billing_last_name(),\n            email: customer_data.get_optional_billing_email(),\n            phone: customer_data.get_optional_billing_phone_number(),\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaysafeCustomerDetails {\n    pub merchant_customer_id: String,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use std::collections::HashMap;\n\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, Currency};\nuse common_types::payments::{ApplePayPaymentData, ApplePayPredecryptData};\nuse common_utils::{\n    ext_traits::ValueExt,\n    id_type,\n    pii::{Email, IpAddress, SecretSerdeValue},\n    request::Method,\n    types::MinorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        ApplePayWalletData, BankRedirectData, GiftCardData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        CompleteAuthorizeData, PaymentMethodTokenizationData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreProcessingRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsPreprocessingResponseRouterData, PaymentsResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self, missing_field_err, to_connector_meta, BrowserInformationData, CardData,\n        PaymentMethodTokenizationRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreProcessingRequestData,\n        RouterData as RouterDataUtils,\n    },\n};\n\nconst MAX_ID_LENGTH: usize = 36;\n\npub struct PaysafeRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PaysafeRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PaysafeConnectorMetadataObject {\n    pub account_id: PaysafePaymentMethodDetails,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct PaysafePaymentMethodDetails {\n    pub apple_pay: Option<HashMap<Currency, ApplePayAccountDetails>>,\n    pub card: Option<HashMap<Currency, CardAccountId>>,\n    pub interac: Option<HashMap<Currency, RedirectAccountId>>,\n    pub pay_safe_card: Option<HashMap<Currency, RedirectAccountId>>,\n    pub skrill: Option<HashMap<Currency, RedirectAccountId>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct CardAccountId {\n    no_three_ds: Option<Secret<String>>,\n    three_ds: Option<Secret<String>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct ApplePayAccountDetails {\n    encrypt: Option<Secret<String>>,\n    decrypt: Option<Secret<String>>,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct RedirectAccountId {\n    three_ds: Option<Secret<String>>,\n}\n\nimpl TryFrom<&Option<SecretSerdeValue>> for PaysafeConnectorMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(meta_data: &Option<SecretSerdeValue>) -> Result<Self, Self::Error> {\n        let metadata: Self = utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"merchant_connector_account.metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nimpl TryFrom<&ConnectorCustomerRouterData> for PaysafeCustomerDetails {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(customer_data: &ConnectorCustomerRouterData) -> Result<Self, Self::Error> {\n        let merchant_customer_id = match customer_data.customer_id.as_ref() {\n            Some(customer_id) if customer_id.get_string_repr().len() <= MAX_ID_LENGTH => {\n                Ok(customer_id.get_string_repr().to_string())\n            }\n            Some(customer_id) => Err(errors::ConnectorError::MaxFieldLengthViolated {\n                connector: \"Paysafe\".to_string(),\n                field_name: \"customer_id\".to_string(),\n                max_length: MAX_ID_LENGTH,\n                received_length: customer_id.get_string_repr().len(),\n            }),\n            None => Err(errors::ConnectorError::MissingRequiredField {\n                field_name: \"customer_id\",\n            }),\n        }?;\n\n        Ok(Self {\n            merchant_customer_id,\n            first_name: customer_data.get_optional_billing_first_name(),\n            last_name: customer_data.get_optional_billing_last_name(),\n            email: customer_data.get_optional_billing_email(),\n            phone: customer_data.get_optional_billing_phone_number(),\n        })\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaysafeCustomerDetails {\n    pub merchant_customer_id: String,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__paysafe__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__gocardless.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as gocardless;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Gocardless {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Gocardless {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Gocardless {}\nimpl api::PaymentSession for Gocardless {}\nimpl api::ConnectorAccessToken for Gocardless {}\nimpl api::MandateSetup for Gocardless {}\nimpl api::PaymentAuthorize for Gocardless {}\nimpl api::PaymentSync for Gocardless {}\nimpl api::PaymentCapture for Gocardless {}\nimpl api::PaymentVoid for Gocardless {}\nimpl api::Refund for Gocardless {}\nimpl api::RefundExecute for Gocardless {}\nimpl api::RefundSync for Gocardless {}\nimpl api::PaymentToken for Gocardless {}\nimpl api::ConnectorCustomer for Gocardless {}\nimpl api::PaymentsPreProcessing for Gocardless {}\n\nconst GOCARDLESS_VERSION: &str = \"2015-07-06\";\nconst GOCARDLESS_VERSION_HEADER: &str = \"GoCardless-Version\";\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gocardless\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                GOCARDLESS_VERSION_HEADER.to_string(),\n                GOCARDLESS_VERSION.to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Gocardless {\n    fn id(&self) -> &'static str {\n        \"gocardless\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.gocardless.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = gocardless::GocardlessAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.access_token.peek()).into_masked(),\n        )])",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__gocardless.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__gocardless.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as gocardless;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Gocardless {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Gocardless {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Gocardless {}\nimpl api::PaymentSession for Gocardless {}\nimpl api::ConnectorAccessToken for Gocardless {}\nimpl api::MandateSetup for Gocardless {}\nimpl api::PaymentAuthorize for Gocardless {}\nimpl api::PaymentSync for Gocardless {}\nimpl api::PaymentCapture for Gocardless {}\nimpl api::PaymentVoid for Gocardless {}\nimpl api::Refund for Gocardless {}\nimpl api::RefundExecute for Gocardless {}\nimpl api::RefundSync for Gocardless {}\nimpl api::PaymentToken for Gocardless {}\nimpl api::ConnectorCustomer for Gocardless {}\nimpl api::PaymentsPreProcessing for Gocardless {}\n\nconst GOCARDLESS_VERSION: &str = \"2015-07-06\";\nconst GOCARDLESS_VERSION_HEADER: &str = \"GoCardless-Version\";\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gocardless\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                GOCARDLESS_VERSION_HEADER.to_string(),\n                GOCARDLESS_VERSION.to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Gocardless {\n    fn id(&self) -> &'static str {\n        \"gocardless\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.gocardless.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = gocardless::GocardlessAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.access_token.peek()).into_masked(),\n        )])",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__gocardless.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsSyncType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as gocardless;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Gocardless {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Gocardless {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Gocardless {}\nimpl api::PaymentSession for Gocardless {}\nimpl api::ConnectorAccessToken for Gocardless {}\nimpl api::MandateSetup for Gocardless {}\nimpl api::PaymentAuthorize for Gocardless {}\nimpl api::PaymentSync for Gocardless {}\nimpl api::PaymentCapture for Gocardless {}\nimpl api::PaymentVoid for Gocardless {}\nimpl api::Refund for Gocardless {}\nimpl api::RefundExecute for Gocardless {}\nimpl api::RefundSync for Gocardless {}\nimpl api::PaymentToken for Gocardless {}\nimpl api::ConnectorCustomer for Gocardless {}\nimpl api::PaymentsPreProcessing for Gocardless {}\n\nconst GOCARDLESS_VERSION: &str = \"2015-07-06\";\nconst GOCARDLESS_VERSION_HEADER: &str = \"GoCardless-Version\";\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Gocardless\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                GOCARDLESS_VERSION_HEADER.to_string(),\n                GOCARDLESS_VERSION.to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Gocardless {\n    fn id(&self) -> &'static str {\n        \"gocardless\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.gocardless.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = gocardless::GocardlessAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.access_token.peek()).into_masked(),\n        )])",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__gocardless.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs",
    "code": "use common_enums::{enums, CountryAlpha2, UsStatesAbbreviation};\nuse common_utils::{\n    id_type,\n    pii::{self, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{\n        ConnectorCustomerData, PaymentMethodTokenizationData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CustomerData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\npub struct GocardlessRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for GocardlessRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomerRequest {\n    customers: GocardlessCustomer,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomer {\n    address_line1: Option<Secret<String>>,\n    address_line2: Option<Secret<String>>,\n    address_line3: Option<Secret<String>>,\n    city: Option<Secret<String>>,\n    region: Option<Secret<String>>,\n    country_code: Option<CountryAlpha2>,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    metadata: CustomerMetaData,\n    danish_identity_number: Option<Secret<String>>,\n    postal_code: Option<Secret<String>>,\n    swedish_identity_number: Option<Secret<String>>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct CustomerMetaData {\n    crm_id: Option<Secret<id_type::CustomerId>>,\n}\n\nimpl TryFrom<&types::ConnectorCustomerRouterData> for GocardlessCustomerRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::ConnectorCustomerRouterData) -> Result<Self, Self::Error> {\n        let email = item.request.get_email()?;\n        let billing_details_name = item.get_billing_full_name()?.expose();\n\n        let (given_name, family_name) = billing_details_name\n            .trim()\n            .rsplit_once(' ')\n            .unwrap_or((&billing_details_name, &billing_details_name));\n\n        let billing_address = item.get_billing_address()?;\n\n        let metadata = CustomerMetaData {\n            crm_id: item.customer_id.clone().map(Secret::new),\n        };\n        let region = get_region(billing_address)?;\n        Ok(Self {\n            customers: GocardlessCustomer {\n                email,\n                given_name: Secret::new(given_name.to_string()),\n                family_name: Secret::new(family_name.to_string()),\n                metadata,\n                address_line1: billing_address.line1.to_owned(),\n                address_line2: billing_address.line2.to_owned(),\n                address_line3: billing_address.line3.to_owned(),\n                country_code: billing_address.country,\n                region,\n                // Should be populated based on the billing country\n                danish_identity_number: None,\n                postal_code: billing_address.zip.to_owned(),\n                // Should be populated based on the billing country\n                swedish_identity_number: None,\n                city: billing_address.city.clone().map(Secret::new),\n            },\n        })\n    }\n}\n\nfn get_region(\n    address_details: &AddressDetails,\n) -> Result<Option<Secret<String>>, error_stack::Report<errors::ConnectorError>> {\n    match address_details.country {\n        Some(CountryAlpha2::US) => {\n            let state = address_details.get_state()?.to_owned();\n            Ok(Some(Secret::new(\n                UsStatesAbbreviation::foreign_try_from(state.expose())?.to_string(),\n            )))\n        }\n        _ => Ok(None),\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct GocardlessCustomerResponse {\n    customers: Customers,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Customers {\n    id: Secret<String>,\n}\n\nimpl<F>\n    TryFrom<",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs",
    "code": "use common_enums::{enums, CountryAlpha2, UsStatesAbbreviation};\nuse common_utils::{\n    id_type,\n    pii::{self, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{\n        ConnectorCustomerData, PaymentMethodTokenizationData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CustomerData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\npub struct GocardlessRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for GocardlessRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomerRequest {\n    customers: GocardlessCustomer,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomer {\n    address_line1: Option<Secret<String>>,\n    address_line2: Option<Secret<String>>,\n    address_line3: Option<Secret<String>>,\n    city: Option<Secret<String>>,\n    region: Option<Secret<String>>,\n    country_code: Option<CountryAlpha2>,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    metadata: CustomerMetaData,\n    danish_identity_number: Option<Secret<String>>,\n    postal_code: Option<Secret<String>>,\n    swedish_identity_number: Option<Secret<String>>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct CustomerMetaData {\n    crm_id: Option<Secret<id_type::CustomerId>>,\n}\n\nimpl TryFrom<&types::ConnectorCustomerRouterData> for GocardlessCustomerRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::ConnectorCustomerRouterData) -> Result<Self, Self::Error> {\n        let email = item.request.get_email()?;\n        let billing_details_name = item.get_billing_full_name()?.expose();\n\n        let (given_name, family_name) = billing_details_name\n            .trim()\n            .rsplit_once(' ')\n            .unwrap_or((&billing_details_name, &billing_details_name));\n\n        let billing_address = item.get_billing_address()?;\n\n        let metadata = CustomerMetaData {\n            crm_id: item.customer_id.clone().map(Secret::new),\n        };\n        let region = get_region(billing_address)?;\n        Ok(Self {\n            customers: GocardlessCustomer {\n                email,\n                given_name: Secret::new(given_name.to_string()),\n                family_name: Secret::new(family_name.to_string()),\n                metadata,\n                address_line1: billing_address.line1.to_owned(),\n                address_line2: billing_address.line2.to_owned(),\n                address_line3: billing_address.line3.to_owned(),\n                country_code: billing_address.country,\n                region,\n                // Should be populated based on the billing country\n                danish_identity_number: None,\n                postal_code: billing_address.zip.to_owned(),\n                // Should be populated based on the billing country\n                swedish_identity_number: None,\n                city: billing_address.city.clone().map(Secret::new),\n            },\n        })\n    }\n}\n\nfn get_region(\n    address_details: &AddressDetails,\n) -> Result<Option<Secret<String>>, error_stack::Report<errors::ConnectorError>> {\n    match address_details.country {\n        Some(CountryAlpha2::US) => {\n            let state = address_details.get_state()?.to_owned();\n            Ok(Some(Secret::new(\n                UsStatesAbbreviation::foreign_try_from(state.expose())?.to_string(),\n            )))\n        }\n        _ => Ok(None),\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct GocardlessCustomerResponse {\n    customers: Customers,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Customers {\n    id: Secret<String>,\n}\n\nimpl<F>\n    TryFrom<",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::{enums, CountryAlpha2, UsStatesAbbreviation};\nuse common_utils::{\n    id_type,\n    pii::{self, IpAddress},\n    types::MinorUnit,\n};\nuse hyperswitch_domain_models::{\n    address::AddressDetails,\n    payment_method_data::{BankDebitData, PaymentMethodData},\n    router_data::{ConnectorAuthType, PaymentMethodToken, RouterData},\n    router_flow_types::refunds::Execute,\n    router_request_types::{\n        ConnectorCustomerData, PaymentMethodTokenizationData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n        ResponseRouterData,\n    },\n    utils::{\n        self, AddressDetailsData, BrowserInformationData, CustomerData, ForeignTryFrom,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\npub struct GocardlessRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for GocardlessRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomerRequest {\n    customers: GocardlessCustomer,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct GocardlessCustomer {\n    address_line1: Option<Secret<String>>,\n    address_line2: Option<Secret<String>>,\n    address_line3: Option<Secret<String>>,\n    city: Option<Secret<String>>,\n    region: Option<Secret<String>>,\n    country_code: Option<CountryAlpha2>,\n    email: pii::Email,\n    given_name: Secret<String>,\n    family_name: Secret<String>,\n    metadata: CustomerMetaData,\n    danish_identity_number: Option<Secret<String>>,\n    postal_code: Option<Secret<String>>,\n    swedish_identity_number: Option<Secret<String>>,\n}\n\n#[derive(Default, Debug, Serialize)]\npub struct CustomerMetaData {\n    crm_id: Option<Secret<id_type::CustomerId>>,\n}\n\nimpl TryFrom<&types::ConnectorCustomerRouterData> for GocardlessCustomerRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::ConnectorCustomerRouterData) -> Result<Self, Self::Error> {\n        let email = item.request.get_email()?;\n        let billing_details_name = item.get_billing_full_name()?.expose();\n\n        let (given_name, family_name) = billing_details_name\n            .trim()\n            .rsplit_once(' ')\n            .unwrap_or((&billing_details_name, &billing_details_name));\n\n        let billing_address = item.get_billing_address()?;\n\n        let metadata = CustomerMetaData {\n            crm_id: item.customer_id.clone().map(Secret::new),\n        };\n        let region = get_region(billing_address)?;\n        Ok(Self {\n            customers: GocardlessCustomer {\n                email,\n                given_name: Secret::new(given_name.to_string()),\n                family_name: Secret::new(family_name.to_string()),\n                metadata,\n                address_line1: billing_address.line1.to_owned(),\n                address_line2: billing_address.line2.to_owned(),\n                address_line3: billing_address.line3.to_owned(),\n                country_code: billing_address.country,\n                region,\n                // Should be populated based on the billing country\n                danish_identity_number: None,\n                postal_code: billing_address.zip.to_owned(),\n                // Should be populated based on the billing country\n                swedish_identity_number: None,\n                city: billing_address.city.clone().map(Secret::new),\n            },\n        })\n    }\n}\n\nfn get_region(\n    address_details: &AddressDetails,\n) -> Result<Option<Secret<String>>, error_stack::Report<errors::ConnectorError>> {\n    match address_details.country {\n        Some(CountryAlpha2::US) => {\n            let state = address_details.get_state()?.to_owned();\n            Ok(Some(Secret::new(\n                UsStatesAbbreviation::foreign_try_from(state.expose())?.to_string(),\n            )))\n        }\n        _ => Ok(None),\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct GocardlessCustomerResponse {\n    customers: Customers,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Customers {\n    id: Secret<String>,\n}\n\nimpl<F>\n    TryFrom<",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__gocardless__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask as _, Maskable};\n\nuse self::transformers as wellsfargopayout;\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Wellsfargopayout {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Wellsfargopayout {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Wellsfargopayout {}\nimpl api::PaymentSession for Wellsfargopayout {}\nimpl api::ConnectorAccessToken for Wellsfargopayout {}\nimpl api::MandateSetup for Wellsfargopayout {}\nimpl api::PaymentAuthorize for Wellsfargopayout {}\nimpl api::PaymentSync for Wellsfargopayout {}\nimpl api::PaymentCapture for Wellsfargopayout {}\nimpl api::PaymentVoid for Wellsfargopayout {}\nimpl api::Refund for Wellsfargopayout {}\nimpl api::RefundExecute for Wellsfargopayout {}\nimpl api::RefundSync for Wellsfargopayout {}\nimpl api::PaymentToken for Wellsfargopayout {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Wellsfargopayout\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargopayout\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Wellsfargopayout {\n    fn id(&self) -> &'static str {\n        \"wellsfargopayout\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        // todo!()\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.wellsfargopayout.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = wellsfargopayout::WellsfargopayoutAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: wellsfargopayout::WellsfargopayoutErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargopayoutErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask as _, Maskable};\n\nuse self::transformers as wellsfargopayout;\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Wellsfargopayout {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Wellsfargopayout {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Wellsfargopayout {}\nimpl api::PaymentSession for Wellsfargopayout {}\nimpl api::ConnectorAccessToken for Wellsfargopayout {}\nimpl api::MandateSetup for Wellsfargopayout {}\nimpl api::PaymentAuthorize for Wellsfargopayout {}\nimpl api::PaymentSync for Wellsfargopayout {}\nimpl api::PaymentCapture for Wellsfargopayout {}\nimpl api::PaymentVoid for Wellsfargopayout {}\nimpl api::Refund for Wellsfargopayout {}\nimpl api::RefundExecute for Wellsfargopayout {}\nimpl api::RefundSync for Wellsfargopayout {}\nimpl api::PaymentToken for Wellsfargopayout {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Wellsfargopayout\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargopayout\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Wellsfargopayout {\n    fn id(&self) -> &'static str {\n        \"wellsfargopayout\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        // todo!()\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.wellsfargopayout.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = wellsfargopayout::WellsfargopayoutAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: wellsfargopayout::WellsfargopayoutErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargopayoutErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, RefundExecuteType,\n        RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{ExposeInterface, Mask as _, Maskable};\n\nuse self::transformers as wellsfargopayout;\nuse crate::{constants::headers, types::ResponseRouterData, utils::convert_amount};\n\n#[derive(Clone)]\npub struct Wellsfargopayout {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Wellsfargopayout {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Wellsfargopayout {}\nimpl api::PaymentSession for Wellsfargopayout {}\nimpl api::ConnectorAccessToken for Wellsfargopayout {}\nimpl api::MandateSetup for Wellsfargopayout {}\nimpl api::PaymentAuthorize for Wellsfargopayout {}\nimpl api::PaymentSync for Wellsfargopayout {}\nimpl api::PaymentCapture for Wellsfargopayout {}\nimpl api::PaymentVoid for Wellsfargopayout {}\nimpl api::Refund for Wellsfargopayout {}\nimpl api::RefundExecute for Wellsfargopayout {}\nimpl api::RefundSync for Wellsfargopayout {}\nimpl api::PaymentToken for Wellsfargopayout {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Wellsfargopayout\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Wellsfargopayout\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Wellsfargopayout {\n    fn id(&self) -> &'static str {\n        \"wellsfargopayout\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        // todo!()\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.wellsfargopayout.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = wellsfargopayout::WellsfargopayoutAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, ConnectorError> {\n        let response: wellsfargopayout::WellsfargopayoutErrorResponse = res\n            .response\n            .parse_struct(\"WellsfargopayoutErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__wellsfargopayout.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__santander__transformers.rs",
    "code": "use api_models::payments::{QrCodeInformation, VoucherNextStepData};\nuse common_enums::{\n    enums, AttemptStatus, BoletoDocumentKind, BoletoPaymentType, ExpiryType, PixKey,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, ValueExt},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse crc::{Algorithm, Crc};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankTransferData, BoletoVoucherData, PaymentMethodData, VoucherData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{PaymentsUpdateMetadataData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        PaymentsUpdateMetadataRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::{self},\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            Environment, SantanderAuthRequest, SantanderAuthType, SantanderBoletoCancelOperation,\n            SantanderBoletoCancelRequest, SantanderBoletoPaymentRequest,\n            SantanderBoletoUpdateRequest, SantanderDebtor, SantanderGrantType,\n            SantanderMetadataObject, SantanderPaymentRequest, SantanderPaymentsCancelRequest,\n            SantanderPixCancelRequest, SantanderPixDueDateCalendarRequest,\n            SantanderPixImmediateCalendarRequest, SantanderPixQRPaymentRequest,\n            SantanderPixRequestCalendar, SantanderRefundRequest, SantanderRouterData,\n            SantanderValue,\n        },\n        responses::{\n            Key, NsuComposite, Payer, SanatanderAccessTokenResponse, SanatanderTokenResponse,\n            SantanderAdditionalInfo, SantanderBoletoDocumentKind, SantanderBoletoPaymentType,\n            SantanderBoletoStatus, SantanderDocumentKind, SantanderPaymentStatus,\n            SantanderPaymentsResponse, SantanderPaymentsSyncResponse, SantanderPixKeyType,\n            SantanderPixQRCodePaymentsResponse, SantanderPixQRCodeSyncResponse,\n            SantanderRefundResponse, SantanderRefundStatus, SantanderUpdateMetadataResponse,\n            SantanderVoidResponse, SantanderVoidStatus,\n        },\n    },\n    types::{RefreshTokenRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self as connector_utils, QrImage, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nimpl<T> From<(StringMajorUnit, T)> for SantanderRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nimpl TryFrom<&Option<common_utils::pii::SecretSerdeValue>> for SantanderMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        meta_data: &Option<common_utils::pii::SecretSerdeValue>,\n    ) -> Result<Self, Self::Error> {\n        let metadata = connector_utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nimpl TryFrom<&PaymentsUpdateMetadataRouterData> for SantanderBoletoUpdateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsUpdateMetadataRouterData) -> Result<Self, Self::Error> {\n        let santander_mca_metadata = SantanderMetadataObject::try_from(&item.connector_meta_data)?;\n\n        let boleto_mca_metadata = santander_mca_metadata\n            .boleto\n            .ok_or(errors::ConnectorError::NoConnectorMetaData)?;\n\n        let boleto_components = extract_boleto_components(&item.request.connector_transaction_id)?;\n\n        let due_date = Some(format_as_date_only(\n            item.request\n                .feature_metadata\n                .clone()\n                .and_then(|data| data.boleto_additional_details)\n                .and_then(|boleto_details| boleto_details.due_date),\n        )?);\n\n        Ok(Self {\n            covenant_code: boleto_mca_metadata.covenant_code,\n            bank_number: boleto_components.bank_number,\n            due_date,\n        })\n    }\n}\n\npub fn format_emv_field(id: &str, value: &str) -> String {\n    format!(\"{id}{:02}{value}\", value.len())\n}\n\nfn format_field(id: &str, value: &str) -> String {\n    format!(\"{}{:02}{}\", id, value.len(), value)\n}\n\npub fn generate_emv_string(\n    cidade: &str,\n    amount: &str,\n    country: enums::CountryAlpha2,\n    merchant_name: &str,\n    transaction_id: String,\n    location: String,\n) -> Result<String, errors::ConnectorError> {\n    // ID 00: Payload Format Indicator\n    let payload_format_indicator = format_field(\"00\", \"01\");\n\n    // ID 01: Point of Initiation Method\n    let point_of_initiation_method = format_field(\"01\", \"12\");\n\n    // ID 26: Merchant Account Information\n    let gui = format_field(\"00\", \"br.gov.bcb.pix\");\n    let loc = format_field(\"25\", &location);\n    let merchant_account_information = format_field(\"26\", &format!(\"{}{}\", gui, loc));\n\n    // ID 52: Merchant Category Code\n    let merchant_category_code = format_field(\"52\", \"0000\");\n\n    // ID 53: Transaction Currency\n    let transaction_currency = format_field(\"53\", \"986\");\n",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__santander__transformers.rs",
    "code": "use api_models::payments::{QrCodeInformation, VoucherNextStepData};\nuse common_enums::{\n    enums, AttemptStatus, BoletoDocumentKind, BoletoPaymentType, ExpiryType, PixKey,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, ValueExt},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse crc::{Algorithm, Crc};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankTransferData, BoletoVoucherData, PaymentMethodData, VoucherData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{PaymentsUpdateMetadataData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        PaymentsUpdateMetadataRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::{self},\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            Environment, SantanderAuthRequest, SantanderAuthType, SantanderBoletoCancelOperation,\n            SantanderBoletoCancelRequest, SantanderBoletoPaymentRequest,\n            SantanderBoletoUpdateRequest, SantanderDebtor, SantanderGrantType,\n            SantanderMetadataObject, SantanderPaymentRequest, SantanderPaymentsCancelRequest,\n            SantanderPixCancelRequest, SantanderPixDueDateCalendarRequest,\n            SantanderPixImmediateCalendarRequest, SantanderPixQRPaymentRequest,\n            SantanderPixRequestCalendar, SantanderRefundRequest, SantanderRouterData,\n            SantanderValue,\n        },\n        responses::{\n            Key, NsuComposite, Payer, SanatanderAccessTokenResponse, SanatanderTokenResponse,\n            SantanderAdditionalInfo, SantanderBoletoDocumentKind, SantanderBoletoPaymentType,\n            SantanderBoletoStatus, SantanderDocumentKind, SantanderPaymentStatus,\n            SantanderPaymentsResponse, SantanderPaymentsSyncResponse, SantanderPixKeyType,\n            SantanderPixQRCodePaymentsResponse, SantanderPixQRCodeSyncResponse,\n            SantanderRefundResponse, SantanderRefundStatus, SantanderUpdateMetadataResponse,\n            SantanderVoidResponse, SantanderVoidStatus,\n        },\n    },\n    types::{RefreshTokenRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self as connector_utils, QrImage, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nimpl<T> From<(StringMajorUnit, T)> for SantanderRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nimpl TryFrom<&Option<common_utils::pii::SecretSerdeValue>> for SantanderMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        meta_data: &Option<common_utils::pii::SecretSerdeValue>,\n    ) -> Result<Self, Self::Error> {\n        let metadata = connector_utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nimpl TryFrom<&PaymentsUpdateMetadataRouterData> for SantanderBoletoUpdateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsUpdateMetadataRouterData) -> Result<Self, Self::Error> {\n        let santander_mca_metadata = SantanderMetadataObject::try_from(&item.connector_meta_data)?;\n\n        let boleto_mca_metadata = santander_mca_metadata\n            .boleto\n            .ok_or(errors::ConnectorError::NoConnectorMetaData)?;\n\n        let boleto_components = extract_boleto_components(&item.request.connector_transaction_id)?;\n\n        let due_date = Some(format_as_date_only(\n            item.request\n                .feature_metadata\n                .clone()\n                .and_then(|data| data.boleto_additional_details)\n                .and_then(|boleto_details| boleto_details.due_date),\n        )?);\n\n        Ok(Self {\n            covenant_code: boleto_mca_metadata.covenant_code,\n            bank_number: boleto_components.bank_number,\n            due_date,\n        })\n    }\n}\n\npub fn format_emv_field(id: &str, value: &str) -> String {\n    format!(\"{id}{:02}{value}\", value.len())\n}\n\nfn format_field(id: &str, value: &str) -> String {\n    format!(\"{}{:02}{}\", id, value.len(), value)\n}\n\npub fn generate_emv_string(\n    cidade: &str,\n    amount: &str,\n    country: enums::CountryAlpha2,\n    merchant_name: &str,\n    transaction_id: String,\n    location: String,\n) -> Result<String, errors::ConnectorError> {\n    // ID 00: Payload Format Indicator\n    let payload_format_indicator = format_field(\"00\", \"01\");\n\n    // ID 01: Point of Initiation Method\n    let point_of_initiation_method = format_field(\"01\", \"12\");\n\n    // ID 26: Merchant Account Information\n    let gui = format_field(\"00\", \"br.gov.bcb.pix\");\n    let loc = format_field(\"25\", &location);\n    let merchant_account_information = format_field(\"26\", &format!(\"{}{}\", gui, loc));\n\n    // ID 52: Merchant Category Code\n    let merchant_category_code = format_field(\"52\", \"0000\");\n\n    // ID 53: Transaction Currency\n    let transaction_currency = format_field(\"53\", \"986\");\n",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use api_models::payments::{QrCodeInformation, VoucherNextStepData};\nuse common_enums::{\n    enums, AttemptStatus, BoletoDocumentKind, BoletoPaymentType, ExpiryType, PixKey,\n};\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{Encode, ValueExt},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse crc::{Algorithm, Crc};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{BankTransferData, BoletoVoucherData, PaymentMethodData, VoucherData},\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_request_types::{PaymentsUpdateMetadataData, ResponseId},\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        PaymentsUpdateMetadataRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::{self},\n};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::{\n    connectors::santander::{\n        requests::{\n            Environment, SantanderAuthRequest, SantanderAuthType, SantanderBoletoCancelOperation,\n            SantanderBoletoCancelRequest, SantanderBoletoPaymentRequest,\n            SantanderBoletoUpdateRequest, SantanderDebtor, SantanderGrantType,\n            SantanderMetadataObject, SantanderPaymentRequest, SantanderPaymentsCancelRequest,\n            SantanderPixCancelRequest, SantanderPixDueDateCalendarRequest,\n            SantanderPixImmediateCalendarRequest, SantanderPixQRPaymentRequest,\n            SantanderPixRequestCalendar, SantanderRefundRequest, SantanderRouterData,\n            SantanderValue,\n        },\n        responses::{\n            Key, NsuComposite, Payer, SanatanderAccessTokenResponse, SanatanderTokenResponse,\n            SantanderAdditionalInfo, SantanderBoletoDocumentKind, SantanderBoletoPaymentType,\n            SantanderBoletoStatus, SantanderDocumentKind, SantanderPaymentStatus,\n            SantanderPaymentsResponse, SantanderPaymentsSyncResponse, SantanderPixKeyType,\n            SantanderPixQRCodePaymentsResponse, SantanderPixQRCodeSyncResponse,\n            SantanderRefundResponse, SantanderRefundStatus, SantanderUpdateMetadataResponse,\n            SantanderVoidResponse, SantanderVoidStatus,\n        },\n    },\n    types::{RefreshTokenRouterData, RefundsResponseRouterData, ResponseRouterData},\n    utils::{self as connector_utils, QrImage, RouterData as _},\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nimpl<T> From<(StringMajorUnit, T)> for SantanderRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\nimpl TryFrom<&Option<common_utils::pii::SecretSerdeValue>> for SantanderMetadataObject {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        meta_data: &Option<common_utils::pii::SecretSerdeValue>,\n    ) -> Result<Self, Self::Error> {\n        let metadata = connector_utils::to_connector_meta_from_secret::<Self>(meta_data.clone())\n            .change_context(errors::ConnectorError::InvalidConnectorConfig {\n                config: \"metadata\",\n            })?;\n        Ok(metadata)\n    }\n}\n\nimpl TryFrom<&PaymentsUpdateMetadataRouterData> for SantanderBoletoUpdateRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &PaymentsUpdateMetadataRouterData) -> Result<Self, Self::Error> {\n        let santander_mca_metadata = SantanderMetadataObject::try_from(&item.connector_meta_data)?;\n\n        let boleto_mca_metadata = santander_mca_metadata\n            .boleto\n            .ok_or(errors::ConnectorError::NoConnectorMetaData)?;\n\n        let boleto_components = extract_boleto_components(&item.request.connector_transaction_id)?;\n\n        let due_date = Some(format_as_date_only(\n            item.request\n                .feature_metadata\n                .clone()\n                .and_then(|data| data.boleto_additional_details)\n                .and_then(|boleto_details| boleto_details.due_date),\n        )?);\n\n        Ok(Self {\n            covenant_code: boleto_mca_metadata.covenant_code,\n            bank_number: boleto_components.bank_number,\n            due_date,\n        })\n    }\n}\n\npub fn format_emv_field(id: &str, value: &str) -> String {\n    format!(\"{id}{:02}{value}\", value.len())\n}\n\nfn format_field(id: &str, value: &str) -> String {\n    format!(\"{}{:02}{}\", id, value.len(), value)\n}\n\npub fn generate_emv_string(\n    cidade: &str,\n    amount: &str,\n    country: enums::CountryAlpha2,\n    merchant_name: &str,\n    transaction_id: String,\n    location: String,\n) -> Result<String, errors::ConnectorError> {\n    // ID 00: Payload Format Indicator\n    let payload_format_indicator = format_field(\"00\", \"01\");\n\n    // ID 01: Point of Initiation Method\n    let point_of_initiation_method = format_field(\"01\", \"12\");\n\n    // ID 26: Merchant Account Information\n    let gui = format_field(\"00\", \"br.gov.bcb.pix\");\n    let loc = format_field(\"25\", &location);\n    let merchant_account_information = format_field(\"26\", &format!(\"{}{}\", gui, loc));\n\n    // ID 52: Merchant Category Code\n    let merchant_category_code = format_field(\"52\", \"0000\");\n\n    // ID 53: Transaction Currency\n    let transaction_currency = format_field(\"53\", \"986\");\n",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__santander__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__worldpay.rs",
    "code": "#[cfg(feature = \"payouts\")]\nmod payout_requests;\n#[cfg(feature = \"payouts\")]\nmod payout_response;\n#[cfg(feature = \"payouts\")]\npub mod payout_transformers;\nmod requests;\nmod response;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{payments::PaymentIdType, webhooks::IncomingWebhookEvent};\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundExecuteRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsVoidType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Mask;\n#[cfg(feature = \"payouts\")]\nuse payout_requests::WorldpayPayoutRequest;\n#[cfg(feature = \"payouts\")]\nuse payout_response::WorldpayPayoutResponse;\nuse requests::{\n    WorldpayCompleteAuthorizationRequest, WorldpayPartialRequest, WorldpayPaymentsRequest,\n};\nuse response::{\n    EventType, ResponseIdStr, WorldpayErrorResponse, WorldpayEventResponse,\n    WorldpayPaymentsResponse, WorldpayWebhookEventType, WorldpayWebhookTransactionId,\n    WP_CORRELATION_ID,\n};\nuse ring::hmac;\n\n#[cfg(feature = \"payouts\")]\nuse self::payout_transformers as worldpay_payout;\nuse self::transformers as worldpay;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, get_header_key_value, is_html_response_from_headers, is_mandate_supported,\n        ForeignTryFrom, PaymentMethodDataType, RefundsRequestData,\n    },\n};\n\n#[cfg(feature = \"payouts\")]\nconst WORLDPAY_PAYOUT_CONTENT_TYPE: &str = \"application/vnd.worldpay.payouts-v4+json\";\n\n#[derive(Clone)]\npub struct Worldpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Worldpay {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (headers::WP_API_VERSION.to_string(), \"2024-06-01\".into()),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut api_key);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Worldpay {\n    fn id(&self) -> &'static str {\n        \"worldpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__worldpay.rs",
    "code": "#[cfg(feature = \"payouts\")]\nmod payout_requests;\n#[cfg(feature = \"payouts\")]\nmod payout_response;\n#[cfg(feature = \"payouts\")]\npub mod payout_transformers;\nmod requests;\nmod response;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{payments::PaymentIdType, webhooks::IncomingWebhookEvent};\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundExecuteRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsVoidType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Mask;\n#[cfg(feature = \"payouts\")]\nuse payout_requests::WorldpayPayoutRequest;\n#[cfg(feature = \"payouts\")]\nuse payout_response::WorldpayPayoutResponse;\nuse requests::{\n    WorldpayCompleteAuthorizationRequest, WorldpayPartialRequest, WorldpayPaymentsRequest,\n};\nuse response::{\n    EventType, ResponseIdStr, WorldpayErrorResponse, WorldpayEventResponse,\n    WorldpayPaymentsResponse, WorldpayWebhookEventType, WorldpayWebhookTransactionId,\n    WP_CORRELATION_ID,\n};\nuse ring::hmac;\n\n#[cfg(feature = \"payouts\")]\nuse self::payout_transformers as worldpay_payout;\nuse self::transformers as worldpay;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, get_header_key_value, is_html_response_from_headers, is_mandate_supported,\n        ForeignTryFrom, PaymentMethodDataType, RefundsRequestData,\n    },\n};\n\n#[cfg(feature = \"payouts\")]\nconst WORLDPAY_PAYOUT_CONTENT_TYPE: &str = \"application/vnd.worldpay.payouts-v4+json\";\n\n#[derive(Clone)]\npub struct Worldpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Worldpay {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (headers::WP_API_VERSION.to_string(), \"2024-06-01\".into()),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut api_key);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Worldpay {\n    fn id(&self) -> &'static str {\n        \"worldpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "#[cfg(feature = \"payouts\")]\nmod payout_requests;\n#[cfg(feature = \"payouts\")]\nmod payout_response;\n#[cfg(feature = \"payouts\")]\npub mod payout_transformers;\nmod requests;\nmod response;\npub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse api_models::{payments::PaymentIdType, webhooks::IncomingWebhookEvent};\nuse common_enums::{enums, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundExecuteRouterData,\n        RefundSyncRouterData, RefundsRouterData, SetupMandateRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, PaymentsVoidType, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Mask;\n#[cfg(feature = \"payouts\")]\nuse payout_requests::WorldpayPayoutRequest;\n#[cfg(feature = \"payouts\")]\nuse payout_response::WorldpayPayoutResponse;\nuse requests::{\n    WorldpayCompleteAuthorizationRequest, WorldpayPartialRequest, WorldpayPaymentsRequest,\n};\nuse response::{\n    EventType, ResponseIdStr, WorldpayErrorResponse, WorldpayEventResponse,\n    WorldpayPaymentsResponse, WorldpayWebhookEventType, WorldpayWebhookTransactionId,\n    WP_CORRELATION_ID,\n};\nuse ring::hmac;\n\n#[cfg(feature = \"payouts\")]\nuse self::payout_transformers as worldpay_payout;\nuse self::transformers as worldpay;\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        convert_amount, get_header_key_value, is_html_response_from_headers, is_mandate_supported,\n        ForeignTryFrom, PaymentMethodDataType, RefundsRequestData,\n    },\n};\n\n#[cfg(feature = \"payouts\")]\nconst WORLDPAY_PAYOUT_CONTENT_TYPE: &str = \"application/vnd.worldpay.payouts-v4+json\";\n\n#[derive(Clone)]\npub struct Worldpay {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Worldpay {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Worldpay\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut headers = vec![\n            (\n                headers::ACCEPT.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (headers::WP_API_VERSION.to_string(), \"2024-06-01\".into()),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        headers.append(&mut api_key);\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Worldpay {\n    fn id(&self) -> &'static str {\n        \"worldpay\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpay.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__nomupay.rs",
    "code": "pub mod transformers;\n\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    pii,\n    request::{Method, RequestContent},\n};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Request, RequestBuilder},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoRecipientAccount,\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types;\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse josekit::{\n    jws::{self, JwsHeader, ES256},\n    jwt::{self, JwtPayload},\n    Map, Value,\n};\nuse masking::{ExposeInterface, Mask};\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\nuse serde_json::json;\nuse transformers as nomupay;\n\nuse crate::{constants::headers, utils};\n#[cfg(feature = \"payouts\")]\nuse crate::{types::ResponseRouterData, utils::RouterData as RouterDataTrait};\n\n#[derive(Clone)]\npub struct Nomupay {\n    #[cfg(feature = \"payouts\")]\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Nomupay {\n    pub fn new() -> &'static Self {\n        &Self {\n            #[cfg(feature = \"payouts\")]\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nfn get_private_key(\n    metadata: &Option<pii::SecretSerdeValue>,\n) -> Result<String, errors::ConnectorError> {\n    match nomupay::NomupayMetadata::try_from(metadata.as_ref()) {\n        Ok(nomupay_metadata) => Ok(nomupay_metadata.private_key.expose()),\n        Err(_e) => Err(errors::ConnectorError::NoConnectorMetaData),\n    }\n}\n\nfn box_to_jwt_payload(\n    body: Box<dyn masking::ErasedMaskSerialize + Send>,\n) -> CustomResult<JwtPayload, errors::ConnectorError> {\n    let str_result = serde_json::to_string(&body)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    let parsed_json: Map<String, Value> = serde_json::from_str(&str_result)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    let jwt_payload = JwtPayload::from_map(parsed_json)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    Ok(jwt_payload)\n}\n\nfn get_signature(\n    metadata: &Option<pii::SecretSerdeValue>,\n    auth: nomupay::NomupayAuthType,\n    body: RequestContent,\n    method: &str,\n    path: String,\n) -> CustomResult<String, errors::ConnectorError> {\n    match body {\n        RequestContent::Json(masked_json) => {\n            let expiration_time = SystemTime::now() + Duration::from_secs(4 * 60);\n            let expires_in = match expiration_time.duration_since(UNIX_EPOCH) {\n                Ok(duration) => duration.as_secs(),\n                Err(_e) => 0,\n            };\n\n            let mut option_map = Map::new();\n            option_map.insert(\"alg\".to_string(), json!(format!(\"ES256\")));\n            option_map.insert(\"aud\".to_string(), json!(format!(\"{} {}\", method, path)));\n            option_map.insert(\"exp\".to_string(), json!(expires_in));\n            option_map.insert(\"kid\".to_string(), json!(auth.kid));\n\n            let header = JwsHeader::from_map(option_map)\n                .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n            let payload = match method {\n                \"GET\" => JwtPayload::new(),\n                _ => box_to_jwt_payload(masked_json)\n                    .change_context(errors::ConnectorError::ProcessingStepFailed(None))?,\n            };\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nomupay.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__nomupay.rs",
    "code": "pub mod transformers;\n\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    pii,\n    request::{Method, RequestContent},\n};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Request, RequestBuilder},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoRecipientAccount,\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types;\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse josekit::{\n    jws::{self, JwsHeader, ES256},\n    jwt::{self, JwtPayload},\n    Map, Value,\n};\nuse masking::{ExposeInterface, Mask};\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\nuse serde_json::json;\nuse transformers as nomupay;\n\nuse crate::{constants::headers, utils};\n#[cfg(feature = \"payouts\")]\nuse crate::{types::ResponseRouterData, utils::RouterData as RouterDataTrait};\n\n#[derive(Clone)]\npub struct Nomupay {\n    #[cfg(feature = \"payouts\")]\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Nomupay {\n    pub fn new() -> &'static Self {\n        &Self {\n            #[cfg(feature = \"payouts\")]\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nfn get_private_key(\n    metadata: &Option<pii::SecretSerdeValue>,\n) -> Result<String, errors::ConnectorError> {\n    match nomupay::NomupayMetadata::try_from(metadata.as_ref()) {\n        Ok(nomupay_metadata) => Ok(nomupay_metadata.private_key.expose()),\n        Err(_e) => Err(errors::ConnectorError::NoConnectorMetaData),\n    }\n}\n\nfn box_to_jwt_payload(\n    body: Box<dyn masking::ErasedMaskSerialize + Send>,\n) -> CustomResult<JwtPayload, errors::ConnectorError> {\n    let str_result = serde_json::to_string(&body)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    let parsed_json: Map<String, Value> = serde_json::from_str(&str_result)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    let jwt_payload = JwtPayload::from_map(parsed_json)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    Ok(jwt_payload)\n}\n\nfn get_signature(\n    metadata: &Option<pii::SecretSerdeValue>,\n    auth: nomupay::NomupayAuthType,\n    body: RequestContent,\n    method: &str,\n    path: String,\n) -> CustomResult<String, errors::ConnectorError> {\n    match body {\n        RequestContent::Json(masked_json) => {\n            let expiration_time = SystemTime::now() + Duration::from_secs(4 * 60);\n            let expires_in = match expiration_time.duration_since(UNIX_EPOCH) {\n                Ok(duration) => duration.as_secs(),\n                Err(_e) => 0,\n            };\n\n            let mut option_map = Map::new();\n            option_map.insert(\"alg\".to_string(), json!(format!(\"ES256\")));\n            option_map.insert(\"aud\".to_string(), json!(format!(\"{} {}\", method, path)));\n            option_map.insert(\"exp\".to_string(), json!(expires_in));\n            option_map.insert(\"kid\".to_string(), json!(auth.kid));\n\n            let header = JwsHeader::from_map(option_map)\n                .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n            let payload = match method {\n                \"GET\" => JwtPayload::new(),\n                _ => box_to_jwt_payload(masked_json)\n                    .change_context(errors::ConnectorError::ProcessingStepFailed(None))?,\n            };\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nomupay.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    pii,\n    request::{Method, RequestContent},\n};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Request, RequestBuilder},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::{\n        PoCancel, PoCreate, PoEligibility, PoFulfill, PoQuote, PoRecipient, PoRecipientAccount,\n        PoSync,\n    },\n    router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData,\n    types::PayoutsRouterData,\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types;\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks,\n};\nuse josekit::{\n    jws::{self, JwsHeader, ES256},\n    jwt::{self, JwtPayload},\n    Map, Value,\n};\nuse masking::{ExposeInterface, Mask};\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\nuse serde_json::json;\nuse transformers as nomupay;\n\nuse crate::{constants::headers, utils};\n#[cfg(feature = \"payouts\")]\nuse crate::{types::ResponseRouterData, utils::RouterData as RouterDataTrait};\n\n#[derive(Clone)]\npub struct Nomupay {\n    #[cfg(feature = \"payouts\")]\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Nomupay {\n    pub fn new() -> &'static Self {\n        &Self {\n            #[cfg(feature = \"payouts\")]\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nfn get_private_key(\n    metadata: &Option<pii::SecretSerdeValue>,\n) -> Result<String, errors::ConnectorError> {\n    match nomupay::NomupayMetadata::try_from(metadata.as_ref()) {\n        Ok(nomupay_metadata) => Ok(nomupay_metadata.private_key.expose()),\n        Err(_e) => Err(errors::ConnectorError::NoConnectorMetaData),\n    }\n}\n\nfn box_to_jwt_payload(\n    body: Box<dyn masking::ErasedMaskSerialize + Send>,\n) -> CustomResult<JwtPayload, errors::ConnectorError> {\n    let str_result = serde_json::to_string(&body)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    let parsed_json: Map<String, Value> = serde_json::from_str(&str_result)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    let jwt_payload = JwtPayload::from_map(parsed_json)\n        .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n    Ok(jwt_payload)\n}\n\nfn get_signature(\n    metadata: &Option<pii::SecretSerdeValue>,\n    auth: nomupay::NomupayAuthType,\n    body: RequestContent,\n    method: &str,\n    path: String,\n) -> CustomResult<String, errors::ConnectorError> {\n    match body {\n        RequestContent::Json(masked_json) => {\n            let expiration_time = SystemTime::now() + Duration::from_secs(4 * 60);\n            let expires_in = match expiration_time.duration_since(UNIX_EPOCH) {\n                Ok(duration) => duration.as_secs(),\n                Err(_e) => 0,\n            };\n\n            let mut option_map = Map::new();\n            option_map.insert(\"alg\".to_string(), json!(format!(\"ES256\")));\n            option_map.insert(\"aud\".to_string(), json!(format!(\"{} {}\", method, path)));\n            option_map.insert(\"exp\".to_string(), json!(expires_in));\n            option_map.insert(\"kid\".to_string(), json!(auth.kid));\n\n            let header = JwsHeader::from_map(option_map)\n                .change_context(errors::ConnectorError::ProcessingStepFailed(None))?;\n\n            let payload = match method {\n                \"GET\" => JwtPayload::new(),\n                _ => box_to_jwt_payload(masked_json)\n                    .change_context(errors::ConnectorError::ProcessingStepFailed(None))?,\n            };\n",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nomupay.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus, CaptureMethod, CountryAlpha2};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::ConnectorAuthType,\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    connectors::paybox::transformers::parse_url_encoded_to_struct,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        BrowserInformationData, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\npub struct GetnetRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GetnetRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Amount {\n    pub value: FloatMajorUnit,\n    pub currency: enums::Currency,\n}\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Address {\n    #[serde(rename = \"street1\")]\n    pub street1: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct AccountHolder {\n    #[serde(rename = \"first-name\")]\n    pub first_name: Option<Secret<String>>,\n    #[serde(rename = \"last-name\")]\n    pub last_name: Option<Secret<String>>,\n    pub email: Option<Email>,\n    pub phone: Option<Secret<String>>,\n    pub address: Option<Address>,\n}\n\n#[derive(Default, Debug, Serialize, PartialEq)]\npub struct Card {\n    #[serde(rename = \"account-number\")]\n    pub account_number: CardNumber,\n    #[serde(rename = \"expiration-month\")]\n    pub expiration_month: Secret<String>,\n    #[serde(rename = \"expiration-year\")]\n    pub expiration_year: Secret<String>,\n    #[serde(rename = \"card-security-code\")]\n    pub card_security_code: Secret<String>,\n    #[serde(rename = \"card-type\")]\n    pub card_type: String,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum GetnetPaymentMethods {\n    CreditCard,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct PaymentMethod {\n    pub name: GetnetPaymentMethods,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Notification {\n    pub url: Option<String>,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct PaymentMethodContainer {\n    #[serde(rename = \"payment-method\")]\n    pub payment_method: Vec<PaymentMethod>,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum NotificationFormat {\n    #[serde(rename = \"application/json-signed\")]\n    JsonSigned,\n    #[serde(rename = \"application/json\")]\n    Json,\n    #[serde(rename = \"application/xml\")]\n    Xml,\n    #[serde(rename = \"application/html\")]\n    Html,\n    #[serde(rename = \"application/x-www-form-urlencoded\")]\n    Urlencoded,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct NotificationContainer {\n    pub notification: Vec<Notification>,\n    pub format: NotificationFormat,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]\npub struct MerchantAccountId {\n    pub value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus, CaptureMethod, CountryAlpha2};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::ConnectorAuthType,\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    connectors::paybox::transformers::parse_url_encoded_to_struct,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        BrowserInformationData, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\npub struct GetnetRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GetnetRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Amount {\n    pub value: FloatMajorUnit,\n    pub currency: enums::Currency,\n}\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Address {\n    #[serde(rename = \"street1\")]\n    pub street1: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct AccountHolder {\n    #[serde(rename = \"first-name\")]\n    pub first_name: Option<Secret<String>>,\n    #[serde(rename = \"last-name\")]\n    pub last_name: Option<Secret<String>>,\n    pub email: Option<Email>,\n    pub phone: Option<Secret<String>>,\n    pub address: Option<Address>,\n}\n\n#[derive(Default, Debug, Serialize, PartialEq)]\npub struct Card {\n    #[serde(rename = \"account-number\")]\n    pub account_number: CardNumber,\n    #[serde(rename = \"expiration-month\")]\n    pub expiration_month: Secret<String>,\n    #[serde(rename = \"expiration-year\")]\n    pub expiration_year: Secret<String>,\n    #[serde(rename = \"card-security-code\")]\n    pub card_security_code: Secret<String>,\n    #[serde(rename = \"card-type\")]\n    pub card_type: String,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum GetnetPaymentMethods {\n    CreditCard,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct PaymentMethod {\n    pub name: GetnetPaymentMethods,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Notification {\n    pub url: Option<String>,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct PaymentMethodContainer {\n    #[serde(rename = \"payment-method\")]\n    pub payment_method: Vec<PaymentMethod>,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum NotificationFormat {\n    #[serde(rename = \"application/json-signed\")]\n    JsonSigned,\n    #[serde(rename = \"application/json\")]\n    Json,\n    #[serde(rename = \"application/xml\")]\n    Xml,\n    #[serde(rename = \"application/html\")]\n    Html,\n    #[serde(rename = \"application/x-www-form-urlencoded\")]\n    Urlencoded,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct NotificationContainer {\n    pub notification: Vec<Notification>,\n    pub format: NotificationFormat,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]\npub struct MerchantAccountId {\n    pub value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use api_models::webhooks::IncomingWebhookEvent;\nuse base64::Engine;\nuse cards::CardNumber;\nuse common_enums::{enums, AttemptStatus, CaptureMethod, CountryAlpha2};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    pii::{Email, IpAddress},\n    types::FloatMajorUnit,\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::ConnectorAuthType,\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    connectors::paybox::transformers::parse_url_encoded_to_struct,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    utils::{\n        BrowserInformationData, PaymentsAuthorizeRequestData, PaymentsSyncRequestData,\n        RouterData as _,\n    },\n};\n\npub struct GetnetRouterData<T> {\n    pub amount: FloatMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(FloatMajorUnit, T)> for GetnetRouterData<T> {\n    fn from((amount, item): (FloatMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Amount {\n    pub value: FloatMajorUnit,\n    pub currency: enums::Currency,\n}\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Address {\n    #[serde(rename = \"street1\")]\n    pub street1: Option<Secret<String>>,\n    pub city: Option<String>,\n    pub state: Option<Secret<String>>,\n    pub country: Option<CountryAlpha2>,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct AccountHolder {\n    #[serde(rename = \"first-name\")]\n    pub first_name: Option<Secret<String>>,\n    #[serde(rename = \"last-name\")]\n    pub last_name: Option<Secret<String>>,\n    pub email: Option<Email>,\n    pub phone: Option<Secret<String>>,\n    pub address: Option<Address>,\n}\n\n#[derive(Default, Debug, Serialize, PartialEq)]\npub struct Card {\n    #[serde(rename = \"account-number\")]\n    pub account_number: CardNumber,\n    #[serde(rename = \"expiration-month\")]\n    pub expiration_month: Secret<String>,\n    #[serde(rename = \"expiration-year\")]\n    pub expiration_year: Secret<String>,\n    #[serde(rename = \"card-security-code\")]\n    pub card_security_code: Secret<String>,\n    #[serde(rename = \"card-type\")]\n    pub card_type: String,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum GetnetPaymentMethods {\n    CreditCard,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct PaymentMethod {\n    pub name: GetnetPaymentMethods,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct Notification {\n    pub url: Option<String>,\n}\n\n#[derive(Default, Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct PaymentMethodContainer {\n    #[serde(rename = \"payment-method\")]\n    pub payment_method: Vec<PaymentMethod>,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum NotificationFormat {\n    #[serde(rename = \"application/json-signed\")]\n    JsonSigned,\n    #[serde(rename = \"application/json\")]\n    Json,\n    #[serde(rename = \"application/xml\")]\n    Xml,\n    #[serde(rename = \"application/html\")]\n    Html,\n    #[serde(rename = \"application/x-www-form-urlencoded\")]\n    Urlencoded,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\npub struct NotificationContainer {\n    pub notification: Vec<Notification>,\n    pub format: NotificationFormat,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]\npub struct MerchantAccountId {\n    pub value: Secret<String>,\n}\n\n#[derive(Debug, Serialize, PartialEq)]",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__getnet__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for list_by_merchant_id",
    "code": "diff --git a/crates/api_models/src/customers.rs b/crates/api_models/src/customers.rs\nindex 19016e292a8..62fd000ddb8 100644\n--- a/crates/api_models/src/customers.rs\n+++ b/crates/api_models/src/customers.rs\n@@ -52,6 +52,8 @@ pub struct CustomerListRequest {\n     /// Limit\n     #[schema(example = 32)]\n     pub limit: Option<u16>,\n+    /// Unique identifier for a customer\n+    pub customer_id: Option<id_type::CustomerId>,\n }\n \n #[cfg(feature = \"v1\")]\ndiff --git a/crates/diesel_models/src/query/customers.rs b/crates/diesel_models/src/query/customers.rs\nindex def8d77fe7a..a6121d408c2 100644\n--- a/crates/diesel_models/src/query/customers.rs\n+++ b/crates/diesel_models/src/query/customers.rs\n@@ -20,6 +20,7 @@ impl CustomerNew {\n pub struct CustomerListConstraints {\n     pub limit: i64,\n     pub offset: Option<i64>,\n+    pub customer_id: Option<id_type::CustomerId>,\n }\n \n impl Customer {\n@@ -54,19 +55,66 @@ impl Customer {\n         generics::generic_find_by_id::<<Self as HasTable>::Table, _, _>(conn, id.to_owned()).await\n     }\n \n+    #[cfg(feature = \"v1\")]\n     pub async fn list_by_merchant_id(\n         conn: &PgPooledConn,\n         merchant_id: &id_type::MerchantId,\n         constraints: CustomerListConstraints,\n     ) -> StorageResult<Vec<Self>> {\n-        generics::generic_filter::<<Self as HasTable>::Table, _, _, _>(\n-            conn,\n-            dsl::merchant_id.eq(merchant_id.to_owned()),\n-            Some(constraints.limit),\n-            constraints.offset,\n-            Some(dsl::created_at),\n-        )\n-        .await\n+        if let Some(customer_id) = constraints.customer_id {\n+            let predicate = dsl::merchant_id\n+                .eq(merchant_id.clone())\n+                .and(dsl::customer_id.eq(customer_id));\n+            generics::generic_filter::<<Self as HasTable>::Table, _, _, Self>(\n+                conn,\n+                predicate,\n+                Some(constraints.limit),\n+                constraints.offset,\n+                Some(dsl::created_at),\n+            )\n+            .await\n+        } else {\n+            let predicate = dsl::merchant_id.eq(merchant_id.clone());\n+            generics::generic_filter::<<Self as HasTable>::Table, _, _, Self>(\n+                conn,\n+                predicate,\n+                Some(constraints.limit),\n+                constraints.offset,\n+                Some(dsl::created_at),\n+            )\n+            .await\n+        }\n+    }\n+\n+    #[cfg(feature = \"v2\")]\n+    pub async fn list_by_merchant_id(\n+        conn: &PgPooledConn,\n+        merchant_id: &id_type::MerchantId,\n+        constraints: CustomerListConstraints,\n+    ) -> StorageResult<Vec<Self>> {\n+        if let Some(customer_id) = constraints.customer_id {\n+            let predicate = dsl::merchant_id\n+                .eq(merchant_id.clone())\n+                .and(dsl::merchant_reference_id.eq(customer_id));\n+            generics::generic_filter::<<Self as HasTable>::Table, _, _, Self>(\n+                conn,\n+                predicate,\n+                Some(constraints.limit),\n+                constraints.offset,\n+                Some(dsl::created_at),\n+            )\n+            .await\n+        } else {\n+            let predicate = dsl::merchant_id.eq(merchant_id.clone());\n+            generics::generic_filter::<<Self as HasTable>::Table, _, _, Self>(\n+                conn,\n+                predicate,\n+                Some(constraints.limit),\n+                constraints.offset,\n+                Some(dsl::created_at),\n+            )\n+            .await\n+        }\n     }\n \n     #[cfg(feature = \"v2\")]\ndiff --git a/crates/hyperswitch_domain_models/src/customer.rs b/crates/hyperswitch_domain_models/src/customer.rs\nindex 5a88cb6cd48..720296cdcac 100644\n--- a/crates/hyperswitch_domain_models/src/customer.rs\n+++ b/crates/hyperswitch_domain_models/src/customer.rs\n@@ -538,6 +538,7 @@ impl From<CustomerUpdate> for CustomerUpdateInternal {\n pub struct CustomerListConstraints {\n     pub limit: u16,\n     pub offset: Option<u32>,\n+    pub customer_id: Option<id_type::CustomerId>,\n }\n \n impl From<CustomerListConstraints> for query::CustomerListConstraints {\n@@ -545,6 +546,7 @@ impl From<CustomerListConstraints> for query::CustomerListConstraints {\n         Self {\n             limit: i64::from(value.limit),\n             offset: value.offset.map(i64::from),\n+            customer_id: value.customer_id,\n         }\n     }\n }\ndiff --git a/crates/router/src/core/customers.rs b/crates/router/src/core/customers.rs\nindex ffc44781037..09f12d62ba0 100644\n--- a/crates/router/src/core/customers.rs\n+++ b/crates/router/src/core/customers.rs\n@@ -590,6 +590,7 @@ pub async fn list_customers(\n             .limit\n             .unwrap_or(crate::consts::DEFAULT_LIST_API_LIMIT),\n         offset: request.offset,\n+        customer_id: request.customer_id,\n     };\n \n     let domain_customers = db\ndiff --git a/crates/router/src/core/locker_migration.rs b/crates/router/src/core/locker_migration.rs\nindex e2680666e4d..bea3ff4e58e 100644\n--- a/crates/router/src/core/locker_migration.rs\n+++ b/crates/router/src/core/locker_migration.rs\n@@ -54,6 +54,7 @@ pub async fn rust_locker_migration(\n     let constraints = CustomerListConstraints {\n         limit: u16::MAX,\n         offset: None,",
    "function_name": "list_by_merchant_id",
    "file": "unknown_file",
    "source": "issue_pr_filenames"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__mollie.rs",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, PeekInterface};\nuse transformers as mollie;\n\n// use self::mollie::{webhook_headers, MollieWebhookBodyEventType};\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Mollie {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Mollie {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mollie {}\nimpl api::PaymentSession for Mollie {}\nimpl api::ConnectorAccessToken for Mollie {}\nimpl api::MandateSetup for Mollie {}\nimpl api::PaymentToken for Mollie {}\nimpl api::PaymentAuthorize for Mollie {}\nimpl api::PaymentsCompleteAuthorize for Mollie {}\nimpl api::PaymentSync for Mollie {}\nimpl api::PaymentCapture for Mollie {}\nimpl api::PaymentVoid for Mollie {}\nimpl api::Refund for Mollie {}\nimpl api::RefundExecute for Mollie {}\nimpl api::RefundSync for Mollie {}\nimpl api::ConnectorCustomer for Mollie {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Mollie\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.get_auth_header(&req.connector_auth_type)\n    }\n}\n\nimpl ConnectorCommon for Mollie {\n    fn id(&self) -> &'static str {\n        \"mollie\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.mollie.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = mollie::MollieAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: mollie::MollieErrorResponse = res\n            .response\n            .parse_struct(\"MollieErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: response.status,\n            code: response\n                .title",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__mollie.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__mollie.rs",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, PeekInterface};\nuse transformers as mollie;\n\n// use self::mollie::{webhook_headers, MollieWebhookBodyEventType};\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Mollie {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Mollie {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mollie {}\nimpl api::PaymentSession for Mollie {}\nimpl api::ConnectorAccessToken for Mollie {}\nimpl api::MandateSetup for Mollie {}\nimpl api::PaymentToken for Mollie {}\nimpl api::PaymentAuthorize for Mollie {}\nimpl api::PaymentsCompleteAuthorize for Mollie {}\nimpl api::PaymentSync for Mollie {}\nimpl api::PaymentCapture for Mollie {}\nimpl api::PaymentVoid for Mollie {}\nimpl api::Refund for Mollie {}\nimpl api::RefundExecute for Mollie {}\nimpl api::RefundSync for Mollie {}\nimpl api::ConnectorCustomer for Mollie {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Mollie\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.get_auth_header(&req.connector_auth_type)\n    }\n}\n\nimpl ConnectorCommon for Mollie {\n    fn id(&self) -> &'static str {\n        \"mollie\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.mollie.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = mollie::MollieAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: mollie::MollieErrorResponse = res\n            .response\n            .parse_struct(\"MollieErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: response.status,\n            code: response\n                .title",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__mollie.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize, CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, ConnectorCustomerData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n        SetupMandateRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::{Mask, PeekInterface};\nuse transformers as mollie;\n\n// use self::mollie::{webhook_headers, MollieWebhookBodyEventType};\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, is_mandate_supported, PaymentMethodDataType},\n};\n\n#[derive(Clone)]\npub struct Mollie {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Mollie {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mollie {}\nimpl api::PaymentSession for Mollie {}\nimpl api::ConnectorAccessToken for Mollie {}\nimpl api::MandateSetup for Mollie {}\nimpl api::PaymentToken for Mollie {}\nimpl api::PaymentAuthorize for Mollie {}\nimpl api::PaymentsCompleteAuthorize for Mollie {}\nimpl api::PaymentSync for Mollie {}\nimpl api::PaymentCapture for Mollie {}\nimpl api::PaymentVoid for Mollie {}\nimpl api::Refund for Mollie {}\nimpl api::RefundExecute for Mollie {}\nimpl api::RefundSync for Mollie {}\nimpl api::ConnectorCustomer for Mollie {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Mollie\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.get_auth_header(&req.connector_auth_type)\n    }\n}\n\nimpl ConnectorCommon for Mollie {\n    fn id(&self) -> &'static str {\n        \"mollie\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.mollie.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = mollie::MollieAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: mollie::MollieErrorResponse = res\n            .response\n            .parse_struct(\"MollieErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_error_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        Ok(ErrorResponse {\n            status_code: response.status,\n            code: response\n                .title",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__mollie.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__thunes.rs",
    "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as thunes;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Thunes {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Thunes {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Thunes {}\nimpl api::PaymentSession for Thunes {}\nimpl api::ConnectorAccessToken for Thunes {}\nimpl api::MandateSetup for Thunes {}\nimpl api::PaymentAuthorize for Thunes {}\nimpl api::PaymentSync for Thunes {}\nimpl api::PaymentCapture for Thunes {}\nimpl api::PaymentVoid for Thunes {}\nimpl api::Refund for Thunes {}\nimpl api::RefundExecute for Thunes {}\nimpl api::RefundSync for Thunes {}\nimpl api::PaymentToken for Thunes {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Thunes\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Thunes\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Thunes {\n    fn id(&self) -> &'static str {\n        \"thunes\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.thunes.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = thunes::ThunesAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: thunes::ThunesErrorResponse = res\n            .response\n            .parse_struct(\"ThunesErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__thunes.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__thunes.rs",
    "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as thunes;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Thunes {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Thunes {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Thunes {}\nimpl api::PaymentSession for Thunes {}\nimpl api::ConnectorAccessToken for Thunes {}\nimpl api::MandateSetup for Thunes {}\nimpl api::PaymentAuthorize for Thunes {}\nimpl api::PaymentSync for Thunes {}\nimpl api::PaymentCapture for Thunes {}\nimpl api::PaymentVoid for Thunes {}\nimpl api::Refund for Thunes {}\nimpl api::RefundExecute for Thunes {}\nimpl api::RefundSync for Thunes {}\nimpl api::PaymentToken for Thunes {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Thunes\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Thunes\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Thunes {\n    fn id(&self) -> &'static str {\n        \"thunes\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.thunes.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = thunes::ThunesAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: thunes::ThunesErrorResponse = res\n            .response\n            .parse_struct(\"ThunesErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__thunes.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as thunes;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Thunes {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Thunes {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Thunes {}\nimpl api::PaymentSession for Thunes {}\nimpl api::ConnectorAccessToken for Thunes {}\nimpl api::MandateSetup for Thunes {}\nimpl api::PaymentAuthorize for Thunes {}\nimpl api::PaymentSync for Thunes {}\nimpl api::PaymentCapture for Thunes {}\nimpl api::PaymentVoid for Thunes {}\nimpl api::Refund for Thunes {}\nimpl api::RefundExecute for Thunes {}\nimpl api::RefundSync for Thunes {}\nimpl api::PaymentToken for Thunes {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Thunes\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Thunes\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Thunes {\n    fn id(&self) -> &'static str {\n        \"thunes\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.thunes.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = thunes::ThunesAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: thunes::ThunesErrorResponse = res\n            .response\n            .parse_struct(\"ThunesErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__thunes.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__dwolla.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::engine::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, PaymentMethodToken as PMT, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, ConnectorInfo, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as dwolla;\nuse transformers::extract_token_from_body;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, get_http_header, RefundsRequestData, RouterData as RD},\n};\n\n#[derive(Clone)]\npub struct Dwolla {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Dwolla {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::ConnectorCustomer for Dwolla {}\nimpl api::Payment for Dwolla {}\nimpl api::PaymentSession for Dwolla {}\nimpl api::ConnectorAccessToken for Dwolla {}\nimpl api::MandateSetup for Dwolla {}\nimpl api::PaymentAuthorize for Dwolla {}\nimpl api::PaymentSync for Dwolla {}\nimpl api::PaymentCapture for Dwolla {}\nimpl api::PaymentVoid for Dwolla {}\nimpl api::Refund for Dwolla {}\nimpl api::RefundExecute for Dwolla {}\nimpl api::RefundSync for Dwolla {}\nimpl api::PaymentToken for Dwolla {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Dwolla\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.common_get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                self.common_get_content_type().to_string().into(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", access_token.token.expose()).into_masked(),\n            ),\n            (\n                headers::IDEMPOTENCY_KEY.to_string(),\n                uuid::Uuid::new_v4().to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Dwolla {\n    fn id(&self) -> &'static str {\n        \"dwolla\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/vnd.dwolla.v1.hal+json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.dwolla.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__dwolla.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__dwolla.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::engine::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, PaymentMethodToken as PMT, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, ConnectorInfo, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as dwolla;\nuse transformers::extract_token_from_body;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, get_http_header, RefundsRequestData, RouterData as RD},\n};\n\n#[derive(Clone)]\npub struct Dwolla {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Dwolla {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::ConnectorCustomer for Dwolla {}\nimpl api::Payment for Dwolla {}\nimpl api::PaymentSession for Dwolla {}\nimpl api::ConnectorAccessToken for Dwolla {}\nimpl api::MandateSetup for Dwolla {}\nimpl api::PaymentAuthorize for Dwolla {}\nimpl api::PaymentSync for Dwolla {}\nimpl api::PaymentCapture for Dwolla {}\nimpl api::PaymentVoid for Dwolla {}\nimpl api::Refund for Dwolla {}\nimpl api::RefundExecute for Dwolla {}\nimpl api::RefundSync for Dwolla {}\nimpl api::PaymentToken for Dwolla {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Dwolla\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.common_get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                self.common_get_content_type().to_string().into(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", access_token.token.expose()).into_masked(),\n            ),\n            (\n                headers::IDEMPOTENCY_KEY.to_string(),\n                uuid::Uuid::new_v4().to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Dwolla {\n    fn id(&self) -> &'static str {\n        \"dwolla\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/vnd.dwolla.v1.hal+json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.dwolla.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__dwolla.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::engine::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ErrorResponse, PaymentMethodToken as PMT, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CreateConnectorCustomer,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, ResponseId, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorCustomerResponseData, ConnectorInfo, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsSyncRouterData,\n        RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData, TokenizationRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, RefreshTokenType, Response, TokenizationType},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse transformers as dwolla;\nuse transformers::extract_token_from_body;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{convert_amount, get_http_header, RefundsRequestData, RouterData as RD},\n};\n\n#[derive(Clone)]\npub struct Dwolla {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Dwolla {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::ConnectorCustomer for Dwolla {}\nimpl api::Payment for Dwolla {}\nimpl api::PaymentSession for Dwolla {}\nimpl api::ConnectorAccessToken for Dwolla {}\nimpl api::MandateSetup for Dwolla {}\nimpl api::PaymentAuthorize for Dwolla {}\nimpl api::PaymentSync for Dwolla {}\nimpl api::PaymentCapture for Dwolla {}\nimpl api::PaymentVoid for Dwolla {}\nimpl api::Refund for Dwolla {}\nimpl api::RefundExecute for Dwolla {}\nimpl api::RefundSync for Dwolla {}\nimpl api::PaymentToken for Dwolla {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Dwolla\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let access_token = req\n            .access_token\n            .clone()\n            .ok_or(errors::ConnectorError::FailedToObtainAuthType)?;\n        let header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.common_get_content_type().to_string().into(),\n            ),\n            (\n                headers::ACCEPT.to_string(),\n                self.common_get_content_type().to_string().into(),\n            ),\n            (\n                headers::AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", access_token.token.expose()).into_masked(),\n            ),\n            (\n                headers::IDEMPOTENCY_KEY.to_string(),\n                uuid::Uuid::new_v4().to_string().into(),\n            ),\n        ];\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Dwolla {\n    fn id(&self) -> &'static str {\n        \"dwolla\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/vnd.dwolla.v1.hal+json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.dwolla.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__dwolla.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__core__relay.rs",
    "code": "use std::marker::PhantomData;\n\nuse api_models::relay as relay_api_models;\nuse async_trait::async_trait;\nuse common_enums::RelayStatus;\nuse common_utils::{\n    self, fp_utils,\n    id_type::{self, GenerateId},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::relay;\n\nuse super::errors::{self, ConnectorErrorExt, RouterResponse, RouterResult, StorageErrorExt};\nuse crate::{\n    core::payments,\n    routes::SessionState,\n    services,\n    types::{\n        api::{self},\n        domain,\n    },\n    utils::OptionExt,\n};\n\npub mod utils;\n\npub trait Validate {\n    type Error: error_stack::Context;\n    fn validate(&self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayRefundRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayCaptureRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount_to_capture.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        fp_utils::when(\n            self.amount_to_capture.get_amount_as_i64() > self.authorized_amount.get_amount_as_i64(),\n            || {\n                Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"Capture Amount should be less than or equal to Authorized Amount\"\n                        .to_string(),\n                })\n            },\n        )?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayIncrementalAuthorizationRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.additional_amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayVoidRequestData {\n    type Error = errors::ApiErrorResponse;\n}\n\n#[async_trait]\npub trait RelayInterface {\n    type Request: Validate;\n    fn validate_relay_request(req: &Self::Request) -> RouterResult<()> {\n        req.validate()\n            .change_context(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Invalid relay request\".to_string(),\n            })\n    }\n\n    fn get_domain_models(\n        relay_request: RelayRequestInner<Self>,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n    ) -> relay::Relay;\n\n    async fn process_relay(\n        state: &SessionState,\n        platform: domain::Platform,\n        connector_account: domain::MerchantConnectorAccount,\n        relay_record: &relay::Relay,\n    ) -> RouterResult<relay::RelayUpdate>;\n\n    fn generate_response(value: relay::Relay) -> RouterResult<api_models::relay::RelayResponse>;\n}\n\npub struct RelayRequestInner<T: RelayInterface + ?Sized> {\n    pub connector_resource_id: String,\n    pub connector_id: id_type::MerchantConnectorAccountId,\n    pub relay_type: PhantomData<T>,\n    pub data: T::Request,\n}\n\nimpl RelayRequestInner<RelayRefund> {\n    pub fn from_relay_request(relay_request: relay_api_models::RelayRequest) -> RouterResult<Self> {\n        match relay_request.data {\n            Some(relay_api_models::RelayData::Refund(ref_data)) => Ok(Self {\n                connector_resource_id: relay_request.connector_resource_id,\n                connector_id: relay_request.connector_id,\n                relay_type: PhantomData,\n                data: ref_data,\n            }),\n            Some(relay_api_models::RelayData::Capture(_))\n            | Some(relay_api_models::RelayData::Void(_))\n            | Some(relay_api_models::RelayData::IncrementalAuthorization(_))\n            | None => Err(errors::ApiErrorResponse::InvalidRequestData {\n                message: \"Relay data is required for relay type refund\".to_string(),\n            })?,\n        }\n    }\n}\n\npub struct RelayRefund;\n\n#[async_trait]\nimpl RelayInterface for RelayRefund {",
    "function_name": "validate",
    "file": "crates__router__src__core__relay.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__core__relay.rs",
    "code": "use std::marker::PhantomData;\n\nuse api_models::relay as relay_api_models;\nuse async_trait::async_trait;\nuse common_enums::RelayStatus;\nuse common_utils::{\n    self, fp_utils,\n    id_type::{self, GenerateId},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::relay;\n\nuse super::errors::{self, ConnectorErrorExt, RouterResponse, RouterResult, StorageErrorExt};\nuse crate::{\n    core::payments,\n    routes::SessionState,\n    services,\n    types::{\n        api::{self},\n        domain,\n    },\n    utils::OptionExt,\n};\n\npub mod utils;\n\npub trait Validate {\n    type Error: error_stack::Context;\n    fn validate(&self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayRefundRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayCaptureRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount_to_capture.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        fp_utils::when(\n            self.amount_to_capture.get_amount_as_i64() > self.authorized_amount.get_amount_as_i64(),\n            || {\n                Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"Capture Amount should be less than or equal to Authorized Amount\"\n                        .to_string(),\n                })\n            },\n        )?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayIncrementalAuthorizationRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.additional_amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayVoidRequestData {\n    type Error = errors::ApiErrorResponse;\n}\n\n#[async_trait]\npub trait RelayInterface {\n    type Request: Validate;\n    fn validate_relay_request(req: &Self::Request) -> RouterResult<()> {\n        req.validate()\n            .change_context(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Invalid relay request\".to_string(),\n            })\n    }\n\n    fn get_domain_models(\n        relay_request: RelayRequestInner<Self>,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n    ) -> relay::Relay;\n\n    async fn process_relay(\n        state: &SessionState,\n        platform: domain::Platform,\n        connector_account: domain::MerchantConnectorAccount,\n        relay_record: &relay::Relay,\n    ) -> RouterResult<relay::RelayUpdate>;\n\n    fn generate_response(value: relay::Relay) -> RouterResult<api_models::relay::RelayResponse>;\n}\n\npub struct RelayRequestInner<T: RelayInterface + ?Sized> {\n    pub connector_resource_id: String,\n    pub connector_id: id_type::MerchantConnectorAccountId,\n    pub relay_type: PhantomData<T>,\n    pub data: T::Request,\n}\n\nimpl RelayRequestInner<RelayRefund> {\n    pub fn from_relay_request(relay_request: relay_api_models::RelayRequest) -> RouterResult<Self> {\n        match relay_request.data {\n            Some(relay_api_models::RelayData::Refund(ref_data)) => Ok(Self {\n                connector_resource_id: relay_request.connector_resource_id,\n                connector_id: relay_request.connector_id,\n                relay_type: PhantomData,\n                data: ref_data,\n            }),\n            Some(relay_api_models::RelayData::Capture(_))\n            | Some(relay_api_models::RelayData::Void(_))\n            | Some(relay_api_models::RelayData::IncrementalAuthorization(_))\n            | None => Err(errors::ApiErrorResponse::InvalidRequestData {\n                message: \"Relay data is required for relay type refund\".to_string(),\n            })?,\n        }\n    }\n}\n\npub struct RelayRefund;\n\n#[async_trait]\nimpl RelayInterface for RelayRefund {",
    "function_name": "validate",
    "file": "crates__router__src__core__relay.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for validate",
    "code": "use std::marker::PhantomData;\n\nuse api_models::relay as relay_api_models;\nuse async_trait::async_trait;\nuse common_enums::RelayStatus;\nuse common_utils::{\n    self, fp_utils,\n    id_type::{self, GenerateId},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::relay;\n\nuse super::errors::{self, ConnectorErrorExt, RouterResponse, RouterResult, StorageErrorExt};\nuse crate::{\n    core::payments,\n    routes::SessionState,\n    services,\n    types::{\n        api::{self},\n        domain,\n    },\n    utils::OptionExt,\n};\n\npub mod utils;\n\npub trait Validate {\n    type Error: error_stack::Context;\n    fn validate(&self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayRefundRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayCaptureRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.amount_to_capture.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        fp_utils::when(\n            self.amount_to_capture.get_amount_as_i64() > self.authorized_amount.get_amount_as_i64(),\n            || {\n                Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"Capture Amount should be less than or equal to Authorized Amount\"\n                        .to_string(),\n                })\n            },\n        )?;\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayIncrementalAuthorizationRequestData {\n    type Error = errors::ApiErrorResponse;\n    fn validate(&self) -> Result<(), Self::Error> {\n        fp_utils::when(self.additional_amount.get_amount_as_i64() <= 0, || {\n            Err(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Amount should be greater than 0\".to_string(),\n            })\n        })?;\n\n        Ok(())\n    }\n}\n\nimpl Validate for relay_api_models::RelayVoidRequestData {\n    type Error = errors::ApiErrorResponse;\n}\n\n#[async_trait]\npub trait RelayInterface {\n    type Request: Validate;\n    fn validate_relay_request(req: &Self::Request) -> RouterResult<()> {\n        req.validate()\n            .change_context(errors::ApiErrorResponse::PreconditionFailed {\n                message: \"Invalid relay request\".to_string(),\n            })\n    }\n\n    fn get_domain_models(\n        relay_request: RelayRequestInner<Self>,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n    ) -> relay::Relay;\n\n    async fn process_relay(\n        state: &SessionState,\n        platform: domain::Platform,\n        connector_account: domain::MerchantConnectorAccount,\n        relay_record: &relay::Relay,\n    ) -> RouterResult<relay::RelayUpdate>;\n\n    fn generate_response(value: relay::Relay) -> RouterResult<api_models::relay::RelayResponse>;\n}\n\npub struct RelayRequestInner<T: RelayInterface + ?Sized> {\n    pub connector_resource_id: String,\n    pub connector_id: id_type::MerchantConnectorAccountId,\n    pub relay_type: PhantomData<T>,\n    pub data: T::Request,\n}\n\nimpl RelayRequestInner<RelayRefund> {\n    pub fn from_relay_request(relay_request: relay_api_models::RelayRequest) -> RouterResult<Self> {\n        match relay_request.data {\n            Some(relay_api_models::RelayData::Refund(ref_data)) => Ok(Self {\n                connector_resource_id: relay_request.connector_resource_id,\n                connector_id: relay_request.connector_id,\n                relay_type: PhantomData,\n                data: ref_data,\n            }),\n            Some(relay_api_models::RelayData::Capture(_))\n            | Some(relay_api_models::RelayData::Void(_))\n            | Some(relay_api_models::RelayData::IncrementalAuthorization(_))\n            | None => Err(errors::ApiErrorResponse::InvalidRequestData {\n                message: \"Relay data is required for relay type refund\".to_string(),\n            })?,\n        }\n    }\n}\n\npub struct RelayRefund;\n\n#[async_trait]\nimpl RelayInterface for RelayRefund {",
    "function_name": "validate",
    "file": "crates__router__src__core__relay.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments::{self, AdditionalPaymentData};\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, AdditionalCardInfo, CardData as _,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst TRANSACTION_ALREADY_CANCELLED: &str = \"transaction already canceled\";\nconst TRANSACTION_ALREADY_SETTLED: &str = \"already settled\";\nconst REDIRECTION_SBX_URL: &str = \"https://pay.sandbox.datatrans.com\";\nconst REDIRECTION_PROD_URL: &str = \"https://pay.datatrans.com\";\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize)]\npub struct DatatransErrorResponse {\n    pub error: DatatransError,\n}\npub struct DatatransAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) passcode: Secret<String>,\n}\n\npub struct DatatransRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DatatransPaymentsRequest {\n    pub amount: Option<MinorUnit>,\n    pub currency: enums::Currency,\n    pub card: DataTransPaymentDetails,\n    pub refno: String,\n    pub auto_settle: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub redirect: Option<RedirectUrls>,\n    pub option: Option<DataTransCreateAlias>,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DataTransCreateAlias {\n    pub create_alias: bool,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct RedirectUrls {\n    pub success_url: Option<String>,\n    pub cancel_url: Option<String>,\n    pub error_url: Option<String>,\n}\n#[derive(Debug, Deserialize, Clone, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum TransactionType {\n    Payment,\n    Credit,\n    CardCheck,\n}\n#[derive(Debug, Deserialize, Clone, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum TransactionStatus {\n    Initialized,\n    Authenticated,\n    Authorized,\n    Settled,\n    Canceled,\n    Transmitted,\n    Failed,\n    ChallengeOngoing,\n    ChallengeRequired,\n}\n\n#[derive(Debug, Deserialize, Clone, Serialize)]\n#[serde(untagged)]\npub enum DatatransSyncResponse {\n    Error(DatatransError),\n    Response(SyncResponse),\n}\n#[derive(Debug, Deserialize, Serialize)]\npub enum DataTransCaptureResponse {\n    Error(DatatransError),\n    Empty,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub enum DataTransCancelResponse {\n    Error(DatatransError),\n    Empty,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncResponse {\n    pub transaction_id: String,\n    #[serde(rename = \"type\")]\n    pub res_type: TransactionType,\n    pub status: TransactionStatus,\n    pub detail: SyncDetails,\n    pub card: Option<SyncCardDetails>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncCardDetails {\n    pub alias: Option<String>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncDetails {\n    fail: Option<FailDetails>,\n}\n#[derive(Serialize, Deserialize, Clone, Debug)]",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments::{self, AdditionalPaymentData};\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{Card, PaymentMethodData},\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{PaymentsAuthorizeData, ResponseId, SetupMandateRequestData},\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsSyncResponseRouterData, RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        get_unimplemented_payment_method_error_message, AdditionalCardInfo, CardData as _,\n        PaymentsAuthorizeRequestData, RouterData as _,\n    },\n};\n\nconst TRANSACTION_ALREADY_CANCELLED: &str = \"transaction already canceled\";\nconst TRANSACTION_ALREADY_SETTLED: &str = \"already settled\";\nconst REDIRECTION_SBX_URL: &str = \"https://pay.sandbox.datatrans.com\";\nconst REDIRECTION_PROD_URL: &str = \"https://pay.datatrans.com\";\n\n#[derive(Default, Debug, Clone, Serialize, Deserialize)]\npub struct DatatransErrorResponse {\n    pub error: DatatransError,\n}\npub struct DatatransAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) passcode: Secret<String>,\n}\n\npub struct DatatransRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DatatransPaymentsRequest {\n    pub amount: Option<MinorUnit>,\n    pub currency: enums::Currency,\n    pub card: DataTransPaymentDetails,\n    pub refno: String,\n    pub auto_settle: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub redirect: Option<RedirectUrls>,\n    pub option: Option<DataTransCreateAlias>,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct DataTransCreateAlias {\n    pub create_alias: bool,\n}\n\n#[derive(Debug, Serialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct RedirectUrls {\n    pub success_url: Option<String>,\n    pub cancel_url: Option<String>,\n    pub error_url: Option<String>,\n}\n#[derive(Debug, Deserialize, Clone, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum TransactionType {\n    Payment,\n    Credit,\n    CardCheck,\n}\n#[derive(Debug, Deserialize, Clone, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum TransactionStatus {\n    Initialized,\n    Authenticated,\n    Authorized,\n    Settled,\n    Canceled,\n    Transmitted,\n    Failed,\n    ChallengeOngoing,\n    ChallengeRequired,\n}\n\n#[derive(Debug, Deserialize, Clone, Serialize)]\n#[serde(untagged)]\npub enum DatatransSyncResponse {\n    Error(DatatransError),\n    Response(SyncResponse),\n}\n#[derive(Debug, Deserialize, Serialize)]\npub enum DataTransCaptureResponse {\n    Error(DatatransError),\n    Empty,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub enum DataTransCancelResponse {\n    Error(DatatransError),\n    Empty,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncResponse {\n    pub transaction_id: String,\n    #[serde(rename = \"type\")]\n    pub res_type: TransactionType,\n    pub status: TransactionStatus,\n    pub detail: SyncDetails,\n    pub card: Option<SyncCardDetails>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncCardDetails {\n    pub alias: Option<String>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncDetails {\n    fail: Option<FailDetails>,\n}\n#[derive(Serialize, Deserialize, Clone, Debug)]",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__datatrans__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__fiuu.rs",
    "code": "pub mod transformers;\n\nuse std::{\n    any::type_name,\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    sync::LazyLock,\n};\n\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::{self as common_errors, CustomResult},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::multipart::Form;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse transformers::{self as fiuu, ExtraParameters, FiuuWebhooksResponse};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentMethodDataType},\n};\n\npub fn parse_and_log_keys_in_url_encoded_response<T>(data: &[u8]) {\n    match std::str::from_utf8(data) {\n        Ok(query_str) => {\n            let loggable_keys = [\n                \"status\",\n                \"orderid\",\n                \"tranID\",\n                \"nbcb\",\n                \"amount\",\n                \"currency\",\n                \"paydate\",\n                \"channel\",\n                \"error_desc\",\n                \"error_code\",\n                \"extraP\",\n            ];\n            let keys: Vec<(Cow<'_, str>, String)> =\n                url::form_urlencoded::parse(query_str.as_bytes())\n                    .map(|(key, value)| {\n                        if loggable_keys.contains(&key.to_string().as_str()) {\n                            (key, value.to_string())\n                        } else {\n                            (key, \"SECRET\".to_string())\n                        }\n                    })\n                    .collect();\n            router_env::logger::info!(\"Keys in {} response\\n{:?}\", type_name::<T>(), keys);\n        }\n        Err(err) => {\n            router_env::logger::error!(\"Failed to convert bytes to string: {:?}\", err);\n        }\n    }\n}\n\nfn parse_response<T>(data: &[u8]) -> Result<T, errors::ConnectorError>\nwhere\n    T: for<'de> Deserialize<'de>,\n{\n    let response_str = String::from_utf8(data.to_vec()).map_err(|e| {\n        router_env::logger::error!(\"Error in Deserializing Response Data: {:?}\", e);\n        errors::ConnectorError::ResponseDeserializationFailed\n    })?;\n\n    let mut json = serde_json::Map::new();\n    let mut miscellaneous: HashMap<String, Secret<String>> = HashMap::new();\n\n    for line in response_str.lines() {\n        if let Some((key, value)) = line.split_once('=') {\n            if key.trim().is_empty() {\n                router_env::logger::error!(\"Null or empty key encountered in response.\");\n                continue;\n            }\n\n            if let Some(old_value) = json.insert(key.to_string(), Value::String(value.to_string()))\n            {\n                router_env::logger::warn!(\"Repeated key encountered: {}\", key);\n                miscellaneous.insert(key.to_string(), Secret::new(old_value.to_string()));\n            }\n        }\n    }\n    if !miscellaneous.is_empty() {\n        let misc_value = serde_json::to_value(miscellaneous).map_err(|e| {\n            router_env::logger::error!(\"Error serializing miscellaneous data: {:?}\", e);\n            errors::ConnectorError::ResponseDeserializationFailed\n        })?;\n        json.insert(\"miscellaneous\".to_string(), misc_value);\n    }\n\n    // TODO: Remove this after debugging\n    let loggable_keys = [\n        \"StatCode\",\n        \"StatName\",\n        \"TranID\",\n        \"ErrorCode\",\n        \"ErrorDesc\",\n        \"miscellaneous\",\n    ];",
    "function_name": "parse_and_log_keys_in_url_encoded_response",
    "file": "crates__hyperswitch_connectors__src__connectors__fiuu.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__fiuu.rs",
    "code": "pub mod transformers;\n\nuse std::{\n    any::type_name,\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    sync::LazyLock,\n};\n\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::{self as common_errors, CustomResult},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::multipart::Form;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse transformers::{self as fiuu, ExtraParameters, FiuuWebhooksResponse};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentMethodDataType},\n};\n\npub fn parse_and_log_keys_in_url_encoded_response<T>(data: &[u8]) {\n    match std::str::from_utf8(data) {\n        Ok(query_str) => {\n            let loggable_keys = [\n                \"status\",\n                \"orderid\",\n                \"tranID\",\n                \"nbcb\",\n                \"amount\",\n                \"currency\",\n                \"paydate\",\n                \"channel\",\n                \"error_desc\",\n                \"error_code\",\n                \"extraP\",\n            ];\n            let keys: Vec<(Cow<'_, str>, String)> =\n                url::form_urlencoded::parse(query_str.as_bytes())\n                    .map(|(key, value)| {\n                        if loggable_keys.contains(&key.to_string().as_str()) {\n                            (key, value.to_string())\n                        } else {\n                            (key, \"SECRET\".to_string())\n                        }\n                    })\n                    .collect();\n            router_env::logger::info!(\"Keys in {} response\\n{:?}\", type_name::<T>(), keys);\n        }\n        Err(err) => {\n            router_env::logger::error!(\"Failed to convert bytes to string: {:?}\", err);\n        }\n    }\n}\n\nfn parse_response<T>(data: &[u8]) -> Result<T, errors::ConnectorError>\nwhere\n    T: for<'de> Deserialize<'de>,\n{\n    let response_str = String::from_utf8(data.to_vec()).map_err(|e| {\n        router_env::logger::error!(\"Error in Deserializing Response Data: {:?}\", e);\n        errors::ConnectorError::ResponseDeserializationFailed\n    })?;\n\n    let mut json = serde_json::Map::new();\n    let mut miscellaneous: HashMap<String, Secret<String>> = HashMap::new();\n\n    for line in response_str.lines() {\n        if let Some((key, value)) = line.split_once('=') {\n            if key.trim().is_empty() {\n                router_env::logger::error!(\"Null or empty key encountered in response.\");\n                continue;\n            }\n\n            if let Some(old_value) = json.insert(key.to_string(), Value::String(value.to_string()))\n            {\n                router_env::logger::warn!(\"Repeated key encountered: {}\", key);\n                miscellaneous.insert(key.to_string(), Secret::new(old_value.to_string()));\n            }\n        }\n    }\n    if !miscellaneous.is_empty() {\n        let misc_value = serde_json::to_value(miscellaneous).map_err(|e| {\n            router_env::logger::error!(\"Error serializing miscellaneous data: {:?}\", e);\n            errors::ConnectorError::ResponseDeserializationFailed\n        })?;\n        json.insert(\"miscellaneous\".to_string(), misc_value);\n    }\n\n    // TODO: Remove this after debugging\n    let loggable_keys = [\n        \"StatCode\",\n        \"StatName\",\n        \"TranID\",\n        \"ErrorCode\",\n        \"ErrorDesc\",\n        \"miscellaneous\",\n    ];",
    "function_name": "parse_and_log_keys_in_url_encoded_response",
    "file": "crates__hyperswitch_connectors__src__connectors__fiuu.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for parse_and_log_keys_in_url_encoded_response",
    "code": "pub mod transformers;\n\nuse std::{\n    any::type_name,\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    sync::LazyLock,\n};\n\nuse common_enums::{CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::{self as common_errors, CustomResult},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse reqwest::multipart::Form;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse transformers::{self as fiuu, ExtraParameters, FiuuWebhooksResponse};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, PaymentMethodDataType},\n};\n\npub fn parse_and_log_keys_in_url_encoded_response<T>(data: &[u8]) {\n    match std::str::from_utf8(data) {\n        Ok(query_str) => {\n            let loggable_keys = [\n                \"status\",\n                \"orderid\",\n                \"tranID\",\n                \"nbcb\",\n                \"amount\",\n                \"currency\",\n                \"paydate\",\n                \"channel\",\n                \"error_desc\",\n                \"error_code\",\n                \"extraP\",\n            ];\n            let keys: Vec<(Cow<'_, str>, String)> =\n                url::form_urlencoded::parse(query_str.as_bytes())\n                    .map(|(key, value)| {\n                        if loggable_keys.contains(&key.to_string().as_str()) {\n                            (key, value.to_string())\n                        } else {\n                            (key, \"SECRET\".to_string())\n                        }\n                    })\n                    .collect();\n            router_env::logger::info!(\"Keys in {} response\\n{:?}\", type_name::<T>(), keys);\n        }\n        Err(err) => {\n            router_env::logger::error!(\"Failed to convert bytes to string: {:?}\", err);\n        }\n    }\n}\n\nfn parse_response<T>(data: &[u8]) -> Result<T, errors::ConnectorError>\nwhere\n    T: for<'de> Deserialize<'de>,\n{\n    let response_str = String::from_utf8(data.to_vec()).map_err(|e| {\n        router_env::logger::error!(\"Error in Deserializing Response Data: {:?}\", e);\n        errors::ConnectorError::ResponseDeserializationFailed\n    })?;\n\n    let mut json = serde_json::Map::new();\n    let mut miscellaneous: HashMap<String, Secret<String>> = HashMap::new();\n\n    for line in response_str.lines() {\n        if let Some((key, value)) = line.split_once('=') {\n            if key.trim().is_empty() {\n                router_env::logger::error!(\"Null or empty key encountered in response.\");\n                continue;\n            }\n\n            if let Some(old_value) = json.insert(key.to_string(), Value::String(value.to_string()))\n            {\n                router_env::logger::warn!(\"Repeated key encountered: {}\", key);\n                miscellaneous.insert(key.to_string(), Secret::new(old_value.to_string()));\n            }\n        }\n    }\n    if !miscellaneous.is_empty() {\n        let misc_value = serde_json::to_value(miscellaneous).map_err(|e| {\n            router_env::logger::error!(\"Error serializing miscellaneous data: {:?}\", e);\n            errors::ConnectorError::ResponseDeserializationFailed\n        })?;\n        json.insert(\"miscellaneous\".to_string(), misc_value);\n    }\n\n    // TODO: Remove this after debugging\n    let loggable_keys = [\n        \"StatCode\",\n        \"StatName\",\n        \"TranID\",\n        \"ErrorCode\",\n        \"ErrorDesc\",\n        \"miscellaneous\",\n    ];",
    "function_name": "parse_and_log_keys_in_url_encoded_response",
    "file": "crates__hyperswitch_connectors__src__connectors__fiuu.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__mpgs.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as mpgs;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Mpgs {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Mpgs {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mpgs {}\nimpl api::PaymentSession for Mpgs {}\nimpl api::ConnectorAccessToken for Mpgs {}\nimpl api::MandateSetup for Mpgs {}\nimpl api::PaymentAuthorize for Mpgs {}\nimpl api::PaymentSync for Mpgs {}\nimpl api::PaymentCapture for Mpgs {}\nimpl api::PaymentVoid for Mpgs {}\nimpl api::Refund for Mpgs {}\nimpl api::RefundExecute for Mpgs {}\nimpl api::RefundSync for Mpgs {}\nimpl api::PaymentToken for Mpgs {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Mpgs\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Mpgs\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Mpgs {\n    fn id(&self) -> &'static str {\n        \"mpgs\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.mpgs.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = mpgs::MpgsAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: mpgs::MpgsErrorResponse = res\n            .response\n            .parse_struct(\"MpgsErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__mpgs.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__mpgs.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as mpgs;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Mpgs {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Mpgs {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mpgs {}\nimpl api::PaymentSession for Mpgs {}\nimpl api::ConnectorAccessToken for Mpgs {}\nimpl api::MandateSetup for Mpgs {}\nimpl api::PaymentAuthorize for Mpgs {}\nimpl api::PaymentSync for Mpgs {}\nimpl api::PaymentCapture for Mpgs {}\nimpl api::PaymentVoid for Mpgs {}\nimpl api::Refund for Mpgs {}\nimpl api::RefundExecute for Mpgs {}\nimpl api::RefundSync for Mpgs {}\nimpl api::PaymentToken for Mpgs {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Mpgs\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Mpgs\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Mpgs {\n    fn id(&self) -> &'static str {\n        \"mpgs\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.mpgs.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = mpgs::MpgsAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: mpgs::MpgsErrorResponse = res\n            .response\n            .parse_struct(\"MpgsErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__mpgs.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as mpgs;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Mpgs {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Mpgs {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Mpgs {}\nimpl api::PaymentSession for Mpgs {}\nimpl api::ConnectorAccessToken for Mpgs {}\nimpl api::MandateSetup for Mpgs {}\nimpl api::PaymentAuthorize for Mpgs {}\nimpl api::PaymentSync for Mpgs {}\nimpl api::PaymentCapture for Mpgs {}\nimpl api::PaymentVoid for Mpgs {}\nimpl api::Refund for Mpgs {}\nimpl api::RefundExecute for Mpgs {}\nimpl api::RefundSync for Mpgs {}\nimpl api::PaymentToken for Mpgs {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Mpgs\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Mpgs\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Mpgs {\n    fn id(&self) -> &'static str {\n        \"mpgs\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.mpgs.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = mpgs::MpgsAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: mpgs::MpgsErrorResponse = res\n            .response\n            .parse_struct(\"MpgsErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__mpgs.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__core__webhooks__recovery_incoming.rs",
    "code": "use std::{collections::HashMap, marker::PhantomData, str::FromStr};\n\nuse api_models::{enums as api_enums, payments as api_payments, webhooks};\nuse common_utils::{\n    ext_traits::{AsyncExt, ValueExt},\n    id_type,\n};\nuse diesel_models::process_tracker as storage;\nuse error_stack::{report, ResultExt};\nuse futures::stream::SelectNextSome;\nuse hyperswitch_domain_models::{\n    payments as domain_payments,\n    revenue_recovery::{self, RecoveryPaymentIntent},\n    router_data_v2::flow_common_types,\n    router_flow_types,\n    router_request_types::revenue_recovery as revenue_recovery_request,\n    router_response_types::revenue_recovery as revenue_recovery_response,\n    types as router_types,\n};\nuse hyperswitch_interfaces::webhooks as interface_webhooks;\nuse masking::{PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse services::kafka;\nuse storage::business_status;\n\nuse crate::{\n    consts,\n    core::{\n        self, admin,\n        errors::{self, CustomResult},\n        payments::{self, helpers},\n    },\n    db::{errors::RevenueRecoveryError, StorageInterface},\n    routes::{app::ReqState, metrics, SessionState},\n    services::{\n        self,\n        connector_integration_interface::{self, RouterDataConversion},\n    },\n    types::{\n        self, api, domain,\n        storage::{\n            revenue_recovery as storage_revenue_recovery,\n            revenue_recovery_redis_operation::{\n                PaymentProcessorTokenDetails, PaymentProcessorTokenStatus, RedisTokenManager,\n            },\n        },\n        transformers::ForeignFrom,\n    },\n    workflows::revenue_recovery as revenue_recovery_flow,\n};\n#[cfg(feature = \"v2\")]\npub const REVENUE_RECOVERY: &str = \"revenue_recovery\";\n\n#[allow(clippy::too_many_arguments)]\n#[instrument(skip_all)]\n#[cfg(feature = \"revenue_recovery\")]\npub async fn recovery_incoming_webhook_flow(\n    state: SessionState,\n    platform: domain::Platform,\n    business_profile: domain::Profile,\n    source_verified: bool,\n    connector_enum: &connector_integration_interface::ConnectorEnum,\n    billing_connector_account: hyperswitch_domain_models::merchant_connector_account::MerchantConnectorAccount,\n    connector_name: &str,\n    request_details: &hyperswitch_interfaces::webhooks::IncomingWebhookRequestDetails<'_>,\n    event_type: webhooks::IncomingWebhookEvent,\n    req_state: ReqState,\n    object_ref_id: &webhooks::ObjectReferenceId,\n) -> CustomResult<webhooks::WebhookResponseTracker, errors::RevenueRecoveryError> {\n    // Source verification is necessary for revenue recovery webhooks flow since We don't have payment intent/attempt object created before in our system.\n    common_utils::fp_utils::when(!source_verified, || {\n        Err(report!(\n            errors::RevenueRecoveryError::WebhookAuthenticationFailed\n        ))\n    })?;\n\n    let connector = api_enums::Connector::from_str(connector_name)\n        .change_context(errors::RevenueRecoveryError::InvoiceWebhookProcessingFailed)\n        .attach_printable_lazy(|| format!(\"unable to parse connector name {connector_name:?}\"))?;\n\n    let billing_connectors_with_invoice_sync_call = &state.conf.billing_connectors_invoice_sync;\n\n    let should_billing_connector_invoice_api_called = billing_connectors_with_invoice_sync_call\n        .billing_connectors_which_requires_invoice_sync_call\n        .contains(&connector);\n\n    let billing_connectors_with_payment_sync_call = &state.conf.billing_connectors_payment_sync;\n\n    let should_billing_connector_payment_api_called = billing_connectors_with_payment_sync_call\n        .billing_connectors_which_require_payment_sync\n        .contains(&connector);\n\n    let billing_connector_payment_details =\n        BillingConnectorPaymentsSyncResponseData::get_billing_connector_payment_details(\n            should_billing_connector_payment_api_called,\n            &state,\n            &platform,\n            &billing_connector_account,\n            connector_name,\n            object_ref_id,\n        )\n        .await?;\n\n    let invoice_id = billing_connector_payment_details\n        .clone()\n        .map(|data| data.merchant_reference_id);\n\n    let billing_connector_invoice_details =\n        BillingConnectorInvoiceSyncResponseData::get_billing_connector_invoice_details(\n            should_billing_connector_invoice_api_called,\n            &state,\n            &platform,\n            &billing_connector_account,\n            connector_name,\n            invoice_id,\n        )\n        .await?;\n\n    // Checks whether we have data in billing_connector_invoice_details , if it is there then we construct revenue recovery invoice from it else it takes from webhook\n    let invoice_details = RevenueRecoveryInvoice::get_recovery_invoice_details(\n        connector_enum,\n        request_details,\n        billing_connector_invoice_details.as_ref(),\n    )?;\n\n    // Fetch the intent using merchant reference id, if not found create new intent.\n    let payment_intent = invoice_details\n        .get_payment_intent(&state, &req_state, &platform, &business_profile)\n        .await\n        .transpose()\n        .async_unwrap_or_else(|| async {\n            invoice_details\n                .create_payment_intent(&state, &req_state, &platform, &business_profile)\n                .await\n        })\n        .await?;\n\n    let is_event_recovery_transaction_event = event_type.is_recovery_transaction_event();\n    let (recovery_attempt_from_payment_attempt, recovery_intent_from_payment_attempt) =\n        RevenueRecoveryAttempt::get_recovery_payment_attempt(",
    "function_name": "recovery_incoming_webhook_flow",
    "file": "crates__router__src__core__webhooks__recovery_incoming.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__core__webhooks__recovery_incoming.rs",
    "code": "use std::{collections::HashMap, marker::PhantomData, str::FromStr};\n\nuse api_models::{enums as api_enums, payments as api_payments, webhooks};\nuse common_utils::{\n    ext_traits::{AsyncExt, ValueExt},\n    id_type,\n};\nuse diesel_models::process_tracker as storage;\nuse error_stack::{report, ResultExt};\nuse futures::stream::SelectNextSome;\nuse hyperswitch_domain_models::{\n    payments as domain_payments,\n    revenue_recovery::{self, RecoveryPaymentIntent},\n    router_data_v2::flow_common_types,\n    router_flow_types,\n    router_request_types::revenue_recovery as revenue_recovery_request,\n    router_response_types::revenue_recovery as revenue_recovery_response,\n    types as router_types,\n};\nuse hyperswitch_interfaces::webhooks as interface_webhooks;\nuse masking::{PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse services::kafka;\nuse storage::business_status;\n\nuse crate::{\n    consts,\n    core::{\n        self, admin,\n        errors::{self, CustomResult},\n        payments::{self, helpers},\n    },\n    db::{errors::RevenueRecoveryError, StorageInterface},\n    routes::{app::ReqState, metrics, SessionState},\n    services::{\n        self,\n        connector_integration_interface::{self, RouterDataConversion},\n    },\n    types::{\n        self, api, domain,\n        storage::{\n            revenue_recovery as storage_revenue_recovery,\n            revenue_recovery_redis_operation::{\n                PaymentProcessorTokenDetails, PaymentProcessorTokenStatus, RedisTokenManager,\n            },\n        },\n        transformers::ForeignFrom,\n    },\n    workflows::revenue_recovery as revenue_recovery_flow,\n};\n#[cfg(feature = \"v2\")]\npub const REVENUE_RECOVERY: &str = \"revenue_recovery\";\n\n#[allow(clippy::too_many_arguments)]\n#[instrument(skip_all)]\n#[cfg(feature = \"revenue_recovery\")]\npub async fn recovery_incoming_webhook_flow(\n    state: SessionState,\n    platform: domain::Platform,\n    business_profile: domain::Profile,\n    source_verified: bool,\n    connector_enum: &connector_integration_interface::ConnectorEnum,\n    billing_connector_account: hyperswitch_domain_models::merchant_connector_account::MerchantConnectorAccount,\n    connector_name: &str,\n    request_details: &hyperswitch_interfaces::webhooks::IncomingWebhookRequestDetails<'_>,\n    event_type: webhooks::IncomingWebhookEvent,\n    req_state: ReqState,\n    object_ref_id: &webhooks::ObjectReferenceId,\n) -> CustomResult<webhooks::WebhookResponseTracker, errors::RevenueRecoveryError> {\n    // Source verification is necessary for revenue recovery webhooks flow since We don't have payment intent/attempt object created before in our system.\n    common_utils::fp_utils::when(!source_verified, || {\n        Err(report!(\n            errors::RevenueRecoveryError::WebhookAuthenticationFailed\n        ))\n    })?;\n\n    let connector = api_enums::Connector::from_str(connector_name)\n        .change_context(errors::RevenueRecoveryError::InvoiceWebhookProcessingFailed)\n        .attach_printable_lazy(|| format!(\"unable to parse connector name {connector_name:?}\"))?;\n\n    let billing_connectors_with_invoice_sync_call = &state.conf.billing_connectors_invoice_sync;\n\n    let should_billing_connector_invoice_api_called = billing_connectors_with_invoice_sync_call\n        .billing_connectors_which_requires_invoice_sync_call\n        .contains(&connector);\n\n    let billing_connectors_with_payment_sync_call = &state.conf.billing_connectors_payment_sync;\n\n    let should_billing_connector_payment_api_called = billing_connectors_with_payment_sync_call\n        .billing_connectors_which_require_payment_sync\n        .contains(&connector);\n\n    let billing_connector_payment_details =\n        BillingConnectorPaymentsSyncResponseData::get_billing_connector_payment_details(\n            should_billing_connector_payment_api_called,\n            &state,\n            &platform,\n            &billing_connector_account,\n            connector_name,\n            object_ref_id,\n        )\n        .await?;\n\n    let invoice_id = billing_connector_payment_details\n        .clone()\n        .map(|data| data.merchant_reference_id);\n\n    let billing_connector_invoice_details =\n        BillingConnectorInvoiceSyncResponseData::get_billing_connector_invoice_details(\n            should_billing_connector_invoice_api_called,\n            &state,\n            &platform,\n            &billing_connector_account,\n            connector_name,\n            invoice_id,\n        )\n        .await?;\n\n    // Checks whether we have data in billing_connector_invoice_details , if it is there then we construct revenue recovery invoice from it else it takes from webhook\n    let invoice_details = RevenueRecoveryInvoice::get_recovery_invoice_details(\n        connector_enum,\n        request_details,\n        billing_connector_invoice_details.as_ref(),\n    )?;\n\n    // Fetch the intent using merchant reference id, if not found create new intent.\n    let payment_intent = invoice_details\n        .get_payment_intent(&state, &req_state, &platform, &business_profile)\n        .await\n        .transpose()\n        .async_unwrap_or_else(|| async {\n            invoice_details\n                .create_payment_intent(&state, &req_state, &platform, &business_profile)\n                .await\n        })\n        .await?;\n\n    let is_event_recovery_transaction_event = event_type.is_recovery_transaction_event();\n    let (recovery_attempt_from_payment_attempt, recovery_intent_from_payment_attempt) =\n        RevenueRecoveryAttempt::get_recovery_payment_attempt(",
    "function_name": "recovery_incoming_webhook_flow",
    "file": "crates__router__src__core__webhooks__recovery_incoming.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for recovery_incoming_webhook_flow",
    "code": "use std::{collections::HashMap, marker::PhantomData, str::FromStr};\n\nuse api_models::{enums as api_enums, payments as api_payments, webhooks};\nuse common_utils::{\n    ext_traits::{AsyncExt, ValueExt},\n    id_type,\n};\nuse diesel_models::process_tracker as storage;\nuse error_stack::{report, ResultExt};\nuse futures::stream::SelectNextSome;\nuse hyperswitch_domain_models::{\n    payments as domain_payments,\n    revenue_recovery::{self, RecoveryPaymentIntent},\n    router_data_v2::flow_common_types,\n    router_flow_types,\n    router_request_types::revenue_recovery as revenue_recovery_request,\n    router_response_types::revenue_recovery as revenue_recovery_response,\n    types as router_types,\n};\nuse hyperswitch_interfaces::webhooks as interface_webhooks;\nuse masking::{PeekInterface, Secret};\nuse router_env::{instrument, logger, tracing};\nuse services::kafka;\nuse storage::business_status;\n\nuse crate::{\n    consts,\n    core::{\n        self, admin,\n        errors::{self, CustomResult},\n        payments::{self, helpers},\n    },\n    db::{errors::RevenueRecoveryError, StorageInterface},\n    routes::{app::ReqState, metrics, SessionState},\n    services::{\n        self,\n        connector_integration_interface::{self, RouterDataConversion},\n    },\n    types::{\n        self, api, domain,\n        storage::{\n            revenue_recovery as storage_revenue_recovery,\n            revenue_recovery_redis_operation::{\n                PaymentProcessorTokenDetails, PaymentProcessorTokenStatus, RedisTokenManager,\n            },\n        },\n        transformers::ForeignFrom,\n    },\n    workflows::revenue_recovery as revenue_recovery_flow,\n};\n#[cfg(feature = \"v2\")]\npub const REVENUE_RECOVERY: &str = \"revenue_recovery\";\n\n#[allow(clippy::too_many_arguments)]\n#[instrument(skip_all)]\n#[cfg(feature = \"revenue_recovery\")]\npub async fn recovery_incoming_webhook_flow(\n    state: SessionState,\n    platform: domain::Platform,\n    business_profile: domain::Profile,\n    source_verified: bool,\n    connector_enum: &connector_integration_interface::ConnectorEnum,\n    billing_connector_account: hyperswitch_domain_models::merchant_connector_account::MerchantConnectorAccount,\n    connector_name: &str,\n    request_details: &hyperswitch_interfaces::webhooks::IncomingWebhookRequestDetails<'_>,\n    event_type: webhooks::IncomingWebhookEvent,\n    req_state: ReqState,\n    object_ref_id: &webhooks::ObjectReferenceId,\n) -> CustomResult<webhooks::WebhookResponseTracker, errors::RevenueRecoveryError> {\n    // Source verification is necessary for revenue recovery webhooks flow since We don't have payment intent/attempt object created before in our system.\n    common_utils::fp_utils::when(!source_verified, || {\n        Err(report!(\n            errors::RevenueRecoveryError::WebhookAuthenticationFailed\n        ))\n    })?;\n\n    let connector = api_enums::Connector::from_str(connector_name)\n        .change_context(errors::RevenueRecoveryError::InvoiceWebhookProcessingFailed)\n        .attach_printable_lazy(|| format!(\"unable to parse connector name {connector_name:?}\"))?;\n\n    let billing_connectors_with_invoice_sync_call = &state.conf.billing_connectors_invoice_sync;\n\n    let should_billing_connector_invoice_api_called = billing_connectors_with_invoice_sync_call\n        .billing_connectors_which_requires_invoice_sync_call\n        .contains(&connector);\n\n    let billing_connectors_with_payment_sync_call = &state.conf.billing_connectors_payment_sync;\n\n    let should_billing_connector_payment_api_called = billing_connectors_with_payment_sync_call\n        .billing_connectors_which_require_payment_sync\n        .contains(&connector);\n\n    let billing_connector_payment_details =\n        BillingConnectorPaymentsSyncResponseData::get_billing_connector_payment_details(\n            should_billing_connector_payment_api_called,\n            &state,\n            &platform,\n            &billing_connector_account,\n            connector_name,\n            object_ref_id,\n        )\n        .await?;\n\n    let invoice_id = billing_connector_payment_details\n        .clone()\n        .map(|data| data.merchant_reference_id);\n\n    let billing_connector_invoice_details =\n        BillingConnectorInvoiceSyncResponseData::get_billing_connector_invoice_details(\n            should_billing_connector_invoice_api_called,\n            &state,\n            &platform,\n            &billing_connector_account,\n            connector_name,\n            invoice_id,\n        )\n        .await?;\n\n    // Checks whether we have data in billing_connector_invoice_details , if it is there then we construct revenue recovery invoice from it else it takes from webhook\n    let invoice_details = RevenueRecoveryInvoice::get_recovery_invoice_details(\n        connector_enum,\n        request_details,\n        billing_connector_invoice_details.as_ref(),\n    )?;\n\n    // Fetch the intent using merchant reference id, if not found create new intent.\n    let payment_intent = invoice_details\n        .get_payment_intent(&state, &req_state, &platform, &business_profile)\n        .await\n        .transpose()\n        .async_unwrap_or_else(|| async {\n            invoice_details\n                .create_payment_intent(&state, &req_state, &platform, &business_profile)\n                .await\n        })\n        .await?;\n\n    let is_event_recovery_transaction_event = event_type.is_recovery_transaction_event();\n    let (recovery_attempt_from_payment_attempt, recovery_intent_from_payment_attempt) =\n        RevenueRecoveryAttempt::get_recovery_payment_attempt(",
    "function_name": "recovery_incoming_webhook_flow",
    "file": "crates__router__src__core__webhooks__recovery_incoming.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__business_profile.rs",
    "code": "use std::borrow::Cow;\n\nuse common_enums::enums as api_enums;\nuse common_types::{domain::AcquirerConfig, primitive_wrappers};\nuse common_utils::{\n    crypto::{OptionalEncryptableName, OptionalEncryptableValue},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    pii, type_name,\n    types::keymanager,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::business_profile::RevenueRecoveryAlgorithmData;\nuse diesel_models::business_profile::{\n    self as storage_types, AuthenticationConnectorDetails, BusinessPaymentLinkConfig,\n    BusinessPayoutLinkConfig, CardTestingGuardConfig, ExternalVaultConnectorDetails,\n    ProfileUpdateInternal, WebhookDetails,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::logger;\n\nuse crate::{\n    behaviour::Conversion,\n    errors::api_error_response,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, AsyncLift, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub version: common_enums::ApiVersion,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<common_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    pub acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub enum ExternalVaultDetails {\n    ExternalVaultEnabled(ExternalVaultConnectorDetails),\n    Skip,\n}\n\n#[cfg(feature = \"v1\")]\nimpl ExternalVaultDetails {\n    pub fn is_external_vault_enabled(&self) -> bool {\n        match self {\n            Self::ExternalVaultEnabled(_) => true,\n            Self::Skip => false,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl\n    TryFrom<(\n        Option<common_enums::ExternalVaultEnabled>,\n        Option<ExternalVaultConnectorDetails>,\n    )> for ExternalVaultDetails\n{\n    type Error = error_stack::Report<ValidationError>;\n    fn try_from(\n        item: (\n            Option<common_enums::ExternalVaultEnabled>,\n            Option<ExternalVaultConnectorDetails>,\n        ),\n    ) -> Result<Self, Self::Error> {\n        match item {\n            (is_external_vault_enabled, external_vault_connector_details)\n                if is_external_vault_enabled\n                    .unwrap_or(common_enums::ExternalVaultEnabled::Skip)\n                    == common_enums::ExternalVaultEnabled::Enable =>\n            {\n                Ok(Self::ExternalVaultEnabled(\n                    external_vault_connector_details\n                        .get_required_value(\"ExternalVaultConnectorDetails\")?,\n                ))\n            }\n            _ => Ok(Self::Skip),\n        }\n    }",
    "function_name": "is_external_vault_enabled",
    "file": "crates__hyperswitch_domain_models__src__business_profile.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_domain_models__src__business_profile.rs",
    "code": "use std::borrow::Cow;\n\nuse common_enums::enums as api_enums;\nuse common_types::{domain::AcquirerConfig, primitive_wrappers};\nuse common_utils::{\n    crypto::{OptionalEncryptableName, OptionalEncryptableValue},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    pii, type_name,\n    types::keymanager,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::business_profile::RevenueRecoveryAlgorithmData;\nuse diesel_models::business_profile::{\n    self as storage_types, AuthenticationConnectorDetails, BusinessPaymentLinkConfig,\n    BusinessPayoutLinkConfig, CardTestingGuardConfig, ExternalVaultConnectorDetails,\n    ProfileUpdateInternal, WebhookDetails,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::logger;\n\nuse crate::{\n    behaviour::Conversion,\n    errors::api_error_response,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, AsyncLift, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub version: common_enums::ApiVersion,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<common_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    pub acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub enum ExternalVaultDetails {\n    ExternalVaultEnabled(ExternalVaultConnectorDetails),\n    Skip,\n}\n\n#[cfg(feature = \"v1\")]\nimpl ExternalVaultDetails {\n    pub fn is_external_vault_enabled(&self) -> bool {\n        match self {\n            Self::ExternalVaultEnabled(_) => true,\n            Self::Skip => false,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl\n    TryFrom<(\n        Option<common_enums::ExternalVaultEnabled>,\n        Option<ExternalVaultConnectorDetails>,\n    )> for ExternalVaultDetails\n{\n    type Error = error_stack::Report<ValidationError>;\n    fn try_from(\n        item: (\n            Option<common_enums::ExternalVaultEnabled>,\n            Option<ExternalVaultConnectorDetails>,\n        ),\n    ) -> Result<Self, Self::Error> {\n        match item {\n            (is_external_vault_enabled, external_vault_connector_details)\n                if is_external_vault_enabled\n                    .unwrap_or(common_enums::ExternalVaultEnabled::Skip)\n                    == common_enums::ExternalVaultEnabled::Enable =>\n            {\n                Ok(Self::ExternalVaultEnabled(\n                    external_vault_connector_details\n                        .get_required_value(\"ExternalVaultConnectorDetails\")?,\n                ))\n            }\n            _ => Ok(Self::Skip),\n        }\n    }",
    "function_name": "is_external_vault_enabled",
    "file": "crates__hyperswitch_domain_models__src__business_profile.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for is_external_vault_enabled",
    "code": "use std::borrow::Cow;\n\nuse common_enums::enums as api_enums;\nuse common_types::{domain::AcquirerConfig, primitive_wrappers};\nuse common_utils::{\n    crypto::{OptionalEncryptableName, OptionalEncryptableValue},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{OptionExt, ValueExt},\n    pii, type_name,\n    types::keymanager,\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::business_profile::RevenueRecoveryAlgorithmData;\nuse diesel_models::business_profile::{\n    self as storage_types, AuthenticationConnectorDetails, BusinessPaymentLinkConfig,\n    BusinessPayoutLinkConfig, CardTestingGuardConfig, ExternalVaultConnectorDetails,\n    ProfileUpdateInternal, WebhookDetails,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse router_env::logger;\n\nuse crate::{\n    behaviour::Conversion,\n    errors::api_error_response,\n    merchant_key_store::MerchantKeyStore,\n    type_encryption::{crypto_operation, AsyncLift, CryptoOperation},\n};\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub struct Profile {\n    profile_id: common_utils::id_type::ProfileId,\n    pub merchant_id: common_utils::id_type::MerchantId,\n    pub profile_name: String,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub return_url: Option<String>,\n    pub enable_payment_response_hash: bool,\n    pub payment_response_hash_key: Option<String>,\n    pub redirect_to_merchant_with_http_post: bool,\n    pub webhook_details: Option<WebhookDetails>,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub routing_algorithm: Option<serde_json::Value>,\n    pub intent_fulfillment_time: Option<i64>,\n    pub frm_routing_algorithm: Option<serde_json::Value>,\n    pub payout_routing_algorithm: Option<serde_json::Value>,\n    pub is_recon_enabled: bool,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub payment_link_config: Option<BusinessPaymentLinkConfig>,\n    pub session_expiry: Option<i64>,\n    pub authentication_connector_details: Option<AuthenticationConnectorDetails>,\n    pub payout_link_config: Option<BusinessPayoutLinkConfig>,\n    pub is_extended_card_info_enabled: Option<bool>,\n    pub extended_card_info_config: Option<pii::SecretSerdeValue>,\n    pub is_connector_agnostic_mit_enabled: Option<bool>,\n    pub use_billing_as_payment_method_billing: Option<bool>,\n    pub collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub collect_billing_details_from_wallet_connector: Option<bool>,\n    pub outgoing_webhook_custom_http_headers: OptionalEncryptableValue,\n    pub always_collect_billing_details_from_wallet_connector: Option<bool>,\n    pub always_collect_shipping_details_from_wallet_connector: Option<bool>,\n    pub tax_connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n    pub is_tax_connector_enabled: bool,\n    pub is_l2_l3_enabled: bool,\n    pub version: common_enums::ApiVersion,\n    pub dynamic_routing_algorithm: Option<serde_json::Value>,\n    pub is_network_tokenization_enabled: bool,\n    pub is_auto_retries_enabled: bool,\n    pub max_auto_retries_enabled: Option<i16>,\n    pub always_request_extended_authorization:\n        Option<primitive_wrappers::AlwaysRequestExtendedAuthorization>,\n    pub is_click_to_pay_enabled: bool,\n    pub authentication_product_ids:\n        Option<common_types::payments::AuthenticationConnectorAccountMap>,\n    pub card_testing_guard_config: Option<CardTestingGuardConfig>,\n    pub card_testing_secret_key: OptionalEncryptableName,\n    pub is_clear_pan_retries_enabled: bool,\n    pub force_3ds_challenge: bool,\n    pub is_debit_routing_enabled: bool,\n    pub merchant_business_country: Option<common_enums::CountryAlpha2>,\n    pub is_iframe_redirection_enabled: Option<bool>,\n    pub is_pre_network_tokenization_enabled: bool,\n    pub three_ds_decision_rule_algorithm: Option<serde_json::Value>,\n    pub acquirer_config_map: Option<common_types::domain::AcquirerConfigMap>,\n    pub merchant_category_code: Option<api_enums::MerchantCategoryCode>,\n    pub merchant_country_code: Option<common_types::payments::MerchantCountryCode>,\n    pub dispute_polling_interval: Option<primitive_wrappers::DisputePollingIntervalInHours>,\n    pub is_manual_retry_enabled: Option<bool>,\n    pub always_enable_overcapture: Option<primitive_wrappers::AlwaysEnableOvercaptureBool>,\n    pub external_vault_details: ExternalVaultDetails,\n    pub billing_processor_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n}\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug)]\npub enum ExternalVaultDetails {\n    ExternalVaultEnabled(ExternalVaultConnectorDetails),\n    Skip,\n}\n\n#[cfg(feature = \"v1\")]\nimpl ExternalVaultDetails {\n    pub fn is_external_vault_enabled(&self) -> bool {\n        match self {\n            Self::ExternalVaultEnabled(_) => true,\n            Self::Skip => false,\n        }\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl\n    TryFrom<(\n        Option<common_enums::ExternalVaultEnabled>,\n        Option<ExternalVaultConnectorDetails>,\n    )> for ExternalVaultDetails\n{\n    type Error = error_stack::Report<ValidationError>;\n    fn try_from(\n        item: (\n            Option<common_enums::ExternalVaultEnabled>,\n            Option<ExternalVaultConnectorDetails>,\n        ),\n    ) -> Result<Self, Self::Error> {\n        match item {\n            (is_external_vault_enabled, external_vault_connector_details)\n                if is_external_vault_enabled\n                    .unwrap_or(common_enums::ExternalVaultEnabled::Skip)\n                    == common_enums::ExternalVaultEnabled::Enable =>\n            {\n                Ok(Self::ExternalVaultEnabled(\n                    external_vault_connector_details\n                        .get_required_value(\"ExternalVaultConnectorDetails\")?,\n                ))\n            }\n            _ => Ok(Self::Skip),\n        }\n    }",
    "function_name": "is_external_vault_enabled",
    "file": "crates__hyperswitch_domain_models__src__business_profile.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__common_utils__src__crypto.rs",
    "code": "//! Utilities for cryptographic algorithms\nuse std::ops::Deref;\n\nuse base64::Engine;\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse ring::{\n    aead::{self, BoundKey, OpeningKey, SealingKey, UnboundKey},\n    hmac, rand as ring_rand,\n    signature::{RsaKeyPair, RSA_PSS_SHA256},\n};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse rsa::{\n    pkcs1::DecodeRsaPrivateKey,\n    pkcs8::{DecodePrivateKey, DecodePublicKey},\n    signature::Verifier,\n    traits::PublicKeyParts,\n};\n\nuse crate::{\n    consts::{BASE64_ENGINE, BASE64_ENGINE_URL_SAFE_NO_PAD},\n    errors::{self, CustomResult},\n    pii::{self, EncryptionStrategy},\n};\n\n#[derive(Clone, Debug)]\nstruct NonceSequence(u128);\n\nimpl NonceSequence {\n    /// Byte index at which sequence number starts in a 16-byte (128-bit) sequence.\n    /// This byte index considers the big endian order used while encoding and decoding the nonce\n    /// to/from a 128-bit unsigned integer.\n    const SEQUENCE_NUMBER_START_INDEX: usize = 4;\n\n    /// Generate a random nonce sequence.\n    fn new() -> Result<Self, ring::error::Unspecified> {\n        use ring::rand::{SecureRandom, SystemRandom};\n\n        let rng = SystemRandom::new();\n\n        // 96-bit sequence number, stored in a 128-bit unsigned integer in big-endian order\n        let mut sequence_number = [0_u8; 128 / 8];\n        rng.fill(&mut sequence_number[Self::SEQUENCE_NUMBER_START_INDEX..])?;\n        let sequence_number = u128::from_be_bytes(sequence_number);\n\n        Ok(Self(sequence_number))\n    }\n\n    /// Returns the current nonce value as bytes.\n    fn current(&self) -> [u8; aead::NONCE_LEN] {\n        let mut nonce = [0_u8; aead::NONCE_LEN];\n        nonce.copy_from_slice(&self.0.to_be_bytes()[Self::SEQUENCE_NUMBER_START_INDEX..]);\n        nonce\n    }\n\n    /// Constructs a nonce sequence from bytes\n    fn from_bytes(bytes: [u8; aead::NONCE_LEN]) -> Self {\n        let mut sequence_number = [0_u8; 128 / 8];\n        sequence_number[Self::SEQUENCE_NUMBER_START_INDEX..].copy_from_slice(&bytes);\n        let sequence_number = u128::from_be_bytes(sequence_number);\n        Self(sequence_number)\n    }\n}\n\nimpl aead::NonceSequence for NonceSequence {\n    fn advance(&mut self) -> Result<aead::Nonce, ring::error::Unspecified> {\n        let mut nonce = [0_u8; aead::NONCE_LEN];\n        nonce.copy_from_slice(&self.0.to_be_bytes()[Self::SEQUENCE_NUMBER_START_INDEX..]);\n\n        // Increment sequence number\n        self.0 = self.0.wrapping_add(1);\n\n        // Return previous sequence number as bytes\n        Ok(aead::Nonce::assume_unique_for_key(nonce))\n    }\n}\n\n/// Trait for cryptographically signing messages\npub trait SignMessage {\n    /// Takes in a secret and a message and returns the calculated signature as bytes\n    fn sign_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Trait for cryptographically verifying a message against a signature\npub trait VerifySignature {\n    /// Takes in a secret, the signature and the message and verifies the message\n    /// against the signature\n    fn verify_signature(\n        &self,\n        _secret: &[u8],\n        _signature: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<bool, errors::CryptoError>;\n}\n\n/// Trait for cryptographically encoding a message\npub trait EncodeMessage {\n    /// Takes in a secret and the message and encodes it, returning bytes\n    fn encode_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Trait for cryptographically decoding a message\npub trait DecodeMessage {\n    /// Takes in a secret, an encoded messages and attempts to decode it, returning bytes\n    fn decode_message(\n        &self,\n        _secret: &[u8],\n        _msg: Secret<Vec<u8>, EncryptionStrategy>,\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Represents no cryptographic algorithm.\n/// Implements all crypto traits and acts like a Nop\n#[derive(Debug)]\npub struct NoAlgorithm;\n\nimpl SignMessage for NoAlgorithm {\n    fn sign_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError> {\n        Ok(Vec::new())\n    }\n}\n\nimpl VerifySignature for NoAlgorithm {\n    fn verify_signature(\n        &self,\n        _secret: &[u8],\n        _signature: &[u8],",
    "function_name": "new",
    "file": "crates__common_utils__src__crypto.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__common_utils__src__crypto.rs",
    "code": "//! Utilities for cryptographic algorithms\nuse std::ops::Deref;\n\nuse base64::Engine;\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse ring::{\n    aead::{self, BoundKey, OpeningKey, SealingKey, UnboundKey},\n    hmac, rand as ring_rand,\n    signature::{RsaKeyPair, RSA_PSS_SHA256},\n};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse rsa::{\n    pkcs1::DecodeRsaPrivateKey,\n    pkcs8::{DecodePrivateKey, DecodePublicKey},\n    signature::Verifier,\n    traits::PublicKeyParts,\n};\n\nuse crate::{\n    consts::{BASE64_ENGINE, BASE64_ENGINE_URL_SAFE_NO_PAD},\n    errors::{self, CustomResult},\n    pii::{self, EncryptionStrategy},\n};\n\n#[derive(Clone, Debug)]\nstruct NonceSequence(u128);\n\nimpl NonceSequence {\n    /// Byte index at which sequence number starts in a 16-byte (128-bit) sequence.\n    /// This byte index considers the big endian order used while encoding and decoding the nonce\n    /// to/from a 128-bit unsigned integer.\n    const SEQUENCE_NUMBER_START_INDEX: usize = 4;\n\n    /// Generate a random nonce sequence.\n    fn new() -> Result<Self, ring::error::Unspecified> {\n        use ring::rand::{SecureRandom, SystemRandom};\n\n        let rng = SystemRandom::new();\n\n        // 96-bit sequence number, stored in a 128-bit unsigned integer in big-endian order\n        let mut sequence_number = [0_u8; 128 / 8];\n        rng.fill(&mut sequence_number[Self::SEQUENCE_NUMBER_START_INDEX..])?;\n        let sequence_number = u128::from_be_bytes(sequence_number);\n\n        Ok(Self(sequence_number))\n    }\n\n    /// Returns the current nonce value as bytes.\n    fn current(&self) -> [u8; aead::NONCE_LEN] {\n        let mut nonce = [0_u8; aead::NONCE_LEN];\n        nonce.copy_from_slice(&self.0.to_be_bytes()[Self::SEQUENCE_NUMBER_START_INDEX..]);\n        nonce\n    }\n\n    /// Constructs a nonce sequence from bytes\n    fn from_bytes(bytes: [u8; aead::NONCE_LEN]) -> Self {\n        let mut sequence_number = [0_u8; 128 / 8];\n        sequence_number[Self::SEQUENCE_NUMBER_START_INDEX..].copy_from_slice(&bytes);\n        let sequence_number = u128::from_be_bytes(sequence_number);\n        Self(sequence_number)\n    }\n}\n\nimpl aead::NonceSequence for NonceSequence {\n    fn advance(&mut self) -> Result<aead::Nonce, ring::error::Unspecified> {\n        let mut nonce = [0_u8; aead::NONCE_LEN];\n        nonce.copy_from_slice(&self.0.to_be_bytes()[Self::SEQUENCE_NUMBER_START_INDEX..]);\n\n        // Increment sequence number\n        self.0 = self.0.wrapping_add(1);\n\n        // Return previous sequence number as bytes\n        Ok(aead::Nonce::assume_unique_for_key(nonce))\n    }\n}\n\n/// Trait for cryptographically signing messages\npub trait SignMessage {\n    /// Takes in a secret and a message and returns the calculated signature as bytes\n    fn sign_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Trait for cryptographically verifying a message against a signature\npub trait VerifySignature {\n    /// Takes in a secret, the signature and the message and verifies the message\n    /// against the signature\n    fn verify_signature(\n        &self,\n        _secret: &[u8],\n        _signature: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<bool, errors::CryptoError>;\n}\n\n/// Trait for cryptographically encoding a message\npub trait EncodeMessage {\n    /// Takes in a secret and the message and encodes it, returning bytes\n    fn encode_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Trait for cryptographically decoding a message\npub trait DecodeMessage {\n    /// Takes in a secret, an encoded messages and attempts to decode it, returning bytes\n    fn decode_message(\n        &self,\n        _secret: &[u8],\n        _msg: Secret<Vec<u8>, EncryptionStrategy>,\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Represents no cryptographic algorithm.\n/// Implements all crypto traits and acts like a Nop\n#[derive(Debug)]\npub struct NoAlgorithm;\n\nimpl SignMessage for NoAlgorithm {\n    fn sign_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError> {\n        Ok(Vec::new())\n    }\n}\n\nimpl VerifySignature for NoAlgorithm {\n    fn verify_signature(\n        &self,\n        _secret: &[u8],\n        _signature: &[u8],",
    "function_name": "new",
    "file": "crates__common_utils__src__crypto.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "//! Utilities for cryptographic algorithms\nuse std::ops::Deref;\n\nuse base64::Engine;\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse ring::{\n    aead::{self, BoundKey, OpeningKey, SealingKey, UnboundKey},\n    hmac, rand as ring_rand,\n    signature::{RsaKeyPair, RSA_PSS_SHA256},\n};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nuse rsa::{\n    pkcs1::DecodeRsaPrivateKey,\n    pkcs8::{DecodePrivateKey, DecodePublicKey},\n    signature::Verifier,\n    traits::PublicKeyParts,\n};\n\nuse crate::{\n    consts::{BASE64_ENGINE, BASE64_ENGINE_URL_SAFE_NO_PAD},\n    errors::{self, CustomResult},\n    pii::{self, EncryptionStrategy},\n};\n\n#[derive(Clone, Debug)]\nstruct NonceSequence(u128);\n\nimpl NonceSequence {\n    /// Byte index at which sequence number starts in a 16-byte (128-bit) sequence.\n    /// This byte index considers the big endian order used while encoding and decoding the nonce\n    /// to/from a 128-bit unsigned integer.\n    const SEQUENCE_NUMBER_START_INDEX: usize = 4;\n\n    /// Generate a random nonce sequence.\n    fn new() -> Result<Self, ring::error::Unspecified> {\n        use ring::rand::{SecureRandom, SystemRandom};\n\n        let rng = SystemRandom::new();\n\n        // 96-bit sequence number, stored in a 128-bit unsigned integer in big-endian order\n        let mut sequence_number = [0_u8; 128 / 8];\n        rng.fill(&mut sequence_number[Self::SEQUENCE_NUMBER_START_INDEX..])?;\n        let sequence_number = u128::from_be_bytes(sequence_number);\n\n        Ok(Self(sequence_number))\n    }\n\n    /// Returns the current nonce value as bytes.\n    fn current(&self) -> [u8; aead::NONCE_LEN] {\n        let mut nonce = [0_u8; aead::NONCE_LEN];\n        nonce.copy_from_slice(&self.0.to_be_bytes()[Self::SEQUENCE_NUMBER_START_INDEX..]);\n        nonce\n    }\n\n    /// Constructs a nonce sequence from bytes\n    fn from_bytes(bytes: [u8; aead::NONCE_LEN]) -> Self {\n        let mut sequence_number = [0_u8; 128 / 8];\n        sequence_number[Self::SEQUENCE_NUMBER_START_INDEX..].copy_from_slice(&bytes);\n        let sequence_number = u128::from_be_bytes(sequence_number);\n        Self(sequence_number)\n    }\n}\n\nimpl aead::NonceSequence for NonceSequence {\n    fn advance(&mut self) -> Result<aead::Nonce, ring::error::Unspecified> {\n        let mut nonce = [0_u8; aead::NONCE_LEN];\n        nonce.copy_from_slice(&self.0.to_be_bytes()[Self::SEQUENCE_NUMBER_START_INDEX..]);\n\n        // Increment sequence number\n        self.0 = self.0.wrapping_add(1);\n\n        // Return previous sequence number as bytes\n        Ok(aead::Nonce::assume_unique_for_key(nonce))\n    }\n}\n\n/// Trait for cryptographically signing messages\npub trait SignMessage {\n    /// Takes in a secret and a message and returns the calculated signature as bytes\n    fn sign_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Trait for cryptographically verifying a message against a signature\npub trait VerifySignature {\n    /// Takes in a secret, the signature and the message and verifies the message\n    /// against the signature\n    fn verify_signature(\n        &self,\n        _secret: &[u8],\n        _signature: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<bool, errors::CryptoError>;\n}\n\n/// Trait for cryptographically encoding a message\npub trait EncodeMessage {\n    /// Takes in a secret and the message and encodes it, returning bytes\n    fn encode_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Trait for cryptographically decoding a message\npub trait DecodeMessage {\n    /// Takes in a secret, an encoded messages and attempts to decode it, returning bytes\n    fn decode_message(\n        &self,\n        _secret: &[u8],\n        _msg: Secret<Vec<u8>, EncryptionStrategy>,\n    ) -> CustomResult<Vec<u8>, errors::CryptoError>;\n}\n\n/// Represents no cryptographic algorithm.\n/// Implements all crypto traits and acts like a Nop\n#[derive(Debug)]\npub struct NoAlgorithm;\n\nimpl SignMessage for NoAlgorithm {\n    fn sign_message(\n        &self,\n        _secret: &[u8],\n        _msg: &[u8],\n    ) -> CustomResult<Vec<u8>, errors::CryptoError> {\n        Ok(Vec::new())\n    }\n}\n\nimpl VerifySignature for NoAlgorithm {\n    fn verify_signature(\n        &self,\n        _secret: &[u8],\n        _signature: &[u8],",
    "function_name": "new",
    "file": "crates__common_utils__src__crypto.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs",
    "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        convert_amount, get_unimplemented_payment_method_error_message, AddressData,\n        AddressDetailsData, BrowserInformationData, CardData as CardDataUtil, CustomerData,\n        OrderDetailsWithAmountData, PaymentMethodTokenizationRequestData,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct MollieRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for MollieRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MolliePaymentsRequest {\n    amount: Amount,\n    description: String,\n    redirect_url: String,\n    cancel_url: Option<String>,\n    webhook_url: String,\n    locale: Option<String>,\n    #[serde(flatten)]\n    payment_method_data: MolliePaymentMethodData,\n    metadata: Option<MollieMetadata>,\n    sequence_type: SequenceType,\n    customer_id: Option<String>,\n    capture_mode: Option<MollieCaptureMode>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]\npub struct Amount {\n    currency: enums::Currency,\n    value: StringMajorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(tag = \"method\")]\n#[serde(rename_all = \"lowercase\")]\npub enum MolliePaymentMethodData {\n    Applepay(Box<ApplePayMethodData>),\n    Eps,\n    Giropay,\n    Ideal(Box<IdealMethodData>),\n    Paypal(Box<PaypalMethodData>),\n    Sofort,\n    Przelewy24(Box<Przelewy24MethodData>),\n    Bancontact,\n    CreditCard(Box<CreditCardMethodData>),\n    DirectDebit(Box<DirectDebitMethodData>),\n    Klarna(Box<KlarnaMethodData>),\n    #[serde(untagged)]\n    MandatePayment(Box<MandatePaymentMethodData>),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ApplePayMethodData {\n    apple_pay_payment_token: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct IdealMethodData {\n    issuer: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaypalMethodData {\n    billing_address: Option<Address>,\n    shipping_address: Option<Address>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct KlarnaMethodData {\n    billing_address: Address,\n    lines: Vec<MollieLinesItems>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MollieLinesItems {\n    description: String,\n    quantity: i32,\n    quantity_unit: Option<String>,\n    unit_price: OrderItemUnitPrice,\n    total_amount: OrderItemUnitPrice,\n    discount_amount: Option<OrderItemUnitPrice>,\n    sku: Option<String>,\n    image_url: Option<String>,\n}\n\nimpl TryFrom<(types::OrderDetailsWithAmount, enums::Currency)> for MollieLinesItems {\n    type Error = Error;\n    fn try_from(\n        (order_details, currency): (types::OrderDetailsWithAmount, enums::Currency),\n    ) -> Result<Self, Self::Error> {\n        let description = order_details.get_order_description()?;\n        let quantity = i32::from(order_details.get_order_quantity());\n        let quantity_unit = order_details.get_optional_order_quantity_unit();\n        let sku = order_details.get_optional_sku();",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs",
    "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        convert_amount, get_unimplemented_payment_method_error_message, AddressData,\n        AddressDetailsData, BrowserInformationData, CardData as CardDataUtil, CustomerData,\n        OrderDetailsWithAmountData, PaymentMethodTokenizationRequestData,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct MollieRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for MollieRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MolliePaymentsRequest {\n    amount: Amount,\n    description: String,\n    redirect_url: String,\n    cancel_url: Option<String>,\n    webhook_url: String,\n    locale: Option<String>,\n    #[serde(flatten)]\n    payment_method_data: MolliePaymentMethodData,\n    metadata: Option<MollieMetadata>,\n    sequence_type: SequenceType,\n    customer_id: Option<String>,\n    capture_mode: Option<MollieCaptureMode>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]\npub struct Amount {\n    currency: enums::Currency,\n    value: StringMajorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(tag = \"method\")]\n#[serde(rename_all = \"lowercase\")]\npub enum MolliePaymentMethodData {\n    Applepay(Box<ApplePayMethodData>),\n    Eps,\n    Giropay,\n    Ideal(Box<IdealMethodData>),\n    Paypal(Box<PaypalMethodData>),\n    Sofort,\n    Przelewy24(Box<Przelewy24MethodData>),\n    Bancontact,\n    CreditCard(Box<CreditCardMethodData>),\n    DirectDebit(Box<DirectDebitMethodData>),\n    Klarna(Box<KlarnaMethodData>),\n    #[serde(untagged)]\n    MandatePayment(Box<MandatePaymentMethodData>),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ApplePayMethodData {\n    apple_pay_payment_token: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct IdealMethodData {\n    issuer: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaypalMethodData {\n    billing_address: Option<Address>,\n    shipping_address: Option<Address>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct KlarnaMethodData {\n    billing_address: Address,\n    lines: Vec<MollieLinesItems>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MollieLinesItems {\n    description: String,\n    quantity: i32,\n    quantity_unit: Option<String>,\n    unit_price: OrderItemUnitPrice,\n    total_amount: OrderItemUnitPrice,\n    discount_amount: Option<OrderItemUnitPrice>,\n    sku: Option<String>,\n    image_url: Option<String>,\n}\n\nimpl TryFrom<(types::OrderDetailsWithAmount, enums::Currency)> for MollieLinesItems {\n    type Error = Error;\n    fn try_from(\n        (order_details, currency): (types::OrderDetailsWithAmount, enums::Currency),\n    ) -> Result<Self, Self::Error> {\n        let description = order_details.get_order_description()?;\n        let quantity = i32::from(order_details.get_order_quantity());\n        let quantity_unit = order_details.get_optional_order_quantity_unit();\n        let sku = order_details.get_optional_sku();",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use cards::CardNumber;\nuse common_enums::enums;\nuse common_utils::{pii::Email, request::Method, types::StringMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankDebitData, BankRedirectData, PayLaterData, PaymentMethodData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken, RouterData},\n    router_request_types::ResponseId,\n    router_response_types::{\n        ConnectorCustomerResponseData, MandateReference, PaymentsResponseData, RedirectForm,\n        RefundsResponseData,\n    },\n    types,\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    unimplemented_payment_method,\n    utils::{\n        convert_amount, get_unimplemented_payment_method_error_message, AddressData,\n        AddressDetailsData, BrowserInformationData, CardData as CardDataUtil, CustomerData,\n        OrderDetailsWithAmountData, PaymentMethodTokenizationRequestData,\n        PaymentsAuthorizeRequestData, PaymentsSetupMandateRequestData,\n        RouterData as OtherRouterData,\n    },\n};\n\ntype Error = error_stack::Report<errors::ConnectorError>;\n\n#[derive(Debug, Serialize)]\npub struct MollieRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for MollieRouterData<T> {\n    fn from((amount, router_data): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MolliePaymentsRequest {\n    amount: Amount,\n    description: String,\n    redirect_url: String,\n    cancel_url: Option<String>,\n    webhook_url: String,\n    locale: Option<String>,\n    #[serde(flatten)]\n    payment_method_data: MolliePaymentMethodData,\n    metadata: Option<MollieMetadata>,\n    sequence_type: SequenceType,\n    customer_id: Option<String>,\n    capture_mode: Option<MollieCaptureMode>,\n}\n\n#[derive(Default, Debug, Serialize, Deserialize)]\npub struct Amount {\n    currency: enums::Currency,\n    value: StringMajorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(tag = \"method\")]\n#[serde(rename_all = \"lowercase\")]\npub enum MolliePaymentMethodData {\n    Applepay(Box<ApplePayMethodData>),\n    Eps,\n    Giropay,\n    Ideal(Box<IdealMethodData>),\n    Paypal(Box<PaypalMethodData>),\n    Sofort,\n    Przelewy24(Box<Przelewy24MethodData>),\n    Bancontact,\n    CreditCard(Box<CreditCardMethodData>),\n    DirectDebit(Box<DirectDebitMethodData>),\n    Klarna(Box<KlarnaMethodData>),\n    #[serde(untagged)]\n    MandatePayment(Box<MandatePaymentMethodData>),\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ApplePayMethodData {\n    apple_pay_payment_token: Secret<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct IdealMethodData {\n    issuer: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PaypalMethodData {\n    billing_address: Option<Address>,\n    shipping_address: Option<Address>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct KlarnaMethodData {\n    billing_address: Address,\n    lines: Vec<MollieLinesItems>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MollieLinesItems {\n    description: String,\n    quantity: i32,\n    quantity_unit: Option<String>,\n    unit_price: OrderItemUnitPrice,\n    total_amount: OrderItemUnitPrice,\n    discount_amount: Option<OrderItemUnitPrice>,\n    sku: Option<String>,\n    image_url: Option<String>,\n}\n\nimpl TryFrom<(types::OrderDetailsWithAmount, enums::Currency)> for MollieLinesItems {\n    type Error = Error;\n    fn try_from(\n        (order_details, currency): (types::OrderDetailsWithAmount, enums::Currency),\n    ) -> Result<Self, Self::Error> {\n        let description = order_details.get_order_description()?;\n        let quantity = i32::from(order_details.get_order_quantity());\n        let quantity_unit = order_details.get_optional_order_quantity_unit();\n        let sku = order_details.get_optional_sku();",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__mollie__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__celero.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as celero;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Celero {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Celero {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Celero {}\nimpl api::PaymentSession for Celero {}\nimpl api::ConnectorAccessToken for Celero {}\nimpl api::MandateSetup for Celero {}\nimpl api::PaymentAuthorize for Celero {}\nimpl api::PaymentSync for Celero {}\nimpl api::PaymentCapture for Celero {}\nimpl api::PaymentVoid for Celero {}\nimpl api::Refund for Celero {}\nimpl api::RefundExecute for Celero {}\nimpl api::RefundSync for Celero {}\nimpl api::PaymentToken for Celero {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Celero\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Celero\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Celero {\n    fn id(&self) -> &'static str {\n        \"celero\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.celero.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = celero::CeleroAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: celero::CeleroErrorResponse = res\n            .response\n            .parse_struct(\"CeleroErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__celero.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__celero.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as celero;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Celero {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Celero {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Celero {}\nimpl api::PaymentSession for Celero {}\nimpl api::ConnectorAccessToken for Celero {}\nimpl api::MandateSetup for Celero {}\nimpl api::PaymentAuthorize for Celero {}\nimpl api::PaymentSync for Celero {}\nimpl api::PaymentCapture for Celero {}\nimpl api::PaymentVoid for Celero {}\nimpl api::Refund for Celero {}\nimpl api::RefundExecute for Celero {}\nimpl api::RefundSync for Celero {}\nimpl api::PaymentToken for Celero {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Celero\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Celero\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Celero {\n    fn id(&self) -> &'static str {\n        \"celero\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.celero.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = celero::CeleroAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: celero::CeleroErrorResponse = res\n            .response\n            .parse_struct(\"CeleroErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__celero.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as celero;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Celero {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Celero {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Celero {}\nimpl api::PaymentSession for Celero {}\nimpl api::ConnectorAccessToken for Celero {}\nimpl api::MandateSetup for Celero {}\nimpl api::PaymentAuthorize for Celero {}\nimpl api::PaymentSync for Celero {}\nimpl api::PaymentCapture for Celero {}\nimpl api::PaymentVoid for Celero {}\nimpl api::Refund for Celero {}\nimpl api::RefundExecute for Celero {}\nimpl api::RefundSync for Celero {}\nimpl api::PaymentToken for Celero {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Celero\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Celero\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Celero {\n    fn id(&self) -> &'static str {\n        \"celero\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.celero.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = celero::CeleroAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: celero::CeleroErrorResponse = res\n            .response\n            .parse_struct(\"CeleroErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__celero.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{self, RefundsResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _},\n};\n\nconst NO_REFUND_REASON: &str = \"No reason provided\";\n\n//TODO: Fill the struct with respective fields\npub struct PayjustnowRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayjustnowRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowPaymentsRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    request_id: Option<String>,\n    payjustnow: PayjustnowRequest,\n    checkout_total_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowRequest {\n    merchant_order_reference: String,\n    order_amount_cents: MinorUnit,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    order_items: Option<Vec<OrderItem>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer: Option<Customer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<Address>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shipping_address: Option<Address>,\n    confirm_redirect_url: String,\n    cancel_redirect_url: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OrderItem {\n    name: String,\n    sku: String,\n    quantity: u32,\n    price_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Customer {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    first_name: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    last_name: Option<Secret<String>>,\n    email: pii::Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    phone_number: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Address {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    address_line1: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    address_line2: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    city: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    province: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    postal_code: Option<Secret<String>>,\n}\n\nimpl Address {\n    fn is_empty(&self) -> bool {\n        self.address_line1.is_none()\n            && self.address_line2.is_none()\n            && self.city.is_none()\n            && self.province.is_none()\n            && self.postal_code.is_none()\n    }\n}\n\nimpl TryFrom<&PayjustnowRouterData<&PaymentsAuthorizeRouterData>> for PayjustnowPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &PayjustnowRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let router_data = item.router_data;\n        let order_items = router_data\n            .request\n            .order_details\n            .as_ref()\n            .map(|order_details| {\n                order_details\n                    .iter()\n                    .map(|order| {\n                        Ok(OrderItem {\n                            name: order.product_name.clone(),\n                            sku: order.product_id.clone().unwrap_or_default(),\n                            quantity: u32::from(order.quantity),\n                            price_cents: order.amount,\n                        })\n                    })\n                    .collect::<Result<Vec<OrderItem>, errors::ConnectorError>>()\n            })\n            .transpose()?;\n\n        let customer = router_data\n            .get_optional_billing_email()\n            .or_else(|| item.router_data.request.email.clone())\n            .map(|email| Customer {",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{self, RefundsResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _},\n};\n\nconst NO_REFUND_REASON: &str = \"No reason provided\";\n\n//TODO: Fill the struct with respective fields\npub struct PayjustnowRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayjustnowRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowPaymentsRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    request_id: Option<String>,\n    payjustnow: PayjustnowRequest,\n    checkout_total_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowRequest {\n    merchant_order_reference: String,\n    order_amount_cents: MinorUnit,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    order_items: Option<Vec<OrderItem>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer: Option<Customer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<Address>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shipping_address: Option<Address>,\n    confirm_redirect_url: String,\n    cancel_redirect_url: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OrderItem {\n    name: String,\n    sku: String,\n    quantity: u32,\n    price_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Customer {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    first_name: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    last_name: Option<Secret<String>>,\n    email: pii::Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    phone_number: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Address {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    address_line1: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    address_line2: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    city: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    province: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    postal_code: Option<Secret<String>>,\n}\n\nimpl Address {\n    fn is_empty(&self) -> bool {\n        self.address_line1.is_none()\n            && self.address_line2.is_none()\n            && self.city.is_none()\n            && self.province.is_none()\n            && self.postal_code.is_none()\n    }\n}\n\nimpl TryFrom<&PayjustnowRouterData<&PaymentsAuthorizeRouterData>> for PayjustnowPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &PayjustnowRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let router_data = item.router_data;\n        let order_items = router_data\n            .request\n            .order_details\n            .as_ref()\n            .map(|order_details| {\n                order_details\n                    .iter()\n                    .map(|order| {\n                        Ok(OrderItem {\n                            name: order.product_name.clone(),\n                            sku: order.product_id.clone().unwrap_or_default(),\n                            quantity: u32::from(order.quantity),\n                            price_cents: order.amount,\n                        })\n                    })\n                    .collect::<Result<Vec<OrderItem>, errors::ConnectorError>>()\n            })\n            .transpose()?;\n\n        let customer = router_data\n            .get_optional_billing_email()\n            .or_else(|| item.router_data.request.email.clone())\n            .map(|email| Customer {",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::enums;\nuse common_utils::{pii, request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{self, RefundsResponseRouterData},\n    utils::{PaymentsAuthorizeRequestData, PaymentsSyncRequestData, RouterData as _},\n};\n\nconst NO_REFUND_REASON: &str = \"No reason provided\";\n\n//TODO: Fill the struct with respective fields\npub struct PayjustnowRouterData<T> {\n    pub amount: MinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for PayjustnowRouterData<T> {\n    fn from((amount, item): (MinorUnit, T)) -> Self {\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowPaymentsRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    request_id: Option<String>,\n    payjustnow: PayjustnowRequest,\n    checkout_total_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PayjustnowRequest {\n    merchant_order_reference: String,\n    order_amount_cents: MinorUnit,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    order_items: Option<Vec<OrderItem>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    customer: Option<Customer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    billing_address: Option<Address>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shipping_address: Option<Address>,\n    confirm_redirect_url: String,\n    cancel_redirect_url: String,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OrderItem {\n    name: String,\n    sku: String,\n    quantity: u32,\n    price_cents: MinorUnit,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Customer {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    first_name: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    last_name: Option<Secret<String>>,\n    email: pii::Email,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    phone_number: Option<Secret<String>>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Address {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    address_line1: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    address_line2: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    city: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    province: Option<Secret<String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    postal_code: Option<Secret<String>>,\n}\n\nimpl Address {\n    fn is_empty(&self) -> bool {\n        self.address_line1.is_none()\n            && self.address_line2.is_none()\n            && self.city.is_none()\n            && self.province.is_none()\n            && self.postal_code.is_none()\n    }\n}\n\nimpl TryFrom<&PayjustnowRouterData<&PaymentsAuthorizeRouterData>> for PayjustnowPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &PayjustnowRouterData<&PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let router_data = item.router_data;\n        let order_items = router_data\n            .request\n            .order_details\n            .as_ref()\n            .map(|order_details| {\n                order_details\n                    .iter()\n                    .map(|order| {\n                        Ok(OrderItem {\n                            name: order.product_name.clone(),\n                            sku: order.product_id.clone().unwrap_or_default(),\n                            quantity: u32::from(order.quantity),\n                            price_cents: order.amount,\n                        })\n                    })\n                    .collect::<Result<Vec<OrderItem>, errors::ConnectorError>>()\n            })\n            .transpose()?;\n\n        let customer = router_data\n            .get_optional_billing_email()\n            .or_else(|| item.router_data.request.email.clone())\n            .map(|email| Customer {",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__payjustnow__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__affirm.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as affirm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Affirm {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Affirm {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Affirm {}\nimpl api::PaymentSession for Affirm {}\nimpl api::ConnectorAccessToken for Affirm {}\nimpl api::MandateSetup for Affirm {}\nimpl api::PaymentAuthorize for Affirm {}\nimpl api::PaymentsCompleteAuthorize for Affirm {}\nimpl api::PaymentSync for Affirm {}\nimpl api::PaymentCapture for Affirm {}\nimpl api::PaymentVoid for Affirm {}\nimpl api::Refund for Affirm {}\nimpl api::RefundExecute for Affirm {}\nimpl api::RefundSync for Affirm {}\nimpl api::PaymentToken for Affirm {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Affirm\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Affirm\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Affirm {\n    fn id(&self) -> &'static str {\n        \"affirm\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.affirm.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = affirm::AffirmAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key = BASE64_ENGINE.encode(format!(\n            \"{}:{}\",\n            auth.public_key.peek(),\n            auth.private_key.peek()\n        ));\n\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__affirm.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__affirm.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as affirm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Affirm {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Affirm {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Affirm {}\nimpl api::PaymentSession for Affirm {}\nimpl api::ConnectorAccessToken for Affirm {}\nimpl api::MandateSetup for Affirm {}\nimpl api::PaymentAuthorize for Affirm {}\nimpl api::PaymentsCompleteAuthorize for Affirm {}\nimpl api::PaymentSync for Affirm {}\nimpl api::PaymentCapture for Affirm {}\nimpl api::PaymentVoid for Affirm {}\nimpl api::Refund for Affirm {}\nimpl api::RefundExecute for Affirm {}\nimpl api::RefundSync for Affirm {}\nimpl api::PaymentToken for Affirm {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Affirm\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Affirm\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Affirm {\n    fn id(&self) -> &'static str {\n        \"affirm\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.affirm.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = affirm::AffirmAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key = BASE64_ENGINE.encode(format!(\n            \"{}:{}\",\n            auth.public_key.peek(),\n            auth.private_key.peek()\n        ));\n\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__affirm.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as affirm;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Affirm {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Affirm {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Affirm {}\nimpl api::PaymentSession for Affirm {}\nimpl api::ConnectorAccessToken for Affirm {}\nimpl api::MandateSetup for Affirm {}\nimpl api::PaymentAuthorize for Affirm {}\nimpl api::PaymentsCompleteAuthorize for Affirm {}\nimpl api::PaymentSync for Affirm {}\nimpl api::PaymentCapture for Affirm {}\nimpl api::PaymentVoid for Affirm {}\nimpl api::Refund for Affirm {}\nimpl api::RefundExecute for Affirm {}\nimpl api::RefundSync for Affirm {}\nimpl api::PaymentToken for Affirm {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Affirm\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Affirm\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Affirm {\n    fn id(&self) -> &'static str {\n        \"affirm\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.affirm.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = affirm::AffirmAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key = BASE64_ENGINE.encode(format!(\n            \"{}:{}\",\n            auth.public_key.peek(),\n            auth.private_key.peek()\n        ));\n\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__affirm.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs",
    "code": "use hyperswitch_domain_models::{router_request_types::*, router_response_types::*};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface as _, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::utils::ForeignTryFrom;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum RefundOutcome {\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularEventResponse {\n    pub last_event: EventType,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<EventLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WroldpayModularActualPsyncResponseObj {\n    pub last_event: PaymentOutcome,\n    pub value: super::PaymentValue,\n}\n\n// Sent for settlement plays totally differnt role in worldpaymodular in webhooks and psync\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayModularPsyncObjResponse {\n    PsyncResponse(WroldpayModularActualPsyncResponseObj),\n    Webhook(WorldpaymodularWebhookEventType),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularCaptureResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularVoidResponse {\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<PaymentLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum EventType {\n    #[serde(alias = \"sentForAuthorization\", alias = \"Sent for Authorization\")]\n    SentForAuthorization,\n    #[serde(alias = \"Authorized\", alias = \"authorized\")]\n    Authorized,\n    #[serde(alias = \"Sent for Settlement\", alias = \"sentForSettlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Settlement Failed\", alias = \"settlementFailed\")]\n    SettlementFailed,\n    #[serde(alias = \"Settlement Rejected\", alias = \"settlementRejected\")]\n    SettlementRejected,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    #[serde(alias = \"Sent for Refund\", alias = \"sentForRefund\")]\n    SentForRefund,\n    RefundFailed,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]\npub struct PaymentLinks {\n    #[serde(\n        rename = \"cardPayments:events\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub events: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:settle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialSettle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:refund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialRefund\",",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs",
    "code": "use hyperswitch_domain_models::{router_request_types::*, router_response_types::*};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface as _, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::utils::ForeignTryFrom;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum RefundOutcome {\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularEventResponse {\n    pub last_event: EventType,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<EventLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WroldpayModularActualPsyncResponseObj {\n    pub last_event: PaymentOutcome,\n    pub value: super::PaymentValue,\n}\n\n// Sent for settlement plays totally differnt role in worldpaymodular in webhooks and psync\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayModularPsyncObjResponse {\n    PsyncResponse(WroldpayModularActualPsyncResponseObj),\n    Webhook(WorldpaymodularWebhookEventType),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularCaptureResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularVoidResponse {\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<PaymentLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum EventType {\n    #[serde(alias = \"sentForAuthorization\", alias = \"Sent for Authorization\")]\n    SentForAuthorization,\n    #[serde(alias = \"Authorized\", alias = \"authorized\")]\n    Authorized,\n    #[serde(alias = \"Sent for Settlement\", alias = \"sentForSettlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Settlement Failed\", alias = \"settlementFailed\")]\n    SettlementFailed,\n    #[serde(alias = \"Settlement Rejected\", alias = \"settlementRejected\")]\n    SettlementRejected,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    #[serde(alias = \"Sent for Refund\", alias = \"sentForRefund\")]\n    SentForRefund,\n    RefundFailed,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]\npub struct PaymentLinks {\n    #[serde(\n        rename = \"cardPayments:events\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub events: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:settle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialSettle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:refund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialRefund\",",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_resource_id",
    "code": "use hyperswitch_domain_models::{router_request_types::*, router_response_types::*};\nuse hyperswitch_interfaces::errors::ConnectorError;\nuse masking::{ExposeInterface as _, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::utils::ForeignTryFrom;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularPaymentsResponse {\n    pub outcome: PaymentOutcome,\n    /// Any risk factors which have been identified for the authorization. This section will not appear if no risks are identified.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub risk_factors: Option<Vec<RiskFactorsInner>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub issuer: Option<Issuer>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub scheme: Option<PaymentsResponseScheme>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payment_instrument: Option<PaymentsResPaymentInstrument>,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpayModularRefundResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum PaymentOutcome {\n    #[serde(alias = \"authorized\", alias = \"Authorized\")]\n    Authorized,\n    Refused,\n    #[serde(alias = \"Sent for Settlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n    #[serde(alias = \"Sent for Cancellation\")]\n    SentForCancellation,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum RefundOutcome {\n    #[serde(alias = \"Sent for Refund\")]\n    SentForRefund,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularEventResponse {\n    pub last_event: EventType,\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<EventLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WroldpayModularActualPsyncResponseObj {\n    pub last_event: PaymentOutcome,\n    pub value: super::PaymentValue,\n}\n\n// Sent for settlement plays totally differnt role in worldpaymodular in webhooks and psync\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WorldpayModularPsyncObjResponse {\n    PsyncResponse(WroldpayModularActualPsyncResponseObj),\n    Webhook(WorldpaymodularWebhookEventType),\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularCaptureResponse {\n    pub payment_id: String,\n    #[serde(rename = \"_links\")]\n    pub links: PaymentLinks,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct WorldpaymodularVoidResponse {\n    #[serde(rename = \"_links\", skip_serializing_if = \"Option::is_none\")]\n    pub links: Option<PaymentLinks>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum EventType {\n    #[serde(alias = \"sentForAuthorization\", alias = \"Sent for Authorization\")]\n    SentForAuthorization,\n    #[serde(alias = \"Authorized\", alias = \"authorized\")]\n    Authorized,\n    #[serde(alias = \"Sent for Settlement\", alias = \"sentForSettlement\")]\n    SentForSettlement,\n    #[serde(alias = \"Settlement Failed\", alias = \"settlementFailed\")]\n    SettlementFailed,\n    #[serde(alias = \"Settlement Rejected\", alias = \"settlementRejected\")]\n    SettlementRejected,\n    Cancelled,\n    Error,\n    Expired,\n    Refused,\n    #[serde(alias = \"Sent for Refund\", alias = \"sentForRefund\")]\n    SentForRefund,\n    RefundFailed,\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]\npub struct PaymentLinks {\n    #[serde(\n        rename = \"cardPayments:events\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub events: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:settle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialSettle\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub partial_settle_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:refund\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub refund_event: Option<PaymentLink>,\n    #[serde(\n        rename = \"cardPayments:partialRefund\",",
    "function_name": "unknown_symbol",
    "file": "crates__hyperswitch_connectors__src__connectors__worldpaymodular__transformers__response.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__router_response_types.rs",
    "code": "pub mod disputes;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\nuse std::collections::HashMap;\n\nuse api_models::payments::AddressDetails;\nuse common_utils::{pii, request::Method, types::MinorUnit};\npub use disputes::{\n    AcceptDisputeResponse, DefendDisputeResponse, DisputeSyncResponse, FetchDisputesResponse,\n    SubmitEvidenceResponse,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    errors::api_error_response::ApiErrorResponse,\n    router_request_types::{authentication::AuthNFlowType, ResponseId, UcsAuthenticationData},\n    vault::PaymentMethodVaultingData,\n};\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct RefundsResponseData {\n    pub connector_refund_id: String,\n    pub refund_status: common_enums::RefundStatus,\n    // pub amount_received: Option<i32>, // Calculation for amount received not in place yet\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConnectorCustomerResponseData {\n    pub connector_customer_id: String,\n    pub name: Option<String>,\n    pub email: Option<String>,\n    pub billing_address: Option<AddressDetails>,\n}\n\nimpl ConnectorCustomerResponseData {\n    pub fn new_with_customer_id(connector_customer_id: String) -> Self {\n        Self::new(connector_customer_id, None, None, None)\n    }\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct GiftCardBalanceCheckResponseData {\n    pub balance: MinorUnit,\n    pub currency: common_enums::Currency,\n}\n\n#[derive(Debug, Clone)]\npub struct TaxCalculationResponseData {\n    pub order_tax_amount: MinorUnit,\n}\n\n#[derive(Serialize, Debug, Clone, serde::Deserialize)]\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum CaptureSyncResponse {\n    Success {",
    "function_name": "new_with_customer_id",
    "file": "crates__hyperswitch_domain_models__src__router_response_types.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_domain_models__src__router_response_types.rs",
    "code": "pub mod disputes;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\nuse std::collections::HashMap;\n\nuse api_models::payments::AddressDetails;\nuse common_utils::{pii, request::Method, types::MinorUnit};\npub use disputes::{\n    AcceptDisputeResponse, DefendDisputeResponse, DisputeSyncResponse, FetchDisputesResponse,\n    SubmitEvidenceResponse,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    errors::api_error_response::ApiErrorResponse,\n    router_request_types::{authentication::AuthNFlowType, ResponseId, UcsAuthenticationData},\n    vault::PaymentMethodVaultingData,\n};\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct RefundsResponseData {\n    pub connector_refund_id: String,\n    pub refund_status: common_enums::RefundStatus,\n    // pub amount_received: Option<i32>, // Calculation for amount received not in place yet\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConnectorCustomerResponseData {\n    pub connector_customer_id: String,\n    pub name: Option<String>,\n    pub email: Option<String>,\n    pub billing_address: Option<AddressDetails>,\n}\n\nimpl ConnectorCustomerResponseData {\n    pub fn new_with_customer_id(connector_customer_id: String) -> Self {\n        Self::new(connector_customer_id, None, None, None)\n    }\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct GiftCardBalanceCheckResponseData {\n    pub balance: MinorUnit,\n    pub currency: common_enums::Currency,\n}\n\n#[derive(Debug, Clone)]\npub struct TaxCalculationResponseData {\n    pub order_tax_amount: MinorUnit,\n}\n\n#[derive(Serialize, Debug, Clone, serde::Deserialize)]\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum CaptureSyncResponse {\n    Success {",
    "function_name": "new_with_customer_id",
    "file": "crates__hyperswitch_domain_models__src__router_response_types.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new_with_customer_id",
    "code": "pub mod disputes;\npub mod fraud_check;\npub mod merchant_connector_webhook_management;\npub mod revenue_recovery;\npub mod subscriptions;\nuse std::collections::HashMap;\n\nuse api_models::payments::AddressDetails;\nuse common_utils::{pii, request::Method, types::MinorUnit};\npub use disputes::{\n    AcceptDisputeResponse, DefendDisputeResponse, DisputeSyncResponse, FetchDisputesResponse,\n    SubmitEvidenceResponse,\n};\nuse error_stack::ResultExt;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    errors::api_error_response::ApiErrorResponse,\n    router_request_types::{authentication::AuthNFlowType, ResponseId, UcsAuthenticationData},\n    vault::PaymentMethodVaultingData,\n};\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct RefundsResponseData {\n    pub connector_refund_id: String,\n    pub refund_status: common_enums::RefundStatus,\n    // pub amount_received: Option<i32>, // Calculation for amount received not in place yet\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ConnectorCustomerResponseData {\n    pub connector_customer_id: String,\n    pub name: Option<String>,\n    pub email: Option<String>,\n    pub billing_address: Option<AddressDetails>,\n}\n\nimpl ConnectorCustomerResponseData {\n    pub fn new_with_customer_id(connector_customer_id: String) -> Self {\n        Self::new(connector_customer_id, None, None, None)\n    }\n    pub fn new(\n        connector_customer_id: String,\n        name: Option<String>,\n        email: Option<String>,\n        billing_address: Option<AddressDetails>,\n    ) -> Self {\n        Self {\n            connector_customer_id,\n            name,\n            email,\n            billing_address,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum PaymentsResponseData {\n    TransactionResponse {\n        resource_id: ResponseId,\n        redirection_data: Box<Option<RedirectForm>>,\n        mandate_reference: Box<Option<MandateReference>>,\n        connector_metadata: Option<serde_json::Value>,\n        network_txn_id: Option<String>,\n        connector_response_reference_id: Option<String>,\n        incremental_authorization_allowed: Option<bool>,\n        authentication_data: Option<Box<UcsAuthenticationData>>,\n        charges: Option<common_types::payments::ConnectorChargeResponseData>,\n    },\n    MultipleCaptureResponse {\n        // pending_capture_id_list: Vec<String>,\n        capture_sync_response_list: HashMap<String, CaptureSyncResponse>,\n    },\n    SessionResponse {\n        session_token: api_models::payments::SessionToken,\n    },\n    SessionTokenResponse {\n        session_token: String,\n    },\n    TransactionUnresolvedResponse {\n        resource_id: ResponseId,\n        //to add more info on cypto response, like `unresolved` reason(overpaid, underpaid, delayed)\n        reason: Option<api_models::enums::UnresolvedResponseReason>,\n        connector_response_reference_id: Option<String>,\n    },\n    TokenizationResponse {\n        token: String,\n    },\n\n    ConnectorCustomerResponse(ConnectorCustomerResponseData),\n\n    ThreeDSEnrollmentResponse {\n        enrolled_v2: bool,\n        related_transaction_id: Option<String>,\n    },\n    PreProcessingResponse {\n        pre_processing_id: PreprocessingResponseId,\n        connector_metadata: Option<serde_json::Value>,\n        session_token: Option<api_models::payments::SessionToken>,\n        connector_response_reference_id: Option<String>,\n    },\n    IncrementalAuthorizationResponse {\n        status: common_enums::AuthorizationStatus,\n        connector_authorization_id: Option<String>,\n        error_code: Option<String>,\n        error_message: Option<String>,\n    },\n    PostProcessingResponse {\n        session_token: Option<api_models::payments::OpenBankingSessionToken>,\n    },\n    PaymentResourceUpdateResponse {\n        status: common_enums::PaymentResourceUpdateStatus,\n    },\n    PaymentsCreateOrderResponse {\n        order_id: String,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct GiftCardBalanceCheckResponseData {\n    pub balance: MinorUnit,\n    pub currency: common_enums::Currency,\n}\n\n#[derive(Debug, Clone)]\npub struct TaxCalculationResponseData {\n    pub order_tax_amount: MinorUnit,\n}\n\n#[derive(Serialize, Debug, Clone, serde::Deserialize)]\npub struct MandateReference {\n    pub connector_mandate_id: Option<String>,\n    pub payment_method_id: Option<String>,\n    pub mandate_metadata: Option<pii::SecretSerdeValue>,\n    pub connector_mandate_request_reference_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum CaptureSyncResponse {\n    Success {",
    "function_name": "new_with_customer_id",
    "file": "crates__hyperswitch_domain_models__src__router_response_types.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__analytics__src__sqlx.rs",
    "code": "use std::{fmt::Display, str::FromStr};\n\nuse api_models::{\n    analytics::{frm::FrmTransactionType, refunds::RefundType},\n    enums::{DisputeStage, DisputeStatus},\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    DbConnectionParams,\n};\nuse diesel_models::enums::{\n    AttemptStatus, AuthenticationType, Currency, FraudCheckStatus, IntentStatus, PaymentMethod,\n    RefundStatus, RoutingApproach,\n};\nuse error_stack::ResultExt;\nuse sqlx::{\n    postgres::{PgArgumentBuffer, PgPoolOptions, PgRow, PgTypeInfo, PgValueRef},\n    Decode, Encode,\n    Error::ColumnNotFound,\n    FromRow, Pool, Postgres, Row,\n};\nuse storage_impl::config::Database;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    health_check::HealthCheck,\n    query::{Aggregate, ToSql, Window},\n    types::{\n        AnalyticsCollection, AnalyticsDataSource, DBEnumWrapper, LoadRow, QueryExecutionError,\n        TableEngine,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct SqlxClient {\n    pool: Pool<Postgres>,\n}\n\nimpl Default for SqlxClient {\n    fn default() -> Self {\n        let database_url = format!(\n            \"postgres://{}:{}@{}:{}/{}\",\n            \"db_user\", \"db_pass\", \"localhost\", 5432, \"hyperswitch_db\"\n        );\n        Self {\n            #[allow(clippy::expect_used)]\n            pool: PgPoolOptions::new()\n                .connect_lazy(&database_url)\n                .expect(\"SQLX Pool Creation failed\"),\n        }\n    }\n}\n\nimpl SqlxClient {\n    pub async fn from_conf(conf: &Database, schema: &str) -> Self {\n        let database_url = conf.get_database_url(schema);\n        #[allow(clippy::expect_used)]\n        let pool = PgPoolOptions::new()\n            .max_connections(conf.pool_size)\n            .acquire_timeout(std::time::Duration::from_secs(conf.connection_timeout))\n            .connect_lazy(&database_url)\n            .expect(\"SQLX Pool Creation failed\");\n        Self { pool }\n    }\n}\n\npub trait DbType {\n    fn name() -> &'static str;\n}\n\nmacro_rules! db_type {\n    ($a: ident, $str: tt) => {\n        impl DbType for $a {\n            fn name() -> &'static str {\n                stringify!($str)\n            }\n        }\n    };\n    ($a:ident) => {\n        impl DbType for $a {\n            fn name() -> &'static str {\n                stringify!($a)\n            }\n        }\n    };\n}\n\ndb_type!(Currency);\ndb_type!(AuthenticationType);\ndb_type!(AttemptStatus);\ndb_type!(IntentStatus);\ndb_type!(PaymentMethod, TEXT);\ndb_type!(RefundStatus);\ndb_type!(RefundType);\ndb_type!(FraudCheckStatus);\ndb_type!(FrmTransactionType);\ndb_type!(DisputeStage);\ndb_type!(DisputeStatus);\ndb_type!(AuthenticationStatus);\ndb_type!(TransactionStatus);\ndb_type!(AuthenticationConnectors);\ndb_type!(DecoupledAuthenticationType);\ndb_type!(RoutingApproach);\n\nimpl<'q, Type> Encode<'q, Postgres> for DBEnumWrapper<Type>\nwhere\n    Type: DbType + FromStr + Display,\n{\n    fn encode_by_ref(\n        &self,\n        buf: &mut PgArgumentBuffer,\n    ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync + 'static>> {\n        <String as Encode<'q, Postgres>>::encode(self.0.to_string(), buf)\n    }\n    fn size_hint(&self) -> usize {\n        <String as Encode<'q, Postgres>>::size_hint(&self.0.to_string())\n    }\n}\n\nimpl<'r, Type> Decode<'r, Postgres> for DBEnumWrapper<Type>\nwhere\n    Type: DbType + FromStr + Display,\n{\n    fn decode(\n        value: PgValueRef<'r>,\n    ) -> Result<Self, Box<dyn std::error::Error + 'static + Send + Sync>> {\n        let str_value = <&'r str as Decode<'r, Postgres>>::decode(value)?;\n        Type::from_str(str_value).map(DBEnumWrapper).or(Err(format!(\n            \"invalid value {:?} for enum {}\",\n            str_value,\n            Type::name()\n        )\n        .into()))\n    }\n}\n\nimpl<Type> sqlx::Type<Postgres> for DBEnumWrapper<Type>",
    "function_name": "default",
    "file": "crates__analytics__src__sqlx.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__analytics__src__sqlx.rs",
    "code": "use std::{fmt::Display, str::FromStr};\n\nuse api_models::{\n    analytics::{frm::FrmTransactionType, refunds::RefundType},\n    enums::{DisputeStage, DisputeStatus},\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    DbConnectionParams,\n};\nuse diesel_models::enums::{\n    AttemptStatus, AuthenticationType, Currency, FraudCheckStatus, IntentStatus, PaymentMethod,\n    RefundStatus, RoutingApproach,\n};\nuse error_stack::ResultExt;\nuse sqlx::{\n    postgres::{PgArgumentBuffer, PgPoolOptions, PgRow, PgTypeInfo, PgValueRef},\n    Decode, Encode,\n    Error::ColumnNotFound,\n    FromRow, Pool, Postgres, Row,\n};\nuse storage_impl::config::Database;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    health_check::HealthCheck,\n    query::{Aggregate, ToSql, Window},\n    types::{\n        AnalyticsCollection, AnalyticsDataSource, DBEnumWrapper, LoadRow, QueryExecutionError,\n        TableEngine,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct SqlxClient {\n    pool: Pool<Postgres>,\n}\n\nimpl Default for SqlxClient {\n    fn default() -> Self {\n        let database_url = format!(\n            \"postgres://{}:{}@{}:{}/{}\",\n            \"db_user\", \"db_pass\", \"localhost\", 5432, \"hyperswitch_db\"\n        );\n        Self {\n            #[allow(clippy::expect_used)]\n            pool: PgPoolOptions::new()\n                .connect_lazy(&database_url)\n                .expect(\"SQLX Pool Creation failed\"),\n        }\n    }\n}\n\nimpl SqlxClient {\n    pub async fn from_conf(conf: &Database, schema: &str) -> Self {\n        let database_url = conf.get_database_url(schema);\n        #[allow(clippy::expect_used)]\n        let pool = PgPoolOptions::new()\n            .max_connections(conf.pool_size)\n            .acquire_timeout(std::time::Duration::from_secs(conf.connection_timeout))\n            .connect_lazy(&database_url)\n            .expect(\"SQLX Pool Creation failed\");\n        Self { pool }\n    }\n}\n\npub trait DbType {\n    fn name() -> &'static str;\n}\n\nmacro_rules! db_type {\n    ($a: ident, $str: tt) => {\n        impl DbType for $a {\n            fn name() -> &'static str {\n                stringify!($str)\n            }\n        }\n    };\n    ($a:ident) => {\n        impl DbType for $a {\n            fn name() -> &'static str {\n                stringify!($a)\n            }\n        }\n    };\n}\n\ndb_type!(Currency);\ndb_type!(AuthenticationType);\ndb_type!(AttemptStatus);\ndb_type!(IntentStatus);\ndb_type!(PaymentMethod, TEXT);\ndb_type!(RefundStatus);\ndb_type!(RefundType);\ndb_type!(FraudCheckStatus);\ndb_type!(FrmTransactionType);\ndb_type!(DisputeStage);\ndb_type!(DisputeStatus);\ndb_type!(AuthenticationStatus);\ndb_type!(TransactionStatus);\ndb_type!(AuthenticationConnectors);\ndb_type!(DecoupledAuthenticationType);\ndb_type!(RoutingApproach);\n\nimpl<'q, Type> Encode<'q, Postgres> for DBEnumWrapper<Type>\nwhere\n    Type: DbType + FromStr + Display,\n{\n    fn encode_by_ref(\n        &self,\n        buf: &mut PgArgumentBuffer,\n    ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync + 'static>> {\n        <String as Encode<'q, Postgres>>::encode(self.0.to_string(), buf)\n    }\n    fn size_hint(&self) -> usize {\n        <String as Encode<'q, Postgres>>::size_hint(&self.0.to_string())\n    }\n}\n\nimpl<'r, Type> Decode<'r, Postgres> for DBEnumWrapper<Type>\nwhere\n    Type: DbType + FromStr + Display,\n{\n    fn decode(\n        value: PgValueRef<'r>,\n    ) -> Result<Self, Box<dyn std::error::Error + 'static + Send + Sync>> {\n        let str_value = <&'r str as Decode<'r, Postgres>>::decode(value)?;\n        Type::from_str(str_value).map(DBEnumWrapper).or(Err(format!(\n            \"invalid value {:?} for enum {}\",\n            str_value,\n            Type::name()\n        )\n        .into()))\n    }\n}\n\nimpl<Type> sqlx::Type<Postgres> for DBEnumWrapper<Type>",
    "function_name": "default",
    "file": "crates__analytics__src__sqlx.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for default",
    "code": "use std::{fmt::Display, str::FromStr};\n\nuse api_models::{\n    analytics::{frm::FrmTransactionType, refunds::RefundType},\n    enums::{DisputeStage, DisputeStatus},\n};\nuse common_enums::{\n    AuthenticationConnectors, AuthenticationStatus, DecoupledAuthenticationType, TransactionStatus,\n};\nuse common_utils::{\n    errors::{CustomResult, ParsingError},\n    DbConnectionParams,\n};\nuse diesel_models::enums::{\n    AttemptStatus, AuthenticationType, Currency, FraudCheckStatus, IntentStatus, PaymentMethod,\n    RefundStatus, RoutingApproach,\n};\nuse error_stack::ResultExt;\nuse sqlx::{\n    postgres::{PgArgumentBuffer, PgPoolOptions, PgRow, PgTypeInfo, PgValueRef},\n    Decode, Encode,\n    Error::ColumnNotFound,\n    FromRow, Pool, Postgres, Row,\n};\nuse storage_impl::config::Database;\nuse time::PrimitiveDateTime;\n\nuse super::{\n    health_check::HealthCheck,\n    query::{Aggregate, ToSql, Window},\n    types::{\n        AnalyticsCollection, AnalyticsDataSource, DBEnumWrapper, LoadRow, QueryExecutionError,\n        TableEngine,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct SqlxClient {\n    pool: Pool<Postgres>,\n}\n\nimpl Default for SqlxClient {\n    fn default() -> Self {\n        let database_url = format!(\n            \"postgres://{}:{}@{}:{}/{}\",\n            \"db_user\", \"db_pass\", \"localhost\", 5432, \"hyperswitch_db\"\n        );\n        Self {\n            #[allow(clippy::expect_used)]\n            pool: PgPoolOptions::new()\n                .connect_lazy(&database_url)\n                .expect(\"SQLX Pool Creation failed\"),\n        }\n    }\n}\n\nimpl SqlxClient {\n    pub async fn from_conf(conf: &Database, schema: &str) -> Self {\n        let database_url = conf.get_database_url(schema);\n        #[allow(clippy::expect_used)]\n        let pool = PgPoolOptions::new()\n            .max_connections(conf.pool_size)\n            .acquire_timeout(std::time::Duration::from_secs(conf.connection_timeout))\n            .connect_lazy(&database_url)\n            .expect(\"SQLX Pool Creation failed\");\n        Self { pool }\n    }\n}\n\npub trait DbType {\n    fn name() -> &'static str;\n}\n\nmacro_rules! db_type {\n    ($a: ident, $str: tt) => {\n        impl DbType for $a {\n            fn name() -> &'static str {\n                stringify!($str)\n            }\n        }\n    };\n    ($a:ident) => {\n        impl DbType for $a {\n            fn name() -> &'static str {\n                stringify!($a)\n            }\n        }\n    };\n}\n\ndb_type!(Currency);\ndb_type!(AuthenticationType);\ndb_type!(AttemptStatus);\ndb_type!(IntentStatus);\ndb_type!(PaymentMethod, TEXT);\ndb_type!(RefundStatus);\ndb_type!(RefundType);\ndb_type!(FraudCheckStatus);\ndb_type!(FrmTransactionType);\ndb_type!(DisputeStage);\ndb_type!(DisputeStatus);\ndb_type!(AuthenticationStatus);\ndb_type!(TransactionStatus);\ndb_type!(AuthenticationConnectors);\ndb_type!(DecoupledAuthenticationType);\ndb_type!(RoutingApproach);\n\nimpl<'q, Type> Encode<'q, Postgres> for DBEnumWrapper<Type>\nwhere\n    Type: DbType + FromStr + Display,\n{\n    fn encode_by_ref(\n        &self,\n        buf: &mut PgArgumentBuffer,\n    ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync + 'static>> {\n        <String as Encode<'q, Postgres>>::encode(self.0.to_string(), buf)\n    }\n    fn size_hint(&self) -> usize {\n        <String as Encode<'q, Postgres>>::size_hint(&self.0.to_string())\n    }\n}\n\nimpl<'r, Type> Decode<'r, Postgres> for DBEnumWrapper<Type>\nwhere\n    Type: DbType + FromStr + Display,\n{\n    fn decode(\n        value: PgValueRef<'r>,\n    ) -> Result<Self, Box<dyn std::error::Error + 'static + Send + Sync>> {\n        let str_value = <&'r str as Decode<'r, Postgres>>::decode(value)?;\n        Type::from_str(str_value).map(DBEnumWrapper).or(Err(format!(\n            \"invalid value {:?} for enum {}\",\n            str_value,\n            Type::name()\n        )\n        .into()))\n    }\n}\n\nimpl<Type> sqlx::Type<Postgres> for DBEnumWrapper<Type>",
    "function_name": "default",
    "file": "crates__analytics__src__sqlx.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__bamboraapac.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse transformers as bamboraapac;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Bamboraapac {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Bamboraapac {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bamboraapac {}\nimpl api::PaymentSession for Bamboraapac {}\nimpl api::ConnectorAccessToken for Bamboraapac {}\nimpl api::MandateSetup for Bamboraapac {}\nimpl api::PaymentAuthorize for Bamboraapac {}\nimpl api::PaymentSync for Bamboraapac {}\nimpl api::PaymentCapture for Bamboraapac {}\nimpl api::PaymentVoid for Bamboraapac {}\nimpl api::Refund for Bamboraapac {}\nimpl api::RefundExecute for Bamboraapac {}\nimpl api::RefundSync for Bamboraapac {}\nimpl api::PaymentToken for Bamboraapac {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Bamboraapac\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bamboraapac\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorValidation for Bamboraapac {\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \"mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n}\n\nimpl ConnectorCommon for Bamboraapac {\n    fn id(&self) -> &'static str {\n        \"bamboraapac\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"text/xml\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bamboraapac.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__bamboraapac.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse transformers as bamboraapac;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Bamboraapac {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Bamboraapac {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bamboraapac {}\nimpl api::PaymentSession for Bamboraapac {}\nimpl api::ConnectorAccessToken for Bamboraapac {}\nimpl api::MandateSetup for Bamboraapac {}\nimpl api::PaymentAuthorize for Bamboraapac {}\nimpl api::PaymentSync for Bamboraapac {}\nimpl api::PaymentCapture for Bamboraapac {}\nimpl api::PaymentVoid for Bamboraapac {}\nimpl api::Refund for Bamboraapac {}\nimpl api::RefundExecute for Bamboraapac {}\nimpl api::RefundSync for Bamboraapac {}\nimpl api::PaymentToken for Bamboraapac {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Bamboraapac\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bamboraapac\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorValidation for Bamboraapac {\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \"mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n}\n\nimpl ConnectorCommon for Bamboraapac {\n    fn id(&self) -> &'static str {\n        \"bamboraapac\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"text/xml\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bamboraapac.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::{BytesExt, XmlExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData, SetupMandateRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse transformers as bamboraapac;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount},\n};\n\n#[derive(Clone)]\npub struct Bamboraapac {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Bamboraapac {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bamboraapac {}\nimpl api::PaymentSession for Bamboraapac {}\nimpl api::ConnectorAccessToken for Bamboraapac {}\nimpl api::MandateSetup for Bamboraapac {}\nimpl api::PaymentAuthorize for Bamboraapac {}\nimpl api::PaymentSync for Bamboraapac {}\nimpl api::PaymentCapture for Bamboraapac {}\nimpl api::PaymentVoid for Bamboraapac {}\nimpl api::Refund for Bamboraapac {}\nimpl api::RefundExecute for Bamboraapac {}\nimpl api::RefundSync for Bamboraapac {}\nimpl api::PaymentToken for Bamboraapac {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Bamboraapac\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bamboraapac\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(header)\n    }\n}\n\nimpl ConnectorValidation for Bamboraapac {\n    fn validate_mandate_payment(\n        &self,\n        _pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,\n    ) -> CustomResult<(), errors::ConnectorError> {\n        let connector = self.id();\n        match pm_data {\n            PaymentMethodData::Card(_) => Ok(()),\n            _ => Err(errors::ConnectorError::NotSupported {\n                message: \"mandate payment\".to_string(),\n                connector,\n            }\n            .into()),\n        }\n    }\n}\n\nimpl ConnectorCommon for Bamboraapac {\n    fn id(&self) -> &'static str {\n        \"bamboraapac\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"text/xml\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bamboraapac.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__bamboraapac.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__bambora.rs",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        self, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsSyncType, PaymentsVoidType, Response,\n    },\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as bambora;\n\nuse crate::{\n    connectors::bambora::transformers::BamboraRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Bambora {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bambora {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bambora {}\nimpl api::PaymentToken for Bambora {}\nimpl api::PaymentAuthorize for Bambora {}\nimpl api::PaymentVoid for Bambora {}\nimpl api::MandateSetup for Bambora {}\nimpl api::ConnectorAccessToken for Bambora {}\nimpl api::PaymentSync for Bambora {}\nimpl api::PaymentCapture for Bambora {}\nimpl api::PaymentSession for Bambora {}\nimpl api::Refund for Bambora {}\nimpl api::RefundExecute for Bambora {}\nimpl api::RefundSync for Bambora {}\nimpl api::PaymentsCompleteAuthorize for Bambora {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bambora\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bambora {\n    fn id(&self) -> &'static str {\n        \"bambora\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bambora.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bambora::BamboraAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bambora.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__bambora.rs",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        self, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsSyncType, PaymentsVoidType, Response,\n    },\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as bambora;\n\nuse crate::{\n    connectors::bambora::transformers::BamboraRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Bambora {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bambora {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bambora {}\nimpl api::PaymentToken for Bambora {}\nimpl api::PaymentAuthorize for Bambora {}\nimpl api::PaymentVoid for Bambora {}\nimpl api::MandateSetup for Bambora {}\nimpl api::ConnectorAccessToken for Bambora {}\nimpl api::PaymentSync for Bambora {}\nimpl api::PaymentCapture for Bambora {}\nimpl api::PaymentSession for Bambora {}\nimpl api::Refund for Bambora {}\nimpl api::RefundExecute for Bambora {}\nimpl api::RefundSync for Bambora {}\nimpl api::PaymentsCompleteAuthorize for Bambora {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bambora\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bambora {\n    fn id(&self) -> &'static str {\n        \"bambora\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bambora.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bambora::BamboraAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bambora.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        CompleteAuthorize,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        self, PaymentsAuthorizeType, PaymentsCaptureType, PaymentsCompleteAuthorizeType,\n        PaymentsSyncType, PaymentsVoidType, Response,\n    },\n    webhooks,\n};\nuse lazy_static::lazy_static;\nuse masking::Mask;\nuse transformers as bambora;\n\nuse crate::{\n    connectors::bambora::transformers::BamboraRouterData,\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, convert_amount, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Bambora {\n    amount_convertor: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Bambora {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Bambora {}\nimpl api::PaymentToken for Bambora {}\nimpl api::PaymentAuthorize for Bambora {}\nimpl api::PaymentVoid for Bambora {}\nimpl api::MandateSetup for Bambora {}\nimpl api::ConnectorAccessToken for Bambora {}\nimpl api::PaymentSync for Bambora {}\nimpl api::PaymentCapture for Bambora {}\nimpl api::PaymentSession for Bambora {}\nimpl api::Refund for Bambora {}\nimpl api::RefundExecute for Bambora {}\nimpl api::RefundSync for Bambora {}\nimpl api::PaymentsCompleteAuthorize for Bambora {}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Bambora\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            PaymentsAuthorizeType::get_content_type(self)\n                .to_string()\n                .into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Bambora {\n    fn id(&self) -> &'static str {\n        \"bambora\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.bambora.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = bambora::BamboraAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__bambora.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__tsys__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{self, ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        self, PaymentsCancelRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\npub struct TsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for TsysRouterData<T> {\n    fn from((amount, router_data): (StringMinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RefundsRequestData as _},\n};\n\n#[derive(Debug, Serialize)]\npub enum TsysPaymentsRequest {\n    Auth(TsysPaymentAuthSaleRequest),\n    Sale(TsysPaymentAuthSaleRequest),\n}\n\n#[derive(Default, Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TsysPaymentAuthSaleRequest {\n    #[serde(rename = \"deviceID\")]\n    device_id: Secret<String>,\n    transaction_key: Secret<String>,\n    card_data_source: String,\n    transaction_amount: StringMinorUnit,\n    currency_code: enums::Currency,\n    card_number: cards::CardNumber,\n    expiration_date: Secret<String>,\n    cvv2: Secret<String>,\n    order_number: String,\n    terminal_capability: String,\n    terminal_operating_environment: String,\n    cardholder_authentication_method: String,\n    #[serde(rename = \"developerID\")]\n    developer_id: Secret<String>,\n}\n\nimpl TryFrom<&TsysRouterData<&types::PaymentsAuthorizeRouterData>> for TsysPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item_data: &TsysRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let item = item_data.router_data.clone();\n        match item.request.payment_method_data.clone() {\n            PaymentMethodData::Card(ccard) => {\n                let connector_auth: TsysAuthType =\n                    TsysAuthType::try_from(&item.connector_auth_type)?;\n                let auth_data: TsysPaymentAuthSaleRequest = TsysPaymentAuthSaleRequest {\n                    device_id: connector_auth.device_id,\n                    transaction_key: connector_auth.transaction_key,\n                    card_data_source: \"INTERNET\".to_string(),\n                    transaction_amount: item_data.amount.clone(),\n                    currency_code: item.request.currency,\n                    card_number: ccard.card_number.clone(),\n                    expiration_date: ccard\n                        .get_card_expiry_month_year_2_digit_with_delimiter(\"/\".to_owned())?,\n                    cvv2: ccard.card_cvc,\n                    order_number: item.connector_request_reference_id.clone(),\n                    terminal_capability: \"ICC_CHIP_READ_ONLY\".to_string(),\n                    terminal_operating_environment: \"ON_MERCHANT_PREMISES_ATTENDED\".to_string(),\n                    cardholder_authentication_method: \"NOT_AUTHENTICATED\".to_string(),\n                    developer_id: connector_auth.developer_id,\n                };\n                if item.request.is_auto_capture()? {\n                    Ok(Self::Sale(auth_data))\n                } else {\n                    Ok(Self::Auth(auth_data))\n                }\n            }\n            PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::Wallet(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)\n            | PaymentMethodData::Crypto(_)\n            | PaymentMethodData::MandatePayment\n            | PaymentMethodData::Reward\n            | PaymentMethodData::RealTimePayment(_)\n            | PaymentMethodData::MobilePayment(_)\n            | PaymentMethodData::Upi(_)\n            | PaymentMethodData::Voucher(_)\n            | PaymentMethodData::GiftCard(_)\n            | PaymentMethodData::OpenBanking(_)\n            | PaymentMethodData::CardToken(_)\n            | PaymentMethodData::NetworkToken(_)\n            | PaymentMethodData::CardDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::CardWithLimitedDetails(_)\n            | PaymentMethodData::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::NetworkTokenDetailsForNetworkTransactionId(_) => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"tsys\"),\n                ))?\n            }\n        }\n    }\n}\n\n// Auth Struct\npub struct TsysAuthType {\n    pub(super) device_id: Secret<String>,\n    pub(super) transaction_key: Secret<String>,\n    pub(super) developer_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for TsysAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                device_id: api_key.to_owned(),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__tsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__tsys__transformers.rs",
    "code": "use common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{self, ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        self, PaymentsCancelRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\npub struct TsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for TsysRouterData<T> {\n    fn from((amount, router_data): (StringMinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RefundsRequestData as _},\n};\n\n#[derive(Debug, Serialize)]\npub enum TsysPaymentsRequest {\n    Auth(TsysPaymentAuthSaleRequest),\n    Sale(TsysPaymentAuthSaleRequest),\n}\n\n#[derive(Default, Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TsysPaymentAuthSaleRequest {\n    #[serde(rename = \"deviceID\")]\n    device_id: Secret<String>,\n    transaction_key: Secret<String>,\n    card_data_source: String,\n    transaction_amount: StringMinorUnit,\n    currency_code: enums::Currency,\n    card_number: cards::CardNumber,\n    expiration_date: Secret<String>,\n    cvv2: Secret<String>,\n    order_number: String,\n    terminal_capability: String,\n    terminal_operating_environment: String,\n    cardholder_authentication_method: String,\n    #[serde(rename = \"developerID\")]\n    developer_id: Secret<String>,\n}\n\nimpl TryFrom<&TsysRouterData<&types::PaymentsAuthorizeRouterData>> for TsysPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item_data: &TsysRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let item = item_data.router_data.clone();\n        match item.request.payment_method_data.clone() {\n            PaymentMethodData::Card(ccard) => {\n                let connector_auth: TsysAuthType =\n                    TsysAuthType::try_from(&item.connector_auth_type)?;\n                let auth_data: TsysPaymentAuthSaleRequest = TsysPaymentAuthSaleRequest {\n                    device_id: connector_auth.device_id,\n                    transaction_key: connector_auth.transaction_key,\n                    card_data_source: \"INTERNET\".to_string(),\n                    transaction_amount: item_data.amount.clone(),\n                    currency_code: item.request.currency,\n                    card_number: ccard.card_number.clone(),\n                    expiration_date: ccard\n                        .get_card_expiry_month_year_2_digit_with_delimiter(\"/\".to_owned())?,\n                    cvv2: ccard.card_cvc,\n                    order_number: item.connector_request_reference_id.clone(),\n                    terminal_capability: \"ICC_CHIP_READ_ONLY\".to_string(),\n                    terminal_operating_environment: \"ON_MERCHANT_PREMISES_ATTENDED\".to_string(),\n                    cardholder_authentication_method: \"NOT_AUTHENTICATED\".to_string(),\n                    developer_id: connector_auth.developer_id,\n                };\n                if item.request.is_auto_capture()? {\n                    Ok(Self::Sale(auth_data))\n                } else {\n                    Ok(Self::Auth(auth_data))\n                }\n            }\n            PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::Wallet(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)\n            | PaymentMethodData::Crypto(_)\n            | PaymentMethodData::MandatePayment\n            | PaymentMethodData::Reward\n            | PaymentMethodData::RealTimePayment(_)\n            | PaymentMethodData::MobilePayment(_)\n            | PaymentMethodData::Upi(_)\n            | PaymentMethodData::Voucher(_)\n            | PaymentMethodData::GiftCard(_)\n            | PaymentMethodData::OpenBanking(_)\n            | PaymentMethodData::CardToken(_)\n            | PaymentMethodData::NetworkToken(_)\n            | PaymentMethodData::CardDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::CardWithLimitedDetails(_)\n            | PaymentMethodData::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::NetworkTokenDetailsForNetworkTransactionId(_) => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"tsys\"),\n                ))?\n            }\n        }\n    }\n}\n\n// Auth Struct\npub struct TsysAuthType {\n    pub(super) device_id: Secret<String>,\n    pub(super) transaction_key: Secret<String>,\n    pub(super) developer_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for TsysAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                device_id: api_key.to_owned(),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__tsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use common_enums::enums;\nuse common_utils::types::StringMinorUnit;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{self, ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsResponseData},\n    types::{\n        self, PaymentsCancelRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\npub struct TsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T)> for TsysRouterData<T> {\n    fn from((amount, router_data): (StringMinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, CardData as _, PaymentsAuthorizeRequestData, RefundsRequestData as _},\n};\n\n#[derive(Debug, Serialize)]\npub enum TsysPaymentsRequest {\n    Auth(TsysPaymentAuthSaleRequest),\n    Sale(TsysPaymentAuthSaleRequest),\n}\n\n#[derive(Default, Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct TsysPaymentAuthSaleRequest {\n    #[serde(rename = \"deviceID\")]\n    device_id: Secret<String>,\n    transaction_key: Secret<String>,\n    card_data_source: String,\n    transaction_amount: StringMinorUnit,\n    currency_code: enums::Currency,\n    card_number: cards::CardNumber,\n    expiration_date: Secret<String>,\n    cvv2: Secret<String>,\n    order_number: String,\n    terminal_capability: String,\n    terminal_operating_environment: String,\n    cardholder_authentication_method: String,\n    #[serde(rename = \"developerID\")]\n    developer_id: Secret<String>,\n}\n\nimpl TryFrom<&TsysRouterData<&types::PaymentsAuthorizeRouterData>> for TsysPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item_data: &TsysRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        let item = item_data.router_data.clone();\n        match item.request.payment_method_data.clone() {\n            PaymentMethodData::Card(ccard) => {\n                let connector_auth: TsysAuthType =\n                    TsysAuthType::try_from(&item.connector_auth_type)?;\n                let auth_data: TsysPaymentAuthSaleRequest = TsysPaymentAuthSaleRequest {\n                    device_id: connector_auth.device_id,\n                    transaction_key: connector_auth.transaction_key,\n                    card_data_source: \"INTERNET\".to_string(),\n                    transaction_amount: item_data.amount.clone(),\n                    currency_code: item.request.currency,\n                    card_number: ccard.card_number.clone(),\n                    expiration_date: ccard\n                        .get_card_expiry_month_year_2_digit_with_delimiter(\"/\".to_owned())?,\n                    cvv2: ccard.card_cvc,\n                    order_number: item.connector_request_reference_id.clone(),\n                    terminal_capability: \"ICC_CHIP_READ_ONLY\".to_string(),\n                    terminal_operating_environment: \"ON_MERCHANT_PREMISES_ATTENDED\".to_string(),\n                    cardholder_authentication_method: \"NOT_AUTHENTICATED\".to_string(),\n                    developer_id: connector_auth.developer_id,\n                };\n                if item.request.is_auto_capture()? {\n                    Ok(Self::Sale(auth_data))\n                } else {\n                    Ok(Self::Auth(auth_data))\n                }\n            }\n            PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::Wallet(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)\n            | PaymentMethodData::Crypto(_)\n            | PaymentMethodData::MandatePayment\n            | PaymentMethodData::Reward\n            | PaymentMethodData::RealTimePayment(_)\n            | PaymentMethodData::MobilePayment(_)\n            | PaymentMethodData::Upi(_)\n            | PaymentMethodData::Voucher(_)\n            | PaymentMethodData::GiftCard(_)\n            | PaymentMethodData::OpenBanking(_)\n            | PaymentMethodData::CardToken(_)\n            | PaymentMethodData::NetworkToken(_)\n            | PaymentMethodData::CardDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::CardWithLimitedDetails(_)\n            | PaymentMethodData::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::NetworkTokenDetailsForNetworkTransactionId(_) => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"tsys\"),\n                ))?\n            }\n        }\n    }\n}\n\n// Auth Struct\npub struct TsysAuthType {\n    pub(super) device_id: Secret<String>,\n    pub(super) transaction_key: Secret<String>,\n    pub(super) developer_id: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for TsysAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                device_id: api_key.to_owned(),",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__tsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__routes__payment_methods.rs",
    "code": "#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse std::collections::HashMap;\n\nuse ::payment_methods::{\n    controller::PaymentMethodsController,\n    core::{migration, migration::payment_methods::migrate_payment_method},\n};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse actix_multipart::form::MultipartForm;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse common_utils::{errors::CustomResult, id_type, transformers::ForeignFrom};\nuse diesel_models::enums::IntentStatus;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    bulk_tokenization::CardNetworkTokenizeRequest, merchant_key_store::MerchantKeyStore,\n    payment_methods::PaymentMethodCustomerMigrate, transformers::ForeignTryFrom,\n};\nuse router_env::{instrument, logger, tracing, Flow};\n\nuse super::app::{AppState, SessionState};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse crate::core::{\n    customers,\n    payment_methods::{batch_retrieve, tokenize},\n};\nuse crate::{\n    core::{\n        api_locking,\n        errors::{self, utils::StorageErrorExt},\n        payment_methods::{self as payment_methods_routes, cards, migration as update_migration},\n    },\n    services::{self, api, authentication as auth, authorization::permissions::Permission},\n    types::{\n        api::payment_methods::{self, PaymentMethodId},\n        domain,\n        storage::payment_method::PaymentTokenData,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _| async move {\n            Box::pin(cards::get_client_secret_or_add_payment_method(\n                &state,\n                req,\n                auth.platform.get_provider(),\n            ))\n            .await\n        },\n        &auth::HeaderAuth(auth::ApiKeyAuth {\n            allow_connected_scope_operation: true,\n            allow_platform_self_operation: true,\n        }),\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    let api_auth = auth::V2ApiKeyAuth {\n        allow_connected_scope_operation: false,\n        allow_platform_self_operation: false,\n    };\n    let jwt_auth = auth::JWTAuth {\n        permission: Permission::MerchantCustomerRead,\n    };\n    let (auth_type, _api_key_type) =\n        match auth::check_internal_api_key_or_dashboard_auth_no_client_secret(\n            req.headers(),\n            api_auth,\n            jwt_auth,\n            state.conf.internal_merchant_id_profile_id_auth.clone(),\n        ) {\n            Ok(auth) => auth,\n            Err(err) => return api::log_and_return_error_response(error_stack::report!(err)),\n        };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, req_state| async move {\n            Box::pin(payment_methods_routes::create_payment_method(\n                &state,\n                &req_state,\n                req,\n                &auth.platform,\n                &auth.profile,\n            ))\n            .await\n        },\n        &*auth_type,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\n#[instrument(skip_all, fields(flow = ?Flow::NetworkTokenEligibilityCheck))]\npub async fn get_pm_nt_eligibility_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    query: web::Query<payment_methods::NetworkTokenEligibilityRequest>,\n) -> HttpResponse {\n    let flow = Flow::NetworkTokenEligibilityCheck;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        query.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _req_state| async move {\n            Box::pin(payment_methods_routes::get_card_nt_eligibility(\n                &state,\n                req,\n                &auth.platform,\n                &auth.profile,\n            ))\n            .await",
    "function_name": "create_payment_method_api",
    "file": "crates__router__src__routes__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__router__src__routes__payment_methods.rs",
    "code": "#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse std::collections::HashMap;\n\nuse ::payment_methods::{\n    controller::PaymentMethodsController,\n    core::{migration, migration::payment_methods::migrate_payment_method},\n};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse actix_multipart::form::MultipartForm;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse common_utils::{errors::CustomResult, id_type, transformers::ForeignFrom};\nuse diesel_models::enums::IntentStatus;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    bulk_tokenization::CardNetworkTokenizeRequest, merchant_key_store::MerchantKeyStore,\n    payment_methods::PaymentMethodCustomerMigrate, transformers::ForeignTryFrom,\n};\nuse router_env::{instrument, logger, tracing, Flow};\n\nuse super::app::{AppState, SessionState};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse crate::core::{\n    customers,\n    payment_methods::{batch_retrieve, tokenize},\n};\nuse crate::{\n    core::{\n        api_locking,\n        errors::{self, utils::StorageErrorExt},\n        payment_methods::{self as payment_methods_routes, cards, migration as update_migration},\n    },\n    services::{self, api, authentication as auth, authorization::permissions::Permission},\n    types::{\n        api::payment_methods::{self, PaymentMethodId},\n        domain,\n        storage::payment_method::PaymentTokenData,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _| async move {\n            Box::pin(cards::get_client_secret_or_add_payment_method(\n                &state,\n                req,\n                auth.platform.get_provider(),\n            ))\n            .await\n        },\n        &auth::HeaderAuth(auth::ApiKeyAuth {\n            allow_connected_scope_operation: true,\n            allow_platform_self_operation: true,\n        }),\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    let api_auth = auth::V2ApiKeyAuth {\n        allow_connected_scope_operation: false,\n        allow_platform_self_operation: false,\n    };\n    let jwt_auth = auth::JWTAuth {\n        permission: Permission::MerchantCustomerRead,\n    };\n    let (auth_type, _api_key_type) =\n        match auth::check_internal_api_key_or_dashboard_auth_no_client_secret(\n            req.headers(),\n            api_auth,\n            jwt_auth,\n            state.conf.internal_merchant_id_profile_id_auth.clone(),\n        ) {\n            Ok(auth) => auth,\n            Err(err) => return api::log_and_return_error_response(error_stack::report!(err)),\n        };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, req_state| async move {\n            Box::pin(payment_methods_routes::create_payment_method(\n                &state,\n                &req_state,\n                req,\n                &auth.platform,\n                &auth.profile,\n            ))\n            .await\n        },\n        &*auth_type,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\n#[instrument(skip_all, fields(flow = ?Flow::NetworkTokenEligibilityCheck))]\npub async fn get_pm_nt_eligibility_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    query: web::Query<payment_methods::NetworkTokenEligibilityRequest>,\n) -> HttpResponse {\n    let flow = Flow::NetworkTokenEligibilityCheck;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        query.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _req_state| async move {\n            Box::pin(payment_methods_routes::get_card_nt_eligibility(\n                &state,\n                req,\n                &auth.platform,\n                &auth.profile,\n            ))\n            .await",
    "function_name": "create_payment_method_api",
    "file": "crates__router__src__routes__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for create_payment_method_api",
    "code": "#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse std::collections::HashMap;\n\nuse ::payment_methods::{\n    controller::PaymentMethodsController,\n    core::{migration, migration::payment_methods::migrate_payment_method},\n};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse actix_multipart::form::MultipartForm;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse common_utils::{errors::CustomResult, id_type, transformers::ForeignFrom};\nuse diesel_models::enums::IntentStatus;\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    bulk_tokenization::CardNetworkTokenizeRequest, merchant_key_store::MerchantKeyStore,\n    payment_methods::PaymentMethodCustomerMigrate, transformers::ForeignTryFrom,\n};\nuse router_env::{instrument, logger, tracing, Flow};\n\nuse super::app::{AppState, SessionState};\n#[cfg(all(feature = \"v1\", any(feature = \"olap\", feature = \"oltp\")))]\nuse crate::core::{\n    customers,\n    payment_methods::{batch_retrieve, tokenize},\n};\nuse crate::{\n    core::{\n        api_locking,\n        errors::{self, utils::StorageErrorExt},\n        payment_methods::{self as payment_methods_routes, cards, migration as update_migration},\n    },\n    services::{self, api, authentication as auth, authorization::permissions::Permission},\n    types::{\n        api::payment_methods::{self, PaymentMethodId},\n        domain,\n        storage::payment_method::PaymentTokenData,\n    },\n};\n\n#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _| async move {\n            Box::pin(cards::get_client_secret_or_add_payment_method(\n                &state,\n                req,\n                auth.platform.get_provider(),\n            ))\n            .await\n        },\n        &auth::HeaderAuth(auth::ApiKeyAuth {\n            allow_connected_scope_operation: true,\n            allow_platform_self_operation: true,\n        }),\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\n#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]\npub async fn create_payment_method_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    json_payload: web::Json<payment_methods::PaymentMethodCreate>,\n) -> HttpResponse {\n    let flow = Flow::PaymentMethodsCreate;\n\n    let api_auth = auth::V2ApiKeyAuth {\n        allow_connected_scope_operation: false,\n        allow_platform_self_operation: false,\n    };\n    let jwt_auth = auth::JWTAuth {\n        permission: Permission::MerchantCustomerRead,\n    };\n    let (auth_type, _api_key_type) =\n        match auth::check_internal_api_key_or_dashboard_auth_no_client_secret(\n            req.headers(),\n            api_auth,\n            jwt_auth,\n            state.conf.internal_merchant_id_profile_id_auth.clone(),\n        ) {\n            Ok(auth) => auth,\n            Err(err) => return api::log_and_return_error_response(error_stack::report!(err)),\n        };\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        json_payload.into_inner(),\n        |state, auth: auth::AuthenticationData, req, req_state| async move {\n            Box::pin(payment_methods_routes::create_payment_method(\n                &state,\n                &req_state,\n                req,\n                &auth.platform,\n                &auth.profile,\n            ))\n            .await\n        },\n        &*auth_type,\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}\n\n#[cfg(feature = \"v2\")]\n#[instrument(skip_all, fields(flow = ?Flow::NetworkTokenEligibilityCheck))]\npub async fn get_pm_nt_eligibility_api(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    query: web::Query<payment_methods::NetworkTokenEligibilityRequest>,\n) -> HttpResponse {\n    let flow = Flow::NetworkTokenEligibilityCheck;\n\n    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        query.into_inner(),\n        |state, auth: auth::AuthenticationData, req, _req_state| async move {\n            Box::pin(payment_methods_routes::get_card_nt_eligibility(\n                &state,\n                req,\n                &auth.platform,\n                &auth.profile,\n            ))\n            .await",
    "function_name": "create_payment_method_api",
    "file": "crates__router__src__routes__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__coingate.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers::{self as coingate, CoingateWebhookBody};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Coingate {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coingate {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Coingate {}\nimpl api::PaymentSession for Coingate {}\nimpl api::ConnectorAccessToken for Coingate {}\nimpl api::MandateSetup for Coingate {}\nimpl api::PaymentAuthorize for Coingate {}\nimpl api::PaymentSync for Coingate {}\nimpl api::PaymentCapture for Coingate {}\nimpl api::PaymentVoid for Coingate {}\nimpl api::Refund for Coingate {}\nimpl api::RefundExecute for Coingate {}\nimpl api::RefundSync for Coingate {}\nimpl api::PaymentToken for Coingate {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Coingate\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Coingate\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Coingate {\n    fn id(&self) -> &'static str {\n        \"coingate\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.coingate.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = coingate::CoingateAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: coingate::CoingateErrorResponse = res\n            .response\n            .parse_struct(\"CoingateErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__coingate.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__coingate.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers::{self as coingate, CoingateWebhookBody};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Coingate {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coingate {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Coingate {}\nimpl api::PaymentSession for Coingate {}\nimpl api::ConnectorAccessToken for Coingate {}\nimpl api::MandateSetup for Coingate {}\nimpl api::PaymentAuthorize for Coingate {}\nimpl api::PaymentSync for Coingate {}\nimpl api::PaymentCapture for Coingate {}\nimpl api::PaymentVoid for Coingate {}\nimpl api::Refund for Coingate {}\nimpl api::RefundExecute for Coingate {}\nimpl api::RefundSync for Coingate {}\nimpl api::PaymentToken for Coingate {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Coingate\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Coingate\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Coingate {\n    fn id(&self) -> &'static str {\n        \"coingate\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.coingate.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = coingate::CoingateAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: coingate::CoingateErrorResponse = res\n            .response\n            .parse_struct(\"CoingateErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__coingate.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse common_enums::{enums, CaptureMethod, PaymentMethod, PaymentMethodType};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse transformers::{self as coingate, CoingateWebhookBody};\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{self, RefundsRequestData},\n};\n\n#[derive(Clone)]\npub struct Coingate {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n}\n\nimpl Coingate {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Coingate {}\nimpl api::PaymentSession for Coingate {}\nimpl api::ConnectorAccessToken for Coingate {}\nimpl api::MandateSetup for Coingate {}\nimpl api::PaymentAuthorize for Coingate {}\nimpl api::PaymentSync for Coingate {}\nimpl api::PaymentCapture for Coingate {}\nimpl api::PaymentVoid for Coingate {}\nimpl api::Refund for Coingate {}\nimpl api::RefundExecute for Coingate {}\nimpl api::RefundSync for Coingate {}\nimpl api::PaymentToken for Coingate {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Coingate\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Coingate\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Coingate {\n    fn id(&self) -> &'static str {\n        \"coingate\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.coingate.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = coingate::CoingateAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: coingate::CoingateErrorResponse = res\n            .response\n            .parse_struct(\"CoingateErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__coingate.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__storage_impl__src__merchant_connector_account.rs",
    "code": "use async_bb8_diesel::AsyncConnection;\nuse common_utils::{encryption::Encryption, ext_traits::AsyncExt};\nuse diesel_models::merchant_connector_account as storage;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_connector_account::{self as domain, MerchantConnectorAccountInterface},\n    merchant_key_store::MerchantKeyStore,\n};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"accounts_cache\")]\nuse crate::redis::cache;\nuse crate::{\n    kv_router_store,\n    utils::{pg_accounts_connection_read, pg_accounts_connection_write},\n    CustomResult, DatabaseStore, MockDb, RouterStore, StorageError,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> MerchantConnectorAccountInterface for kv_router_store::KVRouterStore<T> {\n    type Error = StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n",
    "function_name": "find_merchant_connector_account_by_merchant_id_connector_label",
    "file": "crates__storage_impl__src__merchant_connector_account.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__storage_impl__src__merchant_connector_account.rs",
    "code": "use async_bb8_diesel::AsyncConnection;\nuse common_utils::{encryption::Encryption, ext_traits::AsyncExt};\nuse diesel_models::merchant_connector_account as storage;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_connector_account::{self as domain, MerchantConnectorAccountInterface},\n    merchant_key_store::MerchantKeyStore,\n};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"accounts_cache\")]\nuse crate::redis::cache;\nuse crate::{\n    kv_router_store,\n    utils::{pg_accounts_connection_read, pg_accounts_connection_write},\n    CustomResult, DatabaseStore, MockDb, RouterStore, StorageError,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> MerchantConnectorAccountInterface for kv_router_store::KVRouterStore<T> {\n    type Error = StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n",
    "function_name": "find_merchant_connector_account_by_merchant_id_connector_label",
    "file": "crates__storage_impl__src__merchant_connector_account.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for find_merchant_connector_account_by_merchant_id_connector_label",
    "code": "use async_bb8_diesel::AsyncConnection;\nuse common_utils::{encryption::Encryption, ext_traits::AsyncExt};\nuse diesel_models::merchant_connector_account as storage;\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    behaviour::{Conversion, ReverseConversion},\n    merchant_connector_account::{self as domain, MerchantConnectorAccountInterface},\n    merchant_key_store::MerchantKeyStore,\n};\nuse router_env::{instrument, tracing};\n\n#[cfg(feature = \"accounts_cache\")]\nuse crate::redis::cache;\nuse crate::{\n    kv_router_store,\n    utils::{pg_accounts_connection_read, pg_accounts_connection_write},\n    CustomResult, DatabaseStore, MockDb, RouterStore, StorageError,\n};\n\n#[async_trait::async_trait]\nimpl<T: DatabaseStore> MerchantConnectorAccountInterface for kv_router_store::KVRouterStore<T> {\n    type Error = StorageError;\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_label(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_label: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_label(\n                merchant_id,\n                connector_label,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_profile_id_connector_name(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_profile_id_connector_name(\n                profile_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_connector_name(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        connector_name: &str,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_connector_name(\n                merchant_id,\n                connector_name,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v1\")]\n    async fn find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        merchant_connector_id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n                merchant_id,\n                merchant_connector_id,\n                key_store,\n            )\n            .await\n    }\n\n    #[instrument(skip_all)]\n    #[cfg(feature = \"v2\")]\n    async fn find_merchant_connector_account_by_id(\n        &self,\n        id: &common_utils::id_type::MerchantConnectorAccountId,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_id(id, key_store)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    async fn insert_merchant_connector_account(\n        &self,\n        t: domain::MerchantConnectorAccount,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccount, Self::Error> {\n        self.router_store\n            .insert_merchant_connector_account(t, key_store)\n            .await\n    }\n\n    async fn list_enabled_connector_accounts_by_profile_id(\n        &self,\n        profile_id: &common_utils::id_type::ProfileId,\n        key_store: &MerchantKeyStore,\n        connector_type: common_enums::ConnectorType,\n    ) -> CustomResult<Vec<domain::MerchantConnectorAccount>, Self::Error> {\n        self.router_store\n            .list_enabled_connector_accounts_by_profile_id(profile_id, key_store, connector_type)\n            .await\n    }\n\n    #[instrument(skip_all)]\n    async fn find_merchant_connector_account_by_merchant_id_and_disabled_list(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        get_disabled: bool,\n        key_store: &MerchantKeyStore,\n    ) -> CustomResult<domain::MerchantConnectorAccounts, Self::Error> {\n        self.router_store\n            .find_merchant_connector_account_by_merchant_id_and_disabled_list(\n                merchant_id,\n                get_disabled,\n                key_store,\n            )\n            .await\n    }\n",
    "function_name": "find_merchant_connector_account_by_merchant_id_connector_label",
    "file": "crates__storage_impl__src__merchant_connector_account.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_domain_models__src__merchant_connector_account.rs",
    "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\nuse common_utils::{\n    crypto::Encryptable,\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{StringExt, ValueExt},\n    id_type, pii, type_name,\n    types::keymanager::{Identifier, KeyManagerState, ToEncryptable},\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::merchant_connector_account::{\n    BillingAccountReference as DieselBillingAccountReference,\n    MerchantConnectorAccountFeatureMetadata as DieselMerchantConnectorAccountFeatureMetadata,\n    RevenueRecoveryMetadata as DieselRevenueRecoveryMetadata,\n};\nuse diesel_models::{\n    enums,\n    merchant_connector_account::{self as storage, MerchantConnectorAccountUpdateInternal},\n};\nuse error_stack::ResultExt;\nuse masking::{PeekInterface, Secret};\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\n\nuse super::behaviour;\n#[cfg(feature = \"v2\")]\nuse crate::errors::api_error_response;\nuse crate::{\n    mandates::CommonMandateReference,\n    merchant_key_store::MerchantKeyStore,\n    router_data,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]\nimpl MerchantConnectorAccount {\n    pub fn get_id(&self) -> id_type::MerchantConnectorAccountId {\n        self.merchant_connector_id.clone()\n    }\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n\n    pub fn get_connector_wallets_details(&self) -> Option<Secret<Value>> {\n        self.connector_wallets_details.as_deref().cloned()\n    }\n\n    pub fn get_connector_test_mode(&self) -> Option<bool> {\n        self.test_mode\n    }\n\n    pub fn get_connector_name_as_string(&self) -> String {\n        self.connector_name.clone()\n    }\n\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        self.metadata.clone()\n    }\n\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n\n    pub fn should_construct_webhook_setup_capability(&self) -> bool {\n        matches!(self.connector_type, enums::ConnectorType::PaymentProcessor)\n    }\n\n    pub fn get_connector_webhook_registration_details(&self) -> Option<Value> {\n        self.connector_webhook_registration_details.clone()\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug)]\npub enum MerchantConnectorAccountTypeDetails {\n    MerchantConnectorAccount(Box<MerchantConnectorAccount>),\n    MerchantConnectorDetails(common_types::domain::MerchantConnectorAuthDetails),\n}\n\n#[cfg(feature = \"v2\")]\nimpl MerchantConnectorAccountTypeDetails {\n    pub fn get_connector_account_details(",
    "function_name": "get_id",
    "file": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_domain_models__src__merchant_connector_account.rs",
    "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\nuse common_utils::{\n    crypto::Encryptable,\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{StringExt, ValueExt},\n    id_type, pii, type_name,\n    types::keymanager::{Identifier, KeyManagerState, ToEncryptable},\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::merchant_connector_account::{\n    BillingAccountReference as DieselBillingAccountReference,\n    MerchantConnectorAccountFeatureMetadata as DieselMerchantConnectorAccountFeatureMetadata,\n    RevenueRecoveryMetadata as DieselRevenueRecoveryMetadata,\n};\nuse diesel_models::{\n    enums,\n    merchant_connector_account::{self as storage, MerchantConnectorAccountUpdateInternal},\n};\nuse error_stack::ResultExt;\nuse masking::{PeekInterface, Secret};\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\n\nuse super::behaviour;\n#[cfg(feature = \"v2\")]\nuse crate::errors::api_error_response;\nuse crate::{\n    mandates::CommonMandateReference,\n    merchant_key_store::MerchantKeyStore,\n    router_data,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]\nimpl MerchantConnectorAccount {\n    pub fn get_id(&self) -> id_type::MerchantConnectorAccountId {\n        self.merchant_connector_id.clone()\n    }\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n\n    pub fn get_connector_wallets_details(&self) -> Option<Secret<Value>> {\n        self.connector_wallets_details.as_deref().cloned()\n    }\n\n    pub fn get_connector_test_mode(&self) -> Option<bool> {\n        self.test_mode\n    }\n\n    pub fn get_connector_name_as_string(&self) -> String {\n        self.connector_name.clone()\n    }\n\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        self.metadata.clone()\n    }\n\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n\n    pub fn should_construct_webhook_setup_capability(&self) -> bool {\n        matches!(self.connector_type, enums::ConnectorType::PaymentProcessor)\n    }\n\n    pub fn get_connector_webhook_registration_details(&self) -> Option<Value> {\n        self.connector_webhook_registration_details.clone()\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug)]\npub enum MerchantConnectorAccountTypeDetails {\n    MerchantConnectorAccount(Box<MerchantConnectorAccount>),\n    MerchantConnectorDetails(common_types::domain::MerchantConnectorAuthDetails),\n}\n\n#[cfg(feature = \"v2\")]\nimpl MerchantConnectorAccountTypeDetails {\n    pub fn get_connector_account_details(",
    "function_name": "get_id",
    "file": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for get_id",
    "code": "#[cfg(feature = \"v2\")]\nuse std::collections::HashMap;\n\nuse common_utils::{\n    crypto::Encryptable,\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    ext_traits::{StringExt, ValueExt},\n    id_type, pii, type_name,\n    types::keymanager::{Identifier, KeyManagerState, ToEncryptable},\n};\n#[cfg(feature = \"v2\")]\nuse diesel_models::merchant_connector_account::{\n    BillingAccountReference as DieselBillingAccountReference,\n    MerchantConnectorAccountFeatureMetadata as DieselMerchantConnectorAccountFeatureMetadata,\n    RevenueRecoveryMetadata as DieselRevenueRecoveryMetadata,\n};\nuse diesel_models::{\n    enums,\n    merchant_connector_account::{self as storage, MerchantConnectorAccountUpdateInternal},\n};\nuse error_stack::ResultExt;\nuse masking::{PeekInterface, Secret};\nuse rustc_hash::FxHashMap;\nuse serde_json::Value;\n\nuse super::behaviour;\n#[cfg(feature = \"v2\")]\nuse crate::errors::api_error_response;\nuse crate::{\n    mandates::CommonMandateReference,\n    merchant_key_store::MerchantKeyStore,\n    router_data,\n    type_encryption::{crypto_operation, CryptoOperation},\n};\n\n#[cfg(feature = \"v1\")]\n#[derive(Clone, Debug, router_derive::ToEncryption)]\npub struct MerchantConnectorAccount {\n    pub merchant_id: id_type::MerchantId,\n    pub connector_name: String,\n    #[encrypt]\n    pub connector_account_details: Encryptable<Secret<Value>>,\n    pub test_mode: Option<bool>,\n    pub disabled: Option<bool>,\n    pub merchant_connector_id: id_type::MerchantConnectorAccountId,\n    pub payment_methods_enabled: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_type: enums::ConnectorType,\n    pub metadata: Option<pii::SecretSerdeValue>,\n    pub frm_configs: Option<Vec<pii::SecretSerdeValue>>,\n    pub connector_label: Option<String>,\n    pub business_country: Option<enums::CountryAlpha2>,\n    pub business_label: Option<String>,\n    pub business_sub_label: Option<String>,\n    pub created_at: time::PrimitiveDateTime,\n    pub modified_at: time::PrimitiveDateTime,\n    pub connector_webhook_details: Option<pii::SecretSerdeValue>,\n    pub profile_id: id_type::ProfileId,\n    pub applepay_verified_domains: Option<Vec<String>>,\n    pub pm_auth_config: Option<pii::SecretSerdeValue>,\n    pub status: enums::ConnectorStatus,\n    #[encrypt]\n    pub connector_wallets_details: Option<Encryptable<Secret<Value>>>,\n    #[encrypt]\n    pub additional_merchant_data: Option<Encryptable<Secret<Value>>>,\n    pub version: common_enums::ApiVersion,\n    pub connector_webhook_registration_details: Option<Value>,\n}\n\n#[cfg(feature = \"v1\")]\nimpl MerchantConnectorAccount {\n    pub fn get_id(&self) -> id_type::MerchantConnectorAccountId {\n        self.merchant_connector_id.clone()\n    }\n    pub fn get_connector_account_details(\n        &self,\n    ) -> error_stack::Result<router_data::ConnectorAuthType, common_utils::errors::ParsingError>\n    {\n        self.connector_account_details\n            .get_inner()\n            .clone()\n            .parse_value(\"ConnectorAuthType\")\n    }\n\n    pub fn get_connector_wallets_details(&self) -> Option<Secret<Value>> {\n        self.connector_wallets_details.as_deref().cloned()\n    }\n\n    pub fn get_connector_test_mode(&self) -> Option<bool> {\n        self.test_mode\n    }\n\n    pub fn get_connector_name_as_string(&self) -> String {\n        self.connector_name.clone()\n    }\n\n    pub fn get_metadata(&self) -> Option<Secret<Value>> {\n        self.metadata.clone()\n    }\n\n    pub fn get_ctp_service_provider(\n        &self,\n    ) -> error_stack::Result<\n        Option<common_enums::CtpServiceProvider>,\n        common_utils::errors::ParsingError,\n    > {\n        let provider = self\n            .connector_name\n            .clone()\n            .parse_enum(\"CtpServiceProvider\")\n            .attach_printable_lazy(|| {\n                format!(\n                    \"Failed to parse ctp service provider from connector_name: {}\",\n                    self.connector_name\n                )\n            })?;\n\n        Ok(Some(provider))\n    }\n\n    pub fn should_construct_webhook_setup_capability(&self) -> bool {\n        matches!(self.connector_type, enums::ConnectorType::PaymentProcessor)\n    }\n\n    pub fn get_connector_webhook_registration_details(&self) -> Option<Value> {\n        self.connector_webhook_registration_details.clone()\n    }\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Clone, Debug)]\npub enum MerchantConnectorAccountTypeDetails {\n    MerchantConnectorAccount(Box<MerchantConnectorAccount>),\n    MerchantConnectorDetails(common_types::domain::MerchantConnectorAuthDetails),\n}\n\n#[cfg(feature = \"v2\")]\nimpl MerchantConnectorAccountTypeDetails {\n    pub fn get_connector_account_details(",
    "function_name": "get_id",
    "file": "crates__hyperswitch_domain_models__src__merchant_connector_account.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__nexinets.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::PaymentIntent;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Mask;\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse transformers as nexinets;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        is_mandate_supported, to_connector_meta, PaymentMethodDataType, PaymentsSyncRequestData,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct Nexinets;\n\nimpl api::Payment for Nexinets {}\nimpl api::PaymentSession for Nexinets {}\nimpl api::ConnectorAccessToken for Nexinets {}\nimpl api::MandateSetup for Nexinets {}\nimpl api::PaymentAuthorize for Nexinets {}\nimpl api::PaymentSync for Nexinets {}\nimpl api::PaymentCapture for Nexinets {}\nimpl api::PaymentVoid for Nexinets {}\nimpl api::Refund for Nexinets {}\nimpl api::RefundExecute for Nexinets {}\nimpl api::RefundSync for Nexinets {}\n\nimpl Nexinets {\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: nexinets::NexinetsPaymentsMetadata = to_connector_meta(connector_meta.cloned())?;\n        Ok(meta.transaction_id)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Nexinets\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Nexinets {\n    fn id(&self) -> &'static str {\n        \"nexinets\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.nexinets.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = nexinets::NexinetsAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: nexinets::NexinetsErrorResponse = res\n            .response",
    "function_name": "connector_transaction_id",
    "file": "crates__hyperswitch_connectors__src__connectors__nexinets.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__nexinets.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::PaymentIntent;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Mask;\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse transformers as nexinets;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        is_mandate_supported, to_connector_meta, PaymentMethodDataType, PaymentsSyncRequestData,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct Nexinets;\n\nimpl api::Payment for Nexinets {}\nimpl api::PaymentSession for Nexinets {}\nimpl api::ConnectorAccessToken for Nexinets {}\nimpl api::MandateSetup for Nexinets {}\nimpl api::PaymentAuthorize for Nexinets {}\nimpl api::PaymentSync for Nexinets {}\nimpl api::PaymentCapture for Nexinets {}\nimpl api::PaymentVoid for Nexinets {}\nimpl api::Refund for Nexinets {}\nimpl api::RefundExecute for Nexinets {}\nimpl api::RefundSync for Nexinets {}\n\nimpl Nexinets {\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: nexinets::NexinetsPaymentsMetadata = to_connector_meta(connector_meta.cloned())?;\n        Ok(meta.transaction_id)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Nexinets\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Nexinets {\n    fn id(&self) -> &'static str {\n        \"nexinets\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.nexinets.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = nexinets::NexinetsAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: nexinets::NexinetsErrorResponse = res\n            .response",
    "function_name": "connector_transaction_id",
    "file": "crates__hyperswitch_connectors__src__connectors__nexinets.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for connector_transaction_id",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::ByteSliceExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"v2\")]\nuse hyperswitch_domain_models::payments::PaymentIntent;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse,\n    payment_method_data::PaymentMethodData,\n    payments::payment_attempt::PaymentAttempt,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorTransactionId, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        PaymentsAuthorizeType, PaymentsCaptureType, PaymentsSyncType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::Mask;\n#[cfg(feature = \"v2\")]\nuse masking::PeekInterface;\nuse transformers as nexinets;\n\nuse crate::{\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        is_mandate_supported, to_connector_meta, PaymentMethodDataType, PaymentsSyncRequestData,\n    },\n};\n\n#[derive(Debug, Clone)]\npub struct Nexinets;\n\nimpl api::Payment for Nexinets {}\nimpl api::PaymentSession for Nexinets {}\nimpl api::ConnectorAccessToken for Nexinets {}\nimpl api::MandateSetup for Nexinets {}\nimpl api::PaymentAuthorize for Nexinets {}\nimpl api::PaymentSync for Nexinets {}\nimpl api::PaymentCapture for Nexinets {}\nimpl api::PaymentVoid for Nexinets {}\nimpl api::Refund for Nexinets {}\nimpl api::RefundExecute for Nexinets {}\nimpl api::RefundSync for Nexinets {}\n\nimpl Nexinets {\n    pub fn connector_transaction_id(\n        &self,\n        connector_meta: Option<&serde_json::Value>,\n    ) -> CustomResult<Option<String>, errors::ConnectorError> {\n        let meta: nexinets::NexinetsPaymentsMetadata = to_connector_meta(connector_meta.cloned())?;\n        Ok(meta.transaction_id)\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Nexinets\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Nexinets {\n    fn id(&self) -> &'static str {\n        \"nexinets\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.nexinets.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = nexinets::NexinetsAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: nexinets::NexinetsErrorResponse = res\n            .response",
    "function_name": "connector_transaction_id",
    "file": "crates__hyperswitch_connectors__src__connectors__nexinets.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments;\nuse cards::CardNumber;\nuse common_enums::{enums, BankNames, CaptureMethod, Currency};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::Encode,\n    pii::Email,\n    request::Method,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, CardDetailsForNetworkTransactionId, GooglePayWalletData,\n        PaymentMethodData, RealTimePaymentData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse url::Url;\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{self, PaymentsAuthorizeRequestData, QrImage, RefundsRequestData, RouterData as _},\n};\n\npub struct FiuuRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for FiuuRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\npub struct FiuuAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) verify_key: Secret<String>,\n    pub(super) secret_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for FiuuAuthType {\n    type Error = Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                merchant_id: key1.to_owned(),\n                verify_key: api_key.to_owned(),\n                secret_key: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum TxnType {\n    Sals,\n    Auts,\n}\n\nimpl TryFrom<Option<CaptureMethod>> for TxnType {\n    type Error = Report<errors::ConnectorError>;\n    fn try_from(capture_method: Option<CaptureMethod>) -> Result<Self, Self::Error> {\n        match capture_method {\n            Some(CaptureMethod::Automatic) | Some(CaptureMethod::SequentialAutomatic) | None => {\n                Ok(Self::Sals)\n            }\n            Some(CaptureMethod::Manual) => Ok(Self::Auts),\n            _ => Err(errors::ConnectorError::CaptureMethodNotSupported.into()),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Display, Debug, Clone)]\nenum TxnChannel {\n    #[serde(rename = \"CREDITAN\")]\n    #[strum(serialize = \"CREDITAN\")]\n    Creditan,\n    #[serde(rename = \"RPP_DUITNOWQR\")]\n    #[strum(serialize = \"RPP_DUITNOWQR\")]\n    RppDuitNowQr,\n}\n\n#[derive(Serialize, Deserialize, Display, Debug, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum FPXTxnChannel {\n    FpxAbb,\n    FpxUob,\n    FpxAbmb,\n    FpxScb,\n    FpxBsn,\n    FpxKfh,\n    FpxBmmb,\n    FpxBkrm,\n    FpxHsbc,\n    FpxAgrobank,\n    FpxBocm,\n    FpxMb2u,\n    FpxCimbclicks,\n    FpxAmb,\n    FpxHlb,\n    FpxPbb,\n    FpxRhb,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments;\nuse cards::CardNumber;\nuse common_enums::{enums, BankNames, CaptureMethod, Currency};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::Encode,\n    pii::Email,\n    request::Method,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, CardDetailsForNetworkTransactionId, GooglePayWalletData,\n        PaymentMethodData, RealTimePaymentData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse url::Url;\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{self, PaymentsAuthorizeRequestData, QrImage, RefundsRequestData, RouterData as _},\n};\n\npub struct FiuuRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for FiuuRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\npub struct FiuuAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) verify_key: Secret<String>,\n    pub(super) secret_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for FiuuAuthType {\n    type Error = Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                merchant_id: key1.to_owned(),\n                verify_key: api_key.to_owned(),\n                secret_key: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum TxnType {\n    Sals,\n    Auts,\n}\n\nimpl TryFrom<Option<CaptureMethod>> for TxnType {\n    type Error = Report<errors::ConnectorError>;\n    fn try_from(capture_method: Option<CaptureMethod>) -> Result<Self, Self::Error> {\n        match capture_method {\n            Some(CaptureMethod::Automatic) | Some(CaptureMethod::SequentialAutomatic) | None => {\n                Ok(Self::Sals)\n            }\n            Some(CaptureMethod::Manual) => Ok(Self::Auts),\n            _ => Err(errors::ConnectorError::CaptureMethodNotSupported.into()),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Display, Debug, Clone)]\nenum TxnChannel {\n    #[serde(rename = \"CREDITAN\")]\n    #[strum(serialize = \"CREDITAN\")]\n    Creditan,\n    #[serde(rename = \"RPP_DUITNOWQR\")]\n    #[strum(serialize = \"RPP_DUITNOWQR\")]\n    RppDuitNowQr,\n}\n\n#[derive(Serialize, Deserialize, Display, Debug, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum FPXTxnChannel {\n    FpxAbb,\n    FpxUob,\n    FpxAbmb,\n    FpxScb,\n    FpxBsn,\n    FpxKfh,\n    FpxBmmb,\n    FpxBkrm,\n    FpxHsbc,\n    FpxAgrobank,\n    FpxBocm,\n    FpxMb2u,\n    FpxCimbclicks,\n    FpxAmb,\n    FpxHlb,\n    FpxPbb,\n    FpxRhb,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use std::collections::HashMap;\n\nuse api_models::payments;\nuse cards::CardNumber;\nuse common_enums::{enums, BankNames, CaptureMethod, Currency};\nuse common_types::payments::ApplePayPredecryptData;\nuse common_utils::{\n    crypto::{self, GenerateDigest},\n    errors::CustomResult,\n    ext_traits::Encode,\n    pii::Email,\n    request::Method,\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};\nuse error_stack::{Report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::{\n        BankRedirectData, Card, CardDetailsForNetworkTransactionId, GooglePayWalletData,\n        PaymentMethodData, RealTimePaymentData, WalletData,\n    },\n    router_data::{ConnectorAuthType, ErrorResponse, PaymentMethodToken},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{\n        MandateReference, PaymentsResponseData, RedirectForm, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{consts, errors};\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\nuse strum::Display;\nuse url::Url;\n\n// These needs to be accepted from SDK, need to be done after 1.0.0 stability as API contract will change\nconst GOOGLEPAY_API_VERSION_MINOR: u8 = 0;\nconst GOOGLEPAY_API_VERSION: u8 = 2;\n\nuse crate::{\n    constants,\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsResponseRouterData, PaymentsSyncResponseRouterData, RefundsResponseRouterData,\n    },\n    unimplemented_payment_method,\n    utils::{self, PaymentsAuthorizeRequestData, QrImage, RefundsRequestData, RouterData as _},\n};\n\npub struct FiuuRouterData<T> {\n    pub amount: StringMajorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMajorUnit, T)> for FiuuRouterData<T> {\n    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data: item,\n        }\n    }\n}\n\npub struct FiuuAuthType {\n    pub(super) merchant_id: Secret<String>,\n    pub(super) verify_key: Secret<String>,\n    pub(super) secret_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for FiuuAuthType {\n    type Error = Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::SignatureKey {\n                api_key,\n                key1,\n                api_secret,\n            } => Ok(Self {\n                merchant_id: key1.to_owned(),\n                verify_key: api_key.to_owned(),\n                secret_key: api_secret.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum TxnType {\n    Sals,\n    Auts,\n}\n\nimpl TryFrom<Option<CaptureMethod>> for TxnType {\n    type Error = Report<errors::ConnectorError>;\n    fn try_from(capture_method: Option<CaptureMethod>) -> Result<Self, Self::Error> {\n        match capture_method {\n            Some(CaptureMethod::Automatic) | Some(CaptureMethod::SequentialAutomatic) | None => {\n                Ok(Self::Sals)\n            }\n            Some(CaptureMethod::Manual) => Ok(Self::Auts),\n            _ => Err(errors::ConnectorError::CaptureMethodNotSupported.into()),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Display, Debug, Clone)]\nenum TxnChannel {\n    #[serde(rename = \"CREDITAN\")]\n    #[strum(serialize = \"CREDITAN\")]\n    Creditan,\n    #[serde(rename = \"RPP_DUITNOWQR\")]\n    #[strum(serialize = \"RPP_DUITNOWQR\")]\n    RppDuitNowQr,\n}\n\n#[derive(Serialize, Deserialize, Display, Debug, Clone)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum FPXTxnChannel {\n    FpxAbb,\n    FpxUob,\n    FpxAbmb,\n    FpxScb,\n    FpxBsn,\n    FpxKfh,\n    FpxBmmb,\n    FpxBkrm,\n    FpxHsbc,\n    FpxAgrobank,\n    FpxBocm,\n    FpxMb2u,\n    FpxCimbclicks,\n    FpxAmb,\n    FpxHlb,\n    FpxPbb,\n    FpxRhb,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__fiuu__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as digitalvirgo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Digitalvirgo {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Digitalvirgo {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Digitalvirgo {}\nimpl api::PaymentSession for Digitalvirgo {}\nimpl api::ConnectorAccessToken for Digitalvirgo {}\nimpl api::MandateSetup for Digitalvirgo {}\nimpl api::PaymentAuthorize for Digitalvirgo {}\nimpl api::PaymentSync for Digitalvirgo {}\nimpl api::PaymentCapture for Digitalvirgo {}\nimpl api::PaymentVoid for Digitalvirgo {}\nimpl api::Refund for Digitalvirgo {}\nimpl api::RefundExecute for Digitalvirgo {}\nimpl api::RefundSync for Digitalvirgo {}\nimpl api::PaymentToken for Digitalvirgo {}\nimpl api::PaymentsCompleteAuthorize for Digitalvirgo {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Digitalvirgo\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Digitalvirgo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Digitalvirgo {\n    fn id(&self) -> &'static str {\n        \"digitalvirgo\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.digitalvirgo.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = digitalvirgo::DigitalvirgoAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key = consts::BASE64_ENGINE.encode(format!(\n            \"{}:{}\",\n            auth.username.peek(),\n            auth.password.peek()\n        ));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),\n        )])\n    }\n\n    fn build_error_response(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as digitalvirgo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Digitalvirgo {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Digitalvirgo {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Digitalvirgo {}\nimpl api::PaymentSession for Digitalvirgo {}\nimpl api::ConnectorAccessToken for Digitalvirgo {}\nimpl api::MandateSetup for Digitalvirgo {}\nimpl api::PaymentAuthorize for Digitalvirgo {}\nimpl api::PaymentSync for Digitalvirgo {}\nimpl api::PaymentCapture for Digitalvirgo {}\nimpl api::PaymentVoid for Digitalvirgo {}\nimpl api::Refund for Digitalvirgo {}\nimpl api::RefundExecute for Digitalvirgo {}\nimpl api::RefundSync for Digitalvirgo {}\nimpl api::PaymentToken for Digitalvirgo {}\nimpl api::PaymentsCompleteAuthorize for Digitalvirgo {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Digitalvirgo\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Digitalvirgo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Digitalvirgo {\n    fn id(&self) -> &'static str {\n        \"digitalvirgo\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.digitalvirgo.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = digitalvirgo::DigitalvirgoAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key = consts::BASE64_ENGINE.encode(format!(\n            \"{}:{}\",\n            auth.username.peek(),\n            auth.password.peek()\n        ));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),\n        )])\n    }\n\n    fn build_error_response(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, Session,\n            SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData,\n        PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsSyncRouterData, RefundSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse transformers as digitalvirgo;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Digitalvirgo {\n    amount_converter: &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\n\nimpl Digitalvirgo {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Digitalvirgo {}\nimpl api::PaymentSession for Digitalvirgo {}\nimpl api::ConnectorAccessToken for Digitalvirgo {}\nimpl api::MandateSetup for Digitalvirgo {}\nimpl api::PaymentAuthorize for Digitalvirgo {}\nimpl api::PaymentSync for Digitalvirgo {}\nimpl api::PaymentCapture for Digitalvirgo {}\nimpl api::PaymentVoid for Digitalvirgo {}\nimpl api::Refund for Digitalvirgo {}\nimpl api::RefundExecute for Digitalvirgo {}\nimpl api::RefundSync for Digitalvirgo {}\nimpl api::PaymentToken for Digitalvirgo {}\nimpl api::PaymentsCompleteAuthorize for Digitalvirgo {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Digitalvirgo\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Digitalvirgo\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Digitalvirgo {\n    fn id(&self) -> &'static str {\n        \"digitalvirgo\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.digitalvirgo.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = digitalvirgo::DigitalvirgoAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        let encoded_api_key = consts::BASE64_ENGINE.encode(format!(\n            \"{}:{}\",\n            auth.username.peek(),\n            auth.password.peek()\n        ));\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            format!(\"Basic {encoded_api_key}\").into_masked(),\n        )])\n    }\n\n    fn build_error_response(",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__digitalvirgo.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse transformers as payjustnowinstore;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst PAYJUSTNOWINSTORE_MERCHANT_TERMINAL_ID: &str = \"X-PayJustNow-Merchant-Terminal-ID\";\nconst SIGNATURE: &str = \"X-Signature\";\nconst MERCHANT_REFERENCE_NON_UNIQUE: &str = \"X-Merchant-Reference-Non-Unique\";\n\n#[derive(Clone)]\npub struct Payjustnowinstore {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payjustnowinstore {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Payjustnowinstore {}\nimpl api::PaymentSession for Payjustnowinstore {}\nimpl api::ConnectorAccessToken for Payjustnowinstore {}\nimpl api::MandateSetup for Payjustnowinstore {}\nimpl api::PaymentAuthorize for Payjustnowinstore {}\nimpl api::PaymentSync for Payjustnowinstore {}\nimpl api::PaymentCapture for Payjustnowinstore {}\nimpl api::PaymentVoid for Payjustnowinstore {}\nimpl api::Refund for Payjustnowinstore {}\nimpl api::RefundExecute for Payjustnowinstore {}\nimpl api::RefundSync for Payjustnowinstore {}\nimpl api::PaymentToken for Payjustnowinstore {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payjustnowinstore\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payjustnowinstore\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let request_body = Self::get_request_body(self, req, connectors)?;\n\n        let request_body_string =\n            String::from_utf8(request_body.get_inner_value().peek().as_bytes().to_vec())\n                .map_err(|_| errors::ConnectorError::RequestEncodingFailed)?;\n\n        let request_body_string_without_whitespace =\n            request_body_string.replace(char::is_whitespace, \"\");\n\n        let auth = payjustnowinstore::PayjustnowinstoreAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, auth.merchant_api_key.expose().as_bytes());\n\n        let signature = hmac::sign(&key, request_body_string_without_whitespace.as_bytes());\n\n        let signature_hex = hex::encode(signature.as_ref());\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (SIGNATURE.to_string(), signature_hex.into_masked()),\n            (\n                MERCHANT_REFERENCE_NON_UNIQUE.to_string(),\n                \"true\".to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Payjustnowinstore {\n    fn id(&self) -> &'static str {\n        \"payjustnowinstore\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse transformers as payjustnowinstore;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst PAYJUSTNOWINSTORE_MERCHANT_TERMINAL_ID: &str = \"X-PayJustNow-Merchant-Terminal-ID\";\nconst SIGNATURE: &str = \"X-Signature\";\nconst MERCHANT_REFERENCE_NON_UNIQUE: &str = \"X-Merchant-Reference-Non-Unique\";\n\n#[derive(Clone)]\npub struct Payjustnowinstore {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payjustnowinstore {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Payjustnowinstore {}\nimpl api::PaymentSession for Payjustnowinstore {}\nimpl api::ConnectorAccessToken for Payjustnowinstore {}\nimpl api::MandateSetup for Payjustnowinstore {}\nimpl api::PaymentAuthorize for Payjustnowinstore {}\nimpl api::PaymentSync for Payjustnowinstore {}\nimpl api::PaymentCapture for Payjustnowinstore {}\nimpl api::PaymentVoid for Payjustnowinstore {}\nimpl api::Refund for Payjustnowinstore {}\nimpl api::RefundExecute for Payjustnowinstore {}\nimpl api::RefundSync for Payjustnowinstore {}\nimpl api::PaymentToken for Payjustnowinstore {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payjustnowinstore\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payjustnowinstore\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let request_body = Self::get_request_body(self, req, connectors)?;\n\n        let request_body_string =\n            String::from_utf8(request_body.get_inner_value().peek().as_bytes().to_vec())\n                .map_err(|_| errors::ConnectorError::RequestEncodingFailed)?;\n\n        let request_body_string_without_whitespace =\n            request_body_string.replace(char::is_whitespace, \"\");\n\n        let auth = payjustnowinstore::PayjustnowinstoreAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, auth.merchant_api_key.expose().as_bytes());\n\n        let signature = hmac::sign(&key, request_body_string_without_whitespace.as_bytes());\n\n        let signature_hex = hex::encode(signature.as_ref());\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (SIGNATURE.to_string(), signature_hex.into_masked()),\n            (\n                MERCHANT_REFERENCE_NON_UNIQUE.to_string(),\n                \"true\".to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Payjustnowinstore {\n    fn id(&self) -> &'static str {\n        \"payjustnowinstore\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts::NO_ERROR_MESSAGE,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, PeekInterface};\nuse ring::hmac;\nuse transformers as payjustnowinstore;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\nconst PAYJUSTNOWINSTORE_MERCHANT_TERMINAL_ID: &str = \"X-PayJustNow-Merchant-Terminal-ID\";\nconst SIGNATURE: &str = \"X-Signature\";\nconst MERCHANT_REFERENCE_NON_UNIQUE: &str = \"X-Merchant-Reference-Non-Unique\";\n\n#[derive(Clone)]\npub struct Payjustnowinstore {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payjustnowinstore {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Payjustnowinstore {}\nimpl api::PaymentSession for Payjustnowinstore {}\nimpl api::ConnectorAccessToken for Payjustnowinstore {}\nimpl api::MandateSetup for Payjustnowinstore {}\nimpl api::PaymentAuthorize for Payjustnowinstore {}\nimpl api::PaymentSync for Payjustnowinstore {}\nimpl api::PaymentCapture for Payjustnowinstore {}\nimpl api::PaymentVoid for Payjustnowinstore {}\nimpl api::Refund for Payjustnowinstore {}\nimpl api::RefundExecute for Payjustnowinstore {}\nimpl api::RefundSync for Payjustnowinstore {}\nimpl api::PaymentToken for Payjustnowinstore {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payjustnowinstore\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payjustnowinstore\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let request_body = Self::get_request_body(self, req, connectors)?;\n\n        let request_body_string =\n            String::from_utf8(request_body.get_inner_value().peek().as_bytes().to_vec())\n                .map_err(|_| errors::ConnectorError::RequestEncodingFailed)?;\n\n        let request_body_string_without_whitespace =\n            request_body_string.replace(char::is_whitespace, \"\");\n\n        let auth = payjustnowinstore::PayjustnowinstoreAuthType::try_from(&req.connector_auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n\n        let key = hmac::Key::new(hmac::HMAC_SHA256, auth.merchant_api_key.expose().as_bytes());\n\n        let signature = hmac::sign(&key, request_body_string_without_whitespace.as_bytes());\n\n        let signature_hex = hex::encode(signature.as_ref());\n\n        let mut header = vec![\n            (\n                headers::CONTENT_TYPE.to_string(),\n                self.get_content_type().to_string().into(),\n            ),\n            (SIGNATURE.to_string(), signature_hex.into_masked()),\n            (\n                MERCHANT_REFERENCE_NON_UNIQUE.to_string(),\n                \"true\".to_string().into(),\n            ),\n        ];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Payjustnowinstore {\n    fn id(&self) -> &'static str {\n        \"payjustnowinstore\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n    }",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payjustnowinstore.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__boku__transformers.rs",
    "code": "use std::fmt;\n\nuse common_enums::enums;\nuse common_utils::{request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, AddressDetailsData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct BokuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for BokuRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum BokuPaymentsRequest {\n    BeginSingleCharge(SingleChargeData),\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct SingleChargeData {\n    total_amount: MinorUnit,\n    currency: String,\n    country: String,\n    merchant_id: Secret<String>,\n    merchant_transaction_id: Secret<String>,\n    merchant_request_id: String,\n    merchant_item_description: String,\n    notification_url: Option<String>,\n    payment_method: String,\n    charge_type: String,\n    hosted: Option<BokuHostedData>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuPaymentType {\n    Dana,\n    Momo,\n    Gcash,\n    GoPay,\n    Kakaopay,\n}\n\nimpl fmt::Display for BokuPaymentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Dana => write!(f, \"Dana\"),\n            Self::Momo => write!(f, \"Momo\"),\n            Self::Gcash => write!(f, \"Gcash\"),\n            Self::GoPay => write!(f, \"GoPay\"),\n            Self::Kakaopay => write!(f, \"Kakaopay\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuChargeType {\n    Hosted,\n}\n\nimpl fmt::Display for BokuChargeType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Hosted => write!(f, \"hosted\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct BokuHostedData {\n    forward_url: String,\n}\n\nimpl TryFrom<&BokuRouterData<&types::PaymentsAuthorizeRouterData>> for BokuPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &BokuRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(wallet_data) => Self::try_from((item, &wallet_data)),\n            PaymentMethodData::Card(_)\n            | PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)\n            | PaymentMethodData::Crypto(_)\n            | PaymentMethodData::MandatePayment\n            | PaymentMethodData::Reward\n            | PaymentMethodData::RealTimePayment(_)\n            | PaymentMethodData::MobilePayment(_)\n            | PaymentMethodData::Upi(_)\n            | PaymentMethodData::Voucher(_)\n            | PaymentMethodData::GiftCard(_)\n            | PaymentMethodData::OpenBanking(_)\n            | PaymentMethodData::CardToken(_)\n            | PaymentMethodData::NetworkToken(_)\n            | PaymentMethodData::CardDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::CardWithLimitedDetails(_)\n            | PaymentMethodData::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::NetworkTokenDetailsForNetworkTransactionId(_) => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"boku\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl\n    TryFrom<(\n        &BokuRouterData<&types::PaymentsAuthorizeRouterData>,\n        &WalletData,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__boku__transformers.rs",
    "code": "use std::fmt;\n\nuse common_enums::enums;\nuse common_utils::{request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, AddressDetailsData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct BokuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for BokuRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum BokuPaymentsRequest {\n    BeginSingleCharge(SingleChargeData),\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct SingleChargeData {\n    total_amount: MinorUnit,\n    currency: String,\n    country: String,\n    merchant_id: Secret<String>,\n    merchant_transaction_id: Secret<String>,\n    merchant_request_id: String,\n    merchant_item_description: String,\n    notification_url: Option<String>,\n    payment_method: String,\n    charge_type: String,\n    hosted: Option<BokuHostedData>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuPaymentType {\n    Dana,\n    Momo,\n    Gcash,\n    GoPay,\n    Kakaopay,\n}\n\nimpl fmt::Display for BokuPaymentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Dana => write!(f, \"Dana\"),\n            Self::Momo => write!(f, \"Momo\"),\n            Self::Gcash => write!(f, \"Gcash\"),\n            Self::GoPay => write!(f, \"GoPay\"),\n            Self::Kakaopay => write!(f, \"Kakaopay\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuChargeType {\n    Hosted,\n}\n\nimpl fmt::Display for BokuChargeType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Hosted => write!(f, \"hosted\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct BokuHostedData {\n    forward_url: String,\n}\n\nimpl TryFrom<&BokuRouterData<&types::PaymentsAuthorizeRouterData>> for BokuPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &BokuRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(wallet_data) => Self::try_from((item, &wallet_data)),\n            PaymentMethodData::Card(_)\n            | PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)\n            | PaymentMethodData::Crypto(_)\n            | PaymentMethodData::MandatePayment\n            | PaymentMethodData::Reward\n            | PaymentMethodData::RealTimePayment(_)\n            | PaymentMethodData::MobilePayment(_)\n            | PaymentMethodData::Upi(_)\n            | PaymentMethodData::Voucher(_)\n            | PaymentMethodData::GiftCard(_)\n            | PaymentMethodData::OpenBanking(_)\n            | PaymentMethodData::CardToken(_)\n            | PaymentMethodData::NetworkToken(_)\n            | PaymentMethodData::CardDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::CardWithLimitedDetails(_)\n            | PaymentMethodData::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::NetworkTokenDetailsForNetworkTransactionId(_) => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"boku\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl\n    TryFrom<(\n        &BokuRouterData<&types::PaymentsAuthorizeRouterData>,\n        &WalletData,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use std::fmt;\n\nuse common_enums::enums;\nuse common_utils::{request::Method, types::MinorUnit};\nuse hyperswitch_domain_models::{\n    payment_method_data::{PaymentMethodData, WalletData},\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{self, RefundsRouterData},\n};\nuse hyperswitch_interfaces::errors;\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::{\n    types::{RefundsResponseRouterData, ResponseRouterData},\n    utils::{self, AddressDetailsData, RouterData as _},\n};\n\n#[derive(Debug, Serialize)]\npub struct BokuRouterData<T> {\n    pub amount: MinorUnit,\n    pub router_data: T,\n}\n\nimpl<T> From<(MinorUnit, T)> for BokuRouterData<T> {\n    fn from((amount, router_data): (MinorUnit, T)) -> Self {\n        Self {\n            amount,\n            router_data,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum BokuPaymentsRequest {\n    BeginSingleCharge(SingleChargeData),\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct SingleChargeData {\n    total_amount: MinorUnit,\n    currency: String,\n    country: String,\n    merchant_id: Secret<String>,\n    merchant_transaction_id: Secret<String>,\n    merchant_request_id: String,\n    merchant_item_description: String,\n    notification_url: Option<String>,\n    payment_method: String,\n    charge_type: String,\n    hosted: Option<BokuHostedData>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuPaymentType {\n    Dana,\n    Momo,\n    Gcash,\n    GoPay,\n    Kakaopay,\n}\n\nimpl fmt::Display for BokuPaymentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Dana => write!(f, \"Dana\"),\n            Self::Momo => write!(f, \"Momo\"),\n            Self::Gcash => write!(f, \"Gcash\"),\n            Self::GoPay => write!(f, \"GoPay\"),\n            Self::Kakaopay => write!(f, \"Kakaopay\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub enum BokuChargeType {\n    Hosted,\n}\n\nimpl fmt::Display for BokuChargeType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Hosted => write!(f, \"hosted\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct BokuHostedData {\n    forward_url: String,\n}\n\nimpl TryFrom<&BokuRouterData<&types::PaymentsAuthorizeRouterData>> for BokuPaymentsRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(\n        item: &BokuRouterData<&types::PaymentsAuthorizeRouterData>,\n    ) -> Result<Self, Self::Error> {\n        match item.router_data.request.payment_method_data.clone() {\n            PaymentMethodData::Wallet(wallet_data) => Self::try_from((item, &wallet_data)),\n            PaymentMethodData::Card(_)\n            | PaymentMethodData::CardRedirect(_)\n            | PaymentMethodData::PayLater(_)\n            | PaymentMethodData::BankRedirect(_)\n            | PaymentMethodData::BankDebit(_)\n            | PaymentMethodData::BankTransfer(_)\n            | PaymentMethodData::Crypto(_)\n            | PaymentMethodData::MandatePayment\n            | PaymentMethodData::Reward\n            | PaymentMethodData::RealTimePayment(_)\n            | PaymentMethodData::MobilePayment(_)\n            | PaymentMethodData::Upi(_)\n            | PaymentMethodData::Voucher(_)\n            | PaymentMethodData::GiftCard(_)\n            | PaymentMethodData::OpenBanking(_)\n            | PaymentMethodData::CardToken(_)\n            | PaymentMethodData::NetworkToken(_)\n            | PaymentMethodData::CardDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::CardWithLimitedDetails(_)\n            | PaymentMethodData::DecryptedWalletTokenDetailsForNetworkTransactionId(_)\n            | PaymentMethodData::NetworkTokenDetailsForNetworkTransactionId(_) => {\n                Err(errors::ConnectorError::NotImplemented(\n                    utils::get_unimplemented_payment_method_error_message(\"boku\"),\n                ))?\n            }\n        }\n    }\n}\n\nimpl\n    TryFrom<(\n        &BokuRouterData<&types::PaymentsAuthorizeRouterData>,\n        &WalletData,",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__boku__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__payone.rs",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\nuse common_utils::{consts::BASE64_ENGINE, errors::CustomResult, ext_traits::BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Method, Request, RequestBuilder},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::PoFulfill,\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::{\n    api::{PayoutFulfill, Payouts},\n    types::PayoutFulfillType,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::hmac;\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\n\nuse self::transformers as payone;\n#[cfg(feature = \"payouts\")]\nuse crate::constants::headers::DATE;\n#[cfg(feature = \"payouts\")]\nuse crate::get_formatted_date_time;\nuse crate::{\n    constants::headers::AUTHORIZATION,\n    utils::{\n        get_error_code_error_message_based_on_priority, ConnectorErrorType,\n        ConnectorErrorTypeMapping,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse crate::{types::ResponseRouterData, utils::convert_amount};\n#[derive(Clone)]\npub struct Payone {\n    #[cfg(feature = \"payouts\")]\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payone {\n    pub fn new() -> &'static Self {\n        &Self {\n            #[cfg(feature = \"payouts\")]\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n    pub fn generate_signature(\n        &self,\n        auth: payone::PayoneAuthType,\n        http_method: String,\n        canonicalized_path: String,\n        content_type: String,\n        date_header: String,\n    ) -> CustomResult<String, ConnectorError> {\n        let payone::PayoneAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let string_to_hash: String = format!(\n            \"{}\\n{}\\n{}\\n{}\\n\",\n            http_method,\n            content_type.trim(),\n            date_header.trim(),\n            canonicalized_path.trim()\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let hash_hmac = BASE64_ENGINE.encode(hmac::sign(&key, string_to_hash.as_bytes()));\n        let signature_header = format!(\"GCS v1HMAC:{}:{}\", api_key.peek(), hash_hmac);\n\n        Ok(signature_header)\n    }\n}\n\nimpl Payment for Payone {}\nimpl PaymentSession for Payone {}\nimpl ConnectorAccessToken for Payone {}\nimpl MandateSetup for Payone {}\nimpl PaymentAuthorize for Payone {}\nimpl PaymentSync for Payone {}\nimpl PaymentCapture for Payone {}\nimpl PaymentVoid for Payone {}\nimpl Refund for Payone {}\nimpl RefundExecute for Payone {}\nimpl RefundSync for Payone {}\nimpl PaymentToken for Payone {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payone\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payone\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    #[cfg(feature = \"payouts\")]\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payone.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__payone.rs",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\nuse common_utils::{consts::BASE64_ENGINE, errors::CustomResult, ext_traits::BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Method, Request, RequestBuilder},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::PoFulfill,\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::{\n    api::{PayoutFulfill, Payouts},\n    types::PayoutFulfillType,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::hmac;\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\n\nuse self::transformers as payone;\n#[cfg(feature = \"payouts\")]\nuse crate::constants::headers::DATE;\n#[cfg(feature = \"payouts\")]\nuse crate::get_formatted_date_time;\nuse crate::{\n    constants::headers::AUTHORIZATION,\n    utils::{\n        get_error_code_error_message_based_on_priority, ConnectorErrorType,\n        ConnectorErrorTypeMapping,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse crate::{types::ResponseRouterData, utils::convert_amount};\n#[derive(Clone)]\npub struct Payone {\n    #[cfg(feature = \"payouts\")]\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payone {\n    pub fn new() -> &'static Self {\n        &Self {\n            #[cfg(feature = \"payouts\")]\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n    pub fn generate_signature(\n        &self,\n        auth: payone::PayoneAuthType,\n        http_method: String,\n        canonicalized_path: String,\n        content_type: String,\n        date_header: String,\n    ) -> CustomResult<String, ConnectorError> {\n        let payone::PayoneAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let string_to_hash: String = format!(\n            \"{}\\n{}\\n{}\\n{}\\n\",\n            http_method,\n            content_type.trim(),\n            date_header.trim(),\n            canonicalized_path.trim()\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let hash_hmac = BASE64_ENGINE.encode(hmac::sign(&key, string_to_hash.as_bytes()));\n        let signature_header = format!(\"GCS v1HMAC:{}:{}\", api_key.peek(), hash_hmac);\n\n        Ok(signature_header)\n    }\n}\n\nimpl Payment for Payone {}\nimpl PaymentSession for Payone {}\nimpl ConnectorAccessToken for Payone {}\nimpl MandateSetup for Payone {}\nimpl PaymentAuthorize for Payone {}\nimpl PaymentSync for Payone {}\nimpl PaymentCapture for Payone {}\nimpl PaymentVoid for Payone {}\nimpl Refund for Payone {}\nimpl RefundExecute for Payone {}\nimpl RefundSync for Payone {}\nimpl PaymentToken for Payone {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payone\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payone\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    #[cfg(feature = \"payouts\")]\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payone.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse api_models::webhooks::{IncomingWebhookEvent, ObjectReferenceId};\nuse base64::Engine;\n#[cfg(feature = \"payouts\")]\nuse common_utils::request::RequestContent;\nuse common_utils::{consts::BASE64_ENGINE, errors::CustomResult, ext_traits::BytesExt};\n#[cfg(feature = \"payouts\")]\nuse common_utils::{\n    request::{Method, Request, RequestBuilder},\n    types::{AmountConvertor, MinorUnit, MinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_data::RouterData,\n    router_flow_types::PoFulfill,\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, Execute, PSync, PaymentMethodToken, RSync, Session,\n        SetupMandate, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        ConnectorAccessToken, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration,\n        ConnectorSpecifications, ConnectorValidation, CurrencyUnit, MandateSetup, Payment,\n        PaymentAuthorize, PaymentCapture, PaymentSession, PaymentSync, PaymentToken, PaymentVoid,\n        Refund, RefundExecute, RefundSync,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::Response,\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::{\n    api::{PayoutFulfill, Payouts},\n    types::PayoutFulfillType,\n};\nuse masking::{ExposeInterface, Mask, Maskable, PeekInterface};\nuse ring::hmac;\n#[cfg(feature = \"payouts\")]\nuse router_env::{instrument, tracing};\n\nuse self::transformers as payone;\n#[cfg(feature = \"payouts\")]\nuse crate::constants::headers::DATE;\n#[cfg(feature = \"payouts\")]\nuse crate::get_formatted_date_time;\nuse crate::{\n    constants::headers::AUTHORIZATION,\n    utils::{\n        get_error_code_error_message_based_on_priority, ConnectorErrorType,\n        ConnectorErrorTypeMapping,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse crate::{types::ResponseRouterData, utils::convert_amount};\n#[derive(Clone)]\npub struct Payone {\n    #[cfg(feature = \"payouts\")]\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n}\n\nimpl Payone {\n    pub fn new() -> &'static Self {\n        &Self {\n            #[cfg(feature = \"payouts\")]\n            amount_converter: &MinorUnitForConnector,\n        }\n    }\n    pub fn generate_signature(\n        &self,\n        auth: payone::PayoneAuthType,\n        http_method: String,\n        canonicalized_path: String,\n        content_type: String,\n        date_header: String,\n    ) -> CustomResult<String, ConnectorError> {\n        let payone::PayoneAuthType {\n            api_key,\n            api_secret,\n            ..\n        } = auth;\n        let string_to_hash: String = format!(\n            \"{}\\n{}\\n{}\\n{}\\n\",\n            http_method,\n            content_type.trim(),\n            date_header.trim(),\n            canonicalized_path.trim()\n        );\n        let key = hmac::Key::new(hmac::HMAC_SHA256, api_secret.expose().as_bytes());\n        let hash_hmac = BASE64_ENGINE.encode(hmac::sign(&key, string_to_hash.as_bytes()));\n        let signature_header = format!(\"GCS v1HMAC:{}:{}\", api_key.peek(), hash_hmac);\n\n        Ok(signature_header)\n    }\n}\n\nimpl Payment for Payone {}\nimpl PaymentSession for Payone {}\nimpl ConnectorAccessToken for Payone {}\nimpl MandateSetup for Payone {}\nimpl PaymentAuthorize for Payone {}\nimpl PaymentSync for Payone {}\nimpl PaymentCapture for Payone {}\nimpl PaymentVoid for Payone {}\nimpl Refund for Payone {}\nimpl RefundExecute for Payone {}\nimpl RefundSync for Payone {}\nimpl PaymentToken for Payone {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Payone\n{\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Payone\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    #[cfg(feature = \"payouts\")]\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        connectors: &Connectors,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__payone.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__stripebilling.rs",
    "code": "pub mod transformers;\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::revenue_recovery;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::types as recovery_router_data_types;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery as recovery_router_flows, subscriptions as subscription_flow_types,\n    },\n    router_request_types::{\n        revenue_recovery as recovery_request_types, subscriptions as subscription_request_types,\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery as recovery_response_types, subscriptions as subscription_response_types,\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, subscriptions as subscriptions_api, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse stripebilling::auth_headers;\nuse transformers as stripebilling;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Stripebilling {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Stripebilling {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Stripebilling {}\nimpl api::PaymentSession for Stripebilling {}\nimpl api::ConnectorAccessToken for Stripebilling {}\nimpl api::MandateSetup for Stripebilling {}\nimpl api::PaymentAuthorize for Stripebilling {}\nimpl api::PaymentSync for Stripebilling {}\nimpl api::PaymentCapture for Stripebilling {}\nimpl api::PaymentVoid for Stripebilling {}\nimpl api::Refund for Stripebilling {}\nimpl api::RefundExecute for Stripebilling {}\nimpl api::RefundSync for Stripebilling {}\nimpl api::PaymentToken for Stripebilling {}\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nimpl api::revenue_recovery::RevenueRecoveryRecordBack for Stripebilling {}\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nimpl api::revenue_recovery::BillingConnectorPaymentsSyncIntegration for Stripebilling {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Stripebilling\n{\n    // Not Implemented (R)\n}\n\nimpl subscriptions_api::Subscriptions for Stripebilling {}\nimpl subscriptions_api::GetSubscriptionItemsFlow for Stripebilling {}\nimpl subscriptions_api::SubscriptionRecordBackFlow for Stripebilling {}\nimpl subscriptions_api::SubscriptionCreate for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionItems,\n        subscription_request_types::GetSubscriptionItemsRequest,\n        subscription_response_types::GetSubscriptionItemsResponse,\n    > for Stripebilling\n{\n}\nimpl subscriptions_api::GetSubscriptionPlanPricesFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionItemPrices,\n        subscription_request_types::GetSubscriptionItemPricesRequest,\n        subscription_response_types::GetSubscriptionItemPricesResponse,\n    > for Stripebilling\n{\n}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::SubscriptionCreate,\n        subscription_request_types::SubscriptionCreateRequest,\n        subscription_response_types::SubscriptionCreateResponse,\n    > for Stripebilling\n{\n}\nimpl subscriptions_api::GetSubscriptionEstimateFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionEstimate,\n        subscription_request_types::GetSubscriptionEstimateRequest,\n        subscription_response_types::GetSubscriptionEstimateResponse,\n    > for Stripebilling\n{\n}\n\nimpl subscriptions_api::SubscriptionCancelFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::SubscriptionCancel,\n        subscription_request_types::SubscriptionCancelRequest,\n        subscription_response_types::SubscriptionCancelResponse,\n    > for Stripebilling\n{\n}",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__stripebilling.rs",
    "code": "pub mod transformers;\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::revenue_recovery;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::types as recovery_router_data_types;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery as recovery_router_flows, subscriptions as subscription_flow_types,\n    },\n    router_request_types::{\n        revenue_recovery as recovery_request_types, subscriptions as subscription_request_types,\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery as recovery_response_types, subscriptions as subscription_response_types,\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, subscriptions as subscriptions_api, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse stripebilling::auth_headers;\nuse transformers as stripebilling;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Stripebilling {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Stripebilling {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Stripebilling {}\nimpl api::PaymentSession for Stripebilling {}\nimpl api::ConnectorAccessToken for Stripebilling {}\nimpl api::MandateSetup for Stripebilling {}\nimpl api::PaymentAuthorize for Stripebilling {}\nimpl api::PaymentSync for Stripebilling {}\nimpl api::PaymentCapture for Stripebilling {}\nimpl api::PaymentVoid for Stripebilling {}\nimpl api::Refund for Stripebilling {}\nimpl api::RefundExecute for Stripebilling {}\nimpl api::RefundSync for Stripebilling {}\nimpl api::PaymentToken for Stripebilling {}\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nimpl api::revenue_recovery::RevenueRecoveryRecordBack for Stripebilling {}\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nimpl api::revenue_recovery::BillingConnectorPaymentsSyncIntegration for Stripebilling {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Stripebilling\n{\n    // Not Implemented (R)\n}\n\nimpl subscriptions_api::Subscriptions for Stripebilling {}\nimpl subscriptions_api::GetSubscriptionItemsFlow for Stripebilling {}\nimpl subscriptions_api::SubscriptionRecordBackFlow for Stripebilling {}\nimpl subscriptions_api::SubscriptionCreate for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionItems,\n        subscription_request_types::GetSubscriptionItemsRequest,\n        subscription_response_types::GetSubscriptionItemsResponse,\n    > for Stripebilling\n{\n}\nimpl subscriptions_api::GetSubscriptionPlanPricesFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionItemPrices,\n        subscription_request_types::GetSubscriptionItemPricesRequest,\n        subscription_response_types::GetSubscriptionItemPricesResponse,\n    > for Stripebilling\n{\n}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::SubscriptionCreate,\n        subscription_request_types::SubscriptionCreateRequest,\n        subscription_response_types::SubscriptionCreateResponse,\n    > for Stripebilling\n{\n}\nimpl subscriptions_api::GetSubscriptionEstimateFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionEstimate,\n        subscription_request_types::GetSubscriptionEstimateRequest,\n        subscription_response_types::GetSubscriptionEstimateResponse,\n    > for Stripebilling\n{\n}\n\nimpl subscriptions_api::SubscriptionCancelFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::SubscriptionCancel,\n        subscription_request_types::SubscriptionCancelRequest,\n        subscription_response_types::SubscriptionCancelResponse,\n    > for Stripebilling\n{\n}",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::collections::HashMap;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::revenue_recovery;\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nuse hyperswitch_domain_models::types as recovery_router_data_types;\nuse hyperswitch_domain_models::{\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        revenue_recovery as recovery_router_flows, subscriptions as subscription_flow_types,\n    },\n    router_request_types::{\n        revenue_recovery as recovery_request_types, subscriptions as subscription_request_types,\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        revenue_recovery as recovery_response_types, subscriptions as subscription_response_types,\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, subscriptions as subscriptions_api, ConnectorCommon, ConnectorCommonExt,\n        ConnectorIntegration, ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{Mask, PeekInterface};\nuse stripebilling::auth_headers;\nuse transformers as stripebilling;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Stripebilling {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Stripebilling {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Stripebilling {}\nimpl api::PaymentSession for Stripebilling {}\nimpl api::ConnectorAccessToken for Stripebilling {}\nimpl api::MandateSetup for Stripebilling {}\nimpl api::PaymentAuthorize for Stripebilling {}\nimpl api::PaymentSync for Stripebilling {}\nimpl api::PaymentCapture for Stripebilling {}\nimpl api::PaymentVoid for Stripebilling {}\nimpl api::Refund for Stripebilling {}\nimpl api::RefundExecute for Stripebilling {}\nimpl api::RefundSync for Stripebilling {}\nimpl api::PaymentToken for Stripebilling {}\n#[cfg(all(feature = \"revenue_recovery\", feature = \"v2\"))]\nimpl api::revenue_recovery::RevenueRecoveryRecordBack for Stripebilling {}\n#[cfg(all(feature = \"v2\", feature = \"revenue_recovery\"))]\nimpl api::revenue_recovery::BillingConnectorPaymentsSyncIntegration for Stripebilling {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Stripebilling\n{\n    // Not Implemented (R)\n}\n\nimpl subscriptions_api::Subscriptions for Stripebilling {}\nimpl subscriptions_api::GetSubscriptionItemsFlow for Stripebilling {}\nimpl subscriptions_api::SubscriptionRecordBackFlow for Stripebilling {}\nimpl subscriptions_api::SubscriptionCreate for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionItems,\n        subscription_request_types::GetSubscriptionItemsRequest,\n        subscription_response_types::GetSubscriptionItemsResponse,\n    > for Stripebilling\n{\n}\nimpl subscriptions_api::GetSubscriptionPlanPricesFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionItemPrices,\n        subscription_request_types::GetSubscriptionItemPricesRequest,\n        subscription_response_types::GetSubscriptionItemPricesResponse,\n    > for Stripebilling\n{\n}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::SubscriptionCreate,\n        subscription_request_types::SubscriptionCreateRequest,\n        subscription_response_types::SubscriptionCreateResponse,\n    > for Stripebilling\n{\n}\nimpl subscriptions_api::GetSubscriptionEstimateFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::GetSubscriptionEstimate,\n        subscription_request_types::GetSubscriptionEstimateRequest,\n        subscription_response_types::GetSubscriptionEstimateResponse,\n    > for Stripebilling\n{\n}\n\nimpl subscriptions_api::SubscriptionCancelFlow for Stripebilling {}\nimpl\n    ConnectorIntegration<\n        subscription_flow_types::SubscriptionCancel,\n        subscription_request_types::SubscriptionCancelRequest,\n        subscription_response_types::SubscriptionCancelResponse,\n    > for Stripebilling\n{\n}",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__stripebilling.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__sift.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as sift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Sift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Sift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Sift {}\nimpl api::PaymentSession for Sift {}\nimpl api::ConnectorAccessToken for Sift {}\nimpl api::MandateSetup for Sift {}\nimpl api::PaymentAuthorize for Sift {}\nimpl api::PaymentSync for Sift {}\nimpl api::PaymentCapture for Sift {}\nimpl api::PaymentVoid for Sift {}\nimpl api::Refund for Sift {}\nimpl api::RefundExecute for Sift {}\nimpl api::RefundSync for Sift {}\nimpl api::PaymentToken for Sift {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Sift {\n    fn id(&self) -> &'static str {\n        \"sift\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.sift.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__sift.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__sift.rs",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as sift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Sift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Sift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Sift {}\nimpl api::PaymentSession for Sift {}\nimpl api::ConnectorAccessToken for Sift {}\nimpl api::MandateSetup for Sift {}\nimpl api::PaymentAuthorize for Sift {}\nimpl api::PaymentSync for Sift {}\nimpl api::PaymentCapture for Sift {}\nimpl api::PaymentVoid for Sift {}\nimpl api::Refund for Sift {}\nimpl api::RefundExecute for Sift {}\nimpl api::RefundSync for Sift {}\nimpl api::PaymentToken for Sift {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Sift {\n    fn id(&self) -> &'static str {\n        \"sift\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.sift.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__sift.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMinorUnit, StringMinorUnitForConnector},\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask};\nuse transformers as sift;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\n#[derive(Clone)]\npub struct Sift {\n    amount_converter: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Sift {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_converter: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl api::Payment for Sift {}\nimpl api::PaymentSession for Sift {}\nimpl api::ConnectorAccessToken for Sift {}\nimpl api::MandateSetup for Sift {}\nimpl api::PaymentAuthorize for Sift {}\nimpl api::PaymentSync for Sift {}\nimpl api::PaymentCapture for Sift {}\nimpl api::PaymentVoid for Sift {}\nimpl api::Refund for Sift {}\nimpl api::RefundExecute for Sift {}\nimpl api::RefundSync for Sift {}\nimpl api::PaymentToken for Sift {}\n\nimpl ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>\n    for Sift\n{\n    // Not Implemented (R)\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Sift\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let mut header = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Sift {\n    fn id(&self) -> &'static str {\n        \"sift\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Minor\n        //    TODO! Check connector documentation, on which unit they are processing the currency.\n        //    If the connector accepts amount in lower unit ( i.e cents for USD) then return api::CurrencyUnit::Minor,\n        //    if connector accepts amount in base unit (i.e dollars for USD) then return api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.sift.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let auth = sift::SiftAuthType::try_from(auth_type)\n            .change_context(errors::ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![(\n            headers::AUTHORIZATION.to_string(),\n            auth.api_key.expose().into_masked(),\n        )])\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: sift::SiftErrorResponse = res\n            .response\n            .parse_struct(\"SiftErrorResponse\")",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__sift.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__nuvei.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\n#[cfg(feature = \"payouts\")]\nuse api_models::webhooks::PayoutIdType;\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    id_type,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        unified_authentication_service::PreAuthenticate,\n        AuthorizeSessionToken, CompleteAuthorize, PostCaptureVoid, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, AuthorizeSessionTokenData, CompleteAuthorizeData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCancelPostCaptureData, PaymentsCaptureData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsAuthorizeSessionTokenRouterData,\n        PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::ExposeInterface;\nuse transformers as nuvei;\n\nuse crate::{\n    connectors::nuvei::transformers::{NuveiPaymentsResponse, NuveiTransactionSyncResponse},\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        self, is_mandate_supported, PaymentMethodDataType, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\n#[derive(Clone)]\npub struct Nuvei {\n    pub amount_convertor: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n    amount_converter_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\nimpl Nuvei {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &StringMajorUnitForConnector,\n            amount_converter_string_minor_unit: &StringMinorUnitForConnector,\n            amount_converter_float_major_unit: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Nuvei\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Nuvei {\n    fn id(&self) -> &'static str {\n        \"nuvei\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.nuvei.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n}\n\nimpl ConnectorValidation for Nuvei {\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nuvei.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__nuvei.rs",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\n#[cfg(feature = \"payouts\")]\nuse api_models::webhooks::PayoutIdType;\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    id_type,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        unified_authentication_service::PreAuthenticate,\n        AuthorizeSessionToken, CompleteAuthorize, PostCaptureVoid, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, AuthorizeSessionTokenData, CompleteAuthorizeData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCancelPostCaptureData, PaymentsCaptureData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsAuthorizeSessionTokenRouterData,\n        PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::ExposeInterface;\nuse transformers as nuvei;\n\nuse crate::{\n    connectors::nuvei::transformers::{NuveiPaymentsResponse, NuveiTransactionSyncResponse},\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        self, is_mandate_supported, PaymentMethodDataType, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\n#[derive(Clone)]\npub struct Nuvei {\n    pub amount_convertor: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n    amount_converter_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\nimpl Nuvei {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &StringMajorUnitForConnector,\n            amount_converter_string_minor_unit: &StringMinorUnitForConnector,\n            amount_converter_float_major_unit: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Nuvei\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Nuvei {\n    fn id(&self) -> &'static str {\n        \"nuvei\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.nuvei.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n}\n\nimpl ConnectorValidation for Nuvei {\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nuvei.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for new",
    "code": "pub mod transformers;\nuse std::sync::LazyLock;\n\n#[cfg(feature = \"payouts\")]\nuse api_models::webhooks::PayoutIdType;\nuse api_models::{\n    payments::PaymentIdType,\n    webhooks::{IncomingWebhookEvent, RefundIdType},\n};\nuse common_enums::{enums, CallConnectorAction, PaymentAction};\nuse common_utils::{\n    crypto,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt, ValueExt},\n    id_type,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector, StringMajorUnit,\n        StringMajorUnitForConnector, StringMinorUnit, StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n        unified_authentication_service::PreAuthenticate,\n        AuthorizeSessionToken, CompleteAuthorize, PostCaptureVoid, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, AuthorizeSessionTokenData, CompleteAuthorizeData,\n        PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData,\n        PaymentsCancelPostCaptureData, PaymentsCaptureData, PaymentsPreAuthenticateData,\n        PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData,\n        SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsAuthorizeSessionTokenRouterData,\n        PaymentsCancelPostCaptureRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsCompleteAuthorizeRouterData, PaymentsPreAuthenticateRouterData,\n        PaymentsPreProcessingRouterData, PaymentsSyncRouterData, RefundsRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::payouts::PoFulfill, router_request_types::PayoutsData,\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation,\n    },\n    configs::Connectors,\n    disputes, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::ExposeInterface;\nuse transformers as nuvei;\n\nuse crate::{\n    connectors::nuvei::transformers::{NuveiPaymentsResponse, NuveiTransactionSyncResponse},\n    constants::headers,\n    types::ResponseRouterData,\n    utils::{\n        self, is_mandate_supported, PaymentMethodDataType, PaymentsAuthorizeRequestData,\n        PaymentsSetupMandateRequestData, RouterData as _,\n    },\n};\n\n#[derive(Clone)]\npub struct Nuvei {\n    pub amount_convertor: &'static (dyn AmountConvertor<Output = StringMajorUnit> + Sync),\n    amount_converter_string_minor_unit:\n        &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n    amount_converter_float_major_unit:\n        &'static (dyn AmountConvertor<Output = FloatMajorUnit> + Sync),\n}\nimpl Nuvei {\n    pub fn new() -> &'static Self {\n        &Self {\n            amount_convertor: &StringMajorUnitForConnector,\n            amount_converter_string_minor_unit: &StringMinorUnitForConnector,\n            amount_converter_float_major_unit: &FloatMajorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Nuvei\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        _req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        let headers = vec![(\n            headers::CONTENT_TYPE.to_string(),\n            self.get_content_type().to_string().into(),\n        )];\n        Ok(headers)\n    }\n}\n\nimpl ConnectorCommon for Nuvei {\n    fn id(&self) -> &'static str {\n        \"nuvei\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.nuvei.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        _auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n}\n\nimpl ConnectorValidation for Nuvei {\n    fn validate_mandate_payment(\n        &self,\n        pm_type: Option<enums::PaymentMethodType>,\n        pm_data: PaymentMethodData,",
    "function_name": "new",
    "file": "crates__hyperswitch_connectors__src__connectors__nuvei.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://webservices.apl02.redsys.es\";\npub const REDSYS_SOAP_ACTION: &str = \"consultaOperaciones\";\n\n// Specifies the type of transaction for XML requests\npub mod transaction_type {\n    pub const PAYMENT: &str = \"0\";\n    pub const PREAUTHORIZATION: &str = \"1\";\n    pub const CONFIRMATION: &str = \"2\";\n    pub const REFUND: &str = \"3\";\n    pub const CANCELLATION: &str = \"9\";\n}\n\npub struct RedsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub currency: api_models::enums::Currency,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T, api_models::enums::Currency)> for RedsysRouterData<T> {\n    fn from((amount, item, currency): (StringMinorUnit, T, api_models::enums::Currency)) -> Self {\n        Self {\n            amount,\n            currency,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub struct PaymentsRequest {\n    ds_merchant_amount: StringMinorUnit,\n    ds_merchant_currency: String,\n    ds_merchant_cvv2: Secret<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    ds_merchant_emv3ds: Option<EmvThreedsData>,\n    ds_merchant_expirydate: Secret<String>,\n    ds_merchant_merchantcode: Secret<String>,\n    ds_merchant_order: String,\n    ds_merchant_pan: cards::CardNumber,\n    ds_merchant_terminal: Secret<String>,\n    ds_merchant_transactiontype: RedsysTransactionType,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EmvThreedsData {\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    billing_data: Option<BillingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_accept_header: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_color_depth: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_i_p: Option<Secret<String, common_utils::pii::IpAddress>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_java_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_javascript_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_language: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_height: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_width: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_t_z: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_user_agent: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    cres: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    notification_u_r_l: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    protocol_version: Option<String>,\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    shipping_data: Option<ShippingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    three_d_s_comp_ind: Option<ThreeDSCompInd>,\n    three_d_s_info: RedsysThreeDsInfo,\n    #[serde(\n        alias = \"threeds_server_transaction_id\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    three_d_s_server_trans_i_d: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingData {\n    #[serde(skip_serializing_if = \"Option::is_none\")]",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://webservices.apl02.redsys.es\";\npub const REDSYS_SOAP_ACTION: &str = \"consultaOperaciones\";\n\n// Specifies the type of transaction for XML requests\npub mod transaction_type {\n    pub const PAYMENT: &str = \"0\";\n    pub const PREAUTHORIZATION: &str = \"1\";\n    pub const CONFIRMATION: &str = \"2\";\n    pub const REFUND: &str = \"3\";\n    pub const CANCELLATION: &str = \"9\";\n}\n\npub struct RedsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub currency: api_models::enums::Currency,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T, api_models::enums::Currency)> for RedsysRouterData<T> {\n    fn from((amount, item, currency): (StringMinorUnit, T, api_models::enums::Currency)) -> Self {\n        Self {\n            amount,\n            currency,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub struct PaymentsRequest {\n    ds_merchant_amount: StringMinorUnit,\n    ds_merchant_currency: String,\n    ds_merchant_cvv2: Secret<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    ds_merchant_emv3ds: Option<EmvThreedsData>,\n    ds_merchant_expirydate: Secret<String>,\n    ds_merchant_merchantcode: Secret<String>,\n    ds_merchant_order: String,\n    ds_merchant_pan: cards::CardNumber,\n    ds_merchant_terminal: Secret<String>,\n    ds_merchant_transactiontype: RedsysTransactionType,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EmvThreedsData {\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    billing_data: Option<BillingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_accept_header: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_color_depth: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_i_p: Option<Secret<String, common_utils::pii::IpAddress>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_java_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_javascript_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_language: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_height: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_width: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_t_z: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_user_agent: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    cres: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    notification_u_r_l: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    protocol_version: Option<String>,\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    shipping_data: Option<ShippingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    three_d_s_comp_ind: Option<ThreeDSCompInd>,\n    three_d_s_info: RedsysThreeDsInfo,\n    #[serde(\n        alias = \"threeds_server_transaction_id\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    three_d_s_server_trans_i_d: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingData {\n    #[serde(skip_serializing_if = \"Option::is_none\")]",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for from",
    "code": "use std::str::FromStr;\n\nuse base64::Engine;\nuse common_enums::enums;\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    crypto::{EncodeMessage, SignMessage},\n    ext_traits::{Encode, ValueExt},\n    types::{SemanticVersion, StringMinorUnit},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    address::Address,\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::{\n        self, BrowserInformation, CompleteAuthorizeData, PaymentsAuthenticateData,\n        PaymentsAuthorizeData, PaymentsSyncData, ResponseId,\n    },\n    router_response_types::{PaymentsResponseData, RedirectForm, RefundsResponseData},\n    types::{\n        PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::errors;\nuse masking::{ExposeInterface, PeekInterface, Secret};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    types::{\n        PaymentsCancelResponseRouterData, PaymentsCaptureResponseRouterData,\n        PaymentsPreAuthenticateResponseRouterData, PaymentsPreprocessingResponseRouterData,\n        RefundsResponseRouterData, ResponseRouterData,\n    },\n    utils::{\n        self as connector_utils, missing_field_err, AddressDetailsData, BrowserInformationData,\n        CardData, ForeignTryFrom, PaymentsAuthenticateRequestData, PaymentsAuthorizeRequestData,\n        PaymentsCompleteAuthorizeRequestData, PaymentsPreAuthenticateRequestData,\n        PaymentsPreProcessingRequestData, RouterData as _,\n    },\n};\ntype Error = error_stack::Report<errors::ConnectorError>;\n\nconst DS_VERSION: &str = \"0.0\";\nconst SIGNATURE_VERSION: &str = \"HMAC_SHA256_V1\";\nconst XMLNS_WEB_URL: &str = \"http://webservices.apl02.redsys.es\";\npub const REDSYS_SOAP_ACTION: &str = \"consultaOperaciones\";\n\n// Specifies the type of transaction for XML requests\npub mod transaction_type {\n    pub const PAYMENT: &str = \"0\";\n    pub const PREAUTHORIZATION: &str = \"1\";\n    pub const CONFIRMATION: &str = \"2\";\n    pub const REFUND: &str = \"3\";\n    pub const CANCELLATION: &str = \"9\";\n}\n\npub struct RedsysRouterData<T> {\n    pub amount: StringMinorUnit,\n    pub currency: api_models::enums::Currency,\n    pub router_data: T,\n}\n\nimpl<T> From<(StringMinorUnit, T, api_models::enums::Currency)> for RedsysRouterData<T> {\n    fn from((amount, item, currency): (StringMinorUnit, T, api_models::enums::Currency)) -> Self {\n        Self {\n            amount,\n            currency,\n            router_data: item,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub struct PaymentsRequest {\n    ds_merchant_amount: StringMinorUnit,\n    ds_merchant_currency: String,\n    ds_merchant_cvv2: Secret<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    ds_merchant_emv3ds: Option<EmvThreedsData>,\n    ds_merchant_expirydate: Secret<String>,\n    ds_merchant_merchantcode: Secret<String>,\n    ds_merchant_order: String,\n    ds_merchant_pan: cards::CardNumber,\n    ds_merchant_terminal: Secret<String>,\n    ds_merchant_transactiontype: RedsysTransactionType,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct EmvThreedsData {\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    billing_data: Option<BillingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_accept_header: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_color_depth: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_i_p: Option<Secret<String, common_utils::pii::IpAddress>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_java_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_javascript_enabled: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_language: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_height: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_screen_width: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_t_z: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    browser_user_agent: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    cres: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    notification_u_r_l: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    protocol_version: Option<String>,\n    #[serde(flatten, skip_serializing_if = \"Option::is_none\")]\n    shipping_data: Option<ShippingData>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    three_d_s_comp_ind: Option<ThreeDSCompInd>,\n    three_d_s_info: RedsysThreeDsInfo,\n    #[serde(\n        alias = \"threeds_server_transaction_id\",\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    three_d_s_server_trans_i_d: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct BillingData {\n    #[serde(skip_serializing_if = \"Option::is_none\")]",
    "function_name": "from",
    "file": "crates__hyperswitch_connectors__src__connectors__redsys__transformers.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__hyperswitch_connectors__src__connectors__stripe.rs",
    "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{\n    CallConnectorAction, CaptureMethod, PaymentAction, PaymentChargeType, PaymentMethodType,\n    PaymentResourceUpdateStatus, StripeChargeType,\n};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt as _, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, CreateConnectorCustomer, Evidence, Execute,\n        IncrementalAuthorization, PSync, PaymentMethodToken, RSync, Retrieve, Session,\n        SetupMandate, UpdateMetadata, Upload, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, RetrieveFileRequestData, SetupMandateRequestData,\n        SplitRefundsRequest, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n        SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoCancel, PoCreate, PoFulfill, PoRecipient, PoRecipientAccount},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCancelType, PayoutCreateType, PayoutFulfillType, PayoutRecipientAccountType,\n    PayoutRecipientType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::SubmitEvidence,\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentIncrementalAuthorization,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        ConnectorCustomerType, IncrementalAuthorizationType, PaymentsAuthorizeType,\n        PaymentsCaptureType, PaymentsSyncType, PaymentsUpdateMetadataType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response, RetrieveFileType, SubmitEvidenceType,\n        TokenizationType, UploadFileType,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask as _, Maskable, PeekInterface};\nuse router_env::{instrument, tracing};\nuse stripe::auth_headers;\n\nuse self::transformers as stripe;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as OtherPayoutsData, RouterData as OtherRouterData};\nuse crate::{\n    connectors::stripe::transformers::get_stripe_compatible_connect_account_header,\n    constants::headers::{AUTHORIZATION, CONTENT_TYPE, STRIPE_COMPATIBLE_CONNECT_ACCOUNT},\n    types::{\n        ResponseRouterData, RetrieveFileRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    utils::{\n        self, get_authorise_integrity_object, get_capture_integrity_object,\n        get_refund_integrity_object, get_sync_integrity_object, PaymentMethodDataType,\n        RefundsRequestData as OtherRefundsRequestData,\n    },\n};\n#[derive(Clone)]\npub struct Stripe {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n    amount_converter_webhooks: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Stripe {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Stripe\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            CONTENT_TYPE.to_string(),\n            Self::common_get_content_type(self).to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Stripe {\n    fn id(&self) -> &'static str {\n        \"stripe\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__stripe.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__hyperswitch_connectors__src__connectors__stripe.rs",
    "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{\n    CallConnectorAction, CaptureMethod, PaymentAction, PaymentChargeType, PaymentMethodType,\n    PaymentResourceUpdateStatus, StripeChargeType,\n};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt as _, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, CreateConnectorCustomer, Evidence, Execute,\n        IncrementalAuthorization, PSync, PaymentMethodToken, RSync, Retrieve, Session,\n        SetupMandate, UpdateMetadata, Upload, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, RetrieveFileRequestData, SetupMandateRequestData,\n        SplitRefundsRequest, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n        SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoCancel, PoCreate, PoFulfill, PoRecipient, PoRecipientAccount},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCancelType, PayoutCreateType, PayoutFulfillType, PayoutRecipientAccountType,\n    PayoutRecipientType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::SubmitEvidence,\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentIncrementalAuthorization,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        ConnectorCustomerType, IncrementalAuthorizationType, PaymentsAuthorizeType,\n        PaymentsCaptureType, PaymentsSyncType, PaymentsUpdateMetadataType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response, RetrieveFileType, SubmitEvidenceType,\n        TokenizationType, UploadFileType,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask as _, Maskable, PeekInterface};\nuse router_env::{instrument, tracing};\nuse stripe::auth_headers;\n\nuse self::transformers as stripe;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as OtherPayoutsData, RouterData as OtherRouterData};\nuse crate::{\n    connectors::stripe::transformers::get_stripe_compatible_connect_account_header,\n    constants::headers::{AUTHORIZATION, CONTENT_TYPE, STRIPE_COMPATIBLE_CONNECT_ACCOUNT},\n    types::{\n        ResponseRouterData, RetrieveFileRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    utils::{\n        self, get_authorise_integrity_object, get_capture_integrity_object,\n        get_refund_integrity_object, get_sync_integrity_object, PaymentMethodDataType,\n        RefundsRequestData as OtherRefundsRequestData,\n    },\n};\n#[derive(Clone)]\npub struct Stripe {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n    amount_converter_webhooks: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Stripe {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Stripe\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            CONTENT_TYPE.to_string(),\n            Self::common_get_content_type(self).to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Stripe {\n    fn id(&self) -> &'static str {\n        \"stripe\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__stripe.rs",
    "source": "local_corpus"
  },
  {
    "query": "implementation for build_headers",
    "code": "pub mod transformers;\n\nuse std::{collections::HashMap, sync::LazyLock};\n\nuse api_models::webhooks::IncomingWebhookEvent;\nuse common_enums::{\n    CallConnectorAction, CaptureMethod, PaymentAction, PaymentChargeType, PaymentMethodType,\n    PaymentResourceUpdateStatus, StripeChargeType,\n};\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::{ByteSliceExt as _, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{\n        AmountConvertor, MinorUnit, MinorUnitForConnector, StringMinorUnit,\n        StringMinorUnitForConnector,\n    },\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        AccessTokenAuth, Authorize, Capture, CreateConnectorCustomer, Evidence, Execute,\n        IncrementalAuthorization, PSync, PaymentMethodToken, RSync, Retrieve, Session,\n        SetupMandate, UpdateMetadata, Upload, Void,\n    },\n    router_request_types::{\n        AccessTokenRequestData, ConnectorCustomerData, PaymentMethodTokenizationData,\n        PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData,\n        PaymentsIncrementalAuthorizationData, PaymentsSessionData, PaymentsSyncData,\n        PaymentsUpdateMetadataData, RefundsData, RetrieveFileRequestData, SetupMandateRequestData,\n        SplitRefundsRequest, SubmitEvidenceRequestData, UploadFileRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        RetrieveFileResponse, SubmitEvidenceResponse, SupportedPaymentMethods,\n        SupportedPaymentMethodsExt, UploadFileResponse,\n    },\n    types::{\n        ConnectorCustomerRouterData, PaymentsAuthorizeRouterData, PaymentsCancelRouterData,\n        PaymentsCaptureRouterData, PaymentsIncrementalAuthorizationRouterData,\n        PaymentsSyncRouterData, PaymentsUpdateMetadataRouterData, RefundsRouterData,\n        TokenizationRouterData,\n    },\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::{PoCancel, PoCreate, PoFulfill, PoRecipient, PoRecipientAccount},\n    types::{PayoutsData, PayoutsResponseData, PayoutsRouterData},\n};\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_interfaces::types::{\n    PayoutCancelType, PayoutCreateType, PayoutFulfillType, PayoutRecipientAccountType,\n    PayoutRecipientType,\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self,\n        disputes::SubmitEvidence,\n        files::{FilePurpose, FileUpload, RetrieveFile, UploadFile},\n        ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorRedirectResponse,\n        ConnectorSpecifications, ConnectorValidation, PaymentIncrementalAuthorization,\n    },\n    configs::Connectors,\n    consts::{NO_ERROR_CODE, NO_ERROR_MESSAGE},\n    disputes::DisputePayload,\n    errors::ConnectorError,\n    events::connector_api_logs::ConnectorEvent,\n    types::{\n        ConnectorCustomerType, IncrementalAuthorizationType, PaymentsAuthorizeType,\n        PaymentsCaptureType, PaymentsSyncType, PaymentsUpdateMetadataType, PaymentsVoidType,\n        RefundExecuteType, RefundSyncType, Response, RetrieveFileType, SubmitEvidenceType,\n        TokenizationType, UploadFileType,\n    },\n    webhooks::{IncomingWebhook, IncomingWebhookRequestDetails, WebhookContext},\n};\nuse masking::{Mask as _, Maskable, PeekInterface};\nuse router_env::{instrument, tracing};\nuse stripe::auth_headers;\n\nuse self::transformers as stripe;\n#[cfg(feature = \"payouts\")]\nuse crate::utils::{PayoutsData as OtherPayoutsData, RouterData as OtherRouterData};\nuse crate::{\n    connectors::stripe::transformers::get_stripe_compatible_connect_account_header,\n    constants::headers::{AUTHORIZATION, CONTENT_TYPE, STRIPE_COMPATIBLE_CONNECT_ACCOUNT},\n    types::{\n        ResponseRouterData, RetrieveFileRouterData, SubmitEvidenceRouterData, UploadFileRouterData,\n    },\n    utils::{\n        self, get_authorise_integrity_object, get_capture_integrity_object,\n        get_refund_integrity_object, get_sync_integrity_object, PaymentMethodDataType,\n        RefundsRequestData as OtherRefundsRequestData,\n    },\n};\n#[derive(Clone)]\npub struct Stripe {\n    amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),\n    amount_converter_webhooks: &'static (dyn AmountConvertor<Output = StringMinorUnit> + Sync),\n}\n\nimpl Stripe {\n    pub const fn new() -> &'static Self {\n        &Self {\n            amount_converter: &MinorUnitForConnector,\n            amount_converter_webhooks: &StringMinorUnitForConnector,\n        }\n    }\n}\n\nimpl<Flow, Request, Response> ConnectorCommonExt<Flow, Request, Response> for Stripe\nwhere\n    Self: ConnectorIntegration<Flow, Request, Response>,\n{\n    fn build_headers(\n        &self,\n        req: &RouterData<Flow, Request, Response>,\n        _connectors: &Connectors,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let mut header = vec![(\n            CONTENT_TYPE.to_string(),\n            Self::common_get_content_type(self).to_string().into(),\n        )];\n        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n        header.append(&mut api_key);\n        Ok(header)\n    }\n}\n\nimpl ConnectorCommon for Stripe {\n    fn id(&self) -> &'static str {\n        \"stripe\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n",
    "function_name": "build_headers",
    "file": "crates__hyperswitch_connectors__src__connectors__stripe.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__api_models__src__payment_methods.rs",
    "code": "use std::collections::{HashMap, HashSet};\n#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse cards::CardNumber;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableName;\nuse common_utils::{\n    consts::SURCHARGE_PERCENTAGE_PRECISION_LENGTH,\n    errors,\n    ext_traits::OptionExt,\n    id_type, link_utils, pii,\n    types::{MinorUnit, Percentage, Surcharge},\n};\nuse masking::PeekInterface;\nuse serde::de;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::BankCodeResponse;\n#[cfg(feature = \"payouts\")]\nuse crate::payouts;\nuse crate::{admin, enums as api_enums, open_router, payments};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodCreate {\n    /// The type of payment method use for the payment.\n    #[schema(value_type = PaymentMethod,example = \"card\")]\n    pub payment_method: Option<api_enums::PaymentMethod>,\n\n    /// This is a sub-category of payment method.\n    #[schema(value_type = Option<PaymentMethodType>,example = \"credit\")]\n    pub payment_method_type: Option<api_enums::PaymentMethodType>,\n\n    /// The name of the bank/ provider issuing the payment method to the end user\n    #[schema(example = \"Citibank\")]\n    pub payment_method_issuer: Option<String>,\n\n    /// A standard code representing the issuer of payment method\n    #[schema(value_type = Option<PaymentMethodIssuerCode>,example = \"jp_applepay\")]\n    pub payment_method_issuer_code: Option<api_enums::PaymentMethodIssuerCode>,\n\n    /// Card Details\n    #[schema(example = json!({\n    \"card_number\": \"4111111145551142\",\n    \"card_exp_month\": \"10\",\n    \"card_exp_year\": \"25\",\n    \"card_holder_name\": \"John Doe\"}))]\n    pub card: Option<CardDetail>,\n\n    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.\n    #[schema(value_type = Option<Object>,example = json!({ \"city\": \"NY\", \"unit\": \"245\" }))]\n    pub metadata: Option<pii::SecretSerdeValue>,\n\n    /// The unique identifier of the customer.\n    #[schema(value_type = Option<String>, max_length = 64, min_length = 1, example = \"cus_y3oqhf46pyzuxjbcn2giaqnb44\")]\n    pub customer_id: Option<id_type::CustomerId>,\n\n    /// The card network\n    #[schema(example = \"Visa\")]\n    pub card_network: Option<String>,\n\n    /// Payment method details from locker\n    #[cfg(feature = \"payouts\")]\n    #[schema(value_type = Option<Bank>)]\n    pub bank_transfer: Option<payouts::Bank>,\n\n    /// Payment method details from locker\n    #[cfg(feature = \"payouts\")]\n    #[schema(value_type = Option<Wallet>)]\n    pub wallet: Option<payouts::Wallet>,\n\n    /// For Client based calls, SDK will use the client_secret\n    /// in order to call /payment_methods\n    /// Client secret will be generated whenever a new\n    /// payment method is created\n    pub client_secret: Option<String>,\n\n    /// Payment method data to be passed in case of client\n    /// based flow\n    pub payment_method_data: Option<PaymentMethodCreateData>,\n\n    /// The billing details of the payment method\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<payments::Address>,\n\n    #[serde(skip_deserializing)]\n    /// The connector mandate details of the payment method, this is added only for cards migration\n    /// api and is skipped during deserialization of the payment method create request as this\n    /// it should not be passed in the request\n    pub connector_mandate_details: Option<PaymentsMandateReference>,\n\n    #[serde(skip_deserializing)]\n    /// The transaction id of a CIT (customer initiated transaction) associated with the payment method,\n    /// this is added only for cards migration api and is skipped during deserialization of the\n    /// payment method create request as it should not be passed in the request\n    pub network_transaction_id: Option<String>,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodRetrieveRequest {\n    #[serde(default)]\n    pub fetch_raw_detail: bool,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodCreate {\n    /// The type of payment method use for the payment.\n    #[schema(value_type = PaymentMethod,example = \"card\")]\n    pub payment_method_type: api_enums::PaymentMethod,\n\n    /// This is a sub-category of payment method.\n    #[schema(value_type = Option<PaymentMethodType>,example = \"credit\")]\n    pub payment_method_subtype: Option<api_enums::PaymentMethodType>,\n\n    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.\n    #[schema(value_type = Option<Object>,example = json!({ \"city\": \"NY\", \"unit\": \"245\" }))]\n    pub metadata: Option<pii::SecretSerdeValue>,\n\n    /// The unique identifier of the customer.\n    #[schema(\n        min_length = 32,\n        max_length = 64,\n        example = \"12345_cus_01926c58bc6e77c09e809964e72af8c8\",\n        value_type = String\n    )]\n    pub customer_id: Option<id_type::GlobalCustomerId>,\n\n    /// Payment method data to be passed\n    pub payment_method_data: PaymentMethodCreateData,\n\n    /// The billing details of the payment method\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<payments::Address>,",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "where is logic implemented in crates__api_models__src__payment_methods.rs",
    "code": "use std::collections::{HashMap, HashSet};\n#[cfg(feature = \"v2\")]\nuse std::str::FromStr;\n\nuse cards::CardNumber;\n#[cfg(feature = \"v1\")]\nuse common_utils::crypto::OptionalEncryptableName;\nuse common_utils::{\n    consts::SURCHARGE_PERCENTAGE_PRECISION_LENGTH,\n    errors,\n    ext_traits::OptionExt,\n    id_type, link_utils, pii,\n    types::{MinorUnit, Percentage, Surcharge},\n};\nuse masking::PeekInterface;\nuse serde::de;\nuse utoipa::ToSchema;\n\n#[cfg(feature = \"v1\")]\nuse crate::payments::BankCodeResponse;\n#[cfg(feature = \"payouts\")]\nuse crate::payouts;\nuse crate::{admin, enums as api_enums, open_router, payments};\n\n#[cfg(feature = \"v1\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodCreate {\n    /// The type of payment method use for the payment.\n    #[schema(value_type = PaymentMethod,example = \"card\")]\n    pub payment_method: Option<api_enums::PaymentMethod>,\n\n    /// This is a sub-category of payment method.\n    #[schema(value_type = Option<PaymentMethodType>,example = \"credit\")]\n    pub payment_method_type: Option<api_enums::PaymentMethodType>,\n\n    /// The name of the bank/ provider issuing the payment method to the end user\n    #[schema(example = \"Citibank\")]\n    pub payment_method_issuer: Option<String>,\n\n    /// A standard code representing the issuer of payment method\n    #[schema(value_type = Option<PaymentMethodIssuerCode>,example = \"jp_applepay\")]\n    pub payment_method_issuer_code: Option<api_enums::PaymentMethodIssuerCode>,\n\n    /// Card Details\n    #[schema(example = json!({\n    \"card_number\": \"4111111145551142\",\n    \"card_exp_month\": \"10\",\n    \"card_exp_year\": \"25\",\n    \"card_holder_name\": \"John Doe\"}))]\n    pub card: Option<CardDetail>,\n\n    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.\n    #[schema(value_type = Option<Object>,example = json!({ \"city\": \"NY\", \"unit\": \"245\" }))]\n    pub metadata: Option<pii::SecretSerdeValue>,\n\n    /// The unique identifier of the customer.\n    #[schema(value_type = Option<String>, max_length = 64, min_length = 1, example = \"cus_y3oqhf46pyzuxjbcn2giaqnb44\")]\n    pub customer_id: Option<id_type::CustomerId>,\n\n    /// The card network\n    #[schema(example = \"Visa\")]\n    pub card_network: Option<String>,\n\n    /// Payment method details from locker\n    #[cfg(feature = \"payouts\")]\n    #[schema(value_type = Option<Bank>)]\n    pub bank_transfer: Option<payouts::Bank>,\n\n    /// Payment method details from locker\n    #[cfg(feature = \"payouts\")]\n    #[schema(value_type = Option<Wallet>)]\n    pub wallet: Option<payouts::Wallet>,\n\n    /// For Client based calls, SDK will use the client_secret\n    /// in order to call /payment_methods\n    /// Client secret will be generated whenever a new\n    /// payment method is created\n    pub client_secret: Option<String>,\n\n    /// Payment method data to be passed in case of client\n    /// based flow\n    pub payment_method_data: Option<PaymentMethodCreateData>,\n\n    /// The billing details of the payment method\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<payments::Address>,\n\n    #[serde(skip_deserializing)]\n    /// The connector mandate details of the payment method, this is added only for cards migration\n    /// api and is skipped during deserialization of the payment method create request as this\n    /// it should not be passed in the request\n    pub connector_mandate_details: Option<PaymentsMandateReference>,\n\n    #[serde(skip_deserializing)]\n    /// The transaction id of a CIT (customer initiated transaction) associated with the payment method,\n    /// this is added only for cards migration api and is skipped during deserialization of the\n    /// payment method create request as it should not be passed in the request\n    pub network_transaction_id: Option<String>,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodRetrieveRequest {\n    #[serde(default)]\n    pub fetch_raw_detail: bool,\n}\n\n#[cfg(feature = \"v2\")]\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]\n#[serde(deny_unknown_fields)]\npub struct PaymentMethodCreate {\n    /// The type of payment method use for the payment.\n    #[schema(value_type = PaymentMethod,example = \"card\")]\n    pub payment_method_type: api_enums::PaymentMethod,\n\n    /// This is a sub-category of payment method.\n    #[schema(value_type = Option<PaymentMethodType>,example = \"credit\")]\n    pub payment_method_subtype: Option<api_enums::PaymentMethodType>,\n\n    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.\n    #[schema(value_type = Option<Object>,example = json!({ \"city\": \"NY\", \"unit\": \"245\" }))]\n    pub metadata: Option<pii::SecretSerdeValue>,\n\n    /// The unique identifier of the customer.\n    #[schema(\n        min_length = 32,\n        max_length = 64,\n        example = \"12345_cus_01926c58bc6e77c09e809964e72af8c8\",\n        value_type = String\n    )]\n    pub customer_id: Option<id_type::GlobalCustomerId>,\n\n    /// Payment method data to be passed\n    pub payment_method_data: PaymentMethodCreateData,\n\n    /// The billing details of the payment method\n    #[schema(value_type = Option<Address>)]\n    pub billing: Option<payments::Address>,",
    "function_name": "unknown_symbol",
    "file": "crates__api_models__src__payment_methods.rs",
    "source": "local_corpus"
  },
  {
    "query": "Code from crates__router__src__core__webhooks__incoming.rs",
    "code": "use std::{str::FromStr, time::Instant};\n\nuse actix_web::FromRequest;\n#[cfg(feature = \"payouts\")]\nuse api_models::payouts as payout_models;\nuse api_models::{\n    enums::Connector,\n    webhooks::{self, WebhookResponseTracker},\n};\npub use common_enums::{connector_enums::InvoiceStatus, enums::ProcessTrackerRunner};\nuse common_utils::{\n    errors::ReportSwitchExt,\n    events::ApiEventsType,\n    ext_traits::{AsyncExt, ByteSliceExt},\n    types::{AmountConvertor, StringMinorUnitForConnector},\n};\nuse diesel_models::{refund as diesel_refund, ConnectorMandateReferenceId};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_connectors::connectors::unified_authentication_service::transformers::WebhookResponse;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::payouts::payouts::PayoutsUpdate;\nuse hyperswitch_domain_models::{\n    mandates::CommonMandateReference,\n    payments::{payment_attempt::PaymentAttempt, HeaderPayload},\n    router_request_types::{\n        unified_authentication_service::UasAuthenticationResponseData,\n        VerifyWebhookSourceRequestData,\n    },\n    router_response_types::{VerifyWebhookSourceResponseData, VerifyWebhookStatus},\n};\nuse hyperswitch_interfaces::webhooks::{\n    IncomingWebhookFlowError, IncomingWebhookRequestDetails, WebhookContext, WebhookResourceData,\n};\nuse masking::{ExposeInterface, PeekInterface};\nuse router_env::{instrument, tracing, RequestId};\nuse unified_connector_service_client::payments as payments_grpc;\n\nuse super::{types, utils, MERCHANT_ID};\nuse crate::{\n    consts,\n    core::{\n        api_locking,\n        errors::{self, ConnectorErrorExt, CustomResult, RouterResponse, StorageErrorExt},\n        metrics, payment_methods,\n        payment_methods::cards,\n        payments::{self, tokenization, PaymentIntentStateMetadataExt},\n        refunds, relay,\n        unified_authentication_service::{\n            types::UNIFIED_AUTHENTICATION_SERVICE, utils as uas_utils,\n        },\n        unified_connector_service, utils as core_utils,\n        webhooks::{network_tokenization_incoming, utils::construct_webhook_router_data},\n    },\n    events::api_logs::ApiEvent,\n    logger,\n    routes::{\n        app::{ReqState, SessionStateInfo},\n        lock_utils, SessionState,\n    },\n    services::{\n        self, authentication as auth, connector_integration_interface::ConnectorEnum,\n        ConnectorValidation,\n    },\n    types::{\n        api::{\n            self, mandates::MandateResponseExt, ConnectorCommon, ConnectorData, GetToken,\n            IncomingWebhook,\n        },\n        domain,\n        storage::{self, enums},\n        transformers::{ForeignFrom, ForeignInto, ForeignTryFrom},\n    },\n    utils::{self as helper_utils, ext_traits::OptionExt, generate_id},\n};\n#[cfg(feature = \"payouts\")]\nuse crate::{core::payouts, types::storage::PayoutAttemptUpdate};\n\n#[allow(clippy::too_many_arguments)]\npub async fn incoming_webhooks_wrapper<W: types::OutgoingWebhookType>(\n    flow: &impl router_env::types::FlowMetric,\n    state: SessionState,\n    req_state: ReqState,\n    req: &actix_web::HttpRequest,\n    platform: domain::Platform,\n    connector_name_or_mca_id: &str,\n    body: actix_web::web::Bytes,\n    is_relay_webhook: bool,\n) -> RouterResponse<serde_json::Value> {\n    let start_instant = Instant::now();\n    let (application_response, webhooks_response_tracker, serialized_req) =\n        Box::pin(incoming_webhooks_core::<W>(\n            state.clone(),\n            req_state,\n            req,\n            platform.clone(),\n            connector_name_or_mca_id,\n            body.clone(),\n            is_relay_webhook,\n        ))\n        .await?;\n\n    logger::info!(incoming_webhook_payload = ?serialized_req);\n\n    let request_duration = Instant::now()\n        .saturating_duration_since(start_instant)\n        .as_millis();\n\n    let request_id = RequestId::extract(req)\n        .await\n        .attach_printable(\"Unable to extract request id from request\")\n        .change_context(errors::ApiErrorResponse::InternalServerError)?;\n    let auth_type = auth::AuthenticationType::WebhookAuth {\n        merchant_id: platform.get_processor().get_account().get_id().clone(),\n    };\n    let status_code = 200;\n    let api_event = ApiEventsType::Webhooks {\n        connector: connector_name_or_mca_id.to_string(),\n        payment_id: webhooks_response_tracker.get_payment_id(),\n        refund_id: webhooks_response_tracker.get_refund_id(),\n    };\n    let response_value = serde_json::to_value(&webhooks_response_tracker)\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Could not convert webhook effect to string\")?;\n    let infra = state.infra_components.clone();\n    let api_event = ApiEvent::new(\n        state.tenant.tenant_id.clone(),\n        Some(platform.get_processor().get_account().get_id().clone()),\n        flow,\n        &request_id,\n        request_duration,\n        status_code,\n        serialized_req,\n        Some(response_value),\n        None,\n        auth_type,\n        None,\n        api_event,\n        req,\n        req.method(),\n        infra,",
    "function_name": "incoming_webhooks_wrapper",
    "file": "crates__router__src__core__webhooks__incoming.rs",
    "source": "local_corpus"
  }
]