[
  {
    "query": "function that returns typing.generator[request, response, none]",
    "code": "    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n        if self._last_challenge:\n            request.headers[\"Authorization\"] = self._build_auth_header(\n                request, self._last_challenge\n            )\n\n        response = yield request\n\n        if response.status_code != 401 or \"www-authenticate\" not in response.headers:\n            # If the response is not a 401 then we don't\n            # need to build an authenticated request.\n            return\n\n        for auth_header in response.headers.get_list(\"www-authenticate\"):\n            if auth_header.lower().startswith(\"digest \"):\n                break\n        else:\n            # If the response does not include a 'WWW-Authenticate: Digest ...'\n            # header, then we don't need to build an authenticated request.\n            return\n\n        self._last_challenge = self._parse_challenge(request, response, auth_header)\n        self._nonce_count = 1\n\n        request.headers[\"Authorization\"] = self._build_auth_header(\n            request, self._last_challenge\n        )\n        if response.cookies:\n            Cookies(response.cookies).set_cookie_header(request=request)\n        yield request",
    "function_name": "auth_flow",
    "file": "httpx/_auth.py",
    "num_lines": 30
  },
  {
    "query": "find the function for test url set",
    "code": "def test_url_set():\n    \"\"\"\n    Ensure that `httpx.URL` instances can be used in sets.\n    \"\"\"\n    urls = (\n        httpx.URL(\"http://example.org:123/path/to/somewhere\"),\n        httpx.URL(\"http://example.org:123/path/to/somewhere/else\"),\n    )\n\n    url_set = set(urls)\n\n    assert all(url in urls for url in url_set)",
    "function_name": "test_url_set",
    "file": "tests/models/test_url.py",
    "num_lines": 12
  },
  {
    "query": "function that returns none",
    "code": "def test_multipart_encode_unicode_file_contents() -> None:\n    url = \"https://www.example.com/\"\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n    files = {\"file\": (\"name.txt\", b\"<bytes content>\")}\n\n    request = httpx.Request(\"POST\", url, headers=headers, files=files)\n    request.read()\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n        \"Content-Length\": str(len(request.content)),\n    }\n    assert request.content == (\n        b'--BOUNDARY\\r\\nContent-Disposition: form-data; name=\"file\";'\n        b' filename=\"name.txt\"\\r\\n'\n        b\"Content-Type: text/plain\\r\\n\\r\\n<bytes content>\\r\\n\"\n        b\"--BOUNDARY--\\r\\n\"\n    )",
    "function_name": "test_multipart_encode_unicode_file_contents",
    "file": "tests/test_multipart.py",
    "num_lines": 19
  },
  {
    "query": "function that takes url: URL | str",
    "code": "def delete(\n    url: URL | str,\n    *,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    verify: ssl.SSLContext | str | bool = True,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `DELETE` request.\n\n    **Parameters**: See `httpx.request`.\n\n    Note that the `data`, `files`, `json` and `content` parameters are not available\n    on this function, as `DELETE` requests should not include a request body.\n    \"\"\"\n    return request(\n        \"DELETE\",\n        url,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "delete",
    "file": "httpx/_api.py",
    "num_lines": 34
  },
  {
    "query": "test override content length header in tests models test requests",
    "code": "def test_override_content_length_header():\n    async def streaming_body(data: bytes) -> typing.AsyncIterator[bytes]:\n        yield data  # pragma: no cover\n\n    data = streaming_body(b\"test 123\")\n    headers = {\"Content-Length\": \"8\"}\n\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data, headers=headers)\n    assert request.headers[\"Content-Length\"] == \"8\"",
    "function_name": "test_override_content_length_header",
    "file": "tests/models/test_requests.py",
    "num_lines": 9
  },
  {
    "query": "ensure that invalid types on `httpx.url()` raise a `typeerror`",
    "code": "def test_url_invalid_type():\n    \"\"\"\n    Ensure that invalid types on `httpx.URL()` raise a `TypeError`.\n    \"\"\"\n\n    class ExternalURLClass:  # representing external URL class\n        pass\n\n    with pytest.raises(TypeError):\n        httpx.URL(ExternalURLClass())  # type: ignore",
    "function_name": "test_url_invalid_type",
    "file": "tests/models/test_url.py",
    "num_lines": 10
  },
  {
    "query": "test redirect 303 in tests client test redirects",
    "code": "def test_redirect_303():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    response = client.get(\"https://example.org/redirect_303\", follow_redirects=True)\n    assert response.status_code == httpx.codes.OK\n    assert response.url == \"https://example.org/\"\n    assert len(response.history) == 1",
    "function_name": "test_redirect_303",
    "file": "tests/client/test_redirects.py",
    "num_lines": 6
  },
  {
    "query": "function that returns none",
    "code": "async def test_auth_hidden_header() -> None:\n    url = \"https://example.org/\"\n    auth = (\"example-username\", \"example-password\")\n    app = App()\n\n    async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n        response = await client.get(url, auth=auth)\n\n    assert \"'authorization': '[secure]'\" in str(response.request.headers)",
    "function_name": "test_auth_hidden_header",
    "file": "tests/client/test_auth.py",
    "num_lines": 9
  },
  {
    "query": "how does httpx test multipart data and files content?",
    "code": "async def test_multipart_data_and_files_content():\n    data = {\"message\": \"Hello, world!\"}\n    files = {\"file\": io.BytesIO(b\"<file content>\")}\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=+++\"}\n    request = httpx.Request(method, url, data=data, files=files, headers=headers)\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Length\": \"210\",\n        \"Content-Type\": \"multipart/form-data; boundary=+++\",\n    }\n    assert sync_content == b\"\".join(\n        [\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"message\"\\r\\n',\n            b\"\\r\\n\",\n            b\"Hello, world!\\r\\n\",\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n            b\"Content-Type: application/octet-stream\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--+++--\\r\\n\",\n        ]\n    )\n    assert async_content == b\"\".join(\n        [\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"message\"\\r\\n',\n            b\"\\r\\n\",\n            b\"Hello, world!\\r\\n\",\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n            b\"Content-Type: application/octet-stream\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--+++--\\r\\n\",\n        ]\n    )",
    "function_name": "test_multipart_data_and_files_content",
    "file": "tests/test_content.py",
    "num_lines": 44
  },
  {
    "query": "looking for the code that test value error without request",
    "code": "def test_value_error_without_request(header_value):\n    headers = [(b\"Content-Encoding\", header_value)]\n    broken_compressed_body = b\"xxxxxxxxxxxxxx\"\n    with pytest.raises(httpx.DecodingError):\n        httpx.Response(200, headers=headers, content=broken_compressed_body)",
    "function_name": "test_value_error_without_request",
    "file": "tests/models/test_responses.py",
    "num_lines": 5
  },
  {
    "query": "how to returns a decoder instance which can be used to decode the raw byte",
    "code": "    def _get_content_decoder(self) -> ContentDecoder:\n        \"\"\"\n        Returns a decoder instance which can be used to decode the raw byte\n        content, depending on the Content-Encoding used in the response.\n        \"\"\"\n        if not hasattr(self, \"_decoder\"):\n            decoders: list[ContentDecoder] = []\n            values = self.headers.get_list(\"content-encoding\", split_commas=True)\n            for value in values:\n                value = value.strip().lower()\n                try:\n                    decoder_cls = SUPPORTED_DECODERS[value]\n                    decoders.append(decoder_cls())\n                except KeyError:\n                    continue\n\n            if len(decoders) == 1:\n                self._decoder = decoders[0]\n            elif len(decoders) > 1:\n                self._decoder = MultiDecoder(children=decoders)\n            else:\n                self._decoder = IdentityDecoder()\n\n        return self._decoder",
    "function_name": "_get_content_decoder",
    "file": "httpx/_models.py",
    "num_lines": 24
  },
  {
    "query": "show me how to multi items",
    "code": "    def multi_items(self) -> list[tuple[str, str]]:\n        \"\"\"\n        Return a list of `(key, value)` pairs of headers. Allow multiple\n        occurrences of the same key without concatenating into a single\n        comma separated value.\n        \"\"\"\n        return [\n            (key.decode(self.encoding), value.decode(self.encoding))\n            for _, key, value in self._list\n        ]",
    "function_name": "multi_items",
    "file": "httpx/_models.py",
    "num_lines": 10
  },
  {
    "query": "request test picklable",
    "code": "def test_request_picklable():\n    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n    pickle_request = pickle.loads(pickle.dumps(request))\n    assert pickle_request.method == \"POST\"\n    assert pickle_request.url.path == \"/\"\n    assert pickle_request.headers[\"Content-Type\"] == \"application/json\"\n    assert pickle_request.content == b'{\"test\":123}'\n    assert pickle_request.stream is not None\n    assert request.headers == {\n        \"Host\": \"example.org\",\n        \"Content-Type\": \"application/json\",\n        \"content-length\": \"12\",\n    }",
    "function_name": "test_request_picklable",
    "file": "tests/models/test_requests.py",
    "num_lines": 13
  },
  {
    "query": "function that returns httpx.response",
    "code": "    def challenge_send(self, request: httpx.Request) -> httpx.Response:\n        self._response_count += 1\n        nonce = (\n            hashlib.sha256(os.urandom(8)).hexdigest()\n            if self._regenerate_nonce\n            else \"ee96edced2a0b43e4869e96ebe27563f369c1205a049d06419bb51d8aeddf3d3\"\n        )\n        challenge_data = {\n            \"nonce\": nonce,\n            \"qop\": self.qop,\n            \"opaque\": (\n                \"ee6378f3ee14ebfd2fff54b70a91a7c9390518047f242ab2271380db0e14bda1\"\n            ),\n            \"algorithm\": self.algorithm,\n            \"stale\": \"FALSE\",\n        }\n        challenge_str = \", \".join(\n            '{}=\"{}\"'.format(key, value)\n            for key, value in challenge_data.items()\n            if value\n        )\n\n        headers = {\n            \"www-authenticate\": f'Digest realm=\"httpx@example.org\", {challenge_str}',\n        }\n        return httpx.Response(401, headers=headers)",
    "function_name": "challenge_send",
    "file": "tests/client/test_auth.py",
    "num_lines": 26
  },
  {
    "query": "how to handles encoding the given `content`, `data`, `files`, and `json`,",
    "code": "def encode_request(\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: Any | None = None,\n    boundary: bytes | None = None,\n) -> tuple[dict[str, str], SyncByteStream | AsyncByteStream]:\n    \"\"\"\n    Handles encoding the given `content`, `data`, `files`, and `json`,\n    returning a two-tuple of (<headers>, <stream>).\n    \"\"\"\n    if data is not None and not isinstance(data, Mapping):\n        # We prefer to separate `content=<bytes|str|byte iterator|bytes aiterator>`\n        # for raw request content, and `data=<form data>` for url encoded or\n        # multipart form content.\n        #\n        # However for compat with requests, we *do* still support\n        # `data=<bytes...>` usages. We deal with that case here, treating it\n        # as if `content=<...>` had been supplied instead.\n        message = \"Use 'content=<...>' to upload raw bytes/text content.\"\n        warnings.warn(message, DeprecationWarning, stacklevel=2)\n        return encode_content(data)\n\n    if content is not None:\n        return encode_content(content)\n    elif files:\n        return encode_multipart_data(data or {}, files, boundary)\n    elif data:\n        return encode_urlencoded_data(data)\n    elif json is not None:\n        return encode_json(json)\n\n    return {}, ByteStream(b\"\")",
    "function_name": "encode_request",
    "file": "httpx/_content.py",
    "num_lines": 33
  },
  {
    "query": "show me how to test redirect 303",
    "code": "def test_redirect_303():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    response = client.get(\"https://example.org/redirect_303\", follow_redirects=True)\n    assert response.status_code == httpx.codes.OK\n    assert response.url == \"https://example.org/\"\n    assert len(response.history) == 1",
    "function_name": "test_redirect_303",
    "file": "tests/client/test_redirects.py",
    "num_lines": 6
  },
  {
    "query": "test url eq str in tests models test url",
    "code": "def test_url_eq_str():\n    \"\"\"\n    Ensure that `httpx.URL` supports the equality operator.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/path/to/somewhere?abc=123#anchor\")\n    assert url == \"https://example.org:123/path/to/somewhere?abc=123#anchor\"\n    assert str(url) == url",
    "function_name": "test_url_eq_str",
    "file": "tests/models/test_url.py",
    "num_lines": 7
  },
  {
    "query": "test request async streaming content picklable in tests models test requests",
    "code": "async def test_request_async_streaming_content_picklable():\n    async def streaming_body(data: bytes) -> typing.AsyncIterator[bytes]:\n        yield data\n\n    data = streaming_body(b\"test 123\")\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n    pickle_request = pickle.loads(pickle.dumps(request))\n    with pytest.raises(httpx.RequestNotRead):\n        pickle_request.content  # noqa: B018\n    with pytest.raises(httpx.StreamClosed):\n        await pickle_request.aread()\n\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n    await request.aread()\n    pickle_request = pickle.loads(pickle.dumps(request))\n    assert pickle_request.content == b\"test 123\"",
    "function_name": "test_request_async_streaming_content_picklable",
    "file": "tests/models/test_requests.py",
    "num_lines": 16
  },
  {
    "query": "test unknown status code in tests models test responses",
    "code": "def test_unknown_status_code():\n    response = httpx.Response(\n        600,\n    )\n    assert response.status_code == 600\n    assert response.reason_phrase == \"\"\n    assert response.text == \"\"",
    "function_name": "test_unknown_status_code",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "test build request in tests client test async client",
    "code": "async def test_build_request(server):\n    url = server.url.copy_with(path=\"/echo_headers\")\n    headers = {\"Custom-header\": \"value\"}\n    async with httpx.AsyncClient() as client:\n        request = client.build_request(\"GET\", url)\n        request.headers.update(headers)\n        response = await client.send(request)\n\n    assert response.status_code == 200\n    assert response.url == url\n\n    assert response.json()[\"Custom-header\"] == \"value\"",
    "function_name": "test_build_request",
    "file": "tests/client/test_async_client.py",
    "num_lines": 12
  },
  {
    "query": "read and return the request content",
    "code": "    def read(self) -> bytes:\n        \"\"\"\n        Read and return the request content.\n        \"\"\"\n        if not hasattr(self, \"_content\"):\n            assert isinstance(self.stream, typing.Iterable)\n            self._content = b\"\".join(self.stream)\n            if not isinstance(self.stream, ByteStream):\n                # If a streaming request has been read entirely into memory, then\n                # we can replace the stream with a raw bytes implementation,\n                # to ensure that any non-replayable streams can still be used.\n                self.stream = ByteStream(self._content)\n        return self._content",
    "function_name": "read",
    "file": "httpx/_models.py",
    "num_lines": 13
  },
  {
    "query": "what function handles test client event hooks?",
    "code": "def test_client_event_hooks():\n    def on_request(request):\n        pass  # pragma: no cover\n\n    client = httpx.Client()\n    client.event_hooks = {\"request\": [on_request]}\n    assert client.event_hooks == {\"request\": [on_request], \"response\": []}",
    "function_name": "test_client_event_hooks",
    "file": "tests/client/test_properties.py",
    "num_lines": 7
  },
  {
    "query": "test cookies with domain in tests models test cookies",
    "code": "def test_cookies_with_domain():\n    cookies = httpx.Cookies()\n    cookies.set(\"name\", \"value\", domain=\"example.com\")\n    cookies.set(\"name\", \"value\", domain=\"example.org\")\n\n    with pytest.raises(httpx.CookieConflict):\n        cookies[\"name\"]\n\n    cookies.clear(domain=\"example.com\")\n    assert len(cookies) == 1",
    "function_name": "test_cookies_with_domain",
    "file": "tests/models/test_cookies.py",
    "num_lines": 10
  },
  {
    "query": "function that takes server",
    "code": "async def test_read_timeout(server):\n    timeout = httpx.Timeout(None, read=1e-6)\n\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        with pytest.raises(httpx.ReadTimeout):\n            await client.get(server.url.copy_with(path=\"/slow_response\"))",
    "function_name": "test_read_timeout",
    "file": "tests/test_timeouts.py",
    "num_lines": 6
  },
  {
    "query": "how to ensure that invalid types on `httpx.url()` raise a `typeerror`",
    "code": "def test_url_invalid_type():\n    \"\"\"\n    Ensure that invalid types on `httpx.URL()` raise a `TypeError`.\n    \"\"\"\n\n    class ExternalURLClass:  # representing external URL class\n        pass\n\n    with pytest.raises(TypeError):\n        httpx.URL(ExternalURLClass())  # type: ignore",
    "function_name": "test_url_invalid_type",
    "file": "tests/models/test_url.py",
    "num_lines": 10
  },
  {
    "query": "test post json in tests client test client",
    "code": "def test_post_json(server):\n    with httpx.Client() as client:\n        response = client.post(server.url, json={\"text\": \"Hello, world!\"})\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"",
    "function_name": "test_post_json",
    "file": "tests/client/test_client.py",
    "num_lines": 5
  },
  {
    "query": "code to test aiter text",
    "code": "async def test_aiter_text():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = \"\"\n    async for part in response.aiter_text():\n        content += part\n    assert content == \"Hello, world!\"",
    "function_name": "test_aiter_text",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "bytes userinfo",
    "code": "    def userinfo(self) -> bytes:\n        \"\"\"\n        The URL userinfo as a raw bytestring.\n        For example: b\"jo%40email.com:a%20secret\".\n        \"\"\"\n        return self._uri_reference.userinfo.encode(\"ascii\")",
    "function_name": "userinfo",
    "file": "httpx/_urls.py",
    "num_lines": 6
  },
  {
    "query": "how to the complete url path and query string as raw bytes",
    "code": "    def raw_path(self) -> bytes:\n        \"\"\"\n        The complete URL path and query string as raw bytes.\n        Used as the target when constructing HTTP requests.\n\n        For example:\n\n        GET /users?search=some%20text HTTP/1.1\n        Host: www.example.org\n        Connection: close\n        \"\"\"\n        path = self._uri_reference.path or \"/\"\n        if self._uri_reference.query is not None:\n            path += \"?\" + self._uri_reference.query\n        return path.encode(\"ascii\")",
    "function_name": "raw_path",
    "file": "httpx/_urls.py",
    "num_lines": 15
  },
  {
    "query": "urlencoded test list",
    "code": "async def test_urlencoded_list():\n    request = httpx.Request(method, url, data={\"example\": [\"a\", 1, True]})\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Length\": \"32\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n    }\n    assert sync_content == b\"example=a&example=1&example=true\"\n    assert async_content == b\"example=a&example=1&example=true\"",
    "function_name": "test_urlencoded_list",
    "file": "tests/test_content.py",
    "num_lines": 15
  },
  {
    "query": "function that takes server",
    "code": "def test_post_json(server):\n    with httpx.Client() as client:\n        response = client.post(server.url, json={\"text\": \"Hello, world!\"})\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"",
    "function_name": "test_post_json",
    "file": "tests/client/test_client.py",
    "num_lines": 5
  },
  {
    "query": "typing.iterator iter str",
    "code": "    def iter_lines(self) -> typing.Iterator[str]:\n        decoder = LineDecoder()\n        with request_context(request=self._request):\n            for text in self.iter_text():\n                for line in decoder.decode(text):\n                    yield line\n            for line in decoder.flush():\n                yield line",
    "function_name": "iter_lines",
    "file": "httpx/_models.py",
    "num_lines": 8
  },
  {
    "query": "function that returns typing.iterator[str]",
    "code": "    def iter_lines(self) -> typing.Iterator[str]:\n        decoder = LineDecoder()\n        with request_context(request=self._request):\n            for text in self.iter_text():\n                for line in decoder.decode(text):\n                    yield line\n            for line in decoder.flush():\n                yield line",
    "function_name": "iter_lines",
    "file": "httpx/_models.py",
    "num_lines": 8
  },
  {
    "query": "how to a property which is `true` for 4xx and 5xx status codes, `false` otherwise",
    "code": "    def is_error(self) -> bool:\n        \"\"\"\n        A property which is `True` for 4xx and 5xx status codes, `False` otherwise.\n        \"\"\"\n        return codes.is_error(self.status_code)",
    "function_name": "is_error",
    "file": "httpx/_models.py",
    "num_lines": 5
  },
  {
    "query": "param url manipulation",
    "code": "def test_url_set_param_manipulation():\n    \"\"\"\n    Some basic URL query parameter manipulation.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/?a=123\")\n    assert url.copy_set_param(\"a\", \"456\") == \"https://example.org:123/?a=456\"",
    "function_name": "test_url_set_param_manipulation",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "subclasses can override this method to release any network resources",
    "code": "    def close(self) -> None:\n        \"\"\"\n        Subclasses can override this method to release any network resources\n        after a request/response cycle is complete.\n        \"\"\"",
    "function_name": "close",
    "file": "httpx/_types.py",
    "num_lines": 5
  },
  {
    "query": "ipv6 copy with",
    "code": "def test_ipv6_url_copy_with_host(url_str, new_host):\n    url = httpx.URL(url_str).copy_with(host=new_host)\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]:1234\"\n    assert str(url) == \"http://[::ffff:192.168.0.1]:1234\"",
    "function_name": "test_ipv6_url_copy_with_host",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "test client base url in tests client test properties",
    "code": "def test_client_base_url():\n    client = httpx.Client()\n    client.base_url = \"https://www.example.org/\"\n    assert isinstance(client.base_url, httpx.URL)\n    assert client.base_url == \"https://www.example.org/\"",
    "function_name": "test_client_base_url",
    "file": "tests/client/test_properties.py",
    "num_lines": 5
  },
  {
    "query": "encoding using text",
    "code": "def test_response_decode_text_using_explicit_encoding():\n    # Ensure that a 'default_encoding=\"...\"' on the response is used for text decoding\n    # when no \"Content-Type: text/plain; charset=...\"\" info is present.\n    #\n    # Here we have some french text encoded with Windows-1252, rather than UTF-8.\n    # https://en.wikipedia.org/wiki/Windows-1252\n    text = (\n        \"Non-seulement Despr\u00e9aux ne se trompait pas, mais de tous les \u00e9crivains \"\n        \"que la France a produits, sans excepter Voltaire lui-m\u00eame, impr\u00e9gn\u00e9 de \"\n        \"l'esprit anglais par son s\u00e9jour \u00e0 Londres, c'est incontestablement \"\n        \"Moli\u00e8re ou Poquelin qui reproduit avec l'exactitude la plus vive et la \"\n        \"plus compl\u00e8te le fond du g\u00e9nie fran\u00e7ais.\"\n    )\n    content = text.encode(\"cp1252\")\n    response = httpx.Response(200, content=content, default_encoding=\"cp1252\")\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.encoding == \"cp1252\"\n    assert response.text == text",
    "function_name": "test_response_decode_text_using_explicit_encoding",
    "file": "tests/models/test_responses.py",
    "num_lines": 20
  },
  {
    "query": "none exc info response",
    "code": "        def start_response(\n            status: str,\n            response_headers: list[tuple[str, str]],\n            exc_info: OptExcInfo | None = None,\n        ) -> typing.Callable[[bytes], typing.Any]:\n            nonlocal seen_status, seen_response_headers, seen_exc_info\n            seen_status = status\n            seen_response_headers = response_headers\n            seen_exc_info = exc_info\n            return lambda _: None",
    "function_name": "start_response",
    "file": "httpx/_transports/wsgi.py",
    "num_lines": 10
  },
  {
    "query": "read server timeout",
    "code": "async def test_read_timeout(server):\n    timeout = httpx.Timeout(None, read=1e-6)\n\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        with pytest.raises(httpx.ReadTimeout):\n            await client.get(server.url.copy_with(path=\"/slow_response\"))",
    "function_name": "test_read_timeout",
    "file": "tests/test_timeouts.py",
    "num_lines": 6
  },
  {
    "query": "test queryparams are",
    "code": "def test_queryparams_are_hashable():\n    params = (\n        httpx.QueryParams(\"a=123\"),\n        httpx.QueryParams({\"a\": 123}),\n        httpx.QueryParams(\"b=456\"),\n        httpx.QueryParams({\"b\": 456}),\n    )\n\n    assert len(set(params)) == 2",
    "function_name": "test_queryparams_are_hashable",
    "file": "tests/models/test_queryparams.py",
    "num_lines": 9
  },
  {
    "query": "test load ssl config verify existing file in tests test config",
    "code": "def test_load_ssl_config_verify_existing_file():\n    context = httpx.create_ssl_context()\n    context.load_verify_locations(capath=certifi.where())\n    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n    assert context.check_hostname is True",
    "function_name": "test_load_ssl_config_verify_existing_file",
    "file": "tests/test_config.py",
    "num_lines": 5
  },
  {
    "query": "looking for the code that test proxy with mounts",
    "code": "def test_proxy_with_mounts():\n    proxy_transport = httpx.HTTPTransport(proxy=\"http://127.0.0.1\")\n    client = httpx.Client(mounts={\"http://\": proxy_transport})\n\n    transport = client._transport_for_url(httpx.URL(\"http://example.com\"))\n    assert transport == proxy_transport",
    "function_name": "test_proxy_with_mounts",
    "file": "tests/client/test_proxies.py",
    "num_lines": 6
  },
  {
    "query": "how does httpx test multipart file tuple?",
    "code": "def test_multipart_file_tuple():\n    client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n\n    # Test with a list of values 'data' argument,\n    #     and a tuple style 'files' argument.\n    data = {\"text\": [\"abc\"]}\n    files = {\"file\": (\"name.txt\", io.BytesIO(b\"<file content>\"))}\n    response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n    boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n    boundary_bytes = boundary.encode(\"ascii\")\n\n    assert response.status_code == 200\n    assert response.content == b\"\".join(\n        [\n            b\"--\" + boundary_bytes + b\"\\r\\n\",\n            b'Content-Disposition: form-data; name=\"text\"\\r\\n',\n            b\"\\r\\n\",\n            b\"abc\\r\\n\",\n            b\"--\" + boundary_bytes + b\"\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"name.txt\"\\r\\n',\n            b\"Content-Type: text/plain\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--\" + boundary_bytes + b\"--\\r\\n\",\n        ]\n    )",
    "function_name": "test_multipart_file_tuple",
    "file": "tests/test_multipart.py",
    "num_lines": 26
  },
  {
    "query": "test multipart encode unicode file contents in tests test multipart",
    "code": "def test_multipart_encode_unicode_file_contents() -> None:\n    url = \"https://www.example.com/\"\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n    files = {\"file\": (\"name.txt\", b\"<bytes content>\")}\n\n    request = httpx.Request(\"POST\", url, headers=headers, files=files)\n    request.read()\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n        \"Content-Length\": str(len(request.content)),\n    }\n    assert request.content == (\n        b'--BOUNDARY\\r\\nContent-Disposition: form-data; name=\"file\";'\n        b' filename=\"name.txt\"\\r\\n'\n        b\"Content-Type: text/plain\\r\\n\\r\\n<bytes content>\\r\\n\"\n        b\"--BOUNDARY--\\r\\n\"\n    )",
    "function_name": "test_multipart_encode_unicode_file_contents",
    "file": "tests/test_multipart.py",
    "num_lines": 19
  },
  {
    "query": "how to returns a list of parsed link headers, for more info see:",
    "code": "def _parse_header_links(value: str) -> list[dict[str, str]]:\n    \"\"\"\n    Returns a list of parsed link headers, for more info see:\n    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link\n    The generic syntax of those is:\n    Link: < uri-reference >; param1=value1; param2=\"value2\"\n    So for instance:\n    Link; '<http:/.../front.jpeg>; type=\"image/jpeg\",<http://.../back.jpeg>;'\n    would return\n        [\n            {\"url\": \"http:/.../front.jpeg\", \"type\": \"image/jpeg\"},\n            {\"url\": \"http://.../back.jpeg\"},\n        ]\n    :param value: HTTP Link entity-header field\n    :return: list of parsed link headers\n    \"\"\"\n    links: list[dict[str, str]] = []\n    replace_chars = \" '\\\"\"\n    value = value.strip(replace_chars)\n    if not value:\n        return links\n    for val in re.split(\", *<\", value):\n        try:\n            url, params = val.split(\";\", 1)\n        except ValueError:\n            url, params = val, \"\"\n        link = {\"url\": url.strip(\"<> '\\\"\")}\n        for param in params.split(\";\"):\n            try:\n                key, value = param.split(\"=\")\n            except ValueError:\n                break\n            link[key.strip(replace_chars)] = value.strip(replace_chars)\n        links.append(link)\n    return links",
    "function_name": "_parse_header_links",
    "file": "httpx/_models.py",
    "num_lines": 35
  },
  {
    "query": "function that returns none",
    "code": "        async def send(message: typing.MutableMapping[str, typing.Any]) -> None:\n            nonlocal status_code, response_headers, response_started\n\n            if message[\"type\"] == \"http.response.start\":\n                assert not response_started\n\n                status_code = message[\"status\"]\n                response_headers = message.get(\"headers\", [])\n                response_started = True\n\n            elif message[\"type\"] == \"http.response.body\":\n                assert not response_complete.is_set()\n                body = message.get(\"body\", b\"\")\n                more_body = message.get(\"more_body\", False)\n\n                if body and request.method != \"HEAD\":\n                    body_parts.append(body)\n\n                if not more_body:\n                    response_complete.set()",
    "function_name": "send",
    "file": "httpx/_transports/asgi.py",
    "num_lines": 20
  },
  {
    "query": "returns a decoder instance which can be used to decode the raw byte",
    "code": "    def _get_content_decoder(self) -> ContentDecoder:\n        \"\"\"\n        Returns a decoder instance which can be used to decode the raw byte\n        content, depending on the Content-Encoding used in the response.\n        \"\"\"\n        if not hasattr(self, \"_decoder\"):\n            decoders: list[ContentDecoder] = []\n            values = self.headers.get_list(\"content-encoding\", split_commas=True)\n            for value in values:\n                value = value.strip().lower()\n                try:\n                    decoder_cls = SUPPORTED_DECODERS[value]\n                    decoders.append(decoder_cls())\n                except KeyError:\n                    continue\n\n            if len(decoders) == 1:\n                self._decoder = decoders[0]\n            elif len(decoders) > 1:\n                self._decoder = MultiDecoder(children=decoders)\n            else:\n                self._decoder = IdentityDecoder()\n\n        return self._decoder",
    "function_name": "_get_content_decoder",
    "file": "httpx/_models.py",
    "num_lines": 24
  },
  {
    "query": "challenge httpx.response request",
    "code": "    def challenge_send(self, request: httpx.Request) -> httpx.Response:\n        self._response_count += 1\n        nonce = (\n            hashlib.sha256(os.urandom(8)).hexdigest()\n            if self._regenerate_nonce\n            else \"ee96edced2a0b43e4869e96ebe27563f369c1205a049d06419bb51d8aeddf3d3\"\n        )\n        challenge_data = {\n            \"nonce\": nonce,\n            \"qop\": self.qop,\n            \"opaque\": (\n                \"ee6378f3ee14ebfd2fff54b70a91a7c9390518047f242ab2271380db0e14bda1\"\n            ),\n            \"algorithm\": self.algorithm,\n            \"stale\": \"FALSE\",\n        }\n        challenge_str = \", \".join(\n            '{}=\"{}\"'.format(key, value)\n            for key, value in challenge_data.items()\n            if value\n        )\n\n        headers = {\n            \"www-authenticate\": f'Digest realm=\"httpx@example.org\", {challenge_str}',\n        }\n        return httpx.Response(401, headers=headers)",
    "function_name": "challenge_send",
    "file": "tests/client/test_auth.py",
    "num_lines": 26
  },
  {
    "query": "function that returns response",
    "code": "    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n        import httpcore\n\n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n            resp = self._pool.handle_request(req)\n\n        assert isinstance(resp.stream, typing.Iterable)\n\n        return Response(\n            status_code=resp.status,\n            headers=resp.headers,\n            stream=ResponseStream(resp.stream),\n            extensions=resp.extensions,\n        )",
    "function_name": "handle_request",
    "file": "httpx/_transports/default.py",
    "num_lines": 30
  },
  {
    "query": "primitive value to str in httpx  utils",
    "code": "def primitive_value_to_str(value: PrimitiveData) -> str:\n    \"\"\"\n    Coerce a primitive data type into a string value.\n\n    Note that we prefer JSON-style 'true'/'false' for boolean values here.\n    \"\"\"\n    if value is True:\n        return \"true\"\n    elif value is False:\n        return \"false\"\n    elif value is None:\n        return \"\"\n    return str(value)",
    "function_name": "primitive_value_to_str",
    "file": "httpx/_utils.py",
    "num_lines": 13
  },
  {
    "query": "test response",
    "code": "def test_response():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n        request=httpx.Request(\"GET\", \"https://example.org\"),\n    )\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.text == \"Hello, world!\"\n    assert response.request.method == \"GET\"\n    assert response.request.url == \"https://example.org\"\n    assert not response.is_error",
    "function_name": "test_response",
    "file": "tests/models/test_responses.py",
    "num_lines": 13
  },
  {
    "query": "upload test asgi",
    "code": "async def test_asgi_upload():\n    transport = httpx.ASGITransport(app=echo_body)\n    async with httpx.AsyncClient(transport=transport) as client:\n        response = await client.post(\"http://www.example.org/\", content=b\"example\")\n\n    assert response.status_code == 200\n    assert response.text == \"example\"",
    "function_name": "test_asgi_upload",
    "file": "tests/test_asgi.py",
    "num_lines": 7
  },
  {
    "query": "test queryparams are hashable in tests models test queryparams",
    "code": "def test_queryparams_are_hashable():\n    params = (\n        httpx.QueryParams(\"a=123\"),\n        httpx.QueryParams({\"a\": 123}),\n        httpx.QueryParams(\"b=456\"),\n        httpx.QueryParams({\"b\": 456}),\n    )\n\n    assert len(set(params)) == 2",
    "function_name": "test_queryparams_are_hashable",
    "file": "tests/models/test_queryparams.py",
    "num_lines": 9
  },
  {
    "query": "with cookies test httpx",
    "code": "def test_cookies_with_domain():\n    cookies = httpx.Cookies()\n    cookies.set(\"name\", \"value\", domain=\"example.com\")\n    cookies.set(\"name\", \"value\", domain=\"example.org\")\n\n    with pytest.raises(httpx.CookieConflict):\n        cookies[\"name\"]\n\n    cookies.clear(domain=\"example.com\")\n    assert len(cookies) == 1",
    "function_name": "test_cookies_with_domain",
    "file": "tests/models/test_cookies.py",
    "num_lines": 10
  },
  {
    "query": "a byte-iterator over the raw response content",
    "code": "    def iter_raw(self, chunk_size: int | None = None) -> typing.Iterator[bytes]:\n        \"\"\"\n        A byte-iterator over the raw response content.\n        \"\"\"\n        if self.is_stream_consumed:\n            raise StreamConsumed()\n        if self.is_closed:\n            raise StreamClosed()\n        if not isinstance(self.stream, SyncByteStream):\n            raise RuntimeError(\"Attempted to call a sync iterator on an async stream.\")\n\n        self.is_stream_consumed = True\n        self._num_bytes_downloaded = 0\n        chunker = ByteChunker(chunk_size=chunk_size)\n\n        with request_context(request=self._request):\n            for raw_stream_bytes in self.stream:\n                self._num_bytes_downloaded += len(raw_stream_bytes)\n                for chunk in chunker.decode(raw_stream_bytes):\n                    yield chunk\n\n        for chunk in chunker.flush():\n            yield chunk\n\n        self.close()",
    "function_name": "iter_raw",
    "file": "httpx/_models.py",
    "num_lines": 25
  },
  {
    "query": "sync test none",
    "code": "def test_sync_auth() -> None:\n    \"\"\"\n    Test that we can use an auth implementation specific to the sync case.\n    \"\"\"\n    url = \"https://example.org/\"\n    auth = SyncOrAsyncAuth()\n    app = App()\n\n    with httpx.Client(transport=httpx.MockTransport(app)) as client:\n        response = client.get(url, auth=auth)\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": \"sync-auth\"}",
    "function_name": "test_sync_auth",
    "file": "tests/client/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "how to close",
    "code": "    def close(self) -> None:\n        \"\"\"\n        Subclasses can override this method to release any network resources\n        after a request/response cycle is complete.\n        \"\"\"",
    "function_name": "close",
    "file": "httpx/_types.py",
    "num_lines": 5
  },
  {
    "query": "bytes streaming with",
    "code": "    def streaming_body_with_empty_chunks() -> typing.Iterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"\"\n        yield b\"world!\"\n        yield b\"\"",
    "function_name": "streaming_body_with_empty_chunks",
    "file": "tests/models/test_responses.py",
    "num_lines": 5
  },
  {
    "query": "the url userinfo as a raw bytestring",
    "code": "    def userinfo(self) -> bytes:\n        \"\"\"\n        The URL userinfo as a raw bytestring.\n        For example: b\"jo%40email.com:a%20secret\".\n        \"\"\"\n        return self._uri_reference.userinfo.encode(\"ascii\")",
    "function_name": "userinfo",
    "file": "httpx/_urls.py",
    "num_lines": 6
  },
  {
    "query": "test auth hidden header in tests client test auth",
    "code": "async def test_auth_hidden_header() -> None:\n    url = \"https://example.org/\"\n    auth = (\"example-username\", \"example-password\")\n    app = App()\n\n    async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n        response = await client.get(url, auth=auth)\n\n    assert \"'authorization': '[secure]'\" in str(response.request.headers)",
    "function_name": "test_auth_hidden_header",
    "file": "tests/client/test_auth.py",
    "num_lines": 9
  },
  {
    "query": "test line decoder crnl in tests test decoders",
    "code": "def test_line_decoder_crnl():\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\\r\\n\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\", b\"\\n\\r\\nb\\r\\nc\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    # Issue #1033\n    response = httpx.Response(200, content=[b\"\", b\"12345\\r\\n\", b\"foo bar baz\\r\\n\"])\n    assert list(response.iter_lines()) == [\"12345\", \"foo bar baz\"]",
    "function_name": "test_line_decoder_crnl",
    "file": "tests/test_decoders.py",
    "num_lines": 13
  },
  {
    "query": "function that returns httpx.response",
    "code": "def get_and_set_cookies(request: httpx.Request) -> httpx.Response:\n    if request.url.path == \"/echo_cookies\":\n        data = {\"cookies\": request.headers.get(\"cookie\")}\n        return httpx.Response(200, json=data)\n    elif request.url.path == \"/set_cookie\":\n        return httpx.Response(200, headers={\"set-cookie\": \"example-name=example-value\"})\n    else:\n        raise NotImplementedError()  # pragma: no cover",
    "function_name": "get_and_set_cookies",
    "file": "tests/client/test_cookies.py",
    "num_lines": 8
  },
  {
    "query": "function that takes sockets",
    "code": "    async def serve(self, sockets=None):\n        self.restart_requested = asyncio.Event()\n\n        loop = asyncio.get_event_loop()\n        tasks = {\n            loop.create_task(super().serve(sockets=sockets)),\n            loop.create_task(self.watch_restarts()),\n        }\n        await asyncio.wait(tasks)",
    "function_name": "serve",
    "file": "tests/conftest.py",
    "num_lines": 9
  },
  {
    "query": "value parse links",
    "code": "def _parse_header_links(value: str) -> list[dict[str, str]]:\n    \"\"\"\n    Returns a list of parsed link headers, for more info see:\n    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link\n    The generic syntax of those is:\n    Link: < uri-reference >; param1=value1; param2=\"value2\"\n    So for instance:\n    Link; '<http:/.../front.jpeg>; type=\"image/jpeg\",<http://.../back.jpeg>;'\n    would return\n        [\n            {\"url\": \"http:/.../front.jpeg\", \"type\": \"image/jpeg\"},\n            {\"url\": \"http://.../back.jpeg\"},\n        ]\n    :param value: HTTP Link entity-header field\n    :return: list of parsed link headers\n    \"\"\"\n    links: list[dict[str, str]] = []\n    replace_chars = \" '\\\"\"\n    value = value.strip(replace_chars)\n    if not value:\n        return links\n    for val in re.split(\", *<\", value):\n        try:\n            url, params = val.split(\";\", 1)\n        except ValueError:\n            url, params = val, \"\"\n        link = {\"url\": url.strip(\"<> '\\\"\")}\n        for param in params.split(\";\"):\n            try:\n                key, value = param.split(\"=\")\n            except ValueError:\n                break\n            link[key.strip(replace_chars)] = value.strip(replace_chars)\n        links.append(link)\n    return links",
    "function_name": "_parse_header_links",
    "file": "httpx/_models.py",
    "num_lines": 35
  },
  {
    "query": "test url copywith userinfo subcomponents in tests models test url",
    "code": "def test_url_copywith_userinfo_subcomponents():\n    copy_with_kwargs = {\n        \"username\": \"tom@example.org\",\n        \"password\": \"abc123@ %\",\n    }\n    url = httpx.URL(\"https://example.org\")\n    new = url.copy_with(**copy_with_kwargs)\n    assert str(new) == \"https://tom%40example.org:abc123%40%20%@example.org\"\n    assert new.username == \"tom@example.org\"\n    assert new.password == \"abc123@ %\"\n    assert new.userinfo == b\"tom%40example.org:abc123%40%20%\"",
    "function_name": "test_url_copywith_userinfo_subcomponents",
    "file": "tests/models/test_url.py",
    "num_lines": 11
  },
  {
    "query": "test client trust env in tests client test properties",
    "code": "def test_client_trust_env():\n    client = httpx.Client()\n    assert client.trust_env\n\n    client = httpx.Client(trust_env=False)\n    assert not client.trust_env",
    "function_name": "test_client_trust_env",
    "file": "tests/client/test_properties.py",
    "num_lines": 6
  },
  {
    "query": "302 redirect test python",
    "code": "def test_redirect_302():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    response = client.post(\"https://example.org/redirect_302\", follow_redirects=True)\n    assert response.status_code == httpx.codes.OK\n    assert response.url == \"https://example.org/\"\n    assert len(response.history) == 1",
    "function_name": "test_redirect_302",
    "file": "tests/client/test_redirects.py",
    "num_lines": 6
  },
  {
    "query": "function that takes hostname: str",
    "code": "def is_ipv4_hostname(hostname: str) -> bool:\n    try:\n        ipaddress.IPv4Address(hostname.split(\"/\")[0])\n    except Exception:\n        return False\n    return True",
    "function_name": "is_ipv4_hostname",
    "file": "httpx/_utils.py",
    "num_lines": 6
  },
  {
    "query": "with test event",
    "code": "def test_event_hooks_with_redirect():\n    \"\"\"\n    A redirect request should trigger additional 'request' and 'response' event hooks.\n    \"\"\"\n\n    events = []\n\n    def on_request(request):\n        events.append({\"event\": \"request\", \"headers\": dict(request.headers)})\n\n    def on_response(response):\n        events.append({\"event\": \"response\", \"headers\": dict(response.headers)})\n\n    event_hooks = {\"request\": [on_request], \"response\": [on_response]}\n\n    with httpx.Client(\n        event_hooks=event_hooks,\n        transport=httpx.MockTransport(app),\n        follow_redirects=True,\n    ) as http:\n        http.get(\"http://127.0.0.1:8000/redirect\", auth=(\"username\", \"password\"))\n\n    assert events == [\n        {\n            \"event\": \"request\",\n            \"headers\": {\n                \"host\": \"127.0.0.1:8000\",\n                \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n                \"accept\": \"*/*\",\n                \"accept-encoding\": \"gzip, deflate, br, zstd\",\n                \"connection\": \"keep-alive\",\n                \"authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            },\n        },\n        {\n            \"event\": \"response\",\n            \"headers\": {\"location\": \"/\", \"server\": \"testserver\"},\n        },\n        {\n            \"event\": \"request\",\n            \"headers\": {\n                \"host\": \"127.0.0.1:8000\",\n                \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n                \"accept\": \"*/*\",\n                \"accept-encoding\": \"gzip, deflate, br, zstd\",\n                \"connection\": \"keep-alive\",\n                \"authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            },\n        },\n        {\n            \"event\": \"response\",\n            \"headers\": {\"server\": \"testserver\"},\n        },\n    ]",
    "function_name": "test_event_hooks_with_redirect",
    "file": "tests/client/test_event_hooks.py",
    "num_lines": 54
  },
  {
    "query": "parse challenge in httpx  auth",
    "code": "    def _parse_challenge(\n        self, request: Request, response: Response, auth_header: str\n    ) -> _DigestAuthChallenge:\n        \"\"\"\n        Returns a challenge from a Digest WWW-Authenticate header.\n        These take the form of:\n        `Digest realm=\"realm@host.com\",qop=\"auth,auth-int\",nonce=\"abc\",opaque=\"xyz\"`\n        \"\"\"\n        scheme, _, fields = auth_header.partition(\" \")\n\n        # This method should only ever have been called with a Digest auth header.\n        assert scheme.lower() == \"digest\"\n\n        header_dict: dict[str, str] = {}\n        for field in parse_http_list(fields):\n            key, value = field.strip().split(\"=\", 1)\n            header_dict[key] = unquote(value)\n\n        try:\n            realm = header_dict[\"realm\"].encode()\n            nonce = header_dict[\"nonce\"].encode()\n            algorithm = header_dict.get(\"algorithm\", \"MD5\")\n            opaque = header_dict[\"opaque\"].encode() if \"opaque\" in header_dict else None\n            qop = header_dict[\"qop\"].encode() if \"qop\" in header_dict else None\n            return _DigestAuthChallenge(\n                realm=realm, nonce=nonce, algorithm=algorithm, opaque=opaque, qop=qop\n            )\n        except KeyError as exc:\n            message = \"Malformed Digest WWW-Authenticate header\"\n            raise ProtocolError(message, request=request) from exc",
    "function_name": "_parse_challenge",
    "file": "httpx/_auth.py",
    "num_lines": 30
  },
  {
    "query": "hello world send",
    "code": "async def hello_world(scope, receive, send):\n    status = 200\n    output = b\"Hello, World!\"\n    headers = [(b\"content-type\", \"text/plain\"), (b\"content-length\", str(len(output)))]\n\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n    await send({\"type\": \"http.response.body\", \"body\": output})",
    "function_name": "hello_world",
    "file": "tests/test_asgi.py",
    "num_lines": 7
  },
  {
    "query": "urlencoded test list python",
    "code": "async def test_urlencoded_list():\n    request = httpx.Request(method, url, data={\"example\": [\"a\", 1, True]})\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Length\": \"32\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n    }\n    assert sync_content == b\"example=a&example=1&example=true\"\n    assert async_content == b\"example=a&example=1&example=true\"",
    "function_name": "test_urlencoded_list",
    "file": "tests/test_content.py",
    "num_lines": 15
  },
  {
    "query": "zstd test",
    "code": "def test_zstd():\n    body = b\"test 123\"\n    compressed_body = zstd.compress(body)\n\n    headers = [(b\"Content-Encoding\", b\"zstd\")]\n    response = httpx.Response(\n        200,\n        headers=headers,\n        content=compressed_body,\n    )\n    assert response.content == body",
    "function_name": "test_zstd",
    "file": "tests/test_decoders.py",
    "num_lines": 11
  },
  {
    "query": "how to ensure that `httpx.url` supports the equality operator",
    "code": "def test_url_eq_str():\n    \"\"\"\n    Ensure that `httpx.URL` supports the equality operator.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/path/to/somewhere?abc=123#anchor\")\n    assert url == \"https://example.org:123/path/to/somewhere?abc=123#anchor\"\n    assert str(url) == url",
    "function_name": "test_url_eq_str",
    "file": "tests/models/test_url.py",
    "num_lines": 7
  },
  {
    "query": "test aiterator content in tests test content",
    "code": "async def test_aiterator_content():\n    async def hello_world() -> typing.AsyncIterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"world!\"\n\n    request = httpx.Request(method, url, content=hello_world())\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"\n\n    with pytest.raises(httpx.StreamConsumed):\n        [part async for part in request.stream]\n\n    # Support 'data' for compat with requests.\n    with pytest.warns(DeprecationWarning):\n        request = httpx.Request(method, url, data=hello_world())  # type: ignore\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiterator_content",
    "file": "tests/test_content.py",
    "num_lines": 33
  },
  {
    "query": "function that returns typing.iterator[tuple[typing.anystr, typing.anystr]]",
    "code": "def _obfuscate_sensitive_headers(\n    items: typing.Iterable[tuple[typing.AnyStr, typing.AnyStr]],\n) -> typing.Iterator[tuple[typing.AnyStr, typing.AnyStr]]:\n    for k, v in items:\n        if to_str(k.lower()) in SENSITIVE_HEADERS:\n            v = to_bytes_or_str(\"[secure]\", match_type_of=v)\n        yield k, v",
    "function_name": "_obfuscate_sensitive_headers",
    "file": "httpx/_models.py",
    "num_lines": 7
  },
  {
    "query": "test text decoder empty cases in tests test decoders",
    "code": "def test_text_decoder_empty_cases():\n    response = httpx.Response(200, content=b\"\")\n    assert response.text == \"\"\n\n    response = httpx.Response(200, content=[b\"\"])\n    response.read()\n    assert response.text == \"\"",
    "function_name": "test_text_decoder_empty_cases",
    "file": "tests/test_decoders.py",
    "num_lines": 7
  },
  {
    "query": "function that returns bytes | none",
    "code": "def get_multipart_boundary_from_content_type(\n    content_type: bytes | None,\n) -> bytes | None:\n    if not content_type or not content_type.startswith(b\"multipart/form-data\"):\n        return None\n    # parse boundary according to\n    # https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n    if b\";\" in content_type:\n        for section in content_type.split(b\";\"):\n            if section.strip().lower().startswith(b\"boundary=\"):\n                return section.strip()[len(b\"boundary=\") :].strip(b'\"')\n    return None",
    "function_name": "get_multipart_boundary_from_content_type",
    "file": "httpx/_multipart.py",
    "num_lines": 12
  },
  {
    "query": "how does httpx test unknown status code?",
    "code": "def test_unknown_status_code():\n    response = httpx.Response(\n        600,\n    )\n    assert response.status_code == 600\n    assert response.reason_phrase == \"\"\n    assert response.text == \"\"",
    "function_name": "test_unknown_status_code",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "bytes read httpx",
    "code": "    def read(self) -> bytes:\n        \"\"\"\n        Read and return the request content.\n        \"\"\"\n        if not hasattr(self, \"_content\"):\n            assert isinstance(self.stream, typing.Iterable)\n            self._content = b\"\".join(self.stream)\n            if not isinstance(self.stream, ByteStream):\n                # If a streaming request has been read entirely into memory, then\n                # we can replace the stream with a raw bytes implementation,\n                # to ensure that any non-replayable streams can still be used.\n                self.stream = ByteStream(self._content)\n        return self._content",
    "function_name": "read",
    "file": "httpx/_models.py",
    "num_lines": 13
  },
  {
    "query": "test zstd in tests test decoders",
    "code": "def test_zstd():\n    body = b\"test 123\"\n    compressed_body = zstd.compress(body)\n\n    headers = [(b\"Content-Encoding\", b\"zstd\")]\n    response = httpx.Response(\n        200,\n        headers=headers,\n        content=compressed_body,\n    )\n    assert response.content == body",
    "function_name": "test_zstd",
    "file": "tests/test_decoders.py",
    "num_lines": 11
  },
  {
    "query": "how to challenge send using httpx?",
    "code": "    def challenge_send(self, request: httpx.Request) -> httpx.Response:\n        self._response_count += 1\n        nonce = (\n            hashlib.sha256(os.urandom(8)).hexdigest()\n            if self._regenerate_nonce\n            else \"ee96edced2a0b43e4869e96ebe27563f369c1205a049d06419bb51d8aeddf3d3\"\n        )\n        challenge_data = {\n            \"nonce\": nonce,\n            \"qop\": self.qop,\n            \"opaque\": (\n                \"ee6378f3ee14ebfd2fff54b70a91a7c9390518047f242ab2271380db0e14bda1\"\n            ),\n            \"algorithm\": self.algorithm,\n            \"stale\": \"FALSE\",\n        }\n        challenge_str = \", \".join(\n            '{}=\"{}\"'.format(key, value)\n            for key, value in challenge_data.items()\n            if value\n        )\n\n        headers = {\n            \"www-authenticate\": f'Digest realm=\"httpx@example.org\", {challenge_str}',\n        }\n        return httpx.Response(401, headers=headers)",
    "function_name": "challenge_send",
    "file": "tests/client/test_auth.py",
    "num_lines": 26
  },
  {
    "query": "mounts with proxy",
    "code": "def test_proxy_with_mounts():\n    proxy_transport = httpx.HTTPTransport(proxy=\"http://127.0.0.1\")\n    client = httpx.Client(mounts={\"http://\": proxy_transport})\n\n    transport = client._transport_for_url(httpx.URL(\"http://example.com\"))\n    assert transport == proxy_transport",
    "function_name": "test_proxy_with_mounts",
    "file": "tests/client/test_proxies.py",
    "num_lines": 6
  },
  {
    "query": "code to test ipv6 url from raw url",
    "code": "def test_ipv6_url_from_raw_url(host):\n    url = httpx.URL(scheme=\"https\", host=host, port=443, path=\"/\")\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]\"\n    assert str(url) == \"https://[::ffff:192.168.0.1]/\"",
    "function_name": "test_ipv6_url_from_raw_url",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "find the function for test ipv6 url copy with host",
    "code": "def test_ipv6_url_copy_with_host(url_str, new_host):\n    url = httpx.URL(url_str).copy_with(host=new_host)\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]:1234\"\n    assert str(url) == \"http://[::ffff:192.168.0.1]:1234\"",
    "function_name": "test_ipv6_url_copy_with_host",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "response request handle",
    "code": "    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n        import httpcore\n\n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n            resp = self._pool.handle_request(req)\n\n        assert isinstance(resp.stream, typing.Iterable)\n\n        return Response(\n            status_code=resp.status,\n            headers=resp.headers,\n            stream=ResponseStream(resp.stream),\n            extensions=resp.extensions,\n        )",
    "function_name": "handle_request",
    "file": "httpx/_transports/default.py",
    "num_lines": 30
  },
  {
    "query": "function that takes scope and receive",
    "code": "async def echo_headers(scope, receive, send):\n    status = 200\n    output = json.dumps(\n        {\"headers\": [[k.decode(), v.decode()] for k, v in scope[\"headers\"]]}\n    ).encode(\"utf-8\")\n    headers = [(b\"content-type\", \"text/plain\"), (b\"content-length\", str(len(output)))]\n\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n    await send({\"type\": \"http.response.body\", \"body\": output})",
    "function_name": "echo_headers",
    "file": "tests/test_asgi.py",
    "num_lines": 9
  },
  {
    "query": "where is the flush logic?",
    "code": "    def flush(self) -> list[bytes]:\n        value = self._buffer.getvalue()\n        self._buffer.seek(0)\n        self._buffer.truncate()\n        return [value] if value else []",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "help test",
    "code": "def test_help():\n    runner = CliRunner()\n    result = runner.invoke(httpx.main, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"A next generation HTTP client.\" in result.output",
    "function_name": "test_help",
    "file": "tests/test_main.py",
    "num_lines": 5
  },
  {
    "query": "test async event hooks raising exception in tests client test event hooks",
    "code": "async def test_async_event_hooks_raising_exception():\n    async def raise_on_4xx_5xx(response):\n        response.raise_for_status()\n\n    event_hooks = {\"response\": [raise_on_4xx_5xx]}\n\n    async with httpx.AsyncClient(\n        event_hooks=event_hooks, transport=httpx.MockTransport(app)\n    ) as http:\n        try:\n            await http.get(\"http://127.0.0.1:8000/status/400\")\n        except httpx.HTTPStatusError as exc:\n            assert exc.response.is_closed",
    "function_name": "test_async_event_hooks_raising_exception",
    "file": "tests/client/test_event_hooks.py",
    "num_lines": 13
  },
  {
    "query": "show me how to test url set param manipulation",
    "code": "def test_url_set_param_manipulation():\n    \"\"\"\n    Some basic URL query parameter manipulation.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/?a=123\")\n    assert url.copy_set_param(\"a\", \"456\") == \"https://example.org:123/?a=456\"",
    "function_name": "test_url_set_param_manipulation",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "test queryparams source",
    "code": "def test_queryparams(source):\n    q = httpx.QueryParams(source)\n    assert \"a\" in q\n    assert \"A\" not in q\n    assert \"c\" not in q\n    assert q[\"a\"] == \"123\"\n    assert q.get(\"a\") == \"123\"\n    assert q.get(\"nope\", default=None) is None\n    assert q.get_list(\"a\") == [\"123\", \"456\"]\n\n    assert list(q.keys()) == [\"a\", \"b\"]\n    assert list(q.values()) == [\"123\", \"789\"]\n    assert list(q.items()) == [(\"a\", \"123\"), (\"b\", \"789\")]\n    assert len(q) == 2\n    assert list(q) == [\"a\", \"b\"]\n    assert dict(q) == {\"a\": \"123\", \"b\": \"789\"}\n    assert str(q) == \"a=123&a=456&b=789\"\n    assert repr(q) == \"QueryParams('a=123&a=456&b=789')\"\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        [(\"a\", \"123\"), (\"b\", \"456\")]\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        \"a=123&b=456\"\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        {\"b\": \"456\", \"a\": \"123\"}\n    )\n    assert httpx.QueryParams() == httpx.QueryParams({})\n    assert httpx.QueryParams([(\"a\", \"123\"), (\"a\", \"456\")]) == httpx.QueryParams(\n        \"a=123&a=456\"\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) != \"invalid\"\n\n    q = httpx.QueryParams([(\"a\", \"123\"), (\"a\", \"456\")])\n    assert httpx.QueryParams(q) == q",
    "function_name": "test_queryparams",
    "file": "tests/models/test_queryparams.py",
    "num_lines": 35
  },
  {
    "query": "function that returns typing.keysview[str]",
    "code": "    def keys(self) -> typing.KeysView[str]:\n        \"\"\"\n        Return all the keys in the query params.\n\n        Usage:\n\n        q = httpx.QueryParams(\"a=123&a=456&b=789\")\n        assert list(q.keys()) == [\"a\", \"b\"]\n        \"\"\"\n        return self._dict.keys()",
    "function_name": "keys",
    "file": "httpx/_urls.py",
    "num_lines": 10
  },
  {
    "query": "looking for the code that test override content length header",
    "code": "def test_override_content_length_header():\n    async def streaming_body(data: bytes) -> typing.AsyncIterator[bytes]:\n        yield data  # pragma: no cover\n\n    data = streaming_body(b\"test 123\")\n    headers = {\"Content-Length\": \"8\"}\n\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data, headers=headers)\n    assert request.headers[\"Content-Length\"] == \"8\"",
    "function_name": "test_override_content_length_header",
    "file": "tests/models/test_requests.py",
    "num_lines": 9
  },
  {
    "query": "test headers none python",
    "code": "def test_multipart_headers_include_content_type() -> None:\n    \"\"\"\n    Content-Type from 4th tuple parameter (headers) should\n    override the 3rd parameter (content_type)\n    \"\"\"\n    file_name = \"test.txt\"\n    file_content = io.BytesIO(b\"<file content>\")\n    file_content_type = \"text/plain\"\n    file_headers = {\"Content-Type\": \"image/png\"}\n\n    url = \"https://www.example.com/\"\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n    files = {\"file\": (file_name, file_content, file_content_type, file_headers)}\n\n    request = httpx.Request(\"POST\", url, headers=headers, files=files)\n    request.read()\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n        \"Content-Length\": str(len(request.content)),\n    }\n    assert request.content == (\n        f'--BOUNDARY\\r\\nContent-Disposition: form-data; name=\"file\"; '\n        f'filename=\"{file_name}\"\\r\\nContent-Type: '\n        f\"image/png\\r\\n\\r\\n<file content>\\r\\n--BOUNDARY--\\r\\n\"\n        \"\".encode(\"ascii\")\n    )",
    "function_name": "test_multipart_headers_include_content_type",
    "file": "tests/test_multipart.py",
    "num_lines": 28
  },
  {
    "query": "test empty request in tests test content",
    "code": "async def test_empty_request():\n    request = httpx.Request(method, url, data={}, files={})\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\"Host\": \"www.example.com\", \"Content-Length\": \"0\"}\n    assert sync_content == b\"\"\n    assert async_content == b\"\"",
    "function_name": "test_empty_request",
    "file": "tests/test_content.py",
    "num_lines": 11
  },
  {
    "query": "test response no charset with iso 8859 1 content in tests models test responses",
    "code": "def test_response_no_charset_with_iso_8859_1_content():\n    \"\"\"\n    A response with ISO 8859-1 encoded content should decode correctly,\n    even with no charset specified, if autodetect is enabled.\n    \"\"\"\n    content = \"Accented: \u00d6sterreich abcdefghijklmnopqrstuzwxyz\".encode(\"iso-8859-1\")\n    headers = {\"Content-Type\": \"text/plain\"}\n    response = httpx.Response(\n        200, content=content, headers=headers, default_encoding=autodetect\n    )\n    assert response.text == \"Accented: \u00d6sterreich abcdefghijklmnopqrstuzwxyz\"\n    assert response.charset_encoding is None",
    "function_name": "test_response_no_charset_with_iso_8859_1_content",
    "file": "tests/models/test_responses.py",
    "num_lines": 12
  },
  {
    "query": "iter test raw",
    "code": "def test_iter_raw():\n    response = httpx.Response(\n        200,\n        content=streaming_body(),\n    )\n\n    raw = b\"\"\n    for part in response.iter_raw():\n        raw += part\n    assert raw == b\"Hello, world!\"",
    "function_name": "test_iter_raw",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "test userinfo url",
    "code": "def test_url_copywith_userinfo_subcomponents():\n    copy_with_kwargs = {\n        \"username\": \"tom@example.org\",\n        \"password\": \"abc123@ %\",\n    }\n    url = httpx.URL(\"https://example.org\")\n    new = url.copy_with(**copy_with_kwargs)\n    assert str(new) == \"https://tom%40example.org:abc123%40%20%@example.org\"\n    assert new.username == \"tom@example.org\"\n    assert new.password == \"abc123@ %\"\n    assert new.userinfo == b\"tom%40example.org:abc123%40%20%\"",
    "function_name": "test_url_copywith_userinfo_subcomponents",
    "file": "tests/models/test_url.py",
    "num_lines": 11
  },
  {
    "query": "and set cookies implementation",
    "code": "def get_and_set_cookies(request: httpx.Request) -> httpx.Response:\n    if request.url.path == \"/echo_cookies\":\n        data = {\"cookies\": request.headers.get(\"cookie\")}\n        return httpx.Response(200, json=data)\n    elif request.url.path == \"/set_cookie\":\n        return httpx.Response(200, headers={\"set-cookie\": \"example-name=example-value\"})\n    else:\n        raise NotImplementedError()  # pragma: no cover",
    "function_name": "get_and_set_cookies",
    "file": "tests/client/test_cookies.py",
    "num_lines": 8
  },
  {
    "query": "function that returns typing.iterator[bytes]",
    "code": "    def streaming_body_with_empty_chunks() -> typing.Iterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"\"\n        yield b\"world!\"\n        yield b\"\"",
    "function_name": "streaming_body_with_empty_chunks",
    "file": "tests/models/test_responses.py",
    "num_lines": 5
  },
  {
    "query": "flush in httpx  decoders",
    "code": "    def flush(self) -> bytes:\n        try:\n            return self.decompressor.flush()\n        except zlib.error as exc:  # pragma: no cover\n            raise DecodingError(str(exc)) from exc",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "request params test",
    "code": "def test_request_params():\n    request = httpx.Request(\"GET\", \"http://example.com\", params={})\n    assert str(request.url) == \"http://example.com\"\n\n    request = httpx.Request(\n        \"GET\", \"http://example.com?c=3\", params={\"a\": \"1\", \"b\": \"2\"}\n    )\n    assert str(request.url) == \"http://example.com?a=1&b=2\"\n\n    request = httpx.Request(\"GET\", \"http://example.com?a=1\", params={})\n    assert str(request.url) == \"http://example.com\"",
    "function_name": "test_request_params",
    "file": "tests/models/test_requests.py",
    "num_lines": 11
  },
  {
    "query": "param with space",
    "code": "def test_param_with_space():\n    # Params passed as form key-value pairs should be form escaped,\n    # Including the special case of \"+\" for space seperators.\n    url = httpx.URL(\"http://webservice\", params={\"u\": \"with spaces\"})\n    assert str(url) == \"http://webservice?u=with+spaces\"",
    "function_name": "test_param_with_space",
    "file": "tests/models/test_url.py",
    "num_lines": 5
  },
  {
    "query": "test json in tests test main",
    "code": "def test_json(server):\n    url = str(server.url.copy_with(path=\"/json\"))\n    runner = CliRunner()\n    result = runner.invoke(httpx.main, [url])\n    assert result.exit_code == 0\n    assert remove_date_header(splitlines(result.output)) == [\n        \"HTTP/1.1 200 OK\",\n        \"server: uvicorn\",\n        \"content-type: application/json\",\n        \"Transfer-Encoding: chunked\",\n        \"\",\n        \"{\",\n        '\"Hello\": \"world!\"',\n        \"}\",\n    ]",
    "function_name": "test_json",
    "file": "tests/test_main.py",
    "num_lines": 15
  },
  {
    "query": "how to test that we can use an auth implementation specific to the sync case",
    "code": "def test_sync_auth() -> None:\n    \"\"\"\n    Test that we can use an auth implementation specific to the sync case.\n    \"\"\"\n    url = \"https://example.org/\"\n    auth = SyncOrAsyncAuth()\n    app = App()\n\n    with httpx.Client(transport=httpx.MockTransport(app)) as client:\n        response = client.get(url, auth=auth)\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": \"sync-auth\"}",
    "function_name": "test_sync_auth",
    "file": "tests/client/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "function that iter raw",
    "code": "    def iter_raw(self, chunk_size: int | None = None) -> typing.Iterator[bytes]:\n        \"\"\"\n        A byte-iterator over the raw response content.\n        \"\"\"\n        if self.is_stream_consumed:\n            raise StreamConsumed()\n        if self.is_closed:\n            raise StreamClosed()\n        if not isinstance(self.stream, SyncByteStream):\n            raise RuntimeError(\"Attempted to call a sync iterator on an async stream.\")\n\n        self.is_stream_consumed = True\n        self._num_bytes_downloaded = 0\n        chunker = ByteChunker(chunk_size=chunk_size)\n\n        with request_context(request=self._request):\n            for raw_stream_bytes in self.stream:\n                self._num_bytes_downloaded += len(raw_stream_bytes)\n                for chunk in chunker.decode(raw_stream_bytes):\n                    yield chunk\n\n        for chunk in chunker.flush():\n            yield chunk\n\n        self.close()",
    "function_name": "iter_raw",
    "file": "httpx/_models.py",
    "num_lines": 25
  },
  {
    "query": "a str-iterator over the decoded response content",
    "code": "    async def aiter_text(\n        self, chunk_size: int | None = None\n    ) -> typing.AsyncIterator[str]:\n        \"\"\"\n        A str-iterator over the decoded response content\n        that handles both gzip, deflate, etc but also detects the content's\n        string encoding.\n        \"\"\"\n        decoder = TextDecoder(encoding=self.encoding or \"utf-8\")\n        chunker = TextChunker(chunk_size=chunk_size)\n        with request_context(request=self._request):\n            async for byte_content in self.aiter_bytes():\n                text_content = decoder.decode(byte_content)\n                for chunk in chunker.decode(text_content):\n                    yield chunk\n            text_content = decoder.flush()\n            for chunk in chunker.decode(text_content):\n                yield chunk  # pragma: no cover\n            for chunk in chunker.flush():\n                yield chunk",
    "function_name": "aiter_text",
    "file": "httpx/_models.py",
    "num_lines": 20
  },
  {
    "query": "find the function for test stream response",
    "code": "def test_stream_response(server):\n    with httpx.Client() as client:\n        with client.stream(\"GET\", server.url) as response:\n            content = response.read()\n    assert response.status_code == 200\n    assert content == b\"Hello, world!\"",
    "function_name": "test_stream_response",
    "file": "tests/client/test_client.py",
    "num_lines": 6
  },
  {
    "query": "find the function for delete",
    "code": "def delete(\n    url: URL | str,\n    *,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    verify: ssl.SSLContext | str | bool = True,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `DELETE` request.\n\n    **Parameters**: See `httpx.request`.\n\n    Note that the `data`, `files`, `json` and `content` parameters are not available\n    on this function, as `DELETE` requests should not include a request body.\n    \"\"\"\n    return request(\n        \"DELETE\",\n        url,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "delete",
    "file": "httpx/_api.py",
    "num_lines": 34
  },
  {
    "query": "with test hooks python",
    "code": "def test_event_hooks_with_redirect():\n    \"\"\"\n    A redirect request should trigger additional 'request' and 'response' event hooks.\n    \"\"\"\n\n    events = []\n\n    def on_request(request):\n        events.append({\"event\": \"request\", \"headers\": dict(request.headers)})\n\n    def on_response(response):\n        events.append({\"event\": \"response\", \"headers\": dict(response.headers)})\n\n    event_hooks = {\"request\": [on_request], \"response\": [on_response]}\n\n    with httpx.Client(\n        event_hooks=event_hooks,\n        transport=httpx.MockTransport(app),\n        follow_redirects=True,\n    ) as http:\n        http.get(\"http://127.0.0.1:8000/redirect\", auth=(\"username\", \"password\"))\n\n    assert events == [\n        {\n            \"event\": \"request\",\n            \"headers\": {\n                \"host\": \"127.0.0.1:8000\",\n                \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n                \"accept\": \"*/*\",\n                \"accept-encoding\": \"gzip, deflate, br, zstd\",\n                \"connection\": \"keep-alive\",\n                \"authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            },\n        },\n        {\n            \"event\": \"response\",\n            \"headers\": {\"location\": \"/\", \"server\": \"testserver\"},\n        },\n        {\n            \"event\": \"request\",\n            \"headers\": {\n                \"host\": \"127.0.0.1:8000\",\n                \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n                \"accept\": \"*/*\",\n                \"accept-encoding\": \"gzip, deflate, br, zstd\",\n                \"connection\": \"keep-alive\",\n                \"authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            },\n        },\n        {\n            \"event\": \"response\",\n            \"headers\": {\"server\": \"testserver\"},\n        },\n    ]",
    "function_name": "test_event_hooks_with_redirect",
    "file": "tests/client/test_event_hooks.py",
    "num_lines": 54
  },
  {
    "query": "content test multipart",
    "code": "async def test_multipart_data_and_files_content():\n    data = {\"message\": \"Hello, world!\"}\n    files = {\"file\": io.BytesIO(b\"<file content>\")}\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=+++\"}\n    request = httpx.Request(method, url, data=data, files=files, headers=headers)\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Length\": \"210\",\n        \"Content-Type\": \"multipart/form-data; boundary=+++\",\n    }\n    assert sync_content == b\"\".join(\n        [\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"message\"\\r\\n',\n            b\"\\r\\n\",\n            b\"Hello, world!\\r\\n\",\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n            b\"Content-Type: application/octet-stream\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--+++--\\r\\n\",\n        ]\n    )\n    assert async_content == b\"\".join(\n        [\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"message\"\\r\\n',\n            b\"\\r\\n\",\n            b\"Hello, world!\\r\\n\",\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n            b\"Content-Type: application/octet-stream\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--+++--\\r\\n\",\n        ]\n    )",
    "function_name": "test_multipart_data_and_files_content",
    "file": "tests/test_content.py",
    "num_lines": 44
  },
  {
    "query": "test status unknown",
    "code": "def test_unknown_status_code():\n    response = httpx.Response(\n        600,\n    )\n    assert response.status_code == 600\n    assert response.reason_phrase == \"\"\n    assert response.text == \"\"",
    "function_name": "test_unknown_status_code",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "server test download httpx",
    "code": "def test_download(server):\n    url = str(server.url)\n    runner = CliRunner()\n    with runner.isolated_filesystem():\n        runner.invoke(httpx.main, [url, \"--download\", \"index.txt\"])\n        assert os.path.exists(\"index.txt\")\n        with open(\"index.txt\", \"r\") as input_file:\n            assert input_file.read() == \"Hello, world!\"",
    "function_name": "test_download",
    "file": "tests/test_main.py",
    "num_lines": 8
  },
  {
    "query": "url test base httpx",
    "code": "def test_client_base_url():\n    client = httpx.Client()\n    client.base_url = \"https://www.example.org/\"\n    assert isinstance(client.base_url, httpx.URL)\n    assert client.base_url == \"https://www.example.org/\"",
    "function_name": "test_client_base_url",
    "file": "tests/client/test_properties.py",
    "num_lines": 5
  },
  {
    "query": "function that takes message: typing.MutableMapping[str, typing.Any]",
    "code": "        async def send(message: typing.MutableMapping[str, typing.Any]) -> None:\n            nonlocal status_code, response_headers, response_started\n\n            if message[\"type\"] == \"http.response.start\":\n                assert not response_started\n\n                status_code = message[\"status\"]\n                response_headers = message.get(\"headers\", [])\n                response_started = True\n\n            elif message[\"type\"] == \"http.response.body\":\n                assert not response_complete.is_set()\n                body = message.get(\"body\", b\"\")\n                more_body = message.get(\"more_body\", False)\n\n                if body and request.method != \"HEAD\":\n                    body_parts.append(body)\n\n                if not more_body:\n                    response_complete.set()",
    "function_name": "send",
    "file": "httpx/_transports/asgi.py",
    "num_lines": 20
  },
  {
    "query": "test download in tests test main",
    "code": "def test_download(server):\n    url = str(server.url)\n    runner = CliRunner()\n    with runner.isolated_filesystem():\n        runner.invoke(httpx.main, [url, \"--download\", \"index.txt\"])\n        assert os.path.exists(\"index.txt\")\n        with open(\"index.txt\", \"r\") as input_file:\n            assert input_file.read() == \"Hello, world!\"",
    "function_name": "test_download",
    "file": "tests/test_main.py",
    "num_lines": 8
  },
  {
    "query": "function that returns none",
    "code": "    def close(self) -> None:\n        \"\"\"\n        Subclasses can override this method to release any network resources\n        after a request/response cycle is complete.\n        \"\"\"",
    "function_name": "close",
    "file": "httpx/_types.py",
    "num_lines": 5
  },
  {
    "query": "function that test auth hidden header",
    "code": "async def test_auth_hidden_header() -> None:\n    url = \"https://example.org/\"\n    auth = (\"example-username\", \"example-password\")\n    app = App()\n\n    async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n        response = await client.get(url, auth=auth)\n\n    assert \"'authorization': '[secure]'\" in str(response.request.headers)",
    "function_name": "test_auth_hidden_header",
    "file": "tests/client/test_auth.py",
    "num_lines": 9
  },
  {
    "query": "limits test repr",
    "code": "def test_limits_repr():\n    limits = httpx.Limits(max_connections=100)\n    expected = (\n        \"Limits(max_connections=100, max_keepalive_connections=None,\"\n        \" keepalive_expiry=5.0)\"\n    )\n    assert repr(limits) == expected",
    "function_name": "test_limits_repr",
    "file": "tests/test_config.py",
    "num_lines": 7
  },
  {
    "query": "with test request httpx",
    "code": "def test_response_with_unset_request():\n    response = httpx.Response(200, content=b\"Hello, world!\")\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.text == \"Hello, world!\"\n    assert not response.is_error",
    "function_name": "test_response_with_unset_request",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "test line crnl",
    "code": "def test_line_decoder_crnl():\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\\r\\n\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\", b\"\\n\\r\\nb\\r\\nc\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    # Issue #1033\n    response = httpx.Response(200, content=[b\"\", b\"12345\\r\\n\", b\"foo bar baz\\r\\n\"])\n    assert list(response.iter_lines()) == [\"12345\", \"foo bar baz\"]",
    "function_name": "test_line_decoder_crnl",
    "file": "tests/test_decoders.py",
    "num_lines": 13
  },
  {
    "query": "test url complete",
    "code": "def test_complete_url():\n    url = httpx.URL(\"https://example.org:123/path/to/somewhere?abc=123#anchor\")\n    assert url.scheme == \"https\"\n    assert url.host == \"example.org\"\n    assert url.port == 123\n    assert url.path == \"/path/to/somewhere\"\n    assert url.query == b\"abc=123\"\n    assert url.raw_path == b\"/path/to/somewhere?abc=123\"\n    assert url.fragment == \"anchor\"\n\n    assert str(url) == \"https://example.org:123/path/to/somewhere?abc=123#anchor\"\n    assert (\n        repr(url) == \"URL('https://example.org:123/path/to/somewhere?abc=123#anchor')\"\n    )",
    "function_name": "test_complete_url",
    "file": "tests/models/test_url.py",
    "num_lines": 14
  },
  {
    "query": "a redirect request should trigger additional 'request' and 'response' event hooks",
    "code": "def test_event_hooks_with_redirect():\n    \"\"\"\n    A redirect request should trigger additional 'request' and 'response' event hooks.\n    \"\"\"\n\n    events = []\n\n    def on_request(request):\n        events.append({\"event\": \"request\", \"headers\": dict(request.headers)})\n\n    def on_response(response):\n        events.append({\"event\": \"response\", \"headers\": dict(response.headers)})\n\n    event_hooks = {\"request\": [on_request], \"response\": [on_response]}\n\n    with httpx.Client(\n        event_hooks=event_hooks,\n        transport=httpx.MockTransport(app),\n        follow_redirects=True,\n    ) as http:\n        http.get(\"http://127.0.0.1:8000/redirect\", auth=(\"username\", \"password\"))\n\n    assert events == [\n        {\n            \"event\": \"request\",\n            \"headers\": {\n                \"host\": \"127.0.0.1:8000\",\n                \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n                \"accept\": \"*/*\",\n                \"accept-encoding\": \"gzip, deflate, br, zstd\",\n                \"connection\": \"keep-alive\",\n                \"authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            },\n        },\n        {\n            \"event\": \"response\",\n            \"headers\": {\"location\": \"/\", \"server\": \"testserver\"},\n        },\n        {\n            \"event\": \"request\",\n            \"headers\": {\n                \"host\": \"127.0.0.1:8000\",\n                \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n                \"accept\": \"*/*\",\n                \"accept-encoding\": \"gzip, deflate, br, zstd\",\n                \"connection\": \"keep-alive\",\n                \"authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            },\n        },\n        {\n            \"event\": \"response\",\n            \"headers\": {\"server\": \"testserver\"},\n        },\n    ]",
    "function_name": "test_event_hooks_with_redirect",
    "file": "tests/client/test_event_hooks.py",
    "num_lines": 54
  },
  {
    "query": "typing.iterator bytes raw",
    "code": "    def iter_raw(self, chunk_size: int | None = None) -> typing.Iterator[bytes]:\n        \"\"\"\n        A byte-iterator over the raw response content.\n        \"\"\"\n        if self.is_stream_consumed:\n            raise StreamConsumed()\n        if self.is_closed:\n            raise StreamClosed()\n        if not isinstance(self.stream, SyncByteStream):\n            raise RuntimeError(\"Attempted to call a sync iterator on an async stream.\")\n\n        self.is_stream_consumed = True\n        self._num_bytes_downloaded = 0\n        chunker = ByteChunker(chunk_size=chunk_size)\n\n        with request_context(request=self._request):\n            for raw_stream_bytes in self.stream:\n                self._num_bytes_downloaded += len(raw_stream_bytes)\n                for chunk in chunker.decode(raw_stream_bytes):\n                    yield chunk\n\n        for chunk in chunker.flush():\n            yield chunk\n\n        self.close()",
    "function_name": "iter_raw",
    "file": "httpx/_models.py",
    "num_lines": 25
  },
  {
    "query": "I need to test queryparams are hashable",
    "code": "def test_queryparams_are_hashable():\n    params = (\n        httpx.QueryParams(\"a=123\"),\n        httpx.QueryParams({\"a\": 123}),\n        httpx.QueryParams(\"b=456\"),\n        httpx.QueryParams({\"b\": 456}),\n    )\n\n    assert len(set(params)) == 2",
    "function_name": "test_queryparams_are_hashable",
    "file": "tests/models/test_queryparams.py",
    "num_lines": 9
  },
  {
    "query": "test empty request",
    "code": "async def test_empty_request():\n    request = httpx.Request(method, url, data={}, files={})\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\"Host\": \"www.example.com\", \"Content-Length\": \"0\"}\n    assert sync_content == b\"\"\n    assert async_content == b\"\"",
    "function_name": "test_empty_request",
    "file": "tests/test_content.py",
    "num_lines": 11
  },
  {
    "query": "test complete url implementation",
    "code": "def test_complete_url():\n    url = httpx.URL(\"https://example.org:123/path/to/somewhere?abc=123#anchor\")\n    assert url.scheme == \"https\"\n    assert url.host == \"example.org\"\n    assert url.port == 123\n    assert url.path == \"/path/to/somewhere\"\n    assert url.query == b\"abc=123\"\n    assert url.raw_path == b\"/path/to/somewhere?abc=123\"\n    assert url.fragment == \"anchor\"\n\n    assert str(url) == \"https://example.org:123/path/to/somewhere?abc=123#anchor\"\n    assert (\n        repr(url) == \"URL('https://example.org:123/path/to/somewhere?abc=123#anchor')\"\n    )",
    "function_name": "test_complete_url",
    "file": "tests/models/test_url.py",
    "num_lines": 14
  },
  {
    "query": "test async hooks httpx",
    "code": "async def test_async_event_hooks_raising_exception():\n    async def raise_on_4xx_5xx(response):\n        response.raise_for_status()\n\n    event_hooks = {\"response\": [raise_on_4xx_5xx]}\n\n    async with httpx.AsyncClient(\n        event_hooks=event_hooks, transport=httpx.MockTransport(app)\n    ) as http:\n        try:\n            await http.get(\"http://127.0.0.1:8000/status/400\")\n        except httpx.HTTPStatusError as exc:\n            assert exc.response.is_closed",
    "function_name": "test_async_event_hooks_raising_exception",
    "file": "tests/client/test_event_hooks.py",
    "num_lines": 13
  },
  {
    "query": "function that takes scope and receive",
    "code": "async def hello_world(scope, receive, send):\n    status = 200\n    output = b\"Hello, World!\"\n    headers = [(b\"content-type\", \"text/plain\"), (b\"content-length\", str(len(output)))]\n\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n    await send({\"type\": \"http.response.body\", \"body\": output})",
    "function_name": "hello_world",
    "file": "tests/test_asgi.py",
    "num_lines": 7
  },
  {
    "query": "flush bytes",
    "code": "    def flush(self) -> bytes:\n        try:\n            return self.decompressor.flush()\n        except zlib.error as exc:  # pragma: no cover\n            raise DecodingError(str(exc)) from exc",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "function that takes source",
    "code": "def test_queryparams(source):\n    q = httpx.QueryParams(source)\n    assert \"a\" in q\n    assert \"A\" not in q\n    assert \"c\" not in q\n    assert q[\"a\"] == \"123\"\n    assert q.get(\"a\") == \"123\"\n    assert q.get(\"nope\", default=None) is None\n    assert q.get_list(\"a\") == [\"123\", \"456\"]\n\n    assert list(q.keys()) == [\"a\", \"b\"]\n    assert list(q.values()) == [\"123\", \"789\"]\n    assert list(q.items()) == [(\"a\", \"123\"), (\"b\", \"789\")]\n    assert len(q) == 2\n    assert list(q) == [\"a\", \"b\"]\n    assert dict(q) == {\"a\": \"123\", \"b\": \"789\"}\n    assert str(q) == \"a=123&a=456&b=789\"\n    assert repr(q) == \"QueryParams('a=123&a=456&b=789')\"\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        [(\"a\", \"123\"), (\"b\", \"456\")]\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        \"a=123&b=456\"\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        {\"b\": \"456\", \"a\": \"123\"}\n    )\n    assert httpx.QueryParams() == httpx.QueryParams({})\n    assert httpx.QueryParams([(\"a\", \"123\"), (\"a\", \"456\")]) == httpx.QueryParams(\n        \"a=123&a=456\"\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) != \"invalid\"\n\n    q = httpx.QueryParams([(\"a\", \"123\"), (\"a\", \"456\")])\n    assert httpx.QueryParams(q) == q",
    "function_name": "test_queryparams",
    "file": "tests/models/test_queryparams.py",
    "num_lines": 35
  },
  {
    "query": "str keys typing.keysview",
    "code": "    def keys(self) -> typing.KeysView[str]:\n        \"\"\"\n        Return all the keys in the query params.\n\n        Usage:\n\n        q = httpx.QueryParams(\"a=123&a=456&b=789\")\n        assert list(q.keys()) == [\"a\", \"b\"]\n        \"\"\"\n        return self._dict.keys()",
    "function_name": "keys",
    "file": "httpx/_urls.py",
    "num_lines": 10
  },
  {
    "query": "how to test response using httpx?",
    "code": "def test_response():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n        request=httpx.Request(\"GET\", \"https://example.org\"),\n    )\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.text == \"Hello, world!\"\n    assert response.request.method == \"GET\"\n    assert response.request.url == \"https://example.org\"\n    assert not response.is_error",
    "function_name": "test_response",
    "file": "tests/models/test_responses.py",
    "num_lines": 13
  },
  {
    "query": "text test aiter",
    "code": "async def test_aiter_text():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = \"\"\n    async for part in response.aiter_text():\n        content += part\n    assert content == \"Hello, world!\"",
    "function_name": "test_aiter_text",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "where is the test help logic?",
    "code": "def test_help():\n    runner = CliRunner()\n    result = runner.invoke(httpx.main, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"A next generation HTTP client.\" in result.output",
    "function_name": "test_help",
    "file": "tests/test_main.py",
    "num_lines": 5
  },
  {
    "query": "typing.iterator typing.anystr typing.anystr,",
    "code": "def _obfuscate_sensitive_headers(\n    items: typing.Iterable[tuple[typing.AnyStr, typing.AnyStr]],\n) -> typing.Iterator[tuple[typing.AnyStr, typing.AnyStr]]:\n    for k, v in items:\n        if to_str(k.lower()) in SENSITIVE_HEADERS:\n            v = to_bytes_or_str(\"[secure]\", match_type_of=v)\n        yield k, v",
    "function_name": "_obfuscate_sensitive_headers",
    "file": "httpx/_models.py",
    "num_lines": 7
  },
  {
    "query": "function that takes server",
    "code": "def test_json(server):\n    url = str(server.url.copy_with(path=\"/json\"))\n    runner = CliRunner()\n    result = runner.invoke(httpx.main, [url])\n    assert result.exit_code == 0\n    assert remove_date_header(splitlines(result.output)) == [\n        \"HTTP/1.1 200 OK\",\n        \"server: uvicorn\",\n        \"content-type: application/json\",\n        \"Transfer-Encoding: chunked\",\n        \"\",\n        \"{\",\n        '\"Hello\": \"world!\"',\n        \"}\",\n    ]",
    "function_name": "test_json",
    "file": "tests/test_main.py",
    "num_lines": 15
  },
  {
    "query": "test response decode text using explicit encoding in httpx",
    "code": "def test_response_decode_text_using_explicit_encoding():\n    # Ensure that a 'default_encoding=\"...\"' on the response is used for text decoding\n    # when no \"Content-Type: text/plain; charset=...\"\" info is present.\n    #\n    # Here we have some french text encoded with Windows-1252, rather than UTF-8.\n    # https://en.wikipedia.org/wiki/Windows-1252\n    text = (\n        \"Non-seulement Despr\u00e9aux ne se trompait pas, mais de tous les \u00e9crivains \"\n        \"que la France a produits, sans excepter Voltaire lui-m\u00eame, impr\u00e9gn\u00e9 de \"\n        \"l'esprit anglais par son s\u00e9jour \u00e0 Londres, c'est incontestablement \"\n        \"Moli\u00e8re ou Poquelin qui reproduit avec l'exactitude la plus vive et la \"\n        \"plus compl\u00e8te le fond du g\u00e9nie fran\u00e7ais.\"\n    )\n    content = text.encode(\"cp1252\")\n    response = httpx.Response(200, content=content, default_encoding=\"cp1252\")\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.encoding == \"cp1252\"\n    assert response.text == text",
    "function_name": "test_response_decode_text_using_explicit_encoding",
    "file": "tests/models/test_responses.py",
    "num_lines": 20
  },
  {
    "query": "code to test response no charset with iso 8859 1 content",
    "code": "def test_response_no_charset_with_iso_8859_1_content():\n    \"\"\"\n    A response with ISO 8859-1 encoded content should decode correctly,\n    even with no charset specified, if autodetect is enabled.\n    \"\"\"\n    content = \"Accented: \u00d6sterreich abcdefghijklmnopqrstuzwxyz\".encode(\"iso-8859-1\")\n    headers = {\"Content-Type\": \"text/plain\"}\n    response = httpx.Response(\n        200, content=content, headers=headers, default_encoding=autodetect\n    )\n    assert response.text == \"Accented: \u00d6sterreich abcdefghijklmnopqrstuzwxyz\"\n    assert response.charset_encoding is None",
    "function_name": "test_response_no_charset_with_iso_8859_1_content",
    "file": "tests/models/test_responses.py",
    "num_lines": 12
  },
  {
    "query": "response iso test",
    "code": "def test_response_no_charset_with_iso_8859_1_content():\n    \"\"\"\n    A response with ISO 8859-1 encoded content should decode correctly,\n    even with no charset specified, if autodetect is enabled.\n    \"\"\"\n    content = \"Accented: \u00d6sterreich abcdefghijklmnopqrstuzwxyz\".encode(\"iso-8859-1\")\n    headers = {\"Content-Type\": \"text/plain\"}\n    response = httpx.Response(\n        200, content=content, headers=headers, default_encoding=autodetect\n    )\n    assert response.text == \"Accented: \u00d6sterreich abcdefghijklmnopqrstuzwxyz\"\n    assert response.charset_encoding is None",
    "function_name": "test_response_no_charset_with_iso_8859_1_content",
    "file": "tests/models/test_responses.py",
    "num_lines": 12
  },
  {
    "query": "what function handles test limits repr?",
    "code": "def test_limits_repr():\n    limits = httpx.Limits(max_connections=100)\n    expected = (\n        \"Limits(max_connections=100, max_keepalive_connections=None,\"\n        \" keepalive_expiry=5.0)\"\n    )\n    assert repr(limits) == expected",
    "function_name": "test_limits_repr",
    "file": "tests/test_config.py",
    "num_lines": 7
  },
  {
    "query": "function that returns bool",
    "code": "def is_ipv4_hostname(hostname: str) -> bool:\n    try:\n        ipaddress.IPv4Address(hostname.split(\"/\")[0])\n    except Exception:\n        return False\n    return True",
    "function_name": "is_ipv4_hostname",
    "file": "httpx/_utils.py",
    "num_lines": 6
  },
  {
    "query": "get in httpx  api",
    "code": "def get(\n    url: URL | str,\n    *,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `GET` request.\n\n    **Parameters**: See `httpx.request`.\n\n    Note that the `data`, `files`, `json` and `content` parameters are not available\n    on this function, as `GET` requests should not include a request body.\n    \"\"\"\n    return request(\n        \"GET\",\n        url,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "get",
    "file": "httpx/_api.py",
    "num_lines": 34
  },
  {
    "query": "how to test header merge conflicting headers using httpx?",
    "code": "def test_header_merge_conflicting_headers():\n    url = \"http://example.org/echo_headers\"\n    client_headers = {\"X-Auth-Token\": \"FooBar\"}\n    request_headers = {\"X-Auth-Token\": \"BazToken\"}\n    client = httpx.Client(\n        transport=httpx.MockTransport(echo_headers), headers=client_headers\n    )\n    response = client.get(url, headers=request_headers)\n\n    assert response.status_code == 200\n    assert response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n            \"x-auth-token\": \"BazToken\",\n        }\n    }",
    "function_name": "test_header_merge_conflicting_headers",
    "file": "tests/client/test_headers.py",
    "num_lines": 20
  },
  {
    "query": "file test tuple",
    "code": "def test_multipart_file_tuple():\n    client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n\n    # Test with a list of values 'data' argument,\n    #     and a tuple style 'files' argument.\n    data = {\"text\": [\"abc\"]}\n    files = {\"file\": (\"name.txt\", io.BytesIO(b\"<file content>\"))}\n    response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n    boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n    boundary_bytes = boundary.encode(\"ascii\")\n\n    assert response.status_code == 200\n    assert response.content == b\"\".join(\n        [\n            b\"--\" + boundary_bytes + b\"\\r\\n\",\n            b'Content-Disposition: form-data; name=\"text\"\\r\\n',\n            b\"\\r\\n\",\n            b\"abc\\r\\n\",\n            b\"--\" + boundary_bytes + b\"\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"name.txt\"\\r\\n',\n            b\"Content-Type: text/plain\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--\" + boundary_bytes + b\"--\\r\\n\",\n        ]\n    )",
    "function_name": "test_multipart_file_tuple",
    "file": "tests/test_multipart.py",
    "num_lines": 26
  },
  {
    "query": "function that takes server",
    "code": "def test_download(server):\n    url = str(server.url)\n    runner = CliRunner()\n    with runner.isolated_filesystem():\n        runner.invoke(httpx.main, [url, \"--download\", \"index.txt\"])\n        assert os.path.exists(\"index.txt\")\n        with open(\"index.txt\", \"r\") as input_file:\n            assert input_file.read() == \"Hello, world!\"",
    "function_name": "test_download",
    "file": "tests/test_main.py",
    "num_lines": 8
  },
  {
    "query": "function that returns list[tuple[str, str]]",
    "code": "    def multi_items(self) -> list[tuple[str, str]]:\n        \"\"\"\n        Return a list of `(key, value)` pairs of headers. Allow multiple\n        occurrences of the same key without concatenating into a single\n        comma separated value.\n        \"\"\"\n        return [\n            (key.decode(self.encoding), value.decode(self.encoding))\n            for _, key, value in self._list\n        ]",
    "function_name": "multi_items",
    "file": "httpx/_models.py",
    "num_lines": 10
  },
  {
    "query": "I need to test digest auth rfc 2069",
    "code": "def test_digest_auth_rfc_2069():\n    # Example from https://datatracker.ietf.org/doc/html/rfc2069#section-2.4\n    # with corrected response from https://www.rfc-editor.org/errata/eid749\n\n    auth = httpx.DigestAuth(username=\"Mufasa\", password=\"CircleOfLife\")\n    request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n\n    # The initial request should not include an auth header.\n    flow = auth.sync_auth_flow(request)\n    request = next(flow)\n    assert \"Authorization\" not in request.headers\n\n    # If a 401 response is returned, then a digest auth request is made.\n    headers = {\n        \"WWW-Authenticate\": (\n            'Digest realm=\"testrealm@host.com\", '\n            'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", '\n            'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'\n        )\n    }\n    response = httpx.Response(\n        content=b\"Auth required\", status_code=401, headers=headers, request=request\n    )\n    request = flow.send(response)\n    assert request.headers[\"Authorization\"].startswith(\"Digest\")\n    assert 'username=\"Mufasa\"' in request.headers[\"Authorization\"]\n    assert 'realm=\"testrealm@host.com\"' in request.headers[\"Authorization\"]\n    assert (\n        'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"' in request.headers[\"Authorization\"]\n    )\n    assert 'uri=\"/dir/index.html\"' in request.headers[\"Authorization\"]\n    assert (\n        'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"' in request.headers[\"Authorization\"]\n    )\n    assert (\n        'response=\"1949323746fe6a43ef61f9606e7febea\"'\n        in request.headers[\"Authorization\"]\n    )\n\n    # No other requests are made.\n    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n    with pytest.raises(StopIteration):\n        flow.send(response)",
    "function_name": "test_digest_auth_rfc_2069",
    "file": "tests/test_auth.py",
    "num_lines": 43
  },
  {
    "query": "redirect 303 test",
    "code": "def test_redirect_303():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    response = client.get(\"https://example.org/redirect_303\", follow_redirects=True)\n    assert response.status_code == httpx.codes.OK\n    assert response.url == \"https://example.org/\"\n    assert len(response.history) == 1",
    "function_name": "test_redirect_303",
    "file": "tests/client/test_redirects.py",
    "num_lines": 6
  },
  {
    "query": "auth flow in httpx  auth",
    "code": "    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n        if self._last_challenge:\n            request.headers[\"Authorization\"] = self._build_auth_header(\n                request, self._last_challenge\n            )\n\n        response = yield request\n\n        if response.status_code != 401 or \"www-authenticate\" not in response.headers:\n            # If the response is not a 401 then we don't\n            # need to build an authenticated request.\n            return\n\n        for auth_header in response.headers.get_list(\"www-authenticate\"):\n            if auth_header.lower().startswith(\"digest \"):\n                break\n        else:\n            # If the response does not include a 'WWW-Authenticate: Digest ...'\n            # header, then we don't need to build an authenticated request.\n            return\n\n        self._last_challenge = self._parse_challenge(request, response, auth_header)\n        self._nonce_count = 1\n\n        request.headers[\"Authorization\"] = self._build_auth_header(\n            request, self._last_challenge\n        )\n        if response.cookies:\n            Cookies(response.cookies).set_cookie_header(request=request)\n        yield request",
    "function_name": "auth_flow",
    "file": "httpx/_auth.py",
    "num_lines": 30
  },
  {
    "query": "test complete url in tests models test url",
    "code": "def test_complete_url():\n    url = httpx.URL(\"https://example.org:123/path/to/somewhere?abc=123#anchor\")\n    assert url.scheme == \"https\"\n    assert url.host == \"example.org\"\n    assert url.port == 123\n    assert url.path == \"/path/to/somewhere\"\n    assert url.query == b\"abc=123\"\n    assert url.raw_path == b\"/path/to/somewhere?abc=123\"\n    assert url.fragment == \"anchor\"\n\n    assert str(url) == \"https://example.org:123/path/to/somewhere?abc=123#anchor\"\n    assert (\n        repr(url) == \"URL('https://example.org:123/path/to/somewhere?abc=123#anchor')\"\n    )",
    "function_name": "test_complete_url",
    "file": "tests/models/test_url.py",
    "num_lines": 14
  },
  {
    "query": "event hooks test",
    "code": "def test_client_event_hooks():\n    def on_request(request):\n        pass  # pragma: no cover\n\n    client = httpx.Client()\n    client.event_hooks = {\"request\": [on_request]}\n    assert client.event_hooks == {\"request\": [on_request], \"response\": []}",
    "function_name": "test_client_event_hooks",
    "file": "tests/client/test_properties.py",
    "num_lines": 7
  },
  {
    "query": "send message none httpx",
    "code": "        async def send(message: typing.MutableMapping[str, typing.Any]) -> None:\n            nonlocal status_code, response_headers, response_started\n\n            if message[\"type\"] == \"http.response.start\":\n                assert not response_started\n\n                status_code = message[\"status\"]\n                response_headers = message.get(\"headers\", [])\n                response_started = True\n\n            elif message[\"type\"] == \"http.response.body\":\n                assert not response_complete.is_set()\n                body = message.get(\"body\", b\"\")\n                more_body = message.get(\"more_body\", False)\n\n                if body and request.method != \"HEAD\":\n                    body_parts.append(body)\n\n                if not more_body:\n                    response_complete.set()",
    "function_name": "send",
    "file": "httpx/_transports/asgi.py",
    "num_lines": 20
  },
  {
    "query": "test read and stream data in tests models test requests",
    "code": "def test_read_and_stream_data():\n    # Ensure a request may still be streamed if it has been read.\n    # Needed for cases such as authentication classes that read the request body.\n    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n    request.read()\n    assert request.stream is not None\n    assert isinstance(request.stream, typing.Iterable)\n    content = b\"\".join(list(request.stream))\n    assert content == request.content",
    "function_name": "test_read_and_stream_data",
    "file": "tests/models/test_requests.py",
    "num_lines": 9
  },
  {
    "query": "how does httpx encode multipart data?",
    "code": "def encode_multipart_data(\n    data: RequestData, files: RequestFiles, boundary: bytes | None\n) -> tuple[dict[str, str], MultipartStream]:\n    multipart = MultipartStream(data=data, files=files, boundary=boundary)\n    headers = multipart.get_headers()\n    return headers, multipart",
    "function_name": "encode_multipart_data",
    "file": "httpx/_content.py",
    "num_lines": 6
  },
  {
    "query": "test limits repr in tests test config",
    "code": "def test_limits_repr():\n    limits = httpx.Limits(max_connections=100)\n    expected = (\n        \"Limits(max_connections=100, max_keepalive_connections=None,\"\n        \" keepalive_expiry=5.0)\"\n    )\n    assert repr(limits) == expected",
    "function_name": "test_limits_repr",
    "file": "tests/test_config.py",
    "num_lines": 7
  },
  {
    "query": "function that test header update",
    "code": "def test_header_update():\n    url = \"http://example.org/echo_headers\"\n    client = httpx.Client(transport=httpx.MockTransport(echo_headers))\n    first_response = client.get(url)\n    client.headers.update(\n        {\"User-Agent\": \"python-myclient/0.2.1\", \"Another-Header\": \"AThing\"}\n    )\n    second_response = client.get(url)\n\n    assert first_response.status_code == 200\n    assert first_response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n        }\n    }\n\n    assert second_response.status_code == 200\n    assert second_response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"another-header\": \"AThing\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": \"python-myclient/0.2.1\",\n        }\n    }",
    "function_name": "test_header_update",
    "file": "tests/client/test_headers.py",
    "num_lines": 31
  },
  {
    "query": "function that returns list[bytes]",
    "code": "    def flush(self) -> list[bytes]:\n        value = self._buffer.getvalue()\n        self._buffer.seek(0)\n        self._buffer.truncate()\n        return [value] if value else []",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "test zstd truncated in tests test decoders",
    "code": "def test_zstd_truncated():\n    body = b\"test 123\"\n    compressed_body = zstd.compress(body)\n\n    headers = [(b\"Content-Encoding\", b\"zstd\")]\n    with pytest.raises(httpx.DecodingError):\n        httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body[1:3],\n        )",
    "function_name": "test_zstd_truncated",
    "file": "tests/test_decoders.py",
    "num_lines": 11
  },
  {
    "query": "function that takes test_case",
    "code": "def test_urlparse(test_case):\n    if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n        # Skip these two test cases.\n        # WHATWG cases where are not using percent-encoding for the space character.\n        # Anyone know what's going on here?\n        return\n\n    p = urlparse(test_case[\"href\"])\n\n    # Test cases include the protocol with the trailing \":\"\n    protocol = p.scheme + \":\"\n    # Include the square brackets for IPv6 addresses.\n    hostname = f\"[{p.host}]\" if \":\" in p.host else p.host\n    # The test cases use a string representation of the port.\n    port = \"\" if p.port is None else str(p.port)\n    # I have nothing to say about this one.\n    path = p.path\n    # The 'search' and 'hash' components in the whatwg tests are semantic, not literal.\n    # Our parsing differentiates between no query/hash and empty-string query/hash.\n    search = \"\" if p.query in (None, \"\") else \"?\" + str(p.query)\n    hash = \"\" if p.fragment in (None, \"\") else \"#\" + str(p.fragment)\n\n    # URL hostnames are case-insensitive.\n    # We normalize these, unlike the WHATWG test cases.\n    assert protocol == test_case[\"protocol\"]\n    assert hostname.lower() == test_case[\"hostname\"].lower()\n    assert port == test_case[\"port\"]\n    assert path == test_case[\"pathname\"]\n    assert search == test_case[\"search\"]\n    assert hash == test_case[\"hash\"]",
    "function_name": "test_urlparse",
    "file": "tests/models/test_whatwg.py",
    "num_lines": 30
  },
  {
    "query": "str netloc httpx",
    "code": "    def netloc(self) -> str:\n        return \"\".join(\n            [\n                f\"[{self.host}]\" if \":\" in self.host else self.host,\n                f\":{self.port}\" if self.port is not None else \"\",\n            ]\n        )",
    "function_name": "netloc",
    "file": "httpx/_urlparse.py",
    "num_lines": 7
  },
  {
    "query": "test proxy with mounts in tests client test proxies",
    "code": "def test_proxy_with_mounts():\n    proxy_transport = httpx.HTTPTransport(proxy=\"http://127.0.0.1\")\n    client = httpx.Client(mounts={\"http://\": proxy_transport})\n\n    transport = client._transport_for_url(httpx.URL(\"http://example.com\"))\n    assert transport == proxy_transport",
    "function_name": "test_proxy_with_mounts",
    "file": "tests/client/test_proxies.py",
    "num_lines": 6
  },
  {
    "query": "looking for the code that keys",
    "code": "    def keys(self) -> typing.KeysView[str]:\n        \"\"\"\n        Return all the keys in the query params.\n\n        Usage:\n\n        q = httpx.QueryParams(\"a=123&a=456&b=789\")\n        assert list(q.keys()) == [\"a\", \"b\"]\n        \"\"\"\n        return self._dict.keys()",
    "function_name": "keys",
    "file": "httpx/_urls.py",
    "num_lines": 10
  },
  {
    "query": "function that returns _digestauthchallenge",
    "code": "    def _parse_challenge(\n        self, request: Request, response: Response, auth_header: str\n    ) -> _DigestAuthChallenge:\n        \"\"\"\n        Returns a challenge from a Digest WWW-Authenticate header.\n        These take the form of:\n        `Digest realm=\"realm@host.com\",qop=\"auth,auth-int\",nonce=\"abc\",opaque=\"xyz\"`\n        \"\"\"\n        scheme, _, fields = auth_header.partition(\" \")\n\n        # This method should only ever have been called with a Digest auth header.\n        assert scheme.lower() == \"digest\"\n\n        header_dict: dict[str, str] = {}\n        for field in parse_http_list(fields):\n            key, value = field.strip().split(\"=\", 1)\n            header_dict[key] = unquote(value)\n\n        try:\n            realm = header_dict[\"realm\"].encode()\n            nonce = header_dict[\"nonce\"].encode()\n            algorithm = header_dict.get(\"algorithm\", \"MD5\")\n            opaque = header_dict[\"opaque\"].encode() if \"opaque\" in header_dict else None\n            qop = header_dict[\"qop\"].encode() if \"qop\" in header_dict else None\n            return _DigestAuthChallenge(\n                realm=realm, nonce=nonce, algorithm=algorithm, opaque=opaque, qop=qop\n            )\n        except KeyError as exc:\n            message = \"Malformed Digest WWW-Authenticate header\"\n            raise ProtocolError(message, request=request) from exc",
    "function_name": "_parse_challenge",
    "file": "httpx/_auth.py",
    "num_lines": 30
  },
  {
    "query": "iter lines in httpx  models",
    "code": "    def iter_lines(self) -> typing.Iterator[str]:\n        decoder = LineDecoder()\n        with request_context(request=self._request):\n            for text in self.iter_text():\n                for line in decoder.decode(text):\n                    yield line\n            for line in decoder.flush():\n                yield line",
    "function_name": "iter_lines",
    "file": "httpx/_models.py",
    "num_lines": 8
  },
  {
    "query": "flush in httpx  decoders",
    "code": "    def flush(self) -> list[bytes]:\n        value = self._buffer.getvalue()\n        self._buffer.seek(0)\n        self._buffer.truncate()\n        return [value] if value else []",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "function that takes server",
    "code": "async def test_build_request(server):\n    url = server.url.copy_with(path=\"/echo_headers\")\n    headers = {\"Custom-header\": \"value\"}\n    async with httpx.AsyncClient() as client:\n        request = client.build_request(\"GET\", url)\n        request.headers.update(headers)\n        response = await client.send(request)\n\n    assert response.status_code == 200\n    assert response.url == url\n\n    assert response.json()[\"Custom-header\"] == \"value\"",
    "function_name": "test_build_request",
    "file": "tests/client/test_async_client.py",
    "num_lines": 12
  },
  {
    "query": "show me how to test same domain redirect",
    "code": "def test_same_domain_redirect():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    url = \"https://example.org/cross_domain\"\n    headers = {\"Authorization\": \"abc\"}\n    response = client.get(url, headers=headers, follow_redirects=True)\n    assert response.url == \"https://example.org/cross_domain_target\"\n    assert response.json()[\"headers\"][\"authorization\"] == \"abc\"",
    "function_name": "test_same_domain_redirect",
    "file": "tests/client/test_redirects.py",
    "num_lines": 7
  },
  {
    "query": "how does httpx test iter raw?",
    "code": "def test_iter_raw():\n    response = httpx.Response(\n        200,\n        content=streaming_body(),\n    )\n\n    raw = b\"\"\n    for part in response.iter_raw():\n        raw += part\n    assert raw == b\"Hello, world!\"",
    "function_name": "test_iter_raw",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "test urlencoded list in tests test content",
    "code": "async def test_urlencoded_list():\n    request = httpx.Request(method, url, data={\"example\": [\"a\", 1, True]})\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Length\": \"32\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n    }\n    assert sync_content == b\"example=a&example=1&example=true\"\n    assert async_content == b\"example=a&example=1&example=true\"",
    "function_name": "test_urlencoded_list",
    "file": "tests/test_content.py",
    "num_lines": 15
  },
  {
    "query": "I need to flush",
    "code": "    def flush(self) -> list[str]:\n        value = self._buffer.getvalue()\n        self._buffer.seek(0)\n        self._buffer.truncate()\n        return [value] if value else []",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "hello world in tests test asgi",
    "code": "async def hello_world(scope, receive, send):\n    status = 200\n    output = b\"Hello, World!\"\n    headers = [(b\"content-type\", \"text/plain\"), (b\"content-length\", str(len(output)))]\n\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n    await send({\"type\": \"http.response.body\", \"body\": output})",
    "function_name": "hello_world",
    "file": "tests/test_asgi.py",
    "num_lines": 7
  },
  {
    "query": "streaming body with empty chunks in tests models test responses",
    "code": "    def streaming_body_with_empty_chunks() -> typing.Iterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"\"\n        yield b\"world!\"\n        yield b\"\"",
    "function_name": "streaming_body_with_empty_chunks",
    "file": "tests/models/test_responses.py",
    "num_lines": 5
  },
  {
    "query": "test digest auth rfc 2069 in tests test auth",
    "code": "def test_digest_auth_rfc_2069():\n    # Example from https://datatracker.ietf.org/doc/html/rfc2069#section-2.4\n    # with corrected response from https://www.rfc-editor.org/errata/eid749\n\n    auth = httpx.DigestAuth(username=\"Mufasa\", password=\"CircleOfLife\")\n    request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n\n    # The initial request should not include an auth header.\n    flow = auth.sync_auth_flow(request)\n    request = next(flow)\n    assert \"Authorization\" not in request.headers\n\n    # If a 401 response is returned, then a digest auth request is made.\n    headers = {\n        \"WWW-Authenticate\": (\n            'Digest realm=\"testrealm@host.com\", '\n            'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", '\n            'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'\n        )\n    }\n    response = httpx.Response(\n        content=b\"Auth required\", status_code=401, headers=headers, request=request\n    )\n    request = flow.send(response)\n    assert request.headers[\"Authorization\"].startswith(\"Digest\")\n    assert 'username=\"Mufasa\"' in request.headers[\"Authorization\"]\n    assert 'realm=\"testrealm@host.com\"' in request.headers[\"Authorization\"]\n    assert (\n        'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"' in request.headers[\"Authorization\"]\n    )\n    assert 'uri=\"/dir/index.html\"' in request.headers[\"Authorization\"]\n    assert (\n        'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"' in request.headers[\"Authorization\"]\n    )\n    assert (\n        'response=\"1949323746fe6a43ef61f9606e7febea\"'\n        in request.headers[\"Authorization\"]\n    )\n\n    # No other requests are made.\n    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n    with pytest.raises(StopIteration):\n        flow.send(response)",
    "function_name": "test_digest_auth_rfc_2069",
    "file": "tests/test_auth.py",
    "num_lines": 43
  },
  {
    "query": "echo headers in tests test asgi",
    "code": "async def echo_headers(scope, receive, send):\n    status = 200\n    output = json.dumps(\n        {\"headers\": [[k.decode(), v.decode()] for k, v in scope[\"headers\"]]}\n    ).encode(\"utf-8\")\n    headers = [(b\"content-type\", \"text/plain\"), (b\"content-length\", str(len(output)))]\n\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n    await send({\"type\": \"http.response.body\", \"body\": output})",
    "function_name": "echo_headers",
    "file": "tests/test_asgi.py",
    "num_lines": 9
  },
  {
    "query": "function that returns none",
    "code": "def test_sync_auth() -> None:\n    \"\"\"\n    Test that we can use an auth implementation specific to the sync case.\n    \"\"\"\n    url = \"https://example.org/\"\n    auth = SyncOrAsyncAuth()\n    app = App()\n\n    with httpx.Client(transport=httpx.MockTransport(app)) as client:\n        response = client.get(url, auth=auth)\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": \"sync-auth\"}",
    "function_name": "test_sync_auth",
    "file": "tests/client/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "test header merge conflicting headers in tests client test headers",
    "code": "def test_header_merge_conflicting_headers():\n    url = \"http://example.org/echo_headers\"\n    client_headers = {\"X-Auth-Token\": \"FooBar\"}\n    request_headers = {\"X-Auth-Token\": \"BazToken\"}\n    client = httpx.Client(\n        transport=httpx.MockTransport(echo_headers), headers=client_headers\n    )\n    response = client.get(url, headers=request_headers)\n\n    assert response.status_code == 200\n    assert response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n            \"x-auth-token\": \"BazToken\",\n        }\n    }",
    "function_name": "test_header_merge_conflicting_headers",
    "file": "tests/client/test_headers.py",
    "num_lines": 20
  },
  {
    "query": "how to content-type from 4th tuple parameter (headers) should",
    "code": "def test_multipart_headers_include_content_type() -> None:\n    \"\"\"\n    Content-Type from 4th tuple parameter (headers) should\n    override the 3rd parameter (content_type)\n    \"\"\"\n    file_name = \"test.txt\"\n    file_content = io.BytesIO(b\"<file content>\")\n    file_content_type = \"text/plain\"\n    file_headers = {\"Content-Type\": \"image/png\"}\n\n    url = \"https://www.example.com/\"\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n    files = {\"file\": (file_name, file_content, file_content_type, file_headers)}\n\n    request = httpx.Request(\"POST\", url, headers=headers, files=files)\n    request.read()\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n        \"Content-Length\": str(len(request.content)),\n    }\n    assert request.content == (\n        f'--BOUNDARY\\r\\nContent-Disposition: form-data; name=\"file\"; '\n        f'filename=\"{file_name}\"\\r\\nContent-Type: '\n        f\"image/png\\r\\n\\r\\n<file content>\\r\\n--BOUNDARY--\\r\\n\"\n        \"\".encode(\"ascii\")\n    )",
    "function_name": "test_multipart_headers_include_content_type",
    "file": "tests/test_multipart.py",
    "num_lines": 28
  },
  {
    "query": "show me how to test url remove param manipulation",
    "code": "def test_url_remove_param_manipulation():\n    \"\"\"\n    Some basic URL query parameter manipulation.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/?a=123\")\n    assert url.copy_remove_param(\"a\") == \"https://example.org:123/\"",
    "function_name": "test_url_remove_param_manipulation",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "function that returns tuple[dict[str, str], multipartstream]",
    "code": "def encode_multipart_data(\n    data: RequestData, files: RequestFiles, boundary: bytes | None\n) -> tuple[dict[str, str], MultipartStream]:\n    multipart = MultipartStream(data=data, files=files, boundary=boundary)\n    headers = multipart.get_headers()\n    return headers, multipart",
    "function_name": "encode_multipart_data",
    "file": "httpx/_content.py",
    "num_lines": 6
  },
  {
    "query": "code to auth flow",
    "code": "    def auth_flow(\n        self, request: httpx.Request\n    ) -> typing.Generator[httpx.Request, httpx.Response, None]:\n        nonces = []\n\n        for index in range(self.repeat):\n            request.headers[\"Authorization\"] = f\"Repeat {index}\"\n            response = yield request\n            nonces.append(response.headers[\"www-authenticate\"])\n\n        key = \".\".join(nonces)\n        request.headers[\"Authorization\"] = f\"Repeat {key}\"\n        yield request",
    "function_name": "auth_flow",
    "file": "tests/client/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "test client url",
    "code": "def test_client_base_url():\n    client = httpx.Client()\n    client.base_url = \"https://www.example.org/\"\n    assert isinstance(client.base_url, httpx.URL)\n    assert client.base_url == \"https://www.example.org/\"",
    "function_name": "test_client_base_url",
    "file": "tests/client/test_properties.py",
    "num_lines": 5
  },
  {
    "query": "info implementation",
    "code": "        def info(self) -> email.message.Message:\n            info = email.message.Message()\n            for key, value in self.response.headers.multi_items():\n                # Note that setting `info[key]` here is an \"append\" operation,\n                # not a \"replace\" operation.\n                # https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.__setitem__\n                info[key] = value\n            return info",
    "function_name": "info",
    "file": "httpx/_models.py",
    "num_lines": 8
  },
  {
    "query": "function that returns str",
    "code": "def primitive_value_to_str(value: PrimitiveData) -> str:\n    \"\"\"\n    Coerce a primitive data type into a string value.\n\n    Note that we prefer JSON-style 'true'/'false' for boolean values here.\n    \"\"\"\n    if value is True:\n        return \"true\"\n    elif value is False:\n        return \"false\"\n    elif value is None:\n        return \"\"\n    return str(value)",
    "function_name": "primitive_value_to_str",
    "file": "httpx/_utils.py",
    "num_lines": 13
  },
  {
    "query": "test urlparse in tests models test whatwg",
    "code": "def test_urlparse(test_case):\n    if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n        # Skip these two test cases.\n        # WHATWG cases where are not using percent-encoding for the space character.\n        # Anyone know what's going on here?\n        return\n\n    p = urlparse(test_case[\"href\"])\n\n    # Test cases include the protocol with the trailing \":\"\n    protocol = p.scheme + \":\"\n    # Include the square brackets for IPv6 addresses.\n    hostname = f\"[{p.host}]\" if \":\" in p.host else p.host\n    # The test cases use a string representation of the port.\n    port = \"\" if p.port is None else str(p.port)\n    # I have nothing to say about this one.\n    path = p.path\n    # The 'search' and 'hash' components in the whatwg tests are semantic, not literal.\n    # Our parsing differentiates between no query/hash and empty-string query/hash.\n    search = \"\" if p.query in (None, \"\") else \"?\" + str(p.query)\n    hash = \"\" if p.fragment in (None, \"\") else \"#\" + str(p.fragment)\n\n    # URL hostnames are case-insensitive.\n    # We normalize these, unlike the WHATWG test cases.\n    assert protocol == test_case[\"protocol\"]\n    assert hostname.lower() == test_case[\"hostname\"].lower()\n    assert port == test_case[\"port\"]\n    assert path == test_case[\"pathname\"]\n    assert search == test_case[\"search\"]\n    assert hash == test_case[\"hash\"]",
    "function_name": "test_urlparse",
    "file": "tests/models/test_whatwg.py",
    "num_lines": 30
  },
  {
    "query": "how to test asgi exc no raise using httpx?",
    "code": "async def test_asgi_exc_no_raise():\n    transport = httpx.ASGITransport(app=raise_exc, raise_app_exceptions=False)\n    async with httpx.AsyncClient(transport=transport) as client:\n        response = await client.get(\"http://www.example.org/\")\n\n        assert response.status_code == 500",
    "function_name": "test_asgi_exc_no_raise",
    "file": "tests/test_asgi.py",
    "num_lines": 6
  },
  {
    "query": "test zstd truncated implementation",
    "code": "def test_zstd_truncated():\n    body = b\"test 123\"\n    compressed_body = zstd.compress(body)\n\n    headers = [(b\"Content-Encoding\", b\"zstd\")]\n    with pytest.raises(httpx.DecodingError):\n        httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body[1:3],\n        )",
    "function_name": "test_zstd_truncated",
    "file": "tests/test_decoders.py",
    "num_lines": 11
  },
  {
    "query": "aiterator content test",
    "code": "async def test_aiterator_content():\n    async def hello_world() -> typing.AsyncIterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"world!\"\n\n    request = httpx.Request(method, url, content=hello_world())\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"\n\n    with pytest.raises(httpx.StreamConsumed):\n        [part async for part in request.stream]\n\n    # Support 'data' for compat with requests.\n    with pytest.warns(DeprecationWarning):\n        request = httpx.Request(method, url, data=hello_world())  # type: ignore\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiterator_content",
    "file": "tests/test_content.py",
    "num_lines": 33
  },
  {
    "query": "returns a challenge from a digest www-authenticate header",
    "code": "    def _parse_challenge(\n        self, request: Request, response: Response, auth_header: str\n    ) -> _DigestAuthChallenge:\n        \"\"\"\n        Returns a challenge from a Digest WWW-Authenticate header.\n        These take the form of:\n        `Digest realm=\"realm@host.com\",qop=\"auth,auth-int\",nonce=\"abc\",opaque=\"xyz\"`\n        \"\"\"\n        scheme, _, fields = auth_header.partition(\" \")\n\n        # This method should only ever have been called with a Digest auth header.\n        assert scheme.lower() == \"digest\"\n\n        header_dict: dict[str, str] = {}\n        for field in parse_http_list(fields):\n            key, value = field.strip().split(\"=\", 1)\n            header_dict[key] = unquote(value)\n\n        try:\n            realm = header_dict[\"realm\"].encode()\n            nonce = header_dict[\"nonce\"].encode()\n            algorithm = header_dict.get(\"algorithm\", \"MD5\")\n            opaque = header_dict[\"opaque\"].encode() if \"opaque\" in header_dict else None\n            qop = header_dict[\"qop\"].encode() if \"qop\" in header_dict else None\n            return _DigestAuthChallenge(\n                realm=realm, nonce=nonce, algorithm=algorithm, opaque=opaque, qop=qop\n            )\n        except KeyError as exc:\n            message = \"Malformed Digest WWW-Authenticate header\"\n            raise ProtocolError(message, request=request) from exc",
    "function_name": "_parse_challenge",
    "file": "httpx/_auth.py",
    "num_lines": 30
  },
  {
    "query": "test response in tests models test responses",
    "code": "def test_response():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n        request=httpx.Request(\"GET\", \"https://example.org\"),\n    )\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.text == \"Hello, world!\"\n    assert response.request.method == \"GET\"\n    assert response.request.url == \"https://example.org\"\n    assert not response.is_error",
    "function_name": "test_response",
    "file": "tests/models/test_responses.py",
    "num_lines": 13
  },
  {
    "query": "build auth header in httpx  auth",
    "code": "    def _build_auth_header(\n        self, request: Request, challenge: _DigestAuthChallenge\n    ) -> str:\n        hash_func = self._ALGORITHM_TO_HASH_FUNCTION[challenge.algorithm.upper()]\n\n        def digest(data: bytes) -> bytes:\n            return hash_func(data).hexdigest().encode()\n\n        A1 = b\":\".join((self._username, challenge.realm, self._password))\n\n        path = request.url.raw_path\n        A2 = b\":\".join((request.method.encode(), path))\n        # TODO: implement auth-int\n        HA2 = digest(A2)\n\n        nc_value = b\"%08x\" % self._nonce_count\n        cnonce = self._get_client_nonce(self._nonce_count, challenge.nonce)\n        self._nonce_count += 1\n\n        HA1 = digest(A1)\n        if challenge.algorithm.lower().endswith(\"-sess\"):\n            HA1 = digest(b\":\".join((HA1, challenge.nonce, cnonce)))\n\n        qop = self._resolve_qop(challenge.qop, request=request)\n        if qop is None:\n            # Following RFC 2069\n            digest_data = [HA1, challenge.nonce, HA2]\n        else:\n            # Following RFC 2617/7616\n            digest_data = [HA1, challenge.nonce, nc_value, cnonce, qop, HA2]\n\n        format_args = {\n            \"username\": self._username,\n            \"realm\": challenge.realm,\n            \"nonce\": challenge.nonce,\n            \"uri\": path,\n            \"response\": digest(b\":\".join(digest_data)),\n            \"algorithm\": challenge.algorithm.encode(),\n        }\n        if challenge.opaque:\n            format_args[\"opaque\"] = challenge.opaque\n        if qop:\n            format_args[\"qop\"] = b\"auth\"\n            format_args[\"nc\"] = nc_value\n            format_args[\"cnonce\"] = cnonce\n\n        return \"Digest \" + self._get_header_value(format_args)",
    "function_name": "_build_auth_header",
    "file": "httpx/_auth.py",
    "num_lines": 47
  },
  {
    "query": "function that takes server",
    "code": "async def test_pool_timeout(server):\n    limits = httpx.Limits(max_connections=1)\n    timeout = httpx.Timeout(None, pool=1e-4)\n\n    async with httpx.AsyncClient(limits=limits, timeout=timeout) as client:\n        with pytest.raises(httpx.PoolTimeout):\n            async with client.stream(\"GET\", server.url):\n                await client.get(server.url)",
    "function_name": "test_pool_timeout",
    "file": "tests/test_timeouts.py",
    "num_lines": 8
  },
  {
    "query": "how does httpx obfuscate sensitive headers?",
    "code": "def _obfuscate_sensitive_headers(\n    items: typing.Iterable[tuple[typing.AnyStr, typing.AnyStr]],\n) -> typing.Iterator[tuple[typing.AnyStr, typing.AnyStr]]:\n    for k, v in items:\n        if to_str(k.lower()) in SENSITIVE_HEADERS:\n            v = to_bytes_or_str(\"[secure]\", match_type_of=v)\n        yield k, v",
    "function_name": "_obfuscate_sensitive_headers",
    "file": "httpx/_models.py",
    "num_lines": 7
  },
  {
    "query": "some basic url query parameter manipulation",
    "code": "def test_url_remove_param_manipulation():\n    \"\"\"\n    Some basic URL query parameter manipulation.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/?a=123\")\n    assert url.copy_remove_param(\"a\") == \"https://example.org:123/\"",
    "function_name": "test_url_remove_param_manipulation",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "function that returns none",
    "code": "def test_netrc_auth_credentials_do_not_exist() -> None:\n    \"\"\"\n    When netrc auth is being used and a request is made to a host that is\n    not in the netrc file, then no credentials should be applied.\n    \"\"\"\n    netrc_file = str(FIXTURES_DIR / \".netrc\")\n    url = \"http://example.org\"\n    app = App()\n    auth = httpx.NetRCAuth(netrc_file)\n\n    with httpx.Client(transport=httpx.MockTransport(app), auth=auth) as client:\n        response = client.get(url)\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": None}",
    "function_name": "test_netrc_auth_credentials_do_not_exist",
    "file": "tests/client/test_auth.py",
    "num_lines": 15
  },
  {
    "query": "multipart boundary from content type in httpx  multipart",
    "code": "def get_multipart_boundary_from_content_type(\n    content_type: bytes | None,\n) -> bytes | None:\n    if not content_type or not content_type.startswith(b\"multipart/form-data\"):\n        return None\n    # parse boundary according to\n    # https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n    if b\";\" in content_type:\n        for section in content_type.split(b\";\"):\n            if section.strip().lower().startswith(b\"boundary=\"):\n                return section.strip()[len(b\"boundary=\") :].strip(b'\"')\n    return None",
    "function_name": "get_multipart_boundary_from_content_type",
    "file": "httpx/_multipart.py",
    "num_lines": 12
  },
  {
    "query": "test bytesio content",
    "code": "async def test_async_bytesio_content():\n    class AsyncBytesIO:\n        def __init__(self, content: bytes) -> None:\n            self._idx = 0\n            self._content = content\n\n        async def aread(self, chunk_size: int) -> bytes:\n            chunk = self._content[self._idx : self._idx + chunk_size]\n            self._idx = self._idx + chunk_size\n            return chunk\n\n        async def __aiter__(self):\n            yield self._content  # pragma: no cover\n\n    request = httpx.Request(method, url, content=AsyncBytesIO(b\"Hello, world!\"))\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"",
    "function_name": "test_async_bytesio_content",
    "file": "tests/test_content.py",
    "num_lines": 25
  },
  {
    "query": "function that returns str",
    "code": "    def _build_auth_header(\n        self, request: Request, challenge: _DigestAuthChallenge\n    ) -> str:\n        hash_func = self._ALGORITHM_TO_HASH_FUNCTION[challenge.algorithm.upper()]\n\n        def digest(data: bytes) -> bytes:\n            return hash_func(data).hexdigest().encode()\n\n        A1 = b\":\".join((self._username, challenge.realm, self._password))\n\n        path = request.url.raw_path\n        A2 = b\":\".join((request.method.encode(), path))\n        # TODO: implement auth-int\n        HA2 = digest(A2)\n\n        nc_value = b\"%08x\" % self._nonce_count\n        cnonce = self._get_client_nonce(self._nonce_count, challenge.nonce)\n        self._nonce_count += 1\n\n        HA1 = digest(A1)\n        if challenge.algorithm.lower().endswith(\"-sess\"):\n            HA1 = digest(b\":\".join((HA1, challenge.nonce, cnonce)))\n\n        qop = self._resolve_qop(challenge.qop, request=request)\n        if qop is None:\n            # Following RFC 2069\n            digest_data = [HA1, challenge.nonce, HA2]\n        else:\n            # Following RFC 2617/7616\n            digest_data = [HA1, challenge.nonce, nc_value, cnonce, qop, HA2]\n\n        format_args = {\n            \"username\": self._username,\n            \"realm\": challenge.realm,\n            \"nonce\": challenge.nonce,\n            \"uri\": path,\n            \"response\": digest(b\":\".join(digest_data)),\n            \"algorithm\": challenge.algorithm.encode(),\n        }\n        if challenge.opaque:\n            format_args[\"opaque\"] = challenge.opaque\n        if qop:\n            format_args[\"qop\"] = b\"auth\"\n            format_args[\"nc\"] = nc_value\n            format_args[\"cnonce\"] = cnonce\n\n        return \"Digest \" + self._get_header_value(format_args)",
    "function_name": "_build_auth_header",
    "file": "httpx/_auth.py",
    "num_lines": 47
  },
  {
    "query": "function that returns bytes",
    "code": "    def raw_path(self) -> bytes:\n        \"\"\"\n        The complete URL path and query string as raw bytes.\n        Used as the target when constructing HTTP requests.\n\n        For example:\n\n        GET /users?search=some%20text HTTP/1.1\n        Host: www.example.org\n        Connection: close\n        \"\"\"\n        path = self._uri_reference.path or \"/\"\n        if self._uri_reference.query is not None:\n            path += \"?\" + self._uri_reference.query\n        return path.encode(\"ascii\")",
    "function_name": "raw_path",
    "file": "httpx/_urls.py",
    "num_lines": 15
  },
  {
    "query": "type test invalid python",
    "code": "def test_url_invalid_type():\n    \"\"\"\n    Ensure that invalid types on `httpx.URL()` raise a `TypeError`.\n    \"\"\"\n\n    class ExternalURLClass:  # representing external URL class\n        pass\n\n    with pytest.raises(TypeError):\n        httpx.URL(ExternalURLClass())  # type: ignore",
    "function_name": "test_url_invalid_type",
    "file": "tests/models/test_url.py",
    "num_lines": 10
  },
  {
    "query": "dict none proxies python",
    "code": "def get_environment_proxies() -> dict[str, str | None]:\n    \"\"\"Gets proxy information from the environment\"\"\"\n\n    # urllib.request.getproxies() falls back on System\n    # Registry and Config for proxies on Windows and macOS.\n    # We don't want to propagate non-HTTP proxies into\n    # our configuration such as 'TRAVIS_APT_PROXY'.\n    proxy_info = getproxies()\n    mounts: dict[str, str | None] = {}\n\n    for scheme in (\"http\", \"https\", \"all\"):\n        if proxy_info.get(scheme):\n            hostname = proxy_info[scheme]\n            mounts[f\"{scheme}://\"] = (\n                hostname if \"://\" in hostname else f\"http://{hostname}\"\n            )\n\n    no_proxy_hosts = [host.strip() for host in proxy_info.get(\"no\", \"\").split(\",\")]\n    for hostname in no_proxy_hosts:\n        # See https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html for details\n        # on how names in `NO_PROXY` are handled.\n        if hostname == \"*\":\n            # If NO_PROXY=* is used or if \"*\" occurs as any one of the comma\n            # separated hostnames, then we should just bypass any information\n            # from HTTP_PROXY, HTTPS_PROXY, ALL_PROXY, and always ignore\n            # proxies.\n            return {}\n        elif hostname:\n            # NO_PROXY=.google.com is marked as \"all://*.google.com,\n            #   which disables \"www.google.com\" but not \"google.com\"\n            # NO_PROXY=google.com is marked as \"all://*google.com,\n            #   which disables \"www.google.com\" and \"google.com\".\n            #   (But not \"wwwgoogle.com\")\n            # NO_PROXY can include domains, IPv6, IPv4 addresses and \"localhost\"\n            #   NO_PROXY=example.com,::1,localhost,192.168.0.0/16\n            if \"://\" in hostname:\n                mounts[hostname] = None\n            elif is_ipv4_hostname(hostname):\n                mounts[f\"all://{hostname}\"] = None\n            elif is_ipv6_hostname(hostname):\n                mounts[f\"all://[{hostname}]\"] = None\n            elif hostname.lower() == \"localhost\":\n                mounts[f\"all://{hostname}\"] = None\n            else:\n                mounts[f\"all://*{hostname}\"] = None\n\n    return mounts",
    "function_name": "get_environment_proxies",
    "file": "httpx/_utils.py",
    "num_lines": 47
  },
  {
    "query": "auth flow request",
    "code": "    def auth_flow(\n        self, request: httpx.Request\n    ) -> typing.Generator[httpx.Request, httpx.Response, None]:\n        nonces = []\n\n        for index in range(self.repeat):\n            request.headers[\"Authorization\"] = f\"Repeat {index}\"\n            response = yield request\n            nonces.append(response.headers[\"www-authenticate\"])\n\n        key = \".\".join(nonces)\n        request.headers[\"Authorization\"] = f\"Repeat {key}\"\n        yield request",
    "function_name": "auth_flow",
    "file": "tests/client/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "function that returns typing.callable[[bytes], typing.any]",
    "code": "        def start_response(\n            status: str,\n            response_headers: list[tuple[str, str]],\n            exc_info: OptExcInfo | None = None,\n        ) -> typing.Callable[[bytes], typing.Any]:\n            nonlocal seen_status, seen_response_headers, seen_exc_info\n            seen_status = status\n            seen_response_headers = response_headers\n            seen_exc_info = exc_info\n            return lambda _: None",
    "function_name": "start_response",
    "file": "httpx/_transports/wsgi.py",
    "num_lines": 10
  },
  {
    "query": "function that returns list[str]",
    "code": "    def flush(self) -> list[str]:\n        value = self._buffer.getvalue()\n        self._buffer.seek(0)\n        self._buffer.truncate()\n        return [value] if value else []",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "function that returns response",
    "code": "def delete(\n    url: URL | str,\n    *,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    verify: ssl.SSLContext | str | bool = True,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `DELETE` request.\n\n    **Parameters**: See `httpx.request`.\n\n    Note that the `data`, `files`, `json` and `content` parameters are not available\n    on this function, as `DELETE` requests should not include a request body.\n    \"\"\"\n    return request(\n        \"DELETE\",\n        url,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "delete",
    "file": "httpx/_api.py",
    "num_lines": 34
  },
  {
    "query": "test basic auth in tests test auth",
    "code": "def test_basic_auth():\n    auth = httpx.BasicAuth(username=\"user\", password=\"pass\")\n    request = httpx.Request(\"GET\", \"https://www.example.com\")\n\n    # The initial request should include a basic auth header.\n    flow = auth.sync_auth_flow(request)\n    request = next(flow)\n    assert request.headers[\"Authorization\"].startswith(\"Basic\")\n\n    # No other requests are made.\n    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n    with pytest.raises(StopIteration):\n        flow.send(response)",
    "function_name": "test_basic_auth",
    "file": "tests/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "test post server",
    "code": "def test_post_json(server):\n    with httpx.Client() as client:\n        response = client.post(server.url, json={\"text\": \"Hello, world!\"})\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"",
    "function_name": "test_post_json",
    "file": "tests/client/test_client.py",
    "num_lines": 5
  },
  {
    "query": "looking for the code that flush",
    "code": "    def flush(self) -> bytes:\n        try:\n            return self.decompressor.flush()\n        except zlib.error as exc:  # pragma: no cover\n            raise DecodingError(str(exc)) from exc",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "test request picklable implementation",
    "code": "def test_request_picklable():\n    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n    pickle_request = pickle.loads(pickle.dumps(request))\n    assert pickle_request.method == \"POST\"\n    assert pickle_request.url.path == \"/\"\n    assert pickle_request.headers[\"Content-Type\"] == \"application/json\"\n    assert pickle_request.content == b'{\"test\":123}'\n    assert pickle_request.stream is not None\n    assert request.headers == {\n        \"Host\": \"example.org\",\n        \"Content-Type\": \"application/json\",\n        \"content-length\": \"12\",\n    }",
    "function_name": "test_request_picklable",
    "file": "tests/models/test_requests.py",
    "num_lines": 13
  },
  {
    "query": "test response with unset request in tests models test responses",
    "code": "def test_response_with_unset_request():\n    response = httpx.Response(200, content=b\"Hello, world!\")\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.text == \"Hello, world!\"\n    assert not response.is_error",
    "function_name": "test_response_with_unset_request",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "test asgi upload in tests test asgi",
    "code": "async def test_asgi_upload():\n    transport = httpx.ASGITransport(app=echo_body)\n    async with httpx.AsyncClient(transport=transport) as client:\n        response = await client.post(\"http://www.example.org/\", content=b\"example\")\n\n    assert response.status_code == 200\n    assert response.text == \"example\"",
    "function_name": "test_asgi_upload",
    "file": "tests/test_asgi.py",
    "num_lines": 7
  },
  {
    "query": "how to when netrc auth is being used and a request is made to a host that is",
    "code": "def test_netrc_auth_credentials_do_not_exist() -> None:\n    \"\"\"\n    When netrc auth is being used and a request is made to a host that is\n    not in the netrc file, then no credentials should be applied.\n    \"\"\"\n    netrc_file = str(FIXTURES_DIR / \".netrc\")\n    url = \"http://example.org\"\n    app = App()\n    auth = httpx.NetRCAuth(netrc_file)\n\n    with httpx.Client(transport=httpx.MockTransport(app), auth=auth) as client:\n        response = client.get(url)\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": None}",
    "function_name": "test_netrc_auth_credentials_do_not_exist",
    "file": "tests/client/test_auth.py",
    "num_lines": 15
  },
  {
    "query": "content-type from 4th tuple parameter (headers) should",
    "code": "def test_multipart_headers_include_content_type() -> None:\n    \"\"\"\n    Content-Type from 4th tuple parameter (headers) should\n    override the 3rd parameter (content_type)\n    \"\"\"\n    file_name = \"test.txt\"\n    file_content = io.BytesIO(b\"<file content>\")\n    file_content_type = \"text/plain\"\n    file_headers = {\"Content-Type\": \"image/png\"}\n\n    url = \"https://www.example.com/\"\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n    files = {\"file\": (file_name, file_content, file_content_type, file_headers)}\n\n    request = httpx.Request(\"POST\", url, headers=headers, files=files)\n    request.read()\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n        \"Content-Length\": str(len(request.content)),\n    }\n    assert request.content == (\n        f'--BOUNDARY\\r\\nContent-Disposition: form-data; name=\"file\"; '\n        f'filename=\"{file_name}\"\\r\\nContent-Type: '\n        f\"image/png\\r\\n\\r\\n<file content>\\r\\n--BOUNDARY--\\r\\n\"\n        \"\".encode(\"ascii\")\n    )",
    "function_name": "test_multipart_headers_include_content_type",
    "file": "tests/test_multipart.py",
    "num_lines": 28
  },
  {
    "query": "function that returns response",
    "code": "def post(\n    url: URL | str,\n    *,\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: typing.Any | None = None,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `POST` request.\n\n    **Parameters**: See `httpx.request`.\n    \"\"\"\n    return request(\n        \"POST\",\n        url,\n        content=content,\n        data=data,\n        files=files,\n        json=json,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "post",
    "file": "httpx/_api.py",
    "num_lines": 39
  },
  {
    "query": "unset response with",
    "code": "def test_response_with_unset_request():\n    response = httpx.Response(200, content=b\"Hello, world!\")\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.text == \"Hello, world!\"\n    assert not response.is_error",
    "function_name": "test_response_with_unset_request",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "test request params in tests models test requests",
    "code": "def test_request_params():\n    request = httpx.Request(\"GET\", \"http://example.com\", params={})\n    assert str(request.url) == \"http://example.com\"\n\n    request = httpx.Request(\n        \"GET\", \"http://example.com?c=3\", params={\"a\": \"1\", \"b\": \"2\"}\n    )\n    assert str(request.url) == \"http://example.com?a=1&b=2\"\n\n    request = httpx.Request(\"GET\", \"http://example.com?a=1\", params={})\n    assert str(request.url) == \"http://example.com\"",
    "function_name": "test_request_params",
    "file": "tests/models/test_requests.py",
    "num_lines": 11
  },
  {
    "query": "merge headers header",
    "code": "def test_header_merge_conflicting_headers():\n    url = \"http://example.org/echo_headers\"\n    client_headers = {\"X-Auth-Token\": \"FooBar\"}\n    request_headers = {\"X-Auth-Token\": \"BazToken\"}\n    client = httpx.Client(\n        transport=httpx.MockTransport(echo_headers), headers=client_headers\n    )\n    response = client.get(url, headers=request_headers)\n\n    assert response.status_code == 200\n    assert response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n            \"x-auth-token\": \"BazToken\",\n        }\n    }",
    "function_name": "test_header_merge_conflicting_headers",
    "file": "tests/client/test_headers.py",
    "num_lines": 20
  },
  {
    "query": "server test iterator",
    "code": "def test_stream_iterator(server):\n    body = b\"\"\n\n    with httpx.Client() as client:\n        with client.stream(\"GET\", server.url) as response:\n            for chunk in response.iter_bytes():\n                body += chunk\n\n    assert response.status_code == 200\n    assert body == b\"Hello, world!\"",
    "function_name": "test_stream_iterator",
    "file": "tests/client/test_client.py",
    "num_lines": 10
  },
  {
    "query": "test put in tests client test client",
    "code": "def test_put(server):\n    with httpx.Client() as client:\n        response = client.put(server.url, content=b\"Hello, world!\")\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"",
    "function_name": "test_put",
    "file": "tests/client/test_client.py",
    "num_lines": 5
  },
  {
    "query": "test case urlparse test python",
    "code": "def test_urlparse(test_case):\n    if test_case[\"href\"] in (\"a: foo.com\", \"lolscheme:x x#x%20x\"):\n        # Skip these two test cases.\n        # WHATWG cases where are not using percent-encoding for the space character.\n        # Anyone know what's going on here?\n        return\n\n    p = urlparse(test_case[\"href\"])\n\n    # Test cases include the protocol with the trailing \":\"\n    protocol = p.scheme + \":\"\n    # Include the square brackets for IPv6 addresses.\n    hostname = f\"[{p.host}]\" if \":\" in p.host else p.host\n    # The test cases use a string representation of the port.\n    port = \"\" if p.port is None else str(p.port)\n    # I have nothing to say about this one.\n    path = p.path\n    # The 'search' and 'hash' components in the whatwg tests are semantic, not literal.\n    # Our parsing differentiates between no query/hash and empty-string query/hash.\n    search = \"\" if p.query in (None, \"\") else \"?\" + str(p.query)\n    hash = \"\" if p.fragment in (None, \"\") else \"#\" + str(p.fragment)\n\n    # URL hostnames are case-insensitive.\n    # We normalize these, unlike the WHATWG test cases.\n    assert protocol == test_case[\"protocol\"]\n    assert hostname.lower() == test_case[\"hostname\"].lower()\n    assert port == test_case[\"port\"]\n    assert path == test_case[\"pathname\"]\n    assert search == test_case[\"search\"]\n    assert hash == test_case[\"hash\"]",
    "function_name": "test_urlparse",
    "file": "tests/models/test_whatwg.py",
    "num_lines": 30
  },
  {
    "query": "function that takes server",
    "code": "def test_stream_response(server):\n    with httpx.Client() as client:\n        with client.stream(\"GET\", server.url) as response:\n            content = response.read()\n    assert response.status_code == 200\n    assert content == b\"Hello, world!\"",
    "function_name": "test_stream_response",
    "file": "tests/client/test_client.py",
    "num_lines": 6
  },
  {
    "query": "data test read",
    "code": "def test_read_and_stream_data():\n    # Ensure a request may still be streamed if it has been read.\n    # Needed for cases such as authentication classes that read the request body.\n    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n    request.read()\n    assert request.stream is not None\n    assert isinstance(request.stream, typing.Iterable)\n    content = b\"\".join(list(request.stream))\n    assert content == request.content",
    "function_name": "test_read_and_stream_data",
    "file": "tests/models/test_requests.py",
    "num_lines": 9
  },
  {
    "query": "I need to echo headers",
    "code": "async def echo_headers(scope, receive, send):\n    status = 200\n    output = json.dumps(\n        {\"headers\": [[k.decode(), v.decode()] for k, v in scope[\"headers\"]]}\n    ).encode(\"utf-8\")\n    headers = [(b\"content-type\", \"text/plain\"), (b\"content-length\", str(len(output)))]\n\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n    await send({\"type\": \"http.response.body\", \"body\": output})",
    "function_name": "echo_headers",
    "file": "tests/test_asgi.py",
    "num_lines": 9
  },
  {
    "query": "test param with space in tests models test url",
    "code": "def test_param_with_space():\n    # Params passed as form key-value pairs should be form escaped,\n    # Including the special case of \"+\" for space seperators.\n    url = httpx.URL(\"http://webservice\", params={\"u\": \"with spaces\"})\n    assert str(url) == \"http://webservice?u=with+spaces\"",
    "function_name": "test_param_with_space",
    "file": "tests/models/test_url.py",
    "num_lines": 5
  },
  {
    "query": "multi items in httpx  models",
    "code": "    def multi_items(self) -> list[tuple[str, str]]:\n        \"\"\"\n        Return a list of `(key, value)` pairs of headers. Allow multiple\n        occurrences of the same key without concatenating into a single\n        comma separated value.\n        \"\"\"\n        return [\n            (key.decode(self.encoding), value.decode(self.encoding))\n            for _, key, value in self._list\n        ]",
    "function_name": "multi_items",
    "file": "httpx/_models.py",
    "num_lines": 10
  },
  {
    "query": "content request test",
    "code": "async def test_request_async_streaming_content_picklable():\n    async def streaming_body(data: bytes) -> typing.AsyncIterator[bytes]:\n        yield data\n\n    data = streaming_body(b\"test 123\")\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n    pickle_request = pickle.loads(pickle.dumps(request))\n    with pytest.raises(httpx.RequestNotRead):\n        pickle_request.content  # noqa: B018\n    with pytest.raises(httpx.StreamClosed):\n        await pickle_request.aread()\n\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n    await request.aread()\n    pickle_request = pickle.loads(pickle.dumps(request))\n    assert pickle_request.content == b\"test 123\"",
    "function_name": "test_request_async_streaming_content_picklable",
    "file": "tests/models/test_requests.py",
    "num_lines": 16
  },
  {
    "query": "text test decoder",
    "code": "def test_text_decoder_empty_cases():\n    response = httpx.Response(200, content=b\"\")\n    assert response.text == \"\"\n\n    response = httpx.Response(200, content=[b\"\"])\n    response.read()\n    assert response.text == \"\"",
    "function_name": "test_text_decoder_empty_cases",
    "file": "tests/test_decoders.py",
    "num_lines": 7
  },
  {
    "query": "test auth basic",
    "code": "def test_basic_auth():\n    auth = httpx.BasicAuth(username=\"user\", password=\"pass\")\n    request = httpx.Request(\"GET\", \"https://www.example.com\")\n\n    # The initial request should include a basic auth header.\n    flow = auth.sync_auth_flow(request)\n    request = next(flow)\n    assert request.headers[\"Authorization\"].startswith(\"Basic\")\n\n    # No other requests are made.\n    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n    with pytest.raises(StopIteration):\n        flow.send(response)",
    "function_name": "test_basic_auth",
    "file": "tests/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "test same domain redirect in tests client test redirects",
    "code": "def test_same_domain_redirect():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    url = \"https://example.org/cross_domain\"\n    headers = {\"Authorization\": \"abc\"}\n    response = client.get(url, headers=headers, follow_redirects=True)\n    assert response.url == \"https://example.org/cross_domain_target\"\n    assert response.json()[\"headers\"][\"authorization\"] == \"abc\"",
    "function_name": "test_same_domain_redirect",
    "file": "tests/client/test_redirects.py",
    "num_lines": 7
  },
  {
    "query": "non url component",
    "code": "def test_url_non_printing_character_in_component():\n    with pytest.raises(httpx.InvalidURL) as exc:\n        httpx.URL(\"https://www.example.com\", path=\"/\\n\")\n    assert str(exc.value) == (\n        \"Invalid non-printable ASCII character in URL path component, \"\n        \"'\\\\n' at position 1.\"\n    )",
    "function_name": "test_url_non_printing_character_in_component",
    "file": "tests/models/test_url.py",
    "num_lines": 7
  },
  {
    "query": "test empty doesnt",
    "code": "def test_iter_bytes_doesnt_return_empty_chunks():\n    def streaming_body_with_empty_chunks() -> typing.Iterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"\"\n        yield b\"world!\"\n        yield b\"\"\n\n    response = httpx.Response(200, content=streaming_body_with_empty_chunks())\n\n    parts = list(response.iter_bytes())\n    assert parts == [b\"Hello, \", b\"world!\"]",
    "function_name": "test_iter_bytes_doesnt_return_empty_chunks",
    "file": "tests/models/test_responses.py",
    "num_lines": 11
  },
  {
    "query": "function that returns typing.generator[httpx.request, httpx.response, none]",
    "code": "    def auth_flow(\n        self, request: httpx.Request\n    ) -> typing.Generator[httpx.Request, httpx.Response, None]:\n        nonces = []\n\n        for index in range(self.repeat):\n            request.headers[\"Authorization\"] = f\"Repeat {index}\"\n            response = yield request\n            nonces.append(response.headers[\"www-authenticate\"])\n\n        key = \".\".join(nonces)\n        request.headers[\"Authorization\"] = f\"Repeat {key}\"\n        yield request",
    "function_name": "auth_flow",
    "file": "tests/client/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "what function handles test asgi upload?",
    "code": "async def test_asgi_upload():\n    transport = httpx.ASGITransport(app=echo_body)\n    async with httpx.AsyncClient(transport=transport) as client:\n        response = await client.post(\"http://www.example.org/\", content=b\"example\")\n\n    assert response.status_code == 200\n    assert response.text == \"example\"",
    "function_name": "test_asgi_upload",
    "file": "tests/test_asgi.py",
    "num_lines": 7
  },
  {
    "query": "test multipart data and files content in tests test content",
    "code": "async def test_multipart_data_and_files_content():\n    data = {\"message\": \"Hello, world!\"}\n    files = {\"file\": io.BytesIO(b\"<file content>\")}\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=+++\"}\n    request = httpx.Request(method, url, data=data, files=files, headers=headers)\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Length\": \"210\",\n        \"Content-Type\": \"multipart/form-data; boundary=+++\",\n    }\n    assert sync_content == b\"\".join(\n        [\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"message\"\\r\\n',\n            b\"\\r\\n\",\n            b\"Hello, world!\\r\\n\",\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n            b\"Content-Type: application/octet-stream\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--+++--\\r\\n\",\n        ]\n    )\n    assert async_content == b\"\".join(\n        [\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"message\"\\r\\n',\n            b\"\\r\\n\",\n            b\"Hello, world!\\r\\n\",\n            b\"--+++\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n            b\"Content-Type: application/octet-stream\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--+++--\\r\\n\",\n        ]\n    )",
    "function_name": "test_multipart_data_and_files_content",
    "file": "tests/test_content.py",
    "num_lines": 44
  },
  {
    "query": "test header update in tests client test headers",
    "code": "def test_header_update():\n    url = \"http://example.org/echo_headers\"\n    client = httpx.Client(transport=httpx.MockTransport(echo_headers))\n    first_response = client.get(url)\n    client.headers.update(\n        {\"User-Agent\": \"python-myclient/0.2.1\", \"Another-Header\": \"AThing\"}\n    )\n    second_response = client.get(url)\n\n    assert first_response.status_code == 200\n    assert first_response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n        }\n    }\n\n    assert second_response.status_code == 200\n    assert second_response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"another-header\": \"AThing\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": \"python-myclient/0.2.1\",\n        }\n    }",
    "function_name": "test_header_update",
    "file": "tests/client/test_headers.py",
    "num_lines": 31
  },
  {
    "query": "show me how to test read timeout",
    "code": "async def test_read_timeout(server):\n    timeout = httpx.Timeout(None, read=1e-6)\n\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        with pytest.raises(httpx.ReadTimeout):\n            await client.get(server.url.copy_with(path=\"/slow_response\"))",
    "function_name": "test_read_timeout",
    "file": "tests/test_timeouts.py",
    "num_lines": 6
  },
  {
    "query": "how to test text decoder empty cases using httpx?",
    "code": "def test_text_decoder_empty_cases():\n    response = httpx.Response(200, content=b\"\")\n    assert response.text == \"\"\n\n    response = httpx.Response(200, content=[b\"\"])\n    response.read()\n    assert response.text == \"\"",
    "function_name": "test_text_decoder_empty_cases",
    "file": "tests/test_decoders.py",
    "num_lines": 7
  },
  {
    "query": "str test url",
    "code": "def test_url_eq_str():\n    \"\"\"\n    Ensure that `httpx.URL` supports the equality operator.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/path/to/somewhere?abc=123#anchor\")\n    assert url == \"https://example.org:123/path/to/somewhere?abc=123#anchor\"\n    assert str(url) == url",
    "function_name": "test_url_eq_str",
    "file": "tests/models/test_url.py",
    "num_lines": 7
  },
  {
    "query": "code to encode request",
    "code": "def encode_request(\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: Any | None = None,\n    boundary: bytes | None = None,\n) -> tuple[dict[str, str], SyncByteStream | AsyncByteStream]:\n    \"\"\"\n    Handles encoding the given `content`, `data`, `files`, and `json`,\n    returning a two-tuple of (<headers>, <stream>).\n    \"\"\"\n    if data is not None and not isinstance(data, Mapping):\n        # We prefer to separate `content=<bytes|str|byte iterator|bytes aiterator>`\n        # for raw request content, and `data=<form data>` for url encoded or\n        # multipart form content.\n        #\n        # However for compat with requests, we *do* still support\n        # `data=<bytes...>` usages. We deal with that case here, treating it\n        # as if `content=<...>` had been supplied instead.\n        message = \"Use 'content=<...>' to upload raw bytes/text content.\"\n        warnings.warn(message, DeprecationWarning, stacklevel=2)\n        return encode_content(data)\n\n    if content is not None:\n        return encode_content(content)\n    elif files:\n        return encode_multipart_data(data or {}, files, boundary)\n    elif data:\n        return encode_urlencoded_data(data)\n    elif json is not None:\n        return encode_json(json)\n\n    return {}, ByteStream(b\"\")",
    "function_name": "encode_request",
    "file": "httpx/_content.py",
    "num_lines": 33
  },
  {
    "query": "header test update",
    "code": "def test_header_update():\n    url = \"http://example.org/echo_headers\"\n    client = httpx.Client(transport=httpx.MockTransport(echo_headers))\n    first_response = client.get(url)\n    client.headers.update(\n        {\"User-Agent\": \"python-myclient/0.2.1\", \"Another-Header\": \"AThing\"}\n    )\n    second_response = client.get(url)\n\n    assert first_response.status_code == 200\n    assert first_response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": f\"python-httpx/{httpx.__version__}\",\n        }\n    }\n\n    assert second_response.status_code == 200\n    assert second_response.json() == {\n        \"headers\": {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate, br, zstd\",\n            \"another-header\": \"AThing\",\n            \"connection\": \"keep-alive\",\n            \"host\": \"example.org\",\n            \"user-agent\": \"python-myclient/0.2.1\",\n        }\n    }",
    "function_name": "test_header_update",
    "file": "tests/client/test_headers.py",
    "num_lines": 31
  },
  {
    "query": "how to test aiter bytes using httpx?",
    "code": "async def test_aiter_bytes():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = b\"\"\n    async for part in response.aiter_bytes():\n        content += part\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiter_bytes",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "redirect test 302",
    "code": "def test_redirect_302():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    response = client.post(\"https://example.org/redirect_302\", follow_redirects=True)\n    assert response.status_code == httpx.codes.OK\n    assert response.url == \"https://example.org/\"\n    assert len(response.history) == 1",
    "function_name": "test_redirect_302",
    "file": "tests/client/test_redirects.py",
    "num_lines": 6
  },
  {
    "query": "test build server",
    "code": "async def test_build_request(server):\n    url = server.url.copy_with(path=\"/echo_headers\")\n    headers = {\"Custom-header\": \"value\"}\n    async with httpx.AsyncClient() as client:\n        request = client.build_request(\"GET\", url)\n        request.headers.update(headers)\n        response = await client.send(request)\n\n    assert response.status_code == 200\n    assert response.url == url\n\n    assert response.json()[\"Custom-header\"] == \"value\"",
    "function_name": "test_build_request",
    "file": "tests/client/test_async_client.py",
    "num_lines": 12
  },
  {
    "query": "load ssl existing",
    "code": "def test_load_ssl_config_verify_existing_file():\n    context = httpx.create_ssl_context()\n    context.load_verify_locations(capath=certifi.where())\n    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n    assert context.check_hostname is True",
    "function_name": "test_load_ssl_config_verify_existing_file",
    "file": "tests/test_config.py",
    "num_lines": 5
  },
  {
    "query": "test asgi exc no raise in tests test asgi",
    "code": "async def test_asgi_exc_no_raise():\n    transport = httpx.ASGITransport(app=raise_exc, raise_app_exceptions=False)\n    async with httpx.AsyncClient(transport=transport) as client:\n        response = await client.get(\"http://www.example.org/\")\n\n        assert response.status_code == 500",
    "function_name": "test_asgi_exc_no_raise",
    "file": "tests/test_asgi.py",
    "num_lines": 6
  },
  {
    "query": "copy with url",
    "code": "    def copy_with(self, **kwargs: typing.Any) -> URL:\n        \"\"\"\n        Copy this URL, returning a new URL with some components altered.\n        Accepts the same set of parameters as the components that are made\n        available via properties on the `URL` class.\n\n        For example:\n\n        url = httpx.URL(\"https://www.example.com\").copy_with(\n            username=\"jo@gmail.com\", password=\"a secret\"\n        )\n        assert url == \"https://jo%40email.com:a%20secret@www.example.com\"\n        \"\"\"\n        return URL(self, **kwargs)",
    "function_name": "copy_with",
    "file": "httpx/_urls.py",
    "num_lines": 14
  },
  {
    "query": "str netloc",
    "code": "    def netloc(self) -> str:\n        return \"\".join(\n            [\n                f\"[{self.host}]\" if \":\" in self.host else self.host,\n                f\":{self.port}\" if self.port is not None else \"\",\n            ]\n        )",
    "function_name": "netloc",
    "file": "httpx/_urlparse.py",
    "num_lines": 7
  },
  {
    "query": "test aiter raw in tests models test responses",
    "code": "async def test_aiter_raw():\n    response = httpx.Response(200, content=async_streaming_body())\n\n    raw = b\"\"\n    async for part in response.aiter_raw():\n        raw += part\n    assert raw == b\"Hello, world!\"",
    "function_name": "test_aiter_raw",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "raw aiter test",
    "code": "async def test_aiter_raw():\n    response = httpx.Response(200, content=async_streaming_body())\n\n    raw = b\"\"\n    async for part in response.aiter_raw():\n        raw += part\n    assert raw == b\"Hello, world!\"",
    "function_name": "test_aiter_raw",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "how to the url userinfo as a raw bytestring",
    "code": "    def userinfo(self) -> bytes:\n        \"\"\"\n        The URL userinfo as a raw bytestring.\n        For example: b\"jo%40email.com:a%20secret\".\n        \"\"\"\n        return self._uri_reference.userinfo.encode(\"ascii\")",
    "function_name": "userinfo",
    "file": "httpx/_urls.py",
    "num_lines": 6
  },
  {
    "query": "how to ensure that `httpx.url` instances can be used in sets",
    "code": "def test_url_set():\n    \"\"\"\n    Ensure that `httpx.URL` instances can be used in sets.\n    \"\"\"\n    urls = (\n        httpx.URL(\"http://example.org:123/path/to/somewhere\"),\n        httpx.URL(\"http://example.org:123/path/to/somewhere/else\"),\n    )\n\n    url_set = set(urls)\n\n    assert all(url in urls for url in url_set)",
    "function_name": "test_url_set",
    "file": "tests/models/test_url.py",
    "num_lines": 12
  },
  {
    "query": "find the function for test stream iterator",
    "code": "def test_stream_iterator(server):\n    body = b\"\"\n\n    with httpx.Client() as client:\n        with client.stream(\"GET\", server.url) as response:\n            for chunk in response.iter_bytes():\n                body += chunk\n\n    assert response.status_code == 200\n    assert body == b\"Hello, world!\"",
    "function_name": "test_stream_iterator",
    "file": "tests/client/test_client.py",
    "num_lines": 10
  },
  {
    "query": "test response decode text using explicit encoding in tests models test responses",
    "code": "def test_response_decode_text_using_explicit_encoding():\n    # Ensure that a 'default_encoding=\"...\"' on the response is used for text decoding\n    # when no \"Content-Type: text/plain; charset=...\"\" info is present.\n    #\n    # Here we have some french text encoded with Windows-1252, rather than UTF-8.\n    # https://en.wikipedia.org/wiki/Windows-1252\n    text = (\n        \"Non-seulement Despr\u00e9aux ne se trompait pas, mais de tous les \u00e9crivains \"\n        \"que la France a produits, sans excepter Voltaire lui-m\u00eame, impr\u00e9gn\u00e9 de \"\n        \"l'esprit anglais par son s\u00e9jour \u00e0 Londres, c'est incontestablement \"\n        \"Moli\u00e8re ou Poquelin qui reproduit avec l'exactitude la plus vive et la \"\n        \"plus compl\u00e8te le fond du g\u00e9nie fran\u00e7ais.\"\n    )\n    content = text.encode(\"cp1252\")\n    response = httpx.Response(200, content=content, default_encoding=\"cp1252\")\n\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"\n    assert response.encoding == \"cp1252\"\n    assert response.text == text",
    "function_name": "test_response_decode_text_using_explicit_encoding",
    "file": "tests/models/test_responses.py",
    "num_lines": 20
  },
  {
    "query": "test pool timeout in tests test timeouts",
    "code": "async def test_pool_timeout(server):\n    limits = httpx.Limits(max_connections=1)\n    timeout = httpx.Timeout(None, pool=1e-4)\n\n    async with httpx.AsyncClient(limits=limits, timeout=timeout) as client:\n        with pytest.raises(httpx.PoolTimeout):\n            async with client.stream(\"GET\", server.url):\n                await client.get(server.url)",
    "function_name": "test_pool_timeout",
    "file": "tests/test_timeouts.py",
    "num_lines": 8
  },
  {
    "query": "sockets serve",
    "code": "    async def serve(self, sockets=None):\n        self.restart_requested = asyncio.Event()\n\n        loop = asyncio.get_event_loop()\n        tasks = {\n            loop.create_task(super().serve(sockets=sockets)),\n            loop.create_task(self.watch_restarts()),\n        }\n        await asyncio.wait(tasks)",
    "function_name": "serve",
    "file": "tests/conftest.py",
    "num_lines": 9
  },
  {
    "query": "and set cookies in tests client test cookies",
    "code": "def get_and_set_cookies(request: httpx.Request) -> httpx.Response:\n    if request.url.path == \"/echo_cookies\":\n        data = {\"cookies\": request.headers.get(\"cookie\")}\n        return httpx.Response(200, json=data)\n    elif request.url.path == \"/set_cookie\":\n        return httpx.Response(200, headers={\"set-cookie\": \"example-name=example-value\"})\n    else:\n        raise NotImplementedError()  # pragma: no cover",
    "function_name": "get_and_set_cookies",
    "file": "tests/client/test_cookies.py",
    "num_lines": 8
  },
  {
    "query": "test cookies in tests models test cookies",
    "code": "def test_cookies():\n    cookies = httpx.Cookies({\"name\": \"value\"})\n    assert cookies[\"name\"] == \"value\"\n    assert \"name\" in cookies\n    assert len(cookies) == 1\n    assert dict(cookies) == {\"name\": \"value\"}\n    assert bool(cookies) is True\n\n    del cookies[\"name\"]\n    assert \"name\" not in cookies\n    assert len(cookies) == 0\n    assert dict(cookies) == {}\n    assert bool(cookies) is False",
    "function_name": "test_cookies",
    "file": "tests/models/test_cookies.py",
    "num_lines": 13
  },
  {
    "query": "contentdecoder decoder content",
    "code": "    def _get_content_decoder(self) -> ContentDecoder:\n        \"\"\"\n        Returns a decoder instance which can be used to decode the raw byte\n        content, depending on the Content-Encoding used in the response.\n        \"\"\"\n        if not hasattr(self, \"_decoder\"):\n            decoders: list[ContentDecoder] = []\n            values = self.headers.get_list(\"content-encoding\", split_commas=True)\n            for value in values:\n                value = value.strip().lower()\n                try:\n                    decoder_cls = SUPPORTED_DECODERS[value]\n                    decoders.append(decoder_cls())\n                except KeyError:\n                    continue\n\n            if len(decoders) == 1:\n                self._decoder = decoders[0]\n            elif len(decoders) > 1:\n                self._decoder = MultiDecoder(children=decoders)\n            else:\n                self._decoder = IdentityDecoder()\n\n        return self._decoder",
    "function_name": "_get_content_decoder",
    "file": "httpx/_models.py",
    "num_lines": 24
  },
  {
    "query": "test iter raw in tests models test responses",
    "code": "def test_iter_raw():\n    response = httpx.Response(\n        200,\n        content=streaming_body(),\n    )\n\n    raw = b\"\"\n    for part in response.iter_raw():\n        raw += part\n    assert raw == b\"Hello, world!\"",
    "function_name": "test_iter_raw",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "test basic auth with stream implementation",
    "code": "async def test_basic_auth_with_stream() -> None:\n    \"\"\"\n    See: https://github.com/encode/httpx/pull/1312\n    \"\"\"\n    url = \"https://example.org/\"\n    auth = (\"user\", \"password123\")\n    app = App()\n\n    async with httpx.AsyncClient(\n        transport=httpx.MockTransport(app), auth=auth\n    ) as client:\n        async with client.stream(\"GET\", url) as response:\n            await response.aread()\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": \"Basic dXNlcjpwYXNzd29yZDEyMw==\"}",
    "function_name": "test_basic_auth_with_stream",
    "file": "tests/client/test_auth.py",
    "num_lines": 16
  },
  {
    "query": "test queryparams in tests models test queryparams",
    "code": "def test_queryparams(source):\n    q = httpx.QueryParams(source)\n    assert \"a\" in q\n    assert \"A\" not in q\n    assert \"c\" not in q\n    assert q[\"a\"] == \"123\"\n    assert q.get(\"a\") == \"123\"\n    assert q.get(\"nope\", default=None) is None\n    assert q.get_list(\"a\") == [\"123\", \"456\"]\n\n    assert list(q.keys()) == [\"a\", \"b\"]\n    assert list(q.values()) == [\"123\", \"789\"]\n    assert list(q.items()) == [(\"a\", \"123\"), (\"b\", \"789\")]\n    assert len(q) == 2\n    assert list(q) == [\"a\", \"b\"]\n    assert dict(q) == {\"a\": \"123\", \"b\": \"789\"}\n    assert str(q) == \"a=123&a=456&b=789\"\n    assert repr(q) == \"QueryParams('a=123&a=456&b=789')\"\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        [(\"a\", \"123\"), (\"b\", \"456\")]\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        \"a=123&b=456\"\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) == httpx.QueryParams(\n        {\"b\": \"456\", \"a\": \"123\"}\n    )\n    assert httpx.QueryParams() == httpx.QueryParams({})\n    assert httpx.QueryParams([(\"a\", \"123\"), (\"a\", \"456\")]) == httpx.QueryParams(\n        \"a=123&a=456\"\n    )\n    assert httpx.QueryParams({\"a\": \"123\", \"b\": \"456\"}) != \"invalid\"\n\n    q = httpx.QueryParams([(\"a\", \"123\"), (\"a\", \"456\")])\n    assert httpx.QueryParams(q) == q",
    "function_name": "test_queryparams",
    "file": "tests/models/test_queryparams.py",
    "num_lines": 35
  },
  {
    "query": "test async bytesio content in tests test content",
    "code": "async def test_async_bytesio_content():\n    class AsyncBytesIO:\n        def __init__(self, content: bytes) -> None:\n            self._idx = 0\n            self._content = content\n\n        async def aread(self, chunk_size: int) -> bytes:\n            chunk = self._content[self._idx : self._idx + chunk_size]\n            self._idx = self._idx + chunk_size\n            return chunk\n\n        async def __aiter__(self):\n            yield self._content  # pragma: no cover\n\n    request = httpx.Request(method, url, content=AsyncBytesIO(b\"Hello, world!\"))\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"",
    "function_name": "test_async_bytesio_content",
    "file": "tests/test_content.py",
    "num_lines": 25
  },
  {
    "query": "decode in httpx  decoders",
    "code": "    def decode(self, content: bytes) -> list[bytes]:\n        if self._chunk_size is None:\n            return [content] if content else []\n\n        self._buffer.write(content)\n        if self._buffer.tell() >= self._chunk_size:\n            value = self._buffer.getvalue()\n            chunks = [\n                value[i : i + self._chunk_size]\n                for i in range(0, len(value), self._chunk_size)\n            ]\n            if len(chunks[-1]) == self._chunk_size:\n                self._buffer.seek(0)\n                self._buffer.truncate()\n                return chunks\n            else:\n                self._buffer.seek(0)\n                self._buffer.write(chunks[-1])\n                self._buffer.truncate()\n                return chunks[:-1]\n        else:\n            return []",
    "function_name": "decode",
    "file": "httpx/_decoders.py",
    "num_lines": 22
  },
  {
    "query": "str proxies dict",
    "code": "def get_environment_proxies() -> dict[str, str | None]:\n    \"\"\"Gets proxy information from the environment\"\"\"\n\n    # urllib.request.getproxies() falls back on System\n    # Registry and Config for proxies on Windows and macOS.\n    # We don't want to propagate non-HTTP proxies into\n    # our configuration such as 'TRAVIS_APT_PROXY'.\n    proxy_info = getproxies()\n    mounts: dict[str, str | None] = {}\n\n    for scheme in (\"http\", \"https\", \"all\"):\n        if proxy_info.get(scheme):\n            hostname = proxy_info[scheme]\n            mounts[f\"{scheme}://\"] = (\n                hostname if \"://\" in hostname else f\"http://{hostname}\"\n            )\n\n    no_proxy_hosts = [host.strip() for host in proxy_info.get(\"no\", \"\").split(\",\")]\n    for hostname in no_proxy_hosts:\n        # See https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html for details\n        # on how names in `NO_PROXY` are handled.\n        if hostname == \"*\":\n            # If NO_PROXY=* is used or if \"*\" occurs as any one of the comma\n            # separated hostnames, then we should just bypass any information\n            # from HTTP_PROXY, HTTPS_PROXY, ALL_PROXY, and always ignore\n            # proxies.\n            return {}\n        elif hostname:\n            # NO_PROXY=.google.com is marked as \"all://*.google.com,\n            #   which disables \"www.google.com\" but not \"google.com\"\n            # NO_PROXY=google.com is marked as \"all://*google.com,\n            #   which disables \"www.google.com\" and \"google.com\".\n            #   (But not \"wwwgoogle.com\")\n            # NO_PROXY can include domains, IPv6, IPv4 addresses and \"localhost\"\n            #   NO_PROXY=example.com,::1,localhost,192.168.0.0/16\n            if \"://\" in hostname:\n                mounts[hostname] = None\n            elif is_ipv4_hostname(hostname):\n                mounts[f\"all://{hostname}\"] = None\n            elif is_ipv6_hostname(hostname):\n                mounts[f\"all://[{hostname}]\"] = None\n            elif hostname.lower() == \"localhost\":\n                mounts[f\"all://{hostname}\"] = None\n            else:\n                mounts[f\"all://*{hostname}\"] = None\n\n    return mounts",
    "function_name": "get_environment_proxies",
    "file": "httpx/_utils.py",
    "num_lines": 47
  },
  {
    "query": "test value error without request in tests models test responses",
    "code": "def test_value_error_without_request(header_value):\n    headers = [(b\"Content-Encoding\", header_value)]\n    broken_compressed_body = b\"xxxxxxxxxxxxxx\"\n    with pytest.raises(httpx.DecodingError):\n        httpx.Response(200, headers=headers, content=broken_compressed_body)",
    "function_name": "test_value_error_without_request",
    "file": "tests/models/test_responses.py",
    "num_lines": 5
  },
  {
    "query": "test help in tests test main",
    "code": "def test_help():\n    runner = CliRunner()\n    result = runner.invoke(httpx.main, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"A next generation HTTP client.\" in result.output",
    "function_name": "test_help",
    "file": "tests/test_main.py",
    "num_lines": 5
  },
  {
    "query": "function that takes header_value",
    "code": "def test_value_error_without_request(header_value):\n    headers = [(b\"Content-Encoding\", header_value)]\n    broken_compressed_body = b\"xxxxxxxxxxxxxx\"\n    with pytest.raises(httpx.DecodingError):\n        httpx.Response(200, headers=headers, content=broken_compressed_body)",
    "function_name": "test_value_error_without_request",
    "file": "tests/models/test_responses.py",
    "num_lines": 5
  },
  {
    "query": "sends a `get` request",
    "code": "def get(\n    url: URL | str,\n    *,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `GET` request.\n\n    **Parameters**: See `httpx.request`.\n\n    Note that the `data`, `files`, `json` and `content` parameters are not available\n    on this function, as `GET` requests should not include a request body.\n    \"\"\"\n    return request(\n        \"GET\",\n        url,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "get",
    "file": "httpx/_api.py",
    "num_lines": 34
  },
  {
    "query": "code to test basic auth",
    "code": "def test_basic_auth():\n    auth = httpx.BasicAuth(username=\"user\", password=\"pass\")\n    request = httpx.Request(\"GET\", \"https://www.example.com\")\n\n    # The initial request should include a basic auth header.\n    flow = auth.sync_auth_flow(request)\n    request = next(flow)\n    assert request.headers[\"Authorization\"].startswith(\"Basic\")\n\n    # No other requests are made.\n    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n    with pytest.raises(StopIteration):\n        flow.send(response)",
    "function_name": "test_basic_auth",
    "file": "tests/test_auth.py",
    "num_lines": 13
  },
  {
    "query": "test url set in tests models test url",
    "code": "def test_url_set():\n    \"\"\"\n    Ensure that `httpx.URL` instances can be used in sets.\n    \"\"\"\n    urls = (\n        httpx.URL(\"http://example.org:123/path/to/somewhere\"),\n        httpx.URL(\"http://example.org:123/path/to/somewhere/else\"),\n    )\n\n    url_set = set(urls)\n\n    assert all(url in urls for url in url_set)",
    "function_name": "test_url_set",
    "file": "tests/models/test_url.py",
    "num_lines": 12
  },
  {
    "query": "find the function for test async bytesio content",
    "code": "async def test_async_bytesio_content():\n    class AsyncBytesIO:\n        def __init__(self, content: bytes) -> None:\n            self._idx = 0\n            self._content = content\n\n        async def aread(self, chunk_size: int) -> bytes:\n            chunk = self._content[self._idx : self._idx + chunk_size]\n            self._idx = self._idx + chunk_size\n            return chunk\n\n        async def __aiter__(self):\n            yield self._content  # pragma: no cover\n\n    request = httpx.Request(method, url, content=AsyncBytesIO(b\"Hello, world!\"))\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"",
    "function_name": "test_async_bytesio_content",
    "file": "tests/test_content.py",
    "num_lines": 25
  },
  {
    "query": "netloc in httpx  urlparse",
    "code": "    def netloc(self) -> str:\n        return \"\".join(\n            [\n                f\"[{self.host}]\" if \":\" in self.host else self.host,\n                f\":{self.port}\" if self.port is not None else \"\",\n            ]\n        )",
    "function_name": "netloc",
    "file": "httpx/_urlparse.py",
    "num_lines": 7
  },
  {
    "query": "error in httpx  models",
    "code": "    def is_error(self) -> bool:\n        \"\"\"\n        A property which is `True` for 4xx and 5xx status codes, `False` otherwise.\n        \"\"\"\n        return codes.is_error(self.status_code)",
    "function_name": "is_error",
    "file": "httpx/_models.py",
    "num_lines": 5
  },
  {
    "query": "where is the build auth header logic?",
    "code": "    def _build_auth_header(\n        self, request: Request, challenge: _DigestAuthChallenge\n    ) -> str:\n        hash_func = self._ALGORITHM_TO_HASH_FUNCTION[challenge.algorithm.upper()]\n\n        def digest(data: bytes) -> bytes:\n            return hash_func(data).hexdigest().encode()\n\n        A1 = b\":\".join((self._username, challenge.realm, self._password))\n\n        path = request.url.raw_path\n        A2 = b\":\".join((request.method.encode(), path))\n        # TODO: implement auth-int\n        HA2 = digest(A2)\n\n        nc_value = b\"%08x\" % self._nonce_count\n        cnonce = self._get_client_nonce(self._nonce_count, challenge.nonce)\n        self._nonce_count += 1\n\n        HA1 = digest(A1)\n        if challenge.algorithm.lower().endswith(\"-sess\"):\n            HA1 = digest(b\":\".join((HA1, challenge.nonce, cnonce)))\n\n        qop = self._resolve_qop(challenge.qop, request=request)\n        if qop is None:\n            # Following RFC 2069\n            digest_data = [HA1, challenge.nonce, HA2]\n        else:\n            # Following RFC 2617/7616\n            digest_data = [HA1, challenge.nonce, nc_value, cnonce, qop, HA2]\n\n        format_args = {\n            \"username\": self._username,\n            \"realm\": challenge.realm,\n            \"nonce\": challenge.nonce,\n            \"uri\": path,\n            \"response\": digest(b\":\".join(digest_data)),\n            \"algorithm\": challenge.algorithm.encode(),\n        }\n        if challenge.opaque:\n            format_args[\"opaque\"] = challenge.opaque\n        if qop:\n            format_args[\"qop\"] = b\"auth\"\n            format_args[\"nc\"] = nc_value\n            format_args[\"cnonce\"] = cnonce\n\n        return \"Digest \" + self._get_header_value(format_args)",
    "function_name": "_build_auth_header",
    "file": "httpx/_auth.py",
    "num_lines": 47
  },
  {
    "query": "what function handles test param with space?",
    "code": "def test_param_with_space():\n    # Params passed as form key-value pairs should be form escaped,\n    # Including the special case of \"+\" for space seperators.\n    url = httpx.URL(\"http://webservice\", params={\"u\": \"with spaces\"})\n    assert str(url) == \"http://webservice?u=with+spaces\"",
    "function_name": "test_param_with_space",
    "file": "tests/models/test_url.py",
    "num_lines": 5
  },
  {
    "query": "code to decode",
    "code": "    def decode(self, content: bytes) -> list[bytes]:\n        if self._chunk_size is None:\n            return [content] if content else []\n\n        self._buffer.write(content)\n        if self._buffer.tell() >= self._chunk_size:\n            value = self._buffer.getvalue()\n            chunks = [\n                value[i : i + self._chunk_size]\n                for i in range(0, len(value), self._chunk_size)\n            ]\n            if len(chunks[-1]) == self._chunk_size:\n                self._buffer.seek(0)\n                self._buffer.truncate()\n                return chunks\n            else:\n                self._buffer.seek(0)\n                self._buffer.write(chunks[-1])\n                self._buffer.truncate()\n                return chunks[:-1]\n        else:\n            return []",
    "function_name": "decode",
    "file": "httpx/_decoders.py",
    "num_lines": 22
  },
  {
    "query": "cookies test python",
    "code": "def test_cookies():\n    cookies = httpx.Cookies({\"name\": \"value\"})\n    assert cookies[\"name\"] == \"value\"\n    assert \"name\" in cookies\n    assert len(cookies) == 1\n    assert dict(cookies) == {\"name\": \"value\"}\n    assert bool(cookies) is True\n\n    del cookies[\"name\"]\n    assert \"name\" not in cookies\n    assert len(cookies) == 0\n    assert dict(cookies) == {}\n    assert bool(cookies) is False",
    "function_name": "test_cookies",
    "file": "tests/models/test_cookies.py",
    "num_lines": 13
  },
  {
    "query": "show me how to test url non printing character in component",
    "code": "def test_url_non_printing_character_in_component():\n    with pytest.raises(httpx.InvalidURL) as exc:\n        httpx.URL(\"https://www.example.com\", path=\"/\\n\")\n    assert str(exc.value) == (\n        \"Invalid non-printable ASCII character in URL path component, \"\n        \"'\\\\n' at position 1.\"\n    )",
    "function_name": "test_url_non_printing_character_in_component",
    "file": "tests/models/test_url.py",
    "num_lines": 7
  },
  {
    "query": "function that takes chunk_size: int | None",
    "code": "    async def aiter_text(\n        self, chunk_size: int | None = None\n    ) -> typing.AsyncIterator[str]:\n        \"\"\"\n        A str-iterator over the decoded response content\n        that handles both gzip, deflate, etc but also detects the content's\n        string encoding.\n        \"\"\"\n        decoder = TextDecoder(encoding=self.encoding or \"utf-8\")\n        chunker = TextChunker(chunk_size=chunk_size)\n        with request_context(request=self._request):\n            async for byte_content in self.aiter_bytes():\n                text_content = decoder.decode(byte_content)\n                for chunk in chunker.decode(text_content):\n                    yield chunk\n            text_content = decoder.flush()\n            for chunk in chunker.decode(text_content):\n                yield chunk  # pragma: no cover\n            for chunk in chunker.flush():\n                yield chunk",
    "function_name": "aiter_text",
    "file": "httpx/_models.py",
    "num_lines": 20
  },
  {
    "query": "I need to test read and stream data",
    "code": "def test_read_and_stream_data():\n    # Ensure a request may still be streamed if it has been read.\n    # Needed for cases such as authentication classes that read the request body.\n    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n    request.read()\n    assert request.stream is not None\n    assert isinstance(request.stream, typing.Iterable)\n    content = b\"\".join(list(request.stream))\n    assert content == request.content",
    "function_name": "test_read_and_stream_data",
    "file": "tests/models/test_requests.py",
    "num_lines": 9
  },
  {
    "query": "test cookies",
    "code": "def test_cookies():\n    cookies = httpx.Cookies({\"name\": \"value\"})\n    assert cookies[\"name\"] == \"value\"\n    assert \"name\" in cookies\n    assert len(cookies) == 1\n    assert dict(cookies) == {\"name\": \"value\"}\n    assert bool(cookies) is True\n\n    del cookies[\"name\"]\n    assert \"name\" not in cookies\n    assert len(cookies) == 0\n    assert dict(cookies) == {}\n    assert bool(cookies) is False",
    "function_name": "test_cookies",
    "file": "tests/models/test_cookies.py",
    "num_lines": 13
  },
  {
    "query": "with domain test",
    "code": "def test_cookies_with_domain():\n    cookies = httpx.Cookies()\n    cookies.set(\"name\", \"value\", domain=\"example.com\")\n    cookies.set(\"name\", \"value\", domain=\"example.org\")\n\n    with pytest.raises(httpx.CookieConflict):\n        cookies[\"name\"]\n\n    cookies.clear(domain=\"example.com\")\n    assert len(cookies) == 1",
    "function_name": "test_cookies_with_domain",
    "file": "tests/models/test_cookies.py",
    "num_lines": 10
  },
  {
    "query": "aiter test bytes",
    "code": "async def test_aiter_bytes():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = b\"\"\n    async for part in response.aiter_bytes():\n        content += part\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiter_bytes",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "aiter chunk size none",
    "code": "    async def aiter_text(\n        self, chunk_size: int | None = None\n    ) -> typing.AsyncIterator[str]:\n        \"\"\"\n        A str-iterator over the decoded response content\n        that handles both gzip, deflate, etc but also detects the content's\n        string encoding.\n        \"\"\"\n        decoder = TextDecoder(encoding=self.encoding or \"utf-8\")\n        chunker = TextChunker(chunk_size=chunk_size)\n        with request_context(request=self._request):\n            async for byte_content in self.aiter_bytes():\n                text_content = decoder.decode(byte_content)\n                for chunk in chunker.decode(text_content):\n                    yield chunk\n            text_content = decoder.flush()\n            for chunk in chunker.decode(text_content):\n                yield chunk  # pragma: no cover\n            for chunk in chunker.flush():\n                yield chunk",
    "function_name": "aiter_text",
    "file": "httpx/_models.py",
    "num_lines": 20
  },
  {
    "query": "same test domain",
    "code": "def test_same_domain_redirect():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    url = \"https://example.org/cross_domain\"\n    headers = {\"Authorization\": \"abc\"}\n    response = client.get(url, headers=headers, follow_redirects=True)\n    assert response.url == \"https://example.org/cross_domain_target\"\n    assert response.json()[\"headers\"][\"authorization\"] == \"abc\"",
    "function_name": "test_same_domain_redirect",
    "file": "tests/client/test_redirects.py",
    "num_lines": 7
  },
  {
    "query": "how to test aiterator content",
    "code": "async def test_aiterator_content():\n    async def hello_world() -> typing.AsyncIterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"world!\"\n\n    request = httpx.Request(method, url, content=hello_world())\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"\n\n    with pytest.raises(httpx.StreamConsumed):\n        [part async for part in request.stream]\n\n    # Support 'data' for compat with requests.\n    with pytest.warns(DeprecationWarning):\n        request = httpx.Request(method, url, data=hello_world())  # type: ignore\n    assert not isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiterator_content",
    "file": "tests/test_content.py",
    "num_lines": 33
  },
  {
    "query": "test credentials exist httpx",
    "code": "def test_netrc_auth_credentials_do_not_exist() -> None:\n    \"\"\"\n    When netrc auth is being used and a request is made to a host that is\n    not in the netrc file, then no credentials should be applied.\n    \"\"\"\n    netrc_file = str(FIXTURES_DIR / \".netrc\")\n    url = \"http://example.org\"\n    app = App()\n    auth = httpx.NetRCAuth(netrc_file)\n\n    with httpx.Client(transport=httpx.MockTransport(app), auth=auth) as client:\n        response = client.get(url)\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": None}",
    "function_name": "test_netrc_auth_credentials_do_not_exist",
    "file": "tests/client/test_auth.py",
    "num_lines": 15
  },
  {
    "query": "function that takes content: bytes",
    "code": "    def decode(self, content: bytes) -> list[bytes]:\n        if self._chunk_size is None:\n            return [content] if content else []\n\n        self._buffer.write(content)\n        if self._buffer.tell() >= self._chunk_size:\n            value = self._buffer.getvalue()\n            chunks = [\n                value[i : i + self._chunk_size]\n                for i in range(0, len(value), self._chunk_size)\n            ]\n            if len(chunks[-1]) == self._chunk_size:\n                self._buffer.seek(0)\n                self._buffer.truncate()\n                return chunks\n            else:\n                self._buffer.seek(0)\n                self._buffer.write(chunks[-1])\n                self._buffer.truncate()\n                return chunks[:-1]\n        else:\n            return []",
    "function_name": "decode",
    "file": "httpx/_decoders.py",
    "num_lines": 22
  },
  {
    "query": "gets proxy information from the environment",
    "code": "def get_environment_proxies() -> dict[str, str | None]:\n    \"\"\"Gets proxy information from the environment\"\"\"\n\n    # urllib.request.getproxies() falls back on System\n    # Registry and Config for proxies on Windows and macOS.\n    # We don't want to propagate non-HTTP proxies into\n    # our configuration such as 'TRAVIS_APT_PROXY'.\n    proxy_info = getproxies()\n    mounts: dict[str, str | None] = {}\n\n    for scheme in (\"http\", \"https\", \"all\"):\n        if proxy_info.get(scheme):\n            hostname = proxy_info[scheme]\n            mounts[f\"{scheme}://\"] = (\n                hostname if \"://\" in hostname else f\"http://{hostname}\"\n            )\n\n    no_proxy_hosts = [host.strip() for host in proxy_info.get(\"no\", \"\").split(\",\")]\n    for hostname in no_proxy_hosts:\n        # See https://curl.haxx.se/libcurl/c/CURLOPT_NOPROXY.html for details\n        # on how names in `NO_PROXY` are handled.\n        if hostname == \"*\":\n            # If NO_PROXY=* is used or if \"*\" occurs as any one of the comma\n            # separated hostnames, then we should just bypass any information\n            # from HTTP_PROXY, HTTPS_PROXY, ALL_PROXY, and always ignore\n            # proxies.\n            return {}\n        elif hostname:\n            # NO_PROXY=.google.com is marked as \"all://*.google.com,\n            #   which disables \"www.google.com\" but not \"google.com\"\n            # NO_PROXY=google.com is marked as \"all://*google.com,\n            #   which disables \"www.google.com\" and \"google.com\".\n            #   (But not \"wwwgoogle.com\")\n            # NO_PROXY can include domains, IPv6, IPv4 addresses and \"localhost\"\n            #   NO_PROXY=example.com,::1,localhost,192.168.0.0/16\n            if \"://\" in hostname:\n                mounts[hostname] = None\n            elif is_ipv4_hostname(hostname):\n                mounts[f\"all://{hostname}\"] = None\n            elif is_ipv6_hostname(hostname):\n                mounts[f\"all://[{hostname}]\"] = None\n            elif hostname.lower() == \"localhost\":\n                mounts[f\"all://{hostname}\"] = None\n            else:\n                mounts[f\"all://*{hostname}\"] = None\n\n    return mounts",
    "function_name": "get_environment_proxies",
    "file": "httpx/_utils.py",
    "num_lines": 47
  },
  {
    "query": "coerce a primitive data type into a string value",
    "code": "def primitive_value_to_str(value: PrimitiveData) -> str:\n    \"\"\"\n    Coerce a primitive data type into a string value.\n\n    Note that we prefer JSON-style 'true'/'false' for boolean values here.\n    \"\"\"\n    if value is True:\n        return \"true\"\n    elif value is False:\n        return \"false\"\n    elif value is None:\n        return \"\"\n    return str(value)",
    "function_name": "primitive_value_to_str",
    "file": "httpx/_utils.py",
    "num_lines": 13
  },
  {
    "query": "function that test client trust env",
    "code": "def test_client_trust_env():\n    client = httpx.Client()\n    assert client.trust_env\n\n    client = httpx.Client(trust_env=False)\n    assert not client.trust_env",
    "function_name": "test_client_trust_env",
    "file": "tests/client/test_properties.py",
    "num_lines": 6
  },
  {
    "query": "function that takes data: RequestData and files: RequestFiles",
    "code": "def encode_multipart_data(\n    data: RequestData, files: RequestFiles, boundary: bytes | None\n) -> tuple[dict[str, str], MultipartStream]:\n    multipart = MultipartStream(data=data, files=files, boundary=boundary)\n    headers = multipart.get_headers()\n    return headers, multipart",
    "function_name": "encode_multipart_data",
    "file": "httpx/_content.py",
    "num_lines": 6
  },
  {
    "query": "test client event hooks in tests client test properties",
    "code": "def test_client_event_hooks():\n    def on_request(request):\n        pass  # pragma: no cover\n\n    client = httpx.Client()\n    client.event_hooks = {\"request\": [on_request]}\n    assert client.event_hooks == {\"request\": [on_request], \"response\": []}",
    "function_name": "test_client_event_hooks",
    "file": "tests/client/test_properties.py",
    "num_lines": 7
  },
  {
    "query": "looking for the code that test request async streaming content picklable",
    "code": "async def test_request_async_streaming_content_picklable():\n    async def streaming_body(data: bytes) -> typing.AsyncIterator[bytes]:\n        yield data\n\n    data = streaming_body(b\"test 123\")\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n    pickle_request = pickle.loads(pickle.dumps(request))\n    with pytest.raises(httpx.RequestNotRead):\n        pickle_request.content  # noqa: B018\n    with pytest.raises(httpx.StreamClosed):\n        await pickle_request.aread()\n\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n    await request.aread()\n    pickle_request = pickle.loads(pickle.dumps(request))\n    assert pickle_request.content == b\"test 123\"",
    "function_name": "test_request_async_streaming_content_picklable",
    "file": "tests/models/test_requests.py",
    "num_lines": 16
  },
  {
    "query": "from raw test",
    "code": "def test_ipv6_url_from_raw_url(host):\n    url = httpx.URL(scheme=\"https\", host=host, port=443, path=\"/\")\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]\"\n    assert str(url) == \"https://[::ffff:192.168.0.1]/\"",
    "function_name": "test_ipv6_url_from_raw_url",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "request params test python",
    "code": "def test_request_params():\n    request = httpx.Request(\"GET\", \"http://example.com\", params={})\n    assert str(request.url) == \"http://example.com\"\n\n    request = httpx.Request(\n        \"GET\", \"http://example.com?c=3\", params={\"a\": \"1\", \"b\": \"2\"}\n    )\n    assert str(request.url) == \"http://example.com?a=1&b=2\"\n\n    request = httpx.Request(\"GET\", \"http://example.com?a=1\", params={})\n    assert str(request.url) == \"http://example.com\"",
    "function_name": "test_request_params",
    "file": "tests/models/test_requests.py",
    "num_lines": 11
  },
  {
    "query": "handle request in httpx  transports default",
    "code": "    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n        import httpcore\n\n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n            resp = self._pool.handle_request(req)\n\n        assert isinstance(resp.stream, typing.Iterable)\n\n        return Response(\n            status_code=resp.status,\n            headers=resp.headers,\n            stream=ResponseStream(resp.stream),\n            extensions=resp.extensions,\n        )",
    "function_name": "handle_request",
    "file": "httpx/_transports/default.py",
    "num_lines": 30
  },
  {
    "query": "code to test line decoder crnl",
    "code": "def test_line_decoder_crnl():\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\\r\\n\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    response = httpx.Response(200, content=[b\"\", b\"a\\r\", b\"\\n\\r\\nb\\r\\nc\"])\n    assert list(response.iter_lines()) == [\"a\", \"\", \"b\", \"c\"]\n\n    # Issue #1033\n    response = httpx.Response(200, content=[b\"\", b\"12345\\r\\n\", b\"foo bar baz\\r\\n\"])\n    assert list(response.iter_lines()) == [\"12345\", \"foo bar baz\"]",
    "function_name": "test_line_decoder_crnl",
    "file": "tests/test_decoders.py",
    "num_lines": 13
  },
  {
    "query": "how does httpx test pool timeout?",
    "code": "async def test_pool_timeout(server):\n    limits = httpx.Limits(max_connections=1)\n    timeout = httpx.Timeout(None, pool=1e-4)\n\n    async with httpx.AsyncClient(limits=limits, timeout=timeout) as client:\n        with pytest.raises(httpx.PoolTimeout):\n            async with client.stream(\"GET\", server.url):\n                await client.get(server.url)",
    "function_name": "test_pool_timeout",
    "file": "tests/test_timeouts.py",
    "num_lines": 8
  },
  {
    "query": "function that takes url: URL | str",
    "code": "def get(\n    url: URL | str,\n    *,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `GET` request.\n\n    **Parameters**: See `httpx.request`.\n\n    Note that the `data`, `files`, `json` and `content` parameters are not available\n    on this function, as `GET` requests should not include a request body.\n    \"\"\"\n    return request(\n        \"GET\",\n        url,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "get",
    "file": "httpx/_api.py",
    "num_lines": 34
  },
  {
    "query": "test multipart file tuple in tests test multipart",
    "code": "def test_multipart_file_tuple():\n    client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n\n    # Test with a list of values 'data' argument,\n    #     and a tuple style 'files' argument.\n    data = {\"text\": [\"abc\"]}\n    files = {\"file\": (\"name.txt\", io.BytesIO(b\"<file content>\"))}\n    response = client.post(\"http://127.0.0.1:8000/\", data=data, files=files)\n    boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n    boundary_bytes = boundary.encode(\"ascii\")\n\n    assert response.status_code == 200\n    assert response.content == b\"\".join(\n        [\n            b\"--\" + boundary_bytes + b\"\\r\\n\",\n            b'Content-Disposition: form-data; name=\"text\"\\r\\n',\n            b\"\\r\\n\",\n            b\"abc\\r\\n\",\n            b\"--\" + boundary_bytes + b\"\\r\\n\",\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"name.txt\"\\r\\n',\n            b\"Content-Type: text/plain\\r\\n\",\n            b\"\\r\\n\",\n            b\"<file content>\\r\\n\",\n            b\"--\" + boundary_bytes + b\"--\\r\\n\",\n        ]\n    )",
    "function_name": "test_multipart_file_tuple",
    "file": "tests/test_multipart.py",
    "num_lines": 26
  },
  {
    "query": "function that takes content_type: bytes | None",
    "code": "def get_multipart_boundary_from_content_type(\n    content_type: bytes | None,\n) -> bytes | None:\n    if not content_type or not content_type.startswith(b\"multipart/form-data\"):\n        return None\n    # parse boundary according to\n    # https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n    if b\";\" in content_type:\n        for section in content_type.split(b\";\"):\n            if section.strip().lower().startswith(b\"boundary=\"):\n                return section.strip()[len(b\"boundary=\") :].strip(b'\"')\n    return None",
    "function_name": "get_multipart_boundary_from_content_type",
    "file": "httpx/_multipart.py",
    "num_lines": 12
  },
  {
    "query": "raise asgi test",
    "code": "async def test_asgi_exc_no_raise():\n    transport = httpx.ASGITransport(app=raise_exc, raise_app_exceptions=False)\n    async with httpx.AsyncClient(transport=transport) as client:\n        response = await client.get(\"http://www.example.org/\")\n\n        assert response.status_code == 500",
    "function_name": "test_asgi_exc_no_raise",
    "file": "tests/test_asgi.py",
    "num_lines": 6
  },
  {
    "query": "start response in httpx  transports wsgi",
    "code": "        def start_response(\n            status: str,\n            response_headers: list[tuple[str, str]],\n            exc_info: OptExcInfo | None = None,\n        ) -> typing.Callable[[bytes], typing.Any]:\n            nonlocal seen_status, seen_response_headers, seen_exc_info\n            seen_status = status\n            seen_response_headers = response_headers\n            seen_exc_info = exc_info\n            return lambda _: None",
    "function_name": "start_response",
    "file": "httpx/_transports/wsgi.py",
    "num_lines": 10
  },
  {
    "query": "async test exception",
    "code": "async def test_async_event_hooks_raising_exception():\n    async def raise_on_4xx_5xx(response):\n        response.raise_for_status()\n\n    event_hooks = {\"response\": [raise_on_4xx_5xx]}\n\n    async with httpx.AsyncClient(\n        event_hooks=event_hooks, transport=httpx.MockTransport(app)\n    ) as http:\n        try:\n            await http.get(\"http://127.0.0.1:8000/status/400\")\n        except httpx.HTTPStatusError as exc:\n            assert exc.response.is_closed",
    "function_name": "test_async_event_hooks_raising_exception",
    "file": "tests/client/test_event_hooks.py",
    "num_lines": 13
  },
  {
    "query": "content override test",
    "code": "def test_override_content_length_header():\n    async def streaming_body(data: bytes) -> typing.AsyncIterator[bytes]:\n        yield data  # pragma: no cover\n\n    data = streaming_body(b\"test 123\")\n    headers = {\"Content-Length\": \"8\"}\n\n    request = httpx.Request(\"POST\", \"http://example.org\", content=data, headers=headers)\n    assert request.headers[\"Content-Length\"] == \"8\"",
    "function_name": "test_override_content_length_header",
    "file": "tests/models/test_requests.py",
    "num_lines": 9
  },
  {
    "query": "test aiter bytes in tests models test responses",
    "code": "async def test_aiter_bytes():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = b\"\"\n    async for part in response.aiter_bytes():\n        content += part\n    assert content == b\"Hello, world!\"",
    "function_name": "test_aiter_bytes",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "serve in tests conftest",
    "code": "    async def serve(self, sockets=None):\n        self.restart_requested = asyncio.Event()\n\n        loop = asyncio.get_event_loop()\n        tasks = {\n            loop.create_task(super().serve(sockets=sockets)),\n            loop.create_task(self.watch_restarts()),\n        }\n        await asyncio.wait(tasks)",
    "function_name": "serve",
    "file": "tests/conftest.py",
    "num_lines": 9
  },
  {
    "query": "test url non printing character in component in tests models test url",
    "code": "def test_url_non_printing_character_in_component():\n    with pytest.raises(httpx.InvalidURL) as exc:\n        httpx.URL(\"https://www.example.com\", path=\"/\\n\")\n    assert str(exc.value) == (\n        \"Invalid non-printable ASCII character in URL path component, \"\n        \"'\\\\n' at position 1.\"\n    )",
    "function_name": "test_url_non_printing_character_in_component",
    "file": "tests/models/test_url.py",
    "num_lines": 7
  },
  {
    "query": "function that test iter bytes doesnt return empty chunks",
    "code": "def test_iter_bytes_doesnt_return_empty_chunks():\n    def streaming_body_with_empty_chunks() -> typing.Iterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"\"\n        yield b\"world!\"\n        yield b\"\"\n\n    response = httpx.Response(200, content=streaming_body_with_empty_chunks())\n\n    parts = list(response.iter_bytes())\n    assert parts == [b\"Hello, \", b\"world!\"]",
    "function_name": "test_iter_bytes_doesnt_return_empty_chunks",
    "file": "tests/models/test_responses.py",
    "num_lines": 11
  },
  {
    "query": "how to see: https://github.com/encode/httpx/pull/1312",
    "code": "async def test_basic_auth_with_stream() -> None:\n    \"\"\"\n    See: https://github.com/encode/httpx/pull/1312\n    \"\"\"\n    url = \"https://example.org/\"\n    auth = (\"user\", \"password123\")\n    app = App()\n\n    async with httpx.AsyncClient(\n        transport=httpx.MockTransport(app), auth=auth\n    ) as client:\n        async with client.stream(\"GET\", url) as response:\n            await response.aread()\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": \"Basic dXNlcjpwYXNzd29yZDEyMw==\"}",
    "function_name": "test_basic_auth_with_stream",
    "file": "tests/client/test_auth.py",
    "num_lines": 16
  },
  {
    "query": "raw path in httpx  urls",
    "code": "    def raw_path(self) -> bytes:\n        \"\"\"\n        The complete URL path and query string as raw bytes.\n        Used as the target when constructing HTTP requests.\n\n        For example:\n\n        GET /users?search=some%20text HTTP/1.1\n        Host: www.example.org\n        Connection: close\n        \"\"\"\n        path = self._uri_reference.path or \"/\"\n        if self._uri_reference.query is not None:\n            path += \"?\" + self._uri_reference.query\n        return path.encode(\"ascii\")",
    "function_name": "raw_path",
    "file": "httpx/_urls.py",
    "num_lines": 15
  },
  {
    "query": "test request picklable in tests models test requests",
    "code": "def test_request_picklable():\n    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n    pickle_request = pickle.loads(pickle.dumps(request))\n    assert pickle_request.method == \"POST\"\n    assert pickle_request.url.path == \"/\"\n    assert pickle_request.headers[\"Content-Type\"] == \"application/json\"\n    assert pickle_request.content == b'{\"test\":123}'\n    assert pickle_request.stream is not None\n    assert request.headers == {\n        \"Host\": \"example.org\",\n        \"Content-Type\": \"application/json\",\n        \"content-length\": \"12\",\n    }",
    "function_name": "test_request_picklable",
    "file": "tests/models/test_requests.py",
    "num_lines": 13
  },
  {
    "query": "function that takes server",
    "code": "def test_stream_iterator(server):\n    body = b\"\"\n\n    with httpx.Client() as client:\n        with client.stream(\"GET\", server.url) as response:\n            for chunk in response.iter_bytes():\n                body += chunk\n\n    assert response.status_code == 200\n    assert body == b\"Hello, world!\"",
    "function_name": "test_stream_iterator",
    "file": "tests/client/test_client.py",
    "num_lines": 10
  },
  {
    "query": "test ipv6 url copy with host in tests models test url",
    "code": "def test_ipv6_url_copy_with_host(url_str, new_host):\n    url = httpx.URL(url_str).copy_with(host=new_host)\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]:1234\"\n    assert str(url) == \"http://[::ffff:192.168.0.1]:1234\"",
    "function_name": "test_ipv6_url_copy_with_host",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "how to some basic url query parameter manipulation",
    "code": "def test_url_remove_param_manipulation():\n    \"\"\"\n    Some basic URL query parameter manipulation.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/?a=123\")\n    assert url.copy_remove_param(\"a\") == \"https://example.org:123/\"",
    "function_name": "test_url_remove_param_manipulation",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "how to test url copywith userinfo subcomponents using httpx?",
    "code": "def test_url_copywith_userinfo_subcomponents():\n    copy_with_kwargs = {\n        \"username\": \"tom@example.org\",\n        \"password\": \"abc123@ %\",\n    }\n    url = httpx.URL(\"https://example.org\")\n    new = url.copy_with(**copy_with_kwargs)\n    assert str(new) == \"https://tom%40example.org:abc123%40%20%@example.org\"\n    assert new.username == \"tom@example.org\"\n    assert new.password == \"abc123@ %\"\n    assert new.userinfo == b\"tom%40example.org:abc123%40%20%\"",
    "function_name": "test_url_copywith_userinfo_subcomponents",
    "file": "tests/models/test_url.py",
    "num_lines": 11
  },
  {
    "query": "how does httpx test empty request?",
    "code": "async def test_empty_request():\n    request = httpx.Request(method, url, data={}, files={})\n    assert isinstance(request.stream, typing.Iterable)\n    assert isinstance(request.stream, typing.AsyncIterable)\n\n    sync_content = b\"\".join(list(request.stream))\n    async_content = b\"\".join([part async for part in request.stream])\n\n    assert request.headers == {\"Host\": \"www.example.com\", \"Content-Length\": \"0\"}\n    assert sync_content == b\"\"\n    assert async_content == b\"\"",
    "function_name": "test_empty_request",
    "file": "tests/test_content.py",
    "num_lines": 11
  },
  {
    "query": "test aiter raw httpx",
    "code": "async def test_aiter_raw():\n    response = httpx.Response(200, content=async_streaming_body())\n\n    raw = b\"\"\n    async for part in response.aiter_raw():\n        raw += part\n    assert raw == b\"Hello, world!\"",
    "function_name": "test_aiter_raw",
    "file": "tests/models/test_responses.py",
    "num_lines": 7
  },
  {
    "query": "client env test",
    "code": "def test_client_trust_env():\n    client = httpx.Client()\n    assert client.trust_env\n\n    client = httpx.Client(trust_env=False)\n    assert not client.trust_env",
    "function_name": "test_client_trust_env",
    "file": "tests/client/test_properties.py",
    "num_lines": 6
  },
  {
    "query": "copy this url, returning a new url with some components altered",
    "code": "    def copy_with(self, **kwargs: typing.Any) -> URL:\n        \"\"\"\n        Copy this URL, returning a new URL with some components altered.\n        Accepts the same set of parameters as the components that are made\n        available via properties on the `URL` class.\n\n        For example:\n\n        url = httpx.URL(\"https://www.example.com\").copy_with(\n            username=\"jo@gmail.com\", password=\"a secret\"\n        )\n        assert url == \"https://jo%40email.com:a%20secret@www.example.com\"\n        \"\"\"\n        return URL(self, **kwargs)",
    "function_name": "copy_with",
    "file": "httpx/_urls.py",
    "num_lines": 14
  },
  {
    "query": "test response server",
    "code": "def test_stream_response(server):\n    with httpx.Client() as client:\n        with client.stream(\"GET\", server.url) as response:\n            content = response.read()\n    assert response.status_code == 200\n    assert content == b\"Hello, world!\"",
    "function_name": "test_stream_response",
    "file": "tests/client/test_client.py",
    "num_lines": 6
  },
  {
    "query": "code to test load ssl config verify existing file",
    "code": "def test_load_ssl_config_verify_existing_file():\n    context = httpx.create_ssl_context()\n    context.load_verify_locations(capath=certifi.where())\n    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n    assert context.check_hostname is True",
    "function_name": "test_load_ssl_config_verify_existing_file",
    "file": "tests/test_config.py",
    "num_lines": 5
  },
  {
    "query": "info email.message.message",
    "code": "        def info(self) -> email.message.Message:\n            info = email.message.Message()\n            for key, value in self.response.headers.multi_items():\n                # Note that setting `info[key]` here is an \"append\" operation,\n                # not a \"replace\" operation.\n                # https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.__setitem__\n                info[key] = value\n            return info",
    "function_name": "info",
    "file": "httpx/_models.py",
    "num_lines": 8
  },
  {
    "query": "unicode file none",
    "code": "def test_multipart_encode_unicode_file_contents() -> None:\n    url = \"https://www.example.com/\"\n    headers = {\"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\"}\n    files = {\"file\": (\"name.txt\", b\"<bytes content>\")}\n\n    request = httpx.Request(\"POST\", url, headers=headers, files=files)\n    request.read()\n\n    assert request.headers == {\n        \"Host\": \"www.example.com\",\n        \"Content-Type\": \"multipart/form-data; boundary=BOUNDARY\",\n        \"Content-Length\": str(len(request.content)),\n    }\n    assert request.content == (\n        b'--BOUNDARY\\r\\nContent-Disposition: form-data; name=\"file\";'\n        b' filename=\"name.txt\"\\r\\n'\n        b\"Content-Type: text/plain\\r\\n\\r\\n<bytes content>\\r\\n\"\n        b\"--BOUNDARY--\\r\\n\"\n    )",
    "function_name": "test_multipart_encode_unicode_file_contents",
    "file": "tests/test_multipart.py",
    "num_lines": 19
  },
  {
    "query": "test iter bytes doesnt return empty chunks in tests models test responses",
    "code": "def test_iter_bytes_doesnt_return_empty_chunks():\n    def streaming_body_with_empty_chunks() -> typing.Iterator[bytes]:\n        yield b\"Hello, \"\n        yield b\"\"\n        yield b\"world!\"\n        yield b\"\"\n\n    response = httpx.Response(200, content=streaming_body_with_empty_chunks())\n\n    parts = list(response.iter_bytes())\n    assert parts == [b\"Hello, \", b\"world!\"]",
    "function_name": "test_iter_bytes_doesnt_return_empty_chunks",
    "file": "tests/models/test_responses.py",
    "num_lines": 11
  },
  {
    "query": "see: https://github.com/encode/httpx/pull/1312",
    "code": "async def test_basic_auth_with_stream() -> None:\n    \"\"\"\n    See: https://github.com/encode/httpx/pull/1312\n    \"\"\"\n    url = \"https://example.org/\"\n    auth = (\"user\", \"password123\")\n    app = App()\n\n    async with httpx.AsyncClient(\n        transport=httpx.MockTransport(app), auth=auth\n    ) as client:\n        async with client.stream(\"GET\", url) as response:\n            await response.aread()\n\n    assert response.status_code == 200\n    assert response.json() == {\"auth\": \"Basic dXNlcjpwYXNzd29yZDEyMw==\"}",
    "function_name": "test_basic_auth_with_stream",
    "file": "tests/client/test_auth.py",
    "num_lines": 16
  },
  {
    "query": "test redirect 302 in tests client test redirects",
    "code": "def test_redirect_302():\n    client = httpx.Client(transport=httpx.MockTransport(redirects))\n    response = client.post(\"https://example.org/redirect_302\", follow_redirects=True)\n    assert response.status_code == httpx.codes.OK\n    assert response.url == \"https://example.org/\"\n    assert len(response.history) == 1",
    "function_name": "test_redirect_302",
    "file": "tests/client/test_redirects.py",
    "num_lines": 6
  },
  {
    "query": "how to some basic url query parameter manipulation",
    "code": "def test_url_set_param_manipulation():\n    \"\"\"\n    Some basic URL query parameter manipulation.\n    \"\"\"\n    url = httpx.URL(\"https://example.org:123/?a=123\")\n    assert url.copy_set_param(\"a\", \"456\") == \"https://example.org:123/?a=456\"",
    "function_name": "test_url_set_param_manipulation",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "list flush str",
    "code": "    def flush(self) -> list[str]:\n        value = self._buffer.getvalue()\n        self._buffer.seek(0)\n        self._buffer.truncate()\n        return [value] if value else []",
    "function_name": "flush",
    "file": "httpx/_decoders.py",
    "num_lines": 5
  },
  {
    "query": "where is the ipv4 hostname logic?",
    "code": "def is_ipv4_hostname(hostname: str) -> bool:\n    try:\n        ipaddress.IPv4Address(hostname.split(\"/\")[0])\n    except Exception:\n        return False\n    return True",
    "function_name": "is_ipv4_hostname",
    "file": "httpx/_utils.py",
    "num_lines": 6
  },
  {
    "query": "test zstd",
    "code": "def test_zstd():\n    body = b\"test 123\"\n    compressed_body = zstd.compress(body)\n\n    headers = [(b\"Content-Encoding\", b\"zstd\")]\n    response = httpx.Response(\n        200,\n        headers=headers,\n        content=compressed_body,\n    )\n    assert response.content == body",
    "function_name": "test_zstd",
    "file": "tests/test_decoders.py",
    "num_lines": 11
  },
  {
    "query": "read in httpx  models",
    "code": "    def read(self) -> bytes:\n        \"\"\"\n        Read and return the request content.\n        \"\"\"\n        if not hasattr(self, \"_content\"):\n            assert isinstance(self.stream, typing.Iterable)\n            self._content = b\"\".join(self.stream)\n            if not isinstance(self.stream, ByteStream):\n                # If a streaming request has been read entirely into memory, then\n                # we can replace the stream with a raw bytes implementation,\n                # to ensure that any non-replayable streams can still be used.\n                self.stream = ByteStream(self._content)\n        return self._content",
    "function_name": "read",
    "file": "httpx/_models.py",
    "num_lines": 13
  },
  {
    "query": "request, flow none",
    "code": "    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n        if self._last_challenge:\n            request.headers[\"Authorization\"] = self._build_auth_header(\n                request, self._last_challenge\n            )\n\n        response = yield request\n\n        if response.status_code != 401 or \"www-authenticate\" not in response.headers:\n            # If the response is not a 401 then we don't\n            # need to build an authenticated request.\n            return\n\n        for auth_header in response.headers.get_list(\"www-authenticate\"):\n            if auth_header.lower().startswith(\"digest \"):\n                break\n        else:\n            # If the response does not include a 'WWW-Authenticate: Digest ...'\n            # header, then we don't need to build an authenticated request.\n            return\n\n        self._last_challenge = self._parse_challenge(request, response, auth_header)\n        self._nonce_count = 1\n\n        request.headers[\"Authorization\"] = self._build_auth_header(\n            request, self._last_challenge\n        )\n        if response.cookies:\n            Cookies(response.cookies).set_cookie_header(request=request)\n        yield request",
    "function_name": "auth_flow",
    "file": "httpx/_auth.py",
    "num_lines": 30
  },
  {
    "query": "function that takes server",
    "code": "def test_put(server):\n    with httpx.Client() as client:\n        response = client.put(server.url, content=b\"Hello, world!\")\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"",
    "function_name": "test_put",
    "file": "tests/client/test_client.py",
    "num_lines": 5
  },
  {
    "query": "test ipv6 url from raw url in tests models test url",
    "code": "def test_ipv6_url_from_raw_url(host):\n    url = httpx.URL(scheme=\"https\", host=host, port=443, path=\"/\")\n\n    assert url.host == \"::ffff:192.168.0.1\"\n    assert url.netloc == b\"[::ffff:192.168.0.1]\"\n    assert str(url) == \"https://[::ffff:192.168.0.1]/\"",
    "function_name": "test_ipv6_url_from_raw_url",
    "file": "tests/models/test_url.py",
    "num_lines": 6
  },
  {
    "query": "test aiter text in tests models test responses",
    "code": "async def test_aiter_text():\n    response = httpx.Response(\n        200,\n        content=b\"Hello, world!\",\n    )\n\n    content = \"\"\n    async for part in response.aiter_text():\n        content += part\n    assert content == \"Hello, world!\"",
    "function_name": "test_aiter_text",
    "file": "tests/models/test_responses.py",
    "num_lines": 10
  },
  {
    "query": "show me how to parse header links",
    "code": "def _parse_header_links(value: str) -> list[dict[str, str]]:\n    \"\"\"\n    Returns a list of parsed link headers, for more info see:\n    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link\n    The generic syntax of those is:\n    Link: < uri-reference >; param1=value1; param2=\"value2\"\n    So for instance:\n    Link; '<http:/.../front.jpeg>; type=\"image/jpeg\",<http://.../back.jpeg>;'\n    would return\n        [\n            {\"url\": \"http:/.../front.jpeg\", \"type\": \"image/jpeg\"},\n            {\"url\": \"http://.../back.jpeg\"},\n        ]\n    :param value: HTTP Link entity-header field\n    :return: list of parsed link headers\n    \"\"\"\n    links: list[dict[str, str]] = []\n    replace_chars = \" '\\\"\"\n    value = value.strip(replace_chars)\n    if not value:\n        return links\n    for val in re.split(\", *<\", value):\n        try:\n            url, params = val.split(\";\", 1)\n        except ValueError:\n            url, params = val, \"\"\n        link = {\"url\": url.strip(\"<> '\\\"\")}\n        for param in params.split(\";\"):\n            try:\n                key, value = param.split(\"=\")\n            except ValueError:\n                break\n            link[key.strip(replace_chars)] = value.strip(replace_chars)\n        links.append(link)\n    return links",
    "function_name": "_parse_header_links",
    "file": "httpx/_models.py",
    "num_lines": 35
  },
  {
    "query": "function that returns email.message.message",
    "code": "        def info(self) -> email.message.Message:\n            info = email.message.Message()\n            for key, value in self.response.headers.multi_items():\n                # Note that setting `info[key]` here is an \"append\" operation,\n                # not a \"replace\" operation.\n                # https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.__setitem__\n                info[key] = value\n            return info",
    "function_name": "info",
    "file": "httpx/_models.py",
    "num_lines": 8
  },
  {
    "query": "server put test",
    "code": "def test_put(server):\n    with httpx.Client() as client:\n        response = client.put(server.url, content=b\"Hello, world!\")\n    assert response.status_code == 200\n    assert response.reason_phrase == \"OK\"",
    "function_name": "test_put",
    "file": "tests/client/test_client.py",
    "num_lines": 5
  },
  {
    "query": "post in httpx  api",
    "code": "def post(\n    url: URL | str,\n    *,\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: typing.Any | None = None,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `POST` request.\n\n    **Parameters**: See `httpx.request`.\n    \"\"\"\n    return request(\n        \"POST\",\n        url,\n        content=content,\n        data=data,\n        files=files,\n        json=json,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "post",
    "file": "httpx/_api.py",
    "num_lines": 39
  },
  {
    "query": "auth digest 2069",
    "code": "def test_digest_auth_rfc_2069():\n    # Example from https://datatracker.ietf.org/doc/html/rfc2069#section-2.4\n    # with corrected response from https://www.rfc-editor.org/errata/eid749\n\n    auth = httpx.DigestAuth(username=\"Mufasa\", password=\"CircleOfLife\")\n    request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n\n    # The initial request should not include an auth header.\n    flow = auth.sync_auth_flow(request)\n    request = next(flow)\n    assert \"Authorization\" not in request.headers\n\n    # If a 401 response is returned, then a digest auth request is made.\n    headers = {\n        \"WWW-Authenticate\": (\n            'Digest realm=\"testrealm@host.com\", '\n            'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", '\n            'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'\n        )\n    }\n    response = httpx.Response(\n        content=b\"Auth required\", status_code=401, headers=headers, request=request\n    )\n    request = flow.send(response)\n    assert request.headers[\"Authorization\"].startswith(\"Digest\")\n    assert 'username=\"Mufasa\"' in request.headers[\"Authorization\"]\n    assert 'realm=\"testrealm@host.com\"' in request.headers[\"Authorization\"]\n    assert (\n        'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"' in request.headers[\"Authorization\"]\n    )\n    assert 'uri=\"/dir/index.html\"' in request.headers[\"Authorization\"]\n    assert (\n        'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"' in request.headers[\"Authorization\"]\n    )\n    assert (\n        'response=\"1949323746fe6a43ef61f9606e7febea\"'\n        in request.headers[\"Authorization\"]\n    )\n\n    # No other requests are made.\n    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n    with pytest.raises(StopIteration):\n        flow.send(response)",
    "function_name": "test_digest_auth_rfc_2069",
    "file": "tests/test_auth.py",
    "num_lines": 43
  },
  {
    "query": "encode request in httpx  content",
    "code": "def encode_request(\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: Any | None = None,\n    boundary: bytes | None = None,\n) -> tuple[dict[str, str], SyncByteStream | AsyncByteStream]:\n    \"\"\"\n    Handles encoding the given `content`, `data`, `files`, and `json`,\n    returning a two-tuple of (<headers>, <stream>).\n    \"\"\"\n    if data is not None and not isinstance(data, Mapping):\n        # We prefer to separate `content=<bytes|str|byte iterator|bytes aiterator>`\n        # for raw request content, and `data=<form data>` for url encoded or\n        # multipart form content.\n        #\n        # However for compat with requests, we *do* still support\n        # `data=<bytes...>` usages. We deal with that case here, treating it\n        # as if `content=<...>` had been supplied instead.\n        message = \"Use 'content=<...>' to upload raw bytes/text content.\"\n        warnings.warn(message, DeprecationWarning, stacklevel=2)\n        return encode_content(data)\n\n    if content is not None:\n        return encode_content(content)\n    elif files:\n        return encode_multipart_data(data or {}, files, boundary)\n    elif data:\n        return encode_urlencoded_data(data)\n    elif json is not None:\n        return encode_json(json)\n\n    return {}, ByteStream(b\"\")",
    "function_name": "encode_request",
    "file": "httpx/_content.py",
    "num_lines": 33
  },
  {
    "query": "function that returns url",
    "code": "    def copy_with(self, **kwargs: typing.Any) -> URL:\n        \"\"\"\n        Copy this URL, returning a new URL with some components altered.\n        Accepts the same set of parameters as the components that are made\n        available via properties on the `URL` class.\n\n        For example:\n\n        url = httpx.URL(\"https://www.example.com\").copy_with(\n            username=\"jo@gmail.com\", password=\"a secret\"\n        )\n        assert url == \"https://jo%40email.com:a%20secret@www.example.com\"\n        \"\"\"\n        return URL(self, **kwargs)",
    "function_name": "copy_with",
    "file": "httpx/_urls.py",
    "num_lines": 14
  },
  {
    "query": "test zstd truncated",
    "code": "def test_zstd_truncated():\n    body = b\"test 123\"\n    compressed_body = zstd.compress(body)\n\n    headers = [(b\"Content-Encoding\", b\"zstd\")]\n    with pytest.raises(httpx.DecodingError):\n        httpx.Response(\n            200,\n            headers=headers,\n            content=compressed_body[1:3],\n        )",
    "function_name": "test_zstd_truncated",
    "file": "tests/test_decoders.py",
    "num_lines": 11
  },
  {
    "query": "json server test",
    "code": "def test_json(server):\n    url = str(server.url.copy_with(path=\"/json\"))\n    runner = CliRunner()\n    result = runner.invoke(httpx.main, [url])\n    assert result.exit_code == 0\n    assert remove_date_header(splitlines(result.output)) == [\n        \"HTTP/1.1 200 OK\",\n        \"server: uvicorn\",\n        \"content-type: application/json\",\n        \"Transfer-Encoding: chunked\",\n        \"\",\n        \"{\",\n        '\"Hello\": \"world!\"',\n        \"}\",\n    ]",
    "function_name": "test_json",
    "file": "tests/test_main.py",
    "num_lines": 15
  },
  {
    "query": "find the function for error",
    "code": "    def is_error(self) -> bool:\n        \"\"\"\n        A property which is `True` for 4xx and 5xx status codes, `False` otherwise.\n        \"\"\"\n        return codes.is_error(self.status_code)",
    "function_name": "is_error",
    "file": "httpx/_models.py",
    "num_lines": 5
  },
  {
    "query": "function that takes url: URL | str",
    "code": "def post(\n    url: URL | str,\n    *,\n    content: RequestContent | None = None,\n    data: RequestData | None = None,\n    files: RequestFiles | None = None,\n    json: typing.Any | None = None,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | None = None,\n    proxy: ProxyTypes | None = None,\n    follow_redirects: bool = False,\n    verify: ssl.SSLContext | str | bool = True,\n    timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n    trust_env: bool = True,\n) -> Response:\n    \"\"\"\n    Sends a `POST` request.\n\n    **Parameters**: See `httpx.request`.\n    \"\"\"\n    return request(\n        \"POST\",\n        url,\n        content=content,\n        data=data,\n        files=files,\n        json=json,\n        params=params,\n        headers=headers,\n        cookies=cookies,\n        auth=auth,\n        proxy=proxy,\n        follow_redirects=follow_redirects,\n        verify=verify,\n        timeout=timeout,\n        trust_env=trust_env,\n    )",
    "function_name": "post",
    "file": "httpx/_api.py",
    "num_lines": 39
  }
]